myls.c
#include <stdio.h>
#include <sys/types.h>
#include <dirent.h>
#include <errno.h>

int main(int argc, char const *argv[])
{
	DIR * dp;
	struct dirent *dirp;
	if(argc != 2)
	{
		printf("need one dir\n");
		return -1;
	}

	if((dp = opendir(argv[1])) == NULL)/* 打开一个指定目录 */
	{
		perror("opendir error");
		return -1;
	}
	while((dirp = readdir(dp)) != NULL)/* 读出目录下所有目录及文件 */
		printf("%s\n", dirp->d_name);
	closedir(dp);
	return 0;
}

myread.c
#include <stdio.h>
#include <unistd.h>
#include <errno.h>

#define BUFFSIZE 4096

int main(int argc, char const *argv[])
{
	int n;
	int buff[BUFFSIZE] = {0};

	while((n = read(STDIN_FILENO, buff, BUFFSIZE)) > 0)/* 行缓冲，输入换行符才会真正读入 */
		if(write(STDOUT_FILENO, buff, n) != n)
			perror("write error");
	if(n < 0)
		printf("read error\n");

	return 0;
}

myget.c
#include <stdio.h>

int main(int argc, char const *argv[])
{
	int c;
	while((c = getc(stdin)) != EOF)
		if(putc(c, stdout) == EOF)
		{
			perror("putc error");
			return -1;
		}
	if(ferror(stdin))
		perror("getc error");
	return 0;
}

mypid.c
#include <stdio.h>
#include <unistd.h>
#include <errno.h>

int main(int argc, char const *argv[])
{
	printf("uid = %d, gid = %d\n",getuid(),getgid());
	return 0;
}

myshell.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/wait.h>

#define BUFFSIZE 4096

int main(int argc, char const *argv[])
{
	char buff[BUFFSIZE] = {0};
	pid_t pid;
	printf("$ "); /* 模拟命令行提示符 */
	while(fgets(buff, BUFFSIZE, stdin) != NULL){
		if(buff[strlen(buff) - 1] == '\n')
			buff[strlen(buff) -1] = '\0';
		if((pid = fork()) < 0)
		{
			perror("fork error");
			return -1;
		}
		else if(pid == 0)/* 子进程 */
		{
			if(execlp(buff, buff, (char *)0) < 0)/* execlp 启动的程序要求在PATH目录中能找到 */
			{
				perror("execlp error");
				return -1;
			}
			exit(0);
		}

		waitpid(pid, NULL, 0);
		printf("$ ");
	}

	return 0;
}

myerrno.c
#include <stdio.h>
#include <errno.h>
#include <string.h>

int main(int argc, char const *argv[])
{
	fprintf(stderr, "EACCES:%s\n", strerror(EACCES));
	errno = ENOENT;/* errno 属于全局变量*/
	perror(argv[0]);
	return 0;
}

mysignal.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <signal.h>

#define BUFFSIZE 4096

void handler_int(int signum)
{
	printf("got a SIGINT signal\n");
	exit(-1);
}

int main(int argc, char const *argv[])
{
	char buff[BUFFSIZE] = {0};
	pid_t pid;

	if(signal(SIGINT, handler_int) == SIG_ERR)
	{
		perror("signal error");
		return -1;
	}

	printf("$ "); /* 模拟命令行提示符 */
	while(fgets(buff, BUFFSIZE, stdin) != NULL){
		if(buff[strlen(buff) - 1] == '\n')
			buff[strlen(buff) -1] = '\0';
		if((pid = fork()) < 0)
		{
			perror("fork error");
			return -1;
		}
		else if(pid == 0)/* 子进程 */
		{
			if(execlp(buff, buff, (char *)0) < 0)/* execlp 启动的程序要求在PATH目录中能找到 */
			{
				perror("execlp error");
				return -1;
			}
			exit(0);
		}

		waitpid(pid, NULL, 0);
		printf("$ ");
	}

	return 0;
}

UNIX 基础知识
一、UNIX 系统

    UNIX内核的接口称之为系统调用。公用函数库构建在系统调用接口之上。应用程序既可以使用公用函数库，也可以使用系统调用。

    UNIX shell 是一个特殊的应用程序，它为其他应用程序提供了一个接口。

    路径名由斜线分隔的一个或者多个文件名组成的序列：
        以斜线开头的路径名称为绝对路径名
        以非斜线开头的路径名称为相对路径名

    文件系统根的名字 / 是一个特殊的绝对路径名。它不包含任何其他的字符。

    查看UNIX系统ls命令的 man帮助手册：man 1 ls或者 man -s1 ls。
        1表示第一部分。由于很多命令的说明文档过于庞大，因此 UNIX将说明文档划分成九个部分。常用的段有：
            1： 可执行程序或者 shell command的说明
            2： 系统调用的说明
            3： 库函数的说明
            4： 特殊文件（通常位于/dev/）的说明
            8： 系统管理员命令的说明（通常只有 root可用）
        ls表示shell command，即待查找的目标

    我们可以将 LINUX 操作系统中的 man手册用中文的man替代。方法为（UBUNTU操作系统下）：

    sudo apt-get install manpages-zh
    sudo vi /etc/manpath.config

    将 man的配置文件/etc/manpath.config中所有的/usr/share/man替换为/usr/share/man/zh_CN

    每个进程都有一个工作目录，有时称他为当前工作目录。所有的相对路径名都是从工作目录开始解释。

        可以用 chdir函数更改其工作目录

    登录时， shell的工作目录设置为起始目录

    UNIX系统中，每个进程都有一个唯一的数字标志符，称为进程ID（一个非负整数）。

    通常一个进程只有一个线程。但是你也可以创建多个线程。
        一个进程内的所有线程共享同一个地址空间、文件描述符、栈、进程相关属性
        多线程的程序需要在各线程访问共享数据时采取措施来避免不一致性
        线程也用ID标识，但是线程ID只有在它所属的进程内有意义

    用户和组：
        用户ID：标识各个不同的用户；用户ID为0的用户为根用户，其登录名为 root，它具有超级用户权限。
        组ID：用户所属的组的标识。
        附属组ID： 一个用户可以属于多个组，这些组就是附属组。由附属组的ID来标识。

二、错误处理

    当 UNIX 系统函数出错时，通常会返回一个负值，同时整型变量 errno 通常被设置为具有特定信息的值。
        文件 <errno.h> 定义了 errno 以及赋予它的各种常量，这些常量以 E字符开头
        在多线程环境中，每个线程都有属于自己的局部 errno，以避免一个线程干扰另一个线程。

    对于 errno 的使用要注意两条规则：
        如果没有出错，则errno的值不会被清除.因此只有在函数的返回值指明出错了时，检查errno才有意义
        任何函数都不会将errno的值清零，且在<errno.h>中定义的所有常量都不为0

    strerror/perror函数:用于处理错误信息

    #include<string.h>
    char *strerror(int errnum);
    #include<stdio.h>
    void perror(const char*msg);

        strerror: 将 errnum（通常就是 errno值）映射为一个出错消息字符串，并且返回此字符串的指针
            输入： 一个整数（通常是errno的值）
            输出： 出错消息字符串的指针（不需要用户手动分配出错消息字符串的内存）
        perror: 基于 errno的当前值，在标准错误上产生一条出错消息，然后返回。这条出错消息首先是 msg指向的字符串，后面是冒号，后面是一个空格，后面是对应于 errno值的出错消息，最后是一个换行符。
            输入：附加的出错消息
            输出：无输出。但是向标准错误上输出一条出错消息，这条出错消息如上所述。

    errno handle

    出错恢复：可以将<errno.h>中定义的错误分成两类：
        致命性错误：此类错误无法恢复。最多只能在屏幕上打印一条出错消息或者将出错消息写入日志，然后退出。
        非致命性错误：此类错误可以妥善处理。大多数非致命性错误时暂时的（比如资源短缺）

    与资源相关的非致命性错误包括：EAGAIN、ENFILE、ENOBUFS、ENOLCK、ENOSPC、EWOULDBLOCK.其典型的处理方法是：延迟一段时间，然后重试。
        有时候 ENOMEM 也是非致命性出错
        当 EBUSY 指明 共享资源正在使用是，也可视为非致命性出错处理
        EINTR 中断一个慢速系统调用时，可以视为非致命性出错处理

三、时间

    UNIX 系统使用两种时间：
        日历时间：自 UTC 1970年1月1日 00:00:00 以来经历过的秒数累计值。用 time_t数据类型来保存这种时间值。
        进程时间：也称作CPU时间，用于度量进程使用的CPU资源。进程时间以时间滴答来计算，用clock_t数据类型保存这种时间值。

    当度量一个进程的执行时间时，UNIX系统为一个进程维护了3个进程时间值：
        时钟时间： 又称作墙上时钟时间，是进程运行的时间总量，其值与系统中同时运行的进程数有关
        用户CPU时间：执行用户指令所用的时间量
        系统CPU时间：该进程执行内核程序所经历的时间。如进程执行一个read系统调用，则内核执行该系统调用的时间计入系统 CPU 时间

        用户CPU时间和系统CPU时间之和称作 CPU 时间

    运行 shell 命令 time 可以获取进程的时钟时间、用户时间和系统时间。time的参数请参考 man手册。

UNIX 标准及实现
UNIX 标准

    ISO C：意图是提供C程序的可移植性，使得它能够适合于大量不同的操作系统。
        该标准不仅定义了C程序设计语言的语法和语义，还定义了标准库

    POSIX(Portable Operating System Interface): 指的是可移植操作系统接口。该标准的目的是提升应用程序在各种UNIX系统环境之间的可移植性。它定义了“符合POSIX”的操作系统必须提供的各种服务。
        POSIX 包含了 ISO C 标准库函数

    SUS(Single Unix Specification)：是 POSIX 标准的一个超集，他定义了一些附加接口扩展了 POSIX 规范提供的功能。

    上述三个标准只是定义了接口的规范，而具体的实现由厂商来完成。目前UNIX主要有以下实现：
        SVR4(UNIX System V Release 4)
        4.4 BSD(Berkeley Software Distribution)
        FreeBSD
        Linux
        Mac OS X
        Solaris

限制

    UNIX 系统实现定义了很多幻数和常量。有两种类型的限制是必须的：
        编译时限制，如 short int 最大值是多少
        运行时限制，如文件名最长多少个字符

    通常编译时限制可以在头文件中定义；运行时限制则要求进程调用一个函数获得限制值。

    某些限制在一个给定的 UNIX 实现中可能是固定的（由头文件定义），在另一个 UNIX 实现中可能是动态的（需要由进程调用一个函数获得限制值）。如文件名的最大字符数在不同的操作系统中，是属于动态/静态限制。因此提供了三种限制：
        编译时限制（由头文件给定）
        与文件或者目录无关的运行时限制（由 sysconf函数给定）
        与文件或者目录相关的运行时限制（由 pathconf函数以及fpathconf函数给定）

    ISO C 限制：ISO C 所有编译时限制都在头文件 <limits.h> 中,如整型大小。
        这些限制常量在一个给定的操作系统中不会改变
        关于浮点数的最大最小值的编译时限制，在<float.h>头文件中定义
        <stdio.h> 头文件还定义了三个编译时限制：
            FOPEN_MAX：可同时打开的标准I/O 流限制的最小数
            TMP_MAX：由tmpnam函数产生的唯一文件名的最大个数
            FILENAME_MAX：虽然 ISO C 定义了该常量，但是要避免使用。而要用 POSIX 提供的 NAME_MAX和 PATH_MAX 常量

    POSIX 限制：POSIX定义了很多涉及操作系统实现限制的常量。这些常量大多数在<limits.h>中，也有的按照具体条件定义在其他头文件中

    获取运行时限制：

    #include<unistd.h>
    long sysconf(int name); 
    long pathconf(const char*pathname,int name);
    long fpathconf(int fd,int name); //fd 为文件描述符

        参数：
            name：指定的限制值。name参数是系统定义的常量
                以 _SC_开头的常量用于 sysconf函数
                以 _PC_开头的常量用于pathconf和fpathconf函数
            pathname：文件名
            fd：打开文件的文件描述符
        返回值：
            成功：返回对应的限制值
            失败： 返回 -1

    这三个函数失败的情况：
        若name参数并不是一个合适的常量，则这三个函数返回-1，并将 errno设置为 EINVAL
        有些name会返回一个不确定的值，这通过返回 -1 来体现，同时不改变errno

myconf.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <sys/types.h>

static void	pr_sysconf(char *, int);
static void	pr_pathconf(char *, char *, int);

int main(int argc, char *argv[])
{
	if (argc != 2) {
		printf("usage: %s <dirname>", argv[0]);
		return -1;
	}

#ifdef ARG_MAX
	printf("ARG_MAX defined to be %ld\n", (long)ARG_MAX+0);
#else
	printf("no symbol for ARG_MAX\n");
#endif
#ifdef _SC_ARG_MAX
	pr_sysconf("ARG_MAX =", _SC_ARG_MAX);
#else
	printf("no symbol for _SC_ARG_MAX\n");
#endif
#ifdef ATEXIT_MAX
	printf("ATEXIT_MAX defined to be %ld\n", (long)ATEXIT_MAX+0);
#else
	printf("no symbol for ATEXIT_MAX\n");
#endif
#ifdef _SC_ATEXIT_MAX
	pr_sysconf("ATEXIT_MAX =", _SC_ATEXIT_MAX);
#else
	printf("no symbol for _SC_ATEXIT_MAX\n");
#endif
#ifdef CHARCLASS_NAME_MAX
	printf("CHARCLASS_NAME_MAX defined to be %ld\n", (long)CHARCLASS_NAME_MAX+0);
#else
	printf("no symbol for CHARCLASS_NAME_MAX\n");
#endif
#ifdef _SC_CHARCLASS_NAME_MAX
	pr_sysconf("CHARCLASS_NAME_MAX =", _SC_CHARCLASS_NAME_MAX);
#else
	printf("no symbol for _SC_CHARCLASS_NAME_MAX\n");
#endif
#ifdef CHILD_MAX
	printf("CHILD_MAX defined to be %ld\n", (long)CHILD_MAX+0);
#else
	printf("no symbol for CHILD_MAX\n");
#endif
#ifdef _SC_CHILD_MAX
	pr_sysconf("CHILD_MAX =", _SC_CHILD_MAX);
#else
	printf("no symbol for _SC_CHILD_MAX\n");
#endif
#ifdef CLOCKTICKSPERSECOND /*clock ticks/second*/
	printf("CLOCKTICKSPERSECOND /*clock ticks/second*/ defined to be %ld\n", (long)CLOCKTICKSPERSECOND /*clock ticks/second*/+0);
#else
	printf("no symbol for CLOCKTICKSPERSECOND /*clock ticks/second*/\n");
#endif
#ifdef _SC_CLK_TCK
	pr_sysconf("CLOCKTICKSPERSECOND /*clock ticks/second*/ =", _SC_CLK_TCK);
#else
	printf("no symbol for _SC_CLK_TCK\n");
#endif
#ifdef COLL_WEIGHTS_MAX
	printf("COLL_WEIGHTS_MAX defined to be %ld\n", (long)COLL_WEIGHTS_MAX+0);
#else
	printf("no symbol for COLL_WEIGHTS_MAX\n");
#endif
#ifdef _SC_COLL_WEIGHTS_MAX
	pr_sysconf("COLL_WEIGHTS_MAX =", _SC_COLL_WEIGHTS_MAX);
#else
	printf("no symbol for _SC_COLL_WEIGHTS_MAX\n");
#endif
#ifdef DELAYTIMER_MAX
	printf("DELAYTIMER_MAX defined to be %ld\n", (long)DELAYTIMER_MAX+0);
#else
	printf("no symbol for DELAYTIMER_MAX\n");
#endif
#ifdef _SC_DELAYTIMER_MAX
	pr_sysconf("DELAYTIMER_MAX =", _SC_DELAYTIMER_MAX);
#else
	printf("no symbol for _SC_DELAYTIMER_MAX\n");
#endif
#ifdef HOST_NAME_MAX
	printf("HOST_NAME_MAX defined to be %ld\n", (long)HOST_NAME_MAX+0);
#else
	printf("no symbol for HOST_NAME_MAX\n");
#endif
#ifdef _SC_HOST_NAME_MAX
	pr_sysconf("HOST_NAME_MAX =", _SC_HOST_NAME_MAX);
#else
	printf("no symbol for _SC_HOST_NAME_MAX\n");
#endif
#ifdef IOV_MAX
	printf("IOV_MAX defined to be %ld\n", (long)IOV_MAX+0);
#else
	printf("no symbol for IOV_MAX\n");
#endif
#ifdef _SC_IOV_MAX
	pr_sysconf("IOV_MAX =", _SC_IOV_MAX);
#else
	printf("no symbol for _SC_IOV_MAX\n");
#endif
#ifdef LINE_MAX
	printf("LINE_MAX defined to be %ld\n", (long)LINE_MAX+0);
#else
	printf("no symbol for LINE_MAX\n");
#endif
#ifdef _SC_LINE_MAX
	pr_sysconf("LINE_MAX =", _SC_LINE_MAX);
#else
	printf("no symbol for _SC_LINE_MAX\n");
#endif
#ifdef LOGIN_NAME_MAX
	printf("LOGIN_NAME_MAX defined to be %ld\n", (long)LOGIN_NAME_MAX+0);
#else
	printf("no symbol for LOGIN_NAME_MAX\n");
#endif
#ifdef _SC_LOGIN_NAME_MAX
	pr_sysconf("LOGIN_NAME_MAX =", _SC_LOGIN_NAME_MAX);
#else
	printf("no symbol for _SC_LOGIN_NAME_MAX\n");
#endif
#ifdef NGROUPS_MAX
	printf("NGROUPS_MAX defined to be %ld\n", (long)NGROUPS_MAX+0);
#else
	printf("no symbol for NGROUPS_MAX\n");
#endif
#ifdef _SC_NGROUPS_MAX
	pr_sysconf("NGROUPS_MAX =", _SC_NGROUPS_MAX);
#else
	printf("no symbol for _SC_NGROUPS_MAX\n");
#endif
#ifdef OPEN_MAX
	printf("OPEN_MAX defined to be %ld\n", (long)OPEN_MAX+0);
#else
	printf("no symbol for OPEN_MAX\n");
#endif
#ifdef _SC_OPEN_MAX
	pr_sysconf("OPEN_MAX =", _SC_OPEN_MAX);
#else
	printf("no symbol for _SC_OPEN_MAX\n");
#endif
#ifdef PAGESIZE
	printf("PAGESIZE defined to be %ld\n", (long)PAGESIZE+0);
#else
	printf("no symbol for PAGESIZE\n");
#endif
#ifdef _SC_PAGESIZE
	pr_sysconf("PAGESIZE =", _SC_PAGESIZE);
#else
	printf("no symbol for _SC_PAGESIZE\n");
#endif
#ifdef PAGE_SIZE
	printf("PAGE_SIZE defined to be %ld\n", (long)PAGE_SIZE+0);
#else
	printf("no symbol for PAGE_SIZE\n");
#endif
#ifdef _SC_PAGE_SIZE
	pr_sysconf("PAGE_SIZE =", _SC_PAGE_SIZE);
#else
	printf("no symbol for _SC_PAGE_SIZE\n");
#endif
#ifdef RE_DUP_MAX
	printf("RE_DUP_MAX defined to be %ld\n", (long)RE_DUP_MAX+0);
#else
	printf("no symbol for RE_DUP_MAX\n");
#endif
#ifdef _SC_RE_DUP_MAX
	pr_sysconf("RE_DUP_MAX =", _SC_RE_DUP_MAX);
#else
	printf("no symbol for _SC_RE_DUP_MAX\n");
#endif
#ifdef RTSIG_MAX
	printf("RTSIG_MAX defined to be %ld\n", (long)RTSIG_MAX+0);
#else
	printf("no symbol for RTSIG_MAX\n");
#endif
#ifdef _SC_RTSIG_MAX
	pr_sysconf("RTSIG_MAX =", _SC_RTSIG_MAX);
#else
	printf("no symbol for _SC_RTSIG_MAX\n");
#endif
#ifdef SEM_NSEMS_MAX
	printf("SEM_NSEMS_MAX defined to be %ld\n", (long)SEM_NSEMS_MAX+0);
#else
	printf("no symbol for SEM_NSEMS_MAX\n");
#endif
#ifdef _SC_SEM_NSEMS_MAX
	pr_sysconf("SEM_NSEMS_MAX =", _SC_SEM_NSEMS_MAX);
#else
	printf("no symbol for _SC_SEM_NSEMS_MAX\n");
#endif
#ifdef SEM_VALUE_MAX
	printf("SEM_VALUE_MAX defined to be %ld\n", (long)SEM_VALUE_MAX+0);
#else
	printf("no symbol for SEM_VALUE_MAX\n");
#endif
#ifdef _SC_SEM_VALUE_MAX
	pr_sysconf("SEM_VALUE_MAX =", _SC_SEM_VALUE_MAX);
#else
	printf("no symbol for _SC_SEM_VALUE_MAX\n");
#endif
#ifdef SIGQUEUE_MAX
	printf("SIGQUEUE_MAX defined to be %ld\n", (long)SIGQUEUE_MAX+0);
#else
	printf("no symbol for SIGQUEUE_MAX\n");
#endif
#ifdef _SC_SIGQUEUE_MAX
	pr_sysconf("SIGQUEUE_MAX =", _SC_SIGQUEUE_MAX);
#else
	printf("no symbol for _SC_SIGQUEUE_MAX\n");
#endif
#ifdef STREAM_MAX
	printf("STREAM_MAX defined to be %ld\n", (long)STREAM_MAX+0);
#else
	printf("no symbol for STREAM_MAX\n");
#endif
#ifdef _SC_STREAM_MAX
	pr_sysconf("STREAM_MAX =", _SC_STREAM_MAX);
#else
	printf("no symbol for _SC_STREAM_MAX\n");
#endif
#ifdef SYMLOOP_MAX
	printf("SYMLOOP_MAX defined to be %ld\n", (long)SYMLOOP_MAX+0);
#else
	printf("no symbol for SYMLOOP_MAX\n");
#endif
#ifdef _SC_SYMLOOP_MAX
	pr_sysconf("SYMLOOP_MAX =", _SC_SYMLOOP_MAX);
#else
	printf("no symbol for _SC_SYMLOOP_MAX\n");
#endif
#ifdef TIMER_MAX
	printf("TIMER_MAX defined to be %ld\n", (long)TIMER_MAX+0);
#else
	printf("no symbol for TIMER_MAX\n");
#endif
#ifdef _SC_TIMER_MAX
	pr_sysconf("TIMER_MAX =", _SC_TIMER_MAX);
#else
	printf("no symbol for _SC_TIMER_MAX\n");
#endif
#ifdef TTY_NAME_MAX
	printf("TTY_NAME_MAX defined to be %ld\n", (long)TTY_NAME_MAX+0);
#else
	printf("no symbol for TTY_NAME_MAX\n");
#endif
#ifdef _SC_TTY_NAME_MAX
	pr_sysconf("TTY_NAME_MAX =", _SC_TTY_NAME_MAX);
#else
	printf("no symbol for _SC_TTY_NAME_MAX\n");
#endif
#ifdef TZNAME_MAX
	printf("TZNAME_MAX defined to be %ld\n", (long)TZNAME_MAX+0);
#else
	printf("no symbol for TZNAME_MAX\n");
#endif
#ifdef _SC_TZNAME_MAX
	pr_sysconf("TZNAME_MAX =", _SC_TZNAME_MAX);
#else
	printf("no symbol for _SC_TZNAME_MAX\n");
#endif
#ifdef FILESIZEBITS
	printf("FILESIZEBITS defined to be %ld\n", (long)FILESIZEBITS+0);
#else
	printf("no symbol for FILESIZEBITS\n");
#endif
#ifdef _PC_FILESIZEBITS
	pr_pathconf("FILESIZEBITS =", argv[1], _PC_FILESIZEBITS);
#else
	printf("no symbol for _PC_FILESIZEBITS\n");
#endif
#ifdef LINK_MAX
	printf("LINK_MAX defined to be %ld\n", (long)LINK_MAX+0);
#else
	printf("no symbol for LINK_MAX\n");
#endif
#ifdef _PC_LINK_MAX
	pr_pathconf("LINK_MAX =", argv[1], _PC_LINK_MAX);
#else
	printf("no symbol for _PC_LINK_MAX\n");
#endif
#ifdef MAX_CANON
	printf("MAX_CANON defined to be %ld\n", (long)MAX_CANON+0);
#else
	printf("no symbol for MAX_CANON\n");
#endif
#ifdef _PC_MAX_CANON
	pr_pathconf("MAX_CANON =", argv[1], _PC_MAX_CANON);
#else
	printf("no symbol for _PC_MAX_CANON\n");
#endif
#ifdef MAX_INPUT
	printf("MAX_INPUT defined to be %ld\n", (long)MAX_INPUT+0);
#else
	printf("no symbol for MAX_INPUT\n");
#endif
#ifdef _PC_MAX_INPUT
	pr_pathconf("MAX_INPUT =", argv[1], _PC_MAX_INPUT);
#else
	printf("no symbol for _PC_MAX_INPUT\n");
#endif
#ifdef NAME_MAX
	printf("NAME_MAX defined to be %ld\n", (long)NAME_MAX+0);
#else
	printf("no symbol for NAME_MAX\n");
#endif
#ifdef _PC_NAME_MAX
	pr_pathconf("NAME_MAX =", argv[1], _PC_NAME_MAX);
#else
	printf("no symbol for _PC_NAME_MAX\n");
#endif
#ifdef PATH_MAX
	printf("PATH_MAX defined to be %ld\n", (long)PATH_MAX+0);
#else
	printf("no symbol for PATH_MAX\n");
#endif
#ifdef _PC_PATH_MAX
	pr_pathconf("PATH_MAX =", argv[1], _PC_PATH_MAX);
#else
	printf("no symbol for _PC_PATH_MAX\n");
#endif
#ifdef PIPE_BUF
	printf("PIPE_BUF defined to be %ld\n", (long)PIPE_BUF+0);
#else
	printf("no symbol for PIPE_BUF\n");
#endif
#ifdef _PC_PIPE_BUF
	pr_pathconf("PIPE_BUF =", argv[1], _PC_PIPE_BUF);
#else
	printf("no symbol for _PC_PIPE_BUF\n");
#endif
#ifdef SYMLINK_MAX
	printf("SYMLINK_MAX defined to be %ld\n", (long)SYMLINK_MAX+0);
#else
	printf("no symbol for SYMLINK_MAX\n");
#endif
#ifdef _PC_SYMLINK_MAX
	pr_pathconf("SYMLINK_MAX =", argv[1], _PC_SYMLINK_MAX);
#else
	printf("no symbol for _PC_SYMLINK_MAX\n");
#endif
#ifdef _POSIX_TIMESTAMP_RESOLUTION
	printf("_POSIX_TIMESTAMP_RESOLUTION defined to be %ld\n", (long)_POSIX_TIMESTAMP_RESOLUTION+0);
#else
	printf("no symbol for _POSIX_TIMESTAMP_RESOLUTION\n");
#endif
#ifdef _PC_TIMESTAMP_RESOLUTION
	pr_pathconf("_POSIX_TIMESTAMP_RESOLUTION =", argv[1], _PC_TIMESTAMP_RESOLUTION);
#else
	printf("no symbol for _PC_TIMESTAMP_RESOLUTION\n");
#endif
	exit(0);
}

static void pr_sysconf(char *mesg, int name)
{
	long	val;

	fputs(mesg, stdout);
	errno = 0;
	if ((val = sysconf(name)) < 0) {
		if (errno != 0) {
			if (errno == EINVAL) {
				fputs(" (not supported)\n", stdout);
			}
			else {
				printf("sysconf error");
				exit(-1);
			}
		} else {
			fputs(" (no limit)\n", stdout);
		}
	} else {
		printf(" %ld\n", val);
	}
}

static void pr_pathconf(char *mesg, char *path, int name)
{
	long	val;

	fputs(mesg, stdout);
	errno = 0;
	if ((val = pathconf(path, name)) < 0) {
		if (errno != 0) {
			if (errno == EINVAL) {
				fputs(" (not supported)\n", stdout);
			}
			else {
				printf("pathconf error, path = %s", path);
				exit(-1);
			}
		} else {
			fputs(" (no limit)\n", stdout);
		}
	} else {
		printf(" %ld\n", val);
	}
}

myoptions.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <sys/types.h>

static void	pr_sysconf(char *, int);
static void	pr_pathconf(char *, char *, int);

int main(int argc, char *argv[])
{
	if (argc != 2) {
		printf("usage: %s <dirname>", argv[0]);
		return -1;
	}

#ifdef _POSIX_ADVISORY_INFO
	printf("_POSIX_ADVISORY_INFO is defined (val is %ld)\n", (long)_POSIX_ADVISORY_INFO+0);
#else
	printf("_POSIX_ADVISORY_INFO is undefined\n");
#endif
#ifdef _SC_ADVISORY_INFO
	pr_sysconf("sysconf says _POSIX_ADVISORY_INFO =", _SC_ADVISORY_INFO);
#else
	printf("no symbol for _POSIX_ADVISORY_INFO\n");
#endif
	printf("\n");
#ifdef _POSIX_ASYNCHRONOUS_IO
	printf("_POSIX_ASYNCHRONOUS_IO is defined (val is %ld)\n", (long)_POSIX_ASYNCHRONOUS_IO+0);
#else
	printf("_POSIX_ASYNCHRONOUS_IO is undefined\n");
#endif
#ifdef _SC_ASYNCHRONOUS_IO
	pr_sysconf("sysconf says _POSIX_ASYNCHRONOUS_IO =", _SC_ASYNCHRONOUS_IO);
#else
	printf("no symbol for _POSIX_ASYNCHRONOUS_IO\n");
#endif
	printf("\n");
#ifdef _POSIX_BARRIERS
	printf("_POSIX_BARRIERS is defined (val is %ld)\n", (long)_POSIX_BARRIERS+0);
#else
	printf("_POSIX_BARRIERS is undefined\n");
#endif
#ifdef _SC_BARRIERS
	pr_sysconf("sysconf says _POSIX_BARRIERS =", _SC_BARRIERS);
#else
	printf("no symbol for _POSIX_BARRIERS\n");
#endif
	printf("\n");
#ifdef _POSIX_CLOCK_SELECTION
	printf("_POSIX_CLOCK_SELECTION is defined (val is %ld)\n", (long)_POSIX_CLOCK_SELECTION+0);
#else
	printf("_POSIX_CLOCK_SELECTION is undefined\n");
#endif
#ifdef _SC_CLOCK_SELECTION
	pr_sysconf("sysconf says _POSIX_CLOCK_SELECTION =", _SC_CLOCK_SELECTION);
#else
	printf("no symbol for _POSIX_CLOCK_SELECTION\n");
#endif
	printf("\n");
#ifdef _POSIX_CPUTIME
	printf("_POSIX_CPUTIME is defined (val is %ld)\n", (long)_POSIX_CPUTIME+0);
#else
	printf("_POSIX_CPUTIME is undefined\n");
#endif
#ifdef _SC_CPUTIME
	pr_sysconf("sysconf says _POSIX_CPUTIME =", _SC_CPUTIME);
#else
	printf("no symbol for _POSIX_CPUTIME\n");
#endif
	printf("\n");
#ifdef _POSIX_FSYNC
	printf("_POSIX_FSYNC is defined (val is %ld)\n", (long)_POSIX_FSYNC+0);
#else
	printf("_POSIX_FSYNC is undefined\n");
#endif
#ifdef _SC_FSYNC
	pr_sysconf("sysconf says _POSIX_FSYNC =", _SC_FSYNC);
#else
	printf("no symbol for _POSIX_FSYNC\n");
#endif
	printf("\n");
#ifdef _POSIX_IPV6
	printf("_POSIX_IPV6 is defined (val is %ld)\n", (long)_POSIX_IPV6+0);
#else
	printf("_POSIX_IPV6 is undefined\n");
#endif
#ifdef _SC_IPV6
	pr_sysconf("sysconf says _POSIX_IPV6 =", _SC_IPV6);
#else
	printf("no symbol for _POSIX_IPV6\n");
#endif
	printf("\n");
#ifdef _POSIX_JOB_CONTROL
	printf("_POSIX_JOB_CONTROL is defined (val is %ld)\n", (long)_POSIX_JOB_CONTROL+0);
#else
	printf("_POSIX_JOB_CONTROL is undefined\n");
#endif
#ifdef _SC_JOB_CONTROL
	pr_sysconf("sysconf says _POSIX_JOB_CONTROL =", _SC_JOB_CONTROL);
#else
	printf("no symbol for _POSIX_JOB_CONTROL\n");
#endif
	printf("\n");
#ifdef _POSIX_MAPPED_FILES
	printf("_POSIX_MAPPED_FILES is defined (val is %ld)\n", (long)_POSIX_MAPPED_FILES+0);
#else
	printf("_POSIX_MAPPED_FILES is undefined\n");
#endif
#ifdef _SC_MAPPED_FILES
	pr_sysconf("sysconf says _POSIX_MAPPED_FILES =", _SC_MAPPED_FILES);
#else
	printf("no symbol for _POSIX_MAPPED_FILES\n");
#endif
	printf("\n");
#ifdef _POSIX_MEMLOCK
	printf("_POSIX_MEMLOCK is defined (val is %ld)\n", (long)_POSIX_MEMLOCK+0);
#else
	printf("_POSIX_MEMLOCK is undefined\n");
#endif
#ifdef _SC_MEMLOCK
	pr_sysconf("sysconf says _POSIX_MEMLOCK =", _SC_MEMLOCK);
#else
	printf("no symbol for _POSIX_MEMLOCK\n");
#endif
	printf("\n");
#ifdef _POSIX_MEMLOCK_RANGE
	printf("_POSIX_MEMLOCK_RANGE is defined (val is %ld)\n", (long)_POSIX_MEMLOCK_RANGE+0);
#else
	printf("_POSIX_MEMLOCK_RANGE is undefined\n");
#endif
#ifdef _SC_MEMLOCK_RANGE
	pr_sysconf("sysconf says _POSIX_MEMLOCK_RANGE =", _SC_MEMLOCK_RANGE);
#else
	printf("no symbol for _POSIX_MEMLOCK_RANGE\n");
#endif
	printf("\n");
#ifdef _POSIX_MEMORY_PROTECTION
	printf("_POSIX_MEMORY_PROTECTION is defined (val is %ld)\n", (long)_POSIX_MEMORY_PROTECTION+0);
#else
	printf("_POSIX_MEMORY_PROTECTION is undefined\n");
#endif
#ifdef _SC_MEMORY_PROTECTION
	pr_sysconf("sysconf says _POSIX_MEMORY_PROTECTION =", _SC_MEMORY_PROTECTION);
#else
	printf("no symbol for _POSIX_MEMORY_PROTECTION\n");
#endif
	printf("\n");
#ifdef _POSIX_MESSAGE_PASSING
	printf("_POSIX_MESSAGE_PASSING is defined (val is %ld)\n", (long)_POSIX_MESSAGE_PASSING+0);
#else
	printf("_POSIX_MESSAGE_PASSING is undefined\n");
#endif
#ifdef _SC_MESSAGE_PASSING
	pr_sysconf("sysconf says _POSIX_MESSAGE_PASSING =", _SC_MESSAGE_PASSING);
#else
	printf("no symbol for _POSIX_MESSAGE_PASSING\n");
#endif
	printf("\n");
#ifdef _POSIX_MONOTONIC_CLOCK
	printf("_POSIX_MONOTONIC_CLOCK is defined (val is %ld)\n", (long)_POSIX_MONOTONIC_CLOCK+0);
#else
	printf("_POSIX_MONOTONIC_CLOCK is undefined\n");
#endif
#ifdef _SC_MONOTONIC_CLOCK
	pr_sysconf("sysconf says _POSIX_MONOTONIC_CLOCK =", _SC_MONOTONIC_CLOCK);
#else
	printf("no symbol for _POSIX_MONOTONIC_CLOCK\n");
#endif
	printf("\n");
#ifdef _POSIX_PRIORITIZED_IO
	printf("_POSIX_PRIORITIZED_IO is defined (val is %ld)\n", (long)_POSIX_PRIORITIZED_IO+0);
#else
	printf("_POSIX_PRIORITIZED_IO is undefined\n");
#endif
#ifdef _SC_PRIORITIZED_IO
	pr_sysconf("sysconf says _POSIX_PRIORITIZED_IO =", _SC_PRIORITIZED_IO);
#else
	printf("no symbol for _POSIX_PRIORITIZED_IO\n");
#endif
	printf("\n");
#ifdef _POSIX_PRIORITY_SCHEDULING
	printf("_POSIX_PRIORITY_SCHEDULING is defined (val is %ld)\n", (long)_POSIX_PRIORITY_SCHEDULING+0);
#else
	printf("_POSIX_PRIORITY_SCHEDULING is undefined\n");
#endif
#ifdef _SC_PRIORITY_SCHEDULING
	pr_sysconf("sysconf says _POSIX_PRIORITY_SCHEDULING =", _SC_PRIORITY_SCHEDULING);
#else
	printf("no symbol for _POSIX_PRIORITY_SCHEDULING\n");
#endif
	printf("\n");
#ifdef _POSIX_RAW_SOCKETS
	printf("_POSIX_RAW_SOCKETS is defined (val is %ld)\n", (long)_POSIX_RAW_SOCKETS+0);
#else
	printf("_POSIX_RAW_SOCKETS is undefined\n");
#endif
#ifdef _SC_RAW_SOCKETS
	pr_sysconf("sysconf says _POSIX_RAW_SOCKETS =", _SC_RAW_SOCKETS);
#else
	printf("no symbol for _POSIX_RAW_SOCKETS\n");
#endif
	printf("\n");
#ifdef _POSIX_READER_WRITER_LOCKS
	printf("_POSIX_READER_WRITER_LOCKS is defined (val is %ld)\n", (long)_POSIX_READER_WRITER_LOCKS+0);
#else
	printf("_POSIX_READER_WRITER_LOCKS is undefined\n");
#endif
#ifdef _SC_READER_WRITER_LOCKS
	pr_sysconf("sysconf says _POSIX_READER_WRITER_LOCKS =", _SC_READER_WRITER_LOCKS);
#else
	printf("no symbol for _POSIX_READER_WRITER_LOCKS\n");
#endif
	printf("\n");
#ifdef _POSIX_REALTIME_SIGNALS
	printf("_POSIX_REALTIME_SIGNALS is defined (val is %ld)\n", (long)_POSIX_REALTIME_SIGNALS+0);
#else
	printf("_POSIX_REALTIME_SIGNALS is undefined\n");
#endif
#ifdef _SC_REALTIME_SIGNALS
	pr_sysconf("sysconf says _POSIX_REALTIME_SIGNALS =", _SC_REALTIME_SIGNALS);
#else
	printf("no symbol for _POSIX_REALTIME_SIGNALS\n");
#endif
	printf("\n");
#ifdef _POSIX_REGEXP
	printf("_POSIX_REGEXP is defined (val is %ld)\n", (long)_POSIX_REGEXP+0);
#else
	printf("_POSIX_REGEXP is undefined\n");
#endif
#ifdef _SC_REGEXP
	pr_sysconf("sysconf says _POSIX_REGEXP =", _SC_REGEXP);
#else
	printf("no symbol for _POSIX_REGEXP\n");
#endif
	printf("\n");
#ifdef _POSIX_SAVED_IDS
	printf("_POSIX_SAVED_IDS is defined (val is %ld)\n", (long)_POSIX_SAVED_IDS+0);
#else
	printf("_POSIX_SAVED_IDS is undefined\n");
#endif
#ifdef _SC_SAVED_IDS
	pr_sysconf("sysconf says _POSIX_SAVED_IDS =", _SC_SAVED_IDS);
#else
	printf("no symbol for _POSIX_SAVED_IDS\n");
#endif
	printf("\n");
#ifdef _POSIX_SEMAPHORES
	printf("_POSIX_SEMAPHORES is defined (val is %ld)\n", (long)_POSIX_SEMAPHORES+0);
#else
	printf("_POSIX_SEMAPHORES is undefined\n");
#endif
#ifdef _SC_SEMAPHORES
	pr_sysconf("sysconf says _POSIX_SEMAPHORES =", _SC_SEMAPHORES);
#else
	printf("no symbol for _POSIX_SEMAPHORES\n");
#endif
	printf("\n");
#ifdef _POSIX_SHARED_MEMORY_OBJECTS
	printf("_POSIX_SHARED_MEMORY_OBJECTS is defined (val is %ld)\n", (long)_POSIX_SHARED_MEMORY_OBJECTS+0);
#else
	printf("_POSIX_SHARED_MEMORY_OBJECTS is undefined\n");
#endif
#ifdef _SC_SHARED_MEMORY_OBJECTS
	pr_sysconf("sysconf says _POSIX_SHARED_MEMORY_OBJECTS =", _SC_SHARED_MEMORY_OBJECTS);
#else
	printf("no symbol for _POSIX_SHARED_MEMORY_OBJECTS\n");
#endif
	printf("\n");
#ifdef _POSIX_SHELL
	printf("_POSIX_SHELL is defined (val is %ld)\n", (long)_POSIX_SHELL+0);
#else
	printf("_POSIX_SHELL is undefined\n");
#endif
#ifdef _SC_SHELL
	pr_sysconf("sysconf says _POSIX_SHELL =", _SC_SHELL);
#else
	printf("no symbol for _POSIX_SHELL\n");
#endif
	printf("\n");
#ifdef _POSIX_SPAWN
	printf("_POSIX_SPAWN is defined (val is %ld)\n", (long)_POSIX_SPAWN+0);
#else
	printf("_POSIX_SPAWN is undefined\n");
#endif
#ifdef _SC_SPAWN
	pr_sysconf("sysconf says _POSIX_SPAWN =", _SC_SPAWN);
#else
	printf("no symbol for _POSIX_SPAWN\n");
#endif
	printf("\n");
#ifdef _POSIX_SPIN_LOCKS
	printf("_POSIX_SPIN_LOCKS is defined (val is %ld)\n", (long)_POSIX_SPIN_LOCKS+0);
#else
	printf("_POSIX_SPIN_LOCKS is undefined\n");
#endif
#ifdef _SC_SPIN_LOCKS
	pr_sysconf("sysconf says _POSIX_SPIN_LOCKS =", _SC_SPIN_LOCKS);
#else
	printf("no symbol for _POSIX_SPIN_LOCKS\n");
#endif
	printf("\n");
#ifdef _POSIX_SPORADIC_SERVER
	printf("_POSIX_SPORADIC_SERVER is defined (val is %ld)\n", (long)_POSIX_SPORADIC_SERVER+0);
#else
	printf("_POSIX_SPORADIC_SERVER is undefined\n");
#endif
#ifdef _SC_SPORADIC_SERVER
	pr_sysconf("sysconf says _POSIX_SPORADIC_SERVER =", _SC_SPORADIC_SERVER);
#else
	printf("no symbol for _POSIX_SPORADIC_SERVER\n");
#endif
	printf("\n");
#ifdef _POSIX_SYNCHRONIZED_IO
	printf("_POSIX_SYNCHRONIZED_IO is defined (val is %ld)\n", (long)_POSIX_SYNCHRONIZED_IO+0);
#else
	printf("_POSIX_SYNCHRONIZED_IO is undefined\n");
#endif
#ifdef _SC_SYNCHRONIZED_IO
	pr_sysconf("sysconf says _POSIX_SYNCHRONIZED_IO =", _SC_SYNCHRONIZED_IO);
#else
	printf("no symbol for _POSIX_SYNCHRONIZED_IO\n");
#endif
	printf("\n");
#ifdef _POSIX_THREAD_ATTR_STACKADDR
	printf("_POSIX_THREAD_ATTR_STACKADDR is defined (val is %ld)\n", (long)_POSIX_THREAD_ATTR_STACKADDR+0);
#else
	printf("_POSIX_THREAD_ATTR_STACKADDR is undefined\n");
#endif
#ifdef _SC_THREAD_ATTR_STACKADDR
	pr_sysconf("sysconf says _POSIX_THREAD_ATTR_STACKADDR =", _SC_THREAD_ATTR_STACKADDR);
#else
	printf("no symbol for _POSIX_THREAD_ATTR_STACKADDR\n");
#endif
	printf("\n");
#ifdef _POSIX_THREAD_ATTR_STACKSIZE
	printf("_POSIX_THREAD_ATTR_STACKSIZE is defined (val is %ld)\n", (long)_POSIX_THREAD_ATTR_STACKSIZE+0);
#else
	printf("_POSIX_THREAD_ATTR_STACKSIZE is undefined\n");
#endif
#ifdef _SC_THREAD_ATTR_STACKSIZE
	pr_sysconf("sysconf says _POSIX_THREAD_ATTR_STACKSIZE =", _SC_THREAD_ATTR_STACKSIZE);
#else
	printf("no symbol for _POSIX_THREAD_ATTR_STACKSIZE\n");
#endif
	printf("\n");
#ifdef _POSIX_THREAD_ATTR_CPUTIME
	printf("_POSIX_THREAD_ATTR_CPUTIME is defined (val is %ld)\n", (long)_POSIX_THREAD_ATTR_CPUTIME+0);
#else
	printf("_POSIX_THREAD_ATTR_CPUTIME is undefined\n");
#endif
#ifdef _SC_THREAD_CPUTIME
	pr_sysconf("sysconf says _POSIX_THREAD_ATTR_CPUTIME =", _SC_THREAD_CPUTIME);
#else
	printf("no symbol for _POSIX_THREAD_ATTR_CPUTIME\n");
#endif
	printf("\n");
#ifdef _POSIX_THREAD_PRIO_INHERIT
	printf("_POSIX_THREAD_PRIO_INHERIT is defined (val is %ld)\n", (long)_POSIX_THREAD_PRIO_INHERIT+0);
#else
	printf("_POSIX_THREAD_PRIO_INHERIT is undefined\n");
#endif
#ifdef _SC_THREAD_PRIO_INHERIT
	pr_sysconf("sysconf says _POSIX_THREAD_PRIO_INHERIT =", _SC_THREAD_PRIO_INHERIT);
#else
	printf("no symbol for _POSIX_THREAD_PRIO_INHERIT\n");
#endif
	printf("\n");
#ifdef _POSIX_THREAD_PRIORITY_SCHEDULING
	printf("_POSIX_THREAD_PRIORITY_SCHEDULING is defined (val is %ld)\n", (long)_POSIX_THREAD_PRIORITY_SCHEDULING+0);
#else
	printf("_POSIX_THREAD_PRIORITY_SCHEDULING is undefined\n");
#endif
#ifdef _SC_THREAD_PRIORITY_SCHEDULING
	pr_sysconf("sysconf says _POSIX_THREAD_PRIORITY_SCHEDULING =", _SC_THREAD_PRIORITY_SCHEDULING);
#else
	printf("no symbol for _POSIX_THREAD_PRIORITY_SCHEDULING\n");
#endif
	printf("\n");
#ifdef _POSIX_THREAD_PROCESS_SHARED
	printf("_POSIX_THREAD_PROCESS_SHARED is defined (val is %ld)\n", (long)_POSIX_THREAD_PROCESS_SHARED+0);
#else
	printf("_POSIX_THREAD_PROCESS_SHARED is undefined\n");
#endif
#ifdef _SC_THREAD_PROCESS_SHARED
	pr_sysconf("sysconf says _POSIX_THREAD_PROCESS_SHARED =", _SC_THREAD_PROCESS_SHARED);
#else
	printf("no symbol for _POSIX_THREAD_PROCESS_SHARED\n");
#endif
	printf("\n");
#ifdef _POSIX_THREAD_ROBUST_PRIO_INHERIT
	printf("_POSIX_THREAD_ROBUST_PRIO_INHERIT is defined (val is %ld)\n", (long)_POSIX_THREAD_ROBUST_PRIO_INHERIT+0);
#else
	printf("_POSIX_THREAD_ROBUST_PRIO_INHERIT is undefined\n");
#endif
#ifdef _SC_THREAD_ROBUST_PRIO_INHERIT
	pr_sysconf("sysconf says _POSIX_THREAD_ROBUST_PRIO_INHERIT =", _SC_THREAD_ROBUST_PRIO_INHERIT);
#else
	printf("no symbol for _POSIX_THREAD_ROBUST_PRIO_INHERIT\n");
#endif
	printf("\n");
#ifdef _POSIX_THREAD_ROBUST_PRIO_PROTECT
	printf("_POSIX_THREAD_ROBUST_PRIO_PROTECT is defined (val is %ld)\n", (long)_POSIX_THREAD_ROBUST_PRIO_PROTECT+0);
#else
	printf("_POSIX_THREAD_ROBUST_PRIO_PROTECT is undefined\n");
#endif
#ifdef _SC_THREAD_ROBUST_PRIO_PROTECT
	pr_sysconf("sysconf says _POSIX_THREAD_ROBUST_PRIO_PROTECT =", _SC_THREAD_ROBUST_PRIO_PROTECT);
#else
	printf("no symbol for _POSIX_THREAD_ROBUST_PRIO_PROTECT\n");
#endif
	printf("\n");
#ifdef _POSIX_THREAD_SAFE_FUNCTIONS
	printf("_POSIX_THREAD_SAFE_FUNCTIONS is defined (val is %ld)\n", (long)_POSIX_THREAD_SAFE_FUNCTIONS+0);
#else
	printf("_POSIX_THREAD_SAFE_FUNCTIONS is undefined\n");
#endif
#ifdef _SC_THREAD_SAFE_FUNCTIONS
	pr_sysconf("sysconf says _POSIX_THREAD_SAFE_FUNCTIONS =", _SC_THREAD_SAFE_FUNCTIONS);
#else
	printf("no symbol for _POSIX_THREAD_SAFE_FUNCTIONS\n");
#endif
	printf("\n");
#ifdef _POSIX_THREAD_SPORADIC_SERVER
	printf("_POSIX_THREAD_SPORADIC_SERVER is defined (val is %ld)\n", (long)_POSIX_THREAD_SPORADIC_SERVER+0);
#else
	printf("_POSIX_THREAD_SPORADIC_SERVER is undefined\n");
#endif
#ifdef _SC_THREAD_SPORADIC_SERVER
	pr_sysconf("sysconf says _POSIX_THREAD_SPORADIC_SERVER =", _SC_THREAD_SPORADIC_SERVER);
#else
	printf("no symbol for _POSIX_THREAD_SPORADIC_SERVER\n");
#endif
	printf("\n");
#ifdef _POSIX_THREADS
	printf("_POSIX_THREADS is defined (val is %ld)\n", (long)_POSIX_THREADS+0);
#else
	printf("_POSIX_THREADS is undefined\n");
#endif
#ifdef _SC_THREADS
	pr_sysconf("sysconf says _POSIX_THREADS =", _SC_THREADS);
#else
	printf("no symbol for _POSIX_THREADS\n");
#endif
	printf("\n");
#ifdef _POSIX_TIMEOUTS
	printf("_POSIX_TIMEOUTS is defined (val is %ld)\n", (long)_POSIX_TIMEOUTS+0);
#else
	printf("_POSIX_TIMEOUTS is undefined\n");
#endif
#ifdef _SC_TIMEOUTS
	pr_sysconf("sysconf says _POSIX_TIMEOUTS =", _SC_TIMEOUTS);
#else
	printf("no symbol for _POSIX_TIMEOUTS\n");
#endif
	printf("\n");
#ifdef _POSIX_TIMERS
	printf("_POSIX_TIMERS is defined (val is %ld)\n", (long)_POSIX_TIMERS+0);
#else
	printf("_POSIX_TIMERS is undefined\n");
#endif
#ifdef _SC_TIMERS
	pr_sysconf("sysconf says _POSIX_TIMERS =", _SC_TIMERS);
#else
	printf("no symbol for _POSIX_TIMERS\n");
#endif
	printf("\n");
#ifdef _POSIX_TYPED_MEMORY_OBJECTS
	printf("_POSIX_TYPED_MEMORY_OBJECTS is defined (val is %ld)\n", (long)_POSIX_TYPED_MEMORY_OBJECTS+0);
#else
	printf("_POSIX_TYPED_MEMORY_OBJECTS is undefined\n");
#endif
#ifdef _SC_TYPED_MEMORY_OBJECTS
	pr_sysconf("sysconf says _POSIX_TYPED_MEMORY_OBJECTS =", _SC_TYPED_MEMORY_OBJECTS);
#else
	printf("no symbol for _POSIX_TYPED_MEMORY_OBJECTS\n");
#endif
	printf("\n");
#ifdef _POSIX_VERSION
	printf("_POSIX_VERSION is defined (val is %ld)\n", (long)_POSIX_VERSION+0);
#else
	printf("_POSIX_VERSION is undefined\n");
#endif
#ifdef _SC_VERSION
	pr_sysconf("sysconf says _POSIX_VERSION =", _SC_VERSION);
#else
	printf("no symbol for _POSIX_VERSION\n");
#endif
	printf("\n");
#ifdef _XOPEN_CRYPT
	printf("_XOPEN_CRYPT is defined (val is %ld)\n", (long)_XOPEN_CRYPT+0);
#else
	printf("_XOPEN_CRYPT is undefined\n");
#endif
#ifdef _SC_XOPEN_CRYPT
	pr_sysconf("sysconf says _XOPEN_CRYPT =", _SC_XOPEN_CRYPT);
#else
	printf("no symbol for _XOPEN_CRYPT\n");
#endif
	printf("\n");
#ifdef _XOPEN_ENH_I18N
	printf("_XOPEN_ENH_I18N is defined (val is %ld)\n", (long)_XOPEN_ENH_I18N+0);
#else
	printf("_XOPEN_ENH_I18N is undefined\n");
#endif
#ifdef _SC_XOPEN_ENH_I18N
	pr_sysconf("sysconf says _XOPEN_ENH_I18N =", _SC_XOPEN_ENH_I18N);
#else
	printf("no symbol for _XOPEN_ENH_I18N\n");
#endif
	printf("\n");
#ifdef _XOPEN_REALTIME
	printf("_XOPEN_REALTIME is defined (val is %ld)\n", (long)_XOPEN_REALTIME+0);
#else
	printf("_XOPEN_REALTIME is undefined\n");
#endif
#ifdef _SC_XOPEN_REALTIME
	pr_sysconf("sysconf says _XOPEN_REALTIME =", _SC_XOPEN_REALTIME);
#else
	printf("no symbol for _XOPEN_REALTIME\n");
#endif
	printf("\n");
#ifdef _XOPEN_REALTIME_THREADS
	printf("_XOPEN_REALTIME_THREADS is defined (val is %ld)\n", (long)_XOPEN_REALTIME_THREADS+0);
#else
	printf("_XOPEN_REALTIME_THREADS is undefined\n");
#endif
#ifdef _SC_XOPEN_REALTIME_THREADS
	pr_sysconf("sysconf says _XOPEN_REALTIME_THREADS =", _SC_XOPEN_REALTIME_THREADS);
#else
	printf("no symbol for _XOPEN_REALTIME_THREADS\n");
#endif
	printf("\n");
#ifdef _XOPEN_SHM
	printf("_XOPEN_SHM is defined (val is %ld)\n", (long)_XOPEN_SHM+0);
#else
	printf("_XOPEN_SHM is undefined\n");
#endif
#ifdef _SC_XOPEN_SHM
	pr_sysconf("sysconf says _XOPEN_SHM =", _SC_XOPEN_SHM);
#else
	printf("no symbol for _XOPEN_SHM\n");
#endif
	printf("\n");
#ifdef _XOPEN_UNIX
	printf("_XOPEN_UNIX is defined (val is %ld)\n", (long)_XOPEN_UNIX+0);
#else
	printf("_XOPEN_UNIX is undefined\n");
#endif
#ifdef _SC_XOPEN_UNIX
	pr_sysconf("sysconf says _XOPEN_UNIX =", _SC_XOPEN_UNIX);
#else
	printf("no symbol for _XOPEN_UNIX\n");
#endif
	printf("\n");
#ifdef _XOPEN_UUCP
	printf("_XOPEN_UUCP is defined (val is %ld)\n", (long)_XOPEN_UUCP+0);
#else
	printf("_XOPEN_UUCP is undefined\n");
#endif
#ifdef _SC_XOPEN_UUCP
	pr_sysconf("sysconf says _XOPEN_UUCP =", _SC_XOPEN_UUCP);
#else
	printf("no symbol for _XOPEN_UUCP\n");
#endif
	printf("\n");
#ifdef _XOPEN_VERSION
	printf("_XOPEN_VERSION is defined (val is %ld)\n", (long)_XOPEN_VERSION+0);
#else
	printf("_XOPEN_VERSION is undefined\n");
#endif
#ifdef _SC_XOPEN_VERSION
	pr_sysconf("sysconf says _XOPEN_VERSION =", _SC_XOPEN_VERSION);
#else
	printf("no symbol for _XOPEN_VERSION\n");
#endif
	printf("\n");
#ifdef _POSIX_CHOWN_RESTRICTED
	printf("_POSIX_CHOWN_RESTRICTED is defined (val is %ld)\n", (long)_POSIX_CHOWN_RESTRICTED+0);
#else
	printf("_POSIX_CHOWN_RESTRICTED is undefined\n");
#endif
#ifdef _PC_CHOWN_RESTRICTED
	pr_pathconf("pathconf says _POSIX_CHOWN_RESTRICTED =", argv[1], _PC_CHOWN_RESTRICTED);
#else
	printf("no symbol for _POSIX_CHOWN_RESTRICTED\n");
#endif
	printf("\n");
#ifdef _POSIX_NO_TRUNC
	printf("_POSIX_NO_TRUNC is defined (val is %ld)\n", (long)_POSIX_NO_TRUNC+0);
#else
	printf("_POSIX_NO_TRUNC is undefined\n");
#endif
#ifdef _PC_NO_TRUNC
	pr_pathconf("pathconf says _POSIX_NO_TRUNC =", argv[1], _PC_NO_TRUNC);
#else
	printf("no symbol for _POSIX_NO_TRUNC\n");
#endif
	printf("\n");
#ifdef _POSIX_VDISABLE
	printf("_POSIX_VDISABLE is defined (val is %ld)\n", (long)_POSIX_VDISABLE+0);
#else
	printf("_POSIX_VDISABLE is undefined\n");
#endif
#ifdef _PC_VDISABLE
	pr_pathconf("pathconf says _POSIX_VDISABLE =", argv[1], _PC_VDISABLE);
#else
	printf("no symbol for _POSIX_VDISABLE\n");
#endif
	printf("\n");
#ifdef _POSIX_ASYNC_IO
	printf("_POSIX_ASYNC_IO is defined (val is %ld)\n", (long)_POSIX_ASYNC_IO+0);
#else
	printf("_POSIX_ASYNC_IO is undefined\n");
#endif
#ifdef _PC_ASYNC_IO
	pr_pathconf("pathconf says _POSIX_ASYNC_IO =", argv[1], _PC_ASYNC_IO);
#else
	printf("no symbol for _POSIX_ASYNC_IO\n");
#endif
	printf("\n");
#ifdef _POSIX_PRIO_IO
	printf("_POSIX_PRIO_IO is defined (val is %ld)\n", (long)_POSIX_PRIO_IO+0);
#else
	printf("_POSIX_PRIO_IO is undefined\n");
#endif
#ifdef _PC_PRIO_IO
	pr_pathconf("pathconf says _POSIX_PRIO_IO =", argv[1], _PC_PRIO_IO);
#else
	printf("no symbol for _POSIX_PRIO_IO\n");
#endif
	printf("\n");
#ifdef _POSIX_SYNC_IO
	printf("_POSIX_SYNC_IO is defined (val is %ld)\n", (long)_POSIX_SYNC_IO+0);
#else
	printf("_POSIX_SYNC_IO is undefined\n");
#endif
#ifdef _PC_SYNC_IO
	pr_pathconf("pathconf says _POSIX_SYNC_IO =", argv[1], _PC_SYNC_IO);
#else
	printf("no symbol for _POSIX_SYNC_IO\n");
#endif
	printf("\n");
#ifdef _POSIX2_SYMLINKS
	printf("_POSIX2_SYMLINKS is defined (val is %ld)\n", (long)_POSIX2_SYMLINKS+0);
#else
	printf("_POSIX2_SYMLINKS is undefined\n");
#endif
#ifdef _PC_2_SYMLINKS
	pr_pathconf("pathconf says _POSIX2_SYMLINKS =", argv[1], _PC_2_SYMLINKS);
#else
	printf("no symbol for _POSIX2_SYMLINKS\n");
#endif
	printf("\n");
	exit(0);
}

static void pr_sysconf(char *mesg, int name)
{
	long	val;

	fputs(mesg, stdout);
	errno = 0;
	if ((val = sysconf(name)) < 0) {
		if (errno != 0) {
			if (errno == EINVAL) {
				fputs(" (not supported)\n", stdout);
			}
			else {
				printf("sysconf error");
				exit(-1);
			}
		} else {
			fputs(" (no limit)\n", stdout);
		}
	} else {
		printf(" %ld\n", val);
	}
}

static void pr_pathconf(char *mesg, char *path, int name)
{
	long	val;

	fputs(mesg, stdout);
	errno = 0;
	if ((val = pathconf(path, name)) < 0) {
		if (errno != 0) {
			if (errno == EINVAL) {
				fputs(" (not supported)\n", stdout);
			}
			else {
				printf("pathconf error, path = %s", path);
				exit(-1);
			}
		} else {
			fputs(" (no limit)\n", stdout);
		}
	} else {
		printf(" %ld\n", val);
	}
}

myopenmax.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <sys/types.h>
#include<sys/resource.h>

#define OPEN_MAX_GUESS 256

long open_max(void);

int main(int argc,char*argv[])
{
	printf("open_max=%ld\n",
			open_max());
	return 0;
}

long open_max(void){
	long openmax;
	struct rlimit r1;

	if((openmax=sysconf(_SC_OPEN_MAX))<-1||
			openmax==LONG_MAX){
		if(getrlimit(RLIMIT_NOFILE,&r1))
		{
			printf("can't get file limit\n");
			exit(-1);
		}
		if(r1.rlim_max==RLIM_INFINITY)
			openmax=OPEN_MAX_GUESS;
		else
			openmax=r1.rlim_max;	
	}
	return openmax;
}

文件IO：不带缓冲的IO
一、打开、创建文件、关闭文件

    文件描述符 ：一个非负整数，范围是0~OPEN_MAX-1。内核用它来标识进程正在访问的文件。当进程创建时，默认为它打开了3个文件描述符，它们都链接向终端：
        0： 标准输入
        1： 标准输出
        2： 标准错误输出

    通常我们应该使用STDIN_FILENO，STDOUT_FILENO和 STDERR_FILENO来替代这三个幻数，从而提高可读性。这三个常量位于<unistd.h>中。

    open和openat函数：打开文件

    #include<fcntl.h>
    int open(const char* path,int oflag,.../*mode_t mode*/);
    int openat(int fd,const char*path,int oflag,.../*mode_t mode */);

        参数：

            path:要打开或者创建文件的名字

            oflag：用于指定函数的操作行为：
                O_RDONLY常量：文件只读打开
                O_WRONLY常量：文件只写打开
                O_RDWR常量：文件读、写打开
                O_EXEC常量：只执行打开
                O_SEARCH常量：只搜索打开（应用于目录）。本文涉及的操作系统都没有支持该常量

            在上面五个常量中必须指定且只能指定一个。下面的常量是可选的（进行或运行）：
                O_APPEND：每次写时都追加到文件的尾端
                O_CLOEXEC：将FD_CLOEXEC常量设置为文件描述符标志
                O_CREAT：若此文件不存在则创建它。在使用此选项时，需要同时说明参数mode（指定该文件的访问权限）
                O_DIRECTORY：若path引用的不是目录，则出错
                O_EXCL：若同时指定了O_CREAT时，且文件已存在则出错。根据此可以测试一个文件是否存在。若不存在则创建此文件。这使得测试和创建两者成为一个原子操作
                O_NOCTTY：若path引用的是终端设备，则不将该设备分配作为此进程的控制终端
                O_NOFOLLOW：若path引用的是一个符号链接，则出错
                O_NONBLOCK：如果path引用的是一个FIFO、一个块特殊文件或者一个字符特殊文件，则文件本次打开操作和后续的 I/O 操作设为非阻塞模式。
                O_SYNC：每次 write 等待物理 I/O 完成，包括由 write 操作引起的文件属性更新所需的 I/O
                O_TRUNC： 如果此文件存在，且为O_WRONLY或者O_RDWR成功打开，则将其长度截断为0
                O_RSYNC：使每一个read操作等待，直到所有对文件同一部分挂起的写操作都完成。
                O_DSYNC：每次 write 等待物理 I/O 完成，但不包括由 write 操作引起的文件属性更新所需的 I/O

            mode：文件访问权限。文件访问权限常量在 <sys/stat.h> 中定义，有下列九个：
                S_IRUSR：用户读
                S_IWUSR：用户写
                S_IXUSR：用户执行
                S_IRGRP：组读
                S_IWGRP：组写
                S_IXGRP：组执行
                S_IROTH：其他读
                S_IWOTH：其他写
                S_IXOTH：其他执行

        对于openat函数，被打开的文件名由fd和path共同决定：
            如果path指定的是绝对路径，此时fd被忽略。openat等价于open
            如果path指定的是相对路径名，则fd是一个目录打开的文件描述符。被打开的文件的绝对路径由该fd描述符对应的目录加上path组合而成
            如果path是一个相对路径名，而fd是常量AT_FDCWD，则path相对于当前工作目录。被打开文件在当前工作目录中查找。

        返回值：
            成功：返回文件描述符。
            失败：返回 -1

    由 open/openat 返回的文件描述符一定是最小的未使用的描述符数字。

    creat函数：创建一个新文件

    #include<fcntl.h>
    int creat(const char*path,mode_t mode);

        参数：
            path:要创建文件的名字
            mode：指定该文件的访问权限文件访问权限常量在 <sys/stat.h> 中定义，有下列九个：
                S_IRUSR：用户读
                S_IWUSR：用户写
                S_IXUSR：用户执行
                S_IRGRP：组读
                S_IWGRP：组写
                S_IXGRP：组执行
                S_IROTH：其他读
                S_IWOTH：其他写
                S_IXOTH：其他执行
        返回值：
            成功： 返回O_WRONLY打开的文件描述符
            失败： 返回 -1

    该函数等价于open(path,O_WRONLY|O_CREAT|O_TRUNC,mode)。注意：
        它以只写方式打开，因此若要读取该文件，则必须先关闭，然后重新以读方式打开。
        若文件已存在则将文件截断为0。

- 若文件存在：
	- 简单的open()成功打开
	- 带O_CREAT选项的open()成功打开
	- 带O_CREAT|O_EXCL选项的open()打开失败
	- creat()成功打开并且将文件截断为0
- 若文件不存在：
	- 简单的open()打开失败
	- 带O_CREAT选项的open()成功创建文件，打开并且将文件截断为0
	- 带O_CREAT|O_EXCL选项的open()成功创建文件，打开并且将文件截断为0
	- creat()成功创建文件，打开并且将文件截断为0

    close函数：关闭文件

    #include<unistd.h>
    int close(int fd);

        参数：
            fd：待关闭文件的文件描述符
        返回值：
            成功：返回 0
            失败：返回 -1

    注意：
        进程关闭一个文件会释放它加在该文件上的所有记录锁。
        当一个进程终止时，内核会自动关闭它所有的打开的文件。

二、定位、读、写文件

    lseek函数：设置打开文件的偏移量

    #include<unistd.h>
    off_t lseek(int fd, off_t offset,int whence);

        参数：
            fd：打开的文件的文件描述符
            whence：必须是 SEEK_SET、SEEK_CUR、SEEK_END三个常量之一
            offset：
                如果 whence是SEEK_SET，则将该文件的偏移量设置为距离文件开始处offset个字节
                如果 whence 是 SEEK_CUR，则将该文件的偏移量设置为当前值加上offset个字节，offset可正，可负
                如果 whence 是 SEEK_END，则将该文件的偏移量设置为文件长度加上offset个字节，offset可正，可负
        返回值：
            成功： 返回新的文件偏移量
            失败：返回 -1

    每个打开的文件都有一个与其关联的“当前文件偏移量”。它通常是个非负整数，用于度量从文件开始处计算的字节数。通常读、写操作都从当前文件偏移量处开始，并且使偏移量增加所读写的字节数。注意：
        打开一个文件时，除非指定O_APPEND选项，否则系统默认将该偏移量设为0
        如果文件描述符指定的是一个管道、FIFO、或者网络套接字，则无法设定当前文件偏移量，则lseek将返回 -1 ，并且将 errno 设置为 ESPIPE。
        对于普通文件，其当前文件偏移量必须是非负值。但是某些设备允许负的偏移量出现。因此比较lseek的结果时，不能根据它小于0 就认为出错。要根据是否等于 -1 来判断是否出错。
        lseek 并不会引起任何 I/O 操作，lseek仅仅将当前文件的偏移量记录在内核中。
        当前文件偏移量可以大于文件的当前长度。此时对该文件的下一次写操作将加长该文件，并且在文件中构成一个空洞。空洞中的内容位于文件中但是没有被写过，其字节被读取时都被读为0

        文件中的空洞并不要求在磁盘上占据存储区。具体处理方式与操作系统有关

    read函数：读取文件内容

    #include<unistd.h>
    ssize_t read(int fd,void *buf,size_t nbytes);

        参数：
            fd：打开的文件的文件描述符
            buf：存放读取内容的缓冲区的地址（由程序员手动分配）
            nbytes：期望读到的字节数
        返回值：
            成功：返回读到的字节数，若已到文件尾则返回 0
            失败：返回 -1

    读操作从文件的当前偏移量开始，在成功返回之前，文件的当前偏移量会增加实际读到的字节数。有多种情况可能导致实际读到的字节数少于期望读到的字节数：
        读普通文件时，在读到期望字节数之前到达了文件尾端
        当从终端设备读时，通常一次最多读取一行（终端默认是行缓冲的）
        当从网络读时，网络中的缓存机制可能造成返回值小于期望读到的字节数
        当从管道或者FIFO读时，若管道包含的字节少于所需的数量，则 read只返回实际可用的字节数
        当从某些面向记录的设备（如磁带）中读取时，一次最多返回一条记录
        当一个信号造成中断，而已读了部分数据时。

    write函数：想文件写数据

    #include<unistd.h>
    ssize_t write(int fd,const void *buf,size_t nbytes);

        参数：
            fd：打开的文件的文件描述符
            buf：存放待写的数据内容的缓冲区的地址（由程序员手动分配）
            nbytes：期望写入文件的字节数
        返回值：
            成功：返回已写的字节数
            失败：返回 -1

    write的返回值通常都是与nbytes相同。否则表示出错。write出错的一个常见原因是磁盘写满，或者超过了一个给定进行的文件长度限制

    对于普通文件，写操作从文件的当前偏移量处开始。如果打开文件时指定了O_APPEND选项，则每次写操作之前，都会将文件偏移量设置在文件的当前结尾处。在一次成功写之后，该文件偏移量增加实际写的字节数。

三、 原子操作、同步、复制、修改文件描述符

    内核使用三种数据结构描述打开文件。它们之间的关系决定了一个进程与另一个进程在打开的文件之间的相互影响。
        内核为每个进程分配一个进程表项（所有进程表项构成进程表），每个进程表项包含一张打开的文件描述符表。每个文件描述符占用一项，其内容为：
            文件描述符标志
            指向一个文件表项的指针
        内核为每个打开的文件分配一个文件表项（所有的文件表项构成文件表）。每个文件表项的内容包括：
            文件状态标志（读、写、添写、同步和阻塞等）
            当前文件偏移量
            指向该文件 v 结点表项的指针
        每个打开的文件或者设备都有一个 v 结点结构。 v 结点结构的内容包括：
            文件类型和对此文件进行各种操作函数的指针。
            对于大多数文件， v 结点还包含了该文件的 i 结点。

    这些信息都是在打开文件时从磁盘读入内存的。如 i 结点包含了文件的所有者、文件长度、指向文件实际数据在磁盘上所在位置的指针等等。 v 结点结构和 i 结点结构实际上代表了文件的实体。

    现在假设进程 A 打开文件 file1，返回文件描述符 3；进程 B 也打开文件 file1，返回文件描述符 2：

        内核在文件表上新增两个表项：
            这两个文件表项指向同一个 v 结点表项
            进程 A 、B 各自的文件描述符表项分别指向这两个文件表项；
        对文件的操作结果：
            进程 A 每次 write 之后，进程 A 对应的文件表项的当前文件偏移量即增加所写入的字节数。
                若这导致当前文件偏移量超过当前文件长度，则修改 i 节点的当前文件长度，设为当前文件偏移量
            如果进程 B 用 O_APPEND标志打开一个文件，则相应标志也被设置到文件表项的文件状态标志中。
                每次进程 B 对具有追加写标志的文件执行写操作时，文件表项中的当前文件偏移量首先被置为 i 结点中的文件长度。
            若进程 B 用 lseek 定位到文件当前的尾端，则进程 B 对应的文件表项的当前文件偏移量设置为 i 结点中的当前长度
            lseek 函数只是修改文件表项中的当前文件偏移量，不进行任何 I/O 操作

    可能一个进程中有多个文件描述符指向同一个文件表项。

    原子操作：
        追加一个文件时，不能通过lseek到末尾然后write。要用O_APPEND选项打开文件，然后直接write。
            通过lseek到末尾然后write时，如果多个进程同时执行这两个操作，则会引起竞争条件
            通过 O_APPEND选项打开文件，然后直接write时，内核每一次在写操作之前，都会将进程的当前偏移量设置到文件的末尾，于是就不需要执行lseek定位操作
        pread/pwrite可以执行原子性的定位读/定位写
        O_CREAT|O_EXCL选项打开文件时，可以原子性的检查文件是否存在和创建文件这两个操作。

    pread/pwrite：原子定位读和原子定位写

    #include<unistd.h>
    ssize_t pread(int fd,void*buf,size_t nbytes,off_t offset);
    ssize_t pwrite(int fd,const void*buf,size_t nbytes,off_t offset);

        参数：
            fd：打开的文件描述符
            buf：读出数据存放的缓冲区/ 写到文件的数据的缓冲区
            nbytes：预期读出/写入文件的字节数
            offset：从文件指定偏移量开始执行read/write
        返回：
            成功：读到的字节数/已写的字节数
            失败： -1

    调用pread相当于先调用lseek再调用read.但是调用pread时，无法中断其定位和读操作，并且不更新当前文件偏移量；调用pwrite相当于先调用lseek再调用write.但是调用pwrite时，无法中断其定位和写操作，并且不更新当前文件偏移量

    dup/dup2：复制一个现有的文件描述符：

    #include<unistd.h>
    int dup(int fd);
    int dup2(int fd,int fd2);

        参数：
            fd：被复制的文件描述符（已被打开）
            fd2：指定的新的文件描述符（待生成）
        返回值：
            成功： 返回新的文件描述符
            失败： 返回 -1

    dup_file_descriptor

    对于dup函数，返回的新的文件描述符一定是当前可用的文件描述符中最小的数字。对于dup2函数：
        如果 fd2已经是被打开的文件描述符且不等于fd，则先将其关闭，然后再打开（注意关闭再打开是一个原子操作）
        如果 fd2等于fd，则直接返回fd2（也等于fd），而不作任何操作

    任何情况下，这个返回的新的文明描述符与参数fd共享同一个文件表项（因此文件状态标志以及文件偏移量都会共享）。 任何情况下，这个返回的新的文件描述符的close-on-exec标志总是被清除

    UNIX操作系统在内核中设有缓冲区，大多数磁盘 I/O 都通过缓冲区进行。当我们想文件写入数据时，内核通常都首先将数据复制到缓冲区中，然后排入队列，晚些时候再写入磁盘。这种方式称为延迟写。
        当内核需要重用缓冲区来存方其他数据时，它会把所有延迟写的数据库写入磁盘
        你也可以调用下列函数来显式的将延迟写的数据库写入磁盘

    #include<unistd.h>
    int fsync(int fd);
    int fdatasync(int fd);
    void sync(void);

        参数（前两个函数）：
            fd：指定的打开的文件描述符

        返回值（前两个函数）：
            成功：返回 0
            失败： 返回 -1

    区别：
        sync：将所有修改过的块缓冲区排入写队列，然后返回，它并不等待时机写磁盘结束
        fsync：只对由fd指定的单个文件起作用，等待写磁盘操作结束才返回
        fdatasync：只对由fd指定的单个文件起作用，等待写磁盘操作结束才返回，但是它只影响文件的数据部分（fsync会同步更新文件的属性）

        update 守护进程会周期性的调用sync函数。命令sync也会调用sync函数

    fcntl函数：改变已经打开的文件的属性

    #include<fcntl.h>
    int fcntl(int fd,int cmd,.../* int arg */);

        参数：
            fd：已打开文件的描述符
            cmd：有下列若干种：
                F_DUPFD常量：复制文件描述符 fd。新文件描述符作为函数值返回。它是尚未打开的文件描述符中大于或等于arg中的最小值。新文件描述符与fd共享同一个文件表项，但是新描述符有自己的一套文件描述符标志，其中FD_CLOEXEC文件描述符标志被清除
                F_DUPFD_CLOEXEC常量：复制文件描述符。新文件描述符作为函数值返回。它是尚未打开的个描述符中大于或等于arg中的最小值。新文件描述符与fd共享同一个文件表项，但是新描述符有自己的一套文件描述符标志，其中FD_CLOEXEC文件描述符标志被设置
                F_GETFD常量：对应于fd的文件描述符标志作为函数值返回。当前只定义了一个文件描述符标志FD_CLOEXEC
                F_SETFD常量：设置fd的文件描述符标志为arg
                F_GETFL常量：返回fd的文件状态标志。文件状态标志必须首先用屏蔽字 O_ACCMODE 取得访问方式位，然后与O_RDONLY、O_WRONLY、O_RDWR、O_EXEC、O_SEARCH比较（这5个值互斥，且并不是各占1位）。剩下的还有：O_APPEND、O_NONBLOCK、O_SYNC 、O_DSYNC、O_RSYNC、F_ASYNC、O_ASYNC
                F_SETFL常量：设置fd的文件状态标志为 arg。可以更改的标志是： O_APPEND、O_NONBLOCK、O_SYNC、O_DSYNC、O_RSYNC、F_ASYNC、O_ASYNC
                F_GETOWN常量：获取当前接收 SIGIO和SIGURG信号的进程 ID或者进程组 ID
                F_SETOWN常量：设置当前接收 SIGIO和SIGURG信号的进程 ID或者进程组 ID为arg。若 arg是个正值，则设定进程 ID；若 arg是个负值，则设定进程组ID
                F_GETLK、F_SETLK、F_SETLKW：获取/设置文件记录锁
            arg：依赖于具体的命令

        返回值：
            成功： 依赖于具体的命令
            失败： 返回 -1

注意：
- Linux 下，不支持文件状态标志： F_EXEC与， F_SEARCH
- (result&O_ACCMODE)==O_RDONLY 表达式中， &优先级较低
- F_SETFL命令：当文件读打开时，你无法将文件状态标志修改为O_WRONLY、O_RDWR这两种中任何一个。你只能修改：O_APPEND、O_NONBLOCK、O_SYNC、O_DSYNC、O_RSYNC、F_ASYNC、O_ASYNC等标志

    /dev/fd目录：该目录下是名为0、1、2等的文件。打开文件/dev/fd/n等效于复制描述符（假定描述符n是打开的）
        fd=open("/dev/fd/0",mod)：fd和文件描述符0共享同一个文件表项。
        大多数系统忽略mod参数
        在 Linux 操作系统上， /dev/fd/0是个例外，它是个底层物理文件的符号链接。因此在它上面调用creat 会导致底层文件被截断

mylseek.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

int main(int argc, char const *argv[])
{
	if(lseek(STDIN_FILENO,0,SEEK_SET)==0)
		printf("cannot seek\n");
	else
		printf("seek ok\n");
	exit(0);	
}

myfilehole.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

char buf1[]="abcdefghij";
char buf2[]="ABCDEFGHIJ";

int main(int argc, char const *argv[])
{
	int fd;

	if((fd=creat("file.hole",FILE_MODE))<0) {
		printf("create error");
		exit(-1);
	}
	if(write(fd,buf1,10)!=10) {
		printf("buf1 write error");
		exit(-1);
	}
	if(lseek(fd,16384,SEEK_SET)==-1) {
		printf("lseek error");
		exit(-1);
	}
	if(write(fd,buf2,10)!=10) {
		printf("buf2 write error");
		exit(-1);
	}
	printf("%dKB\n",(int)(lseek(fd,0,SEEK_END)-lseek(fd,0,SEEK_SET))/1024);
	close(fd);
	exit(0);	
}

mytexthole.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

int main(int argc, char const *argv[])
{
	int fd, n;

	if((fd = open("text.hole",O_RDWR | O_CREAT | O_TRUNC, 0666)) < 0)
	{
		perror("open error");
		exit(EXIT_FAILURE);
	}

	/* 偏移量6 */
	if((n = write(fd, "hello\n", 6)) != 6)
	{
		perror("write first error");
		exit(EXIT_FAILURE);
	}

	/* 偏移量26 */
	if(lseek(fd, 20, SEEK_CUR) == -1)
	{
		perror("lseek error");
		exit(EXIT_FAILURE);
	}

	/* 偏移量32，中间有20个字节的hole */
	if((n = write(fd, "hello\n", 6)) != 6)
	{
		perror("write second error");
		exit(EXIT_FAILURE);
	}

	close(fd);
	return 0;
}

myappendlseek.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

#define BUFSIZE 4096

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(-1);
}

int main(int argc,char*argv[])
{
	int n;
	char buf[BUFSIZE];

	if (argc != 2)
		err_sys("Usage:command filename\n");

	int fd;
	if ((fd = open(argv[1], O_RDWR | O_APPEND | O_CREAT)) < 0)
		err_sys("open error\n");
	if (write(fd, "show me the code\n", 17) != 17)
		err_sys("append write error\n");

	if (lseek(fd, 0, SEEK_SET) < 0)
		err_sys("lseek error\n");
	while((n=read(fd,buf,BUFSIZE))>0) {
		if(write(STDOUT_FILENO,buf,n)!=n)
			err_sys("write error");
	}
	if(n<0)
		err_sys("read error");

	if (lseek(fd, 0, SEEK_SET) < 0)
		err_sys("lseek error\n");
	if (write(fd, "write from start\n", 17) != 17)
		err_sys("write error\n");

	close(fd);
	exit(0);
}

myopenat.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

int main(int agrc, char *argv[])
{
	int dirfd;
	int fd;
	/* 打开一个目录 */
	if((dirfd = open("test", O_RDONLY | O_DIRECTORY)) < 0)
	{
		perror("open dirfd error");
		exit(EXIT_FAILURE);
	}
#if 0 
	/* 在dirfd所表示的目录下打开文件text.txt */
	if((fd = openat(dirfd, "text.txt", O_RDWR | O_CREAT, 0666)) < 0)
	{
		perror("openat error");
		exit(EXIT_FAILURE);
	}

	/* pathname是绝对路径，忽略dirfd，直接创建/home/stone/test_my/text.txt文件 */
	if((fd = openat(dirfd, "/home/stone/test_my/text.txt", O_RDWR | O_CREAT, 0666)) < 0)
	{
		perror("openat error");
		exit(EXIT_FAILURE);
	}
#endif
	/* 无论pathname是相对路径还是绝对路径<必须是指向一个文件>，只要dirfd是AT_FDCWD，openat和open等价 */
	if((fd = openat(AT_FDCWD, "text.txt", O_RDWR | O_CREAT, 0666)) < 0)
	{
		perror("openat error");
		exit(EXIT_FAILURE);
	}

	write(fd, "hello text.txt\n", 15);
	close(fd);
	close(dirfd);
	return 0;
}

mycp.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

#define BUFSIZE 4096

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(-1);
}

int main(int argc,char*argv[])
{
	int n;
	char buf[BUFSIZE];
	while((n=read(STDIN_FILENO,buf,BUFSIZE))>0)
		if(write(STDOUT_FILENO,buf,n)!=n)
			err_sys("write error");
	if(n<0)
		err_sys("read error");
	exit(0);	
}

mypread.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

#define BUFSIZE 4096

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(-1);
}

int main(void)
{
	int fd, n;
	char buf[BUFSIZE];
	if((fd=open("outfile",O_RDONLY)) < 0)
		err_sys("open error");

	if ((n = pread(fd, buf, BUFSIZE, 0)) > 0) {
		if (write(STDOUT_FILENO, buf, n) != n)
			err_sys("write error");
	}
	else if(n<0)
		err_sys("pread error");

	while ((n = read(fd, buf, BUFSIZE)) > 0)
		if (write(STDOUT_FILENO, buf, n) != n)
			err_sys("write error");
	if (n < 0)
		err_sys("read error");

	exit(0);
}

mydup2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

#define OPEN_MAX ((int)sysconf(_SC_OPEN_MAX)) /* 一个进程最多能打开的文件数，也是文件描述符的最大值 */

int mydup2(int oldfd, int newfd)
{
	int i, j, fd[OPEN_MAX];
	/* 首先检验文件描述符的范围是否正确 */
	if (oldfd < 0 || oldfd > (OPEN_MAX-1))
	{
		perror("oldfd error");
		return -1;
	}
	if(newfd < 0 || newfd > (OPEN_MAX - 1))
	{
		perror("newfd error");
		return -1;
	}
	/* 相等时返回newfd */
	if(oldfd == newfd)
		return newfd;
	/* 先关闭newfd，好让dup时能有机会选择newfd作为返回值 */
	close(newfd);
	for(i=0; i<OPEN_MAX; i++)
	{
		if((fd[i] = dup(oldfd)) < 0)
		{
			perror("dup error");
			return -1;
		}

		/* 关掉之前dup出来的文件描述符 */
		if(fd[i] == newfd)
		{
			for(j=0; j<i; j++)
				close(fd[j]);
			return newfd;
		}
	}
	return -1;
}

int main(int argc, char const *argv[])
{
	int retfd;
	if((retfd = mydup2(2, 5)) < 0)
	{
		perror("mydup2 error");
		return -1;
	}
	printf("dup result:%d\n", retfd);
	return 0;
}

mytouch.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(-1);
}

int main(int argc, char** argv)
{
	if (argc != 2) {
		fprintf(stderr, "Usage:mytouch filename\n");
		exit(0);
	}
	int fd;
	if ((fd = open(argv[1], O_WRONLY | O_CREAT | O_EXCL | O_TRUNC)) < 0)
		err_sys("this file has existed");
	else
		close(fd);
	exit(0);
}

myfcntlget.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

int main(int argc, char const *argv[])
{
	int val;
	if(argc != 2)
	{
		printf("need a file name\n");
		return -1;
	}
	/* F_GETFL获取访问属性 */
	if((val = fcntl(atoi(argv[1]), F_GETFL, 0)) < 0)
	{
		perror("fcntl error");
		return -1;
	}

	/* 基础访问属性 */
	switch(val & O_ACCMODE){
		case O_RDONLY:
			printf("read only");
			break;
		case O_WRONLY:
			printf("write only");
			break;
		case O_RDWR:
			printf("read or write");
			break;
		default:
			printf("unknow access mode");
	}

	/* 扩展访问属性 */
	if(val & O_APPEND)
		printf(", append");
	if(val & O_NONBLOCK)
		printf("nonblock");
	if(val & O_SYNC)
		printf("sync");
#if !defined(_POSIX_C_SOURCE) && defined(O_FSYNC) && (O_FSYNC != O_SYNC)
	if(val & O_FSYNC)
		printf("fsync");
#endif	
	putchar('\n');
	return 0;
}

在shell执行如下命令
myfcntlget 0 < /dev/tty  -->标准输入文件执行只读的/dev/tty
read only
myfcntlget 1 > temp -->标准输出是只写的
cat temp 
write only
myfcntlget 2 2>>temp  -->把标准错误重定向到temp
write only, append
myfcntlget 5 5<>temp  -->描述符5的访问属性同temp文件一样
read or write

mycpsync.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(-1);
}

void set_fsflag(int fd, int flags) {
	int val;
	if ((val = fcntl(fd, F_GETFL, 0)) < 0)
		err_sys("fcntl F_GETFL error");
	
	val |= flags;

	if (fcntl(fd, F_SETFL, val) < 0)
		err_sys("fcntl F_SETFL error");
}

void close_fsflag(int fd, int flags) {
	int val;
	if ((val = fcntl(fd, F_GETFL, 0)) < 0)
		err_sys("fcntl F_GETFL error");

	val &= ~flags;

	if (fcntl(fd, F_SETFL, val) < 0)
		err_sys("fcntl F_SETFL error");
}

#define BUFSIZE 4096

int main(int argc, char const *argv[])
{
	int n;
	char buf[BUFSIZE];
	set_fsflag(STDOUT_FILENO, O_SYNC);
	
	//检测O_SYNC文件状态标志是否被设置
	if((n=fcntl(STDOUT_FILENO,F_GETFL,0))<0)
		err_sys("fcntl error for fd STDOUT_FILENO");
	if(n&O_SYNC)printf("synchronous writes");
	else printf("synchronous write isn't valid\n");

	while ((n = read(STDIN_FILENO, buf, BUFSIZE)) > 0)
		if (write(STDOUT_FILENO, buf, n) != n)
			err_sys("write error");
	if (n < 0)
		err_sys("read error");
	exit(0);
}

mycpsync_fsync.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(-1);
}

void set_fsflag(int fd, int flags) {
	int val;
	if ((val = fcntl(fd, F_GETFL, 0)) < 0)
		err_sys("fcntl F_GETFL error");
	
	val |= flags;

	if (fcntl(fd, F_SETFL, val) < 0)
		err_sys("fcntl F_SETFL error");
}

void close_fsflag(int fd, int flags) {
	int val;
	if ((val = fcntl(fd, F_GETFL, 0)) < 0)
		err_sys("fcntl F_GETFL error");

	val &= ~flags;

	if (fcntl(fd, F_SETFL, val) < 0)
		err_sys("fcntl F_SETFL error");
}

#define BUFSIZE 4096

int main(int argc, char const *argv[])
{
	int val;
	char buf[BUFSIZE];
	set_fsflag(STDOUT_FILENO, O_SYNC);
	while ((val = read(STDIN_FILENO, buf, BUFSIZE)) > 0) {
		if (write(STDOUT_FILENO, buf, val) != val)
			err_sys("write error");
		fsync(STDOUT_FILENO);
	}

	if (val < 0)err_sys("read error");
	exit(0);
}

mycp_realsync.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(-1);
}

void set_fsflag(int fd, int flags) {
	int val;
	if ((val = fcntl(fd, F_GETFL, 0)) < 0)
		err_sys("fcntl F_GETFL error");
	
	val |= flags;

	if (fcntl(fd, F_SETFL, val) < 0)
		err_sys("fcntl F_SETFL error");
}

void close_fsflag(int fd, int flags) {
	int val;
	if ((val = fcntl(fd, F_GETFL, 0)) < 0)
		err_sys("fcntl F_GETFL error");

	val &= ~flags;

	if (fcntl(fd, F_SETFL, val) < 0)
		err_sys("fcntl F_SETFL error");
}

#define BUFSIZE 4096

int main(int argc, char* argv[])
{
	if (argc != 2) {
		fprintf(stderr, "Usage:command outfile_name\n");
		exit(-1);
	}
	int val, fd;
	char buf[BUFSIZE];
	if ((fd = open(argv[1], O_WRONLY | O_CREAT | O_SYNC | O_TRUNC)) < 0)
		err_sys("open error\n");

	if ((val = fcntl(fd, F_GETFL, 0)) < 0)
		err_sys("get file status flags error\n");
	if (val & O_SYNC)printf("synchronous write valid\n");
	else printf("synchronous write invalid\n");

	while ((val = read(STDIN_FILENO, buf, BUFSIZE)) > 0)
		if (write(fd, buf, val) != val)
			err_sys("write error\n");
	if (val < 0)
		err_sys("read error\n");
	exit(0);
}

mycp_nosync.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(-1);
}

void set_fsflag(int fd, int flags) {
	int val;
	if ((val = fcntl(fd, F_GETFL, 0)) < 0)
		err_sys("fcntl F_GETFL error");
	
	val |= flags;

	if (fcntl(fd, F_SETFL, val) < 0)
		err_sys("fcntl F_SETFL error");
}

void close_fsflag(int fd, int flags) {
	int val;
	if ((val = fcntl(fd, F_GETFL, 0)) < 0)
		err_sys("fcntl F_GETFL error");

	val &= ~flags;

	if (fcntl(fd, F_SETFL, val) < 0)
		err_sys("fcntl F_SETFL error");
}

#define BUFSIZE 4096

int main(int argc, char* argv[])
{
	if (argc != 2) {
		fprintf(stderr, "Usage:command outfile_name\n");
		exit(-1);
	}
	int val, fd;
	char buf[BUFSIZE];
	if ((fd = open(argv[1], O_WRONLY | O_CREAT | O_TRUNC)) < 0)
		err_sys("open error\n");

	if ((val = fcntl(fd, F_GETFL, 0)) < 0)
		err_sys("get file status flags error\n");
	if (val & O_SYNC)printf("synchronous write valid\n");
	else printf("synchronous write invalid\n");

	while ((val = read(STDIN_FILENO, buf, BUFSIZE)) > 0)
		if (write(fd, buf, val) != val)
			err_sys("write error\n");
	if (val < 0)
		err_sys("read error\n");
	exit(0);
}

mycpfdatasync.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(-1);
}

void set_fsflag(int fd, int flags) {
	int val;
	if ((val = fcntl(fd, F_GETFL, 0)) < 0)
		err_sys("fcntl F_GETFL error");
	
	val |= flags;

	if (fcntl(fd, F_SETFL, val) < 0)
		err_sys("fcntl F_SETFL error");
}

void close_fsflag(int fd, int flags) {
	int val;
	if ((val = fcntl(fd, F_GETFL, 0)) < 0)
		err_sys("fcntl F_GETFL error");

	val &= ~flags;

	if (fcntl(fd, F_SETFL, val) < 0)
		err_sys("fcntl F_SETFL error");
}

#define BUFSIZE 4096

int main(void)
{
	int val;
	char buf[BUFSIZE];
	while ((val = read(STDIN_FILENO, buf, BUFSIZE)) > 0) {
		if (write(STDOUT_FILENO, buf, val) != val)
			err_sys("write error");
		fdatasync(STDOUT_FILENO);
	}

	if (val < 0)err_sys("read error");
	exit(0);
}

文件和目录
一、 stat 结构和权限相关

    四个stat函数：返回文件或者目录的信息结构：

    #include<sys/stat.h>
    int stat(const char * restrict pathname, struct stat*restrict buf);
    int fstat(int fd, struct stat* buf);
    int lstat(const char* restrict pathname,struct stat *restrict buf);
    int fstatat(int fd,const char*restrict pathname,struct stat*restrict buf,int flag);

        参数：
            pathname：文件或者目录的名字
            buf：存放信息结构的缓冲区
            fd：打开的文件描述符
                对于fstat，该文件就是待查看信息的文件
                对于fstatat，该文件并不是待查看信息的文件。待查看信息的文件是根据该fd对应的目录进行定位的
            flag：控制着fstatat函数是否跟随一个符号链接。

        对于fstatat函数：
            待查看的文件名是由fd和pathname共同决定的。
                如果pathname是个绝对路径，则忽略fd参数
                如果pathname是个相对路径路径，且 fd=AT_FDCWD，则在当前工作目录的路径下查找pathname
                如果pathname是个相对路径路径，且 fd!=AT_FDCWD，则在fd对应的打开目录下查找pathname
            flag：控制着fstatat函数是否跟随一个符号链接。当!AT_SYMLINK_FOLLOW标志被设置时，查看的是pathname（如果它是个符号链接）本身的信息；否则默认查看的是pathname（如果它是个符号链接）链接引用的文件的信息。

        返回值：
            成功：返回 0
            失败： 返回 -1

    注意：
        lstat类似于stat，但是当pathname是个符号链接时，lstat查看的是该符号链接的有关信息；而stat是查看该符号链接引用的文件的信息。
        在 ubuntu 16.04上，虽然有 AT_SYMLINK_NOFOLLOW这个常量，但是不支持。必须用 !AT_SYMLINK_FOLLOW。

    stat数据结构：其定义可能与具体操作系统相关，但是基本形式为：

    struct stat{
    mode_t 			st_mode; 	//文件权限和类型信息
    ino_t 			st_ino;		//i-node 号
    dev_t 			st_dev;		// 设备号
    dev_t 			st_rdev;	// 特殊文件的设备号
    nlink_t 		st_nlink;	// 硬链接数量
    uid_t 			st_uid;		// owner 的用户ID
    gid_t 			st_gid;		// owner 的组ID
    off_t 			st_size;	//对普通文件，它是文件字节大小
    struct timespec st_atime;	// 上次访问时间
    struct timespec st_mtile;	// 上次修改时间
    struct timespec st_ctime;	// 上次文件状态改变的时间
    blksize_t 		st_blksize;	// 最佳的 I/O block 大小
    blkcnt_t 		st_blocks;	//分配的磁盘块数量
    }

    其中timespec结构与具体操作系统相关，但是至少包括下面两个字段：

    struct timespec{
    time_t tv_sec;	// 秒
    long tv_nsec; 	//纳秒
    	}


3. UNIX 文件类型：
	- 普通文件：最常见的文件类型，这种文件包含了某种形式的数据。至于这种数据是二进制还是文本，对内核无区别。普通文件的内容解释由具体的应用程序进行。
	- 目录文件：这种文件包含了其他文件的名字，以及指向这些文件有关信息的指针。
		- 只有内核可以直接写目录文件（通常用户写目录文件都要通过内核）
		- 对某个目录文件具有读权限的任何一个进程都可以读取该目录的内容
	- 块特殊文件：这种类型的文件提供对设备（如磁盘）带缓冲的访问。每次访问以固定长度为单位进行。
	- 字符特殊文件：这种类型的文件提供对设备不带缓冲的访问，每次访问长度可变。
		系统的所有设备，要么是字符特殊文件，要么是块特殊文件
	- FIFO：这种类型的文件用于进程间通信，有时也称为命名管道
	- 套接字：这种类型的文件用于进程间的网络通信（也可用于单机上进程的非网络通信）
	- 符号链接：这种类型的文件指向另一个文件

	文件类型信息存放在stat.st_mode成员中，可以用下列的宏测试文件类型：
	- S_ISREG()：测试是否普通文件
	- S_ISDIR()：测试是否目录文件
	- S_ISCHR()：测试是否字符特殊文件
	- S_ISBLK()：测试是否块特殊文件
	- S_ISFIFO()：测试是否FIFO
	- S_ISLNK()：测试是否符号链接文件
	- S_ISSOCK()：测试是否套接字

	另外 POSIX.1 允许将进程间通信对象说明为文件。但是下面的宏测试的不是stat.st_mode，而是stat*（stat指针）：
	- S_TYPEISMQ()：测试是否消息队列
	- S_TYPEISSEM()：测试是否信号量
	- S_TYPEISSHM()：测试是否共享存储对象

4. 与一个进程有关的ID有很多:
	- 实际用户 ID 和实际组 ID： 标志我们究竟是谁。当我们登录进操作系统时，这两个值就确定了！
	- 有效用户 ID、有效组ID、附属组 ID： 用于文件访问权限检查。
	- 保存的设置用户ID、保存的设置组ID：由 exec函数保存

	每个文件都有一个所有者和组所有者，分别有 stat.st_uid和stat.st_gid指定。当一个文件时可执行文件时，如果执行这个文件，那么进程的有效用户ID就是实际用户ID，有效组ID就是实际组ID，除了下面的情况：
	-  当在stat.st_mode中设置了一个特殊标志：设置用户ID位时，则将进程的有效用户ID设置为文件所有者的用户ID
	-  当在stat.st_mode中设置了一个特殊标志：设置组ID位时，则将进程的有效组ID设置为文件所有者的组ID
	任何进程都是由可执行文件被执行而得到。因此位于磁盘上的可执行文件的所属的用户ID和组ID会影响到进程的用户ID和组ID

	如果某个可执行文件所有者是root，且该文件的设置用户ID位已经被设置，那么无论谁执行这个可执行文件时，该可执行文件产生的进程就具有超级用户权限。

	设置用户ID位、设置组ID位 都包含在stat.st_mode中，可以通过下列两个宏测试：
	- S_ISUID()：测试是否设置了设置用户ID位
	- S_ISGID()：测试是否设置了设置组ID位

5. 文件访问权限：所有文件类型（包括目录，字符特别文件等）都有访问权限。每个文件都有9个访问权限位：
	- S_IRUSR：用户读
	- S_IWUSR：用户写
	- S_IXUSR：用户执行
	- S_IRGRP：组读
	- S_IWGRP：组写
	- S_IXGRP：组执行
	- S_IROTH：其他读
	- S_IWOTH：其他写
	- S_IXOTH：其他执行

	访问权限规则：

	- 当用名字pathname打开任何一个类型的文件时，对pathname中包含的每一个目录，包括pathname可能隐含的当前工作目录都应该具有执行权限
		因此目录的执行权限位也称之为搜索位
	- 对一个文件的读权限决定了我们能否打开现有文件进行读操作
	- 对一个文件的写权限决定了我们能否打开现有文件进行写操作
	- 如果你在open函数中对一个文件指定了O_TRUNC标志，则必须对该文件具有写权限
	- 为了在一个目录中创建一个新文件，必须对该目录具有写权限和执行权限
	- 为了删除一个现有文件，必须对包含该文件的目录具有写权限和执行权限。对该文件本身没有权限的限制
	- 如果用7个exec函数中的任何一个执行某个文件，则必须对该文件具有执行权限，且该文件必须是个普通文件

	进程每次打开、创建、删除一个文件时，内核就进行文件访问权限测试。这种测试如下：

	- 若进程的有效用户ID是0（超级用户），则对该文件的任何访问行为都批准
	- 若进程的有效用户ID等于文件的所有者ID（也就是进程拥有此文件）：
		- 如果该文件的用户读权限开放，则内核允许进程读该文件
		- 如果该文件的用户写权限开放，则内核允许进程写该文件
		- 如果该文件的用户执行权限开放，则内核允许进程执行该文件
	- 若进程的有效组ID或者进程的附属组ID之一等于文件的组ID：
		- 如果该文件的组读权限开放，则内核允许进程读该文件
		- 如果该文件的组写权限开放，则内核允许进程写该文件
		- 如果该文件的用户执行权限开放，则内核允许进程执行该文件
	- 否则：
		- 如果该文件的其他读权限开放，则内核允许进程读该文件
		- 如果该文件的其他写权限开放，则内核允许进程写该文件
		- 如果该文件的其他户执行权限开放，则内核允许进程执行该文件

	只要有一个权限通过，则不再进行测试。若所有权限都不通过，则不允许访问。

6. 对一个目录的读权限和可执行权限是不同的：
	- 目录读权限：允许读目录，从而获得在该目录中所有文件名的列表
	- 目录可执行权限：允许搜索该目录，从而寻找一个特定的文件名

7. 当一个进程通过open或者creat创建一个新文件时：
	- 新文件的用户ID被设置为进程的有效用户ID
	- 新文件的组ID可以有两个值之一：
		- 进程的有效组ID
		- 文件所在目录的组ID
		> 具体选择哪个，由具体操作系统决定

二、访问测试和文件模式创建屏蔽字

1. 当用open()函数打开一个文件时，内核根据进程的有效用户ID和有效组ID为依据来执行访问权限测试。但是如果你想测试进程的实际用户ID和实际组ID是否能够通过权限测试时，可以用下列两个函数：

	#include<unistd.h>
	int access(const char *pathname,int mode);
	int faccess(int fd,const char*pathname,int mode,int flag);
	- 参数：
		- pathname：文件路径名
		- mode：指定要测试的模式。
			- 如果要测试文件是否已存在，则mode设为F_OK
			- 如果要测试进程的实际用户ID和实际组ID的权限，则可以为下列常量的按位或
				- R_OK：测试读权限
				- W_OK：测试写权限
				- X_OK：测试执行权限

		对于 faccess函数：
		- fd：一个打开目录文件的描述符，或者AT_FDCWD
		- pathname：
			- 如果为绝对路径，则忽略fd参数
			- 如果为相对路径，则相对路径的目录由fd指定。
				- 若fd=AT_FDCWD，则表示相对于当前工作目录
				- 否则相对于fd对于的打开的目录
		- flag：如果是AT_EACCESS，则访问检查使用进程的有效用户ID和有效组ID，而不是实际用户ID和实际组ID

	- 返回值：
		- 成功：返回0
		- 出错： 返回 -1

2. 文件模式创建屏蔽字：当进程创建一个新的目录或者文件时，会使用文件模式创建屏蔽字。在文件模式创建屏蔽字中为1的位，在文件mode中的相应位一定被关闭。设置进程的文件模式创建屏蔽字的函数为：

	#include<sys/stat.h>
	mode_t umask(mode_t cmask);

	- 参数： 
		- cmask：要设置的新的文件模式创建屏蔽字
	- 返回值：
		- 成功：旧的文件模式创建屏蔽字
		- 函数未指定失败时返回何值

	如果你在通过creat或者open函数指定了mode，那么该mode必须通过文件模式创建屏蔽字的屏蔽之后才是最终新创建的文件的权限模式。umask指定了哪个，哪个权限就被屏蔽了！
	shell 有一个umask命令。我们可以通过该命令来设置或者打印当前的文件模式创建屏蔽字

三、修改文件访问权限和文件所属用户

1. 修改文件的现有的访问权限：

	#include<sys/stat.h>
	int chmod(const char*pathname,mode_t mode);
	int fchmod(int fd,mode_t mode);
	int fchmodat(int fd,const char*pathname,mode_t mode,int flag);

	- 参数：
		- pathname：文件路径名
		- mode：文件修改后的权限。

		对于 fchmod函数：
		- fd：打开的文件描述符

		对于 fchmodat函数：
		- fd：一个打开目录文件的描述符，或者AT_FDCWD
		- pathname：
			- 如果为绝对路径，则忽略fd参数
			- 如果为相对路径，则相对路径的目录由fd指定。
				- 若fd=AT_FDCWD，则表示相对于当前工作目录
				- 否则相对于fd对于的打开的目录
		- flag：如果是!AT_SYMLINK_FOLLOW，则fchmodtat并不跟随符号链接

	- 返回值：
		- 成功：返回0
		- 出错： 返回 -1

	参数mode可以是下面常量的按位或：（来自头文件<sys/stat.h>）
	- S_ISUID：执行时设置用户ID
	- S_ISGID：执行时设置组ID
	- S_ISVTX：粘着位
	- S_IRWXU：用户读、写和执行
	- S_IRUSR：用户读
	- S_IWUSR：用户写
	- S_IXUSR：用户执行
	- S_IRWXG：组读、写和执行
	- S_IRGRP：用户读
	- S_IWGRP：用户写
	- S_IXGRP：用户执行
	- S_IRWXO：其他读、写和执行
	- S_IROTH：用户读
	- S_IWOTH：用户写
	- S_IXOTH：用户执行

	chmod函数更新的只是i节点最近一次被修改的时间。

	chmod函数在下列条件下自动清除两个权限位：
	- 如果我们试图设置普通文件的粘着位，而且又没有超级用户权限，则mod中的粘着位被自动关闭。这意味着只有超级用户才能设置普通文件的粘着位
	- 新创建文件的组ID可能不是调用进程所属的组ID，它可能是父目录的组ID
 
2. 粘着位：如果对一个目录设置了粘着位，则任何对该目录具有写权限的进程都能够在该目录中创建文件。但是：只有满足下列条件之一的用户才能删除或者重命名该目录下的文件：
	- 拥有此文件
	- 拥有此目录
	- 是超级用户
	对于未设置粘着位的目录，则只要用户对该目录有写权限，那么就有修改和重命名该目录下其他文件的能力

3. 修改用户的ID和组ID：

	#include<unistd.h>
	int chown(const char *pathname,uid_t owner,gid_t group);
	int fchown(int fd,uid_t owner,gid_t group);
	int fchownat(int fd,const char *pathname,uid_t owner,gid_t group,int flag);
	int lchown(const char *pathname,uid_t owner,gid_t group);

	- 参数：
		- pathname：文件路径名
		- owner：文件修改后的用户ID
		- group：文件修改后的组ID

		对于fchown函数：
		- fd：打开的文件描述符，要修改的就是这个文件

		对于 fchownat函数：

		- fd：一个打开目录文件的描述符，或者AT_FDCWD
		- pathname：
			- 如果为绝对路径，则忽略fd参数
			- 如果为相对路径，则相对路径的目录由fd指定。
				- 若fd=AT_FDCWD，则表示相对于当前工作目录
				- 否则相对于fd对于的打开的目录
		- flag：如果是!AT_SYMLINK_FOLLOW，则fchownat并不跟随符号链接，修改的是符号链接本身而不是符号链接指向的文件

	- 返回值：
		- 成功： 返回 0
		- 出错： 返回 -1

	有两点注意：
	- lchown函数更改的是符号链接本身，而chown遇到符号链接时更改的是符号链接指向的文件
	- 如果这些函数由非超级用户进程调用，则成功返回时，该文件的设置用户ID和设置组ID位都被清除

四、修改文件长度

1. 文件长度：stat.st_size字段存放的是以字节为单位的文件的长度。此字段只对普通文件、目录文件、符号链接才有意义：
	- 对普通文件：其长度就是文件的大小。长度为0表示该文件为空
	- 对目录文件：其长度通常是个整数（如16或者512）的整数倍
	- 对符号链接：其长度是符号链接本身存放的某个文件名的实际字节数（它并不包含字符串的null字节，因为这些字符是存放在文件中，而不是存放在内存中的字符串）

	另外stat.st_blksize存放的是对于文件 I/O 较合适的块长度；stat.st_blocks存放的是所分配的块的数量（一个块512字节）。
	注意：
	- 对于普通文件，可能包含空洞。空洞是由于设置的文件偏移量超过了文件末尾，然后写入了某些数据造成的。
	  对于空洞文件，空洞文件的存储需要的磁盘块数量可能远小于文件大小。文件大小是文件末尾到文件头的字节数
	  读取空洞文件的空洞时，对于没有写过的字节位置read返回的是字节0

2. 截断文件：通常可以用带O_TRUNC选项的open()函数来清空一个文件（截断到0）。但是如果希望截断文件使得文件大小为指定字节数，则可以用下列的函数：

	#include<unistd.h>
	int truncate(const char*pathname,off_t length);
	int ftruncate(int fd,off_t length);

	- 参数：
		- pathname：文件路径名
		- length：文件修改后大小（字节数）
		- fd：打开的文件描述符，要修改的就是这个文件
	- 返回值：
		- 成功： 返回 0
		- 出错： 返回 -1

	有两点注意：
	- 若length小于文件的原大小，则修改文件大小之后，文件新的尾端之后的位置不再可以访问
	- 若length大于文件的原大小，则修改文件大小之后，会形成空洞。即从文件原大小新的尾端形成了空洞

五、UNIX文件系统、硬链接、软链接、删除、重命名

1. UNIX文件系统简介(传统的基于BSD的UNIX文件系统，称作UFS）：
	- 一个磁盘可以划分成一个或者多个分区，每个分区可以包含一个文件系统。每个文件系统包含一些柱面组。每个柱面组包括：
		- 一个 i 节点图：用于指示哪些 i 节点已经被使用，哪些未被使用
		- 一个 块位图：用于指示哪些数据块已经被使用，哪些为被使用
		- 一个 i 节点组。它包含的是许多 i  节点。
		- 一个数据区：存放具体的数据块和目录块
	- 数据区包含两种类型的块：
		- 目录块：它的内容是 <i 节点编号>|<文件名> 这种格式的记录的列表
		- 数据块：它的内容就是具体文件的数据		
	- i 节点是固定长度的记录项，它包含有关文件的大部分信息
		- 每个 i 节点都有一个链接计数，其值是指向 i 节点的目录的项数(这种链接类型称之为硬链接)。只有当该链接计数减少为0时，才可以删除该链接文件（也就是释放该文件占用的数据块）。
			- 在stat结构中，链接计数包含在st_nlink成员中（POSIX常量：LINK_MAX指定了一个文件链接数的最大值）			 
		- 每个 i 节点包含了文件有关的所有信息：文件类型、文件权限访问位、文件长度和指向文件数据块的指针
			- stat结构中的大多数信息来自于 i  结点。只有两项重要数据存放在目录项中：文件名、i节点编号
		- 目录项中的 i 节点编号只能指向同一个文件系统中的相应的 i 节点。
			因此硬链接不能跨文件系统
		- 当在不更换文件系统的情况下重命名一个文件时，该文件的实际内容并未移动。只需要构造一个指向现有 i 节点的新目录项，并删除来的目录项。此时该 i节点的链接计数不会改变
			> 这就是 mv命令的操作方式

2. 与硬链接对应的概念是软链接。软链接也称作符号链接，它是一种特殊的文件。该文件的实际内容（在数据块中）包含了该符号链接所指向的文件的名字。
    同时该文件的 i 节点指示了该文件类型是 S_IFLNK，于是系统知道了这个文件是个符号链接。
	- 硬链接直接指向文件的i节点
	- 软链接是对一个文件的间接指针

	引入符号链接的原因是为了避开硬链接的一些限制：
	- 硬链接通常要求链接和文件位于同一个文件系统中
	- 只有超级用户才能创建指向目录的硬链接（在底层文件系统支持的情况下）

	对于符号链接以及它指向何种类型的文件并没有什么限制。任何用户都可以创建指向目录的符号链接。但是使用符号链接有可能在文件系统中引入循环

	对于处理文件和目录的函数，如果传递的是一个符号链接的文件名，则应该注意：函数是否跟随符号链接，即函数是处理符号链接指向的文件，还是处理符号链接本身。

	- 跟随符号链接（即处理符号链接指向的文件）的函数有：access、chdir、chmod、chown、creat、exec、link、open、opendir、pathconf、stat、truncate
	- 不跟随符号链接（即处理符号链接文件本身）的函数有：lchown、lstat、readlink、remove、rename、unlink
		- 一个例外的情况：如果用O_CREAT和O_EXCL选项调用open，此时若参数是个符号链接的文件名，则open出错返回（并不考虑符号链接指向的文件是否存在），同时将errno设为EEXIST

3. 任何一个目录 dirxxx 的硬链接至少为2：
	- 该目录的内容中有一条名为的.记录，该记录的 <i节点编号>指向dirxxx目录的节点
	- 该目录的父目录的内容中有一条记录，记录的名字dirxxx，记录的 <i节点编号> 指向dirxxx目录的节点
	- 若该目录有子目录。dirxxx 的任何子目录的内容有一条名为..的记录，该记录的 <i节点编号> 指向dirxxx目录的节点
	因此父目录中的每个子目录都使得父目录的链接计数加 1

4. link/linkat函数：创建一个指向现有文件的硬链接

	#include<unistd.h>
	int link(const char *existingpath,const char *newpath);
	int linkat(int efd,const char*existingpath,int nfd,const char *newpath,int flag);

	- 参数：
		- existingpath：现有的文件的文件名（新创建的硬链接指向它）
		- newpath：新创建的目录项
			- 如果newpath已存在，则返回出错
			- 只创建newpath中的最后一个分量，路径中的其他部分应当已经存在。
			假设 newpath为：/home/aaa/b/c.txt，则要求 /home/aaa/b已经存在，只创建c.txt

		对于linkat函数：
		- 现有的文件名是通过efd和existingpath指定。
			- 若 existingpath 是绝对路径，则忽略efd
			- 若 existingpath 是相对路径，则：
				- 若 efd=AT_FDCWD，则existingpath是相对于当前工作目录来计算
				- 若 efd是一个打开的目录文件的文件描述符，则existingpath是相对于efd对应的目录文件
		- 新建的文件名是通过nfd和newpath指定。
			- 若 newpath 是绝对路径，则忽略nfd
			- 若 newpath 是相对路径，则：
				- 若 nfd=AT_FDCWD，则newpath是相对于当前工作目录来计算
				- 若 nfd是一个打开的目录文件的文件描述符，则newpath是相对于nfd对应的目录文件
		- flag：当现有文件是符号链接时的行为：
			- flag=AT_SYMLINK_FOLLOW：创建符号链接指向的文件的硬链接（跟随行为）
			- flag=!AT_SYMLINK_FOLLOW: 创建符号链接本身的硬链接（默认行为）

	- 返回值：
		- 成功： 返回 0
		- 失败： 返回 -1

	这两个函数创建新目录项并对链接计数加1。创建新目录项和增加链接计数是一个原子操作。

	另外，大多数操作系统中，只有超级用户才能创建指向一个目录的硬链接，因为这样做很有可能在文件系统中形成循环。

5. unlink函数：删除一个现有的目录项

	#include<unistd.h>
	int unlink(const char*pathname);
	int unlinkat(int fd,const char*pathname,int flag);

	- 参数：
		- pathname：现有的、待删除的目录项的完整路径名。

		对于unlinkat函数：
		- 现有的文件名是通过fd和pathname指定。
			- 若 pathname 是绝对路径，则忽略fd
			- 若 pathname 是相对路径，则：
				- 若 fd=AT_FDCWD，则pathname是相对于当前工作目录来计算
				- 若 fd是一个打开的目录文件的文件描述符，则pathname是相对于fd对应的目录文件
		- flag：
			- flag=AT_REMOVEDIR：可以类似于rmdir一样的删除目录
			- flag=!AT_REMOVEDIR:与unlink执行同样的操作
	- 返回值：
		- 成功： 返回 0
		- 失败： 返回 -1

	为了解除对文件的链接，必须对包含该目录项的目录具有写和执行权限。如果还对该目录设置了粘着位，则对该目录必须具有写权限以及下列三个条件之一：
	- 拥有该文件
	- 拥有该目录
	- 具有超级用户权限

	这两个函数删除目录项并对链接计数减1。创建新目录和增加链接计数是一个原子操作。
	- 如果该文件的硬链接数不为0， 则还可以通过其他链接访问该文件的内容
	- 如果该文件的硬链接数为0，而没有进程打开该文件，则该文件的内容才有被删除
	- 如果该文件的硬链接数为0，但是有进程打开了该文件，则该文件的内容不能被删除。当进程关闭文件时，内核会检查打开该文件的进程个数；当这个数量为0，内核再去检查其链接计数。如果链接计数也是0，则就删除该文件的内容。
		这个特性常用于创建临时文件，先open,create一个文件，然后立即调用unlink。这样即使程序崩溃，它所创建的临时文件也不会遗留下来
	- 如果删除目录项出错，则不对该文件做任何更改

	如果pathname是个符号链接，则unlink删除该符号链接，而不会删除由该符号链接所引用的文件。	
	如果仅仅给出符号链接的文件名，没有一个函数可以删除由该符号链接所引用的文件

	如果文件系统支持，超级用户可以调用unlink，其参数pathname指定一个目录
	通常推荐用rmdir函数，其语义更加清晰

7. remove函数：解除对一个目录或者文件的链接。

	#include<stdio.h>
	int remove(const char *pathname);
	- 参数
		- pathname：文件名或者目录名
	- 返回值：
		- 成功：返回0
		- 失败：返回 -1

	对于文件，remove功能与unlink相同；对于目录，remove功能与rmdir相同

8. rename/renameat函数：重命名文件或目录

	#inluce<stdio.h>
	int rename(const char*oldname,const char *newname);
	int renameat(int oldfd,const char*oldname,int newfd,const char* newname);

	- 参数：
		- oldname：现有的文件名或者目录名
		- newname：重命名的名字
			- 如果oldname是个文件名，则为该文件或者符号链接重命名。
				- 此时若newname已存在：若newname是个目录则报错；若newname不是个目录：则先将newname目录项删除，然后将oldname重命名为newname
				- 此时若newname不存在：则直接将oldname重命名为newname
			- 如果oldname是个目录名，则为该目录重命名。
				- 此时若newname已存在：若newname是个目录且该目录是个空目录，则先将它删除，然后oldname重命名为newname；若newname是个目录且该目录不是个空目录，则报错；
							若newname不是个目录，则报错
				- 此时若newname不存在：则直接将oldname重命名为newname
			oldname 不能是 newname 的前缀。因为重命名时，需要删除oldname
			- 如果oldname或者newname引用的是符号链接，则处理的是符号链接本身，而不是它引用的文件
			- 不能对 . 和 .. 重命名。即 . 和 .. 不能出现在oldname和newname的最后部分
			- 若newname和oldname引用同一个文件，则函数不作任何更改而成功返回

		对于renameat函数：
		- 现有的文件名或目录名是通过oldfd和oldname指定。
			- 若 oldname 是绝对路径，则忽略oldfd
			- 若 oldname 是相对路径，则：
				- 若 oldfd=AT_FDCWD，则oldname是相对于当前工作目录来计算
				- 若 oldfd 是一个打开的目录文件的文件描述符，则oldname是相对于oldfd对应的目录文件
		- 重命名的文件名或目录名是通过newfd和newname指定。
			- 若 newname 是绝对路径，则忽略newfd
			- 若 newname 是相对路径，则：
				- 若 newfd=AT_FDCWD，则 newname是相对于当前工作目录来计算
				- 若 newfd 是一个打开的目录文件的文件描述符，则 newname 是相对于 newfd 对应的目录文件
		- flag：当现有文件是符号链接时的行为：
			- flag=AT_SYMLINK_FOLLOW：创建符号链接指向的文件的硬链接（跟随行为）
			- flag=!AT_SYMLINK_FOLLOW: 创建符号链接本身的硬链接（默认行为）

	- 返回值：
		- 成功： 返回 0
		- 失败： 返回 -1

	对于包含oldname以及newname的目录，调用进程必须具有写和执行的权限，因为将同时更改这两个目录。

9. symlink/symlinkat函数：创建一个符号链接

	#include<unistd.h>
	int symlink(const char*actualpath,const char *sympath);
	int symlinkat(const char*actualpath,int fd,const char*sympath);

	- 参数：
		- actualpath：符号链接要指向的文件或者目录（可能尚不存在）
		- sympath：符号链接的名字
		二者不要求位于同一个文件系统中


		对于symlinkat函数：
		- 符号链接的名字是通过fd和sympath指定。
			- 若 sympath 是绝对路径，则忽略fd
			- 若 sympath 是相对路径，则：
				- 若 fd=AT_FDCWD，则sympath是相对于当前工作目录来计算
				- 若 fd 是一个打开的目录文件的文件描述符，则sympath是相对于fd对应的目录文件

	- 返回值：
		- 成功： 返回 0
		- 失败： 返回 -1

10. readlink/readlinkat函数：打开符号链接本身
	open 函数是跟随链接的，即打开符号链接指向的文件

	#include<unistd.h>
	ssize_t readlink(const char *restrict pathname,char *restrict buf,size_t bufsize);
	ssize_t readlinkat(int fd, const char* restrict pathname,char *restrict buf, size_t bufsize);

	- 参数：
		- pathname：符号链接的名字
		- buf：存放符号链接内容的缓冲区
		- bufsize：期望读入缓冲区的字节数

		对于readlinkat函数：

		- 符号链接的名字是通过fd和pathname指定。
			- 若 pathname 是绝对路径，则忽略fd
			- 若 pathname 是相对路径，则：
				- 若 fd=AT_FDCWD，则pathname是相对于当前工作目录来计算
				- 若 fd 是一个打开的目录文件的文件描述符，则pathname是相对于fd对应的目录文件

	- 返回值：
		- 成功： 返回实际上读取的字节数
		- 失败： 返回 -1

	readlink和readlinkat函数组合了open、read、close函数的所有操作。

	注意：读入buf中的符号链接的内容，并不是以null字节终止。
	以null字节终止的是内存中的字符串这种数据结构。而符号链接文件的内容是简单的字符序列，并不是字符串。

六、修改文件的时间

1. 文件的时间：在stat结构中存放着文件的三个时间：
	- st_atim：文件数据的最后访问时间
	- st_mtim：文件数据的最后修改时间
	- st_ctim： i 节点状态的最后更改时间

	关于这三个时间：
	- 有很多操作，比如修改文件权限，修改文件的所有者等操作，他们只修改 i 节点状态（只影响st_ctim），但是并不修改文件数据，也并不访问文件数据
	- 系统并不维护对 i 节点的最后访问时间。因此对于 access函数和 stat函数，他们并不修改这三个时间中的任何一个
	- 创建一个文件不仅影响了文件本身的这三个时间，也会影响该文件目录的这三个时间

2. futimens/utimensat/utimes函数：修改文件的访问和修改时间

	#include<sys/stat.h>
	int futimens(int fd,const struct timespec times[2]);
	int utimensat(int fd,const char*path,const struct timespec times[2],int flag);
	#include<sys/time.h>
	int utimes(const char*pathname,const struct timeval times[2]);

	- 参数：

		对于  futimens和 utimensat函数：
		- times：指向待修改文件的指定的文件数据访问和文件数据修改时间的指针。
			对于C语言，参数中的数组自动转换为指向数组的指针

			- 这两个时间是日历时间，是自 1970:01:01--00:00:00 以来经历的秒数。不足秒的部分用纳秒表示
			- 数组的第一个元素指定 st_atim；数组的第二个元素指定 st_mtim
			- times可以按照下列四种方式之一指定：
				- times为空指针： 则将文件的数据访问时间和文件数据修改时间设置为当前时间
				此时要求进程的有效用户ID等于该文件所有者的ID；或者进程对该文件有写权限；或者进程是个超级用户进程
				- times参数是指向timespec数组的指针：
					- 若数组的任何一个元素的tv_nsec字段为 UTIME_NOW，则相应的时间戳就设置为当前时间，忽略相应的tv_sec字段
					此时要求进程的有效用户ID等于该文件所有者的ID；或者进程对该文件有写权限；或者进程是个超级用户进程
					- 若数组的任何一个元素的tv_nsec字段为 UTIME_OMIT，则相应的时间戳保持不变，忽略相应的tv_sec字段
						若两个时间戳都忽略，则不需要任何权限限制
					- 若数组的任何一个元素的tv_nsec字段为不是上面的两种之一，则相应的时间戳就设置为相应的tv_sec和tv_nsec字段
					此时要求进程的有效用户ID等于该文件所有者的ID；或者进程是个超级用户进程（对文件只有写权限是不够的）

		对于 utimes 函数：
		- pathname：文件的路径名
		- times：指向timeval数组的指针。 timeval结构用秒和微秒表示。

			struct timeval{
				time_t tv_sec;//秒
				long tv_usec; //微秒
			};

		对于 futimens 函数：
		- fd：待修改文件的打开的文件描述符

		对于 utimensat函数：
		- 待打开文件的名字是通过fd和path指定。
			- 若 path 是绝对路径，则忽略fd
			- 若 path是相对路径，则：
				- 若 fd=AT_FDCWD，则path是相对于当前工作目录来计算
				- 若 fd是一个打开的目录文件的文件描述符，则path是相对于fd对应的目录文件
		- flag：若待修改的文件是符号链接
			- 如果为!AT_SYMLINK_FOLLOW，则符号链接本身的时间就会被修改
			- 默认情况下，修改的是符号链接指向的文件的时间（跟随行为）

	- 返回值：
		- 成功： 返回 0
		- 失败： 返回 -1

	我们不能对st_ctim（i节点最后被修改时间）指定一个值。这个时间是被自动更新的。

七、目录操作

1. mkdir/mkdirat函数创建一个空目录：

	#include<sys/stat.h>
	int mkdir(const char*pathname,mode_t mode);
	int mkdirat(int fd,const char *pathname,mode_t mode);

	- 参数：
		- pathname:被创建目录的名字
		- mode:被创建目录的权限

		对于 mkdirat，被创建目录的名字是由fd和pathname共同决定的。
		- 若 pathname 是绝对路径，则忽略fd
		- 若 pathname 是相对路径，则：
			- 若 fd=AT_FDCWD，则pathname是相对于当前工作目录来计算
			- 若 fd是一个打开的目录文件的文件描述符，则pathname是相对于fd对应的目录文件

	- 返回值：
		- 成功： 返回0
		- 失败： 返回 -1

	注意：
	- 他们创建的目录是空目录。
	- 对于目录，通常至少要设置一个执行权限位，以允许访问该目录中的文件名

2. rmdir函数：删除一个空目录

	#include<unistd.h>
	int rmdir(const char *pathname);

	- 参数：
		- pathname：待删除的空目录的名字

	- 返回值：
		- 成功： 返回0
		- 失败： 返回 -1

	如果调用此函数使得目录的链接计数为0时：	
	- 如果此时没有其他进程打开该目录，则释放由此目录占用的空间。
	- 如果此时有一个或者多个进程打开此目录，则在此函数返回时删除最后一个链接以及 . 和 .. 项，直到最后一个打开该目录的进程关闭该目录时此目录才真正被释放。
		- 此时，在此目录中不能再创建新文件。

3. 读、写目录：对于某个目录具有访问权限的任何用户都可以读该目录。但是为了防止文件系统产生混乱，只有内核才能写目录。
	一个目录的写权限和执行权限位决定了在该目录中能否创建新文件以及删除文件，它们并不能写目录本身

	#include<dirent.h>
	DIR *opendir(const char *pathname);
	DIR *fdopendir(int fd);
	struct dirent *readdir(DIR *dp);
	void rewinddir(DIR *dp);
	int closedir(DIR *dp);
	long telldir(DIR *dp);
	void seekdir(DIR *dp,long loc);

	各个函数：
	- opendir：打开目录。
		- 参数：pathname：目录的名字
		- 返回值：成功返回目录指针；失败返回 NULL
	- fdopendir：打开目录。
		- 参数：fd：目录文件的文件描述符
		- 返回值：成功返回目录指针；失败返回 NULL
	- readdir：读取目录
		- 参数： dp：目录指针
		- 返回值： 成功则返回目录项的指针；失败返回 NULL
	- rewinddir :将目录的文件偏移量清零（这样下次读取就是从头开始）
		- 参数：dp：目录指针
	- closedir：关闭目录。
		- 参数：dp：目录指针
		- 返回值：成功返回 0 ；失败返回 -1
	- telldir：返回目录的文件偏移量
		- 参数：dp：目录指针
		- 返回值：成功返回目录的文件偏移量 ；失败返回 -1
	- seekdir：设置目录的当前位置
		- 参数：dp：目录指针；loc：要设定的文件偏移量

	对于 DIR 结构，它是一个内部结构。起作用类似于 FILE 结构。
	对于 dirent 结构，它是定义在<dirent.h>头文件中。其与具体操作系统相关。但是它至少定义了两个成员：

	struct dirent{
	ino_t d_ino; // i 节点编号
	char d_name[];// 以 null 结尾的文件名字符串
	}
	d_name项的大小并没有指定，但必须保证它能包含至少 NAME_MAX个字节（不包含终止null字节）

	目录中各目录项的顺序与操作系统有关。它们通常不按照字母顺序排列

4. 当前工作目录：每个进程都有一个当前工作目录。此目录是搜索所有相对路径名的起点。
	当前工作目录是本进程的一个属性

	与当前工作目录相关的有三个函数：

	#include<unistd.h>
	int chdir(const char *pathname);
	int fchdir(int fd);
	char *getcwd(char *buf,size_t size);

	各个函数：
	- chdir：更改当前工作目录。
		- 参数：pathname：将该目录作为当前工作目录
		- 返回值：成功返回 0 ；失败返回 -1
	- fchdir：更改当前工作目录。
		- 参数：fd：将该 fd 文件描述符对应的目录作为当前工作目录
		- 返回值：成功返回 0 ；失败返回 -1
	- getcwd：返回当前工作目录的名字
		- 参数： buf：缓冲区地址；size：缓冲区长度。这两个参数决定了当前工作目录名字字符串存放的位置。
		缓冲区必须足够长以容纳绝对路径名加上一个终止null字节。否则返回出错。
		- 返回值： 成功则返回 buf；失败返回 NULL

mylstat.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(-1);
}

const char *getfiletype(const mode_t *mode)
{
	if(NULL == mode)
		return "mode_t has error";
	if(S_ISREG(*mode))
		return "regular";
	else if(S_ISDIR(*mode))
		return "directory";
	else if(S_ISCHR(*mode))
		return "character special";
	else if(S_ISBLK(*mode))
		return "block special";
	else if(S_ISFIFO(*mode))
		return "fifo";
	else if(S_ISLNK(*mode))
		return "link";
	else if(S_ISSOCK(*mode))
		return "socket";
	else
		return "** unknow type **";
}

int main(int argc, char const *argv[])
{
	if (argc < 2)
		err_sys("usage:mystat [pathname...]\n");

	int i;
	struct stat buf;
	for(i=1; i < argc; i++)
	{
		printf("<file name>:%s ---- ", argv[i]);
		if(lstat(argv[i], &buf) < 0)
		{
			printf("%s lstat error\n", argv[i]);
			return -1;
		}
		printf("<type>:%s\n", getfiletype(&(buf.st_mode)));
	}
	return 0;
}

myaccess.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(-1);
}

int main(int argc, char const *argv[])
{
	int n;
	int fd;
	char buf[64] = {0};
	if(argc != 2)
	{
		printf("need a file\n");
		return -1;
	}
	/* 检验有没有读权限 */
	if(access(argv[1], R_OK) < 0)
	{
		perror("access error");
		return -1;
	}

	/* 按只读打开文件 */
	if((fd = open(argv[1], O_RDONLY)) < 0)
	{
		perror("open error");
		return -1;
	}

	while ((n = read(fd, buf, sizeof(buf))) > 0) {
		write(STDOUT_FILENO, buf, n);
	}
	if (n < 0) err_sys("read error");

	close(fd);
	return 0;
}

myumask.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(-1);
}

#define RWRWRW (S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH) /* 权限值0666 */

int main(int argc, char const *argv[])
{
	umask(0); /* umask=0000 */
	if(creat("foo", RWRWRW) < 0)
	{
		perror("creat foo error");
		return -1;
	}

	umask(S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH); /* umask=0066 */
	if(creat("bar", RWRWRW) < 0)
	{
		perror("creat bar error");
		return -1;
	}

	return 0;
}

mychmod.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(-1);
}

#define RWRWRW (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH) /* 权限制0666 */

int main(int argc, char const *argv[])
{
	struct stat buf;

	/* 设置foo文件的相对访问属性 */
	if(stat("foo", &buf) < 0)
	{
		perror("stat foo error");
		return -1;
	}
	/* 关闭了组执行位，开启了设置组ID位 */
	if(chmod("foo", (buf.st_mode & ~S_IXGRP) | S_ISGID) < 0)
	{
		perror("foo chmod error");
		return -1;
	}

	/* 设置bar的绝对访问属性 */
	if(chmod("bar", RWRWRW) < 0)
	{
		perror("bar chmod error");
		return -1;
	}

	return 0;
}

mylink.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(-1);
}

int main(int argc, char const *argv[])
{
	if(linkat(AT_FDCWD, "softlink", AT_FDCWD, "mylink", AT_SYMLINK_FOLLOW) < 0)
	{
		perror("linkat error");
		return -1;
	}

	sleep(10);

	if(unlinkat(AT_FDCWD, "mylink" ,0) < 0)
	{
		perror("unlinkat error");
		return -1;
	}

	return 0;
}

mslnk.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(-1);
}

int main(int argc, char* argv[])
{
	if (argc != 3)
		err_sys("usage:myslnk [pathname] [linkname]\n");
	if (symlink(argv[1], argv[2]) < 0)
		err_sys("symlink error\n");
	exit(EXIT_SUCCESS);
}

myreadlink.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(-1);
}

#define BUFSIZE 4096

int main(int argc, char* argv[])
{
	if (argc != 2) err_sys("usage:myreadlink [linkname]\n");
	
	int val;
	char buf[BUFSIZE];
	while ((val = readlink(argv[1], buf, BUFSIZE)) > 0)
		if (write(STDOUT_FILENO, buf, val) != val)
			err_sys("write error");
	if (val < 0)err_sys("readlink error\n");
	exit(EXIT_SUCCESS);
}

mytrunc.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(-1);
}

int main(int argc, char* argv[])
{
	if (argc < 2)
		err_sys("usage:truc [filename...]");

	int i, fd;
	struct stat statbuf;
	struct timespec times[2];
	for (i = 1; i < argc; ++i) {
		if (stat(argv[i], &statbuf) < 0) {
			err_ret("%s:stat error", argv[1]);
			continue;
		}
		if ((fd = open(argv[i], O_RDWR | O_TRUNC)) < 0) {
			err_ret("%s:open error",argv[i]);
			continue;
		}
		times[0] = statbuf.st_atim;
		times[1] = statbuf.st_mtim;
		if (futimens(fd, times) < 0)
			err_ret("%s:futimens error", argv[i]);
		close(fd);
	}
	exit(EXIT_SUCCESS);
}

myreaddir.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(-1);
}

const char *getfiletype(mode_t mode)
{
	if(0 == mode)
		return "mode_t has error";
	if(S_ISREG(mode))
		return "regular";
	else if(S_ISDIR(mode))
		return "directory";
	else if(S_ISCHR(mode))
		return "character special";
	else if(S_ISBLK(mode))
		return "block special";
	else if(S_ISFIFO(mode))
		return "fifo";
	else if(S_ISLNK(mode))
		return "link";
	else if(S_ISSOCK(mode))
		return "socket";
	else
		return "** unknow type **";
}

int read_directory(const char *directory)
{
	DIR *dp = NULL;
	struct dirent *dirp = NULL;
	struct stat st;
	mode_t mymode;
	char filename[1024] = {0};
	char *ptr = NULL;
	strncpy(filename, directory, 1024);
	if(lstat(directory ,&st) < 0)
	{
		perror("lstat error");
		return -1;
	}

	mymode = st.st_mode;
	if(S_ISDIR(st.st_mode)){/* 是目录就继续读 */
		ptr = filename + strlen(filename);/* ptr保存了添加子目录/文件的位置 */
		if(*(ptr-1) != '/') *ptr++ = '/';/* 父子目录之间的'/'符号 */
		printf("Directory:%s\t--type:%s\n", filename, getfiletype(mymode));
		if((dp = opendir(filename)) == NULL){
			perror("opendir error");
			return -1;
		}	
		while((dirp = readdir(dp)) != NULL){
			if(strcmp(dirp->d_name, ".")==0 || strcmp(dirp->d_name, "..")==0)/* 忽略. 和 .. 目录，否则会造成重复 */
				continue;
			strncpy(ptr, dirp->d_name, sizeof(dirp->d_name));
			read_directory(filename);
		}
		closedir(dp);
	}
	else{/* 是一个文件就打印文件名字 */
		printf("--file:%s\t--type:%s\n", filename, getfiletype(mymode));
	}
}

int main(int argc, char const *argv[])
{
	if(argc != 2)
	{
		printf("need a directory\n");
		return -1;
	}

	read_directory(argv[1]);
	return 0;
}

mydir.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(EXIT_FAILURE);
}

int main(int argc, char** argv)
{
	if (argc != 2)
		err_sys("usage:mydir [dirname]\n");

	DIR* dp;
	int fd;
	struct dirent* dirp;

	if ((fd = open(argv[1], O_RDONLY)) < 0)
		err_sys("open error\n");
	if ((dp = fdopendir(fd)) == NULL)
		err_sys("fdopendir error\n");
	while ((dirp = readdir(dp)) != NULL)
		printf("%s\n", dirp->d_name);

	closedir(dp);
	close(fd);
	exit(EXIT_SUCCESS);
}

myftw.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(EXIT_FAILURE);
}

typedef int Myfunc(const char*, const struct stat*, int);

static Myfunc myfunc;
static int myftw(char*, Myfunc*);
static int dopath(Myfunc*);
static long nreg, ndir, nblk, nchr, nfifo, nslink, nsock, ntot;

int main(int argc, char* argv[])
{
	if (argc != 2)
		err_sys("usage:ftw <starting-pathname>");
	
	int ret = myftw(argv[1], myfunc);
	ntot = nreg + ndir + nblk + nchr + nfifo + nslink + nsock;
	if (ntot == 0)
		ntot = 1;

	printf("regular files  = %7ld, %5.2f %%\n", nreg, nreg * 100.0 / ntot);
	printf("directories    = %7ld, %5.2f %%\n", ndir, ndir * 100.0 / ntot);
	printf("block special  = %7ld, %5.2f %%\n", nblk, nblk * 100.0 / ntot);
	printf("char special   = %7ld, %5.2f %%\n", nchr, nchr * 100.0 / ntot);
	printf("FIFOs          = %7ld, %5.2f %%\n", nfifo, nfifo * 100.0 / ntot);
	printf("symbolic links = %7ld, %5.2f %%\n", nslink, nslink * 100.0 / ntot);
	printf("sockets        = %7ld, %5.2f %%\n", nsock, nsock * 100.0 / ntot);

	exit(ret);
}

enum {FTW_F,FTW_D,FTW_DNR,FTW_NS};

static char fullpath[8192];
static size_t pathlen = 8192;

static int myftw(char* pathname, Myfunc* func) {
	strcpy(fullpath, pathname);

	return dopath(func);
}

static int dopath(Myfunc* func) {
	struct stat statbuf;
	struct dirent* dirp;
	DIR* dp;
	int ret, n;

	if (lstat(fullpath, &statbuf) < 0)
		return func(fullpath, &statbuf, FTW_NS);
	if (S_ISDIR(statbuf.st_mode) == 0)
		return func(fullpath, &statbuf, FTW_F);

	if ((ret = func(fullpath, &statbuf, FTW_D)) != 0)
		return ret;

	n = strlen(fullpath);
	fullpath[n++] = '/';
	fullpath[n] = 0;

	if ((dp = opendir(fullpath)) == NULL)
		return func(fullpath, &statbuf, FTW_DNR);
	while ((dirp = readdir(dp)) != NULL) {
		if (strcmp(dirp->d_name, ".") == 0 ||
			strcmp(dirp->d_name, "..") == 0)
			continue;
		strcpy(&fullpath[n], dirp->d_name);
		if ((ret = dopath(func)) != 0)
			break;
	}
	fullpath[n - 1] = 0;
	if (closedir(dp) < 0) {
		printf("can't close directory %s", fullpath); exit(-1);
	}
	return ret;
}

static int myfunc(const char* pathname, const struct stat* statptr, int type) {
	switch (type) {
	case FTW_F://若是非目录文件
		switch (statptr->st_mode & S_IFMT) {
		case S_IFREG:nreg++; break;
		case S_IFBLK:nblk++; break;
		case S_IFCHR:nchr++; break;
		case S_IFIFO:nfifo++; break;
		case S_IFLNK:nslink++; break;
		case S_IFSOCK:nsock++; break;
		case S_IFDIR:printf("myfunc S_IFDIR for %s", pathname); exit(-1);
		}
                          break;
	case FTW_D://若是文件
		ndir++; break;
	case FTW_DNR://若是不可读目录
		printf("can't read directory %s", pathname); exit(-1);
		break;
	case FTW_NS://若是不可调用stat函数的文件，或者说是上一个stat函数调用者调用失败
		printf("stat error for %s", pathname); exit(-1);
		break;
	default:
		printf("unknown type %d for pathname %s", type, pathname); exit(-1);
		break;
	}
	return 0;
}

mychdir.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(EXIT_FAILURE);
}

int main(int argc, char const *argv[])
{
	char pathname[64] = {0};
	
	/* 旧的工作目录 */ 
	if (getcwd(pathname, 64) == NULL)
	{
		perror("getcwd error");
		return -1;
	}
	printf("before chdir path:%s\n", pathname);


	/* 改变工作目录为/tmp */
	if(chdir("/tmp") < 0)
	{
		perror("chdir error");
		return -1;
	}

	/* 新的工作目录 */
	if (getcwd(pathname, 64) == NULL)
	{
		perror("getcwd error");	
		return -1;
	}
	printf("after chdir path:%s\n", pathname);

	return 0;
}

mychftw.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(EXIT_FAILURE);
}

typedef int Myfunc(const char* filename, const struct stat* pstat, int flags);
static Myfunc myfunc;
static int dopath(const char* filename, Myfunc* func);
static int myftw(const char* pathname, Myfunc* func);

static long nreg, ndir, nblk, nchr, nfifo, nslink, nsock, ntot;
enum{FTW_F,FTW_D,FTW_DNR,FTW_DNCHD,FTW_NS};

int main(int argc, char* argv[])
{
	if (argc != 2)
		err_quit("usage:myftw <starting-pathname>");

	int ret = myftw(argv[1], myfunc);
	ntot = nreg + ndir + nblk + nchr + nfifo + nslink + nsock;
	if (ntot == 0)
		ntot = 1;

	printf("regular files  = %7ld, %5.2f %%\n", nreg, nreg * 100.0 / ntot);
	printf("directories    = %7ld, %5.2f %%\n", ndir, ndir * 100.0 / ntot);
	printf("block special  = %7ld, %5.2f %%\n", nblk, nblk * 100.0 / ntot);
	printf("char special   = %7ld, %5.2f %%\n", nchr, nchr * 100.0 / ntot);
	printf("FIFOs          = %7ld, %5.2f %%\n", nfifo, nfifo * 100.0 / ntot);
	printf("symbolic links = %7ld, %5.2f %%\n", nslink, nslink * 100.0 / ntot);
	printf("sockets        = %7ld, %5.2f %%\n", nsock, nsock * 100.0 / ntot);

	exit(ret);
}

static int  myftw(const char* pathname, Myfunc* func) {
	return dopath(pathname, func);
}

static int dopath(const char* filename, Myfunc* func) {
	struct stat statbuf;
	struct dirent* pentry;
	DIR* pdir;
	int ret;

	if (lstat(filename, &statbuf) < 0)
		return func(filename, &statbuf, FTW_NS);
	if (S_ISDIR(statbuf.st_mode) == 0)
		return func(filename, &statbuf, FTW_F);
	
	//下面处理目录:
	if ((ret = func(filename, &statbuf, FTW_D)) != 0)
		return ret;
	if (chdir(filename) < 0)
		return func(filename, &statbuf, FTW_DNCHD);
	if ((pdir = opendir(".")) == NULL)
		return func(filename, &statbuf, FTW_DNR);
	while ((pentry = readdir(pdir)) != NULL) {
		if (strcmp(pentry->d_name, ".") == 0 ||
			strcmp(pentry->d_name, "..") == 0)
			continue;
		if ((ret = dopath(pentry->d_name, func)) != 0)
			break;
	}
	
	if (closedir(pdir) < 0 || chdir("..") < 0)
		err_sys("closedir error or chdir error");
	return ret;
}

static int myfunc(const char* filename, const struct stat* pstat, int flags) {
	switch (flags) {
	case FTW_F:
		switch (pstat->st_mode & S_IFMT) {
		case S_IFREG:++nreg; break;
		case S_IFBLK:++nblk; break;
		case S_IFCHR:++nchr; break;
		case S_IFIFO:++nfifo; break;
		case S_IFLNK:++nslink; break;
		case S_IFSOCK:++nsock; break;
		default:printf("unkown type %s", filename); exit(-1);
		}
		break;
	case FTW_D:
		++ndir; break;
	case FTW_DNCHD:
		printf("chdir %s error", filename); exit(-1); break;
	case FTW_DNR:
		printf("read diretory %s error", filename); exit(-1); break;
	case FTW_NS:
		printf("stat %s error", filename); exit(-1); break;
	default:
		printf("unkown type"); exit(-1); break;
	}
	return 0;
}

mypathmax.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(EXIT_FAILURE);
}

#define DEFAULT_MODE (S_IRUSR|S_IWUSR|S_IXUSR)

int main(int argc, char* argv[])
{
	long pathMax = pathconf("/", _PC_PATH_MAX);
	printf("pathMax=%ld\n", pathMax);
	pathMax *= 3;
	char pathchar[pathMax];
	
	while (1) {
		if (mkdir("test", DEFAULT_MODE) < 0)
			err_sys("mkdir error\n");
		if (chdir("test") < 0)
			err_sys("chdir error\n");

		if ((getcwd(pathchar, pathMax)) != NULL)
			printf("current path: %s(pathlength: %ld)\n",
				pathchar, strlen(pathchar));
		else
			err_sys("getcwd error\n");
	}
	exit(EXIT_SUCCESS);
}

myrename.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(EXIT_FAILURE);
}

int main(int argc, char** argv)
{
	if (argc != 3)
		err_sys("usage:myrename [oldname] [newname]\n");
	if (rename(argv[1], argv[2]) < 0)
		err_sys("rename error\n");
	exit(EXIT_SUCCESS);
}

mymkrmdir.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(EXIT_FAILURE);
}

int main(int argc, char* argv[])
{
	if (argc < 3) err_sys("usage:mymkrmdir [-m|r] dirname\n");
	
	if (strcmp(argv[1], "-m") == 0) {
		struct stat statbuf;
		if (stat(".", &statbuf) < 0)
			err_sys("stat error\n");
		mode_t default_mode = statbuf.st_mode;
		if (mkdir(argv[2], default_mode) < 0)
			err_sys("mkdir error\n");
	}
	else if (strcmp(argv[1], "-r") == 0) {
		if (rmdir(argv[2]) < 0)
			err_sys("rmdir error\n");
	}
	else
		err_sys("usage:mkrmdir [-m|r] dirname\n");

	exit(EXIT_SUCCESS);
}

mychgrp.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int main(int argc, char* argv[])
{
	if (argc != 3)
		err_sys("Usage:mychgrp new_grpid filename\n");
	if (lchown(argv[2], -1, atoi(argv[1])) < 0)
		err_sys("change group id error\n");

	exit(0);
}

myhandle_cp.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define BUFSIZE 4096
#define DEFAULT_MODE (S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)

int buf_handle(char* buf, int read_size, char ch) {
	int i;
	for (i = 0; i < read_size; ++i) {
		if (buf[i] == ch) {
			int j = i + 1;
			for (; j < read_size; ++j)
				if (buf[j] != ch)
					buf[i++] = buf[j];
			break;
		}
	}
	return i;
}

int main(int argc, char* argv[])
{
	if (argc < 3)
		err_sys("usage:myhandle_cp [src file] [target file] [del_char]\n");
	char ch = '\0';
	if (argc == 4)ch = argv[3][0];

	int val, src_fd, tar_fd;
	char buf[BUFSIZE];
	if ((src_fd = open(argv[1], O_RDONLY)) < 0 ||
		(tar_fd = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, DEFAULT_MODE)) < 0)
		err_sys("open error\n");

	while ((val = read(src_fd, buf, BUFSIZE)) > 0) {
		val = buf_handle(buf, val, ch);
		if (write(tar_fd, buf, val) != val)
			err_sys("write error\n");
	}
	if (val < 0)
		err_sys("read error\n");
	exit(EXIT_SUCCESS);
}

myblk.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int main(int argc, char* argv[])
{
	if (argc < 2)
		err_sys("usage:command filename...\n");

	int i;
	struct stat statbuf;

	for (i = 1; i < argc; ++i) {
		if (stat(argv[i], &statbuf) < 0) {
			fprintf(stderr, "stat read error\n");
			continue;
		}
		printf("%s filesize:%ld blocksize:%ld\n",
			argv[i], statbuf.st_size, statbuf.st_blocks);
	}

	exit(0);
}

mytruncate.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int main(int argc, char const *argv[])
{
	int fd;
	char str[] = "hello\nstone\n";
	if((fd = open("foo", (O_RDWR | O_CREAT | O_TRUNC), 0666)) < 0)
	{
		perror("open error");
		return -1;
	}

	if(write(fd, str, sizeof(str)) != sizeof(str))
	{
		perror("write error");
		return -1;
	}
	/* 截断动作超过文件大小会造成文件空洞 */
	if(ftruncate(fd, 2*sizeof(str)) < 0)
	{
		perror("ftruncate error");
		return -1;
	}
	close(fd);
	return 0;
}

myrdev.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int main(int argc, char const *argv[])
{
	int i;
	struct stat st;
	if(argc<2)
	{
		printf("need some file\n");
		return -1;
	}

	for(i=1; i<argc; i++)
	{
		if(lstat(argv[i] ,&st) < 0)
		{
			perror("lstat error");
			continue;
		}

		printf("file:%s\t %d/%d \t", argv[i], major(st.st_dev), minor(st.st_dev));
		/* 如果是字符或块设备文件(只有它们的st.st_rdev属性不为空) */
		if(S_ISCHR(st.st_mode) || S_ISBLK(st.st_mode))
			printf("(%s)--%d/%d", S_ISBLK(st.st_mode) ? "block" : "character", major(st.st_rdev), minor(st.st_rdev));
	
		putchar('\n');
	}
	return 0;
}

标准IO库
流和 FILE对象

    标准IO库与文件IO区别：
        标准IO库处理很多细节，如缓冲区分片、以优化的块长度执行IO等。
        文件IO函数都是围绕文件描述符进行。首先打开一个文件，返回一个文件描述符；后续的文件IO操作都使用该文件描述符
        标准IO库是围绕流进行的。当用标准IO库打开或者创建一个文件时，就有一个内建的流与之相关联

        标准IO库的函数很多都是以 f开头，如fopen、fclose

    对于ASCII字符集，一个字符用一个字节表示；对于国际字符集，一个字符可以用多个字节表示。
        标准IO文件流可用于单字节或者多字节字符集。流的定向决定了所处理的字符是单字节还是多字节的。
        当一个流最初被创建时，它并没有定向。
            若在未定向的流上使用一个多字节IO函数，则将该流的定向设置为宽定向的（即处理多字节）
            若在未定向的流上使用一个单字节IO函数，则将该流的定向设置为字节定向的（即处理单字节）
        只有两个函数可以改变流的定向
            freopen函数清除一个流的定向
            fwide函数设置流的定向

    fwide函数：设置流的定向

    #include<stdio.h>
    #include<wchar.h>
    int fwide(FILE *fp,int mode);

        参数：
            fp：FILE文件对象的指针
            mode：流的定向模式。
                如果mode是负数，则函数试图使指定的流为字节定向（并不保证修改成功，因为fwide并不改变已定向流的定向）
                如果mode是正数，则函数试图使指定的流为宽定向的（并不保证修改成功，因为fwide并不改变已定向流的定向）
                如果mode为0，则函数不试图设置流的定向，而直接返回该流定向的值
        返回值：
            若流是宽定向的，返回正值
            若流是字节定向的，返回负值
            若流是未定向的，返回0

        这里并没有函数失败的情况

    注意：
        fwide并不改变已定向流的定向。
        如果fp是无效流，由于fwide从返回值无法得知函数执行成功还是失败。那么我们必须采用这个方法：首先在调用fwide之前清除errno。然后在fwide之后检查errno的值。通过errno来检测fwide执行成功还是失败。

    FILE指针：当使用fopen函数打开一个流时，它返回一个执行FILE对象的指针。该对象通常是一个结构，包含了标准IO库为管理该流所需要的所有信息，包括：
        用于实际IO的文件描述符
        指向用于该流缓冲区的指针
        该流缓冲区的长度
        当前在缓冲区中的字符数
        出错标志

    应用程序没必要检验FILE对象，只需要将FILE指针作为参数传递给每个标准IO函数。

    操作系统对每个进程定义了3个流，并且这3个流可以自动地被进程使用，他们都是定义在<stdio.h>中：
        标准输入：预定义的文件指针为stdin，它内部的文件描述符就是STDIN_FILENO
        标准输出：预定义的文件指针为stdout，它内部的文件描述符就是STDOUT_FILENO
        标准错误：预定义的文件指针为stderr，它内部的文件描述符就是STDERR_FILENO

    标准IO库提供缓冲的目的是：尽量减少使用read和write调用的次数。标准IO库对每个IO流自动地进行缓冲管理，从而避免了程序员需要手动管理这一点带来的麻烦。

    标准IO库提供了三种类型的缓冲：
        全缓冲：此时在标准IO缓冲区被填满后，标准IO库才进行实际的IO操作。
        行缓冲：此时当输入和输出中遇到换行符时，标准IO库执行实际的IO操作。但是注意：
            只要填满了缓冲区，即使还没有写一个换行符，也立即进行IO操作
            任何时候只要通过标准IO库，从一个不带缓冲的流或者一个行缓冲的流得到输入数据，则会冲洗所有行缓冲输出流。(即要缓冲输入，先冲洗输出缓冲)
        不带缓冲：标准IO库不对字符进行缓冲存储。此时任何IO都立即执行实际的IO操作。

    另外：
        在一个流上执行第一次IO操作时，相关标准的IO函数通常调用 malloc获取使用的缓冲区
        缓冲区可以由标准的IO操作自动地冲洗（如，当填满一个缓冲区时），也可以手动调用fflush函数冲洗一个流。

    ISO C 要求以下缓冲特征：
        当且仅当标准输入和标准输出并不指向交互式设备时，他们才是全缓冲的
        标准错误绝不会是全缓冲的。

    很多操作系统默认使用下列类型的缓冲：
        标准错误stderr时不带缓冲的
        标准输入stdin和输出stdout：若是指向终端设备的流，则是行缓冲的；否则是全缓冲的

    setbuf/setvbuf函数：设置流的缓冲类型

    #include<stdio.h>
    void setbuf(FILE *restrict fp,char *restrict buf);
    int setvbuf(FILE *restrict fp,char* restrict buf,int mode,size_t size);

        参数：
            fp：被打开的文件对象的指针
            buf：一个缓冲区的指针。缓冲区长度必须为BUFSIZ常量（该常量定义在<stdio.h>中）。
                如果buf为NULL，则是关闭缓冲
                如果buf非NULL，则通常设定该流为全缓冲的。但若该流与一个设备终端相关，则设为行缓冲的

        对于setvbuf函数：
            buf：一个缓冲区的指针。缓冲区长度为size。
                若buf为NULL，且mode为_IONBF：则该流为不带缓冲的。因为此时忽略buf和size参数
                若buf为NULL，且mode不是_IONBF：则标准IO库将自动为该流分配合适长度的缓冲区（即BUFSIZE长度），然后设定该流为指定的mode
            mode：指定缓冲类型。可以为：
                _IOFBF：全缓冲。
                _IOLBF：行缓冲
                _IONBF：不带缓冲。此时忽略buf和size参数
            size：缓冲的长度

        返回值：
            成功： 返回0
            失败： 返回非0(并不是-1)

    注意：
        如果在一个函数内分配一个自动变量类型的标准IO缓冲区，则从该函数返回之前，必须关闭流。因此自动变量是栈上分配，函数返回之后自动变量被销毁
        某些操作系统将缓冲区的一部分存放它自己的管理操作信息，因此可以存放在缓冲区中的实际数据字节数将少于size
        通常推荐利用操作系统自动选择缓冲区长度并自动分配缓冲区。在这种情况下若关闭此流，则标准IO库会自动释放缓冲区

    fflush函数：手动冲洗一个流

    #include<stdio.h>
    int fflush(FILE *fp);

        参数：
            fp：被打开的文件对象的指针

        返回值：
            成功：返回0
            失败：返回EOF (并不是-1)

    该函数会使得该流所有未写的数据都被传送至内核。当fp为NULL时，此函数将导致所有输出流被冲洗。

            冲洗是双向的：输出流 ---> 内核 ---> 磁盘或者终端； 输入流---> 用户缓冲区
            冲洗并不是立即写到磁盘文件中。冲洗只是负责数据传到内核

打开关闭流

    fopen/freopen/fdopen函数：打开标准IO流

    #include<stdio.h>
    FILE *fopen(const char*restrict pathname,const char*restrict type);
    FILE *freopen(const char*restrict pathname,const char*restrict type, FILE *restrict fp);
    FILE *fdopen(int fd,const char*type);

        参数：
            type：指定对该IO流的读写方式：
                "r"或者"rb"：为读打开
                "w"或者"wb"：写打开。若文件存在则把文件截断为0长；若文件不存在则创建然后写
                "a"或者"ab"：追加写打开；若文件存在每次都定位到文件末尾；若文件不存在则创建然后写
                "r+"或者"r+b"或者"rb+"：为读和写打开
                "w+"或者"w+b"或者"wb+"：若文件存在则文件截断为0然后读写；若文件不存在则创建然后读写
                "a+"或者"a+b"或者"ab+"：若文件存在则每次都定位到文件末尾然后读写；若文件不存在则创建然后读写

                    其中b用于区分二进制文件和文本文件。但是由于UNIX内核并不区分这两种文件，所以在UNIX环境中指定b并没有什么卵用
                    创建文件时，无法指定文件访问权限位。POSIX默认要求为：S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH

        对于 fopen函数：
            pathname：待打开文件的路径名
        对于 freopen函数：
            pathname：待打开文件的路径名
            fp：在指定的流上打开文件。若fp已经打开，则先关闭该流；若fp已经定向，则清除该定向。

        对于 fdopen函数：
            fd：打开文件的文件描述符
            对于fopen，type意义稍微有点区别。因为该描述符已经被打开，所以fdopen为写而打开并不截断该文件。另外该文件既然被打开并返回一个文件描述符，则它一定存在。因此标准 IO追加写方式也不能创建文件

        返回值：
            成功： 返回文件指针
            失败： 返回NULL

    这几个函数的常见用途：
        fopen常用于打开一个指定的文件，返回一个文件指针
        freopen常用于将一个指定的文件打开为一个预定义的流（标准输入、标准输出或者标准错误）
        fdopen常用于将文件描述符包装成一个标准IO流。因为某些特殊类型的文件（如管道、socket文件）不能用fopen打开，必须先获取文件描述符，然后对文件描述符调用fdopen。

    注意：当以读和写类型打开一个文件时(type中带+号的类型)，有下列限制：
        如果写操作后面没有fflush,fseek,fsetpos,rewind操作之一，则写操作后面不能紧跟读操作
        如果读操作后面没有fseek,fsetpos,rewind操作之一，也没有到达文件末尾，则在读操作之后不能紧跟写操作

    注意：按照系统默认，流被打开时是全缓冲的。但是如果流引用的是终端设备，则安装系统默认，流被打开时是行缓冲的。

    fclose：关闭一个打开的流

    #include<stdio.h>
    int fclose(FILE *fp);

        参数：
            fp：待关闭的文件指针
        返回值：
            成功： 返回 0
            失败： 返回 -1

    在该文件被关闭之前：
        fclose会自动冲洗缓冲区的输出数据
        缓冲区中的输入数据被丢弃
        若该缓冲区是标准IO库自动分配的，则释放此缓冲区

    当一个进程正常终止时（直接调用exit函数，或者从main函数返回）：
        所有带未写缓存数据的标准IO流都被冲洗
        所有打开的标准IO流都被关闭

- 三个标准IO流的文件描述符依次为 0、1、2
- 未被使用的流不会分配缓冲，因此stdin、stderr的缓冲区地址是 NULL。刚被创建的流的缓冲区地址也是NULL。
- 未被使用的流是未定向的。因此stdin、stderr是未定向的。刚被创建的流的也是未定向的
- 对已经定向的流设置流向，并不会改变流的方向。但是也不报告失败。
- 未分配缓冲区的流，与非缓冲流不是一个概念。非缓冲流是分配了缓冲区的，它的缓冲区长度为1。而未分配缓冲区的流，其缓冲区是无效待分配的。

读写流

    一旦打开了流，可以在3中不同类型的非格式化IO中选择，对流进行读、写操作：
        每次一个字符的IO。一次读、写一个字符。若流是带缓冲的，则标准IO函数处理所有缓冲
        每次一行的IO。一次读、写一行。每一行都以一个换行符终止
        二进制IO。每次IO读、写某种数量的对象。

        格式化IO由printf族函数完成

    getc/fgetc/getchar函数：一次读一个字符：

    #include<stdio.h>
    int getc(FILE*fp);
    int fgetc(FILE*fp);
    int getchar(void);

        参数：
            fp：打开的文件对象指针
        返回值：
            成功：则返回下一个字符
            到达文件尾端：返回EOF
            失败：返回EOF

    注意：
        getchar()等价于getc(stdin)。它从标准输入中读取一个字符
        getc和fgetc的区别在于：getc可能通过宏定义来实现，而fgetc不能实现为宏。因此：
            getc的参数不应该是具有副作用的表达式，因为它可能被计算多次
            fgetc可以得到其地址，这就允许将fgetc的地址作为参数传递。而getc不行
            调用fgetc所需的时间可能比调用getc长，因为函数调用所需时间通常比调用宏长
        这三个函数在返回下一个字符时，将unsigned char类型转换成了int类型。

            因为需要通过返回EOF来标记到达末尾或者出错。而EOF通常是常量 -1 。所以需要返回 int

    ferror/feof函数：查看是读文件出错，还是到达读文件遇到尾端

    #include<stdio.h>
    int ferror(FILE *fp);
    int feof(FILE *fp);

        参数：
            fp：打开的文件对象指针
        返回值：
            若条件为真：则返回非 0
            若条件为假： 则返回 0

    当读流返回EOF时，我们可能不清楚到底是遇到错误，还是读到了文件尾端。此时必须调用ferror或者feof来区别这两种情况。

    clearerr函数：清除文件出错标志和文件结束标志

    #include<stdio.h>
    void clearerr(FILE *fp)

        参数：
            fp：打开的文件对象指针

    在大多数操作系统中，每个流在FILE对象中维护了两个标志：
        出错标志
        文件结束标志

    调用clearerr函数可以清除这两个标志

    ungetc函数：将字符压回流中

    #include<stdio.h>
    int ungetc(int c,FILE *fp);

        参数：
            c：待压入字符转换成的整数值
            fp：打开的文件对象指针
        返回值：
            成功：则返回 c
            失败：返回EOF

    注意：
        若根据某个序列向流中压入一串字符，则再从该流中读取的字符序列是逆序的。即最后压入的字符最先读出
        可以执行任意次数的压入单个字符，但是不支持一次压入多个字符
        不能压入 EOF。但是当已经读到文件尾端时，支持压入一个字符，此时ungetc会清除该流的文件结束标志

        ungetc通常用于这样的情形：正在读取一个输入流，然后需要根据某个字符串（标记字符串）来对输入进行切分。那么我们就需要先看一看下一个字符，来决定如何处理当前字符。此时需要方便的将刚查看的字符回送。

        ungetc只是将字符压入流缓冲区中，并没有压入底层的磁盘文件或者操作系统内核中

    putc/fputc/putchar函数：一次写一个字符

    #include<stdio.h>
    int putc(int c,FILE*fp);
    int fputc(int c,FILE*fp);
    int putchar(int c);

        参数：
            c：待写字符转换成的整数值
            fp：打开的文件对象指针
        返回值：
            成功：则返回 c
            失败：返回EOF

    注意：
        putchar(c)等价于putc(c,stdout)。它向标准输出中写一个字符
        putc和fputc的区别在于：putc可能通过宏定义来实现，而fputc不能实现为宏

    fgets/gets函数：一次读一行字符：

    #include<stdio.h>
    char *fgets(char *restrict buf,int n, FILE* restrict fp);
    char *gets(char *buf);

        参数：
            buf：存放读取到的字符的缓冲区地址

        对于 fgets函数：
            n：缓冲区长度
            fp：打开的文件对象指针

        返回值：
            成功：则返回buf
            到达文件尾端：返回NULL
            失败：返回NULL

    注意：
        对于fgets函数，必须指定缓冲区的长度n。该函数一直读到下一个换行符为止，但是不超过n-1个字符。
            无论读到多少个字符，缓冲区一定以null字节结尾
            若某一行包括换行符超过 n-1个字节，则fgets只返回一个不完整的行；下次调用fgets会继续读该行
        对于gets函数，从标准输入中读取字符。由于无法指定缓冲区的长度，因此很可能造成缓冲区溢出漏洞。故该函数不推荐使用
        对于发生错误和读到末尾，都是返回NULL

    fputs/puts函数：一次写一行字符：

    #include<stdio.h>
    int fputs(const char* restrict str,FILE*restrict fp);
    int puts(const char*str);

        参数：
            str：待写的字符串
            fp：打开的文件对象指针
        返回值：
            成功：则返回非负值
            失败：返回EOF

    注意：
        fputs和puts都是将一个以null字节终止的字符串写到流中，末尾的null字符不写出！。字符串不要求以换行符结尾！
        puts将字符串写到标准输出，末尾的null字符不写出！但是puts随后又将一个换行符写到标准输出中！。而fputs不会自动添加换行符。

        虽然puts是安全的，但是我们也是要避免使用它，以免要记住它在最后是否添加了一个换行符。

    fread/fwrite函数：执行二进制读写IO

    #include<stdio.h>
    size_t fread(void *restrict ptr,size_t size,size_t nobj,FILE *restrict fp);
    size_t fwrite(const void*restrict ptr,size_t size,size_t nobj,FILE *restrict fp);

        参数：
            ptr:存放二进制数据对象的缓冲区地址
            size：单个二进制数据对象的字节数（比如一个struct的大小）
            nobj：二进制数据对象的数量
            fp：打开的文件对象指针
        返回值：
            成功或失败： 读/写的对象数
                对于读：如果出错或者到达文件尾端，则此数字可以少于nobj。此时应调用ferror或者feof来判断究竟是那种情况
                对于写：如果返回值少于nobj，则出错

    使用二进制IO的基本问题是：它只能用在读取同一个操作系统上已写的数据。如果跨操作系统读写，则很可能工作异常。因为：
        同一个struct，可能在不同操作系统或者不同编译系统中，成员的偏移量不同
        存储多字节整数和浮点数的二进制格式在不同的操作系统中可能不同

    有三种方法定位标准IO流

        通过 ftell/fseek函数：

         #include<stdio.h>
         long ftell(FILE *fp);

            参数：fp：打开的文件对象指针

            返回值：
                成功：返回当前文件位置指示
                失败：返回 -1L

            若是二进制文件，则文件指示器是从文件开始位置度量的，并以字节为度量单位。ftell就是返回这种字节位置。

         #include<stdio.h>
         int fseek(FILE *fp,long offset,int whence);

            参数：
                fp：打开的文件对象指针
                offset：偏移量。其解释依赖于whence
                whence：偏移量的解释方式：
                    SEEK_SET常量：表示从文件的起始位置开始
                    SEEK_CUR常量：表示从文件的当前位置开始
                    SEEK_END常量：表示从文件的尾端开始

            返回值：
                成功：返回 0
                失败：返回 -1

                原书说，对文本文件和二进制文件，fseek定位有某些限制。但是经过在ubuntu 16.04上测试，可以任意定位。并没有要求说不能定位到文件尾端，以及必须用SEEK_SET等诸多限制。

         #include<stdio.h>
         void rewind(FILE *fp);

            参数：
                fp：打开的文件对象指针

            rewind函数将一个流设置到文件的起始位置

        通过 ftello/fseeko函数：除了偏移量类型为off_t而不是long以外，ftello/fseeko与ftell/fseek相同

         #include<stdio.h>
         off_t ftello(FILE *fp);

            参数：fp：打开的文件对象指针
            返回值：
                成功：返回当前文件位置指示
                失败：返回 (off_t)-1

         #include<stdio.h>
         int fseeko(FILE *fp,off_t offset,int whence);

            参数：
                fp：打开的文件对象指针
                offset：偏移量。其解释依赖于whence
                whence：偏移量的解释方式：
                    SEEK_SET常量：表示从文件的起始位置开始
                    SEEK_CUR常量：表示从文件的当前位置开始
                    SEEK_END常量：表示从文件的尾端开始
            返回值：
                成功：返回 0
                失败：返回 -1

        fgetpos/fsetpos函数：由 ISO C 引入

         #include<stdio.h>
         int fgetpos(FILE *restrict fp,fpos_t *restrict pos);
         int fsetpos(FILE * fp,const fpos_t * pos);

            参数：
                fp：打开的文件对象指针
                pos：存放偏移量的缓冲区
            返回值：
                成功： 返回 0
                失败： 返回非 0

格式化IO

    格式化输出函数：

    #include<stdio.h>
    int printf(const char *restrict format,...);
    int fprintf(FILE *restrict fp,const char*restrict format,...);
    int dprintf(int fd,const char *restrict format,...);
    int sprintf(char *restrict buf,const char*restrict format,...);
    int snprintf(char *restrict buf,size_t n,const char *restrict format,...);

        参数：
            format,...：输出的格式化字符串

        对于fprintf：
            fp：打开的文件对象指针。格式化输出到该文件中

        对于dprintf：
            fd：打开文件的文件描述符。格式化输出到该文件中

        对于sprintf:
            buf：一个缓冲区的指针。格式化输出到该缓冲区中

        对于snprintf:
            buf：一个缓冲区的指针。格式化输出到该缓冲区中
            n：缓冲区的长度。格式化输出到该缓冲区中

        返回值：
            成功：返回输出字符数（不包含null字节）
            失败：返回负数

    printf将格式化输出写到标准输出；fprintf写到指定的流；dprintf写到指定的文件描述符；sprintf写到数组buf中；snprintf也是写到数组buf中，但是在该数组的尾端自动添加一个null字节（该字节不包含在返回值中）。
        通常不推荐使用sprintf，因为它可能引起缓冲区溢出流动
        如果格式化输出一共 s 个字节，那么snprintf的数组缓冲区至少为s+1个字节，否则发生截断

    格式说明：%[flags][fldwidth][precision][lenmodifier]convtype
        标志flags有：
            ' : 撇号，将整数按照千位分组字符
            - ： 在字段内左对齐输出
            +： 总是显示带符号转换的正负号
            ：空格。如果第一个字符不是正负号，则在其前面加一个空格
            #：指定另一种转换形式（如，对于十六进制格式，加 0x 前缀）
            0：添加前导0（而非空格） 进行填充
        fldwidth：说明最小字段宽度。转换后参数字符如果小于宽度，则多余字符位置用空格填充。
            字段宽度是一个非负十进制数，或者是一个星号 *
        precision：说明整型转换后最少输出数字位数、浮点数转换后小数点后的最少位数、字符串转换后最大字节数。
            精度是一个点.后跟随一个可选的非负十进制数或者一个星号*

        宽度和精度可以为*，此时一个整型参数指定宽度或者精度的值。该整型参数正好位于被转换的参数之前

        lenmodifier：说明参数长度。可以为：
            hh：将相应的参数按照signed char或者unsigned char类型输出
            h：将相应的参数按照signed short或者unsigned short类型输出
            l：将相应的参数按照signed long或者unsigned long或者宽字符类型输出
            ll：将相应的参数按照signed longlong或者unsigned longlong类型输出
            j：intmax_t或者uintmax_t
            z：size_t
            t：ptrdiff_t
            L：long double
        convtype：控制如何解释参数
            d或者i：有符号十进制
            o：无符号八进制
            u：无符号十进制
            x或者X：无符号十六进制
            f或者F：双精度浮点数
            e或者E：指数格式双精度浮点数
            g或者G：根据转换后的值解释为f、F、e、E
            a或者A：十六进制指数格式双精度浮点数
            c：字符（若带上长度修饰符l,则为宽字符）
            s：字符串（若带上长度修饰符l,则为宽字符）
            p：指向void的指针
            n：到目前位置，此printf调用输出的字符的数目将被写入到指针所指向的带符号整型中
            %：一个%字符
            C：宽字符，等效于lc
            S：宽字符串，等效于ls

    printf族的变体：将可变参数(...)替换成了va_list arg:

    #include<stdarg.h>
    #include<stdio.h>
    int vprintf(const char *restrict format,va_list arg);
    int vfprintf(FILE *restrict fp,const char*restrict format,va_list arg);
    int vdprintf(int fd,const char *restrict format,va_list arg);
    int vsprintf(char *restrict buf,const char*restrict format,va_list arg);
    int vsnprintf(char *restrict buf,size_t n,const char *restrict format,va_list arg);

    其参数与返回值与前面的printf族完全相同

    格式化输入函数：

    #include<stdio.h>
    int scanf(const char*restrict format,...);
    int fscanf(FILE *restrict fp,const char *restrict format,...);
    int sscanf(const char *restrict buf,const char *restrict format,...);

        参数：
            format,...：格式化字符串

        对于fscanf：
            fp：打开的文件对象指针。从流中读取输入

        对于sscanf：
            buf：一个缓冲区指针。从该缓冲区中读取输入

        返回值：
            成功：返回赋值的输入项数
            提前到达文件尾端：返回EOF
            失败：返回EOF

    scanf族用于分析输入字符串，将字符序列转换成指定类型的变量。在格式之后的各参数中包含了变量的地址，用转换结果对这些变量赋值。
        除了转换说明和空白字符以外，格式字符串中的其他字符必须与输入匹配。如有一个字符不匹配，则停止后续处理，不再读输入的其余部分。
        转换说明的格式为：%[*][fldwidth][m][lenmodifier]convtype：
            *：用于抑制转换。按照转换说明的其余部分对输入进行转换，但是转换结果不存放在参数中而是抛弃
            fldwidth：说明最大宽度，即最大字符数
            lenmodifier：说明要转换结果赋值的参数大小。见前述说明
            convtype：类似前述说明。但是稍有区别：输入中的带符号的数值可以赋给无符号类型的变量
            m：用于强迫内存分配。当%c,%s时，如果指定了m，则会自动分配内存来容纳转换的字符串。同时该内存的地址会赋给指针类型的变量（即要求对应的参数必须是指针的地址）。同时要求程序员负责释放该缓冲区（通过free函数）

    scanf族也有一类变体：将可变参数(...)替换成了va_list arg:

    #include<stdarg.h>
    #include<stdio.h>
    int vscanf(const char*restrict format,va_list arg);
    int vfscanf(FILE *restrict fp,const char *restrict format,va_list arg);
    int vsscanf(const char *restrict buf,const char *restrict format,va_list arg);

其他

    fileno函数：获取文件对象的文件描述符

    #include<stdio.h>
    int fileno(FILE *fp);

        参数：
            fp：打开的文件对象的指针
        返回值： 返回与该流相关联的文件描述符

    tmpnam/tmpfile函数：创建临时文件

    #include<stdio.h>
    char *tmpnam(char *ptr);
    FILE *tmpfile(void);

        tmpnam参数：
            ptr：指向存放临时文件名的缓冲区的指针
                若为NULL，则产生的路径名存放在一个静态区中，指向该静态区的指针作为函数值返回

                下次再调用tmpnam时，会重写该静态区

                如果为非NULL，则认为它指向长度至少为L_tmpnam个字符的数组，产生的路径名存放在该缓冲区中，返回ptr。L_tmpnam常量定义在<stdio.h>头文件中
        tmpnam返回值：返回指向唯一路径名的指针
        tmpfile返回值：
            成功：返回文件指针
            失败：返回NULL

    tmpnam函数产生一个与现有文件名不同的有效路径名字符串。每次调用它时，都产生一个不同路径名。最多调用次数是TMP_MAX次（定义在<stdio.h>中）

        它只创建独一无二的文件名，但是并不创建临时文件

    tmpfile是创建一个临时二进制文件（类型wb+），在关闭该文件或者程序结束时将自动删除这种文件

        UNIX对二进制文件、文本文件并不进行特殊区分

    mkdtemp/mkstemp函数：创建临时文件（由SUS 标准给出）

    #include<stdlib.h>
    char *mkdtemp(char *template);
    int mkstemp(char *template);

        参数：
            template：一个字符串。这个字符是最末6个字符设置为XXXXXX的路径名。函数将这些占位符替代成不同的字符来构建一个唯一的路径名。若成功的话，这两个函数将修改template字符串来反映临时文件的名字

        因为函数会修改template,因此一定不能用常量字符串来赋值！

        mkdtemp返回值：
            成功：返回指向目录名的指针
            失败：返回NULL
        mkstemp返回值：
            成功： 返回文件描述符
            失败： 返回 -1

    mkdtemp函数创建了一个目录，该目录有一个唯一的名字；mkstemp函数创建了一个文件，该文件有一个唯一的名字。名字是通过template字符串进行构建的。
        mkdtemp函数创建的目录具有权限位集： S_IRUSR|S_IWUSR|S_IXUSR。调用进程的文件模式创建屏蔽字可以进一步限制这些权限
        mkstemp函数返回的文件描述符以读写方式打开。它创建的文件用访问权限位：S_IRUSR|S_IWUSR
        mkstemp创建的临时文件并不会自动删除

    内存流：一种标准IO流，虽然它通过 FILE指针来访问，但是并没有底层的文件 。所有的IO都是通过在缓冲区和主存之间来回传送字节来完成。

        虽然它看起来像是文件流，但是更适用于字符串操作

        创建内存流：

         #include<stdio.h>
         FILE *fmemopen(void *restrict buf,size_t size,const char *restrict type);

            参数：
                buf：内存流缓冲区的起始地址
                size：内存流缓冲区的大小（字节数）
                    若buf为NULL时，则函数负责分配size字节的缓冲区，并在流关闭时自动释放分配的缓冲区
                type:控制如何使用流（即打开内存流的方式）：
                    r或者rb：读打开
                    w或者wb：写打开
                    a或者ab：追加打开；为在第一个null字节处写打开
                    r+或者r+b或rb+：读写打开
                    w+或者w+b或wb+：把文件截断为0，然后读写打开
                    a+或者a+b或ab+：追加；为在第一个null字节处读写打开
            返回值：
                成功：返回流指针
                失败：返回NULL

        注意：
            无论何时以追a方式打开内存流时，当前文件位置设为缓冲区中第一个null字节处。
                若缓冲区中不存在null字节，则当前位置设为缓冲结尾的后一个字节
            当内存流不是a方式打开时，当前位置设置为缓冲区的开始位置
            如果buf是null，则打开流进行读或者写都没有任何意义。因为此时缓冲区是通过fmemopen分配的，没办法找到缓冲区的地址。
            任何时候需要增加流缓冲区中数据流以及调用fclose、fflush、fseek、fseeko、fsetpos时都会在当前位置写入一个null字节

        创建内存流的其他两个函数：

         #include<stdio.h>
         FILE *open_memstream(char **bufp,size_t *sizep);
         #include <wchar.h>
         FILE *open_wmemstream(wchar_t **bufp,size_t *sizep);

            参数：
                bufp：指向缓冲区地址的指针（用于返回缓冲区地址）
                sizep:指向缓冲区大小的指针（用于返回缓冲区大小）
            返回值：
                成功：返回流指针
                失败：返回 NULL

        这两个函数创建的流：
            只能写打开
            缓冲区由函数自动创建
            关闭流后需要程序员释放缓冲区
            对流添加字节会增加缓冲区大小

        在缓冲区地址和大小使用上要遵守规则：
            缓冲区地址和长度只有在调用fclose或者fflush后才有效
            这些值只有在下一次写入或者调用fclose之前才有效。因为缓冲区可能增长，也可能需要重新分配

    标准IO库的缺点：效率不高。这与它需要复制的数据量有关。当使用每次一行的函数fgets/fputs时，通常需要复制两次数据：
        内核和标准IO缓冲区之间（当调用read/write时）
        标准IO缓冲区和用户程序的缓冲区之间

mygetc_putc.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int main(int argc, char const *argv[])
{
	int ret;
	while((ret = getc(stdin)) != EOF)
	{
		if(putc(ret, stdout) == EOF)
		{
			printf("finish\n");
			return 0;
		}
	}

	if(ferror(stdin))
		perror("input stdin error");
	return 0;
}

myfgets_fputs.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int main(int argc, char const *argv[])
{
	char buff[256] = {0};

	while(fgets(buff, 256, stdin) != NULL)/* 行缓冲 */
	{
		if(fputs(buff, stdout) == EOF)
		{
			printf("finish\n");
			return 0;
		}
	}

	if(ferror(stdin))
		printf("input fgets error\n");
	return 0;
}

mybuffertype.c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

bool is_unbuffered(FILE* fp) {
	return fp->_flags & _IONBF;
}

bool is_linebuffered(FILE* fp) {
	return fp->_flags & _IOLBF;
}

bool is_fullbuffered(FILE* fp) {
	return fp->_flags & _IOFBF;
}

int buffer_size(FILE* fp) {
	return fp->_IO_buf_end -
		fp->_IO_buf_base;
}

#define BUFSIZE 4096

void print_iostat(const char* stream, FILE* fp) {
	printf("%s: ", stream);
	if (fp != NULL) {
		if (is_unbuffered(fp))
			printf("nonbuffered");
		else if (is_linebuffered(fp))
			printf("line buffered");
		else
			printf("full buffered");
		printf(", buffer size: %d\n", buffer_size(fp));
	}
	else
		printf("stream invalid\n");
}

int main(int argc, char const *argv[])
{
	FILE *fp;
	fputs("enter any character\n", stdout);
	if(getchar() == EOF)
	{
		perror("getchar got a EOF");
		return -1;
	}	

	fputs("one line output to stderr\n", stderr);

	print_iostat("stdin", stdin);
	print_iostat("stdout", stdout);
	print_iostat("stderr", stderr);

	if((fp = fopen("/etc/passwd", "r")) == NULL)
	{
		perror("fopen error");
		return -1;
	}
	setvbuf(fp,NULL,_IOFBF,BUFSIZE);
	if(getc(fp) == EOF)
	{
		printf("/etc/passwd is empty!\n");
		if(fp) fclose(fp);
		return -1;
	}

	print_iostat("/etc/passwd", fp);		
	fclose(fp);
	return 0;
}

mytmpfile.c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define MAXLINE 1024

int main(int argc, char const *argv[])
{
	char name[L_tmpnam];
	char line[MAXLINE];
	FILE *fp;

	printf("%s\n", tmpnam(NULL)); /* tmpnam参数为空，仅返回指向文件名的指针，文件名存储在静态区，再次调用tmpnam会更新此静态区的内容 */
	tmpnam(name);/* tmpnam只是给出一个在系统中独一无二的名字 */	
	printf("%s\n", name);
	if((fp = tmpfile()) == NULL)
	{
		perror("tmpfile error");
		return -1;
	}
	fputs("hello to a file\n", fp); /* 向临时文件输入字符串 */
	rewind(fp);						/* 调整临时文件的当前偏移量到文件首 */
	if(fgets(line, sizeof(line), fp) == NULL)
	{
		perror("fgets error");
		if(fp) fclose(fp);
		return -1;
	}
	fputs(line, stdout);
	fclose(fp);
	return 0;
}

mymkstemp.c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

void make_temp(char *temp)
{
	int fd;
	struct stat st;

	if((fd = mkstemp(temp)) < 0)
	{
		perror("mkstemp error");
		exit(-1);
	}

	printf("temp name:%s\n", temp);
	close(fd);

	if(lstat(temp, &st) < 0)
	{
		if(errno == ENOENT) 
			printf("no this file\n");
		else 
		{
			perror("stat error");
			exit(-1);
		}
	}
	else
	{
		printf("the file exists\n");
		unlink(temp);
	}
}



int main(int argc, char const *argv[])
{
	char good_tmp[] = "/tmp/dirXXXXXX";
	char *bad_tmp   = "/tmp/dirXXXXXX";
	printf("trying to create first temp file ....\n");
	make_temp(good_tmp);

	printf("trying to create second temp file ....\n");
	make_temp(bad_tmp);
	return 0;
}

mymemopen.c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define BUFFSIZE 64

int main(int argc, char const *argv[])
{
	FILE *fp;
	char buf[BUFFSIZE] = {0};
	memset(buf, 'a', BUFFSIZE-1);
	if((fp = fmemopen(buf, BUFFSIZE, "w+")) == NULL)/* fmemopen的“w+”模式打开会将文件长度清零(O_TRUNC) */
	{
		perror("fmemopen error");
		return -1;
	}
	/* first */
	printf("initial buffer contents: %s\n", buf);
	fprintf(fp, "hello world");
	printf("before fflush: %s\n", buf);
	fflush(fp);
	printf("after  fflush: %s\n", buf);
	printf("length buf: %ld\n", (long)strlen(buf));

	/* second */
	memset(buf, 'b', BUFFSIZE-1);
	fprintf(fp, "hello world");
	printf("before fseek: %s\n", buf);
	fseek(fp, 0, SEEK_SET);
	printf("after  fseek: %s\n", buf);
	printf("length buf: %ld\n", (long)strlen(buf));

	/* third */
	memset(buf, 'c', BUFFSIZE-1);
	fprintf(fp, "hello world");
	fclose(fp);
	printf("after fclose: %s\n", buf);
	printf("length buf: %ld\n", (long)strlen(buf));
	return 0;
}

mygetputc.c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int main(void) {
	int c;
	while ((c = getc(stdin)) != EOF)
		if (putc(c, stdout) == EOF)
			err_sys("output error");
	if (ferror(stdin))
		err_sys("input error");
	exit(EXIT_SUCCESS);
}

myfgetputc.c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int main(void)
{
	int ch;
	while ((ch = fgetc(stdin)) != EOF)
		if (fputc(ch, stdout) == EOF)
			err_sys("output error");
	if (ferror(stdin))
		err_sys("input error");
	exit(EXIT_SUCCESS);
}

myfgetputs.c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int main(void)
{
	char buf[MAXLINE];

	while (fgets(buf, MAXLINE, stdin) != NULL)
		if (fputs(buf, stdout) == EOF)
			err_sys("output error");
	if (ferror(stdin))
		err_sys("input error");
	exit(EXIT_SUCCESS);
}

myfreopen.c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define BUFSIZE 4096

int main(int argc, char* argv[])
{
	if (argc != 3)
		err_sys("usage:reout [false_open_file] [real_open_file]]\n");

	char buf[BUFSIZE];
	FILE* file = fopen(argv[1], "r");
	if (file == NULL)
		err_sys("fopen error\n");
	if (freopen(argv[2], "r", file) == NULL)
		err_sys("freopen error\n");
	if (setvbuf(file, buf, _IOFBF, BUFSIZE) != 0)
		err_sys("setvbuf error\n");

	while (fgets(buf, BUFSIZE, file) != NULL)
		if (fputs(buf, stdout) == EOF)
			err_sys("fputs error\n");
	if (ferror(file))
		err_sys("fgets error\n");

	fclose(file);
	exit(EXIT_SUCCESS);
}

mysetvbuf.c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define BUFSIZE 4096

int main(int argc, char* argv[]) {
	if (argc != 2)
		err_sys("usage:out <filename>\n");

	char outbuf[BUFSIZE];
	char inbuf[BUFSIZE];
	char buf[BUFSIZE];
	FILE* file = fopen(argv[1], "r");
	if (file == NULL)
		err_sys("fopen error\n");
	if (setvbuf(file, inbuf, _IOFBF, BUFSIZE) != 0)
		err_sys("file setvbuf error\n");
	if (setvbuf(stdout, outbuf, _IOFBF, BUFSIZE) != 0)
		err_sys("stdout setvbuf error\n");


	while (fgets(buf, BUFSIZE, file) != NULL)
		if (fputs(buf, stdout) == EOF)
			err_sys("fputs error\n");
	if (ferror(file))
		err_sys("fgets error\n");

	if (fclose(file))
		err_sys("fclose error\n");
	exit(EXIT_SUCCESS);
}


myreadwrite.c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define BUFSIZE 4096

int main(void)
{
	int val;
	char buf[BUFSIZE];

	while ((val = read(STDIN_FILENO, buf, BUFSIZE)) > 0)
		if (write(STDOUT_FILENO, buf, val) != val)
			err_sys("output error");
	if (val < 0)
		err_sys("input error");
	exit(EXIT_SUCCESS);
}

mysetbuf.c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

bool is_unbuffered(FILE* fp) {
	return fp->_flags & _IONBF;
}

bool is_linebuffered(FILE* fp) {
	return fp->_flags & _IOLBF;
}

bool is_fullbuffered(FILE* fp) {
	return fp->_flags & _IOFBF;
}

int buffer_size(FILE* fp) {
	return fp->_IO_buf_end -
		fp->_IO_buf_base;
}

#define BUFSIZE 4096

void print_iostat(const char* stream, FILE* fp) {
	printf("%s: ", stream);
	if (fp != NULL) {
		if (is_unbuffered(fp))
			printf("nonbuffered");
		else if (is_linebuffered(fp))
			printf("line buffered");
		else
			printf("full buffered");
		printf(", buffer size: %d\n", buffer_size(fp));
	}
	else
		printf("stream invalid\n");
}


void SetBuf(FILE* restrict fp, char* restrict buf) {
	if (setvbuf(fp, buf, buf ? _IOFBF : _IONBF, BUFSIZ) != 0)
		err_sys("setvbuf error\n");
}

int main(int argc, char* argv[])
{
	if (argc != 2)
		err_sys("usage:out <filename>\n");
	
	char buf[BUFSIZ];
	FILE* fp = fopen(argv[1], "r");
	if (fp == NULL)
		err_sys("fopen error\n");

	SetBuf(fp, buf);

	if (getc(fp) == EOF)
		err_sys("getc error\n");
	print_iostat("file stream", fp);

	fclose(fp);
	exit(EXIT_SUCCESS);
}

系统数据文件和信息

    UNIX系统的正常运作需要使用大量与系统有关的数据文件。如口令文件 /etc/passwd/和组文件/etc/group
        由于历史原因，这些数据文件都是 ASCII 文本文件
        我们可以用标准 IO 库来读取这些文件，但是也可以有专门的 API 来读取这些文件

系统文件

    UNIX口令文件 /etc/passwd/是一个ASCII文件，每一行包含很多字段，字段之间用冒号分隔。这些字段包含在<pwd.h>头文件定义的passwd，该结构有如下成员：
        char *pw_name：用户名
        char *pw_passwd：加密口令
        uid_t pw_uid：数值用户ID
        gid_t pw_gid：数值组ID
        char *pw_gecos：注释字段
        char *pw_dir：初始工作目录
        char *pw_shell：初始shell
        char *pw_class：用户访问类
        time_t pw_change：下次更改口令时间
        time_t pw_expire：账户有效期时间

    关于口令文件：
        通常有一个用户名为root的登录项，其用户ID是 0
        加密口令字段包含一个占位符。现在加密口令其实是放在另一个文件中
        口令文件中某些字段可能为空。
            如果加密口令字段为空，则说明该用户没有口令
            如果注释字段为空，则没有任何影响
        shell字段指定了初始shell
            若它为空，则取系统默认值（通常是/bin/sh）
            若它为/dev/null，则会阻止任何人以该字段所在行记录中的用户名来登录系统
        用户名如果是nobody，则任何人都可以使用它登录系统，但是其用户ID和组ID不提供任何特权。该用户ID和组ID只能访问人人皆可读、可写的文件
        在Linux中，没有 pw_class,pw_change,pw_expire字段

    getpwuid/getpwnam函数：读取口令文件：

    #include<pwd.h>
    struct passwd* getpwuid(uid_t uid);
    struct passwd* getpwnam(const char*name);

        参数：
            uid：用户ID
            name：用户名
        返回值：
            成功：返回passwd结构的指针
            失败：返回NULL

    注意：getpwuid/getpwnam函数返回的 struct passwd结构通常是函数内部的静态变量，因此多次调用上面的函数，该静态变量会被覆写。

    查看整个口令文件，使用下面的函数：

    #include<pwd.h>
    struct passwd *getpwent(void);
    void setpwent(void);
    void endpwent(void);

        getpwent返回值：
            成功：返回passwd结构的指针
            失败：返回NULL
            到达文件尾端：返回NULL

    用法：
        调用getpwent时，它返回口令文件中的下一个记录项

            返回的 struct passwd结构通常是函数内部的静态变量，因此多次调用getpwent函数，该静态变量会被覆写

        在第一次调用getpwent函数时，它会打开所使用的各个文件
        getpwent对返回的各个记录项顺序并没有要求
        setpwent会反绕getpwent所使用的文件到文件起始处。即当调用setpwent之后，getpwent又会从头开始读取记录项
        endpwent会关闭getpwent所使用的文件。在调用getpwent读取完口令文件后，一定要调用endpwent关闭这些文件

            getpwent知道什么时候应该打开它所使用的文件（第一次被调用时），但是不知道何时应该关闭这些文件

    加密口令是经单向加密算法处理过的用户口令副本。

        因为此算法是单向的，所以不能从加密口令猜测到原始口令

    现在的UNIX将加密口令存放在一个称作阴影口令的文件中（即文件/etc/shadow）。该文件至少应该包含用户名和加密口令。这些字段包含在<shadow.h>头文件的struct spwd结构中。相关的字段如下：
        char *sp_namp：用户登录名
        char *sp_pwdp：加密口令
        int sp_lstchg：上次更改口令以来经过的时间
        int sp_min：经过多少天后允许修改口令
        int sp_max：经过多少天后必须修改口令
        int sp_warn：经过多少天后如果未修改口令则系统发出警告
        int sp_inact：经过多少天后，该账户是inactive
        int sp_expire：经过多少天后，该账户过期
        unsigned int sp_flag：保留字段

    其中只有用户登录名和加密口令这两个字段是必须的。其他字段都是用于控制口令更改的频率。 注意：
        阴影口令文件/etc/shadow 不应该由一般用户读取。
            仅有少数几个程序需要访问加密口令，如login,passwd。这些程序通常是设置用户ID为root的程序
            普通口令文件/etc/passwd/可以任由各用户读取

    用于读取阴影口令文件的函数为：

    #include<shadow.h>
    struct spwd *getspnam(const char*name);
    struct spwd *getspent(void);
    void setspent(void);
    void endspent(void);

        getspnam参数：
            name：用户名
        getspnam返回值：
            成功：返回spwd结构指针
            失败：返回NULL
        getspent返回值：
            成功：返回spwd结构指针
            失败：返回NULL
            到达文件尾端：返回NULL

    用法：
        调用 getspnam时，它返回阴影口令文件中，对应用户名的那一条记录项

            返回的 struct spwd结构通常是函数内部的静态变量，因此多次调用getspnam函数，该静态变量会被覆写

        调用getspent时，它返回阴影口令文件中的下一个记录项

            返回的 struct spwd结构通常是函数内部的静态变量，因此多次调用getspent函数，该静态变量会被覆写

        在第一次调用getspent函数时，它会打开所使用的各个文件
        getspent对返回的各个记录项顺序并没有要求
        setspent会反绕getspent所使用的文件到文件起始处。即当调用setspent之后，getspent又会从头开始读取记录项
        endspent会关闭getspent所使用的文件。在调用getspent读取完阴影口令文件后，一定要调用endspent关闭这些文件

            getspent知道什么时候应该打开它所使用的文件（第一次被调用时），但是不知道何时应该关闭这些文件

    UNIX 组文件包含的字段定义在<grp.h>所定义的group结构中：
        char *gr_name：组名
        char *gr_passwd：加密口令
        int gr_gid：组ID
        char **gr_mem：指向各用户名指针的数组

            它是一个指针数组，其中每个指针指向一个属于该组的用户名。该数组以null指针结尾

    getgrgid/getgrnam函数：查看组文件：

    #include<grp.h>
    struct group* getgrgid(gid_t gid);
    struct group* getgrnam(const char* name);

        参数：
            gid：组ID
            name：组名
        返回值：
            成功：返回group结构的指针
            失败：返回NULL

    注意：getgrgid/getgrnam函数返回的 struct group结构通常是函数内部的静态变量，因此多次调用上面的函数，该静态变量会被覆写。

    查看整个组文件，使用下面的函数：

    #include<grp.h>
    struct group *getgrent(void);
    void setgrent(void);
    void endgrent(void);

        getgrent返回值：
            成功：返回group结构的指针
            失败：返回NULL
            到达文件尾端：返回NULL

    用法：
        调用getgrent时，它返回组文件中的下一个记录项

            返回的 struct group结构通常是函数内部的静态变量，因此多次调用getgrent函数，该静态变量会被覆写

        在第一次调用getgrent函数时，它会打开所使用的各个文件
        getgrent对返回的各个记录项顺序并没有要求
        setgrent会反绕getgrent所使用的文件到文件起始处。即当调用setgrent之后，getgrent又会从头开始读取记录项
        endgrent会关闭getgrent所使用的文件。在调用getgrent读取完组文件后，一定要调用endgrent关闭这些文件

            getgrent知道什么时候应该打开它所使用的文件（第一次被调用时），但是不知道何时应该关闭这些文件

    UNIX中还提供了附属组ID。其中获取和设置附属组ID的函数为：

    #include<unistd.h>
    int getgroups(int gidsetsize,gid_t grouplist[]);

    #include<grp.h>    	//对Linux
    #include<unistd.h>	//对 FreeBSD, Mac OS X, Solaris
    int setgroups(int ngroups,const gid_t grouplist[]);

    #include<grp.h>    	//对Linux
    #include<unistd.h>	//对 FreeBSD, Mac OS X, Solaris
    int initgroups(const char *username, gid_t basegid);	

    参数：
        对于getgroups函数：
            gidsetsize：填入grouplist数组的附属组ID的最大数量

                若该值为0，则函数只返回附属组ID数，而不修改grouplist数组

            grouplist：存放附属组ID的数组
        对于setgroups函数：
            ngroups：grouplist数组中元素个数

                数量不能太大，不能超过NGROUPS_MAX

            grouplist：待设置的附属组ID的数组
        对于initgroups函数：
            username：用户名
            basegid：用户的base组ID（它就是在口令文件中，用户名对于的组ID）

    返回值：
        对于getgroups函数：
            成功：返回附属组ID的数量
            失败：返回 -1
        对于setgroups/initgroups函数：
            成功：返回 0
            失败：返回 -1

    用法：
        getgroups函数将进程所属用户的各附属组ID填写到grouplist中，填入该数组的附属组ID数最多为gidsetsize个。实际填写到数组中的附属组ID数由函数返回
        setgroups函数可由超级用户调用以便为调用进程设置附属组ID表。
        由于initgroups函数会在内部调用setgroups函数，因此它也必须由超级用户调用

    除了口令文件和组文件之外，系统中还有很多其他重要的数据文件。UNIX对于这些系统数据文件提供了对应的类似的API。对于每种数据文件，至少有三个函数：
        get函数：读下一个记录。如果需要还会打开该文件。
            此种函数通常返回一个指向某个结构的指针。
            当已到达文件尾端时，返回空指针
            大多数get函数返回指向一个静态存储类结构的指针，如果需要保存其内容，则需要复制该结构
        set函数：打开相应数据文件（如果尚未打开），然后反绕该文件
            如果希望在相应文件起始处开始处理，则调用该函数
        end函数：关闭相应数据文件。在结束了对相应数据文件的读、写操作后，总应该调用此函数以关闭所有相关文件

    另外如果数据文件支持某种形式的键搜索，则也提供搜索具有指定键的记录的函数

    下面是各个重要的数据文件：
    说明 	数据文件 	头文件 	结构 	附加的键搜索函数
    口令 	/etc/passwd 	<pwd.h> 	passwd 	getpwnam,getpwuid
    组 	/etc/group 	<grp.h> 	group 	getgrnam,getgrgid
    阴影 	/etc/shadow 	<shadow.h> 	spwd 	getspnam
    主机 	/etc/hosts 	<netdb.h> 	hostent 	getnameinfo,getaddrinfo
    网络 	/etc/networks 	<netdb.h> 	netent 	getnetbyname,getnetbyaddr
    协议 	/etc/protocols 	<netdb.h> 	protoent 	getprotobyname,getprotobynumber
    服务 	/etc/services 	<netdb.h> 	servent 	getservbyname,getservbyport

    大多数UNIX系统都提供了两个数据文件：
        utmp文件：记录了当前登录到系统的各个用户
        wtmp文件：跟踪各个登录和注销事件

    每次写入到这两个文件的是下列结构的一个二进制记录：

    struct utmp{
    	char ut_line[8];   // 登录的 tty 
    	char ut_name[9];   //登录用户名
    	long ut_time;	   //自1970.01.01 00：00：00 经过的秒数
    }

        登录时，login程序填写此类结构，然后将其写入到utmp文件中，同时也将其添写到wtmp文件中
        注销时，init进程将utmp文件中相应的记录擦除（每个字节都填写null字节），并将一个新的记录添写到wtmp文件中
        在系统重启时，以及更改系统时间和日期的前后，都将在wtmp文件中追加写特殊的记录项

            who程序会读取utmp文件；last程序会读取wtmp文件

        linux系统中，这两个文件的路径是/var/run/utmp以及/var/log/wtmp

    uname函数：返回主机和操作系统的有关信息：

    #include<sys/utsname.h>
    int uname(struct utsname *name);

        参数：
            name：一个utsname结构的地址，该函数会填写此结构
        返回值：
            成功： 返回非负值
            失败： 返回 -1

    POSIX 之定义了utsname结构最少需要提供的字段（全部是字符数组），某些操作系统会在该结构中提供了另外一些字段：

    struct utsname {
    	char sysname[];  //操作系统的名字
    	char nodename[]; // 节点名字
    	char release[];  //当前操作系统的 release
    	char version[];  //该 release 的版本
    	char machine[];  //硬件类型
    }

    这些字符串都是以null结尾。

        通常 uname 命令会打印utsname结构中的信息

    gethostname函数：返回主机名。改名字通常就是 TCP/IP 网络上主机的名字：

    #include<unistd.h>
    int gethostname(char *name,int namelen);

        参数：
            name：放置主机名字符串的缓冲区
            namelen：name缓冲区的长度

                如果缓冲区够长，则通过name返回的字符串以null结尾；如果缓冲区不够长，则标准没有说通过name返回的字符串是否以null结尾

        返回值：
            成功： 返回 0
            失败： 返回 -1

        hostname命令可以获取和设置主机名

时间和日期

    UNIX内核提供的基本时间服务是自 UTC 1970-01-01 00：00：00 这一特定时间以来经过的秒数。
        这个时间称作日历时间，用数据类型 time_t 表示（它包括了时间和日期）
        UNIX 提供若干个时间函数来转换日历时间

    time函数：返回当前的日历时间

    #include<time.h>
    time_t time(time_t *calptr);

        参数：
            calptr：如果该指针不是NULL，则返回的日历时间也存放在calptr指向的内存中
        返回值：
            成功：返回当前日历时间的值
            失败：返回 -1

    clock_gettime函数：用于获取指定的时钟类型的时间：

    #include<sys/time.h>
    int clock_gettime(clockid_t clock_id,struct timespec *tsp);

        参数：
            clock_id：时钟类型。
                CLOCK_REALTIME：获取实时系统时间。此时clock_gettime函数提供了与time函数类似的功能。不过在系统支持高精度时间值的情况下，clock_gettime可能比time函数得到更高精度的时间值。
                CLOCK_MONOTONIC：获取不带负跳数的实时系统时间
                CLOCK_PROCESS_CPUTIME_ID：调用进程的CPU时间
                CLOCK_THREAD_CPUTIME_ID：调用线程的CPU时间
            tsp：存放获取时间的timespec结构（它把时间表示为秒和纳秒）的指针
        返回值：
            成功： 返回 0
            失败： 返回 -1

    clock_getres函数：时间精度调整

    #include<sys/time.h>
    int clock_getres(clockid_t clock_id,struct timespec *tsp);

        参数：
            clock_id：时钟类型。
            tsp：存放时间的timespec结构（它把时间表示为秒和纳秒）的指针
        返回值：
            成功： 返回 0
            失败： 返回 -1

    clock_getres函数把参数tsp指向的timespec结构初始化为与clock_id参数对应的时钟精度

    clock_settime函数：设置时间

    #include<sys/time.h>
    int clock_settime(clockid_t clock_id,const struct timepsec *tsp);

        参数：
            clock_id：时钟类型。
            tsp：存放时间的timespec结构（它把时间表示为秒和纳秒）的指针
        返回值：
            成功： 返回 0
            失败： 返回 -1

    clock_settime函数对特定的时钟设置时间。但是：
        某些时钟是不能修改的
        需要适当的权限来修改时钟值

    gettimeofday函数：更高精度的获取当前时间（但是目前已经弃用）

    #include<sys/time.h>
    int gettimeofday(struct timeval *restrict tp,void *restrict tzp);

        参数：
            tp：存放当前时间的timeval结构（将当前时间表示为秒和微秒）的指针
            tzp：唯一合法值是NULL。其他任何值都产生未定义的结果
        返回值：总是返回 0

    gmtime/localtime函数：将日历时间转换成struct tm结构：

    #include<time.h>
    struct tm* gmtime(const time_t *calptr);
    struct tm* localtime(const time_t *calptr);

        参数：calptr：指向日历时间的指针
        返回值：
            成功：指向struct tm结构的指针
            失败：返回NULL

    struct tm{
    	int tm_sec; 	//秒数，范围是 [0~60]
    	int tm_min; 	//分钟数，范围是 [0~59]
    	int tm_hour;	//小时数，范围是 [0~23]。午夜12点是 0
    	int tm_mday;	//一个月中的天数，范围是 [1~31]
    	int tm_mon; 	//月数，范围是 [0~11] ，一月是 0	
    	int tm_year;	//年数，范围是 [1900~]，如果是16则表示 1916	
    	int tm_wday;	//一个星期中的天数，范围是 [0~6] ，周日是0
    	int tm_yday;	//一年中的天数，范围是 [0~365]，一月一号是 0
    	int tm_isdst;  //daylight saving time flag
    }

    其中秒可以超过 59 的理由是表示润秒

    gmtime/localtime函数的区别：
        gmtime：将日历时间转换成统一协调的年月日时分秒周日分解结构
        localtime：将日历时间转换成本地实际（考虑本地市区和夏令时标志），由TZ环境变量指定

        TZ环境变量影响localtime/mktime/strftime这三个函数：
            如果定义了TZ环境变量：则这些函数将使用TZ的值代替系统默认时区
            如果TZ定位为空TZ=，则使用UTC作为时区

    mktime函数：以本地时间的年月日等作为参数，将其变化成time_t值：

    #include<time.h>
    time_t mktime(struct tm*tmptr);

        参数： tmptr：指向struct tm结构的指针
        返回值：
            成功： 返回日历时间
            失败： 返回 -1

    所谓的本地实际的”本地“：由 TZ环境变量指定

    strftime/strftime_l函数：类似printf的打印时间的函数。它们可以通过可用的多个参数来定制产生的字符串

    #include<time.h>
    size_t strftime(char *restrict buf,size_t maxsize,const char*restrict format,
    	const struct tm* restrict tmptr);
    size_t strftime_l(char *restrict buf,size_t maxsize,const char*restrict format,
    	const struct tm* restrict tmptr,locale_t locale);

        参数：
            buf：存放格式化后的时间字符串的缓冲区的地址
            maxsize：存放格式化后的时间字符串的缓冲区的大小
            format：时间的格式化字符串
            tmptr：存放时间的struct tm结构的指针

        对于strftime_l 函数：
            locale：指定的区域

        返回值：
            成功：返回存入buf的字符数
            失败： 返回 0

    注意：
        如果buf长度足够存放格式化结果以及一个null终止符，则这两个函数才有可能顺利转换；否则空间不够，这两个函数返回0，表示转换失败
        strftime_l运行调用者将区域指定为参数；而strftime使用通过TZ环境变量指定的区域
        format参数控制时间值的格式。如同printf，转换说明的形式是百分号之后跟随一个特定的字符，而format中的其他字符则按照原样输出：
            %a：缩写的周日名，如Thu
            %A：周日名，如Thursday
            %b：缩写的月名：如Jan
            %B：全月名，如January
            %c：日期和时间，如Thu Jan 19 21:24:25 2012
            %C：年的最后两位，范围是（00～99），如20
            %d：月日，范围是 (01~31)，如19
            %D日期（MM/DD/YY），如01/19/12
            %e月日（一位数字前加空格）（1～31），如19
            %F：ISO 8601 日期格式 (YYYY-MM-DD)，如 2012-01-19
            %g：ISO 8601 年的最后2位数（00～99），如12
            %G：ISO 8601 的年，如 2012
            %h：与 %b 相同，缩写的月名
            %H：小时（24小时制）（00～23）
            %I：小时（12小时制）（01～12）
            %j：年日（001～366），如019
            %m：月（01～12），如 01
            %M：分（00～59），如 24
            %n：换行符
            %p：AM/PM
            %r：本地时间（12小时制），如 09：24：52 PM
            %R：与 %H：%M相同
            %S：秒（00～60），如 52
            %t：水平制表符
            %T：同 %H：%M：%S 相同，如 21：24：52
            %u：ISO 8601 周几（1～7，1为周一）
            %U：一年的星期日周数（00～53）
            %V：ISO 8601 周数（01～53）
            %w：周几：（0～6，周日为0）
            %W：一年的星期一周数（00～53）
            %x：本地日期，如 01/19/12
            %X：本地时间，如21：24：52
            %y：年的最后两位（00～99）
            %Y：年，如2012
            %z：ISO 8601 格式的UTC偏移量，如 -0500
            %Z：时区名，如EST
            %%：百分号

    strptime函数：它是strftime的逆向过程，把时间字符串转换成struct tm时间

    #include<time.h>
    char *strptime(const char*restrict buf,const char*restrict format,
    	struct tm*restrict tmptr);

        参数：
            buf：存放已经格式化的时间字符串的缓冲区的地址
            format：给出了buf缓冲区中的格式化时间字符串的格式
            tmptr：存放时间的struct tm结构的指针
        返回值：
            成功：返回非NULL
            失败：返回NULL

    注意：strptime的格式化说明与strftime的几乎相同，但是下列会有区别
        %a：缩写或者完整的周日名
        %A：同%a
        %b：缩写或者完整的月名
        %B：同%b
        %n：任何空白
        %t：任何空白

mygetnameinfo.c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int main(int argc, char const *argv[])
{
	struct passwd *ptr;
	setpwent();
	while((ptr = getpwent()) != NULL)
		printf("name:%s\tpasswd:%s\tuid:%d\tgid:%d\treal name:%s\tdir:%s\tshell:%s\n", ptr->pw_name, ptr->pw_passwd, ptr->pw_uid, ptr->pw_gid, ptr->pw_gecos, ptr->pw_dir, ptr->pw_shell);
	endpwent();
	return 0;
}

myuserinfo.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

struct passwd * GetpwNam(const char* name) {
	struct passwd* p = NULL;

	setpwent();
	while ((p = getpwent()) != NULL)
		if (strcmp(name, p->pw_name) == 0)
			break;
	endpwent();
	return p;
}

int main(int argc, char* argv[])
{
	if (argc != 2)
		err_sys("usage:userinfo <username>\n");

	struct passwd* pwd = GetpwNam(argv[1]);
	if (pwd == NULL)
		err_sys("GetpwNam error\n");
	printf("username: %s\n", pwd->pw_name);
	printf("uid     : %u\n", pwd->pw_uid);
	printf("gid     : %u\n", pwd->pw_gid);
	printf("home dir: %s\n", pwd->pw_dir);
	printf("shell   : %s\n", pwd->pw_shell);

	exit(EXIT_SUCCESS);
}

myshadow.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include<shadow.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

struct spwd* GetspNam(const char* name) {
	struct spwd* pret = NULL;
	setspent();
	while ((pret = getspent()) != NULL)
		if (strcmp(pret->sp_namp, name) == 0)
			break;
	endspent();
	return pret;
}

int main(int argc, char* argv[])
{
	if (argc != 2)
		err_sys("usage:spw <username>\n");

	struct spwd* ptr;
	if ((ptr = GetspNam(argv[1])) == NULL)
		err_sys("getspnam error\n");

	printf("hash passwd:\n%s\n", ptr->sp_pwdp == NULL || ptr->sp_pwdp[0] == '\0' ?
		"(none)" : ptr->sp_pwdp);

	exit(EXIT_SUCCESS);
}

mygroupinfo.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include<shadow.h>
#include<grp.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

struct group* GetgrNam(const char* name) {
	struct group* p = NULL;
	
	setgrent();
	while ((p = getgrent()) != NULL)
		if (strcmp(name, p->gr_name) == 0)
			break;
	endgrent();
	return p;
}

int main(int argc, char* argv[])
{
	if (argc != 2)
		err_sys("usage:groupinfo <groupname>\n");

	struct group* pgrp = GetgrNam(argv[1]);
	if (pgrp == NULL)
		err_sys("GetgrNam error\n");
	printf("group name : %s\n", pgrp->gr_name);
	printf("group id   : %u\n", pgrp->gr_gid);
	if (pgrp->gr_mem != NULL) {
		char** pp = pgrp->gr_mem;
		printf("group mem  :");
		while(*pp!=NULL)
			printf(" %s", *pp++);
		putchar('\n');
	}

	exit(EXIT_SUCCESS);
}

mygetgroups.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include<shadow.h>
#include<grp.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define GRP_NUM 10

static struct group* GetgrpUid(gid_t gid) {
	struct group* pret = NULL;

	setgrent();
	while ((pret = getgrent()) != NULL)
		if (pret->gr_gid == gid)
			break;
	endgrent();
	return pret;
}

int main(int argc, char* argv[])
{
	gid_t grparr[GRP_NUM];
	int mem_size = getgroups(GRP_NUM, grparr);
	if (mem_size > 0) {
		int i = 0;
		printf("group mem :");
		while (i < mem_size)
			printf(" %s", GetgrpUid(grparr[i++])->gr_name);
		putchar('\n');
	}
	
	exit(EXIT_SUCCESS);
}

myuname.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include<shadow.h>
#include<grp.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include<sys/utsname.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int main(void) {
	struct utsname utsbuf;
	if (uname(&utsbuf) != 0)
		err_sys("uname error\n");

	const char* domain = utsbuf.__domainname;
	printf("%s %s %s %s %s %s\n",
		utsbuf.sysname, utsbuf.nodename, utsbuf.release, utsbuf.version,
		utsbuf.machine, strcmp(domain,"(none)")==0?"":domain);

	exit(EXIT_SUCCESS);
}

myhostname.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include<shadow.h>
#include<grp.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include<sys/utsname.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int main(void)
{
	char buf[128] = {0};
	if (gethostname(buf, sizeof(buf)) != 0) {
		fprintf(stderr, "gethostname error\n");
		exit(EXIT_FAILURE);
	}
	printf("hostname: %s\n", buf);

	exit(EXIT_SUCCESS);
}

myctime.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#include<time.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include<shadow.h>
#include<grp.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include<sys/utsname.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int main(void)
{
	time_t realtime = time(NULL);
	printf("%s", ctime(&realtime));
	exit(0);
}

mystrftime.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#include<time.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include<shadow.h>
#include<grp.h>
#include <sys/types.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include<sys/utsname.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int main(void)
{
	time_t nowtime;
	struct tm* ptm;
	char buf[128] = {0};

	time(&nowtime);
	if ((ptm = localtime(&nowtime)) == NULL)
		err_sys("localtime error\n");
	if (strftime(buf, sizeof(buf), "%c %Z\n", ptm) == 0)
		err_sys("strftime error\n");
	fputs(buf,stdout);

	exit(EXIT_SUCCESS);
}

mydate.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#include<time.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/utsname.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

const char* getweek(int w) {
	switch (w) {
	case 1:return "Monday";
	case 2:return "Tuesday";
	case 3:return "Wednesday";
	case 4:return "Thursday";
	case 5:return "Friday";
	case 6:return "Saturday";
	case 0:return "Sunday";
	default:return NULL;
	}
}

int main(void)
{
	struct timeval timevalbuf;
	struct tm* ptm;
	gettimeofday(&timevalbuf, NULL);
	if((ptm=localtime(&(timevalbuf.tv_sec)))==NULL)
		err_sys("localtime error\n");

	printf("%d-%d-%d %d:%d:%d %s\n", ptm->tm_year+1900, ptm->tm_mon+1,
		ptm->tm_mday, ptm->tm_hour, ptm->tm_min,ptm->tm_sec,getweek(ptm->tm_wday));

	exit(EXIT_SUCCESS);
}

进程环境
进程相关

    C程序总是从main函数开始执行的。main函数的原型是：

    int main(int argc,char* argv[]);

        参数：
            argc：命令行参数的数目
            argv：由指向各命令行参数的指针所组成的数组。ISOC和POSIX都要求argv[argc]是一个空指针

    当内核执行 C 程序时，在调用main之前先调用一个特殊的启动例程。
        内核执行C程序是通过使用一个exec函数实现的
        可执行程序文件将此启动例程指定为程序的起始地址（这是由链接器设置的，而链接器由C编译器调用）
        启动例程从内核取得命令行参数和环境变量值，然后为调用main函数做好安排

    有 8 种方式使得进程终止，其中 5 种为正常终止，3 种异常终止：
        正常终止方式：
            从main函数返回
            调用exit函数
            调用_exit函数或者_Exit函数
            多线程的程序中，最后一个线程从其启动例程返回
            多线程的程序中，最后一个线程调用pthread_exit函数
        异常终止方式：
            调用abort函数
            接收到一个信号
            多线程的程序中，最后一个线程对取消请求作出响应

        关于多线程部分，在多线程章节讲述

    当内核执行 C 程序时，在调用main之前先调用一个特殊的启动例程。该启动例程是这样编写的：从main函数返回后立即调用exit函数。其形式为exit(main(argc,argv))。

        实际上启动例程通常是汇编语言编写的

    exit/_Exit/_exit函数：正常终止一个程序

    #include<stdlib.h>
    void exit(int status);
    void _Exit(int status);
    #include<unistd.h>
    void _exit(int status);

        参数：status：终止状态

    上述三个退出函数的区别：
        _exit和_Exit函数：立即进入内核
        exit函数：先执行一些清理处理，然后返回内核

            “清理”代表什么？见下文

        exit和_Exit是由ISOC说明的， _exit是由POSIX说明的 ，因此头文件不同

    注意：
        上述三个函数都带有一个整型参数，称为终止状态（或称作退出状态）。大多数 UNIX 系统 shell 都提供检查进程终止状态的方法
            若调用上述三个函数时不带终止状态，则该进程的终止状态是未定义的
            若main执行了一个无返回值的return语句，则该进程的终止状态是未定义的
            若main没有声明返回类型为整型，则该进程的终止状态是未定义的
            若main声明返回类型为整型，并且main执行到最后一条语句时返回（隐式返回），则该进程的终止状态是 0
        main函数返回一个整型值与用该值调用exit是等价的。即main函数中，exit(100);等价于return 100;
        在LINUX中，退出状态码最高是255，一般自定义的代码值为0~255，如果超出255，则返回该数值被256除了之后的余数

    atexit函数：登记由exit函数调用的清理函数

    #include<stdlib.h>
    int atexit(void (*func) (void));

        参数：
            func：函数指针。它指向的函数的原型是：返回值为void，参数为void
        返回值：
            成功：返回 0
            失败：返回非 0

    一个进程可以登记最多 32 个函数，这些函数将由exit函数自动调用。这些函数称作终止处理程序（exit handler）。而atexit函数就是登记exit handler的
        exit调用这些exit handler的顺序与它们登记的时候顺序相反
        如果同一个exit handler被登记多次，则它也会被调用多次

        通常操作系统会提供多于32个exit handler的限制。可以用sysconf函数查询这个限制值

    C程序的启动和终止
        exit函数首先调用各终止处理程序，然后关闭（通过fclose）所打开的流。
        内核执行程序的唯一方法是调用一个exec函数
        内核自愿终止的唯一方法是显式或者隐式（通过调用exit函数）的调用_exit或者_Exit

    每个程序都会接收一张环境表。
        与参数表一样，环境表也是一个字符指针数组
            其中数组中的每个指针指向一个以null结束的 C 字符串，这些字符串称之为环境字符串
            数组的最后一项是null
        全局变量envrion包含了该指针数组的地址：extern char **envrion。我们称environ为环境指针，它位于头文件unistd.h中
        按照惯例，环境字符串由name=value这种格式的字符串组成

    C程序的存储空间布局：C程序一直由下列几部分组成：
        正文段：这是由CPU执行的机器指令部分。
            通常正文段是可以共享的。一个程序的可以同时执行N次，但是该程序的正文段在内存中只需要有一份而不是N份
            通常正文段是只读的，以防止程序由于意外而修改其指令
        初始化数据段：通常将它称作数据段。
            它包含了程序中明确地赋了初值的变量：包括函数外的赋初值的全局变量、函数内的赋初值的静态变量
        未初始化数据段：通常将它称作bss段。在程序开始执行之前，内核将此段中的数据初始化为0或者空指针。
            它包含了程序中未赋初值的变量：包括函数外的未赋初值的全局变量、函数内的未赋初值的静态变量
        栈段：临时变量以及每次函数调用时所需要保存的信息都存放在此段中。
            每次函数调用时，函数返回地址以及调用者的环境信息（如某些CPU 寄存器的值）都存放在栈中
            最新的正被执行的函数，在栈上为其临时变量分配存储空间

            通过这种方式使用栈，C 递归函数可以工作。递归函数每次调用自身时，就创建一个新的栈帧，因此某一次函数调用中的变量不影响下一次调用中的变量

        堆段：通常在堆中进行动态存储分配。
            由于历史习惯，堆位于未初始化数据段和栈段之间

    注意：
        栈从高地址向低地址增长。堆顶和栈顶之间未使用的虚拟地址空间很大
        未初始化数据段的内容并不存放在磁盘程序文件中。需要存放在磁盘程序文件中的段只有正文段和初始化数据段

            因为内核在程序开始运行前将未初始化数据段设置为 0

        size命令可以查看程序的正文段、数据段 和bss段长度（以字节为单位）

    malloc/calloc/realloc函数：动态分配存储空间

#include<stdlib.h>
void *malloc(size_t size);
void *calloc(size_t nobj,size_t size);
void *realloc(void *ptr,size_t newsize);

- 参数：

	对于malloc函数：
	- size：动态分配的存储空间的大小（字节数）

	对于calloc函数：
	- nobj：动态分配的对象的数量
	- size：每个对象的大小（字节数）

	对于realloc函数：
	- ptr：由malloc/realloc返回的指针，指向一个动态分配的空间
		- 如果ptr是NULL，则realloc与malloc功能相同，是分配一个指定长度为newsize字节的动态存储空间
	- newsize：调整后的动态空间的大小（字节数）
- 返回值：
	- 成功：返回非空指针
	- 失败：返回NULL

注意：
- 这三个分配函数所返回的指针一定是适当对齐的，使其可以用于任何数据对象
- realloc可以增加、减少之前分配的动态存储区长度。对于增加动态存储区的情况：
	- 如果在原来动态存储区位置后面有足够的空间可以扩充，则可以在原存储区位置上向高地址扩充，无需移动任何原先的内容，并返回与传给它相同的指针值
	- 如果在原来动态存储区位置后面没有足够的空间可以扩充，则realloc分配另一个足够大的动态存储区，然后将原先的内容移动到新的存储区。然后释放原存储区，返回新分配存储区的指针
- 这些分配函数通常使用sbrk系统调用实现。该系统调用用于扩充或者缩小进程的堆空间。
	- 大多数实现所分配的存储空间要比所要求的稍大一些，额外的空间用来记录管理信息，比如分配块的长度、指向下一个分配块的指针等等。
	- 因此在一个动态分配区的尾部之后或者在起始位置之前进行写操作会修改另一块的管理记录信息。这种类型的错误是灾难性的，但是由于这种错误不会立即暴露出来，因此很难被发现
- 这三个函数返回的动态分配区必须用free()函数进行释放。
	- 如果一个进程调用了malloc函数但是没有调用free函数，则该进程占用的存储空间就会连续增加，这称作内存泄漏。
	- 内存泄漏会导致进程地址空间长度慢慢增加直到不再有空闲空间。此时过度的换页开销会导致性能下降
- 对一块动态分配的内存，只能free一次。如果free多次则会发生错误。free(NULL) 执行成功，不会报错。

    必须用不同的变量保存realloc返回的值：

    char * ptr=malloc(10);
    ptr=realloc(ptr, 1000); # 错误行为

    因为，一旦realloc失败，则ptr赋值为NULL。ptr原来指向的动态内存区再也不能访问，也就无法释放，从而发生内存泄漏

环境变量

    环境字符串的形式是：name=value。UNIX内核并不查看这些字符串，这些字符串的具体意义由各应用程序解释

    getenv函数：获取环境变量的值：

    #include<stdlib.h>
    char *getenv(const char*name);

        参数：
            name：环境变量名
        返回值：
            成功：指向与name关联的value的指针
            失败：返回NULL

    注意：
        虽然我们也可以通过environ全局变量访问到环境字符串，但是推荐使用getenv函数
        常用的环境变量民有：
            "HOME"：home目录
            "LANG":语言
            "LOGNAME"：登录名
            "PATH"：搜索路径
            "PWD"：当前工作目录的绝对路径名
            "SHELL"：用户首选的SHELL
            "TERM"：终端类型
            "TMPDIR"：在其中创建临时文件的目录路径名
            "TZ"：时区信息

    putenv/setenv/unsetenv函数：设置环境变量的值

    #include<stdlib.h>
    int putenv(char *str);
    int setenv(const char *name,const char *value,int rewrite);
    int unsetenv(const char *name);

        参数：

        对于putenv函数：
            str：形式为name=value的字符串，将其放置到进程的环境表中。如果name已经存在，则先删除其原来的语义

        对于setenv函数：
            name：环境变量名
            value：环境变量的值
            rewrite：指定覆写行为。
                如果它为0，则如果name在环境表中已存在，则直接返回而不修改。同时也不报错
                如果它非0，则如果name在环境表中已存在，则首先删除它现有的定义，然后添加新的定义

        对于unsetenv函数：
            name：环境变量名

        返回值：

        对于 putenv函数：
            成功：返回0
            失败：返回非0

        对于setenv/unsetenv函数：
            成功： 返回 0
            失败： 返回 -1

    注意：
        unsetenv是从环境表中删除name的定义。如果name不存在，则也不算出错
        这些函数内部操作环境表非常复杂，下面是原理：
            如果修改一个现有的name：
                如果新的value长度少于或等于现有value的长度，则只需要将新字符串复制到原字符串所用的空间即可
                如果新的value长度大于现有value的长度，则必须调用malloc为新字符串分配空间，然后将新字符串复制到该空间，接着使环境表中对name的指针指向新分配区并释放旧分配区
            如果增加一个新的name：
                如果这是第一次增加一个新的name：
                    则必须调用malloc为新指针表分配空间
                    然后将原来的环境表复制到新分配区
                    并将新的name=value字符串的指针存放到该指针表的表尾，
                    然后将一个空指针存放在其后
                    然后使environ指向新指针表
                    最后释放旧的指针表
                如果这不是第一次增加一个新的name，则可知以前已经调用了malloc：
                    则只需要调用realloc，以分配比原空间多存放一个指针的空间
                    并将新的name=value字符串的指针存放到该指针表的表尾，
                    然后将一个空指针存放在其后
            如果删除一个name：则只需要先在环境表中找到该指针，然后将所有的后续指针都向环境表的首部依次顺序移动一个位置即可

setjmp 和 longjmp

    在C语言中， goto语句是不能够跨越函数的。如果想执行跨函数跳转功能，则使用setjmp和longjmp，它们称作非局部goto。
        非局部是指：这不是普通的C语言goto语句在一个函数内实施的跳转，而是在栈上跳过若干调用帧，返回到当前函数调用路径上

    setjmp/longjmp函数：非局部goto

    #include<setjmp.h>
    int setjmp(jmp_buf env);
    void longjmp(jmp_buf env,int val);

        参数：

        对于setjmp函数：
            env是一个特殊类型jmp_buf。
                它是某种形式的数组，其内容由setjmp函数填写
                它必须和配对的longjmp使用同一个env

                jmp_buf类型就是某种形式的数组，其中存放的是在调用longjmp时能用来恢复栈状态的所有信息
                简单地说，env参数就是在setjmp和longjmp之间传递状态信息

        对于longjmp函数：
            env：它就是setjmp所设置的env。它就像是一个锚点，从而跳转时知道跳到哪个位置
            val：用于标识本次longjmp。
                因此某个setjmp可能有多个longjmp对应。因此这些jmp之间可以用val分辨。setjmp就知道是从哪个longjmp跳转过来的
                longjmp的val参数就是setjmp的返回值

                    但是setjmp的返回值不一定是longjmp的val参数

        setjmp的返回值：
            如果直接调用，则返回 0
            如果从longjmp返回，则为 非0 （其实就是所跳转的那个longjmp的val参数）

    注意：
        假设在执行setjmp之前，有变量包括：全局变量global_var、局部静态变量static_var、以及自动变量auto_var，则跨longjmp这些变量都不会回滚到setjmp之前的状态
        使用非局部goto时，在声明自动变量的函数已经返回后，不能引用这些自动变量。因为它们已经被释放了

注意：使用longjmp和setjmp时，不能将它们包装起来使用（即不能使用My_longjmp,My_setjmp包装函数），而是直接使用。

进程资源限制

    每个进程都有一组资源限制，其中一些可以通过getrlimit/setrlimit函数查询和修改：

    #include<sys/resource.h>
    int getrlimit(int resource,struct rlimit *rlptr);
    int setrlimit(int resource,struct rlimit *rlptr);

        参数：
            resource：指定资源
            rlptr：指向struct rlimit的指针。在getrlimit中，它返回资源限制值；在setrlimit中，它存放待设置的资源限制值
        返回值：
            成功：返回 0
            失败： 返回非 0

    其中struct rlimit为：

    struct rlimit{
    	rlim_t rlim_cur; //软限制：当前的限制值
    	rlim_t rlim_max; //硬限制：最大值
    };

    注意：
        在更改资源限制时，有三条规则：
            任何进程都可将一个软限制值更改为小于或者等于其硬限制值
            任何进程都可以降低其硬限制值，但是它必须大于或者等于其软限制值

            这种降低，对普通用户而言不可逆，因为普通用户不可提高其硬限制值

            只有超级用户进程才能够提高其硬限制值
        常量RLIM_INFINITY指定了一个无限量的限制
        resource可以取下列的常量值之一：
            RLIMIT_AS：进程总的可用存储空间的最大长度（字节）

                这会影响到sbrk函数和mmap函数

            RLIMIT_CORE：core文件的最大字节数。如果为0，则阻止创建core文件
            RLIMIT_CPU：CPU时间的最大量值（秒），如果超过此软限制时，向该进程发送SIGXCPU信号
            RLIMIT_DATA：数据段的最大字节长度（包括初始化数据、非初始以及堆的总和）
            RLIMIT_FSIZE：可以创建的文件的最大字节长度。当超过此软限制时，向该进程发送SIGXFSX信号
            RLIMIT_MEMLOCK：一个进程使用mlock能够锁定在存储空间中的最大字节长度
            RLIMIT_MSGQUEUE：进程为POSIX消息队列可分配的最大存储字节数
            RLIMIT_NICE：为了影响进程的调度优先级，nice值可设置的最大限制
            RLIMIT_NOFILE：每个进程能打开的最多文件数。更改此限制将影响到sysconf函数在参数_SC_OPEN_MAX中返回的值
            RLIMIT_NPROC：每个实际用户ID可以拥有的最大子进程数。更改此限制将影响到sysconf函数在参数_SC_CHILD_MAX中返回的值
            RLIMIT_RSS：最大驻内存集字节长度
            RLIMIT_SIGPENDING：一个进程可排队的信号的最大数量。这个限制是sigqueue函数实施的
            RLIMIT_STACK：栈的最大字节长度
        资源限制会由子进程继承

    注意： setrlimit需要超级用户的权限，否则报错。

myatexit.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#include<time.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/utsname.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

static void exit_fun1(void)
{
	printf("exit_fun1\n");
}

static void exit_fun2(void)
{
	printf("exit_fun2\n");
}

static void exit_fun3(void)
{
	printf("exit_fun3\n");
}

int main(int argc, char const *argv[])
{
	if(atexit(exit_fun1) != 0)
	{
		perror("register exit_fun1 error");
		return -1;
	}	

	if(atexit(exit_fun2) != 0)
	{
		perror("register exit_fun2 error");
		return -1;
	}
	
	if(atexit(exit_fun2) != 0)
	{
		perror("register exit_fun2 error");
		return -1;
	}

	if(atexit(exit_fun3) != 0)
	{
		perror("register exit_fun2 error");
		return -1;
	}
	return 0;
}

myechoarg.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#include<time.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/utsname.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int main(int argc, char* argv[])
{
	int i;
	for (i = 0; i < argc; i++)
		printf("argv[%d]: %s\n", i, argv[i]);
	exit(EXIT_SUCCESS);
}

myechoenv.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#include<time.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/utsname.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

extern char** environ;

int main(void)
{
	char* const * p = environ;
	for (; *p != NULL; ++p)
		printf("%s\n", *p);

	exit(EXIT_SUCCESS);
}

mygetenv.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdbool.h>
#include<ctype.h>
#include <string.h>
#include<time.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/utsname.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

void StringUpper(char* buf, int buf_size) {
	int i;
	for (i = 0; buf[i] != '\0' && i < buf_size; ++i)
		buf[i] = toupper(buf[i]);
}

int main(int argc, char* argv[])
{
	if (argc < 2)
		err_sys("usage:getenv <env>\n");

	int i = 1;
	const char* penv_value;
	char string[64];
	for (; i < argc; ++i) {
		if (strcpy(string, argv[i]) == NULL)
			continue;
		StringUpper(string, 64);
		if ((penv_value = getenv(string)) == NULL)
			continue;
		printf("%s=\n%s\n", string, penv_value);
	}

	exit(EXIT_SUCCESS);
}

mycalloc.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdbool.h>
#include<ctype.h>
#include <string.h>
#include<time.h>
#include<alloca.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/utsname.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

struct Type {
	char buf[64];
	int value;
};

int main(void)
{
	//struct Type* ptype = malloc(sizeof(struct Type));
	struct Type* ptype = calloc(sizeof(struct Type), 1);
	//struct Type* ptype = alloca(sizeof(struct Type));//alloca函数具有自动释放内存空间的作用
	if (strcpy(ptype->buf, "hello world") == NULL)
		err_sys("strcpy error\n");
	ptype->value = 10;

	printf("struct Type's value  = %d\n", ptype->value);
	printf("struct Type's string = %s\n", ptype->buf);

	free(ptype);
	exit(EXIT_SUCCESS);
}

jmp_buf is an array type capable of storing the information of a calling environment to be restored later.

mysetjmp.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdbool.h>
#include<ctype.h>
#include <string.h>
#include<time.h>
#include<alloca.h>
#include<setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/utsname.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

jmp_buf jump_buf;
static int value;

void in_func(void) {
	if (value < 2) {
		++value;
		longjmp(jump_buf, 1);
	}
	printf("get here?\n");
}

void func(void) {
	in_func();
}

int main(void)
{
	volatile int value = 0;

	if (setjmp(jump_buf) != 0)
		printf("from a deep function jump to here\n");
	++value;
	func();
	printf("value = %d\n", value);

	exit(EXIT_SUCCESS);
}

mysetenv.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdbool.h>
#include<ctype.h>
#include <string.h>
#include<time.h>
#include<alloca.h>
#include<setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/utsname.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

char* StringUpper(char* buf, int size_len) {
	int i = 0;
	while (i < size_len && buf[i] != '\0') {
		buf[i] = toupper(buf[i]);
		++i;
	}
	return buf;
}

void print_env(const char* env) {
	const char* env_content = getenv(env);
	printf("%s = %s\n", env, env_content ? env_content : "");
}

int main(int argc, char* argv[]) {
	if (argc != 3)
		err_sys("usage:set-unset <env_var> <var_content>\n");

	const char* Upper_string = StringUpper(argv[1],strlen(argv[1]));
	if (setenv(Upper_string, argv[2], 0) == -1)
		err_sys("setenv error\n");
	printf("After setting:\n\t");
	print_env(Upper_string);
	if (unsetenv(Upper_string) == -1)
		err_sys("unsetenv error\n");
	printf("After unsetting:\n\t");
	print_env(Upper_string);

	exit(EXIT_SUCCESS);
}

mylongjmp.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdbool.h>
#include<ctype.h>
#include <string.h>
#include<time.h>
#include<alloca.h>
#include<setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/utsname.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

jmp_buf jmp;

static void fun_init(void)
{
	int retjmp;
	retjmp = setjmp(jmp);/* 首次调用立即返回0 */

	printf("%d\n", retjmp);
	switch(retjmp){
		case 0:
			printf("first call setjmp!\n");
			break;
		case 1:
			printf("longjmp from fun1!\n");
			break;
		case 2:
			printf("longjmp from fun2!\n");
			break;
		default:
			printf("unexpected retjmp\n");
	}
}

static void fun1(void)
{
	longjmp(jmp, 1);
}

static void fun2(void)
{
	longjmp(jmp, 2);
}

int main(int argc, char const *argv[])
{
	
	fun_init();
	fun1();	    /* 使用了setjmp函数的函数在函数执行完毕之后不回收栈空间，以备longjmp的访问(实现机制) */
	fun2();

	return 0;
}

myjmp.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdbool.h>
#include<ctype.h>
#include <string.h>
#include<time.h>
#include<alloca.h>
#include<setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/utsname.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

jmp_buf jmp;
int globalval;

static void fun2(void)
{
	longjmp(jmp, 1);
}

static void fun1(int auto_val, int regi_val, int vola_val, int stat_val)
{
	printf("in fun1:\n");
	printf("\tglobal=%d, auto=%d, register:%d, volatile:%d, static:%d\n", \
			  globalval, auto_val, regi_val, vola_val, stat_val);
	fun2();
}

int main(int argc, char const *argv[])
{
	int          autoval;
	register int regival;
	volatile int volaval;
	static   int statval;
	/* main 中初始化 */
	globalval = 1; autoval = 2; regival = 3; volaval = 4; statval = 5;

	if(setjmp(jmp) != 0)
	{
		/* 从其它函数中回调后的值 */
		printf("longjmp from fun2!\n");
		printf("\tglobal=%d, auto=%d, register:%d, volatile:%d, static:%d\n", \
			  globalval, autoval, regival, volaval, statval);
		return 0;
	}

	globalval = 91; autoval = 92; regival = 93; volaval = 94; statval = 95;
	fun1(autoval, regival, volaval, statval);

	return 0;
}
显示结构如下
in fun1:
        global=91, auto=92, register:93, volatile:94, static:95
longjmp from fun2!
        global=91, auto=92, register:3, volatile:94, static:95

myrlimit.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdbool.h>
#include<ctype.h>
#include <string.h>
#include<time.h>
#include<alloca.h>
#include<setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/utsname.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define doit(name) pr_limits(#name, name)

static void pr_limits(char *name, int resource)
{
	struct rlimit      limit;
	unsigned long long lim;
	if(getrlimit(resource, &limit) < 0)
	{
		printf("getrlimit for %s error!\n", name);
		return;
	}
	printf("%-14s ", name);

	/* 资源软限制 */
	if(limit.rlim_cur == RLIM_INFINITY){
		printf("(infinity) ");
	} else {
		lim = limit.rlim_cur;
		printf("%12lld ", lim);
	}

	/* 资源硬限制 */
	if(limit.rlim_max == RLIM_INFINITY){
		printf("(infinity) ");
	} else {
		lim = limit.rlim_max;
		printf("%12lld ", lim);
	}

	printf("\n");
}

int main(int argc, char const *argv[])
{
#ifdef RLIMIT_AS
	doit(RLIMIT_AS);
#endif
	/* 平台通用 */
	doit(RLIMIT_CORE);
	doit(RLIMIT_CPU);
	doit(RLIMIT_DATA);
	doit(RLIMIT_FSIZE);
	doit(RLIMIT_NOFILE);
	doit(RLIMIT_STACK);

#ifdef RLIMIT_MEMLOCK
	doit(RLIMIT_MEMLOCK);
#endif

#ifdef RLIMIT_MSGQUEUE
	doit(RLIMIT_MSGQUEUE);
#endif

#ifdef RLIMIT_NICE
	doit(RLIMIT_NICE);
#endif

#ifdef RLIMIT_NPROC
	doit(RLIMIT_NPROC);
#endif
		
#ifdef RLIMIT_NPTS
	doit(RLIMIT_NPTS);
#endif

#ifdef RLIMIT_RSS
	doit(RLIMIT_RSS);
#endif

#ifdef RLIMIT_SBSIZE
	doit(RLIMIT_SBSIZE);
#endif

#ifdef RLIMIT_SIGPENDING
	doit(RLIMIT_SIGPENDING);
#endif

#ifdef RLIMIT_SWAP
	doit(RLIMIT_SWAP);
#endif

#ifdef RLIMIT_VMEM
	doit(RLIMIT_VMEM);
#endif
	return 0;
}

mymemlayout.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdbool.h>
#include<ctype.h>
#include <string.h>
#include<time.h>
#include<alloca.h>
#include<setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/utsname.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int global_init = 1; //全局变量、初始化、数据段(data)
int global_uninit;//全局变量、未初始化、未初始化段(bss)
static int static_global_init = 1;//全局变量、静态的、初始化、数据段(data)
static int static_global_uninit;//全局变量、静态的、未初始化、未初始化段(bss)
const  int const_global = 1;//全局常量、初始化、文本段(text)
const  int const_global_uninit;//全局常量、未初始化、文本段(text) *一般不定义这种变量，它的值始终为0且不可改变*
/* 
   全局变量都是保存在静态内存中(这也是为什么不初始化默认是0的原因)，data、bss、text、stack都含有静态内存，
   heap没有静态内存
*/

int main(int agrc, char *argv[])
{
	int local_init = 1;//局部变量、初始化、栈(stack)
	int local_uninit;//局部变量、未初始化、栈(stack)
	static int static_local_init = 1;//全局变量、静态存储区域、初始化、数据段(data)
	static int static_local_uninit;//全局变量、静态存储区域、未初始化、未初始化数据段(bss)
	const  int const_local_init = 1;//局部常量、栈
	const  int const_local_uninit;//局部常量、栈
	char *p = malloc(1024);//p指向的内存、堆
	return 0;
}

进程控制
进程的创建

    每个进程都有一个非负整数表示的唯一进程 ID 。
        所谓的唯一，即当前正在系统中运行的所有进程的ID各不相同
        当一个进程A终止后，它的进程 ID 可以复用
            大多数UNIX系统实现的是延迟复用算法，使得新进程B的ID不同于最近终止的进程A的ID
        系统中有一些专用的进程
            ID为0的进程通常是调度进程，也称作交换进程。该进程是操作系统内核的一部分，并不执行任何磁盘上的程序，因此也称作是系统进程
            ID为1的进程通常是init进程，在自举过程结束时由内核调用。
                该进程对应的程序文件为/etc/init，在较新的版本中是/sbin/init文件
                该进程负责在自举内核后启动一个UNIX系统
                该进程通常读取与系统有关的初始化文件（/etc/rc*文件，/etc/inittab文件以及/etc/init.d中的文件），并将系统引导到一个状态
                该进程永远不会终止
                该进程是一个普通的用户进程（不是内核中的系统进程），但是它以超级用户特权运行

    获取进程的标识符：

    #include<unistd.h>
    pid_t getpid(void);  // 返回值：调用进程的进程ID
    pid_t getppid(void); // 返回值：调用进程的父进程ID
    uid_t getuid(void);  // 返回值：返回进程的实际用户ID
    uid_t geteuid(void); // 返回值：返回进程的有效用户ID
    gid_t getgid(void);  // 返回值：返回进程的实际组ID
    gid_t getegid(void); // 返回值：返回进程的有效组ID

        这些函数都没有出错返回

    fork函数：创建一个新进程

    #include<unistd.h>
    pid_t fork(void);

        返回值：
            成功：
                子进程返回 0
                父进程返回子进程ID
            失败：返回 -1

    注意：
        如果fork调用成功，则它被调用一次，但是返回两次。 两次返回的区别是：子进程的返回值是0，父进程的返回值是新建子进程的进程ID
            子进程返回值是 0 的理由：一个进程总可以通过getpid知道它的进程ID，通过getppid知道它的父进程的ID
            父进程返回值是子进程的进程ID的理由：一个进程的子进程可以有多个，但是并没有函数可以获取它的子进程的ID
        子进程是父进程的一份一模一样的拷贝，如子进程获取了父进程数据空间、堆、栈的副本。
            父子进程共享正文段（因为正文段是只读的）
            父子进程并不共享数据空间、堆、栈
        子进程和父进程都从fork调用之后的指令开始执行。也就是子进程从出生开始，就跟父进程处于同样的状态
        由于创建子进程的目的通常是为了完成某个任务，因此fork之后经常跟随exec，所以很多操作系统的实现并不执行一个父进程数据段、堆和栈的完全拷贝，而是使用写时赋值技术（copy-on-write:COW）
            这些区域由父进程和子进程共享，而且内核将它们的访问权限改变为只读
            如果父子进程中有一个试图修改这些区域，则内核只为修改区域的那块内存制作一个副本
        通常fork之后，是父进程先执行还是子进程先执行是不确定的，这取决于内核所使用的进程调度算法
        注意标准IO库的跨fork行为。由于标准IO库是带缓冲的，因此在fork调用之后，这些缓冲的数据也被拷贝到子进程中
        父进程的所有打开的文件描述符都被复制到子进程中。父进程和子进程每个相同的打开描述符共享同一个文件表项
            更重要的是：父进程和子进程共享同一个文件偏移量
            如果父进程和子进程写同一个描述符指向的文件，但是又没有任何形式的同步，则它们的输出会相互混合
                如果父进程fork之后的任务就是等待子进程完成，而不作任何其他的事情，则父进程和子进程无需对打开的文件描述符做任何处理。因为此时只有子进程处理文件
                如果父进程fork之后，父进程与子进程都有自己的任务要处理，则此时父进程和子进程需要各自关闭它们不需要使用的文件描述符，从而避免干扰对方的文件操作
        除了打开的文件描述符之外，子进程还继承了父进程的下列属性：实际用户ID、实际组ID、有效用户ID、有效组ID、附属组ID、进程组ID、会话ID、控制终端、
        设置用户ID标志和设置组ID标志、当前工作目录、根目录、文件模式创建屏蔽字、信号屏蔽和信号处理、对任一打开文件描述符的执行时关闭标志、环境、连接的共享存储段、存储映像、资源限制
        父进程和子进程的区别为：
            fork返回值不同
            进程ID不同
            进程父进程ID不同
            子进程的tms_utime,tms_stime,tms_cutime,tms_ustime的值设置为0
            子进程不继承父进程设置的文件锁
            子进程的未处理闹钟被清除
            子进程的未处理信号集设置为空集
        fork失败的零个主要原因：
            系统已经有了太多的进程
            实际用户ID的进程总数超过了系统的限制（CHILD_MAX规定了每个实际用户ID在任何时刻拥有的最大进程数）

    fork有两种用法：
        父进程希望复制自己，使父进程和子进程同时执行不同的代码段。在网络服务中很常见：父进程等待请求，然后调用fork并使子进程处理请求
        父进程要执行一个不同的程序。在shell是很常见。此时子进程从fork返回之后立即调用exec

    vfork函数的调用序列和返回值与fork相同，但是二者语义不同：
        vfork用于创建一个新进程，该新进程的目的是exec一个新程序，所以vfork并不将父进程的地址空间拷贝到子进程中。
            vfork的做法是：在调用exec或者exit之前，子进程在父进程的空间中运行

            所以在exec或者exit之前，子进程可以篡改父进程的数据空间

        vfork保证子进程优先运行，在子进程调用exec或者exit之后父进程才可能被调度运行

        当子进程调用exec或者exit中的任何一个时，父进程会恢复运行，在此之前内核会使父进程处于休眠状态

进程的终止

    进程有 8 种方式使得进程终止，其中 5 种为正常终止，3 种异常终止：
        正常终止方式：
            从main函数返回，等效于exit
            调用exit函数。exit会调用各终止处理程序，然后关闭所有标准IO流
            调用_exit函数或者_Exit函数。它们不运行终止处理程序，也不冲洗标准IO流
            多线程的程序中，最后一个线程从其启动例程返回。但是该线程的返回值并不用做进程的返回值，进程是以终止状态 0 返回的
            多线程的程序中，从最后一个线程调用pthread_exit函数。进程也是以终止状态 0 返回的
        异常终止方式：
            调用abort函数。它产生SIGABRT信号
            接收到一个信号
            多线程的程序中，最后一个线程对取消请求作出响应

    更进一步的：

        不管进程如何终止，最后都会执行内核中的同一段代码：这段代码为相应进程关闭所有打开的描述符（不仅仅是文件描述符），释放它所使用的内存。

        不管进程如何终止，我们需要有一种方法来通知父进程，本进程是如何终止的。
            对于exit,_exit,_Exit这三种情况：将本进程的退出状态作为参数传给函数，并且在最后调用_exit时，内核将退出状态转换成终止状态

            exit函数和_Exit函数最终调用的是_exit函数

            对于异常终止情况，内核产生一个指示异常终止原因的终止状态

        在任意一种情况下，终止进程的父进程都能够用wait或者waitpid函数取得终止状态。然后父进程能够检测终止状态。如果发现子进程是正常终止，则可以从终止状态中提取出退出状态

    如果父进程在子进程之前终止，那么内核会将该子进程的父进程改变为init进程，称作由init进程收养。其原理为：
        在一个进程终止时，内核逐个检查所有活动进程，以判断这些活动进程是否是正要终止的进程的子进程
        如果是，则该活动进程的父进程ID就改为 1

    这种方式确保了每个进程都有一个父进程

    内核为每个终止子进程保存了一定量的信息，所以当终止进程的父进程调用wait函数或者waitpid函数时，可以得到这些信息。
        这些信息至少包括：终止进程的进程ID、终止进程的终止状态、终止进程的使用的CPU时间总量
        内核此时可以释放终止进程使用的所有内存，关闭它所有的打开文件。但是该终止进程还残留了上述信息等待父进程处理
        我们称一个已经终止、但是等待父进程对它进行善后处理的进程称作僵死进程，在ps命令中显示为Z
            所谓善后处理，就是父进程调用wait函数或者waitpid函数读取终止进程的残留信息
            一旦父进程进行了善后处理，则终止进程的所有占用资源（包括残留信息）都得到释放，该进程被彻底销毁
        对于init超级进程，它被设计成：任何时候只要有一个子进程终止，就立即调用wait函数取得其终止状态。这种做法防止系统中塞满了僵死进程

    当一个进程终止时，内核就向其父进程发送SIGCHLD信号。这种信号是一个异步信号，因为该信号可能在任何时间发出
        父进程可以选择忽略此信号。这是系统的默认行为
        父进程也可以针对此信号注册一个信号处理程序，从而当接收到该信号时调用相应的信号处理程序

    wait/waitpid函数：

    #include<sys/wait.h>
    pid_t wait(int *staloc);
    pid_t waitpid(pid_t pid,int *staloc,int options);

        参数：
            staloc：存放子进程终止状态的缓冲区的地址。如果你不关心子进程的终止状态，则可以设它为空指针NULL

        对于waitpid函数：
            pid：
                如果pid==-1：则等待任意一个子进程终止
                如果pid>0：则等待进程ID等于pid的那个子进程终止
                如果pid==0：则等待组ID等于调用进程组ID的任一子进程终止
                如果pid<0：等待组ID等于pid绝对值的任一子进程终止
            options：或者是0，或者是下列常量按位或的结果：
                WNOHANG：没有指定的子进程终止时，并不阻塞程序的执行
                WUNTRACED：执行作业控制。若操作系统支持作业控制，则由pid指定的任一子进程在停止后已经继续(the status of any child specified by pid that has been continued after being stopped,)，
	但其状态尚未报告，则返回其状态
                WCONTINUED：执行作业控制。若操作系统支持作业控制，则由pid指定的任一子进程已处于停止状态(the status of any child specified by pid that has stopped)，并且其状态自停止以来尚未报告过，则返回其状态

                进程的停止状态：类似于暂停。它不同于终止状态

        返回值：
            成功：返回终止子进程的进程ID
            失败：返回 0 或者 -1

    注意：

        wait的语义是等待任何一个子进程终止：
            如果当前进程的所有子进程都还在运行，则阻塞
            如果有一个子进程已终止，正在等待父进程获取其终止状态，则当前进程取得该子进程的终止状态并立即返回
            如果当前进程没有任何子进程，则立即出错返回

        waitpid的语义是等待指定的子进程终止：
            如果当前进程的所有子进程都在运行：
                如果options指定为WNOHANG，则waitpid并不阻塞，而是立即返回 0
                如果options未指定为WNOHANG，则waitpid阻塞
            如果指定pid的子进程已终止，正在等待父进程获取其终止状态，则当前进程取得该子进程的终止状态并立即返回
            如果指定的pid有问题（如不存在，或者不是当前进程的子进程），则立即出错返回

        对于出错的情况：
            wait出错的原因是：
                调用进程没有子进程
                函数调用（正在阻塞中）被一个信号中断
            waitpid出错的原因是：
                指定的进程或者进程组不存在
                pid指定的进程不是调用进程的子进程
                函数调用（正在阻塞中）被一个信号中断

        可以通过宏从终止状态中取得退出状态以及终止原因等：
            WIFEXITED(status)：如果子进程正常终止，则为真。此时可以执行WEXITSTATUS(status)获取子进程的退出状态的低 8 位
            WIFSIGNALED(status)：如果子进程异常终止，则为真。此时可以执行WTERMSIG(status)获取使得子进程终止的信号编号
            WIFSTOPPED(status)：如果子进程的当前状态为暂停，则为真。此时可执行WSTOPSIG(status)获取使得子进程暂停的信号编号
            WIFCONTINUED(status):如果子进程在暂停后已经继续执行了，则为真。

- 子进程的结束顺序跟它们派生的顺序没有什么关系。wait只会处理最先结束的子进程
- 调用了_exit的子进程，属于正常终止；调用了abort和被信号终止的子进程属于异常终止
- 通过waitpid可以严格控制取得终止子进程状态的顺序
- 通过waitpid依次等待所有的子进程，可以确保父进程是最后一个结束的

    waitid函数：它类似waitpid，但是提供了更灵活的参数

    #include<sys/wait.h>
    int waitid(idtype_t idtype,id_t id,siginfo_t *infop,int options);

        参数：
            idtype：指定了id类型，可以为下列常量
                P_PID：等待特定进程。此时id表示要等待的子进程的进程ID
                P_GID：等待属于特定进程组的任一子进程。此时id表示要等待的进程组ID
                P_ALL：等待任一子进程。此时忽略id
            id：指定的进程id或者进程组id
            infop：一个缓冲区的地址。该缓冲区由waitid填写，存放了造成子进程状态改变的有关信号的详细信息
            options：指示调用者关心哪些状态变化。可以是下列常量的按位或：
                WCONTINUED：等待这样的子进程：它以前曾被停止过，此后又继续执行，但是其状态尚未报告
                WEXITED：等待已经终止的子进程
                WNOHANG：如无可用的子进程终止状态，立即返回而不是阻塞
                WNOWAIT：不破坏子进程的终止状态，该子进程的终止状态可以由后续的wait,waitid,waitpid调用取得
                WSTOPPED：等待这样的子进程：它已经停止，但是其状态尚未报告
        返回值：
            成功： 返回 0
            失败： 返回 -1

    wait3/wait4函数：可以返回终止子进程及其子子进程的资源使用情况

    #include<sys/types.h>
    #include<sys/wait.h>
    #include<sys/time.h>
    #include<sys/resource.h>
    pid_t wait3(int *staloc,int options,struct rusage *rusage);
    pid_t wait4(pid_t pid,int *staloc,int options,struct rusage *rusage);

        参数：
            staloc：存放子进程终止状态的缓冲区的地址。如果你不关心子进程的终止状态，则可以设它为空指针NULL
            rusage：一个缓冲区的地址，该缓冲区存放由wait3,wait4返回的终止子进程的资源统计信息，包括：用户CPU时间总量、系统CPU时间总量、缺页次数、接收到的信号的次数等

        pid和options参数与waitpid相同

        返回值：
            成功：返回终止子进程的进程ID
            失败：返回 -1

    如果fork之后的逻辑依赖于父进程还是子进程先执行，则产生了竞争条件。
        可以使用进程间通信机制解决这类竞争问题

    当进程调用一种exec函数时，该进程执行的程序完全替换成新程序，而新程序则从main函数开始执行
        调用exec前后，进程ID并未改变。因为exec并不创建新进程
        exec只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆段和栈段

    有7种不同的exec函数可以供使用，它们被统称称作exec函数：

    #include<unistd.h>
    int execl(const char *pathname,const char *arg0,.../*(char *) 0 */);
    int execv(const char *pathname,char *const argv[]);
    int execle(const char *pathname,const char *arg0,.../*(char *) 0, char *const envp[] */);
    int execve(const char *pathname,char *const argv[],char *const envp[]);
    int execlp(const char *filename,const char*arg0,.../*(char *) 0*/);
    int execvp(const char *filename, char *const argv[]);
    int fexecve(int fd,char *const argv[],char *const evnp[]);

    返回值：
        若成功：不返回
        若失败：返回 -1

    这几个函数的区别：
        前四个函数取路径名作为参数；后两个函数取文件名作为参数；最后一个取文件描述符做参数
            若filename中包含/，则视为路径名
            若filename不包含/，则按照PATH环境变量指定的各个目录中搜寻可执行文件
        函数execl,execlp,execle要求将新程序的每个命令行参数都说明为一个单独的参数，这种参数表以空指针结尾；函数execv,execvp,execve,fexecve应先构造一个指向各参数的指针数组，然后将该指针数组的地址作为参数
            l表示列表list
            v表示矢量vector
            l形式中，必须以空指针结尾，否则新程序根本不知道要读取多少个参数。空指针就是命令行参数序列终止的标记
            v形式中，数组的最后一个元素必须是空指针，否则报错。
        以e结尾的execle,execve,fexecve可以传递一个指向环境字符串指针数组的指针。注意这个数组的最后一个元素必须是空指针，否则报错。其他四个函数则使用调用进程的environ变量为新程序复制现有的环境

    注意：
        操作系统对参数表和环境表的总长度有一个限制。在POSIX中，这个值至少是 4096 字节
        执行exec之后，新程序的进程ID不变，进程的大多数属性不变。但是对打开文件的处理要注意：
            进程中每个打开的文件描述符都有一个执行时关闭标志。若设置了此标志，则执行exec时会关闭该文件描述符；否则该文件描述符仍然保持打开。系统默认行为是不设置执行时关闭标志
        执行exec之后，进程的实际用户 ID 和实际组 ID不变，但是进程的有效用户 ID 要注意：
            进程的有效用户 ID 和有效组 ID 是否改变取决于所执行程序文件的设置用户 ID 和设置组 ID 位是否设置。
                若程序文件的设置用户 ID 位已设置，则进程的有效用户 ID 变成程序文件所有者的 ID；否则有效用户 ID 不变
                若程序文件的设置组 ID 位已设置，则进程的有效组 ID 变成程序文件所有组的 ID；否则有效组 ID 不变
        在很多UNIX操作系统中，这7个函数只有execve是内核的系统调用。另外 6 个只是库函数。它们最终都要调用该系统调用 execve

- execl/execv/execvp/execlp继承了父进程的环境变量；execle/execve指定了环境变量
- execvp/execlp在PATH中正确搜索到了可执行文件
- execv/execvp/execve指定的参数表数组必须以空指针结尾，否则exec失败
- execle/execve指定的环境变量数组必须以空指针结尾，否则exec失败

    PATH环境变量包含了一张目录表，称作路径前缀。目录之间用冒号:分隔。如PATH=/bin:/usr/bin:.
        .表示当前目录
        零长前缀也表示当前目录。在起始处，零长前缀为:xxx，在中间，零长前缀为xxx::xxx，在行尾，零长前缀为xxx：

    基本的进程控制原语：
        fork创建进程
        exec初始化执行新的程序
        exit终止进程
        wait等待子进程终止

    exec不仅可以执行二进制可执行文件，也可以执行解释器可执行文件。

        解释器可执行文件时文本文件，其首行格式为：

         #!/bin/sh

        其中/bin/sh（或者其他路径）通常是绝对路径名，对它不进行任何特殊的处理

        实际上exec执行的并不是解释器文件（它是个文本），而是由/bin/sh指定的二进制可执行文件，然后/bin/sh以该解释器文件作为参数

        对解释器可执行文件的识别是由操作系统内核来完成的。该识别步骤是作为exec系统调用处理的一部分来完成的

        注意该解释器文件必须要有可执行权限。可以通过chmod a+x添加任意用户的可执行权限

    system函数：在程序中执行一个命令字符串

    #include<stdlib.h>
    int system(const char *cmdstring);

        参数：
            cmdstring：命令字符串（在shell中执行），如 "ps -aux"
        返回值：
            有三种返回值。见下面描述

    system用于将一个字符作为命令来执行。它等同于同时调用了fork、exec、waitpid。有三种返回值：
        fork失败或者waitpid返回除了EINTR之外的错误，则system返回 -1，并且设置errno以指示错误类型
        如果exec失败(表示不能执行shell)，则其返回值如同shell执行了exit(127)一样
        如果三个函数都执行成功，则system返回值是shell的终止状态，其格式在waitpid中说明

    system对操作系统依赖性很强。目前在UNIX操作系统上，system总是可用的。如果cmdstring为空指针，则if no shell is available，system返回 0；否则if a shell is available，system返回非0值。

    system相较于fork+exec的优点是：system进行了所需的各种出错处理以及各种信号处理。缺点是：一旦调用system的进程具有超级用户权限，则system执行的命令也具有超级用户权限。

        因为system的实现过程中并没有更改有效用户ID和实际用户ID的操作。

            因此如果一个进程以特殊的权限运行，而它又想生成另一个进程执行另外一个程序，则它应该直接使用fork、exec并且在fork之后，exec之前改回普通权限。
            设置用户ID和设置组ID程序绝不应该调用system函数

注意：调用system后不再需要调用wait等进程控制原语了。这一切控制由system打包。

更改用户ID和更改组ID

    在设计应用程序时，应该使用最小特权模型：程序应当只具有为完成给定认为所需的最小的特权
        当进程需要增加特权或需要访问当前并不允许访问的资源时，我们需要更换自己的用户ID或者组ID，使得新ID具有合适的特权或者访问权限
        当前进程需要降低其特权或者阻止对某些资源的访问时，也需要更换用户ID或者组ID，新ID不具有相应的特权
        进程在大部分时候都是最低特权运行。只有到必要的时候提升特权访问资源，一旦资源访问完毕立即降低特权

    setuid/setgid函数：设置实际用户ID和有效用户ID/ 实际组ID和有效组ID

    #include<unistd.h>
    int setuid(uid_t uid);
    int setgid(gid_t gid);

        参数：
            uid：待设置的用户ID
            gid：待设置的组ID
        返回值：
            成功： 返回 0
            失败： 返回 -1

    设置的规则为：
        如果进程具有超级用户特权，则setuid函数将实际用户ID，有效用户ID以及保存的设置用户ID(saved set-user-ID) 全部设置为uid（此时uid没有限制）
        如果进程没有超级用户特权，但是uid等于实际用户ID或者保存的设置用户ID，则setuid只会将有效用户ID设置为uid，不改变实际用户ID和保存的设置用户ID
        如果上面两个条件都不满足，则errno设置为EPERM并返回 -1
        上述讨论中，假设_POSIX_SAVED_IDS为真。如果为提供此功能，则对于保存的设置用户ID部分都无效
        针对setgid的讨论类似setuid

    操作系统内核为每个进程维护3个用户ID：实际用户ID、有效用户ID、保存的设置用户ID：
        只有超级用户进程可以更改实际用户ID
            通常是基用户ID是在用户登录时，由login程序设置的，而且绝不会改变它。login是一个超级用户进程，当它调用setuid时，设置所有的3个用户ID
        仅当对程序文件设置了设置用户ID时，exec函数才设置有效用户ID。如果程序文件的设置用户ID位没有设置，则exec函数不会改变有效用户ID，而是维持其现有值
            任何时候都可以调用setuid将有效用户ID设置为实际用户ID或者保存的设置用户ID
            调用setuid时，有效用户ID不能随意取值，只能从实际用户ID或者保存的设置用户ID中取得
        保存的设置用户ID是由exec复制有效用户ID而得到。如果设置了程序文件的设置用户ID位，则exec根据文件的用户ID设置了进程的有效用户ID之后，这个副本就保存起来
        目前可以通过getuid获取进程的当前实际用户ID，可以通过geteuid获取进程的当前有效用户ID，但是没有函数获取进程当前的保存的设置用户ID

    POSIX提供了两个函数：

    #include<unistd.h>
    int seteuid(uid_t uid);
    int setegid(gid_t gid);

        参数：
            uid：待设置的有效用户ID
            gid：待设置的有效组ID
        返回值：
            成功： 返回 0
            失败： 返回 -1

    seteuid只修改进程的有效用户ID；setegid只修改进程的有效组ID。
        如果进程具有超级用户权限，则seteuid将设置进程的有效用户ID为uid（此时uid没有限制）
        如果进程没有超级用户权限，则seteuid只能将进程的有效用户ID设置为它的实际用户ID或者保存的设置用户ID
        针对setegid的讨论类似seteuid

    getlogin：获取运行该程序的用户的登录名

    #include<unistd.h>
    char *getlogin(void);

        返回值：
            成功：返回指向登录名字符串的指针
            失败：返回NULL

    通常失败的原因是：进程的用户并没有登录到系统。比如守护进程。

- 普通进程无法将自己的用户ID和有效用户ID设置为超级用户root
- 超级进程可以设置自己的用户ID和有效用户ID为任意值，但是无法修改组ID和有效组ID
  超级进程一旦将自己的用户ID和有效用户ID设置为普通用户之后，该进程退化为普通进程

进程会计

    大多数UNIX系统提供了一个选项以进行进程会计处理
        启用该选项后，每当进程结束时内核就会写一个会计记录
        超级用户执行命令accton pathname则会启用会计处理，会计记录会写到pathname指定的文件中
            如果不带文件名参数，会停止会计处理
        会计记录文件是个二进制文件，包含的会计记录是二进制数据

    会计记录结构定义在<sys/acct.h>头文件中。虽然各个操作系统的实现可能有差别，但是基本数据如下：

    typedef u_short comp_t;
    struct acct
    {
    	char ac_flag;  	//标记
    	char ac_stat; 	//终止状态
    	uid_t ac_uid; 	//真实用户ID
    	gid_t ac_gid;	//真实组ID
    	dev_t ac_tty;	// 控制终端
    	time_t ac_btime;// 起始的日历时间
    	comp_t ac_utime;// 用户 CPU 时间
    	comp_t ac_stime;// 系统 CPU 时间
    	comp_t ac_etime;// 流逝时间
    	comp_t ac_mem;	// 平均内存使用
    	comp_t ac_io;	// read和write字节数量
    	comp_t ac_rw;	// read和write的块数
    	char ac_comm[8];//命令名。对于LINUX ，则是 ac_comm[17]
    };

        ac_flag记录了进程执行期间的某些事件：
            AFORK：进程是由fork产生的，但从未调用exec
            ASU：进程使用超级用户特区
            ACORE:进程转储core（转储core的字节并不计算在会计记录内）
            AXSIG：进程由一个信号杀死
        在大多数平台上，时间是以时钟滴答数来记录的
        会计记录所需的所有数据都由内核保存在进程表中，并在一个新进程被创建时初始化
        进程终止时，会写一个会计记录。这产生两个后果：
            我们不能获取永远不终止的进程的会计记录。因此init进程以及内核守护进程不会产生会计记录
            在会计文件中记录的顺序对应的是进程终止的顺序，而不是他们启动的顺序
        会计记录对应的是进程而不是程序。因此如果一个进程顺序的执行了3个程序 ： A exec B, B exec C，则只会写一个会计记录。在该记录中的命令名对应于程序C，但是CPU时间是程序A,B,C之和

    times函数：任何进程都可以用该函数获取它自己以及已经终止子进程的运行时间

    #include<sys/times.h>
    clock_t times(struct tms *buf);

        参数：
            buf：执行tms结构的指针。该结构由times填写并返回
        返回值：
            成功：返回流逝的墙上始终时间（以时钟滴答数为单位）
            失败：返回 -1

    一个进程可以度量的有3个时间：

        墙上时钟流逝的时间。从进程从开始运行到结束时钟走过的时间，这其中包含了进程在阻塞和等待状态的时间

        用户 CPU 时间：用户进程获得了CPU资源以后，在用户态执行的时间

            与用户进程对应的是内核进程

        系统 CPU 时间：用户进程获得了CPU资源以后，在内核态的执行时间

            进程的三种状态为阻塞、就绪、运行
                墙上时钟流逝的时间 ＝ 阻塞时间 ＋ 就绪时间 ＋运行时间
                用户CPU时间 ＝ 运行状态下用户空间的时间
                系统CPU时间 = 运行状态下系统空间的时间
                用户CPU时间+系统CPU时间=运行时间

    times函数就是获取进程的这几个时间的。这里的tms结构定义为：

    struct tms{
    	clock_t tms_utime;  //用户 CPU 时间
    	clock_t tms_stime;  //系统 CPU 时间
    	clock_t tms_cutime; //终止的子进程的用户 CPU 时间的累加值
    	clock_t tms_cstime; //终止的子进程的系统 CPU 时间的累加值

    注意：
        墙上时钟是相对于过去某个时刻度量的，所以不能用其绝对值而必须用相对值。通常的用法是：调用两次times，然后取两次墙上时钟的差值
        tms_cutime和tms_cstime包含了wait函数族已经等待到的各个子进程的值
        clock_t可以使用_SC_CLK_TCK（用sysconf函数）转换成秒数

进程调度

    UNIX系统的调度策略和调度优先级是内核确定的。进程可以通过调整nice值选择以更低优先级运行
        只有特权进程运行提高调度权限
        POSIX实时扩展增加了进一步细调的行为

    nice值的在UBUNTU 16.04中范围是 -20～19 之间。
        nice值越小，优先级越高（该进程抢占能力更强，更霸道）；nice值越大，优先级越低（从而该进程是“友好的”）
        0 是系统默认的nice值

    nice函数：进程通过它来获取自己的nice值或者修改自己的nice值：

    #include<unistd.h>
    int nice(int incr);

        参数：
            incr：nice值的增量
        返回值：
            成功：返回新的nice值
            失败：返回 -1

    incr会被增加到调用进程的nice值上。
        如果incr值太大，系统会直接将它降到最大合法值，不会出错（UBUNTU 16.04中是 19）
        如果incr值太小，系统会直接将它提高到最小合法值，不会出错（UBUNTU 16.04中是 -20）
            由于 -1 是合法的成功返回值。因此在nice返回 -1 时，需要综合errno才能判断是否出错

    getpriority/setpriority函数：获取/设置进程的nice值：

    #include<sys/resource.h>
    int getpriority(int which,id_t who);
    int setpriority(int which,id_t who,int value);

        参数：
            which：控制who参数是如何解释的。可以取三个值之一：
                PRIO_PROCESS：表示进程
                PRIO_PGRP:表示进程组
                PRIO_USER表示用户ID
            who：选择感兴趣的一个或者多个进程。
                如果who为0，which为PRIO_PROCESS，返回当前进程的nice值
                如果who为0，which为PRIO_PGRP，则返回进程组中最小的nice值
                如果who为0，which为PRIO_USER，则返回调用进程的实际用户ID拥有的那些进程中最小的nice值
            value：nice的增量

        返回值：
            getpriority：成功返回-20～19之间的nice值；失败返回 -1

    getpriority不仅可以获得本进程的nice值，还可以获取一组相关进程的nice值。而setpriority可以为本进程、进程组、属于特定用户ID的所有进程设置优先级

myfork.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include<ctype.h>
#include <string.h>
#include<time.h>
#include<alloca.h>
#include<setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int global_var = 1;

int main(int agrc, char *argv[])
{
	int local_var = 1;
	int status;
	int pid;
	printf("before fork!\n");
	if((pid = fork()) < 0 )
	{
		perror("fork error");
		return -1;
	}
	else if(pid == 0)
	{
		global_var++;
		local_var++;
		printf("child global_var_addr:%p  value:%d\n", &global_var, global_var);
		printf("child local_var_addr:%p  value:%d\n", &local_var, local_var);
		exit(0);// exit可能会关闭标准IO，导致父进程的printf返回-1(建议使用_exit()函数使程序可移植性更高)
	}

	if(waitpid(pid, &status, 0) < 0)
	{
		perror("waitpid error");
		return -1;
	}
	printf("father global_var_addr:%p  value:%d\n", &global_var, global_var);
	printf("father  local_var_addr:%p  value:%d\n", &local_var, local_var);

	return 0;
}

myfork2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include<ctype.h>
#include <string.h>
#include<time.h>
#include<alloca.h>
#include<setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int globalvalue = 6;
char buf[] = "a write to stdout\n";

int main(void)
{
	int var = 88;
	pid_t pid;

	if (write(STDOUT_FILENO, buf, sizeof(buf) - 1) != sizeof(buf) - 1)
		err_sys("write error");
	printf("before fork\n");

	if ((pid = fork()) < 0)
		err_sys("fork error");
	else if (pid == 0) {
		globalvalue++;
		var++;
	}
	else
		sleep(2);

	printf("pid =%ld, globalvalue =%d, var =%d\n", (long)getpid(), globalvalue, var);
	exit(EXIT_SUCCESS);
}

myvfork.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include<ctype.h>
#include <string.h>
#include<time.h>
#include<alloca.h>
#include<setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int global_var = 1;

int main(int agrc, char *argv[])
{
	int local_var = 1;
	int status;
	int pid;
	printf("before fork!\n");
	if((pid = vfork()) < 0 )
	{
		perror("fork error");
		return -1;
	}
	else if(pid == 0)
	{
		global_var++;
		local_var++;
		printf("child global_var_addr:%p  value:%d\n", &global_var, global_var);
		printf(" child local_var_addr:%p  value:%d\n", &local_var, local_var);
		exit(0);
	}

	printf("father global_var_addr:%p  value:%d\n", &global_var, global_var);
	printf("father  local_var_addr:%p  value:%d\n", &local_var, local_var);

	return 0;
}

myvfork2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include<ctype.h>
#include <string.h>
#include<time.h>
#include<alloca.h>
#include<setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int globalvalue = 6;

int main(void)
{
	volatile int var = 88;
	pid_t pid;

	printf("before fork...\n");
	if ((pid = vfork()) < 0)
		err_sys("fork error\n");
	else if (pid == 0) {
		++globalvalue;
		++var;
		_exit(0);
	}
	
	printf("pid = %ld, globalvalue = %d, var = %d\n", (long)getpid(), globalvalue, var);
	exit(EXIT_SUCCESS);
}

myvfork3.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include<ctype.h>
#include <string.h>
#include<time.h>
#include<alloca.h>
#include<setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int global_var = 6;

int main(void)
{
	int var = 88;
	pid_t pid;

	printf("before vfork...\n");
	if ((pid = vfork()) < 0)
		err_sys("vfork error\n");
	else if (pid == 0) {
		global_var++;
		var++;

		if (fclose(stdout) != 0)
			err_sys("fclose error\n");
		_exit(0);
	}
	
	if (printf("pid:%d, ppid:%d, var=%d, global_var:%d\n",
		getpid(), getppid(), var, global_var) == -1)
		fputs("stdout closed\n", stderr);

	exit(0);
}

myvfork4.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include<ctype.h>
#include <string.h>
#include<time.h>
#include<alloca.h>
#include<setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

void func(void) {
	pid_t pid;
	volatile int local_value = 10;

	if ((pid = vfork()) < 0)
		err_sys("fork error\n");
	else if (pid == 0) {
		printf("value= %d\n", local_value);
		printf("pid: %d,ppid: %d, child in func\n", getpid(), getppid());
	}
	else {
		if (waitpid(pid, NULL, 0) != pid)
			err_sys("waitpid error\n");
		printf("value= %d\n", local_value);
		printf("pid: %d,ppid: %d, parent in func\n", getpid(), getppid());
	}
	return;
}

int main(void)
{
	printf("pid: %d,ppid: %d,parent before func executed\n\n",
		getpid(), getppid());
	func();
	printf("pid: %d,ppid: %d,child or parent??\n",
		getpid(), getppid());
	
	exit(EXIT_SUCCESS);
}

myexecvp.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include<ctype.h>
#include <string.h>
#include<time.h>
#include<alloca.h>
#include<setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int main(int argc, char* argv[])
{
	if (argc < 2)
		err_sys("usage:do <execute-file>\n");

	pid_t pid;

	if ((pid = fork()) < 0)
		err_sys("fork error\n");
	else if (pid == 0) {
		if (execvp(argv[1], &argv[1]) == -1)
			err_sys("execvp error\n");
	}
	else {
		if (waitpid(pid, NULL, 0) != pid)
			err_sys("waitpid error\n");
	}

	exit(EXIT_SUCCESS);
}

myexecvp2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include<ctype.h>
#include <string.h>
#include<time.h>
#include<alloca.h>
#include<setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

static void pr_time(clock_t real, const struct tms* pstart, const struct tms* pend) {
	static long clktck;
	if (clktck == 0)
		if ((clktck = sysconf(_SC_CLK_TCK)) < 0)
			err_sys("sysconf error\n");

	printf("\n________________________________________\n");
	printf(" real : %7.3fs\n", real / (double)clktck);
	printf(" user : %7.3fs\n",
		(pend->tms_cutime - pstart->tms_cutime) / (double)clktck);
	printf(" sys  : %7.3fs\n",
		(pend->tms_cstime - pstart->tms_cstime) / (double)clktck);
}

int main(int argc, char* argv[])
{
	if (argc < 2)
		err_sys("usage: time <execute-file>\n");

	pid_t pid;
	clock_t start, end;
	struct tms starttms, endtms;

	if ((start = times(&starttms)) == -1)
		err_sys("times error\n");

	if ((pid = fork()) < 0)
		err_sys("fork error\n");
	else if (pid == 0) {
		if (execvp(argv[1], &argv[1]) == -1) {
			fputs("execvp error\n", stderr);
			_exit(1);
		}
	}
	else {
		if (waitpid(pid, NULL, 0) != pid)
			err_sys("waitpid error\n");
		if ((end = times(&endtms)) == -1)
			err_sys("times error\n");
		pr_time(end - start, &starttms, &endtms);
	}
	
	exit(EXIT_SUCCESS);
}

mywait.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include<ctype.h>
#include <string.h>
#include<time.h>
#include<alloca.h>
#include<setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

void pr_exit(int status)
{
	if(WIFEXITED(status))//正常退出
		printf("normal termination, exit status=%d\n", WEXITSTATUS(status));
	else if(WIFSIGNALED(status))//异常终止
		printf("abnormal termination, signal number=%d, %s\n", WTERMSIG(status), 
#ifdef WCOREDUMP
			WCOREDUMP(status) ? "got a core file":" no core file"
#endif	
			);
	else if(WIFSTOPPED(status))//子进程停止
		printf("child was stopped, signal number=%d\n", WSTOPSIG(status));
}

int main(int argc, char const *argv[])
{
	pid_t pid;
	int status;
	/*子进程return终止*/
	if((pid = fork()) < 0)
		printf("fork error\n");
	else if(pid == 0)
		return 0;
	if(wait(&status) != pid)
		printf("wait error\n");
	pr_exit(status);

	/*子进程exit终止*/
	if((pid = fork()) < 0)
		printf("fork error\n");
	else if(pid == 0)
		exit(7);
	if(wait(&status) != pid)
		printf("wait error\n");
	pr_exit(status);

	/*子进程异常退出，收到SIGABRT信号*/
	if((pid = fork()) < 0)
		printf("fork error\n");
	else if(pid == 0)
		abort();
	if(wait(&status) != pid)
		printf("wait error\n");
	pr_exit(status);

	/*子进程异常退出，内核产生相应信号*/
	if((pid = fork()) < 0)
		printf("fork error\n");
	else if(pid == 0)
		status /= 0;
	if(wait(&status) != pid)
		printf("wait error\n");
	pr_exit(status);


	return 0;
}

myforktwice.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include<ctype.h>
#include <string.h>
#include<time.h>
#include<alloca.h>
#include<setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int main(int argc, char const *argv[])
{
	pid_t pid;
	if((pid = fork()) < 0){
		perror("first fork error");
		return -1;
	}else if(pid == 0){ 	/* 第一个子进程 */
		if((pid = fork()) < 0){
			perror("second fork error");
			return -1;
		}else if(pid > 0){/* 第二个fork的父进程也就是第一个子进程 */
			exit(0);
		}
		/* 这里是第二个子进程 */
		sleep(2);//确保第一个子进程先结束
		printf("second id:%d, father id:%d\n", getpid(), getppid());
		exit(0);
	}

	/* 第一个父进程 */
	
	if(waitpid(pid, NULL, 0) != pid)
	{
		perror("waitpid error");
		return -1;
	}
	return 0;
}

myrace.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include<ctype.h>
#include <string.h>
#include<time.h>
#include<alloca.h>
#include<setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

void output(char *str)
{
	char *ptr;
	int c;
	setbuf(stdout, NULL);/* 设置无IO缓冲 */
	for(ptr=str; (c=*ptr++) != 0; )
		putc(c, stdout);
}

int main(int argc, char const *argv[])
{
	pid_t pid;
	if((pid = fork()) < 0)
		printf("fork error\n");
	else if(pid == 0)
		output("from child process\n");
	else
		output("from father process\n");
	return 0;
}

echoall.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include<ctype.h>
#include <string.h>
#include<time.h>
#include<alloca.h>
#include<setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}
 
int main(int argc, char const *argv[])
{
	extern char **environ;
	int i;
	char **ptr;
	printf("echoall pid:%d\n", getpid());
	/* 输出所有的命令参数 */ 
	for(i=0; i<argc; i++)
		printf("argv[%d]:%s\n", i,argv[i]);

	/* 输出所有的环境参数 */
	for(ptr=environ; *ptr != NULL; ptr++)
		printf("%s\n", *ptr);

	return 0;
}

myexec.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include<ctype.h>
#include <string.h>
#include<time.h>
#include<alloca.h>
#include<setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

/* 初始化传递给新进程的环境变量，一个以NULL结束的指针数组 */
char *env_init[] = {"USER=unknown", "PATH=/tmp", NULL};

int main(int argc, char const *argv[])
{
	pid_t pid;
	if((pid = fork()) < 0)
		printf("fork error\n");
	else if(pid == 0)/* 在子进程中启动新进程(pid不改变) */
	{
		printf("execle pid:%ld\n", (long)getpid());
		if(execle("./echoall", "echoall", "argv[1]", "argv[2]", "argv[3]", (char *)0, env_init) < 0)/* execle 启动新进程(使用新的环境变量env_init) */
			printf("execle error\n");
	}
	if(waitpid(pid, NULL, 0) < 0)
		printf("waitpid error\n");

	if((pid = fork()) < 0)
		printf("fork error\n");
	else if(pid == 0)
	{
		printf("execlp pid:%ld\n", (long)getpid());
		if(execlp("echoall", "echoall", "argv[1]", (char *)0) < 0)/* execlp 启动新进程(沿用当前环境变量，且echoall程序要在PATH路径中找得到) */
			printf("execlp error\n");
	}	

	if(waitpid(pid, NULL, 0) < 0)
		printf("waitpid error\n");

	return 0;
}

myinitisparent.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include<ctype.h>
#include <string.h>
#include<time.h>
#include<alloca.h>
#include<setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int main(void)
{
	pid_t pid;
	if ((pid = fork()) < 0)
		err_sys("fork error\n");
	else if (pid == 0) {
		if ((pid = fork()) < 0)
			err_sys("fork error\n");
		else if (pid > 0)
			exit(EXIT_SUCCESS);

		sleep(2);
		printf("second child, parent pid = %ld\n", (long)getppid());
		exit(EXIT_SUCCESS);
	}

	if (waitpid(pid, NULL, 0) != pid)
		err_sys("waitpid error\n");
	exit(EXIT_SUCCESS);
}

mygetlogin.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include<ctype.h>
#include <string.h>
#include<time.h>
#include<alloca.h>
#include<setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int main(void)
{
	struct passwd* pwd;
	char* name;
	if((pwd=getpwuid(getuid()))==NULL)
		err_sys("getpwuid error\n");
	if ((name = getlogin()) == NULL)
		err_sys("getlogin error\n");
	printf("username(from getpwuid): %s\n", pwd->pw_name);
	printf("username(from getlogin): %s\n", name);

	exit(EXIT_SUCCESS);
}

mygetpid.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include<ctype.h>
#include <string.h>
#include<time.h>
#include<alloca.h>
#include<setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int main(void)
{
	printf("pid  : %d\n", getpid());
	printf("ppid : %d\n", getppid());
	printf("uid  : %d\n", getuid());
	printf("gid  : %d\n", getgid());
	printf("euid : %d\n", geteuid());
	printf("egid : %d\n", getegid());

	return 0;
}

mygettime.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include<ctype.h>
#include <string.h>
#include<time.h>
#include<alloca.h>
#include<setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int main(int argc, char* argv[])
{
	if (argc < 2)
		err_sys("usage:time <execute-file> <args...>\n");

	pid_t pid;
	struct timeval begin, end;

	gettimeofday(&begin, NULL);
	if ((pid = fork()) < 0)
		err_sys("fork error\n");
	else if (pid == 0) {
		if (execvp(argv[1], &argv[1]) == -1)
			err_sys("execvp error\n");
	}
	else {
		if (wait(NULL) != pid)
			err_sys("wait error\n");
		gettimeofday(&end, NULL);
		fputs("\n------------------------------\n",stdout);
		printf("total time: %ld us\n",
			(end.tv_sec - end.tv_sec) * 1000000+(end.tv_usec-begin.tv_usec));
	}

	exit(EXIT_SUCCESS);
}

mynoreturn.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include<ctype.h>
#include <string.h>
#include<time.h>
#include<alloca.h>
#include<setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

void main(void)
{
	const char* msg = "helloworldshowmethecode\n";
	printf("strlen= %ld\n", strlen(msg));
	printf("%s", msg);
}

mysiginfo.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include<ctype.h>
#include <string.h>
#include<time.h>
#include<alloca.h>
#include<setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

void siginfo_status(siginfo_t* infop) {
	//si_signo总是会被设定为SIGCHLD
	if (infop->si_code == CLD_EXITED)
		printf("normal terminal, signal number = %d, exit status = %d\n",
			infop->si_signo, infop->si_status);
	else if (infop->si_code == CLD_KILLED ||
		infop->si_code == CLD_DUMPED) {
		//printf("si_code = %d\n", infop->si_code);
		printf("abnormal terminal, signal number = %d%s\n", infop->si_signo,
			(infop->si_code == CLD_DUMPED) ? ", dump file generated" : "");
	}
	else if (infop->si_code == CLD_STOPPED)
		printf("child stopeped, signal number = %d\n", infop->si_signo);
}

int main(void)
{
	siginfo_t siginfo;
	pid_t pid;

	if ((pid = fork()) < 0)
		err_sys("fork error\n");
	else if (pid == 0)
		exit(7);

	if (waitid(P_PID, pid, &siginfo, WEXITED) != 0)
		err_sys("waitid error\n");
	siginfo_status(&siginfo);

	if ((pid = fork()) < 0)
		err_sys("fork error\n");
	else if (pid == 0)
		abort();

	if (waitid(P_PID, pid, &siginfo, WEXITED) != 0)
		err_sys("watiid error\n");
	siginfo_status(&siginfo);

	if ((pid = fork()) < 0)
		err_sys("fork error\n");
	else if (pid == 0)
		siginfo.si_code /= 0;

	if (waitid(P_PID, pid, &siginfo, WEXITED) != 0)
		err_sys("waitid error\n");
	siginfo_status(&siginfo);

	exit(EXIT_SUCCESS);
}

mywaitpid.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include<ctype.h>
#include <string.h>
#include<time.h>
#include<alloca.h>
#include<setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int main(void)
{
	pid_t pid;

	if ((pid = fork()) < 0)
		err_sys("fork error\n");
	else if (pid == 0) {
		printf("output from child(pid: %d)\n", getpid());
	}
	else {
		sleep(2);
		if (system("ps aux|grep defunct") < 0)
			err_sys("system error\n");
		if (waitpid(pid, NULL, 0) != pid)
			err_sys("watipid error\n");
	}

	exit(EXIT_SUCCESS);
}

mysystem.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include<ctype.h>
#include <string.h>
#include<time.h>
#include<alloca.h>
#include<setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

void pr_exit(int status)
{
	if(WIFEXITED(status))//正常退出
		printf("normal termination, exit status=%d\n", WEXITSTATUS(status));
	else if(WIFSIGNALED(status))//异常终止
		printf("abnormal termination, signal number=%d, %s\n", WTERMSIG(status), 
#ifdef WCOREDUMP
			WCOREDUMP(status) ? "got a core file":" no core file"
#endif	
			);
	else if(WIFSTOPPED(status))//子进程停止
		printf("child was stopped, signal number=%d\n", WSTOPSIG(status));
}


int System(const char* cmdstring) {
	if (cmdstring == NULL)
		return 1;

	pid_t pid;
	int status;
	if ((pid = fork()) < 0)
		status = -1;
	else if (pid == 0) {
		execl("/usr/bin/sh", "sh", "-c", cmdstring, (char*)NULL);
		_exit(127);
	}
	else {
		while (waitpid(pid, &status, 0) < 0) {
			if (errno == EINTR) {
				status = -1;
				break;
			}
		}
	}

	return status;
}

int main(int argc, char* argv[])
{
	if (argc < 2)
		err_sys("usage:tsys <execute-file>\n");

	int status;
	if ((status = System(argv[1])) < 0)
		err_sys("System() error\n");
	pr_exit(status);

	exit(EXIT_SUCCESS);
}

mynice.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include<ctype.h>
#include <string.h>
#include<time.h>
#include<alloca.h>
#include<setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

struct timeval end;
unsigned long long count;

static void checktime(const char *name)
{
	struct timeval tv;
	gettimeofday(&tv, NULL);
	if(tv.tv_sec >= end.tv_sec && tv.tv_usec >= end.tv_usec){
		printf("%s count:%lld\n", name, count);
		exit(0);
	}
}


int main(int argc, char const *argv[])
{
	pid_t pid;
	char *s = NULL;
	int nzero, ret;
	int adj = 0;	

	setbuf(stdout, NULL);// 标准输出无缓冲

#if defined(NZERO)
	nzero = NZERO;	
#elif defined(_SC_NZERO)
	nzero = sysconf(_SC_NZERO);
#else
#error NZERO undefined
#endif

	printf("NZERO=%d\n", nzero);
	if(argc == 2)
		adj = strtol(argv[1], NULL, 10);

	gettimeofday(&end, NULL);
	end.tv_sec += 10;//count++执行最多10秒

	if((pid = fork()) < 0){
		perror("fork error");
		return -1;
	}else if(pid == 0){// 子进程
		s = "child";
		printf("Child nice value:%d, adj:%d\n", nice(0)+nzero, adj);
		errno = 0;
		if((ret = nice(adj)) == -1 && errno != 0)// nice返回-1有两种情况:1<成功返回> 2<失败返回，重置errno>
		{
			perror("set child nice error");
			exit(0);
		}
		printf("Now child nice value:%d\n", ret+nzero);
	}else{// 父进程
		s = "parent";
		printf("Father nice value:%d\n", nice(0)+nzero);
	}

	for(;;){
		count++;
		checktime(s);
	}

	return 0;
}

mytimes.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

void pr_exit(int status)
{
	if(WIFEXITED(status))//正常退出
		printf("normal termination, exit status=%d\n", WEXITSTATUS(status));
	else if(WIFSIGNALED(status))//异常终止
		printf("abnormal termination, signal number=%d, %s\n", WTERMSIG(status), 
#ifdef WCOREDUMP
			WCOREDUMP(status) ? "got a core file":" no core file"
#endif	
			);
	else if(WIFSTOPPED(status))//子进程停止
		printf("child was stopped, signal number=%d\n", WSTOPSIG(status));
}


int System(const char* cmdstring) {
	if (cmdstring == NULL)
		return 1;

	pid_t pid;
	int status;
	if ((pid = fork()) < 0)
		status = -1;
	else if (pid == 0) {
		execl("/usr/bin/sh", "sh", "-c", cmdstring, (char*)NULL);
		_exit(127);
	}
	else {
		while (waitpid(pid, &status, 0) < 0) {
			if (errno == EINTR) {
				status = -1;
				break;
			}
		}
	}

	return status;
}

static void pr_times(clock_t real, struct tms* tmsstart, struct tms* tmsend) {
	static long clktck = 0;
	if (clktck == 0)
		if ((clktck = sysconf(_SC_CLK_TCK)) < 0)
			err_sys("sysconf error\n");

	printf(" real: %7.2f\n", real / (double)clktck);
	printf(" user: %7.2f\n",
		(tmsend->tms_utime - tmsstart->tms_utime) / (double)clktck);
	printf(" sys:  %7.2f\n",
		(tmsend->tms_stime - tmsstart->tms_stime) / (double)clktck);
	printf(" child user: %7.2f\n",
		(tmsend->tms_cutime - tmsstart->tms_cutime) / (double)clktck);
	printf(" child sys:  %7.2f\n",
		(tmsend->tms_cstime - tmsstart->tms_cstime) / (double)clktck);
}

static void do_cmd(char* cmd) {
	struct tms tmsstart, tmsend;
	clock_t start, end;
	int status;

	printf("\ncommand: %s\n", cmd);
	if ((start = times(&tmsstart)) == -1)
		err_sys("times error\n");
	if ((status = System(cmd)) < 0)
		err_sys("System() error\n");
	if ((end = times(&tmsend)) == -1)
		err_sys("times error\n");

	pr_times(end - start, &tmsstart, &tmsend);
	pr_exit(status);
}

int main(int argc, char* argv[])
{
	setbuf(stdout, NULL);
	for (int i = 1; i < argc; ++i)
		do_cmd(argv[i]);

	exit(EXIT_SUCCESS);
}

mytimes2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

void pr_exit(int status)
{
	if(WIFEXITED(status))//正常退出
		printf("normal termination, exit status=%d\n", WEXITSTATUS(status));
	else if(WIFSIGNALED(status))//异常终止
		printf("abnormal termination, signal number=%d, %s\n", 
			WTERMSIG(status), 
#ifdef WCOREDUMP
			WCOREDUMP(status) ? "got a core file":" no core file"
#endif	
			);
	else if(WIFSTOPPED(status))//子进程停止
		printf("child was stopped, signal number=%d\n", WSTOPSIG(status));
}


static void pr_times(clock_t real, struct tms *tmsstart, struct tms *tmsend)
{
	static long clktck;
	if((clktck = sysconf(_SC_CLK_TCK)) < 0)// 获得每秒钟的CPU滴答数, _SC_CLK_TCK宏定义在unistd.h文件中
	{
		perror("sysconf error");
		return;
	}

	printf("   real:  %7.2f\n", real/(double)clktck); //总滴答数/每秒滴答数 = 秒数
	printf("   user:  %7.2f\n", 
	(tmsend->tms_utime - tmsstart->tms_utime)/(double)clktck);
	printf("   sys :  %7.2f\n",
	(tmsend->tms_stime - tmsstart->tms_stime)/(double)clktck);
	printf("   child user:  %7.2f\n", 
	(tmsend->tms_cutime - tmsstart->tms_cutime)/(double)clktck);
	printf("   child sys :  %7.2f\n", 
	(tmsend->tms_cstime - tmsstart->tms_cstime)/(double)clktck);
}


static void do_cmd(const char *cmd)
{
	struct tms tmsstart, tmsend;
	clock_t start, end;
	int status;

	printf("\nCommand:%s\n", cmd);
	if((start = times(&tmsstart)) < 0)
	{
		perror("times tmsstart error");
		return;
	}

	if((status = system(cmd)) < 0)
	{
		perror("cmd error");
		return;
	}

	if((end = times(&tmsend)) < 0)
	{
		perror("times tmsend error");
		return;
	}

	pr_times(end-start, &tmsstart, &tmsend);
	pr_exit(status);
}


int main(int argc, char const *argv[])
{
	int i;
	printf("argc:%d\n", argc);
	setbuf(stdout, NULL);

	for(i = 1; i < argc; i++)
		do_cmd(argv[i]);
	return 0;
}

mysystem2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

void pr_exit(int status)
{
	if(WIFEXITED(status))//正常退出
		printf("normal termination, exit status=%d\n", WEXITSTATUS(status));
	else if(WIFSIGNALED(status))//异常终止
		printf("abnormal termination, signal number=%d, %s\n", WTERMSIG(status), 
#ifdef WCOREDUMP
			WCOREDUMP(status) ? "got a core file":" no core file"
#endif	
			);
	else if(WIFSTOPPED(status))//子进程停止
		printf("child was stopped, signal number=%d\n", WSTOPSIG(status));
}

int System(const char* cmdstring) {
	if (cmdstring == NULL)
		return 1;
	
	pid_t pid;
	int status;
	if ((pid = fork()) < 0)
		status = -1;
	else if (pid == 0) {
		execl("/usr/bin/sh", "sh", "-c", cmdstring, (char*)NULL);
		_exit(127);
	}
	else {
		while (waitpid(pid, &status, 0) < 0) {
			if (errno == EINTR) {
				status = -1;
				break;
			}
		}
	}

	return status;
}

int main(void){
	int status;

	if ((status = System("date +%Y-%m-%d")) < 0)
		err_sys("System() error\n");
	pr_exit(status);
	putchar('\n');

	if ((status = System("nosuchcmd")) < 0)
		err_sys("System() error\n");
	pr_exit(status);
	putchar('\n');

	if ((status = System("who;exit 44")) < 0)
		err_sys("System() error\n");
	pr_exit(status);
	putchar('\n');

	exit(EXIT_SUCCESS);
}

mysystem3.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

void pr_exit(int status)
{
	if(WIFEXITED(status))//正常退出
		printf("normal termination, exit status=%d\n", WEXITSTATUS(status));
	else if(WIFSIGNALED(status))//异常终止
		printf("abnormal termination, signal number=%d, %s\n", 
			WTERMSIG(status), 
#ifdef WCOREDUMP
			WCOREDUMP(status) ? "got a core file":" no core file"
#endif
			);
	else if(WIFSTOPPED(status))//子进程停止
		printf("child was stopped, signal number=%d\n", WSTOPSIG(status));
}

int mysystem(const char *cmd)
{
	pid_t pid;
	int status;
	if(cmd == NULL)
		return 1;

	if((pid = fork()) < 0){
		perror("fork error");
		return -1;
	}
	else if(pid == 0){
		execl("/usr/bin/sh", "sh", "-c", cmd, (char *)0);
		_exit(127);
	}
	else{
		while (waitpid(pid, &status, 0) < 0) {
			if (errno == EINTR) {
				status = -1;
				break;
			}
		}
	}
	return status;
}

int main(int argc, char const *argv[])
{
	int status;
	if((status = mysystem("ls -l")) < 0)
	{
		perror("first mysystem error");
		return -1;
	}
	pr_exit(status);

	if((status = mysystem("errorcmd")) < 0)
	{
		perror("second mysystem error");
		return -1;
	}
	pr_exit(status);

	if((status = mysystem("who; exit 66")) < 0)
	{
		perror("third mysystem error");
		return -1;
	}
	pr_exit(status);
	return 0;
}

进程关系

    终端登录：
        BSD系统：
            当系统自举时，内核创建进程ID为 1 的进程，即init进程
            init进程读取文件/etc/ttys，对每个允许登录的终端设备，init调用一次fork，其所生成的子进程则exec getty程序（以一个空的环境）
            getty对终端设备调用open函数，以读、写方式将终端打开。

                一旦设备被打开则文件描述符0、1、2被设置到该设备

                然后getty输出login:之类的信息，并等待用户键入用户名

                当用户键入了用户名后，getty的工作就完成了，它以类似下列的方式调用login程序：

                execle("/bin/login","login","-p",username,(char *)0,envp);

                其中envp是getty使用终端名和在gettytab中说明的环境字符串为login创建的环境。-p标志通知login保留传递给它的环境，也可以将其他环境字符串添加到该环境中，但是不能替换它
            login能处理多项工作
                login得到了用户名，所以能够调用getpwnam获取相应用户的口令文件登录项，然后调用getpass以显示Password:
                接着login读取用户键入的口令，它调用crypt将用户键入的口令加密，并且与该用户在阴影口令文件中登录的pw_passwd字段比较
                如果用户自己键入的口令都无效，则login以参数1调用exit表示登录过程失败
                    父进程init了解了子进程的终止情况后，再次调用fork其后又调用了getty，对此终端重复上述过程
                如果用户键入的口令正确，则login完成下列工作：
                    将当前工作目录更改为用户的起始目录
                    调用chown更改该终端的所有权，使得登录用户成为它的所有者
                    将对该终端设备的访问权限变成”用户读和写“
                    调用setgid和initgroups设置进程组ID
                    用login得到的所有信息初始化环境：起始目录(HOME)、shell(SHELL)、用户名(USER和LOGNAME)以及一个系统默认路径(PATH)
                    login进程调用setuid，将进程的用户ID更改为登录用户的用户ID，并调用该用户的登录shell，其方式类似于：execl("/bin/sh","sh",(char*)0);
                    至此，登录用户的登录shell开始运行。登录shell读取其启动文件（如.profile)。这些启动文件通常是更改某些环境变量并增加很多环境变量。当执行完启动文件后，用户最后得到shell提示符，并能键入命令
        MAC OS X系统：它部分地基于Free BSD，启动步骤与FreeBSD 几乎相同，除了：
            init工作是由launchd完成的
            一开始提供的就是图形终端
        Linux：步骤几乎与Free BSD相同。但是init读取的是/etc/inittab文件而不是/etc/ttys文件

    网络登录：对于网络登录，所有登录都是经由内核的网络接口驱动程序。
        在BSD系统中，由init执行shell脚本/etc/rc，此shell脚本启动inetd守护进程。由inetd负责处理网络登录
        在Linux系统中，使用xinetd代替inetd进程

进程组

    进程组：每个进程除了有一个进程ID之外，还属于一个进程组。进程组是一个或者多个进程的集合。
        通常进程组是在同一个作业中结合起来的
        同一个进程组中的各进程接收来自同一个终端的信号
        每个进程组都有一个唯一的进程组ID
            进程组ID类似于进程ID，是一个整数并且可以存放在pid_t数据类型中
        每个进程组都有一个组长进程。进程组ID就等于组长进程的进程ID
            进程组的组长进程可以创建该组中的进程
            进程组的组长进程也可以终止。只要进程组中至少有一个进程存在，则该进程组就存在，这与组长进程是否终止无关
        进程组的生命周期：从组长进程创建进程中开始，到组内最后一个进程离开为止的时间
            这里用离开，是因为进程可以从一个进程组转移到另一个进程组

    getpgrp/getpgid函数：获取进程所属的进程组：

    #include<unistd.h>
    pid_t getpgrp(void);
    pid_t getpgid(pid_t pid);

        对于getpgrp函数：其返回值是调用进程的进程组ID（没有失败值）
        对于getpgid函数：
            参数：pid为待查看进程的进程ID。如果pid=0，则返回调用进程的进程组ID

            这里没有要求pid和本进程的关系

            返回值：成功，则返回进程组ID；失败返回 -1

    setpgid函数：加入一个现有的进程组或者创建一个新进程组

    #include<unistd.h>
    int setpgid(pid_t pid,pid_t pgid);

        参数：
            pid：待处理的进程的进程ID
            pgid：进程组的组ID
        返回值：
            成功：返回 0
            失败： 返回 -1

    setpgid函数将pid进程的进程组ID设置为pgid
        如果pid等于pgid，则由pid指定的进程变成进程组组长
        如果pid等于0，则使用调用者的进程ID
        如果pgid等于0，则使用pid指定的进程ID用作进程组ID

    注意：一个进程只能为它自己或者他的子进程设置进程组ID，且进程组ID只能为父进程进程组ID、父进程的进程ID或者子进程的进程ID。
        在它的子进程调用exec之后，它就不再更改子进程的进程组ID
        在大多数作业控制shell中，fork之后立即调用此函数，使得父进程设置其子进程的进程组ID，同时也使子进程设置其自己的进程组ID（这两个调用是冗余的，但是是个双保险）

会话

    会话session是一个或者多个进程组的集合。

    setsid函数：创建一个新会话

    #include<unistd.h>
    pid_t setsid(void);

        返回值：
            成功：返回进程组ID
            失败：返回 -1

    进程调用setsid建立一个新会话。如果调用此函数的进程不是一个进程组的组长进程，则此函数创建一个新会话并且发生下面三件事：
        该进程会变成新会话的会话首进程session leader。此时该进程是新会话中的唯一进程

            会话首进程是创建该会话的进程

        该进程成为一个新进程组的组长进程。新进程组ID就是该调用进程的进程ID
        该进程没有控制终端。即使调用setsid之前该进程有一个控制终端，该联系也被切断

    如果调用此函数的进程是个进程组的组长，则此函数返回出错。

        通常是进程首先fork，然后父进程终止，子进程调用setsid继续执行。这确保了子进程不是一个进程组的组长

    getsid函数：返回进程所在的会话ID（会话ID等于会话首进程的进程组ID，会话首进程总是进程组的组长进程，因此它也等于会话首进程的进程ID）

    #include<unistd.h>
    pid_t getsid(pid_t pid);

        参数：
            pid:待查看进程的进程ID
        返回值：
            成功：会话ID
            失败：返回 -1

    如果pid为0，则getsid返回调用进程的会话ID。如果pid并不属于调用者所在的会话，则调用进程就不能得到该会话ID

作业控制

    会话和进程组还有一些特性：
        一个会话可以有一个控制终端controlling terminal
            这可以是终端设备（在终端登录的情况下）
            也可以是伪终端设备（在网络登录的情况下）
        建立与控制终端连接的会话首进程称作控制进程controlling process
        一个会话中的进程组可以分成一个前台进程组，以及一个或者多个后台进程组
        如果一个会话有一个控制终端，则它有一个前台进程组，其他进程组为后台进程组
        无论何时键入终端的中断键（通常是Ctrl+C），都会将中断信号发送至前台进程组的所有进程
        无论何时键入终端的退出键（通常是Ctrl+\），都会将退出信号发送至前台进程组的所有进程

    tcgetpgrp/tcsetpgrp函数：获取/设置当前进程所在会话的前台进程组ID

    #include<unistd.h>
    pid_t tcgetpgrp(int fd);
    int tcsetpgrp(int fd,pid_t pgrpid);

        参数：
            fd：进程在fd这个描述符上打开的终端
            pgrpid：待设置的前台进程组ID

        返回值：
            对于tcgetpgrp：成功则返回前台进程组ID，失败返回 -1
            对于 tcsetpgrp：成功返回 0；失败返回 -1

    如果进程有一个控制终端，则该进程可以调用tcsetpgrp将前台进程组ID设置为pgrpid，其中：
        pgrpid必须是同一个会话的一个进程组的ID
        fd必须引用该会话的控制终端

    注意：大多数应用程序并不直接使用这两个函数，它们通常是由作业控制shell调用

    tcgetsid函数：获取会话首进程的进程组ID（也就是会话ID）

    #include<termios.hh>
    pid_t tcgetsid(int fd);

        参数：
            fd：进程在fd这个描述符上打开的终端
        返回值：
            成功则返回前台进程组ID
            失败返回 -1

    注意会话ID不一定等于前台进程组的组ID。对于一个会话，会话ID通常不变（前提是没有函数主动设置它）；但是前台进程组进程由于作业调度会经常发生变化

    作业控制：运行在一个终端上启动多个作业，它控制哪个作业可以访问终端以及那些作业在后台运行
        一个作业是一个进程组。该进程组的进程协同完成一个任务
        在Linux中，当执行ls > a.out &等命令以&时，就启动了一个后台作业
            shell会赋予它一个作业标识符，并打印作业标识符以及一个或者多个进程ID
        在Linux中，当执行ls > a.out等命令时，就启动了一个前台作业
        当我们键入以下三个字符之一时，会使终端产生信号，并将它们发送到所有的前台进程组（后台进程组不受影响）：
            Ctrl+C中断字符：产生SIGINT信号
            Ctrl+\退出字符：产生SIGQUIT信号
            Ctrl+Z挂起字符：产生SIGTSTP信号
        只有前台作业能够接收来自终端的输入。如果后台作业试图读取终端，则这并不是个错误。终端驱动程序会检测到这种情况，并向后台作业发送一个特定的信号SIGTTIN，该信号通常会停止此后台作业，而shell会向用户发出这种情况的通知
            用户此时可以通过shell命令将该后台作业转换为前台作业运行
        通过stty命令可以禁止或者允许后台作业输出到终端。
            用户禁止后台作业向控制终端写入，则当后台作业试图写到标准输出时，终端驱动程序识别出该写操作来自于后台进程，于是向该作业发送SGITTOU信号，该信号通常会停止此后台作业，而shell会向用户发出这种情况的通知
            用户此时可以通过shell命令将该后台作业转换为前台作业运行
        作业控制是在窗口终端得到广泛应用之前设计和实现的

    孤儿进程组：一个进程组不是孤儿进程组的条件是：该进程组中存在一个进程，其父进程在属于同一个会话的另一个组中
        如果进程组不是孤儿进程组，则属于同一个会话的另一个组中的父进程就有机会重启该组中停止的进程

        如果一个进程组中的所有进程：
            要么其父进程不在同一个会话中
            要么其父进程就在同一个组中

        则该进程组是个孤儿进程组

    当孤儿进程组产生的时候，如果孤儿进程组中有TASK_STOP的进程，那么就发送SIGHUP和SIGCONT信号给这个进程组

        这个顺序是不能变的。我们知道进程在TASK_STOP的时候是不能响应信号的，只有当进程继续运行的时候，才能响应之前的信号。
            如果先发送SIGCONT信号再发送SIGHUP信号，那么SIGCONT信号后，进程就开始重新进入运行态，这个和马上响应SIGHUP信号的用意相悖
            所以这个时候需要在进程TASK_STOP的过程中首先发送SIGHUP信号，为的是让进程运行之后马上执行SIGHUP信号。

        这两个信号是发送给有处于TASK_STOP状态的进程的进程组的所有进程的。所以进程组中正在运行的进程，如果没有建立SIGHUP信号处理函数，那么运行的进程就会因为SIGHUP退出。

mygetpgid.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int main(void) {
	printf("pid: %4d, ppid= %4d, pgid= %4d, sid= %4d, session id= %4d\n",
		getpid(), getppid(), getpgid(0),getsid(0),tcgetsid(STDOUT_FILENO));
	exit(EXIT_SUCCESS);
}

mysetpgid.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int main(int argc, char* argv[])
{
	pid_t pid;

	if ((pid = fork()) < 0)
		err_sys("fork error\n");
	else if (pid == 0) {
		if (setpgid(getpid(), getppid()) == -1)
			err_sys("setpgid error\n");
		execlp("./mygetpgid", "mygetpgid", (char*)0);

		exit(EXIT_FAILURE);
	}
	else {
		if (setpgid(pid, getpid()) == -1)
			err_sys("setpgid error\n");
		if (waitpid(pid, NULL, 0) != pid)//等某一个进程组中的任一终止进程
			err_sys("waitpid error\n");
		execlp("./mygetpgid", "mygetpgid", (char*)0);
		exit(EXIT_FAILURE);
	}
}

mygetsid.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

static void pr_id(const char* info) {
	pid_t pid;

	printf("From %s Process: \n", info);
	printf("Parent process id: %d\n", getppid());
	printf("This  process  id: %d\n", getpid());
	printf("Process group  id: %d\n", getpgrp());
	printf("Session leader id: %d\n", getsid(0));
	if ((pid = tcgetsid(STDOUT_FILENO)) == -1) {
		if(ENOTTY==errno)
			printf("This process has no controlling terminal\n");
	}
	else {
		printf("Controlling process id: %d\n",
			pid);
	}
}

int main(void)
{
	pid_t pid;

	if ((pid = fork()) < 0)
		err_sys("fork error\n");
	else if (pid == 0) {
		if (setsid() == -1)//创建新会话以及新进程组
			err_sys("setsid error\n");
		pr_id("Child");
	}
	else {
		if (waitpid(pid, NULL, 0) != pid)
			err_sys("waitpid error\n");
		printf("---------------------------------------\n");
		pr_id("Parent");
	}
	
	exit(EXIT_SUCCESS);
}

myorphan.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

static void sig_hup(int signo) {
	printf("SIGHUP received, pid = %ld\n", (long)getpid());
}

static void pr_ids(char* name) {
	//		进程名  进程id  父进程id  进程组id  所属会话id  前台进程组id
	printf("%-6s: pid= %4d, ppid= %4d, pgid= %4d, sid= %d, tpgid= %d, tcgetsid = %d\n",
		name, getpid(), getppid(), getpgrp(), getsid(getpid()), tcgetpgrp(STDOUT_FILENO),
		tcgetsid(STDOUT_FILENO));
	fflush(stdout);
}

int main(void)
{
	char ch;
	pid_t pid;

	pr_ids("parent");
	if ((pid = fork()) < 0)
		err_sys("fork error");
	else if (pid > 0) {
		sleep(5);
	}
	else {
		pr_ids("child");
		signal(SIGHUP, sig_hup);
		kill(getpid(), SIGTSTP);
		pr_ids("child");
		if (read(STDIN_FILENO, &ch, 1) != 1) {
			printf("read error %d on controlling TTY\n", errno); exit(1);
		}
	}

	exit(0);
}

myorphan2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

static void sig_hup(int signo)
{
	printf("Got SIGHUP, pid=%ld\n", (long)getpid());
}

static void pr_ids(const char *name)
{
	printf("%s: pid:%ld, ppid:%ld, pgrp:%ld, tpgrp:%ld\n", \
		    name, (long)getpid(), (long)getppid(), (long)getpgrp(), (long)tcgetpgrp(STDIN_FILENO));
	fflush(stdout);
}

int main(int argc, char const *argv[])
{
	pid_t pid;
	char c;
	pr_ids("parent");
	if((pid = fork()) < 0){
		perror("fork error");
		return -1;
	}else if(pid > 0){// parent
		sleep(3);
	}else{
		pr_ids("child");
		signal(SIGHUP, sig_hup);// 当一个进程退出导致一个进程组成为孤儿进程组，且新的孤儿进程组中所有进程处于停止状态，则SIGHUP,SIGCONT会依次
		kill(getpid(), SIGTSTP);// 送到孤儿进程组中的所有孤儿进程
		pr_ids("child");
		if(read(STDIN_FILENO, &c, 1) != 1){
			printf("read error %d on controlling TTY\n", errno);
		}
	}

	return 0;
}

mysetsid.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

static void pr_ids(const char *name)
{
	printf("%s: pid:%ld, ppid:%ld, pgrp:%ld, tpgrp:%ld\n", \
		    name, (long)getpid(), (long)getppid(), (long)getpgrp(), (long)tcgetpgrp(STDIN_FILENO));
	fflush(stdout);
}

int main(int argc, char const *argv[])
{
	pid_t pid;
	if((pid = fork()) < 0){
		err_sys("fork error");
	}else if(pid > 0){// parent exit
		sleep(3);
		exit(EXIT_SUCCESS);
	}

	pr_ids("child1");
	if(setsid() < 0)// 子进程成为新的会话组长
		err_sys("setsid error");
	pr_ids("child2");
	return 0;
}

信号
信号的概念

    信号是软中断，它提供了一种处理异步事件的方法
        产生信号的事件对于进程而言是随机出现的
        进程不能简单的测试一个变量来判断是否发生了一个信号，而是必须告诉内核当某个信号发生时，执行哪些操作。

    每个信号都有一个名字，这些名字都以SIG开头：
        所有的信号名都被定义为正整数常量（信号编号），定义在头文件<signal.h>中
        不存在编号为 0 的信号，POSIX将 0 号编号值称作空信号
        Mac OS X 10.6.8以及Linux 3.2.0都支持31种信号

    很多条件可以产生信号：
        当用户按某些终端键时，引发终端产生信号。如当用户在终端上按Delete键（通常是Ctrl+C）时，产生中断信号SIGINT
        硬件异常信号：除数为0、无效的内存引用等等

            这些条件通常由硬件检测到，并通知内核。然后内核为该条件发生时正在运行的进程产生适当的信号。如对执行一个无效内存引用的进程产生SIGSEGV信号

        进程调用kill()函数可将任意信号发送给另一个进程或者进程组

            要求接收信号的进程和发送信号的进程的所有者必须相同，或者发送信号的进程的所有者是超级用户

        用户可以用kill命令将任意信号发送给其他进程

            此命令只是kill()函数的接口。通常用于终止一个失控的后台进程

        当检测到某种软件条件已经发生并应将其通知有关进程时，也产生信号。如定时器超时的时候产生SIGALRM信号

    进程可以告诉内核当某个信号发生时，执行下列三种操作之一（我们称作信号处理）：
        忽略此信号。大多数信号都可以使用这种方式进行处理，但是SIGKILL和SIGSTOP信号决不能被忽略
            SIGKILL和SIGSTOP向内核和超级用户提供了使进程终止或者停止的可靠方法
            如果忽略某些由硬件异常产生的信号（如非法内存引用或除以0），则进程的运行行为是未定义的
        捕捉信号。为了做到这一点，进程需要通知内核当某种信号发生时，调用一个用户函数。
            在用户函数中，内核执行进程希望对这种事件进行的处理
            注意无法捕捉SIGKILL和SIGSTOP信号
        执行系统默认动作。对大多数信号的系统默认动作是终止该进程。默认动作是忽略的常见的信号有：SIGCANCEL（线程库内部使用）、SIGCHILD（子进程状态改变）

    进程执行时，如果没有显式设定，则所有的信号的处理都为默认动作
        调用fork之后，子进程继承父进程的信号处理方式，因为子进程在开始时复制了父进程的进程空间
        对于子进程，exec函数会将原先设置为要捕捉的信号都改为默认动作，非捕捉的信号则不变。这是因为信号捕捉函数的地址很可能在新程序中没有任何意义

中断的系统调用

    如果进程在执行一个低速系统调用而阻塞期间捕捉到一个信号，则该系统调用就会被中断而不再继续执行。此时该系统调用返回出错，其errno设置为EINTR
        这么做的意义是因为一个信号发生了，进程捕捉到了它，意味着已经发生了某种事情，所以是个好机会应当唤醒阻塞的系统调用

    为了支持中断的系统调用，我们将系统调用分成两类：低速系统调用和非低速系统调用
        低速系统调用是可能使进程永远阻塞的一类系统调用，包括：
            如果某些类型文件（如读管道、终端设备、网络设备）的数据不存在，则读操作可能会使调用者永远阻塞
            如果写某些类型文件（如写管道、终端设备、网络设备），可能会使得调用者永远阻塞
            pause函数（根据定义，它使调用进程休眠直到捕捉一个信号）和wait函数
            某些ioctl函数
            某些进程间通信函数

    为了帮助应用程序使其不必处理被中断的系统调用（即不需要人工来重新启动被中断的系统调用），4.2BSD引进了某些被中断的系统调用自动重启动
        自动重启动的系统调用包括ioctl、read、readv、write、writev、wait、waitpid
        有些情况下，可能我们并不希望这些函数被中断后重启动，因此4.3BSD运行进程基于每个信号禁用重启动功能
        需要自动重启动的原因是：有时候用户根本不知道所使用的输入、输出设备是否是低速设备。如果不提供重启动功能，则对每次read、write系统调用就要进行是否出错返回的测试；如果是被中断的，则需要再调用read、write系统调用

    POSIX要求：只有中断信号的SA_RESTART标志有效时，才重启动被该信号中断的系统调用

可重入函数

    进程捕捉到信号并对其进行处理时，进程正在执行的正常指令序列就被信号处理程序临时中断
        CPU 首先执行该信号处理程序中的指令
        如果从信号处理程序返回，则继续执行进程正在执行的正常指令序列

            有可能无法从信号处理程序返回，如在信号处理程序中调用_exit()或者longjmp

        但是有个问题：在信号处理程序中，无法判断捕捉到信号的时候，进程执行到何处。
            如果在捕捉到信号的时候，进程正在执行malloc，那么在信号处理程序中，绝不应该再调用malloc。否则会破坏malloc维护的存储区链表
            对于某一类函数，如果在捕捉到信号的时候，进程正在执行这些函数，那么在信号处理程序中，可以安全的重复调用这些函数。这一类函数称作可重入函数

    SUS规范说明了在信号处理程序中保证调用安全的函数。这些函数有以下特点：
        没有使用静态数据结构。使用了静态数据结构的函数不是可重入的
        没有调用malloc或者free。调用malloc或者free的函数不是可重入的
        没有使用标准IO函数。使用标准IO函数的函数不是可重入的。因为标准IO库很多都是用了全局数据结构

    当在信号处理函数中调用可重入函数时，应当在调用前保存errno，然后在调用后恢复errno
        因为可重入函数执行失败的时候，可能会修改全局的errno值。而这种改变并不属于进程的正常执行逻辑。

可靠信号术语

    当造成信号的事件发生时，内核为进程产生一个信号（或者说向进程发送一个信号）
        事件产生的原因不限，可以是硬件异常，也可以是软条件或者其他原因
        当信号产生时，内核在进程表中以某种方式设置一个标志

    当内核在进程表中以某种方式设置一个标志时，我们说向进程递送(delivery)了一个信号
        在信号产生(generation)和递送之间的很短的时间间隔内，信号是未决的(pending)

    进程可以阻塞信号的递送：
        如果为进程产生了一个信号，而这个信号是被进程阻塞的，而且对该信号的动作是系统默认的或者捕捉该信号（即不是忽略），则内核为该进程将此信号一直保持为未决状态；直到该进程对此信号解除了阻塞或者将对此信号的动作更改为忽略
        进程可以调用sigpending()函数来判断哪些信号是设置为阻塞并且处于未决状态的
        如果在进程解除对某个信号的阻塞之前，这种信号发生了多次
            POSIX.1运行系统递送该信号一次或者多次。如果递送该信号多次，则称这些信号进行了排队
            除非支持POSIX.1实时扩展，否则大多数UNIX并不对信号排队，而是只递送这种信号一次

    内核在递送一个信号给进程时才决定对此信号的处理方式（而不是在产生该信号的时候决定处理方式）。于是进程在信号递送给它之前仍可以改变对该信号的动作

        通常只有在信号被阻塞且处于未决状态下，我们才有机会改变对该信号的动作。如果该信号未被阻塞，则从信号产生到信号递送之间根本没有机会执行信号处理动作的改变

    如果有多个信号要递送给一个进程，则POSIX.1并没有规定这些信号的递送顺序

    每个进程都有一个信号屏蔽字signal mask，它规定了当前要阻塞递送到该进程的信号集。
        对于每种可能的信号，该屏蔽字中都有一位与之对应
        对于某种信号，如果其对应位已经被设置，则该信号当前是被阻塞的
        进程可以调用sigprocmask来检测和更改其当前信号屏蔽字

    信号编号可能会超过一个整型所包含的二进制位数，因此POSIX.1定义了数据类型sigset_t，它可以容纳一个信号集

信号处理

    signal函数：设置信号处理函数（该函数没什么作用）

    #include<signal.h>
    void (*signal(int signo,void (*func)(int)))(int);

    为了简化分析，我们定义：typedef void Sigfunc(int)， Sigfunc为一个函数，它的参数为int，返回值为void。然后我们得到：

    Sigfunc * signal(int signo,Sigfunc func);

        参数：
            signo：信号编号
            func：针对该信号设置的信号处理函数的函数指针
                也可以是常量SIG_IGN，表示通知内核忽略此信号
                也可以是常量SIG_DFL，表示通知内核采用系统默认动作
        返回值：
            成功：返回以前的信号处理函数的函数指针
            失败：返回 SIG_ERR

    当func是我们指定的函数地址时，一旦指定的信号发生，内核就会调用此函数。我们称这种处理为捕捉该信号，称此函数为信号处理程序。

        在<signal.h>内部，我们可以找到声明：

    #define SIG_ERR (void (*)()) -1
    #define SIG_DFL (void (*)()) 0
    #define SIG_IGN (void (*)()) 1

    signal函数由ISO C定义，由于ISO C不涉及多进程、进程组以及终端IO等，所以它对于信号的定义非常模糊，以至于对UNIX系统而言几乎毫无用处

    kill/raise函数：发送信号给进程或者进程组

    #include<signal.h>
    int kill(pid_t pid,int signo);
    int raise(int signo);

        参数：
            signo：要发送信号的信号编号

        对于kill函数：
            pid：接受信号的进程或者进程组。分为四种情况：
                pid >0：将信号发送给进程ID为pid的进程
                pid==0：将信号发送给与发送进程属于同一个进程组的所有其他进程（这些进程的进程组ID等于发送进程的进程组ID ），且发送进程必须要有权限向这些进程发送信号

                    注意：这里的所有其他进程不包括内核进程和init进程

                pid<0：将该信号发送给其进程组ID等于pid绝对值，且发送进程具有权限向其发送信号的所有进程。

                    注意：这里的所有其他进程不包括内核进程和init进程

                pid==-1：将信号发送给发送进程有权限向他们发送信号的所有进程。

                    注意：这里的所有其他进程不包括内核进程和init进程

        返回值：
            成功：返回 0
            失败： 返回 -1

    raise函数向进程自己发送信号；而kill函数可以发送信号给其他进程或者进程组，但是需要权限：
        超级用户可以将信号发送给任一进程
        非超级用户：发送进程的实际用户ID或者有效用户ID必须等于接收进程的实际用户ID或者有效用户ID
            如果操作系统支持_POSIX_SAVED_IDS，则检查接收进程的保存设置用户ID（而不是有效用户ID）
        有一个信号有例外：如果被发送的信号是SIGCONT，则发送进程可以将它发送给属于同一个会话的任一其他进程

    kill有两种经典应用场景：
        如果kill的signo参数为 0 ，则kill仍然执行正常的错误检查，但是不发送信号
            这常用于确定一个特定的进程是否仍然存在。如果向一个并不存在的进程发送空信号，则kill返回 -1， errno设置为ESRCH
            但是注意：UNIX系统每经过一定时间会重新使用销毁的进程的进程ID，所以可能存在某个给定进程ID的进程并不是你所期望的那个进程
        如果调用kill为本进程产生信号，而且此信号是不被阻塞的，那么可以确保在kill返回之前，任何其他未决的、非阻塞信号（包括signo信号）都被递送到本进程。

- 父进程注册的信号处理程序，在fork之后的子进程中还有效
- 子进程没有权限向进程pid为 1 的init进程发送任何信号（哪怕是空信号）
- 子进程向本进程组发送的SIGINT信号（kill的pid为 0）同时被子进程和父进程捕捉到了
- 子进程向自己raise的SIGINT信号被自己捕捉到了
- 子进程终止时，自动向父进程发送的SIGCHLD信号被父进程捕捉到了

    alarm函数：为进程设置定时器

    #include<unistd.h>
    unsigned int alarm(unsigned int seconds);

        参数：
            seconds：定时器超时需要经过的秒数。
        返回值： 0 或者以前设置的闹钟时间的剩余秒数

    alarm函数为进程设置一个定时器，在将来的seconds秒之后定时器超时。当定时器超时的时候，内核产生SIGALRM信号。该信号的默认动作是终止调用alarm函数的进程。

        由于进程调度的延迟，进程收到SIGALRM信号不是精确的seconds秒，而是要加上一个时间间隔

        如果我们想捕捉SIGALRM信号，则必须在调用alarm之前安装该信号的处理程序。如果我们在alarm之后才安装SIGALRM的信号处理程序，则可能在设定信号处理程序之前信号就产生了

    每个进程只能拥有一个定时器。如果在调用alarm的时候，之前已经为该进程设置了定时器且该定时器尚未超时，则该定时器距离超时的残留时间作为本次alarm函数调用的返回值返回
        如果seconds=0，则取消旧定时器，此时并没有新设定一个定时器，进程不再拥有任何定时器。
        如果以seconds>0，则取消旧定时器，并设定新定时器（超时时间为seconds秒）

- 以seconds=0调用alarm会取消当前的定时器，此时并不会调用信号处理程序。
- 一旦进程终止，所有的定时器都无效。因为进程终止时释放了所有的资源，包括定时器。

    pause函数：阻塞调用进程直到捕捉到一个信号

    #include<unistd.h>
    int pause(void);

        返回值：一定是 -1， 且errno设置为EINTR

    只有执行了一个信号处理程序并且从其返回时，pause才返回。这种情况下pause返回 -1， errno设置为EINTR
        如果我们仅仅是想从pause返回，则信号处理程序可以什么都不做（函数体为空）

    操作信号集的函数：

    #include<signal.h>
    int sigemptyset(sigset_t *set); 
    int sigfillset(sigset_t *set);
    int sigaddset(sigset_t *set,int signo);
    int sigdelset(sigset_t *set,int signo);
    int sigismember(const sigset_t *set,int signo);

        参数：
            set：待处理的信号集的地址
            signo：待处理的信号的编号
        返回值：
            sigemptyset、sigfillset、sigaddset、sigdelset :成功返回 0，失败返回 -1
            sigismember：如果为真，则返回 1；如果为假则返回 0

    sigemptyset清除set指向的信号集的所有信号（set之后就成为一个空的信号集）；sigfillset使得set指向的信号集包含所有的信号；sigaddset将信号signo添加到set指向的信号集中；sigdelset从set指向的信号集中删除信号signo；sigismember测试信号signo是否在set指向的信号集中

    sigprocmask函数：检查、更改、或者同时检测更改进程的信号屏蔽字

    #include<signal.h>
    int sigprocmask(int how,const sigset_t *restrict set,sigset_t *restrict oset);

        参数：
            how:如果set是非空指针，则它结合set一起指示了如何修改当前信号屏蔽字
            set:如果set是非空指针，则它结合how一起指示了如何修改当前信号屏蔽字
            oset:如果是非空指针，则进程的当前信号屏蔽字通过它返回
        返回值：
            成功返回 0
            失败返回 -1

    如果set是非空指针，则它结合how一起指示了如何修改当前信号屏蔽字
        how=SIG_BLOCK：该进程新的信号屏蔽字是其当前信号屏蔽字和set指向的信号集的并集。即set包含了希望阻塞的信号
        how=SIG_UNBLOCK：该进程新的信号屏蔽字是其当前信号屏蔽字和set指向的信号集补集的交集。即set包含了希望解除阻塞的附加信号
        how=SIG_SETMASK：该进程新的信号屏蔽字是set指向的值

    如果set是空指针，则不改变进程的信号屏蔽字，how的值没有任何意义

        sigprocmask是仅为单线程定义的

    如果调用sigprocmask之前，进程有未决的某个信号；调用sigprocmask之后，解除了对该信号的屏蔽，则在sigprocmask返回之前，该信号的信号处理程序就被调用（而不是等到sigprocmask返回之后）

    sigpending函数：返回当前进程的被阻塞而且未决的信号的集合

    #include<signal.h>
    int sigpending(sigset_t *set);

        参数：
            set：指向一个信号集的指针，该信号集存放当前进程的被阻塞的，而且未决的信号
        返回值：
            成功：返回 0
            失败： 返回 -1

    对于调用进程而言，如果某个信号是被阻塞的，那么它一定无法递送，则该信号当前一定也是未决的。

    sigaction函数：检查或者修改指定信号相关联的处理动作。它取代了UNIX早期使用的signal函数

    #include<signal.h>
    int sigaction(int signo,const struct sigaction *restrict act
    		,struct sigaction*restrict oact);

        参数：
            signo：指定处理的信号的编号
            act：如果非NULL，则它指定的数据结构指定了对该信号执行的动作
            oact：如果非NULL，则它指向的数据结构中返回该信号的上一个动作
        返回值：
            成功，返回 0
            失败，返回 -1

    struct sigaction的结构为：

    struct sigaction{
    	void (*sa_handler)(int); //可以为 SIG_IGN、SIG_DFL或者信号处理函数的地址
    	sigset_t sa_mask; //额外需要屏蔽的信号
    	int sa_flags; // 标志位
    	void (*sa_sigaction)(int,siginfo_t *,void*); //可选的另一种信号处理函数
    };
    下面讲解sigaction个字段的意义：

        sa_handler：对该信号执行的信号处理函数的地址或者 SIG_IGN、SIG_DFL

        sa_mask： 当设置信号处理程序时，如果sa_handler字段包含了一个信号捕捉函数的地址（不是常量SIG_IGN，也不是常量SIG_DFL），则sa_mask字段说明了一个信号集。
            在调用该信号捕捉函数之前，这一信号集要加到进程的信号屏蔽字中

                这是为了确保在信号处理函数执行过程中，额外的屏蔽某些信号

            仅当从信号捕捉函数返回时，再将进程的信号屏蔽字恢复为原先值。这样在调用信号处理程序时就能够阻塞某些信号
            在信号处理程序被调用时，操作系统建立的新的信号屏蔽字包括了正在被递送的信号。确保了在处理一个给定的信号时，如果这种信号多次发生，那么它会被阻塞到对当前信号的处理结束为止。同时多次发生的这种信号并不会被排队，而是只登记为一次。

                通常你并不需要在sa_mask中添加signo，因为这是操作系统默认帮你处理的

        一旦对给定的信号设置了一个动作，那么在调用sigaction显式改变它之前，该设置就一直有效。

        sa_flags字段指定对信号进行处理的各个选项：
            SA_INTERRUPT：由此信号中断的系统调用不会自动重启动
            SA_NOCLDSTOP：如果signo是SIGCHLD，则当子进程停止时，不产生此信号。
            SA_NOCLDWAIT：如果signo是SIGCHLD，则当调用进程的子进程终止时，不创建僵死进程。

                若进程随后调用wait，则阻塞到它所有子进程都终止，此时返回 -1 ，errno设置为ECHILD

            SA_NODEFER：当捕捉到信号时，在执行其信号捕捉函数时，系统并不自动阻塞此信号

                这意味着，如果在信号捕捉函数执行期间，该信号又发生了，则会执行新一轮的信号捕捉函数

            SA_RESETHAND：在信号处理函数的入口处，将此信号的处理方式重置为SIG_DFL，并清除SA_SIGINFO标志。

                这意味着所建立的信号处理函数只是一次性的。下一次信号递送时，采用默认的SIG_DFL

            SA_RESTART：由此信号中断的系统调用自动重启动
            SA_SIGINFO：此选项对信号处理程序提供了附加信息：一个指向siginfo结构的指针，以及一个指向进程上下文标志符的指针

                此时对应的是字段 void (*sa_sigaction)(int,siginfo_t *,void*);

        sa_sigaction：它是一个替代的信号处理程序，当sa_flags中设置了SA_SIGINFO标志时使用sa_sigaction。

            对于sa_sigaction和sa_handler，你只能选择使用这两个字段中的一个

            通常按照下列方式调用信号处理程序： void handler(int signo);

            但是如果设置了SA_SIGINFO标志，则按照下列方式调用信号处理程序： void handler(int signo,siginfo_t *info,void* context);。其中siginfo_t结构包含了信号产生原因的有关信息，结构大致如下：

        struct siginfo{
	int si_signo; //信号编号 
	int si_errno; //如果非零，则为 errno 
	int si_code; //额外的信息 
	pid_t si_pid; //sending process ID 
	uid_t si_uid; // sending process real user ID 
	void *si_addr; // address that caused the fault 
	int si_status; //退出状态或者信号编号 
	union sigval si_value; //application-specific value  
        };
如果信号是SIGCHLD，则将设置si_pid、si_status、si_uid字段
如果信号是SIGBUS、SIGILL、SIGFPE、SIGSEGV，则si_addr包含了造成故障的根源地址，该地址可能并不准确。
si_errno字段包含了错误编号，它对应了造成信号产生的条件，并由操作系统定义

          其中si_code给出了信号产生的详细信息，它有一些常量定义。如SIGCHLD信号中，si_code可以为：CLD_EXITED、CLD_KILLED、CLD_STOPPED....

          其中 union sigval包含：
          
          union sigval{
          	int sival_int;
          	void* sival_ptr;
          };
          
          应用程序在递送信号时，在si_value.sival_int中传递一个整数或者在si_value.sival_ptr中传递一个指针

            context参数是无类型指针，它可以被强制转换为ucontext_t结构指针，ucontext_t结构标识信号传递时进程的上下文。该结构至少包含下列字段：

             ucontext_t *uc_link; //指向当前上下文结束后，要返回的上下文的地址
             sigset_t uc_sigmask; // 当前上下文执行时，阻塞的信号集
             stack_t uc_stack; //当前上下文使用的栈
             mcontext_t uc_mcontext;// machine-specific representation of saved context

            uc_stack字段描述了当前上下文使用的栈，至少包含下列成员：

             void *ss_sp;   // 栈基指针
             size_t ss_size;// 栈大小
             nt ss_flags;   // 栈标识

    sigsetjmp/siglongjmp函数：用于信号处理程序中的跳转函数

    #include<setjmp.h>
    int sigsetjmp(sigjmp_buf env,int savemask);
    void siglongjmp(sigjmp_buf env,int val);

    对于 sigsetjmp：
        参数：
            env：一个sigjmp_buf结构。由sigsetjmp函数使用它与siglongjmp之间通信
            savemask：调用siglongjmp时，如果savemask非0，则siglongjmp跳转会自动恢复保存的信号屏蔽字；如果为0，则siglongjmp跳转时不会自动恢复保存的信号屏蔽字。
        返回值：
            若直接调用，则返回0
            若从siglongjmp调用返回，则返回siglongjmp的val参数

    对于 siglongjmp：
        参数：
            env：一个sigjmp_buf结构。由siglongjmp函数使用它与sigsetjmp之间通信
            val：用于跳转到sigsetjmp，并作为sigsetjmp的返回值

    在信号处理程序中直接使用longjmp/setjmp有个问题：当捕捉到一个信号并进入信号处理程序中时，此时当前信号自动的加到进程的信号屏蔽字中。如果longjmp跳出了信号处理程序，那么此时进程的信号屏蔽字并不恢复。
    因此提供了sigsetjmp/siglongjmp函数。sigsetjmp/siglongjmp函数与longjmp/setjmp的唯一区别是：sigsetjmp增加了一个参数savemask，savemask非0则siglongjmp跳转时会自动恢复保存的信号屏蔽字。

    注意：savemask非0时，调用sigsetjmp会在env中记录下当前的信号屏蔽字。如果后续siglongjmp跳转，则恢复的是sigsetjmp时的信号屏蔽字，而不是进入信号处理程序之前时刻的信号屏蔽字。

    sigsuspend函数：用于原子性的修改信号屏蔽字然后进程睡眠

    #include<signal.h>
    int sigsuspend(const sigset_t *sigmask);

        参数：
            sigmask：进程的信号屏蔽字修改为sigmask指向的值
        返回值：-1，并将errno设置为EINTER

    sigsuspend将进程的信号屏蔽字设置为sigmask指向的值 ，然后将进程投入睡眠，这两步是原子的。如果不是原子的，可能在修改屏蔽字之后，进程睡眠之前发生了信号递送，则进程的睡眠不会被该信号打断（信号发生在进程睡眠之前）。

    sigsuspend在捕捉到一个信号（该信号未被sigmask屏蔽）或者发生了一个会终止进程的信号之前，进程被挂起。如果捕捉到一个信号而且从该信号处理程序中返回，则sigsuspend返回，并且该进程的信号屏蔽字设置为调用sigsuspend之前的值。

    sigsuspend没有成功返回值。如果它返回到调用者，则总是返回-1，并将errno设置为EINTER，表示一个被中断的系统调用。

    abort函数：是程序异常终止

    #include<stdlib.h>
    void abort(void);

    abort函数将SIGABRT信号发送给调用进程。对于SIGABRT信号，任何进程都不能忽略此信号。
        ISO C要求：如果捕捉到了SIGABRT信号，则信号处理程序不会返回到其调用者，因此必须在信号处理程序中调用exit、_exit、_Exit、longjmp、siglongjmp之一，因为只有这些函数才不返回到其调用者

        Linux 中测试：没有这个要求，而是直接就退出程序

        POSIX要求：abort不理会进程对SIGABRT信号的阻塞和忽略行为

    进程捕捉SIGABRT的目的是为了在进程终止之前由进程执行所需的清理工作。如果进程不在SIGABRT信号处理程序中终止自己，则POSIX声明，当信号处理程序返回时，abort终止该进程。

在进程中，即使设置了进程的信号屏蔽字为SIGABRT，但是进程仍然递送SIGABRT信号。
当捕获了SIGABRT信号时，从信号处理程序返回时，直接退出进程，而不是返回原上下文中。
虽然在信号处理程序中没有显式给出_exit语句，但是这就是SIGABRT的语义。

    sleep/nanosleep/clock_nanosleep函数：将进程投入睡眠

    #include<unistd.h>
    unsigned int sleep(unsigned int seconds);
    #include<time.h>
    int nanosleep(const struct timespec*reqtp,struct timespec *remtp);
    int clock_nanosleep(clockid_t clock_id,int flags,
    		const struct timespec *reqtp,struct timespec *remtp);

        对于 sleep函数：
            参数： seconds：进程要睡眠的时间，单位为秒
            返回值：0 或者未休眠完的秒数

        sleep函数使得调用进程被挂起直到下列两个条件之一发生：
            已经经过了seconds所指定的时间。此时返回值是0

            由于操作系统调度等原因，实际返回的时刻可能要比所要求的迟一点

            调用进程捕捉到一个信号，并且从信号处理程序返回。此时返回值是为休眠完的秒数。

            某些操作系统上使用alarm来实现sleep，因此不能将alarm与sleep混合使用，容易出问题。

        对于nanosleep函数：
            参数：
                reqtp：它指向的结构用秒和纳秒指定了需要休眠的时间长度
                remtp：如果某个信号中断了休眠间隔，进程并未终止，则它指向的结构存放未休眠完的时间长度。如果对未休眠完的时间不感兴趣，则可以设置它为NULL
            返回值：
                如果休眠到要求的时间，则返回0
                如果未休眠到要求的时间（被信号中断），则返回 -1

        如果系统不支持纳秒这一精度，则要求的时间就会取整。另外nanosleep函数并不涉及任何信号，所以不需要担心它与其他函数的交互（如alarm)

        对于clock_nanosleep函数：
            参数：
                clock_id：指定了计算延迟时间的基准始终。可以为：
                    CLOCK_REALTIME：实时系统时间
                    CLOCK_MONOTONIC：不带负跳数的实时系统时间
                    CLOCK_PROCESS_CPUTIME_ID：调用进程的CPU时间
                    CLOCK_THREAD_CPUTIME_ID：调用线程的CPU时间
                flags：用于控制延迟是相对的还是绝对的。
                    0：表示休眠时间是相对的（如休眠的时间为 3秒）
                    TIMER_ABSTIME：休眠时间是绝对的（如休眠到时钟到达某个特定的刻度）
                reqtp：它指向的结构用秒和纳秒指定了需要休眠的时间长度
                remtp：如果某个信号中断了休眠间隔，进程并未终止，则它指向的结构存放未休眠完的时间长度。如果对未休眠完的时间不感兴趣，则可以设置它为NULL。注意如果使用绝对时间时，remtp未使用，因为没有必要。
            返回值：
                若休眠到要求的时间，返回 0
                若出错，返回错误码

        提供clock_nanosleep的原因是：由于多个系统时钟的引入，需要使用相对于特定时钟的延迟时间挂起调用线程。除了出错返回之外，调用clock_nanosleep(CLOCK_REALTIME,0,reqtp,remtp)和调用nanosleep(reqtp,remtp)效果相同的。

        要求提供绝对延迟是因为某些应用对休眠长度有精度要求。而相对休眠时间会导致实际休眠比要求的长（处理器调度和抢占可能会导致相对休眠时间超过实际需要的时间间隔）

    sigqueue函数：向进程发送排队的信号

    # include<signal.h>
    int sigqueue(pid_t pid,int signo,const union sigval value);

        参数：
            pid：接收信号的进程的ID
            signo：发送的信号的编号
            value：向信号处理程序传递的数据（可以传递整数或者指针值）
        返回值：
            成功，返回 0
            失败， 返回 -1

    使用排队信号必须做以下几个操作：
        使用sigaction函数安装信号处理程序时指定SA_SIGINFO标志
        在sigaction结构的sa_sigaction成员中（而不是sa_handler字段）提供信号处理程序。

        因为只有sa_sigaction指定的信号处理程序才带有siginfo参数。所有的信号信息都嵌入在siginfo结构中。

        使用sigqueue函数发送信号

    使用sigqueue类似kill，但是sigqueue可以向信号处理程序传递整数或者指针值。除此之外二者类似。

    信号不能被无限排队，有一个SIGQUEUE_MAX限制。到达相应的限制之后，sigqueue会失败，将errno设置为EAGIN

        经测试，在 UBUNTU 16.04上并未有排队功能。

    作业控制信号：
        SIGCHLD：子进程已经停止或者终止
        SIGCONT：如果进程已停止，则使其继续运行
        SIGSTOP：停止信号（不能被捕捉或者忽略）
        SIGTSTP：交互式停止信号
        SIGTTIN：后台进程组成员读控制终端
        SIGTTOU：后台进程组成员写控制终端

    除了SIGCHLD之外，大多数应用程序并不处理这些信号，交互式shell通常会完成这些信号的处理工作：
        当键入挂起字符（一般是Ctrl+Z）时，SIGTSTP被送至前台进程组的所有进程

    信号名和编号：某些操作系统（如Linux/Mac）提供了数组：extern char *sys_siglist[];，数组下标是信号编号，数组中的元素是指向信号名字符串的指针。

    psignal函数：打印与信号编号对应的字符串

    #include<signal.h>
    void psignal(int signo,const char*msg);

        参数：
            signo：待处理的信号的编号
            msg：添加到信号说明部分的内容

    该函数会将msg字符串输出到标准错误文件，后面跟一个冒号和一个空格，再后面是对信号signo的说明。如果msg为NULL，则只有信号说明部分会输出到标准错误文件。

    psiginfo函数：打印siginfo结构

    #include<signal.h>
    void psiginfo(const siginfo_t *info,const char *msg);

        参数：
            info：指向待打印的siginfo结构
            msg：添加到信号说明部分的内容

    该函数会将msg字符串输出到标准错误文件，后面跟一个冒号和一个空格，再后面是对结构info的说明。如果msg为NULL，则只有结构info的说明部分会输出到标准错误文件。

    strsigal函数：返回信号的字符描述（类似于strerror函数）

    #include<string.h>
    char *strsignal(int signo);

        参数：
            signo：待描述的信号的编号
        返回值：
            返回指向描述该信号的字符串的指针

mysigusr.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

static void sig_hanlder(int signo)
{
	if(signo == SIGUSR1)
		printf("Got SIGUSR1 signal!\n");
	else if(signo == SIGUSR2)
		printf("Got SIGUSR2 signal!\n");
	else
		printf("Got a signal:%d\n", signo);
}


int main(int argc, char const *argv[])
{
	if(signal(SIGUSR1, sig_hanlder) == SIG_ERR)
	{
		perror("can't catch SIGUSR1");
		_exit(0);
	}
	
	if(signal(SIGUSR2, sig_hanlder) == SIG_ERR)
	{
		perror("can't catch SIGUSR2");
		_exit(0);
	}

	for( ; ; )
		pause();
	return 0;
}

myalarm.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

static void my_alarm(int signo)
{
	struct passwd *root_ptr;
	printf("in signal handler\n");
	if((root_ptr = getpwnam("root")) == NULL)
	{
		perror("getpwnam root error");
		return;
	}
	alarm(1);
}


int main(int argc, char const *argv[])
{	
	struct passwd *ptr;
	signal(SIGALRM, my_alarm);
	alarm(1);
	for( ; ; ){
		if((ptr = getpwnam("st")) == NULL){
			perror("getpwnam error");
			return -1;
		}

		if(strcmp(ptr->pw_name, "st") != 0)
			printf("return value corrupted!, pw_name=%s\n", ptr->pw_name);

	}
	return 0;
}

mysigchild.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

static void sig_chld(int signo)
{
	pid_t pid;
	int status;

	printf("SIGCHLD received!\n");
	if(signal(SIGCHLD, sig_chld) == SIG_ERR)
		perror("signal error");

	if((pid = wait(&status)) < 0)
		perror("wait error");

	printf("pid:%d\n", pid);
}

int main(int argc, char const *argv[])
{
	pid_t pid;
	if(signal(SIGCHLD, sig_chld) == SIG_ERR)
		perror("signal error");

	if((pid = fork()) < 0){
		perror("fork error");
		return -1;
	}else if(pid == 0){//child
		sleep(2);
		_exit(0);
	}

	pause();
	return 0;
}

mysleep1.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

static void sig_handler(int signo)
{
	printf("got a signal\n");
}

unsigned int sleep1(unsigned int second)
{
	if(signal(SIGALRM, sig_handler) == SIG_ERR)
	{
		perror("signal error");
		return second;
	}
	alarm(second);
	pause();
	return(alarm(0));
}

int main(int argc, char const *argv[])
{
	unsigned int ret;
	ret = sleep1(3);
	printf("sleep1:%d\n", ret);
	return 0;
}

mysleep2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

static jmp_buf env_alrm;

static void sig_handler(int signo)
{
	longjmp(env_alrm, 1);
}

unsigned int sleep2(unsigned int second)
{
	if(signal(SIGALRM, sig_handler) == SIG_ERR)
	{
		perror("signal error");
		return second;
	}

	if(setjmp(env_alrm) == 0){//成功设置返回0，从longjmp跳回返回非零
		alarm(second);
		pause(); 
	}

	return(alarm(0));
}

int main(int argc, char const *argv[])
{
	unsigned int ret;
	ret = sleep2(3);
	printf("sleep2:%d\n", ret);
	return 0;
}

mysleep3.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

static jmp_buf env_alrm;

static void sig_alrm(int signo)
{
	longjmp(env_alrm, 1);
}

/* 处理函数的执行时间将超过3秒钟 */
static void sig_int(int signo)
{
	int i, j;
	volatile int k;
	printf("\nsig_int start\n");
	for(i=0; i<300000; i++)
		for(j=0; j<4000; j++)
			k += i*j;
	printf("sig_int finished\n");
}


unsigned int sleep3(unsigned int second)
{
	if(signal(SIGALRM, sig_alrm) == SIG_ERR){
		perror("signal alrm error");
		return second;
	}

	if(setjmp(env_alrm) == 0){//成功设置返回0，从longjmp跳回返回非零
		alarm(second);
		printf("123\n");
		pause(); 
	}

	return(alarm(0));
}

int main(int argc, char const *argv[])
{
	if(signal(SIGINT, sig_int) == SIG_ERR){
		perror("signal int error");
		return -1;
	}
	unsigned int ret;
	ret = sleep3(3);
	printf("sleep3:%d\n", ret);
	return 0;
}

mytimeoutread1.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

static jmp_buf env_alrm;

static void sig_alrm(int signo)
{
	longjmp(env_alrm, 1);
}

int main(int argc, char const *argv[])
{
	int n;
	char line[1024];
	if(signal(SIGALRM, sig_alrm) != 0){
		perror("signal error");
		return -1;
	}

	if(setjmp(env_alrm) != 0){
		perror("setjmp error");
		return -1;
	}

	alarm(10);//设置定时器,10秒内read没返回sig_alrm将中断read调用
	if((n = read(STDIN_FILENO, line, 1024)) < 0){
		perror("read error");
		return -1;
	}
	alarm(0);//取消定时器
	write(STDIN_FILENO, line, n);
	return 0;
}

mytimeoutread2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

static void sig_alrm(int signo)
{
	;
}

int main(int argc, char const *argv[])
{
	int n;
	char line[1024];
	if(signal(SIGALRM, sig_alrm) != 0){
		perror("signal error");
		return -1;
	}

	alarm(10);//设置定时器,10秒内read没返回sig_alrm将中断read调用
	if((n = read(STDIN_FILENO, line, 1024)) < 0){
		perror("read error");
		return -1;
	}
	alarm(0);//取消定时器
	write(STDIN_FILENO, line, n);
	return 0;
}

mysigset.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define sigemptyset(ptr)  (*(ptr) == 0) //清空信号集
#define sigfillset(ptr)   (*(ptr) = ~(int)0) //将信号集全设置为1

#define BADSIG(signo) ((signo) <= 0 || (signo) >= 32) //信号的值范围应该在1-31之间

//设置某一位信号
int sigaddset(int *set, int signo)
{
	if(BADSIG(signo)){
		errno = EINVAL;
		return -1;
	}

	*set |= 1 << (signo -1);
	return 0; 
}

//清除某一位信号
int sigdelset(int *set, int signo)
{
	if(BADSIG(signo)){
		errno = EINVAL;
		return -1;
	}

	*set &= (~(1 << (signo -1)));
	return 0;
}

//测试某一位信号
int sigismember(int *set, int signo)
{
	if(BADSIG(signo)){
		errno = EINVAL;
		return -1;
	}

	return((*set & (1 << (signo -1))) != 0)
}

mysigprocmask1.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

static void print_sigmask(void)
{
	sigset_t sigset;
	int 	 errno_save;
	errno_save = errno;

	if(sigprocmask(0, NULL, &sigset) < 0){
		perror("sigprocmask error");
		return;
	}else {
		printf("some signal are blocked!\n");
		if(sigismember(&sigset, SIGINT))
			printf("SIGINT\n");
		if(sigismember(&sigset, SIGQUIT))
			printf("SIGQUIT\n");
		if(sigismember(&sigset, SIGUSR1))
			printf("SIGUSER1\n");
		if(sigismember(&sigset, SIGALRM))
			printf("SIGALRM\n");
	}
	printf("over!\n");
	errno = errno_save;//恢复errno值
}

int main(int argc, char const *argv[])
{
	print_sigmask();
	return 0;
}

mysigprocmask2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

static void sig_quit(int signo)
{
	printf("got SIGQUIT\n");
	if(signal(SIGQUIT, SIG_DFL) == SIG_ERR){
		perror("signal in sig_quit error");
		return;
	}
}

int main(int argc, char const *argv[])
{
	sigset_t  newmask, oldmask, pendmask;
	if(signal(SIGQUIT, sig_quit) == SIG_ERR){
		perror("signal error");
		return -1;
	}

	sigemptyset(&newmask);//先清空信号集
	sigaddset(&newmask, SIGQUIT);//再将SIGQUIT信号设置如信号集中
	if(sigprocmask(SIG_BLOCK, &newmask, &oldmask) < 0){//设置信号集阻塞的同时保存当前的信号集到oldmask中
		perror("sigprocmask error");
		return -1;
	}

	sleep(5);//SIGQUIT将在这里被block

	if(sigpending(&pendmask) < 0){//获得当前被pending的信号集
		perror("sigpending error");
		return -1;
	}
	if(sigismember(&pendmask, SIGQUIT))
		printf("SIGQUIT signal is pending\n");

	//恢复原先的信号集
	if(sigprocmask(SIG_SETMASK, &oldmask, NULL) < 0){
		perror("sigprocmask error");
		return -1;
	}
	printf("SIGQUIT unblock\n");
	return 0;
}

mysigaction1.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

typedef void Sigfunc(int);//定义一个新类型Sigfunc,表示没有返回值，参数是int的函数

static void sig_handler(int signo)
{
	printf("got a sig_int\n");
}

static Sigfunc *my_signal(int signo, Sigfunc *func)
{
	struct sigaction act, oact;
	act.sa_handler = func;
	sigemptyset(&act.sa_mask);
	act.sa_flags = 0;
	if(signo == SIGALRM){
#ifdef    SA_INTERRUPT
		  act.sa_flags |= SA_INTERRUPT; //只有SIGALRM不重启被中断的系统调用,是为了使用系统调用定时器功能
#endif
	} else {
		  act.sa_flags |= SA_RESTART; //表示如果信号处理函数中断了某个系统调用,系统调用将自动重启
	}

	if(sigaction(signo, &act, &oact) < 0)
		return SIG_ERR;

	return(oact.sa_handler);
}

int main(int argc, char const *argv[])
{
	my_signal(SIGINT, sig_handler);
	sleep(10);
	return 0;
}

mysigaction2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

typedef void Sigfunc(int);//定义一个新类型Sigfunc,表示没有返回值，参数是int的函数

static void sig_handler(int signo)
{
	printf("got a sig_int\n");
}

static Sigfunc *signal_intr(int signo, Sigfunc *func)
{
	struct sigaction act, oact;
	act.sa_handler = func;
	sigemptyset(&act.sa_mask);
	act.sa_flags = 0;
	if(signo == SIGALRM){
#ifdef    SA_INTERRUPT
		  act.sa_flags |= SA_INTERRUPT; //只有SIGALRM不重启被中断的系统调用,是为了使用系统调用定时器功能
#endif
	} 
	if(sigaction(signo, &act, &oact) < 0)
		return SIG_ERR;

	return(oact.sa_handler);
}

int main(int argc, char const *argv[])
{
	my_signal(SIGINT, signal_intr);
	sleep(10);
	return 0;
}

mysigsetjmp.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

static sigjmp_buf jmpbuf;
static volatile sig_atomic_t canjump;

/* 查看当前信号屏蔽字 */
static void print_sigmask(const char* ptr)
{
	sigset_t sigset;
	int 	 errno_save;
	errno_save = errno;
	printf("%s\n", ptr);
	if(sigprocmask(0, NULL, &sigset) < 0){
		perror("sigprocmask error");
		return;
	}else {
		printf("block signal:\n");
		if(sigismember(&sigset, SIGUSR1))
			printf("\tSIGUSER1\n");
		if(sigismember(&sigset, SIGALRM))
			printf("\tSIGALRM\n");
	}
	errno = errno_save;//恢复errno值
}

static void sig_alrm(int signo)
{
	print_sigmask("in sig_alrm");
}

static void sig_usr1(int signo)
{
	time_t starttime;
	if(canjump == 0)
		return;

	print_sigmask("starting sig_usr1:");
	alarm(3);

	starttime = time(NULL);
	for( ; ; )
		if(time(NULL) > starttime + 5)// 保证能让SIGALRM中断此信号处理函数
			break;
	print_sigmask("finishing sig_use1:");
	canjump = 0;
	siglongjmp(jmpbuf, 1);
}

int main(int argc, char const *argv[])
{
	printf("pid:%d\n", getpid());
	if(signal(SIGUSR1, sig_usr1) == SIG_ERR){
		perror("signal sig_usr1 error");
		return -1;
	}

	if(signal(SIGALRM, sig_alrm) == SIG_ERR){
		perror("signal sig_alrm error");
		return -1;
	}

	print_sigmask("starting main:");
	if(sigsetjmp(jmpbuf, 1)){
		print_sigmask("end main:");
		return -1;
	}
	canjump = 1;

	for( ; ; )
		pause();

	return 0;
}

mysigsuspend1.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

static void print_sigmask(const char *ptr)
{
	sigset_t sigset;
	int 	 errno_save;
	errno_save = errno;
	printf("%s\n", ptr);
	if(sigprocmask(0, NULL, &sigset) < 0){
		perror("sigprocmask error");
		return;
	}else {
		if(sigismember(&sigset, SIGINT))
			printf("\tSIGINT\n");
		if(sigismember(&sigset, SIGQUIT))
			printf("\tSIGQUIT\n");
		if(sigismember(&sigset, SIGUSR1))
			printf("\tSIGUSER1\n");
		if(sigismember(&sigset, SIGALRM))
			printf("\tSIGALRM\n");
	}
	errno = errno_save;//恢复errno值
}

static void sig_int(int signo)
{
	print_sigmask("in sig_int:");
}


int main(int argc, char const *argv[])
{
	sigset_t newmask, oldmask, waitmask;
	print_sigmask("main start:");

	if(signal(SIGINT, sig_int) == SIG_ERR){
		perror("signal SIGINT error");
		return -1;
	}

	sigemptyset(&waitmask);
	sigaddset(&waitmask, SIGUSR1);
	sigemptyset(&newmask);
	sigaddset(&newmask, SIGINT);

	// 设置新的信号屏蔽字(屏蔽SIGINT),保留原始信号屏蔽字到oldmask中
	if(sigprocmask(SIG_BLOCK, &newmask, &oldmask) < 0){
		perror("sigprocmask error");
		return -1;
	}

	// 这里是不希望被SIGINT信号中断的代码临界区

	print_sigmask("in critical region:");

	// sigsuspend函数挂起进程,并且设置挂起阶段的新的信号屏蔽字(只屏蔽SIGUSR1)
	if(sigsuspend(&waitmask) != -1){
		perror("sigsuspend error");
		return -1;
	}
	print_sigmask("return form sigsuspend:");

	// 恢复原先的信号屏蔽字
	if(sigprocmask(SIG_SETMASK, &oldmask, NULL) < 0){
		perror("sigprocmask error");
		return -1;
	}

	print_sigmask("over:");
	return 0;
}

mysigsuspend2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

volatile sig_atomic_t quitflag;

static void sig_int(int signo)
{
	if(signo == SIGINT)
		printf("interrupt\n");
	else if(signo == SIGQUIT){
		printf("sigquit\n");
		quitflag = 1;
	}
}

int main(int argc, char const *argv[])
{
	sigset_t newmask, oldmask, zeromask;
	if(signal(SIGINT, sig_int) == SIG_ERR){
		perror("signal error");
		return -1;
	}

	if(signal(SIGQUIT, sig_int) == SIG_ERR){
		perror("signal error");
		return -1;
	}

	sigemptyset(&zeromask);
	sigemptyset(&newmask);
	sigemptyset(&oldmask);

	sigaddset(&newmask, SIGQUIT);

	// 当前进程阻塞SIGQUIT信号
	if(sigprocmask(SIG_BLOCK, &newmask, &oldmask) < 0){
		perror("sigprocmask error");
		return -1;
	}

	while(quitflag == 0)
		sigsuspend(&zeromask);// 函数里不阻塞任何信号

	quitflag = 0;

	if(sigprocmask(SIG_SETMASK, &oldmask, NULL) < 0){
		perror("sigprocmask error");
		return -1;
	}

	return 0;
}

myabort.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

static void myabort(void)
{
	sigset_t mask;
	struct sigaction action;

	/* SIGABRT不应该被忽略,而应该使用默认处理方式 */
	sigaction(SIGABRT, NULL, &action);// 获得SIGABRT信号的处理信息
	if(action.sa_handler == SIG_IGN){
		action.sa_handler = SIG_DFL;
		sigaction(SIGABRT, &action, NULL);
	}

	if(action.sa_handler == SIG_DFL)
		fflush(NULL);
	/* 进程不应该阻塞SIGABRT信号 */
	sigfillset(&mask);
	sigdelset(&mask, SIGABRT);
	sigprocmask(SIG_SETMASK, &mask, NULL);
	kill(getpid(), SIGABRT);
	
	//到这里表示SIGABRT被捕获且返回,下面会再次唤起SIGABRT信号
	fflush(NULL);
	action.sa_handler = SIG_DFL;
	sigaction(SIGABRT, &action, NULL);
	sigprocmask(SIG_SETMASK, &mask, NULL);
	kill(getpid(), SIGABRT);//终止进程

	exit(1);// 程序不应该走到这里
}


int main(int argc, char const *argv[])
{
	printf("main\n");
	myabort();
	printf("mian over\n");
	return 0;
}

mysystemed.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

static void sig_int(int signo)
{
	printf("In SIGINT\n");
}

static void sig_chld(int signo)
{
	printf("In SIGCHLD\n");
}

int main(int argc, char const *argv[])
{
	if(signal(SIGINT, sig_int) == SIG_ERR){
		perror("signal SIGINT error");
		return -1;
	}

	if(signal(SIGCHLD, sig_chld) == SIG_ERR){
		perror("signal SIGCHLD error");
		return -1;
	}

	if(system("/bin/ed") < 0){
		perror("system error");
		return -1;
	}
	return 0;
}

mysystem.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

static int mysystem(const char *cmdstr)
{
	pid_t 				pid;
	int 				status;
	struct  sigaction	ignore, saveint, savequit;
	sigset_t			chldmask, savemask;

	if(cmdstr == NULL)
		return 1;

	/* 忽略SIGINT和SIGQUIT信号 */
	ignore.sa_handler = SIG_IGN;
	sigemptyset(&ignore.sa_mask);
	ignore.sa_flags = 0;
	if(sigaction(SIGINT, &ignore, &saveint) < 0){
		perror("sigaction SIGINT error");
		return -1;
	}
	if(sigaction(SIGQUIT, &ignore, &savequit) < 0){
		perror("sigaction SIGQUIT error");
		return -1;
	}

	/* 进程阻塞SIGCHLD信号 */
	sigemptyset(&chldmask);
	sigaddset(&chldmask, SIGCHLD);
	if(sigprocmask(SIG_BLOCK, &chldmask, &savemask) < 0){
		perror("sigprocmask error");
		return -1;
	}

	if((pid = fork()) < 0){
		status = -1;
	}else if(pid == 0){
		/* 子进程在执行新程序前恢复SIGINT和SIGQUIT的处理方式以及进程的信号集(这些会被execl执行的新进程继承) */
		sigaction(SIGINT, &saveint, NULL);
		sigaction(SIGQUIT, &savequit, NULL);
		sigprocmask(SIG_SETMASK, &savemask, NULL);

		execl("/bin/sh", "sh", "-c", cmdstr, (char*)0);
		_exit(127);
	}else{
		while(waitpid(pid, &status, 0) < 0)// 防止产生僵尸进程
			if(errno != EINTR){
				status = -1;
				break;
			}
	}

	/* mysystem返回前恢复父进程的SIGINT和SIGQUIT的处理方式以及进程的信号集 */
	sigaction(SIGINT, &saveint, NULL);
	sigaction(SIGQUIT, &savequit, NULL);
	sigprocmask(SIG_SETMASK, &savemask, NULL);
	return status;
}

static void sig_int(int signo)
{
	printf("In SIGINT\n");
}

static void sig_chld(int signo)
{
	printf("In SIGQUIT\n");
}

int main(int argc, char const *argv[])
{
	if(signal(SIGINT, sig_int) == SIG_ERR){
		perror("signal SIGINT error");
		return -1;
	}

	if(signal(SIGCHLD, sig_chld) == SIG_ERR){
		perror("signal SIGCHLD error");
		return -1;
	}

	if(mysystem("/bin/ed") < 0){
		perror("system error");
		return -1;
	}
	return 0;
}

mysigsleep.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

static void sig_alrm(int signo)
{
	;// 仅仅是为了唤起sigsuspend函数
}

static void sig_int(int signo)
{
	;// 测试使用SIGINT去中断sigsuspend函数
}

static unsigned int mysleep(unsigned int seconds)
{
	struct sigaction newact, oldact;
	sigset_t 		 newmask, oldmask, susmask;
	unsigned int 	 unslept;

	signal(SIGINT, sig_int);
	// 设置SIGALRM处理函数,保存旧处理方式
	newact.sa_handler = sig_alrm;
	sigemptyset(&newact.sa_mask);// sa_mask也是进程mask,但是它的作用时间是在调用该信号捕捉函数之前,捕捉函数返回之后进程mask恢复原值
	newact.sa_flags = 0;
	sigaction(SIGALRM, &newact, &oldact);	

	// 设置进程mask,阻塞SIGALRM信号,保存当前进程mask
	sigemptyset(&newmask);
	sigaddset(&newmask, SIGALRM);
	sigprocmask(SIG_BLOCK, &newmask, &oldmask);
	// 程序至此,进程虽然有SIGALRM信号的处理函数,但是进程mask却阻塞了此信号

	alarm(seconds);
	susmask = oldmask;

	// 确保SIGALRM不被阻塞
	sigdelset(&susmask, SIGALRM);

	// 进程挂起直到被某个信号唤起
	sigsuspend(&susmask);
	// 某个信号到来唤起进程,最好是SIGALRM,如果是就表示计时时间到

	unslept = alarm(0);// 取消定时器
	// unslept = 0 表示sigsuspend函数被SIGALRM唤起,计时跑完
	// unslept > 0 表示sigsuspend函数被其它信号唤起,计时未跑完,返回剩余时间

	// 恢复之前的SIGALRM处理函数和进程mask
	sigaction(SIGALRM, &oldact, NULL);
	sigprocmask(SIG_SETMASK, &oldmask, NULL);
	printf("unslept:%d\n", unslept);
	return unslept;
}

int main(int argc, char const *argv[])
{	
	mysleep(5);
	return 0;
}

mykill.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

static void isChildExisted(pid_t pid) {
	struct timeval timebuf;
	struct tm* ptm;
	char buf[64];

	gettimeofday(&timebuf, NULL);
	if ((ptm = localtime(&timebuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
	if (strftime(buf, 64, "%c", ptm) == 0)
		err_sys("strftime error\n");
	printf("Now time is %s\n", buf);

	if (kill(pid, 0) == -1) {
		if (errno == ESRCH)
			printf("child(pid: %d) is not exited\n",
				pid);
	}
	else {
		printf("child(pid: %d) is exited\n", pid);
	}
}

int main(void)
{
	pid_t pid;

	if ((pid = fork()) < 0)
		err_sys("fork error\n");
	else if (pid == 0) {
		sleep(2);
	}
	else {
		isChildExisted(pid);
		if (waitpid(pid, NULL, 0) != pid)
			err_sys("waitpid error\n");
		isChildExisted(pid);
	}

	exit(EXIT_SUCCESS);
}

mySleep.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define BufSize 64

static void alarm_handler(int sig){}

unsigned int mySleep(unsigned int seconds) {
	if (signal(SIGALRM, alarm_handler) == SIG_ERR)
		return seconds;
	alarm(seconds);
	pause();
	return alarm(0);
}

void print_now(void) {
	struct timeval timevalbuf;
	struct tm* ptm;
	char buf[BufSize];

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
	if (strftime(buf, BufSize, "%Y-%m-%d %H:%M:%S", ptm) == 0)
		err_sys("strftime error\n");
	printf("now time is %s\n", buf);
}

int main(int argc,char*argv[])
{
	if(argc!=2)
		err_sys("usage:sleep <seconds>\n");

	print_now();
	mySleep(atoi(argv[1]));
	print_now();
	return 0;
}

mySleep2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

static jmp_buf env_alrm;

static void sig_alrm(int sig) {
	longjmp(env_alrm, 1);
}

static void sig_int(int sig) {
	volatile int k;

	printf("\nsig_int start...\n");
	for (int i = 0; i < 300000; i++)
		for (int j = 0; j < 4000; j++)
			k += i * j;
	printf("sig_int finished\n");
}

unsigned int mySleep2(unsigned int seconds) {
	void (*po)(int);

	if ((po = signal(SIGALRM, sig_alrm)) == SIG_ERR)
		err_sys("signal error\n");
	if (setjmp(env_alrm) == 0) {
		alarm(seconds);
		pause();
	}

	if (signal(SIGALRM, po) == SIG_ERR)
		err_sys("signal error\n");
	return alarm(0);
}

int main(void)
{
	unsigned int unslept;

	if (signal(SIGINT, sig_int) == SIG_ERR)
		err_sys("signal error\n");
	unslept = mySleep2(2);
	printf("mySleep returned: %d\n", unslept);
	exit(0);
}

myAbort.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

static void abort_sig(int sig) {
	if (sig == SIGABRT)
		printf("received SIGABRT\n");
}

int main(void)
{
	if (signal(SIGABRT, abort_sig) == SIG_ERR)
		err_sys("signal error\n");
	abort();
	printf("after abort\n");
	exit(EXIT_SUCCESS);
}

mynanosleep.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define BufSize 64

void print_now(void) {
	struct timeval timevalbuf;
	struct tm* ptm;
	char buf[BufSize];

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
	if (strftime(buf, BufSize, "%Y-%m-%d %H:%M:%S", ptm) == 0)
		err_sys("strftime error\n");
	printf("now time is %s\n", buf);
}

static unsigned int hrsleep(unsigned int seconds) {
	struct timespec passtime, endtime;

	passtime.tv_sec = seconds;
	passtime.tv_nsec = 0;
	if (nanosleep(&passtime, &endtime) != 0)
		fputs("nanosleeep doesn't pass the time of request\n",
			stderr);
	return endtime.tv_sec;
}

int main(int argc, char* argv[])
{
	if (argc != 2)
		err_sys("usage:hrsleep <seconds>\n");

	print_now();
	hrsleep(atoi(argv[1]));
	print_now();
	exit(EXIT_SUCCESS);
}

线程
1.线程概念

    一个进程中的所有线程都可以访问该进程的资源，如文件描述符、内存等等。

    典型的UNIX进程可以看成只有一个控制线程：一个进程在某个时刻只能做一件事情。有了多线程之后，程序设计就可以把进程设计成：在某个时刻能做不止一件事情，每个线程处理各自独立的任务。优点：
        通过为每种事件类型分配单独的处理线程，可以简化处理异步事件的代码
            每个线程在进行事件处理时可以采取同步编程模式（同步编程模式要比异步编程模式简单得多）
        多个进程必须使用操作系统提供的复杂机制才能实现内存共享和文件描述符的共享。而多线程能自动地访问相同的存储空间和文件描述符
        有些问题可以分解从而提高整个程序的吞吐量
            多线程中，相互独立的任务的处理可以交叉进行
        交互式程序可以通过多线程改善响应时间
            多线程可以把程序中处理用户的输入输出部分与其他部分分开

    多线程不等于多核编程。即使在单核处理器上，也能够使用多线程。

    对于多线程任务，如果某个线程阻塞了，那么其他的线程也可以执行，而不会像单线程那样阻塞整个进程。

    每个线程都包含有表示执行环境所必须的所有信息，包括：进程中标识线程的线程ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、errno变量、以及线程私有数据
        进程的所有信息对该进程的所有线程是共享的，包括：可执行程序的代码、程序的全局内存和堆内存、栈、以及文件描述符

    这里讨论的线程接口来自POSIX。线程接口也称作pthread，其功能测试宏是_POSIX_THREADS
        应用程序可以用 #ifdef _POSIX_THREADS 测试，从而在编译时确定是否支持线程
        应用程序也可以用_SC_THREADS常数调用sysconf函数，从而在运行时确定是否支持线程

2. 线程标识、创建、终止

    每个线程都有一个线程ID。线程ID只有在它所属的进程中才有意义。
        比较两个进程中的线程ID没有任何意义

    线程ID类型为pthread_t，实现的时候可以用一个struct来代表它，通常都不把它看作整数来处理。因此如果要判断两个线程ID是否相等，不能直接用==

    pthread_equal函数：判断两个线程ID是否相等

    #include<pthread.h>
    int pthread_equal(pthread_t tid1,pthread tid2);

        参数：
            tid1：第一个线程ID
            tid2：第二个线程ID
        返回值：
            相等：返回非0数值
            不等：返回 0

    对于Linux，使用的是无符号长整型来表示pthread_t；MacOSX采用一个指向pthread结构的指针来表示pthread_t数据类型

    pthread_self(void)函数：返回本线程自身的线程ID

    #include<pthread.h>
    pthread_t pthread_self(void);

        返回值：调用线程的线程ID

    在POSIX线程的情况下，程序开始运行时，它也是以单进程中的单个控制线程启动的。在创建多个控制线程之前，程序的行为与传统的进程并没有区别。

    pthread_create函数：创建新线程

    #include<pthread.h>
    int pthread_create(pthread_t *restrict tidp,
    	const pthread_attr_t *restrict attr,
    	void *(*start_rtn)(void*),
    	void *restrict arg);

        参数：
            tidp：成功创建时，新线程的线程ID存放在tidp指向的内存单元
            attr：用于定制不同的线程属性。如果为NULL，则是默认属性
            start_rtn：线程例程地址。新创建的线程从start_rtn函数的地址处开始运行，该函数的参数为void *，返回值为void *
            arg：作为start_rtn函数的参数
        返回值：
            成功：返回 0
            失败：返回错误编号

    注意：
        如果需要向start_rtn函数传递一个以上的参数，那么可以将这些参数放置在一个结构中，然后将这个结构的地址作为arg参数传入。
        线程创建的时候，并不能保证哪个线程会先运行：有可能是新创建线程先运行，也可能是调用线程先运行
        新创建的线程可以访问进程的地址空间，并继承了调用线程的浮点环境和信号屏蔽字，但是该线程的挂起信号集会被清除

注意：链接时必须添加 pthread库，-lpthread

可以看到：
- 子线程的工作例程的返回值，由父线程通过pthread_join来捕获
- 如果子线程没有使用互斥量同步，则可以看到子线程的输出交叉进行，说明了子线程的运行是并行的，而且没有先后顺序

    pthread系列的函数在调用失败时通常会返回错误码，它并不像其他POSIX函数一样设置errno。
        每个线程都提供了errno的副本，这只是为了与使用errno的现有函数兼容
        在线程中，从函数中返回错误码更为清晰整洁，不需要依赖那些随着函数执行不断变化的全局状态

    单个线程可以通过三种方式退出

        可以在不终止整个进程的情况下，停止它的控制流

        线程可以简单的从启动例程中返回，返回值是线程的退出码
        线程可以被同一个进程中的其他线程取消
        线程可以自己调用phtread_exit函数来主动退出

    单个线程还有其它的退出方式，此时的行为是终止整个进程：
        如果进程中的任意线程调用了exit、_Exit、_exit之一，那么整个进程就会终止
        如果某个信号的默认动作是终止进程，那么发送到任意线程的这种信号就会终止整个进程

    pthread_exit函数：线程主动退出

    #include<pthread.h>
    void pthread_exit(void *rval_ptr);

        参数：
            rval_ptr：一个无类型指针，用于给pthread_join函数传递参数（即线程间消息传递）

    pthread_join函数：等待指定的线程结束（类似于waitpid）

    #include<pthread.h>
    int pthread_join(pthread_t tid,void **rval_pptr);

        参数：
            tid：要等待的线程的线程ID
            rval_pptr：一个指针，指向无类型指针（该无类型指针用于线程返回值）
        返回值：
            成功：返回 0
            失败：返回错误编号

    当调用线程调用pthread_join之后，调用线程将会一直阻塞，直到:
        指定的线程tid调用pthread_exit。此时rval_pptr指向的内存区就包含pthread_exit的rval_ptr的值
        指定的线程tid从启动例程返回。此时rval_pptr指向的内存区就包含返回码
        指定的线程tid被取消。此时rval_pptr指向的内存单元就设置为PTHREAD_CANCELED

    如果不关注线程的返回值，则可以将rval_pptr设置为NULL。此时pthread_join函数可以等待指定的线程终止，但是并不获取线程的终止状态。

    可以通过调用pthread_join自动把线程置于分离状态，此时资源可以恢复。如果线程已经处理分离状态，pthread_join调用就会失败，返回EINVAL

    pthread_cancel函数：请求取消同一个进程中的其他某个线程

    #include<pthread.h>
    int pthread_cancel(pthread_t tid);

        参数：
            tid：期望取消的线程的ID
        返回值：
            成功：返回 0
            失败：返回错误码

    默认情况下，pthread_cancel函数会使得由tid标识的线程的行为表现得如同调用了pthread_exit(PTHREAD_CANCELD)函数。但是，tid标识的线程可以选择忽略取消或者控制如何被取消。

        pthread_cancel并不等待线程tid终止，也不保证线程tid终止，它仅仅提出了请求

    线程可以安排它退出时需要调用的函数，这与进程在退出时可以使用atexit函数类似。这样的函数称作线程清理处理程序thread cleanup handler。
        一个线程可以建立多个清理处理程序
        处理程序记录在栈中。即它们的执行顺序与它们注册时相反

    pthread_clearnup_push/pthread_cleanup_pop函数：注册与注销清理处理程序

    #include<pthread.h>
    void pthread_cleanup_push(void (*rtn)(void*),void *arg);
    void pthread_cleanup_pop(int execute);

        对于 pthread_cleanup_push函数：
            rtn：清理处理程序的指针。rtn函数的参数是void *，返回void
            arg：作为清理处理程序rtn的参数
        对于pthread_cleanup_pop函数：
            execute：如果为0，则线程退出时，清理函数不被调用（哪个清理函数？见后面说明）
            execute：如果非零，则线程退出时，对应的清理函数被调用

    当线程退出时，清理函数rtn是由pthread_cleanup_push函数调度的，调用时只有一个参数arg。调用的顺序和它们注册的顺序是相反的。同时跳过 pthread_cleanup_pop设为0的那个清理处理程序。

    每一个pthread_cleanup_pop都匹配了在它之前且离他最近的那个pthread_cleanup_push。如果 pthread_cleanup_pop(0)，则对应的pthread_cleanup_push注册的清理处理程序就不会被执行。

    这两个函数有个限制：由于它们可以实现为宏，因此必须在于线程相同的作用域中以配对的形式使用。（否则程序编译不通过，在Ubuntu 16.04上测试是这样的）

        实际上，每次遇到pthread_cleanup_pop，如果参数非零，则调用清理函数

    默认的情况下，线程的终止状态会保存直到其他某个线程对它调用了pthread_join。如果线程已经被分离，则线程的底层存储资源可以在线程终止时立即被收回。
        在线程被分离后，我们不能用pthread_join函数等待它的终止状态。
        我们可以调用pthread_detach将指定线程设置为分离状态

    pthread_detach函数：将指定线程设置为分离状态

    #include<pthread.h>
    int pthread_detach(pthread_t tid);

        参数：
            tid：被分离的线程的ID
        返回值：
            成功：返回 0
            失败：返回错误码

一旦对子线程调用了pthread_detach，就无法对子线程调用pthread_join了

任何子线程无法等待主线程的结束。因为一旦主线程从main函数返回，则整个进程结束，则子线程的pthread_join也就没有返回了（子线程阻塞，还没来得及被唤醒，进程就结束了）

另外可以验证：任何子线程可以取消主线程。此时一旦取消主线程，则进程立即结束。

3. 线程同步

    当多个线程共享相同的内存时，必须确保每个线程看到一致的数据视图。
        如果每个线程使用的变量都是其他线程不会读取和修改的，则不会存在数据一致性问题
        如果变量是只读的，多个线程同时读取改变了也不会有数据一致性问题
        若一个线程可以修改的变量，其他线程也可以读取或者修改的时候，我们就需要对这些线程进行同步，确保他们在访问变量的存储内容时不会访问到无效的值

            当一个线程修改变量时，其他线程在读取这个变量时可能会看到一个不一致的值。当变量修改的时间多于一个存储器反问周期的处理器结构中，当存储器读和存储器写这两个周期交叉时，这种不一致就会出现。这就是由于计算机体系结构引起的不一致。

    除了计算机体系结构外，程序使用变量的方式也会引起竞争。如加1然后判断是否大于0。在加1和判断之间的组合并非原子操作，这就为不一致的出现提供了可能。

    为了解决数据不一致的问题，线程不得不在访问数据前加锁并在访问结束后解锁，使得同一时间只允许一个线程访问被锁住的变数据。

3.1 互斥量

    可以使用pthread的互斥接口来保护数据，确保同一时刻只有一个线程访问数据

        互斥量mutex 本质上是一把锁，在访问共享资源前对互斥量进行设置（加锁），在访问完成后释放互斥量（解锁）

        任何其他试图再次对互斥量进行加锁的线程都会被阻塞，直到当前线程解锁该互斥量

        如果解锁互斥量时有一个以上的线程阻塞，那么等待锁住该互斥量的阻塞线程都变成可运行状态
            第一个变成运行状态的线程就可以对互斥量进行加锁
            其他线程看到互斥量仍然是锁住的，只能回去再次等待它重新变为可用

        因此，每次只有一个线程是可以向前执行的

    只有将所有线程都设计成遵守使用互斥量进行访问，互斥机制才能正常工作。操作系统并不会帮我们完成这个工作，必须程序员手动编写互斥量加锁和解锁流程。
        如果你允许其中的某个线程在没有获得互斥量加锁的情况下也可以访问共享资源，那么即使其他线程在使用共享资源之前都对互斥量加锁，也还是会出现不一致的情形

    互斥量是用pthread_mutex_t数据类型表示。
        使用互斥量之前必须初始化。
            如果是动态分配的互斥量（如通过malloc函数），则必须调用pthread_mutex_init函数进行初始化
            如果是静态分配的互斥量，那么除了调用pthread_mutex_init函数来初始化，也可以将它设置为常量PTHREAD_MUTEX_INITALIZER来初始化
        如果是动态分配的互斥量，那么在free释放内存之前必须调用pthread_mutex_destroy函数来销毁互斥量。该函数会释放在动态初始化互斥量时动态分配的资源

    涉及的函数为：

    #include<pthread.h>
    int pthread_mutex_init(pthread_mutex_t *restrict mutex,
    	const pthread_mutexattr_t *restrict attr);
    int pthread_mutex_destroy(pthread_mutex_t *mutex);

        参数：
            mutex：待初始化/释放的互斥量的地址
            attr：互斥量的属性。如果为NULL，那么互斥量设置为默认属性
        返回值：
            成功：返回0
            失败： 返回错误编号

    pthread_mutex_lock/pthread_mutex_trylock/pthread_mutex_unlock函数：对互斥量加锁/解锁操作

    #include<pthread.h>
    int pthread_mutex_lock(pthread_mutex_t *mutex);
    int pthread_mutex_trylock(pthread_mutex_t *mutex);
    int pthread_mutex_unlock(pthread_mutex_t *mutex);

        参数：
            mutex：待加锁/解锁的互斥量的地址
        返回值：
            成功：返回0
            失败： 返回错误编号

    用法：
        pthread_mutex_lock用于对互斥量进行加锁。如果互斥量已经上锁，则调用线程将阻塞直到互斥量解锁
        pthread_mutex_unlock用于对互斥量进行解锁
        pthread_mutex_trylock也用于对互斥量进行加锁
            如果它被调用时，互斥量处于未锁定状态，那么函数将锁住互斥量并返回0
            如果它被调用时，互斥量处于锁定状态，则函数调用失败，立即返回EBUSY而不是阻塞

    有两种情况可能导致死锁：
        如果线程试图对同一个互斥量加锁两次，则它自身就会陷入死锁状态
        如果程序中使用了两个互斥量 Mutex1,Mutex2；线程A锁住了 Mutex1并请求锁住 Mutex2；线程B锁住了 Mutex2并请求锁住 Mutex1，所以这两个线程都无法向前进行，导致死锁

    一般可以通过仔细控制互斥量加锁的顺序来避免死锁的发生。假设要同时对互斥量 M1,M2,M3同时加锁。如果所有线程总是在对互斥量M2锁住之前先锁住互斥量M1，在对互斥量M3锁住之前先锁住互斥量M2，那么就不会发生死锁

    还有一种办法是使用pthread_mutex_trylock接口并执行多次测试。一旦多次试图锁住互斥量都失败，则立即释放自己锁定的互斥量。

    pthread_mutex_timedlock函数：对互斥量加锁或等待指定时间

    #include<pthread.h>
    #include<time.h>
    int pthread_mutex_timedlock(pthread_mutex_t *restrict mutex,
    	const struct timespec *restrict tsptr);

        参数：
            mutex：待加锁的互斥量的地址
            tsptr：指向一个timespec的指针，该timepsec指定了一个绝对时间（并不是相对时间，比如10秒）
        返回值：
            成功：返回0
            失败： 返回错误编号

    pthread_mutex_timedlock被调用时：
        如果互斥量处于未锁定状态，那么函数将锁住互斥量并返回0
        如果互斥量处于锁定状态，那么函数将阻塞到tsptr指定的时刻。在到达超时时刻时，pthread_mutex_timedlock不再试图对互斥量进行加锁，而是返回错误码ETIMEOUT

        可以使用clock_gettime函数获取timespec结构表示的当前时间。但是目前并不是所有平台都支持这个函数。因此也可以用gettimeofday函数获取timeval结构表示的当前时间，然后将这个时间转换为timespec结构。

注意：
- 使用pthread_mutex_trylock时，如果不能加锁则直接返回EBUSY；使用pthread_mutex_timedlock时，如果超时则直接返回ETIMEOUT
- 对于线程持有的锁，可以解锁多次。也就是当线程不再持有锁时，也可以调用pthread_mutex_unlock而不报错
- 如果线程已经持有了锁，再次调用pthread_mutex_lock，则线程彻底死锁。

3.2 读写锁

    读写锁与互斥量类似，不过读写锁允许更高的并行性

        互斥量要么是锁住状态，要么是不加锁状态。而且一次只有一个线程可以对其进行加锁

        读写锁可以有三种状态：
            读模式下加锁状态（读锁定）
            写模式下加锁状态（写锁定）
            不加锁状态（未锁定）

        一次只能有一个线程可以对读写锁加写锁，但是允许多个线程同时对读写锁加读锁
        当读写锁是写锁定状态时，在该锁被解锁之前，所有试图对这个锁加锁（无论是加读锁还是价写锁）的线程都会被阻塞
        当读写锁是读锁定状态时，所有试图对它加读锁的线程都可以获得访问权，但是所有试图对它加写锁的线程都会被阻塞

    通常如果读写锁处于读锁定的状态，此时有一个线程试图对这个读写锁加写锁时，读写锁会阻塞该加写锁请求之后任何线程的所有加读锁请求。因为如果不阻塞之后的所有加读锁请求，那么当后续不断有加读锁请求到来时，该锁始终处于读锁定的状态，那么那个加写锁请求将永远得不到满足

    读写锁非常适合对于数据结构读的次数远大于写的情况。读写锁也叫共享互斥锁
        当读写锁是读锁定时，称它以共享模式锁住的
        当读写锁是写锁定时，称它以互斥模式锁住的

    读写锁是用pthread_rwlock_t数据类型表示。
        使用读写锁之前必须初始化。
            如果是动态分配的读写锁（如通过malloc函数），则必须调用pthread_rwlock_init函数进行初始化
            如果是静态分配的读写锁，那么除了调用pthread_rwlock_init函数来初始化，也可以将它设置为常量PTHREAD_RWLOCK_INITALIZER来初始化
        如果是动态分配的读写锁，那么在free释放内存之前必须调用pthread_rwlock_destroy函数来销毁读写锁。该函数会释放在动态初始化读写锁时动态分配的资源

    涉及的函数为：

    #include<pthread.h>
    int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,
    	const pthread_rwlockattr_t *restrict attr);
    int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);

        参数：
            rwlock：待初始化/销毁的读写锁的地址
            attr：读写锁的属性。如果为NULL，那么读写锁设置为默认属性
        返回值：
            成功：返回0
            失败： 返回错误编号

    pthread_rwlock_rdlock/pthread_rwlock_wrlock/pthread_rwlock_unlock函数：对读写锁加锁/解锁操作

    #include<pthread.h>
    int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
    int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
    int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);

        参数：
            rwlock：待加锁/解锁的读写锁的地址
        返回值：
            成功：返回0
            失败： 返回错误编号

    用法：
        pthread_rwlock_rdlock用于对读写锁加读锁。如果读写锁当前是未加锁的，或者是读锁定的，则加锁成功；如果读写锁当前是写锁定的，则阻塞线程。
        pthread_rwlock_wrlock用于对读写锁加写锁。如果读写锁当前是未加锁的，则加锁成功；如果读写锁当前是读锁定或者写锁定的，则阻塞线程。
        pthread_rwlock_unlock用于对读写锁进行解锁，无论读写锁当前状态是处于读锁定还是写锁定。

    注意：有的实现对读写锁同时加读锁的数量有限制。并不是无限制的加读锁。

    pthread_rwlock_tryrdlock/pthread_rwlock_trywrlock函数：对读写锁加锁的条件版本

    #include<pthread.h>
    int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);
    int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);

        参数：
            rwlock：待加锁的读写锁的地址
        返回值：
            成功：返回0
            失败： 返回错误编号

    当可以加锁时，这两个函数返回0。否则它们返回错误EBUSY而不是阻塞线程。

    pthread_rwlock_timedrdlock/pthread_rwlock_timedwrlock函数：对读写锁加锁的超时版本

    #include<pthread.h>
    #include<time.h>
    int pthread_rwlock_timedrdlock(pthread_rwlock_t *rwlock,
    	const struct timespect*restrict tsptr);
    int pthread_rwlock_timedwrlock(pthread_rwlock_t *rwlock,
    	const struct timespect*restrict tsptr);

        参数：
            rwlock：待加锁的读写锁的地址
            tsptr：指向一个timespec的指针，该timepsec指定了一个绝对时间（并不是相对时间，比如10秒）
        返回值：
            成功：返回0
            失败： 返回错误编号

    这两个函数被调用时：
        如果允许加锁，那么函数将对读写锁加锁并返回0
        如果不允许加锁，那么函数将阻塞到tsptr指定的时刻。在到达超时时刻时，pthread_mutex_timedlock不再试图对读写锁进行加锁，而是返回错误码ETIMEOUT

        可以使用clock_gettime函数获取timespec结构表示的当前时间。但是目前并不是所有平台都支持这个函数。因此也可以用gettimeofday函数获取timeval结构表示的当前时间，然后将这个时间转换为timespec结构。

3.3 条件变量

    条件变量是不同于锁的另一种同步机制。条件变量给多个线程提供了一个会合的场所。条件变量实际应用中，它映射到某个数据的真假，如判断缓冲区的长度不为零：buffer_len!=0
        条件变量与互斥量一起使用时，允许线程以无竞争的方式等待指定的条件发生

        这里的“指定的条件“表示的是：数据变量为真，如buffer_len!=0

    条件本身是由互斥量来进行保护的：（即缓冲区buffer的访问需要互斥量保护）
        线程在改变条件的状态之前必须首先锁住互斥量，如要修改buffer或者buffer_len
        其他线程在获得互斥量之前不会察觉这种改变，因为必须首先锁定互斥量之后才能计算buffer_len

    条件变量是用pthread_cond_t数据类型表示。
        使用条件变量之前必须初始化。
            如果是动态分配的条件变量（如通过malloc函数），则必须调用pthread_cond_init函数进行初始化
            如果是静态分配的条件变量，那么除了调用pthread_cond_init函数来初始化，也可以将它设置为常量PTHREAD_COND_INITALIZER来初始化
        如果是动态分配的条件变量，那么在free释放内存之前必须调用pthread_cond_destroy函数来销毁条件变量。该函数会释放在动态初始化条件变量时动态分配的资源

    涉及的函数为：

    #include<pthread.h>
    int pthread_cond_init(pthread_cond_t *restrict cond,
    	const pthread_condattr_t *restrict attr);
    int pthread_cond_destroy(pthread_cond_t *cond);

        参数：
            cond：待初始化/销毁的条件变量的地址
            attr：条件变量的属性。如果为NULL，那么条件变量设置为默认属性
        返回值：
            成功：返回0
            失败： 返回错误编号

    pthread_cond_wait/pthread_cond_timedwait函数：等待条件成立

    #include<pthread.h>
    #include<time.h>
    int pthread_cond_wait(pthread_cond_t *restrict cond,
    	pthread_mutext_t *restrict mutex);
    int pthread_cond_timedwait(pthread_cond_t *restrict cond,
    	pthread_mutext_t *restrict mutex,
    	const struct timespect*restrict tsptr);

        参数：
            cond：要等待的条件变量的地址
            mutex：与条件变量配套的互斥量的地址
            tsptr：指向一个timespec的指针，该timepsec指定了一个绝对时间（并不是相对时间，比如10秒）
        返回值：
            成功：返回0
            失败： 返回错误编号

    pthread_cond_wait等待指定指定的条件成立；如果指定的条件不成立，则线程阻塞。pthread_cond_timedwait会指定一个超时时刻。如果在超时时刻到来时，指定条件仍然不满足，则函数返回错误码ETIMEOUT

    互斥量mutex用于对条件变量cond进行保护。调用者在调用pthread_cond_wait/pthread_cond_timedwait函数之前，必须首先对mutex加锁（即mutex此时必须是处于已锁定状态）。
        pthread_cond_wait/pthread_cond_timedwait会计算指定的条件是否成立，如果不成立则会自动把调用线程放到等待条件的线程列表中并阻塞线程，然后对互斥量mutex进行解锁。

        之所以mutex必须是已锁定状态，就是因为这里有“计算条件然后如果不满足条件就把进程投入休眠”的操作。这两步并不是原子的，所以需要利用条件变量保护起来

        当从pthread_cond_wait/pthread_cond_timedwait函数返回时，返回之前互斥量mutex再次被锁住

    pthread_cond_timedwait被调用时：
        如果指定条件成立，那么函数返回0
        如果指定条件不成立，那么函数将阻塞到tsptr指定的时刻。在到达超时时刻时，pthread_mutex_timedlock返回错误码ETIMEOUT

        可以使用clock_gettime函数获取timespec结构表示的当前时间。但是目前并不是所有平台都支持这个函数。因此也可以用gettimeofday函数获取timeval结构表示的当前时间，然后将这个时间转换为timespec结构。

    pthread_cond_signal/pthread_cond_broadcast函数：通知所有线程，某个条件成立

    #include<pthread.h>
    int pthread_cond_signal(pthread_cond_t *cond);
    int pthread_cond_broadcast(pthread_cond_t *cond);

        参数：
            cond：该指针指向的条件变量状态变为：条件成立
        返回值：
            成功：返回0
            失败： 返回错误编号

    pthread_cond_signal函数能够唤醒一个等待cond条件发生的线程；而pthread_cond_broadcast函数能够唤醒等待cond条件发生的所有线程

        在调用pthread_cond_signal/pthread_cond_broadcast函数时，我们说这是在给线程或者条件发信号。

    条件变量通常用于通知其它线程：某个条件成立。条件变量本身只是一个标记，真正发生改变的是某个真实等待同步的数据。如：
        线程A负责从网络接口读取网络数据，然后存入缓冲区中
        线程B负责GUI，并且当用户点击某个按钮时，打印缓冲区中的网络数据

    这种情况必须用多线程。如果是单线程，则当线程A读取网络数据时，可能发生阻塞。此时导致用户界面失去响应，用户体验极差。一旦使用多线程时，则必须有某种通信机制，使得当线程B打印网络数据时，确保缓冲区中有数据。所以典型的流程是：
        线程B等待条件变量cond的发生，然后投入睡眠
        线程A读取网络数据，一旦读取成功，则通知线程B，cond条件成立
        线程B被唤醒，继续执行打印网络数据的工作

    这里真实的条件是：缓冲区中有了有效的数据！而cond条件变量只是真实条件的一个标记！

pthread_cond_signal调用时可以加锁，也可以不加锁
如果线程执行 pthread_cond_signal 时，线程持有锁，则仅当线程释放锁的时候，阻塞在pthread_cond_wait的线程才会被唤醒。因为pthread_cond_wait需要获得锁
如果线程执行 pthread_cond_signal 时，线程不持有锁，则阻塞在pthread_cond_wait的线程马上被唤醒

3.4 自旋锁

    自旋锁与互斥量类似，但是它并不是通过睡眠使得线程阻塞，而是在获得锁之前一直处于忙等（自旋）阻塞状态。此时CPU不能做其他的事情。

    自旋锁常用于以下情况：锁被持有时间很短，而且线程不希望在重新调度上花费太多的成本

    自旋锁通常作为底层原语用于实现其他类型的锁。

    自旋锁用于非抢占式内核中时非常有用。但是在用户层，自旋锁并不是非常有用（除了运行在不允许抢占的实时调度操作系统中）

    自旋锁的接口与互斥量的接口 类似，这使得它们之间可以方便的替换。

    自旋锁是用pthread_spinlock_t数据类型表示。
        使用自旋锁之前必须初始化。可以调用pthread_spin_init函数进行初始化
        在free释放内存之前必须调用pthread_spin_destroy函数来销毁自旋锁。该函数会释放在动态初始化自旋锁时动态分配的资源

    涉及的函数为：

    #include<pthread.h>
    int pthread_spin_init(pthread_spinlock_t *restrict lock,
    	int pshared);
    int pthread_spin_destroy(pthread_spinlock_t *lock);

        参数：
            lock：待初始化/释放的自旋锁的地址
            pshared：自旋锁的属性。可以为：
                PTHREAD_PROCESS_SHARED：表示自旋锁能够跨进程使用
                PTHREAD_PROCESS_PRIVATE：表示自旋锁只能在进程内部的线程中使用
        返回值：
            成功：返回0
            失败： 返回错误编号

    pthread_spin_lock/pthread_spin_trylock/pthread_spin_unlock函数：对自旋锁加锁/解锁操作

    #include<pthread.h>
    int pthread_spin_lock(pthread_spinlock_t *lock);
    int pthread_spin_trylock(pthread_spinlock_t *lock);
    int pthread_spin_unlock(pthread_spinlock_t *lock);

        参数：
            lock：待加锁/解锁的自旋锁的地址
        返回值：
            成功：返回0
            失败： 返回错误编号

    用法：
        pthread_spin_lock用于对自旋锁进行加锁。如果自旋锁已经上锁，则调用线程自旋
        pthread_spin_unlock用于对自旋锁进行解锁
        pthread_spin_trylock也用于对自旋锁进行加锁
            如果它被调用时，自旋锁处于未锁定状态，那么函数将锁住自旋锁并返回 0
            如果它被调用时，自旋锁处于锁定状态，则函数调用失败，立即返回EBUSY而不是自旋

    注意：
        同一个线程连续对自旋锁进行加锁，结构未定义。可能第二次加锁会返回EDEADLK错误或其他错误，也可能永久自旋
        试图对未加锁的自旋锁进行解锁，结果也未定义
        不要在持有自旋锁的情况下调用可能使线程休眠的函数。如果持有自旋锁的线程休眠，会浪费CPU资源，因为其他线程需要获取自旋锁要等待的时间就延长了

    对于线程持有的自旋锁，可以解锁多次。也就是当线程不再持有锁时，也可以调用pthread_spin_unlock而不报错
    如果线程已经持有了自旋锁，再次调用pthread_spin_lock，则线程彻底死锁。

3.5 屏障

    屏障barrier是用户协作多个线程并行工作的同步机制。屏障允许每个线程等待，直到所有的合作线程都到达某一点，然后从改点继续执行

    pthread_join函数就是一种屏障，它允许一个线程等待，直到另一个线程退出

    屏障是用pthread_barrier_t数据类型表示。
        使用屏障之前必须初始化。可以调用pthread_barrier_init函数进行初始化
        在free释放内存之前必须调用pthread_barrier_destroy函数来销毁屏障。该函数会释放在动态初始化屏障时动态分配的资源

    涉及的函数为：

    #include<pthread.h>
    int pthread_barrier_init(pthread_barrier_t *restrict barrier,
    	const pthread_barrierattr_t *restrict attr,
    	int count);
    int pthread_barrier_destroy(pthread_barrier_t *barrier);

        参数：
            barrier：待初始化/释放的屏障的地址
            attr：屏障的属性的地址。如果为NULL则采用默认属性
            count：在允许所有线程继续允许之前，必须到达屏障的线程的数量
        返回值：
            成功：返回0
            失败： 返回错误编号

    pthread_barrier_wait函数：线程到达屏障并等待其他线程也到达屏障

    #include<pthread.h>
    int pthread_barrier_wait(pthread_barrier_t * barrier);

        参数：
            barrier：到达的屏障的地址
        返回值：
            成功：返回0或者PTHREAD_BARRIER_SERIAL_THREAD
            失败： 返回错误编号

    线性调用pthread_barrier_wait函数来表明，线程已经到达屏障barrier，并等待其他线程赶上来。

    调用pthread_barrier_wait的线程在屏障计数未满足条件时（即：到达屏障的线程数量小于count），会进入休眠状态。
    如果线程调用pthread_barrier_wait后，刚好满足了屏障计数条件，则返回 PTHREAD_BARRIER_SERIAL_THREAD ，同时所有的等待线程都将被唤醒(同时这些线程上的pthread_barrier_wait 函数返回 0）。

    一旦到达屏障计数值，而且线程处于非阻塞状态，那么屏障就可以重用（即屏障计数有从零开始）。此时屏障的计数目标数量仍然不变。如果你希望改变计数的目标数量（比如扩大到达线程的目标数量），则必须再一次调用pthread_barrier_init函数。

- 所有线程到达pthread_barrier_wait函数处就投入睡眠，等待其他线程追上来
- 最后到达的一个线程，其 pthread_barrier_wait函数返回值为PTHREAD_BARRIER_SERIAL_THREAD（在UBUNTU 16.04上它就是 -1）
- 当所有线程都到达，从pthread_barrier_wait函数返回时，线程唤醒的顺序不确定

mythreadid.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

pthread_t ntid;// 保存新线程的id

static void printids(const char *str)
{
	pid_t     pid;
	pthread_t tid;
	pid = getpid();
	tid = pthread_self();
	printf("%s\n\tpid:%lu, tid:%lu(0x%lx)\n", str, (long unsigned int)pid, (long unsigned int)tid, (long unsigned int)tid);
}

static void * thr_fn(void *arg)
{
	printids("new pthread:");
	return((void *)0);
}

int main(int argc, char const *argv[])
{
	int err;
	err = pthread_create(&ntid, NULL, thr_fn, NULL);
	if(err != 0){
		perror("pthread_create error");
		return -1;
	}
	printids("main thread:");
	sleep(1);// 主进程不等待的话直接退出,子线程可能没有机会得到执行
	return 0;
}

mythreadexit1.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

static void * thr_fn1(void *arg)
{
	printf("pthread1 running.....\n");
	return((void *)1);
}

static void * thr_fn2(void *arg)
{
	printf("pthread2 running.....\n");
	pthread_exit((void *)2);
}

int main(int argc, char const *argv[])
{
	int       err;
	pthread_t tid1, tid2;
	void      *tret;
	// 创建线程1
	err = pthread_create(&tid1, NULL, thr_fn1, NULL);
	if(err != 0){
		perror("pthread_create 1 error");
		return -1;
	}
	// 创建线程2
	err = pthread_create(&tid2, NULL, thr_fn2, NULL);
	if(err != 0){
		perror("pthread_create 2 error");
		return -1;
	}

	// 等待线程1退出
	err = pthread_join(tid1, &tret);
	if(err != 0){
		perror("pthread_join 1 error");
		return -1;
	}
	printf("pthread1 return:%ld\n", (long unsigned int)tret);// 打印线程1 exit code

	// 等待线程2退出
	err = pthread_join(tid2, &tret);
	if(err != 0){
		perror("pthread_join 2 error");
		return -1;
	}
	printf("pthread2 return:%ld\n", (long unsigned int)tret);// 打印线程1 exit code

	return 0;
}

mythreadexit2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

struct foo {
	int a, b, c, d;
};

static void printfoo(const char *str, struct foo *fp)
{
	printf("%s\n", str);
	printf("\tstructure at 0x%lx\n", (unsigned long)fp);
	printf("\tfoo.a = %d\n", fp->a);
	printf("\tfoo.b = %d\n", fp->b);
	printf("\tfoo.c = %d\n", fp->c);
	printf("\tfoo.d = %d\n", fp->d);	
}

static void *thr_fn1(void *arg)
{
	struct foo foo1 = {1, 2, 3, 4};// 在线程1栈上分配的空间
	printfoo("thread 1:\n", &foo1);
	pthread_exit((void *)&foo1);// 线程1退出后栈空间会被回收被它用
}

static void *thr_fn2(void *arg)
{
	printf("thread 2: ID is %lu\n", (unsigned long)pthread_self());
	pthread_exit((void *)0);
}

int main(int argc, char const *argv[])
{
	int err;
	pthread_t tid1, tid2;
	struct foo *fp;

	err = pthread_create(&tid1, NULL, thr_fn1, NULL);
	if(err != 0){
		perror("pthread_create 1 error");
		return -1;
	}
	err = pthread_join(tid1, (void **)&fp);
	if(err != 0){
		perror("pthread_join 1 error");
		return -1;
	}
	printfoo("main :\n", fp);
	sleep(1);
	return 0;
}

mythreadexit3.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define ARRSIZE 4

typedef struct foo {
	int arr[ARRSIZE];
} foo;

void pr_foo(const char* s, const foo* fp) {
	printf("%s structure at 0x%lx\n", s, (unsigned long)fp);
	for (int i = 0; i < ARRSIZE; ++i)
		printf(" foo.arr[%d] = %d\n", i, fp->arr[i]);
}

void* thread_func1(void* args) {
	//foo f = { 1,2,3,4 };//错误的使用线程栈中的局部变量进行返回
	/*pr_foo("thread 1:\n", &f);
	pthread_exit((void*)&f);*/

	foo* f = malloc(sizeof(foo));
	for (int i = 0; i < ARRSIZE; ++i)
		f->arr[i] = i + 1;
	pr_foo("thread 1:\n", f);
	pthread_exit((void*)f);
}

void* thread_func2(void* args) {
	printf("thread 2:ID is 0x%lx\n", pthread_self());
	pthread_exit((void*)NULL);
}


int main(void)
{
	int err;
	foo* fp;
	pthread_t thread_id1, thread_id2;

	if ((err = pthread_create(&thread_id1, NULL, thread_func1, NULL)) != 0) {
		printf("%d, %s\n",err, "pthread_create error"); exit(1);
	}
	if ((err = pthread_join(thread_id1, (void**)&fp)) != 0) {
		printf("%d, %s\n", err, "pthread_join error"); exit(1);
	}

	putchar('\n');
	if ((err = pthread_create(&thread_id2, NULL, thread_func2, NULL)) != 0) {
		printf("%d, %s\n",err, "pthread_create error"); exit(1);
	}
	if ((err = pthread_join(thread_id2, NULL)) != 0) {
		printf("%d, %s\n", err, "pthread_join error"); exit(1);
	}
	pr_foo("parent:\n", fp);
	free(fp);
	
	exit(EXIT_SUCCESS);
}

mythreadcleanup1.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

static void *cleanup(void *arg)
{
	printf("%s\n", (char *)arg);
}

static void *thr_fn1(void *arg)
{
	printf("pthread 1 starting....\n");
	pthread_cleanup_push(cleanup, "thread 1 first handler");
	pthread_cleanup_push(cleanup, "thread 1 second handler");
	printf("pthread 1 cleanup set complete\n");
	if(arg)
		return((void*)1);
	pthread_cleanup_pop(0); // 取消登记的cleanup函数
	pthread_cleanup_pop(0);
	return((void*)0);
}

static void *thr_fn2(void *arg)
{
	printf("pthread 2 starting....\n");
	pthread_cleanup_push(cleanup, "thread 2 first handler");
	pthread_cleanup_push(cleanup, "thread 2 second handler");
	printf("pthread 2cleanup set complete\n");
	if(arg)
		pthread_exit((void*)2);

	pthread_cleanup_pop(0); // 取消登记的cleanup函数
	pthread_cleanup_pop(0);
	return((void*)0);
}

int main(int argc, char const *argv[])
{
	int 	  err;
	pthread_t tid1, tid2;
	void 	  *tret;

	err = pthread_create(&tid1, NULL, thr_fn1, (void *)1);	
	if(err != 0){
		perror("pthread_create thread1 error");
		return -1;
	}
	sleep(1);// 保证线程1先执行
	err = pthread_create(&tid2, NULL, thr_fn2, (void*)2);
	if(err != 0){
		perror("pthread_create thread2 error");
		return -1;
	}

	err = pthread_join(tid1, &tret);
	if(err != 0){
		perror("pthread_join thread1 error");
		return -1;
	}
	printf("thread 1 exit code:%ld\n", (unsigned long)tret);

	err = pthread_join(tid2, &tret);
	if(err != 0){
		perror("pthread_join thread2 error");
		return -1;
	}
	printf("thread 2 exit code:%ld\n", (unsigned long)tret);

	return 0;
}

mythreadcleanup2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

void cleanup(void* args) {
	printf("cleanup: %s\n", (char*)args);
}

void* thread_func1(void* args) {
	printf("thread 1 start\n");
	pthread_cleanup_push(cleanup, "thread 1 first handler");
	pthread_cleanup_push(cleanup, "thread 1 second handler");
	printf("thread 1 push complete\n");
	if (args)
		return (void*)1;
	pthread_cleanup_pop(0);
	pthread_cleanup_pop(0);

	printf("thread 1 get here?\n");
	return (void*)1;
}


void* thread_func2(void* args) {
	printf("thread 2 start\n");
	pthread_cleanup_push(cleanup, "thread 2 first handler");
	pthread_cleanup_push(cleanup, "thread 2 second handler");
	printf("thread 2 push complete\n");
	if (args)
		pthread_exit((void*)2);
	pthread_cleanup_pop(0);
	pthread_cleanup_pop(0);

	printf("thread 2 get here?\n");
	pthread_exit((void*)2);
}

void* thread_func3(void* args) {
	printf("thread 3 start\n");
	pthread_cleanup_push(cleanup, "thread 3 first handler");
	pthread_cleanup_push(cleanup, "thread 3 second handler");
	printf("thread 3 push complete\n");
	sleep(1);
	if (args)
		pthread_exit((void*)3);
	pthread_cleanup_pop(0);
	pthread_cleanup_pop(0);

	printf("thread 3 get here?\n");
	pthread_exit((void*)3);
}


int main(void)
{
	pthread_t thread1, thread2, thread3;
	void* thread_ret;
	int err;

	if ((err = pthread_create(&thread1, NULL, thread_func1, (void*)1)) != 0)
		printf("%d, %s\n", err, "pthread_create error");
	if ((err = pthread_create(&thread2, NULL, thread_func2, NULL)) != 0)
		printf("%d, %s\n", err, "pthread_create error");
	if ((err = pthread_create(&thread3, NULL, thread_func3, (void*)3)) != 0)
		printf("%d, %s\n", err, "pthread_create error");

	//若向某线程发送取消请求，也会导致该线程执行cleanup线程清理程序
	if ((err = pthread_cancel(thread3)) != 0)
		printf("%d, %s\n", err, "pthread_cancel error");
	if ((err = pthread_join(thread1, &thread_ret)) != 0)
		printf("%d, %s\n", err, "pthread_join error");
	printf("thread 1 exit code: %ld\n", (long)thread_ret);
	if ((err = pthread_join(thread2, &thread_ret)) != 0)
		printf("%d, %s\n", err, "pthread_join error");
	printf("thread 2 exit code: %ld\n",(long)thread_ret);
	if ((err = pthread_join(thread3, &thread_ret)) != 0)
		printf("%d, %s\n", err, "pthread_join error");
	printf("thread 3 exit code: %ld\n",
		thread_ret == PTHREAD_CANCELED ? -1 : (long)thread_ret);

	exit(EXIT_SUCCESS);
}

mythreadcancel.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

void* thread_func(void* args) {
	sleep(1);
	printf("thread get here?\n");
	pthread_exit((void*)NULL);
}

int main(void)
{
	pthread_t thread_id;
	void* thread_ret;
	int err;

	if ((err = pthread_create(&thread_id, NULL, thread_func, NULL)) != 0) {
		printf("%d, %s\n", err, "pthread_create error"); exit(1);
	}
	if ((err = pthread_cancel(thread_id)) != 0) {
		printf("%d, %s\n", err, "pthread_cancel"); exit(1);
	}
	if ((err = pthread_join(thread_id, &thread_ret)) != 0) {
		printf("%d, %s\n", err, "pthread_join error"); exit(1);
	}
	if (PTHREAD_CANCELED == thread_ret)
		printf("thread is canceled\n");

	exit(EXIT_SUCCESS);
}

mythreaderrno.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

void* thread_func(void* args) {
	errno = 10;//每一个线程都有属于自己的errno变量
	printf("in thread_func: errno = %d\n", errno);
	return (void*)NULL;
}


int main(void)
{
	pthread_t thread_id;
	int err;

	errno = 11;
	printf("before pthread_create: errno = %d\n", errno);
	if ((err = pthread_create(&thread_id, NULL, thread_func, NULL)) != 0)
		printf("%d, %s\n", err, "pthread_create error");
	if ((err = pthread_join(thread_id, NULL)) != 0)
		printf("%d, %s\n", err, "pthread_join error");
	printf("after pthread_join: errno = %d\n", errno);

	exit(EXIT_SUCCESS);
}

mythreadarg.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

typedef struct arg_type {
	int lvalue;
	int rvalue;
}arg_type;

void* thread_func(void* args) {
	arg_type* p = (arg_type*)args;
	printf("thread func return the max one between lvalue and rvalue\n");
	return (void*)(long)(p->lvalue > p->rvalue ? p->lvalue : p->rvalue);
	//在64位架构中：void*指针的大小是64位，long的大小也是64位
}

int main(void)
{
	pthread_t thread_id;
	arg_type argbuf;
	void* retval;
	int err;
	
	argbuf.lvalue = 10;
	argbuf.rvalue = 23;
	if ((err = pthread_create(&thread_id, NULL, thread_func, (void*)&argbuf)) != 0)
		printf("%d, %s\n", err, "thread create error");
	if ((err = pthread_join(thread_id, &retval)) != 0)
		printf("%d, %s\n", err, "pthread_join error");
	printf("The max one is %ld\n", (long)retval);
	//printf("sizeof long: %lu\n", sizeof(void*));

	exit(EXIT_SUCCESS);
}

mythreadmutex1.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

typedef struct foo {
	int f_count;
	int f_id;
	int share_value;
	pthread_mutex_t lock;
}foo;

foo* foo_alloc(int id) {
	foo* pret = NULL;

	if ((pret = malloc(sizeof(foo))) != NULL) {
		pret->f_count = 1;
		pret->f_id = id;
		pret->share_value = 0;
		if (pthread_mutex_init(&pret->lock,NULL) != 0) {
			free(pret);
			return NULL;
		}
	}
	return pret;
}

void foo_hold(foo* p) {
	pthread_mutex_lock(&p->lock);
	p->f_count++;
	pthread_mutex_unlock(&p->lock);
}

void foo_update(foo* p) {
	pthread_mutex_lock(&p->lock);
	p->share_value++;
	pthread_mutex_unlock(&p->lock);
}

int foo_read(foo* p) {
	int ret;

	pthread_mutex_lock(&p->lock);
	ret = p->share_value;
	pthread_mutex_unlock(&p->lock);
	return ret;
}

void foo_rele(foo* p) {
	pthread_mutex_lock(&p->lock);
	if (--p->f_count == 0) {
		pthread_mutex_unlock(&p->lock);
		pthread_mutex_destroy(&p->lock);
		free(p);
		printf("foo freed\n");
	}
	else {
		pthread_mutex_unlock(&p->lock);
	}
}

void* thread_func(void* args) {
	foo* p = (foo*)args;
	foo_hold(p);
	for (int i = 0; i < 10000; i++)
		foo_update(p);
	printf("At the end of thread, the shared value: %d\n", foo_read(p));
	foo_rele(p);
	pthread_exit((void*)NULL);
}

int main(void)
{
	pthread_t tid1, tid2, tid3;
	foo* pf;
	int err;

	if ((pf = foo_alloc(1)) == NULL)
		err_sys("foo_alloc error\n");
	if ((err = pthread_create(&tid1, NULL, thread_func, (void*)pf)) != 0)
		printf("%d, %s\n", err, "pthread_create error");
	if ((err = pthread_create(&tid2, NULL, thread_func, (void*)pf)) != 0)
		printf("%d, %s\n", err, "pthread_create error");
	if ((err = pthread_create(&tid3, NULL, thread_func, (void*)pf)) != 0)
		printf("%d, %s\n", err, "pthread_create error");

	if ((err = pthread_join(tid1, NULL)) != 0)
		printf("%d, %s\n", err, "pthread_join error");
	if ((err = pthread_join(tid2, NULL)) != 0)
		printf("%d, %s\n", err, "pthread_join error");
	if ((err = pthread_join(tid3, NULL)) != 0)
		printf("%d, %s\n", err, "pthread_join error");
	printf("Result shared value: %d\n", foo_read(pf));

	foo_rele(pf);
	exit(EXIT_SUCCESS);
}

mythreadmutex2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define NHASH 29
#define HASH(id) (((unsigned long)id)%NHASH)

struct foo {
	int f_count;
	unsigned long f_id;
	int f_value;
	pthread_mutex_t lock;
	struct foo* pnext;
};
typedef struct foo foo;

//散列表
foo* foo_hash[NHASH];
pthread_mutex_t hashlock = PTHREAD_MUTEX_INITIALIZER;

foo* foo_alloc(unsigned long id);
void foo_hold(foo* fp);
foo* foo_find(unsigned long id);
int foo_read(foo* fp);
void foo_update(foo* fp);
void foo_rele(foo* fp);

void* thread_func(void* args);


int main(void)
{
	pthread_t tid1, tid2, tid3, tid4;
	foo* pf1, * pf2;

	if ((pf1 = foo_alloc(32)) == NULL)
		err_sys("foo_alloc error\n");
	if ((pf2 = foo_alloc(21)) == NULL)
		err_sys("foo_alloc error\n");
	pthread_create(&tid1, NULL, thread_func, (void*)32);
	pthread_create(&tid2, NULL, thread_func, (void*)32);
	pthread_create(&tid3, NULL, thread_func, (void*)21);
	pthread_create(&tid4, NULL, thread_func, (void*)21);
	pthread_join(tid1, NULL);
	pthread_join(tid2, NULL);
	pthread_join(tid3, NULL);
	pthread_join(tid4, NULL);
	printf("\nAt the end of process: pf1->f_value = %d\n",
		foo_read(pf1));
	printf("At the end of process: pf2->f_value = %d\n",
		foo_read(pf2));

	foo_rele(pf1);
	foo_rele(pf2);
	exit(EXIT_SUCCESS);
}


foo* foo_alloc(unsigned long id) {
	foo* pret = NULL;
	unsigned long index;

	if ((pret = malloc(sizeof(foo))) != NULL) {
		pret->f_count = 1;
		pret->f_id = id;
		if (pthread_mutex_init(&pret->lock, NULL) != 0) {
			free(pret);
			return NULL;
		}
		index = HASH(id);
		pthread_mutex_lock(&hashlock);
		pret->pnext = foo_hash[index];
		foo_hash[index] = pret;
		pthread_mutex_lock(&pret->lock);
		pthread_mutex_unlock(&hashlock);
		pret->f_value = 0;
		//
		pthread_mutex_unlock(&pret->lock);
	}
	return pret;
}

void foo_hold(foo* pf) {
	pthread_mutex_lock(&pf->lock);
	pf->f_count++;
	pthread_mutex_unlock(&pf->lock);
}

foo* foo_find(unsigned long id) {
	foo* pret = NULL;

	pthread_mutex_lock(&hashlock);
	for (pret = foo_hash[HASH(id)];
		pret != NULL; pret = pret->pnext) {
		if (pret->f_id == id) {
			foo_hold(pret);
			break;
		}
	}
	pthread_mutex_unlock(&hashlock);
	return pret;
}

int foo_read(foo* pf) {
	int ret;

	pthread_mutex_lock(&pf->lock);
	ret = pf->f_value;
	pthread_mutex_unlock(&pf->lock);
	return ret;
}

void foo_update(foo* pf) {
	pthread_mutex_lock(&pf->lock);
	pf->f_value++;
	pthread_mutex_unlock(&pf->lock);
}

void foo_rele(foo* pf) {
	foo* find_header;
	unsigned long index;

	pthread_mutex_lock(&pf->lock);
	if (pf->f_count == 1) {
		pthread_mutex_unlock(&pf->lock);//先对foo结构中的lock解锁
		pthread_mutex_lock(&hashlock);	//再重新对从大锁到foo结构中的lock重新进行加锁
		pthread_mutex_lock(&pf->lock);
		if (pf->f_count != 1) {
			pf->f_count--;
			pthread_mutex_unlock(&pf->lock);
			pthread_mutex_unlock(&hashlock);
			return;
		}
		index = HASH(pf->f_id);			//从链表中删除节点
		find_header = foo_hash[index];
		if (find_header == pf)
			find_header = pf->pnext;
		else {
			while (find_header->pnext != pf)
				find_header = find_header->pnext;
			find_header->pnext = pf->pnext;
		}
		pthread_mutex_unlock(&pf->lock);//链表一旦修改完毕就应该将大锁进行释放
		pthread_mutex_unlock(&hashlock);
		pthread_mutex_destroy(&pf->lock);
		free(pf);
		printf("foo freed\n");
	}
	else {
		pf->f_count--;
		pthread_mutex_unlock(&pf->lock);
	}
}

void* thread_func(void* args) {
	unsigned long id = (unsigned long)args;
	foo* pf = foo_find(id);
	for (int i = 0; i < 10000; i++)
		foo_update(pf);

	printf("At the of thread(%lu), pf->f_value = %d\n",
		id, foo_read(pf));
	foo_rele(pf);
	return (void*)NULL;
}

mythreadmutex3.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define NHASH 29
#define HASH(id) (((unsigned long)id)%NHASH)

struct foo {
	int f_count;
	unsigned long f_id;
	int f_value;
	pthread_mutex_t lock;
	struct foo* pnext;
};
typedef struct foo foo;

//散列表
foo* foo_hash[NHASH];
pthread_mutex_t hashlock = PTHREAD_MUTEX_INITIALIZER;

foo* foo_alloc(unsigned long id);
void foo_hold(foo* fp);
foo* foo_find(unsigned long id);
int foo_read(foo* fp);
void foo_update(foo* fp);
void foo_rele(foo* fp);

void* thread_func(void* args);


int main(void)
{
	pthread_t tid1, tid2, tid3, tid4;
	foo* pf1, * pf2;

	if ((pf1 = foo_alloc(32)) == NULL)
		err_sys("foo_alloc error\n");
	if ((pf2 = foo_alloc(21)) == NULL)
		err_sys("foo_alloc error\n");
	pthread_create(&tid1, NULL, thread_func, (void*)32);
	pthread_create(&tid2, NULL, thread_func, (void*)32);
	pthread_create(&tid3, NULL, thread_func, (void*)21);
	pthread_create(&tid4, NULL, thread_func, (void*)21);
	pthread_join(tid1, NULL);
	pthread_join(tid2, NULL);
	pthread_join(tid3, NULL);
	pthread_join(tid4, NULL);
	printf("\nAt the end of process: pf1->f_value = %d\n",
		foo_read(pf1));
	printf("At the end of process: pf2->f_value = %d\n",
		foo_read(pf2));

	foo_rele(pf1);
	foo_rele(pf2);
	exit(EXIT_SUCCESS);
}


foo* foo_alloc(unsigned long id) {
	foo* pret = NULL;
	unsigned long index;

	if ((pret = malloc(sizeof(foo))) != NULL) {
		pret->f_count = 1;
		pret->f_id = id;
		if (pthread_mutex_init(&pret->lock, NULL) != 0) {
			free(pret);
			return NULL;
		}
		index = HASH(id);
		pthread_mutex_lock(&hashlock);
		pret->pnext = foo_hash[index];
		foo_hash[index] = pret;
		pthread_mutex_lock(&pret->lock);
		pthread_mutex_unlock(&hashlock);
		pret->f_value = 0;
		//
		pthread_mutex_unlock(&pret->lock);
	}
	return pret;
}

void foo_hold(foo* pf) {
	pthread_mutex_lock(&pf->lock);
	pf->f_count++;
	pthread_mutex_unlock(&pf->lock);
}

foo* foo_find(unsigned long id) {
	foo* pret = NULL;

	pthread_mutex_lock(&hashlock);
	for (pret = foo_hash[HASH(id)];
		pret != NULL; pret = pret->pnext) {
		if (pret->f_id == id) {
			foo_hold(pret);
			break;
		}
	}
	pthread_mutex_unlock(&hashlock);
	return pret;
}

int foo_read(foo* pf) {
	int ret;

	pthread_mutex_lock(&pf->lock);
	ret = pf->f_value;
	pthread_mutex_unlock(&pf->lock);
	return ret;
}

void foo_update(foo* pf) {
	pthread_mutex_lock(&pf->lock);
	pf->f_value++;
	pthread_mutex_unlock(&pf->lock);
}

void foo_rele(foo* pf) {
	foo* find_header;
	unsigned long index;

	pthread_mutex_lock(&hashlock);
	if (--pf->f_count == 0) {
		index = HASH(pf->f_id);
		find_header = foo_hash[index];
		if (find_header == pf)
			find_header = pf->pnext;
		else {
			while (find_header->pnext != pf)
				find_header = find_header->pnext;
			find_header->pnext = pf->pnext;
		}
		pthread_mutex_unlock(&hashlock);
		pthread_mutex_destroy(&pf->lock);
		free(pf);
		printf("foo freed\n");
	}
	else {
		pthread_mutex_unlock(&hashlock);
	}
}

void* thread_func(void* args) {
	unsigned long id = (unsigned long)args;
	foo* pf = foo_find(id);
	for (int i = 0; i < 10000; i++)
		foo_update(pf);

	printf("At the of thread(%lu), pf->f_value = %d\n",
		id, foo_read(pf));
	foo_rele(pf);
	return (void*)NULL;
}

mythreadmutex4.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

typedef struct foo {
	int shared_value;
	pthread_mutex_t lock;
}foo;

foo* foo_alloc(void) {
	foo* pret = NULL;

	if ((pret = malloc(sizeof(foo))) != NULL) {
		pret->shared_value = 0;
		if (pthread_mutex_init(&pret->lock, NULL) != 0) {
			free(pret);
			return NULL;
		}
	}
	return pret;
}

void foo_destroy(foo* pfoo) {
	if (pfoo == NULL)return;
	pthread_mutex_destroy(&pfoo->lock);
	free(pfoo);
}

void add_foo(foo* p) {
	pthread_mutex_lock(&p->lock);
#ifdef DISPLAY_
	int val = ++(p->shared_value);
#else
	p->shared_value++;
#endif
	pthread_mutex_unlock(&p->lock);
#ifdef DISPLAY_
	printf("Thread(0x%lx) increase shared_value: %d\n",
		pthread_self(), val);
#endif
}

void* thread_func(void* args) {
	foo* p = (foo*)args;
	for (int i = 0; i < 10000; ++i)
		add_foo(p);
	pthread_exit((void*)NULL);
}


int main(void) {
	pthread_t thr1, thr2;
	foo* pfoo;
	int err;

	if ((pfoo = foo_alloc()) == NULL)
		err_sys("foo_alloc error\n");
	printf("before pthread_create, pfoo->shared_value= %d\n", pfoo->shared_value);
	if ((err = pthread_create(&thr1, NULL, thread_func, (void*)pfoo)) != 0)
		printf("%d, %s\n", err, "pthread_create error");
	if ((err = pthread_create(&thr2, NULL, thread_func, (void*)pfoo)) != 0)
		printf("%d, %s\n", err, "pthread_create error");
	if ((err = pthread_join(thr1, NULL)) != 0)
		printf("%d, %s\n", err, "pthread_join error");
	if ((err = pthread_join(thr2, NULL)) != 0)
		printf("%d, %s\n", err, "pthread_join  error");

	printf("after pthread_join, pfoo->shared_value= %d\n", pfoo->shared_value);
	foo_destroy(pfoo);
	exit(EXIT_SUCCESS);
}

mythreadmutex5.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int main(void)
{
	pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
	struct timespec tout;
	struct tm* tmp;
	char buf[64];
	int err;

	pthread_mutex_lock(&lock);
	printf("mutex is locked\n");
	clock_gettime(CLOCK_REALTIME, &tout);
	tmp = localtime(&tout.tv_sec);
	strftime(buf, 64, "%r", tmp);
	printf("current time is %s\n", buf);
	tout.tv_sec += 10;

	err = pthread_mutex_timedlock(&lock, &tout);

	clock_gettime(CLOCK_REALTIME, &tout);
	tmp = localtime(&tout.tv_sec);
	strftime(buf, 64, "%r", tmp);
	printf("current time is %s\n", buf);

	if (err == 0)
		printf("mutex lock again\n");
	else
		printf("can't lock mutex again:%s\n", strerror(err));
	exit(EXIT_SUCCESS);
}

mythreadmutex6.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

typedef struct foo {
	pthread_mutex_t first_lock;
	pthread_mutex_t second_lock;
	int value;
}foo;

foo* foo_init(void) {
	foo* pret = NULL;

	if ((pret = malloc(sizeof(foo))) != NULL) {
		pret->value = 0;
		if (pthread_mutex_init(&pret->first_lock, NULL) != 0) {
			free(pret);
			return NULL;
		}
		if (pthread_mutex_init(&pret->second_lock, NULL) != 0) {
			pthread_mutex_destroy(&pret->first_lock);
			free(pret);
			return NULL;
		}
	}
	return pret;
}

void foo_destroy(foo* p) {
	if (p == NULL)return;
	pthread_mutex_destroy(&p->first_lock);
	pthread_mutex_destroy(&p->second_lock);
	free(p);
}

void update_foo1(foo* p) {
	while (1) {
		pthread_mutex_lock(&p->first_lock);
		if (pthread_mutex_trylock(&p->second_lock) == EBUSY) {
			pthread_mutex_unlock(&p->first_lock);
			continue;
		}
		pthread_mutex_unlock(&p->first_lock);
		p->value++;
		pthread_mutex_unlock(&p->second_lock);
		break;
	}
}

void update_foo2(foo* p) {
	while (1) {
		pthread_mutex_lock(&p->second_lock);
		if (pthread_mutex_trylock(&p->first_lock) == EBUSY) {
			pthread_mutex_unlock(&p->second_lock);
			continue;
		}
		pthread_mutex_unlock(&p->second_lock);
		p->value++;
		pthread_mutex_unlock(&p->first_lock);
		break;
	}
}

void* thread1_func(void* args) {
	foo* p = (foo*)args;
	for (int i = 0; i < 100000; i++)
		update_foo1(p);
	pthread_exit((void*)NULL);
}

void* thread2_func(void* args) {
	foo* p = (foo*)args;
	for (int i = 0; i < 100000; i++)
		update_foo2(p);
	pthread_exit((void*)NULL);
}

int main(void)
{
	pthread_t thr1, thr2;
	foo* p;
	int err;

	if ((p = foo_init()) == NULL)
		err_sys("foo_init error\n");
	if ((err = pthread_create(&thr1, NULL, thread1_func, (void*)p)) != 0)
		printf("%d, %s\n", err, "pthread_create error");
	if ((err = pthread_create(&thr2, NULL, thread2_func, (void*)p)) != 0)
		printf("%d, %s\n", err, "pthread_create error");
	if ((err = pthread_join(thr1, NULL)) != 0)
		printf("%d, %s\n", err, "pthread_join error");
	if ((err = pthread_join(thr2, NULL)) != 0)
		printf("%d, %s\n", err, "pthread_join error");
	printf("Result shared_value = %d\n", p->value);

	foo_destroy(p);
	exit(EXIT_SUCCESS);
}

mythreadmutex7.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

//工作结构体
typedef struct job {
	struct job* pnext;
	struct job* pprev;
	pthread_t thread_id;
	int value;
}job;

//工作队列
typedef struct job_queue {
	job* head;
	job* tail;
	pthread_rwlock_t jq_lock;
}job_queue;


/*
	初始化工作队列
*/
int jobqueue_init(job_queue* jq) {
	int err;

	jq->head = NULL;
	jq->tail = NULL;
	if ((err = pthread_rwlock_init(&jq->jq_lock, NULL)) != 0)
		return err;
	return 0;
}

/*
	销毁工作队列
*/
void jobqueue_destroy(job_queue* jq) {
	if (jq == NULL)return;
	pthread_rwlock_destroy(&jq->jq_lock);
	free(jq);
}

/*
	前向插入工作
*/
void job_finsert(job_queue* jq, job* insertjob) {
	pthread_rwlock_wrlock(&jq->jq_lock);
	insertjob->pnext = jq->head;
	insertjob->pprev = NULL;
	if (jq->head == NULL)//若job_queue本身为空
		jq->tail = insertjob;
	else
		jq->head->pprev = insertjob;
	jq->head = insertjob;
	pthread_rwlock_unlock(&jq->jq_lock);
}

/*
	后向插入工作
*/
void job_binsert(job_queue* jq, job* insertjob) {
	pthread_rwlock_wrlock(&jq->jq_lock);
	insertjob->pprev = jq->tail;
	insertjob->pnext = NULL;
	if (jq->tail == NULL)//若job_queue本身为空
		jq->head = insertjob;
	else
		jq->tail->pnext = insertjob;
	jq->tail = insertjob;
	pthread_rwlock_unlock(&jq->jq_lock);
}

/*
	从队列中删除一个工作
*/
void job_remove(job_queue* jq, job* remove_job) {
	pthread_rwlock_wrlock(&jq->jq_lock);
	if (jq->head == remove_job) {
		jq->head = remove_job->pnext;
		if (jq->tail == remove_job)
			jq->tail = NULL;
		else
			remove_job->pnext->pprev = NULL;
	}
	else if (jq->tail == remove_job) {
		jq->tail = remove_job->pprev;
		if (remove_job == jq->head)
			jq->head = NULL;
		else
			remove_job->pprev->pnext = NULL;
	}
	else {
		remove_job->pnext->pprev = remove_job->pprev;
		remove_job->pprev->pnext = remove_job->pnext;
	}
	pthread_rwlock_unlock(&jq->jq_lock);
}

/*
	从工作队列中找到一个属于自己的工作
*/
job* job_find(job_queue* jq, pthread_t tid) {
	job* retp;

	if (pthread_rwlock_rdlock(&jq->jq_lock) != 0)
		return NULL;
	for (retp = jq->head; retp != NULL; retp = retp->pnext)
		if (pthread_equal(retp->thread_id, tid))
			break;
	pthread_rwlock_unlock(&jq->jq_lock);
	return retp;
}

/*
	返回工作队列长度
*/
int queue_size(job_queue* jq) {
	int size = 0;
	job* pjob;

	if (pthread_rwlock_rdlock(&jq->jq_lock) != 0)
		return -1;
	pjob = jq->head;
	while (pjob != NULL) {
		++size;
		pjob = pjob->pnext;
	}
	pthread_rwlock_unlock(&jq->jq_lock);

	return size;
}

/*
	初始化一个工作
*/
static job* job_init(job* pjob, pthread_t tid, int init_value) {
	pjob->thread_id = tid;
	pjob->value = init_value;
	return pjob;
}

/*
	线程函数，负责从工作队列中取出一个属于自己的工作并销毁它
*/
void* thread_func(void* args) {
	job_queue* jq = (job_queue*)args;
	job* myjob = NULL;
	int count = 5;
	char buf[64];

	while (1) {
		if ((myjob = job_find(jq, pthread_self())) != NULL) {
			count = 5;
			job_remove(jq, myjob);//从队列中取出属于自己的工作
			snprintf(buf, 64, "Thread(0x%lx) decrease value %d to 0\n",
				pthread_self(), myjob->value);
			while (myjob->value--);
			fputs(buf, stdout);
			free(myjob);
		}
		else {
			printf("Thread(0x%lx) doesn't find any job\n", pthread_self());
			if (--count == 0)//当5秒内没有发现新的工作就退出当前进程
				break;
		}
		sleep(1);
	}

	pthread_exit((void*)NULL);
}

/*
	------------------------------------------------
*/
int main(int argc,char*argv[])
{
	int count = 20;
	pthread_t tid1, tid2;
	job_queue* jq;
	job* pjob;

	if (argc > 1)
		count = atoi(argv[1]);

	if ((jq = malloc(sizeof(job_queue))) == NULL)
		err_sys("malloc error\n");
	if (jobqueue_init(jq) != 0)
		err_sys("jobqueue_init error\n");

	pthread_create(&tid1, NULL, thread_func, (void*)jq);
	pthread_create(&tid2, NULL, thread_func, (void*)jq);

	while (count--) {//主线程向工作队列中加入count*2个工作
		pjob = malloc(sizeof(job));
		job_binsert(jq, job_init(pjob, tid1, 100000000));
		pjob = malloc(sizeof(job));
		job_binsert(jq, job_init(pjob, tid2, 100000000));
	}
#ifdef DEBUG
	printf("job queue size = %d\n", queue_size(jq));
#endif
	pthread_join(tid1, NULL);
	pthread_join(tid2, NULL);
#ifdef DEBUG
	printf("job queue size = %d\n", queue_size(jq));
#endif
	jobqueue_destroy(jq);
	printf("process quit\n");

	exit(EXIT_SUCCESS);
}

mythreadmutex8.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

typedef struct svalue {
	pthread_spinlock_t lock;
	volatile int value;
}svalue;

void svalue_init(svalue* psv) {
	int err;

	if ((err = pthread_spin_init(&psv->lock, PTHREAD_PROCESS_PRIVATE)) != 0)
		printf("%d, %s\n", err, "pthread_spin_init error");
	psv->value = 0;
}

void svalue_destroy(svalue* psv) {
	int err;

	if ((err = pthread_spin_destroy(&psv->lock)) != 0)
		printf("%d, %s\n", err, "pthread_spin_destroy error");
}

void* thread_func(void* args) {
	svalue* psv = (svalue*)args;

	for (int i = 0; i < 10000; i++) {
		pthread_spin_lock(&psv->lock);
		psv->value++;
		pthread_spin_unlock(&psv->lock);
	}
	pthread_exit((void*)NULL);
}


int main(void) {
	pthread_t tid1, tid2, tid3;
	svalue* psv;

	if ((psv = malloc(sizeof(svalue))) == NULL)
		err_sys("malloc error\n");
	svalue_init(psv);
	pthread_create(&tid1, NULL, thread_func, (void*)psv);
	pthread_create(&tid2, NULL, thread_func, (void*)psv);
	pthread_create(&tid3, NULL, thread_func, (void*)psv);
	pthread_join(tid1, NULL);
	pthread_join(tid2, NULL);
	pthread_join(tid3, NULL);
	printf("At the end, the value of svalue: %d\n", psv->value);
	svalue_destroy(psv);
	free(psv);

	exit(EXIT_SUCCESS);
}

mythreadcond.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define MAX 20

typedef struct queue {
	pthread_mutex_t lock;
	pthread_cond_t consumer;
	pthread_cond_t producer;
	int buf[MAX];//这里可以用struct job来代替
	int head;
	int tail;
	int size;
}queue;


void queue_init(queue* q) {
	q->head = 0;
	q->tail = 0;
	q->size = 0;
	if (pthread_mutex_init(&q->lock, NULL) != 0)
		err_sys("pthread_mutex_init error\n");
	if (pthread_cond_init(&q->consumer, NULL) != 0)
		err_sys("pthread_cond_init error\n");
	if (pthread_cond_init(&q->producer, NULL) != 0)
		err_sys("pthread_cond_init error\n");
}


void queue_destroy(queue* q) {
	int err;

	if ((err = pthread_mutex_destroy(&q->lock)) != 0)
		printf("%d, %s\n", err, "pthread_mutex_destroy error");
	if ((err = pthread_cond_destroy(&q->consumer)) != 0)
		printf("%d, %s\n", err, "pthread_cond_destroy error");
	if ((err = pthread_cond_destroy(&q->producer)) != 0)
		printf("%d, %s\n", err, "pthread_cond_destroy error");
}


void enqueue(queue* q, int ival) {
	q->buf[q->tail] = ival;
	q->tail = (q->tail + 1) % MAX;
	q->size++;
}


int dequeue(queue* q) {
	int ret;

	ret = q->buf[q->head];
	q->head = (q->head + 1) % MAX;
	q->size--;
	return ret;
}

int full(queue* q) {
	return q->size == MAX;
}

int empty(queue* q) {
	return q->size == 0;
}

void get_abstime(struct timespec* tsp, long seconds) {
        if (clock_gettime(CLOCK_REALTIME, tsp) != 0)
                err_sys("clock_gettime error\n");
        tsp->tv_sec += seconds;
}

void* consumer(void* args) {
	queue* q = (queue*)args;
	struct timespec timebuf;
	int value;

	while (1) {
		pthread_mutex_lock(&q->lock);
		while (empty(q)) {
			get_abstime(&timebuf, 5);

			if (pthread_cond_timedwait(&q->consumer, &q->lock, &timebuf) == ETIMEDOUT) {
				pthread_mutex_unlock(&q->lock);
				printf("Thread(0x%lx) quit\n", pthread_self());
				pthread_exit((void*)NULL);
			}
		}
		value = dequeue(q);

		printf("Thread(0x%lx) pop value %d\n", pthread_self(), value);
		pthread_mutex_unlock(&q->lock);
		pthread_cond_signal(&q->producer);//放在unlock的上面也可以但效果不好
	}
}


int main(int argc, char* argv[])
{
	pthread_t tid1, tid2;
	int looptime = 10;
	queue* q;

	if (argc > 1)
		looptime = atoi(argv[1]);

	if ((q = malloc(sizeof(queue))) == NULL)
		err_sys("malloc error\n");
	queue_init(q);
	pthread_create(&tid1, NULL, consumer, (void*)q);
	pthread_create(&tid2, NULL, consumer, (void*)q);

	for (int i = 0; i < looptime; i++) {
		pthread_mutex_lock(&q->lock);
		while (full(q))
			pthread_cond_wait(&q->producer, &q->lock);
		enqueue(q, i);
		
		/*
				之所以把printf也放在这里是因为这样push-pop的顺序
			会跟实际的push-pop的顺序是一致的，且线程们都是使用同一
			个进程的标准输出
		*/
		printf("Main thread push value %d\n", i);
		pthread_mutex_unlock(&q->lock);
		pthread_cond_signal(&q->consumer);
	}
	pthread_join(tid1, NULL);
	pthread_join(tid2, NULL);
	queue_destroy(q);
	free(q);

	exit(EXIT_SUCCESS);
}

mythreadbarrier1.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

//使用互斥量和条件变量实现屏障机制
typedef struct Pthread_barrier_t {
	pthread_mutex_t lock;
	pthread_cond_t cond;
	unsigned count;
} Pthread_barrier_t;

int Pthread_barrier_init(Pthread_barrier_t* barrier, unsigned count) {
	int err;

	barrier->count = count;
	if ((err = pthread_mutex_init(&barrier->lock, NULL)) != 0)
		return err;
	if ((err = pthread_cond_init(&barrier->cond, NULL)) != 0)
		return err;
	return 0;
}


/*
	自定义屏障销毁
*/
int Pthread_barrier_destroy(Pthread_barrier_t* barrier) {
	int err;

	if ((err = pthread_cond_destroy(&barrier->cond)) != 0)
		return err;
	if ((err = pthread_mutex_destroy(&barrier->lock)) != 0)
		return err;
	return 0;
}


/*
	自定义屏障等待函数
*/
int Pthread_barrier_wait(Pthread_barrier_t* barrier) {
	pthread_mutex_lock(&barrier->lock);
	if (--barrier->count == 0) {
		pthread_mutex_unlock(&barrier->lock);
		pthread_cond_broadcast(&barrier->cond);
		return PTHREAD_BARRIER_SERIAL_THREAD;
	}
	pthread_cond_wait(&barrier->cond, &barrier->lock);
	pthread_mutex_unlock(&barrier->lock);
	return 0;
}


Pthread_barrier_t barrier;


void* thread_func(void* args) {
	printf("Thread(0x%lx) begin\n", pthread_self());
	sleep(1);
	Pthread_barrier_wait(&barrier);
	printf("Thread(0x%lx) end\n", pthread_self());

	pthread_exit((void*)NULL);
}


int main(int argc, char* argv[]) {
	unsigned THREAD_NUM = 4;
	pthread_t thd;

	if (argc == 2)
		THREAD_NUM = (unsigned)atoi(argv[1]);

	Pthread_barrier_init(&barrier, THREAD_NUM + 1);
	for (int i = 0; i < THREAD_NUM; ++i)
		pthread_create(&thd, NULL, thread_func, (void*)NULL);
	Pthread_barrier_wait(&barrier);
	sleep(1);/*因为main线程在从Pthread_barrier_wait返回之后很快就会调用pthread_exit，
			 而其他线程可能还没有运行完毕，所以需要让main线程稍微等待它们一下，至少要让它们的打印要执行到*/
	Pthread_barrier_destroy(&barrier);

	exit(EXIT_SUCCESS);
}

mythreadbarrier2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define DEBUG
#define NTHR 8
#define NUMNUM 10000000
#define TNUM (NUMNUM/NTHR)

pthread_barrier_t barrier;
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;

int comp(const int* lhs, const int* rhs) {
	return *lhs > * rhs ? 1 : 0;
}

typedef int _Comp(const int*, const int*);

void mergeArr(int arr[], int left, int mid, int right, _Comp* pf) {
        int LSIZE = mid - left;
        int RSIZE = right - mid + 1;
        int larr[LSIZE];
        int rarr[RSIZE];

        for (int i = 0; i < LSIZE; ++i)
                larr[i] = arr[left + i];
        for (int i = 0; i < RSIZE; ++i)
                rarr[i] = arr[mid + i];

        int i = 0, j = 0, k = 0;
        while (i < LSIZE && j < RSIZE) {
                if (pf(&rarr[j], &larr[i]) > 0)
                        arr[left + k++] = larr[i++];
                else
                        arr[left + k++] = rarr[j++];
        }
        while (i < LSIZE)
                arr[left + k++] = larr[i++];
        while (j < RSIZE)
                arr[left + k++] = rarr[j++];
}

void RecMergeSort(int arr[], int left, int right, _Comp* pf) {
        if (left == right)return;
        int MID = (left + right) / 2;
        RecMergeSort(arr, left, MID, pf);
        RecMergeSort(arr, MID + 1, right, pf);
        mergeArr(arr, left, MID + 1, right, pf);
}

void MergeSort(int arr[], int n, _Comp* pf) {
        RecMergeSort(arr, 0, n - 1, pf);
}

void merge(const int* src_arr, int* tar_arr) {
	int thread_index[NTHR];
	int min_t;
	int min;

	//初始化各个线程下标数组的最初的下标
	for (int i = 0; i < NTHR; ++i)
		thread_index[i] = i * TNUM;
	for (int i = 0; i < NUMNUM; ++i) {
		min = INT_MAX;
		for (int j = 0; j < NTHR; ++j) {

			/*	1、线程下标数组中的下标没有越界
				2、找出这一轮中最小的数赋给min，它会赋给目标数组
					以及这个最小值来自哪个min_t线程数组
			*/
			if ((thread_index[j] < (j + 1) * TNUM) && (src_arr[thread_index[j]] < min)) {
				min = src_arr[thread_index[j]];
				min_t = j;
			}
		}
		tar_arr[i] = src_arr[thread_index[min_t]];
		thread_index[min_t]++;
	}
}

void* thread_func(void* args) {
	int* arr = (int*)args;

	MergeSort(arr, TNUM, comp);
	pthread_barrier_wait(&barrier);
	
	return (void*)NULL;
}


int main(void)
{
	struct timespec start, end;
	int* src_arr, *tar_arr;
	pthread_t tid;

	//随机初始化一个数组
	srand(time(NULL));
	src_arr = malloc(sizeof(int) * NUMNUM);
	tar_arr = malloc(sizeof(int) * NUMNUM);
	for (int i = 0; i < NUMNUM; ++i)
		src_arr[i] = rand() % NUMNUM;

	clock_gettime(CLOCK_REALTIME, &start);

	//让各线程分而治之处理属于自己的小数组，main线程做合并工作
	pthread_barrier_init(&barrier, NULL, NTHR + 1);
	for (int i = 0; i < NTHR; ++i)
		pthread_create(&tid, NULL, thread_func, (void*)&src_arr[i*TNUM]);
	pthread_barrier_wait(&barrier);
	merge(src_arr, tar_arr);

	clock_gettime(CLOCK_REALTIME, &end);

	//打印输出
	long nas = (end.tv_sec - start.tv_sec) * 1000000000 +
		end.tv_nsec - start.tv_nsec;
	for (int i = 0; i < NUMNUM; i++)
		printf("%d\n", tar_arr[i]);
	fprintf(stderr,"sort took %.4f seconds\n", (double)nas / 1000000000.0);

	free(src_arr);
	free(tar_arr);
	exit(0);
}

线程控制

    SUS（Single UNIX Specification）定义了与线程操作有关的一些限制。与其他的系统限制一样，这些限制也可以通过sysconf函数进行查询：
        PTHREAD_DESTRUCTOR_ITERATIONS：线程退出时，操作系统试图销毁线程特定数据的最大次数
        PTHREAD_KEYS_MAX：线程可以创建的键的最大数目
        PTHREAD_STACK_MIN：一个线程的栈可用的最小字节数
        PTHREAD_THREADS_MAX：进程可以创建的最大线程数

    pthread接口允许我们通过设置线程/同步对象关联的属性对象来详细调节线程/同步对象。通常，管理这些属性的函数遵循相同的模式
        每个对象与它自己类型的属性对象进行关联
            线程与线程属性关联
            互斥量与互斥量属性关联，等等
        一个属性对象可以代表多个属性。属性对象对于应用程序来说是不透明的。这意味着应用程序并不需要了解有关属性对象内部的详细结构，应用程序只需要使用相应函数来管理属性对象
            有一个初始化函数，用于将属性设置为默认值
            有一个销毁属性对象的函数。如果初始化函数分配了与属性对象关联的资源，销毁函数则负责释放这些资源
            每个属性都有一个从属性对象中获取属性值的函数。由于函数成功时会返回0，失败时会返回错误编号，因此获取的属性值是通过传入函数的一个指针参数返回的。
            每个属性都有一个设置属性值的函数。此时属性值作为参数按照值传递。

1. 线程属性

    pthread_attr_init/pthread_attr_destroy函数：线程属性的初始化函数和销毁函数

    #include<pthread>
    int pthread_attr_init(pthread_attr_t *attr);
    int pthread_attr_destroy(pthread_attr_t *attr);

        参数：
            attr：指向待初始/销毁的线程属性对象的指针
        返回值：
            成功：返回0
            失败：返回错误编号

    如果pthread_attr_init的实现对属性对象的内存空间是动态分配的，则pthread_attr_destroy就会释放该内存空间。另外pthread_attr_destroy还会用无效的值初始化属性对象。如果用pthread_attr_destroy销毁后的属性对象去调用pthread_create，则会创建线程失败

    如果pthread_attr_init调用失败，我们通常可以检测到，并且可以不去创建子线程。但是如果pthread_attr_destroy调用失败，那么通常子线程已经创建并开始执行了。这时非常难以清理：
        我们需要销毁刚创建的子线程
        如果pthread_attr_init分配了内存空间，那么没有任何补救措施（因为唯一可以清理的pthread_attr_destroy调用失败），会出现内存泄漏

    POSIX.1定义了如下的线程属性：
        detachstate：线程的分离状态属性

            分离线程：这种类型的线程在退出时会由操作系统马上收回它所占有的资源。非分离线程在退出时会持有某些资源直到另一个线程对它调用pthread_join

        guardsize：线程栈末尾的警戒缓冲区大小（字节数）
        stackaddr：线程栈的最低地址
        stacksize：线程栈的最小长度（字节数）

    pthread_attr_getdetachstate/pthread_attr_setdetachsetate函数：获取/设置线程的分离状态属性

    #include<pthread>
    int pthread_attr_getdetachstate(const pthread_attr_t *restrict attr, int *detachstate);
    int pthread_attr_setdetachsetate(const pthread_attr_t *restrict attr, int detachstate);

        参数：
            attr：指向待获取/设置的线程属性对象
            pthread_attr_getdetachstate函数，detachstate：一个整数指针，获取的分离状态属性存放在它指向的地址
            pthread_attr_setdetachsetate函数，detachstate：一个整数，其值就是要设置的分离状态属性。它只有两个合法值：
                pthread_create_DETACHED：以分离状态启动线程
                pthread_create_JOINABLE：以正常状态启动线程

        返回值：
            成功：返回0
            失败：返回错误编号

    如果在创建线程时就知道不需要了解子线程的终止状态，则可以修改pthread_attr_t中的detachstate属性，让子线程从创建完毕就处于分离状态。

    当你想获取线程的分离状态时，调用pthread_attr_getdetachstate，其detachstate参数指向的内容要么是pthread_create_DETACHED，要么是pthread_create_JOINABLE

    pthread_attr_getstack/pthread_attr_setstack函数：获取/设置线程的线程栈属性

    #include<pthread.h>
    int pthread_attr_getstack(const pthread_attr_t *restrict attr, void ** restrict stackaddr,size_t *restrict stacksize);
    int pthread_attr_setstack(pthread_attr_t *attr, void *stackaddr,size_t stacksize);

        参数：
            attr：指向待获取/设置的线程属性对象
            pthread_attr_getstack函数，stackaddr：一个指向void*的指针，获取的线程栈的最低地址存放在它指向的内存
            pthread_attr_getstack函数，stacksize：一个指向size_t*的指针，获取的线程栈的大小存放在它指向的内存
            pthread_attr_setstack函数，stackaddr：一个void*，其值就是要设置的线程栈的最低地址
            pthread_attr_setstack函数，stacksize：一个size_t，其值就是要设置的线程栈的大小

        返回值：
            成功：返回0
            失败：返回错误编号

    对于遵守POSIX标准的操作系统来说，并不一定需要支持线程栈属性。对于遵守SUS中XSI选项的系统来说，必须支持线程栈属性。
        可以在编译阶段使用_POSIX_THREAD_ATTR_STACKADDR和_POSIX_THREAD_ATTR_STACKSIZE符号来检查操作系统是否支持线程栈属性
        也可以在运行阶段把_SC_THREAD_ATTR_STACKADDR和_SC_THREAD_ATTR_STACKSIZE选项传递给sysconf参数，检查操作系统是否支持线程栈属性

    对于进程来说，虚拟地址空间的大小是固定的。因为进程中只有一个进程栈，因此其大小通常不是问题。但是对线程来说，同样大小的虚拟地址空间被所有的线程所共享。如果有很多个线程，以至于这些线程栈的总大小超过了可用的虚拟地址空间，则需要减少默认的线程栈大小。

    另外如果线程调用的函数分配了大量的自动变量，或者调用的函数设计很多很深的栈帧，则需要的线程栈大小可能要比默认的大。

    如果线程栈的虚拟地址空间都用完了，那么可以调用malloc或者mmap来为线程栈分配空间，并用pthread_attr_setstack函数来改变新建线程的线程栈的位置。

    stackaddr线程属性被定义为线程栈的最低内存地址。但是这不一定是线程栈的开始位置。
        如果处理器结构的栈是从高地址到低地址方向增长，那么stackaddr将是线程栈的结尾位置
        如果处理器结构的栈是从低地址到高地址方向增长，那么stackaddr将是线程栈的开始位置

    在LINUX上，设置时，stacksize 如果小于PTHREAD_STACK_MIN (16384字节，4*4Kb)，则报错Invalid Argument

    pthread_attr_getstacksize/pthread_attr_setstacksize函数：获取/设置线程的栈大小

    #include<pthread.h>
    int pthread_attr_getstacksize(const pthread_attr_t *restrict attr, size_t *restrict stacksize);
    int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);

        参数：
            attr：指向待获取/设置的线程属性对象
            pthread_attr_getstacksize函数，stacksize：一个指向size_t*的指针，获取的线程栈的大小存放在它指向的内存
            pthread_attr_setstacksize函数，stacksize：一个size_t，其值就是要设置的线程栈的大小

        返回值：
            成功：返回0
            失败：返回错误编号

    如果仅仅希望改变默认线程栈的大小，又不想自己处理线程栈的分配问题，则可以使用pthread_attr_setstacksize函数

        pthread_attr_setstack函数不仅需要设置默认线程栈的大小，还需要分配线程栈的空间

    pthread_attr_getguardsize/pthread_attr_setguardsize函数：获取/设置线程的guardsize属性

    #include<pthread.h>
    int pthread_attr_getguardsize(const pthread_attr_t *restrict attr, size_t *restrict guardsize);
    int pthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize);

        参数：
            attr：指向待获取/设置的线程属性对象
            pthread_attr_getguardsize函数，guardsize：一个指向size_t*的指针，获取的线程栈的guardsize值存放在它指向的内存
            pthread_attr_setguardsize函数，guardsize：一个size_t，其值就是要设置的线程栈的guardsize值

        返回值：
            成功：返回0
            失败：返回错误编号

    一个线程的guardsize属性就是线程栈末尾的警戒缓冲区大小（字节数）。它控制着线程栈末尾之后，用以避免栈溢出的扩展内存大小。这个属性默认值由具体操作系统定义，但通常是系统页大小
        可以将这个值设置为 0 ，表示不提供警戒缓冲区
        如果修改了线程属性stackaddr，则系统认为我们将自己管理线程栈，进而也会使得警戒缓冲区机制无效，这等同于将guardsize属性设为 0

    如果guardsize属性设为非 0 ，则操作系统可能会将它设置为页大小的整数倍。如果线程的栈指针溢出到警戒区域，则应用程序可能通过信号接收到出错信息。

2. 同步属性
2.1 互斥量属性

    互斥量 属性是用pthread_mutexattr_t结构表示的

    pthread_mutexattr_init/pthread_mutexattr_destroy函数：初始化/销毁互斥量 属性

    #include<pthread.h>
    int pthread_mutexattr_init(pthread_mutexattr_t *attr);
    int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);

        参数：
            attr：指向待初始化/销毁的互斥量属性

        返回值：
            成功：返回0
            失败：返回错误编号

    pthread_mutexattr_init将用默认的互斥量属性初始化pthread_mutexattr_t结构。

    互斥量属性最重要的有3个属性：
        进程共享属性：决定了该互斥量是进程共享PTHREAD_PROCESS_SHARED ，还是线程共享PTHREAD_PROCESS_PRIVATE
        健壮属性：它改变了当持有互斥量的进程未释放互斥量就退出时，另一个进程的线程调用pthread_mutex_lock的返回类型
        类型属性：控制了互斥量的锁定属性

    进程共享属性：可以通过静态检查_POSIX_THREAD_PROCESS_SHARED符号是否定义从而判断这个平台是否支持进程共享这个属性。也可以运行时将_SC_THREAD_PROCESS_SHARED传入sysconf函数来动态判断这个平台是否支持进程共享这个属性。

    如果将互斥量用于多线程同步，则互斥量的进程共享属性需要设置为PTHREAD_PROCESS_PRIVATE（默认情况）。

    我们也允许多个进程将同一个内存数据块映射到它们各自独立的地址空间中（即共享内存区）。就像多线程访问共享数据一样，多个进程访问共享数据通常也需要同步。如果互斥量的进程共享属性设置为PTHREAD_PROCESS_SHARED，共享内存区中的数据块中分配的互斥量就可以用于这些进程的同步。

    phtread_mutexattr_getpshared/pthread_mutexattr_setpshared函数：获取/设置互斥量的进程共享属性

    #include<pthread.h>
    int phtread_mutexattr_getpshared(const pthread_mutexattr_t *restrict attr, int *restrict pshared);
    int pthread_mutexattr_setpshared(pthread_mutexattr_t * attr, int pshared);

        参数：
            attr：指向待获取/设置的互斥量属性对象
            phtread_mutexattr_getpshared函数，pshared：一个指向int*的指针，获取的互斥量的进程共享属性的值存放在它指向的内存
            pthread_mutexattr_setpshared函数，pshared：一个int，其值就是要设置的互斥量的进程共享属性

        返回值：
            成功：返回0
            失败：返回错误编号

    我们可以设置pthread_mutexattr_t的进程共享属性为PTHREAD_PROCESS_PRIVATE或者PTHREAD_PROCESS_SHARED

    pthread_mutexattr_getrobust/pthread_mutexattr_setrobust函数：获取/设置互斥量的健壮属性：

    #include<pthread.h>
    int pthread_mutexattr_getrobust(const pthread_mutexattr_t *restrict attr, int *restrict robust);
    int pthread_mutexattr_setrobust(pthread_mutexattr_t * attr, int robust);

        参数：
            attr：指向待获取/设置的互斥量属性对象
            pthread_mutexattr_getrobust函数，robust：一个指向int*的指针，获取的互斥量的健壮属性的值存放在它指向的内存
            pthread_mutexattr_setrobust函数，robust：一个int，其值就是要设置的互斥量的健壮属性

        返回值：
            成功：返回0
            失败：返回错误编号

    健壮属性用于这种情况：在进程间共享互斥量时，如果进程A持有互斥量，而其他进程都因为等待互斥量而投入睡眠。现在进程A没有来得及释放互斥量就异常终止了。问题是谁来唤醒那些因为等待互斥量而睡眠的进程？

    健壮属性有两种取值：
        PTHREAD_MUTEX_STALLED：意味着持有互斥量的进程终止时不需要采取特别的动作（即不需要释放互斥量），此时所有等待该互斥量的进程都将死锁。
        PTHREAD_MUTEX_ROBUST：意味着持有互斥量的进程A终止时，如果进程A并没有释放互斥量，那么进程B的线程调用pthread_mutex_lock时，成功返回，且返回值为EOWNERDEAD（而不是死锁），但是进程B并不会持有锁（此时锁的状态被破坏了，因为锁的持有者死亡了，必须调用下面的pthred_mutex_consistent函数来完修复锁的状态）。

    健壮属性的互斥量改变了我们使用pthread_mutex_lock的方式，因为现在有3类返回值：
        不需要恢复的成功（返回，成功持有锁）
        需要恢复的成功（此时虽然返回，但是并没有持有锁）
        失败

    当 pthread_mutex_lock返回 EOWNERDEAD 时，我们需要调用pthred_mutex_consistent函数从而完成互斥量的owner切换工作。其函数为：

    #include<pthread.h>
    int pthread_mutex_consistent(pthread_mutex_t *mutex);

        参数：
            mutex:指向待设置的互斥量的指针
        返回值：
            成功：返回0
            失败：返回错误编号

    pthread_mutexattr_gettype/pthread_mutexattr_settype函数：获取/设置互斥量的类型属性

    #include<pthread>
    int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict attr, int *restrict type);
    int pthread_mutexattr_settype(pthread_mutexattr_t * attr, int type);

        参数：
            attr：指向待获取/设置的互斥量属性对象
            pthread_mutexattr_gettype函数，type：一个指向int*的指针，获取的互斥量的类型属性的值存放在它指向的内存
            pthread_mutexattr_settype函数，type：一个int，其值就是要设置的互斥量的类型属性

        返回值：
            成功：返回0
            失败：返回错误编号

    POSIX.1定义了四种互斥量类型：
        PTHREAD_MUTEX_NORMAL：一种标准互斥量类型，不做任何特殊的错误检查或死锁检查
        PTHREAD_MUTEX_ERRORCHECK：此类型互斥量进行错误检查
        PTHREAD_MUTEX_RECURSIVE：此类型互斥量运行同一线程在互斥量解锁之前对该互斥量进行多次加锁（维持了一个加锁的计数）。当解锁次数和加锁次数不相同的情况下，并不会释放锁
        PTHREAD_MUTEX_DEFAULT：此类型互斥量提供默认特性和行为。操作系统在实现的时候可以将它映射到上面三类中的任何一种。

    下面是四种互斥量类型的加锁/解锁行为：

	| 互斥量类型 			| 未解锁时重新加锁 	|未占用时解锁 	| 已解锁时再解锁 
	|PTHREAD_MUTEX_NORMAL 	| 死锁 			| 未定义 		| 未定义 
	| PTHREAD_MUTEX_ERRORCHECK	| 返回错误 		| 返回错误 	| 返回错误
	| PTHREAD_MUTEX_RECURSIVE 	| 允许 			| 返回错误 	| 返回错误 
	|PTHREAD_MUTEX_DEFAULT 	| 未定义 			| 未定义 		| 未定义

    通常递归锁很难处理，因此只有在没有其他可行方案的前提下才使用它们。

        在pthread_cond_wait中永远不要使用递归锁。因为如果递归锁多次加锁，则pthread_cond_wait的解锁操作并不能真正的释放锁。

2.2 读写锁属性

    pthread_rwlockattr_init/pthread_rwlockattr_destroy函数：初始化/销毁读写锁属性

    #include<pthread.h>
    int pthread_rwlockattr_init(pthread_rwlockattr_t *attr);
    int pthread_rwlockattr_destroy(pthread_rwlockattr_t *attr);	

        参数：
            attr：指向待初始化/销毁的读写锁属性
        返回值：
            成功：返回0
            失败：返回错误编号

    读写锁支持的唯一属性是进程共享属性。它与互斥量的进程共享属性是相同的。获取/设置这一属性的函数为：

    #include<pthread.h>
    int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t * restrict attr, int *restrict pshared);
    int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *attr, int pshared);

        参数：
            attr：指向待获取/设置的读写锁属性对象
            pthread_rwlockattr_getpshared函数，pshared：一个指向int*的指针，获取的读写锁的进程共享属性的值存放在它指向的内存
            pthread_rwlockattr_setpshared函数，pshared：一个int，其值就是要设置的读写锁的进程共享属性

        返回值：
            成功：返回0
            失败：返回错误编号

    我们可以设置pthread_rwlockattr_t的进程共享属性为PTHREAD_PROCESS_PRIVATE或者PTHREAD_PROCESS_SHARED

    虽然POSIX只定义了一个读写锁属性，但是不同的平台的实现可以自由地定义额外的、非标准的属性

2.3 条件变量属性

    pthread_condattr_init/pthread_condattr_destroy函数：初始化/销毁条件变量属性

    #include<pthread.h>
    int pthread_condattr_init(pthread_condattr_t *attr);
    int pthread_condattr_destroy(pthread_condattr_t *attr);	

        参数：
            attr：指向待初始化/销毁的条件变量属性
        返回值：
            成功：返回0
            失败：返回错误编号

    SUS定义了条件变量的两个属性：
        进程共享属性：条件变量的进程共享属性与互斥量的进程共享属性是相同的。
        时钟属性：控制了计算pthread_cond_timedwait函数的超时参数tsptr时，采用的是哪个时钟

    pthread_condattr_getpshared/pthread_condattr_setpshared函数：获取/设置条件变量的进程共享属性。条件变量的进程共享属性与互斥量的进程共享属性是相同的。

    #include<pthread.h>
    int pthread_condattr_getpshared(const pthread_condattr_t * restrict attr, int *restrict pshared);
    int pthread_condattr_setpshared(pthread_condattr_t *attr, int pshared);

        参数：
            attr：指向待获取/设置的条件变量属性对象
            pthread_condattr_getpshared函数，pshared：一个指向int*的指针，获取的条件变量的进程共享属性的值存放在它指向的内存
            pthread_condattr_setpshared函数，pshared：一个int，其值就是要设置的条件变量的进程共享属性

        返回值：
            成功：返回0
            失败：返回错误编号

    我们可以设置pthread_condattr_t的进程共享属性为PTHREAD_PROCESS_PRIVATE或者PTHREAD_PROCESS_SHARED

    pthread_condattr_getclock/pthread_condattr_setclock函数：获取/设置条件变量的时钟属性：

    #include<pthread.h>
    int pthread_condattr_getclock(const pthread_condattr_t * restrict attr, int *restrict clock_id);
    int pthread_condattr_setclock(pthread_condattr_t *attr, int clock_id);

        参数：
            attr：指向待获取/设置的条件变量属性对象
            pthread_condattr_getclock函数，clock_id：一个指向int*的指针，获取的条件变量的时钟属性的值存放在它指向的内存
            pthread_condattr_setclock函数，clock_id：一个int，其值就是要设置的条件变量的时钟属性
        返回值：
            成功：返回0
            失败：返回错误编号

    clock_id的有效值为：
        CLOCK_REALTIME：实时系统时间
        CLOCK_MONOTONIC：不带负跳数的实时系统时间
        CLOCK_PROCESS_CPUTIME_ID：调用进程的CPU时间
        CLOCK_THREAD_CPUTIME_ID：调用线程的CPU时间

2.4 屏障属性

    pthread_barrierattr_init/pthread_barrierattr_destroy函数：初始化/销毁屏障属性

    #include<pthread.h>
    int pthread_barrierattr_init(pthread_barrierattr_t *attr);
    int pthread_barrierattr_destroy(pthread_barrierattr_t *attr);	

        参数：
            attr：指向待初始化/销毁的屏障属性
        返回值：
            成功：返回0
            失败：返回错误编号

    屏障支持的唯一属性是进程共享属性。它与互斥量的进程共享属性是相同的。获取/设置这一属性的函数为：

    #include<pthread.h>
    int pthread_barrierattr_getpshared(const pthread_barrierattr_t * restrict attr, int *restrict pshared);
    int pthread_barrierattr_setpshared(pthread_barrierattr_t *attr, int pshared);

        参数：
            attr：指向待获取/设置的屏障属性对象
            pthread_barrierattr_getpshared函数，pshared：一个指向int*的指针，获取的屏障的进程共享属性的值存放在它指向的内存
            pthread_barrierattr_setpshared函数，pshared：一个int，其值就是要设置的屏障的进程共享属性

        返回值：
            成功：返回0
            失败：返回错误编号

    我们可以设置pthread_barrierattr_t的进程共享属性为PTHREAD_PROCESS_PRIVATE或者PTHREAD_PROCESS_SHARED

3. 线程重入

    线程在遇到重入问题时，与信号处理程序是类似的：
        如果一个函数在相同的时间点，可以被多个线程安全的调用，则称该函数是线程安全的
        操作系统实现如果支持线程安全函数这个特性，那么对于POSIX.1中的那些非线程安全函数，操作系统会提供可替代的线程安全版本。线程安全函数版本的命名方式与它们的非线程安全版本的名字相似，只是在名字最后加了_r，以表明这些版本是可重入的
        通过静态检查符号_POSIX_THREAD_SAFE_FUNCTIONS可以静态检查操作系统释放支持线程安全函数这个特性；或者在sysconf函数传入_SC_THREAD_SAFE_FUNCTIONS参数可以动态检查操作系统释放支持线程安全函数这个特性

    如果一个函数是线程安全的，那么这并不能说明对于信号处理程序来说，该函数也是可重入的。
        如果函数对于异步信号处理程序的重入是安全的，那么就说该函数是异步信号安全的。

    由于FILE对象内部有缓冲区，因此FILE对象不是线程安全的。为了在线程中安全的使用FILE对象，POSIX提供了线程安全的方式管理FILE对象。
        ftrylockfile/flockfile函数：用于为FILE对象上锁
        funlockfile函数：用于为FILE对象解锁

    FILE对象的锁是递归锁。当你持有锁时，可以重复加锁。只有解锁的次数和加锁的次数一致时，锁才会被释放。

    ftrylockfile/flockfile/funlockfile函数：为FILE对象加锁/解锁

    #include<stdio.h>
    int ftrylockfile(FILE *fp);
    void flockfile(FILE *fp);
    void funlockfile(FILE *fp);

        参数：
            fp：指向待加锁/解锁的对象
        ftrylockfile返回值：
            成功：返回0
            如果不能获取锁，则返回非 0 值

    当处理多个FILE对象时，需要注意潜在的死锁，需要对所有的锁仔细排序

    对于线程可重入版本的标准IO函数，标准IO函数都首先对FILE加锁，然后操作完成后再对FILE解锁。那么在进行一次一个字符的IO时，就会出现严重的性能下降。此时提供了不加锁版本的基于字符的标准IO函数：

    #include<stdio.h>
    int getchar_unlocked(void);
    int getc_unlocked(FILE *fp);
    int putchar_unlocked(int c);
    int putc_unlocked(int c,FILE *fp);

        参数：
            fp：指向待处理的FILE对象
            c：待写入的字符
        返回值：
            get...函数：成功则返回下一个字符；如果出错或者遇到文件尾，则返回EOF
            put...函数：成功则返回c；如果出错则返回EOF

    除非被flockfile/ftrylockfile和funlockfile调用包围，否则尽量不要直接调用这四个函数，因为它们会导致不可预期的结果（如多个线程非同步访问FILE引起的种种问题）

    一旦对FILE加锁，那么可以在释放锁之前对上述四个函数进行多次调用，从而在多次的数据读写上分摊总的加锁/解锁的开销。（这就是需要将无锁版本暴露出来的原因：分摊开销）

4. 线程特定数据

    线程特定数据也称作线程私有数据，是存储和查询某个线程相关数据的一种机制。我们采用线程特定数据的原因是：我们希望每个线程都可以访问线程各自独立的数据副本，而不需要担心与其他线程的同步问题。因为：
        有时候需要维护基于线程的数据
        线程特定数据让基于进程的接口适应于多线程环境。比如errno：为了让线程中可以使用原本基于进程的系统调用和库例程，errno被重新定义为线程私有数据。这样一个线程中做了重置errno的操作也不会影响进程中其它线程的errno值

    进程中的所有线程都可以访问这个进程的地址空间，线程特定数据也不例外。因此虽然底层的实现并不能阻止一个线程去访问另一个线程的线程私有数据，但是使用了管理线程私有数据的函数可以提供线程之间的数据独立性，使得线程不太容易访问到其他线程的线程私有数据。

        简单地说：只要你一致性的使用管理线程私有数据的函数来访问线程私有数据，那么就可以保证线程之间不会访问其他线程的线程私有数据

    在分配线程私有数据之前，需要创建与该数据关联的键。这个键的作用是：获取对线程私有数据的访问。

    pthread_key_create函数：创建线程私有数据的键

    #include<pthread.h>
    int pthread_key_create(pthread_key_t *keyp,void (*destructor)(void*));

        参数：
            keyp：指向键的指针
            destructor：一个函数指针，该函数返回void，参数是void*。该函数是键的析构函数。
        返回值：
            成功：返回0
            失败：返回错误编号

    当创建键时，这个键可以被进程中的所有线程使用，但是每个线程把这个键绑定了不同的私有数据。
        创建新键时，每个线程未绑定私有数据

        绑定的私有数据的类型是 (void *)。你可以传入一个整数；如果数据较多你可以传入一个结构体的指针。

    除了创建键以外，你也可以选择为键提供一个可选的析构函数。当线程退出时，如果键绑定了私有数据，则析构函数会被调用。
        析构函数的唯一参数就是键绑定的私有数据
        如果传入的析构函数为空，则表明没有析构函数与这个键关联

    析构函数被调用的情形：
        如果线程是调用pthread_exit或者线程例程中返回，则退出时，析构函数会被调用
        如果线程是被取消的，则在线程最后的清理处理程序返回值后，析构函数才会被调用
        如果线程调用了exit、_ext、_Exit、abort或者其他非正常的退出时，不会调用析构函数

    为们要提供析构函数？因为线程通常使用malloc为线程私有数据分配内存。析构函数通常释放已分配的内存。如果线程在没有释放内存之前就退出了，那么这块内存就会泄露。

    线程可以为线程私有数据分配多个键
        每个键都可以有一个析构函数与之关联。
        每个键的析构函数都可以互不相同，当然也可以使用相同的析构函数
        操作系统可以对进程可分配的键的数量进行限制（PTHREAD_KEYS_MAX）

    线程退出时，线程私有数据的析构函数将按照操作系统实现中定义的顺序被调用。注意：
        析构函数中可能会调用另一个函数，这个函数可能会创建新的线程私有数据的，并把这个数据绑定当前的键
        当所有的析构函数都调用完成后，系统会检查是否还有线程私有数据绑定了键；如果有的话，再次调用析构函数
        这个过程会一直重复到所有的键都未绑定线程私有数据，或者已经做了PTHREAD_DESTRUCTOR_ITERATIONS中定义的最大次数的尝试

    对所有的线程，我们可以调用pthread_key_delete来取消键与线程私有数据值之间绑定

    #include<pthread.h>
    int pthread_key_delete(pthread_key_t key);

        参数：
            key：键
        返回值：
            成功：返回0
            失败：返回错误编号

    注意：调用pthread_key_delete并不会激活与键关联的析构函数。

    pthread_once函数：

    #include<pthread.h>
    pthread_once_t initflag=PTHREAD_ONCE_INIT;
    int pthread_once(pthread_once_t *initflag,void (*initfn)(void));

        参数：
            initflag：它指向一个pthread_once_t变量，该变量必须是个全局变量或者静态变量（即非局部变量），且该变量必须初始化为PTHREAD_ONCE_INIT
            initfn：初始化例程
        返回值：
            成功：返回0
            失败：返回错误编号

    如果每个线程都调用pthread_once，那么系统就能够保证初始化例程initfn只会被调用一次，即系统首次调用pthread_once时。

    pthread_setspecific/pthread_getspecific函数：将键与线程私有数据绑定 / 根据键获取它绑定的线程私有数据

    #include<pthread.h>
    void *pthread_getspecific(pthread_key_t key);
    int pthread_setspecific(pthread_key_t key,const void*value);

        参数：
            key：键
            value：绑定的线程私有数据

        返回值：
            pthread_getspecific：返回绑定的线程私有数据；如果没有线程私有数据与该键绑定，则返回NULL
            pthread_setspecific：成功：返回0；失败：返回错误编号

    通常我们可以通过pthread_getspecific返回的值是否为NULL来判断键上是否解除绑定了线程私有数据。

        注意到这里绑定的线程私有数据类型为void *。所以，理论上我们可以绑定一个整数-1（一个有效的数字），但是其(void*)转换后恰好是NULL，pthread_getspecific返回的结果就是NULL。事实上这就是我们故意设置的一个整数值。所以格式转换要注意！

5. 取消选项

    有两个线程属性并没有包含在pthread_attr_t结构中：
        可取消状态
        可取消类型

    可取消状态：

    当线程A对线程B调用pthread_cancel时，线程B不一定终止。在默认情况下，线程B在取消请求发出以后还是继续运行，直到线程达到某个取消点。

    取消点是线程B检查它是否被取消的一个位置。如果取消了，则按照请求行事。POSIX.1给出了一个函数列表，当线程B调用该列表中的任何一个函数时，取消点都会出现。

    线程B启动的默认的可取消状态是PTHREAD_CANCEL_ENABLE。此时，一旦线程B到达取消点时，线程B会执行取消操作。

    如果线程B的可取消状态设置为PTHREAD_CANCEL_DISABLE，则对线程B调用pthread_cancel并不会杀死线程。相反，对线程B来说，取消请求还是处于挂起的状态。当线程B的可取消状态再次变成PTHREAD_CANCEL_ENABLE时，线程B将在下一个取消点上对所有的挂起的取消请求进行处理。

    如果线程B在很长的一段时间内都不会调用哪个函数列表中指定的函数（也就是不会遇到取消点），你可以自动调用pthread_testcancel函数来在线程中手动添加自己的取消点：

    pthread_testcancel函数：手动添加取消点

    #include<pthread.h>
    void pthread_testcancel(void);

    pthread_setcancelstate函数：设置线程的可取消状态

    #include<pthread.h>
    int pthread_setcancelstate(int state,int *oldstate);

        参数：
            state：即将被设置的线程的可取消状态
            oldstate：线程的原有的可取消状态存放在它指向的内存
        返回值：
            成功：返回0
            失败：返回错误编号

    函数将当前的可取消状态设置为state，将原来的可取消状态存储在由oldstate指向的内存单元。这两步是一个原子操作。

    state可选的两个值：
        PTHREAD_CANCEL_ENABLE：可取消
        PTHREAD_CANCEL_DISABLE： 不可取消

    我们之前描述的默认的取消类型是“延迟取消”。即线程A对线程B调用pthread_cancel之后，在线程B达到取消点之前，并不会出现真正的取消。我们也可以调用pthread_setcanceltype来修改取消类型。

    pthread_setcanceltype函数：修改取消类型

    #include<pthread.h>
    int pthread_setcanceltype(int type,int *oldtype);

        参数：
            type：即将被设置的线程的取消类型
            oldtype：线程的原有的取消类型存放在它指向的内存
        返回值：
            成功：返回0
            失败：返回错误编号

    函数将当前的取消类型设置为type，将原来的取消类型存储在由oldtype指向的内存单元。这两步是一个原子操作。

    type可选的两个值：
        PTHREA_CANCEL_DEFERRED：延迟取消
        PTHREAD_CANCEL_ASYNCHRONOUS： 异步取消。此时线程可以在任意时间取消，不是非的遇到取消点才能被取消

6. 线程和信号

    每个线程都有自己的信号屏蔽字，但是信号的处理是进程中所有线程共享的
        这意味着单个线程可以阻止某些信号，但是当某个线程修改了与某个给定信号相关的处理行为以后，所有的线程必须共享这个处理行为的改变

    进程中的信号是递送到单个线程中的
        如果一个信号与硬件故障相关，那么该信号一般会被发送到引发该事件的线程中去
        其他的信号则被发送到任意一个线程

    在进程中可以使用sigprocmask来修改进程的信号屏蔽字。但是sigprocmask的行为在多线程中是未定义的。线程必须使用pthread_sigmask。

    pthread_sigmask函数：修改线程的信号屏蔽字

    #include<signal.h>
    int pthread_sigmask(int how,const sigset_t *restrict set,sigset_t *restrict oset);

        参数：
            how:如果set是非空指针，则它结合set一起指示了如何修改线程的当前信号屏蔽字
            set:如果set是非空指针，则它结合how一起指示了如何修改线程的当前信号屏蔽字
            oset:如果是非空指针，则线程的前信号屏蔽字通过它返回
        返回值：
            成功：返回0
            失败：返回错误编号

    如果set是非空指针，则它结合how一起指示了如何修改线程的当前信号屏蔽字
        how=SIG_BLOCK：该线程的新的信号屏蔽字是其当前信号屏蔽字和set指向的信号集的并集。即set包含了希望阻塞的信号
        how=SIG_UBBLOCK：该线程的新的信号屏蔽字是其当前信号屏蔽字和set指向的信号集补集的交集。即set包含了希望解除阻塞的附加信号
        how=SIG_SETMASK：该线程的新的信号屏蔽字是set指向的值

    如果set是空指针，则不改变线程的信号屏蔽字，how的值没有任何意义

    线程可以通过sigwait来等待一个或者多个信号的出现：

    #include<signal.h>
    int sigwait(const sigset_t *restrict set,int *restrict signop);

        参数：
            set：指定了线程等待的信号集
            signop：返回时，它指向的整数将包含发送信号的数量
        返回值：
            成功：返回0
            失败：返回错误编号

    如果信号集set中的某个信号在调用sigwait时处于挂起状态，那么sigwait将无阻塞地返回。在返回之前，sigwait将从进程中移除那些处于挂起状态的信号。如果具体实现支持排队信号，并且信号的多个实例被挂起，那么sigwait将会移除该信号的一个实例，其他的实例还要继续排队。

    为了避免错误行为发生，线程在调用sigwait之前，必须阻塞那些它正在等待的信号。sigwait函数会原子地取消set信号集中信号的阻塞状态，直到有新的信号被递送。在返回之前，sigwait将恢复线程的信号屏蔽字。

    sigwait的好处在于：它简化了信号处理。它把异步产生的信号用同步的方式处理。为了防止信号中断线程，你可以将信号加到每个线程的信号屏蔽字中，然后可以安排专门的线程处理信号。这些专用线程可以进行函数调用，而不使用信号处理程序那一套机制。因此也不用担心调用哪些函数是安全的。

    如果多个线程在sigwait的调用中因为等待同一个信号而被阻塞，那么在信号递送的时候，就只有一个线程可以从sigwait中返回。如果一个信号被捕获（如进程通过调用sigaction建立了一个信号处理程序），而某个线程正在用sigwait调用来等待该信号，那么将由操作系统来决定以何种方式递送信号
        操作系统可以让sigwait返回，也可以激活信号处理程序。但是这二者不会同时发生。

    要把信号发送给线程，可以用pthread_kill

    #include<signal.h>
    int pthread_kill(pthread_t thread,int signo);

        参数：
            thread：接收信号的线程
            signo：信号的编号
        返回值：
            成功：返回0
            失败：返回错误编号

    可以传入一个 0 值的signo来检查线程是否存在。如果某个信号的默认处理动作是终止该进程，则将该信号传递给某个线程仍然会杀死整个进程。

    闹钟定时器是进程资源，并且所有的线程都共享相同的闹钟。所以进程中的多个线程不可能互不干扰的使用闹钟定时器。

7. 线程和 fork

    在多线程的环境中，当父进程的某个线程调用fork时，为子进程创建了整个进程地址空间的副本。
        子进程通过继承整个地址空间的副本，还从父进程那儿继承了每个互斥量、读写锁和条件变量的状态
        如果父进程包含了一个以上的线程，则子进程内部，只存在一个线程，它是由父进程中调用fork的线程的副本构成的

    如果父进程中的线程占有锁，子进程将同样占有这些锁。问题是子进程并不包含占有锁的线程的副本。所以子进程没有办法知道它占有了哪些锁、需要释放哪些锁。所以子进程从fork返回以后马上调用exec族函数就可以避免锁的问题，因为这种情况下，旧的地址空间被丢弃，锁的状态就无所谓了。

    在多线程的进程中，为了避免不一致的问题，POSIX.1声明，在fork返回和子进程调用exec族函数之间，子进程只能调用异步信号安全的函数。
        这限制了在调用exec之前子进程能做什么，但是不涉及子进程中锁的状态问题
        要想清除锁的状态，可以通过调用pthread_atfork函数建立fork处理程序

    pthread_atfork 函数：建立fork处理程序

    #include<pthread.h>
    int pthread_atfork(void (*prepare)(void),void (*parent)(void),void (*child)(void));

        参数：
            prepare：一个函数指针。该函数在父进程fork创建子进程之前调用
            parent:一个函数指针。该函数在fork返回之前在父进程的上下文中调用
            child：一个函数指针。该函数在fork返回之前在子进程的上下文中调用
        返回值：
            成功：返回0
            失败：返回错误编号

    pthread_atfork是父进程在调用fork之前调用的。它给出了fork前后可以执行的三个清理函数。你可以在其中清理锁。此时：
        在prepare处理程序中获取所有的锁（因此潜在的条件是：所有使用这些锁的线程都释放了锁）
        在parent处理程序中释放锁
        在child处理程序中释放锁

    可以多次调用pthread_atfork函数从而设置多套fork处理程序。如果你不需要使用其中某个处理程序，可以给特定的处理程序参数传入空指针。
        多个fork处理程序时，处理程序的调用顺序并不相同：
            parent和child处理程序是以它们注册时的顺序进行调用的
            prepare处理程序是以它们注册时的逆序进行调用的
        这样安排的目的是：保持锁的层次。

    虽然可以通过fork处理程序来清理锁的状态，但是目前不存在清理条件变量的方法。

8. 线程和IO

    在多线程的环境中，进程中的所有线程共享相同的文件描述符。因此pread（原子定位读）和pwrite（原子定位写）这两个方法在多线程的环境下非常有用。

mythreaddetached.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

void pr_threadattr(const pthread_attr_t* pattr) {
	int detachstate, err;
	size_t guardsize;
	size_t stacksize;
	
	if ((err = pthread_attr_getdetachstate(pattr, &detachstate)) != 0)
		return;
	if ((err = pthread_attr_getguardsize(pattr, &guardsize)) != 0)
		return;
	if ((err = pthread_attr_getstacksize(pattr, &stacksize)) != 0)
		return;
	printf("Thread state: %s\n", detachstate == PTHREAD_CREATE_DETACHED ?
		"Detached" : "Joinable");
	printf("Thread guardsize: %ld\n", guardsize);
	printf("Thread stacksize: %ld\n", stacksize);
}

int makeThread(void* (*func)(void*), void* args) {
	pthread_attr_t attr;
	pthread_t thd;
	int err;

	if ((err = pthread_attr_init(&attr)) != 0)
		return err;
	if ((err = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED)) == 0)
		if ((err = pthread_attr_setstacksize(&attr, 40960)) == 0)
			err = pthread_create(&thd, &attr, func, args);
	pr_threadattr(&attr);
	pthread_attr_destroy(&attr);
	return err;
}

void* thread_func(void* args) {
	printf("Thread(0x%lx) begin\n", pthread_self());
	sleep(1);
	printf("Thread(0x%lx) end\n", pthread_self());
	pthread_exit((void*)NULL);
}

int main(void)
{
	int err;

	printf("Main thread begin\n");
	if((err=makeThread(thread_func,(void*)NULL))!=0)
		printf("%d, %s\n", err,"makeThread error");
	sleep(2);
	printf("Main thread end\n");

	exit(EXIT_SUCCESS);
}

mythreadrobust.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

pthread_mutex_t lock;
pthread_mutexattr_t mutexattr;

void* thread_func1(void* args) {
	pthread_mutex_lock(&lock);
	printf("thread(0x%lx) locks mutex but doesn't unlock it\n",
		pthread_self());
	return (void*)NULL;
}

void* thread_func2(void* args) {
	int err;

	while ((err = pthread_mutex_lock(&lock)) != 0) {
		if (err == EOWNERDEAD) {
			/* 若先不执行pthread_mutex_consistent函数，则当前线程是无法对
				一个死亡线程持有的健壮互斥量进行恢复*/
			if (pthread_mutex_consistent(&lock) != 0)
				err_sys("pthread_mutex_consistent error\n");
			if (pthread_mutex_unlock(&lock) != 0)
				err_sys("pthread_mutex_unlock error\n");
			printf("thread(0x%lx) restore the lock\n", pthread_self());
		}
		else
			err_sys("pthread_mutex_lock error\n");
	}
	printf("thread(0x%lx) get in critical zone\n", pthread_self());
	pthread_mutex_unlock(&lock);
	return (void*)NULL;
}

int makeDetachedThread(void* (*thread_func)(void*), void* args) {
        pthread_attr_t attr;
        pthread_t tid;
        int err;

        if ((err = pthread_attr_init(&attr)) != 0)
                return err;
        if ((err = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED)) == 0)
                err = pthread_create(&tid, &attr, thread_func, args);
        pthread_attr_destroy(&attr);
        return err;
}

int main(void)
{
	int err;

	if ((err = pthread_mutexattr_init(&mutexattr)) != 0)
		printf("%d, %s\n", err, "pthread_mutexattr_init error");
	if ((err = pthread_mutexattr_setrobust(&mutexattr, PTHREAD_MUTEX_ROBUST)) != 0)
		printf("%d, %s\n", err, "pthread_mutex_setrobust error");
	if ((err = pthread_mutex_init(&lock, &mutexattr)) != 0)
		printf("%d, %s\n", err, "pthread_mutex_init error");

	makeDetachedThread(thread_func1, (void*)NULL);
	makeDetachedThread(thread_func2, (void*)NULL);

	sleep(1);
	exit(EXIT_SUCCESS);
}

mythreadnorecursive.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

typedef struct X {
	pthread_mutex_t lock;
	void* saved;
	int value;
}X;


int Xinit(X* x, pthread_mutexattr_t* mutexattr) {
	x->value = 0;
	x->saved = NULL;
	return pthread_mutex_init(&x->lock, mutexattr);
}


void Xdestroy(X* x) {
	pthread_mutex_destroy(&x->lock);
}

void func2_locked(X* x) {
	x->value++;
}


void func2(X* x) {
	pthread_mutex_lock(&x->lock);
	x->value++;
	pthread_mutex_unlock(&x->lock);
}


void func1(X* x) {
	pthread_mutex_lock(&x->lock);
	x->value++;
	func2_locked(x);
	pthread_mutex_unlock(&x->lock);
}


void* thread_func(void* args) {
	X* x = (X*)args;

	printf("Thread(0x%lx) begin\n", pthread_self());
	func1(x);
	printf("Thread(0x%lx) end\n", pthread_self());
	pthread_exit((void*)NULL);
}

int main(void)
{
	pthread_t tid;
	int err;
	X* x;

	if ((x = malloc(sizeof(X))) == NULL)
		return -1;
	if ((err = Xinit(x, NULL)) != 0) {
		free(x);
		printf("%d, %s\n", err, "Xinit error");
	}

	pthread_create(&tid, NULL, thread_func, (void*)x);
	pthread_join(tid, NULL);
	printf("final value in x: %d\n", x->value);

	Xdestroy(x);
	free(x);
	exit(EXIT_SUCCESS);
}

mythreadrecursive1.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

typedef struct X {
	pthread_mutex_t lock;
	void* saved;
	int value;
}X;

int Xinit(X* x, pthread_mutexattr_t* attr) {
	int err;

	x->value = 0;
	x->saved = (void*)NULL;
	err = pthread_mutex_init(&x->lock, attr);
	return err;
}


void Xdestroy(X* x) {
	pthread_mutex_destroy(&x->lock);
}

void func2(X* x) {
	pthread_mutex_lock(&x->lock);
	x->value++;
	pthread_mutex_unlock(&x->lock);
}


void func1(X* x) {
	pthread_mutex_lock(&x->lock);
	x->value++;
	func2(x);
	pthread_mutex_unlock(&x->lock);
}


void* thread_func(void* args) {
	X* x = (X*)args;

	printf("Thread(0x%lx) begin\n", pthread_self());
	func1(x);
	sleep(1);
	printf("Thread(0x%lx) end\n", pthread_self());
	pthread_exit((void*)NULL);
}

int main(void)
{
	pthread_mutexattr_t mutexattr;
	pthread_t tid;
	int err;
	X* x;

	//预处理互斥量属性和互斥量
	if ((x = malloc(sizeof(X))) == NULL)
		return -1;
	if ((err = pthread_mutexattr_init(&mutexattr)) != 0) {
		free(x);
		printf("%d, %s\n", err, "pthread_mutex_init error");
	}
	if ((err = pthread_mutexattr_settype(&mutexattr, PTHREAD_MUTEX_RECURSIVE)) != 0) {
		free(x);
		printf("%d, %s\n", err, "pthread_mutexattr_settype error");
	}
	if ((err = Xinit(x, &mutexattr)) != 0) {
		free(x);
		printf("%d, %s\n", err, "Xinit error");
	}

	//创建线程并执行回收
	pthread_create(&tid, NULL, thread_func, (void*)x);
	pthread_join(tid, NULL);
	printf("final value in x: %d\n", x->value);
	
	//尾处理
	Xdestroy(x);
	pthread_mutexattr_destroy(&mutexattr);
	free(x);
	exit(EXIT_SUCCESS);
}

mythreadrecursive2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int makeDetachedThread(void* (*thread_func)(void*), void* args) {
        pthread_attr_t attr;
        pthread_t tid;
        int err;

        if ((err = pthread_attr_init(&attr)) != 0)
                return err;
        if ((err = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED)) == 0)
                err = pthread_create(&tid, &attr, thread_func, args);
        pthread_attr_destroy(&attr);
        return err;
}

typedef struct to_info {
	void (*to_func)(void*);
	void* to_args;
	struct timespec when;
}to_info;


pthread_mutex_t lock;
pthread_mutexattr_t mutexattr;


/*
	超时后线程执行的函数例程
*/
void* timeout_helper(void* args) {
	to_info* tip = (to_info*)args;

	printf("timeout_helper begin\n");
	clock_nanosleep(CLOCK_REALTIME, 0, &tip->when, NULL);
	tip->to_func(tip->to_args);
	free(args);
	printf("timeout_helper end\n");

	pthread_exit((void*)NULL);
}


/*
	定时设定函数
*/
void timeout(const struct timespec* when, void (*pf)(void*), void* args) {
	to_info* tip;
	int err;

	if (when->tv_sec > 0 || when->tv_nsec > 0) {
		if ((tip = malloc(sizeof(to_info))) != NULL) {
			tip->to_func = pf;
			tip->to_args = args;
			tip->when.tv_sec = when->tv_sec;
			tip->when.tv_nsec = when->tv_nsec;

			if ((err = makeDetachedThread(timeout_helper, (void*)tip)) != 0)
				free(tip);
			else return;
		}
	}
	pf(args);
}


/*
	超时后执行的函数操作	
*/
void retry(void* args) {
	pthread_mutex_lock(&lock);
	/*
		do sth
	*/
	printf("value of args: %d\n", (*(int*)args)++);

	pthread_mutex_unlock(&lock);
}


int main(void)
{
	int err, condition, args;
	struct timespec when;

	if ((err = pthread_mutexattr_init(&mutexattr)) != 0)
		printf("%d, %s\n", err, "pthread_mutexattr_init error");
	if ((err = pthread_mutexattr_settype(&mutexattr, PTHREAD_MUTEX_RECURSIVE)) != 0)
		printf("%d, %s\n", err, "pthread_mutexattr_settype error");
	if ((err = pthread_mutex_init(&lock, &mutexattr)) != 0)
		printf("%d, %s\n", err, "pthread_mutex_init error");

	condition = 1;
	args = 233;
	pthread_mutex_lock(&lock);
	if (condition) {
		when.tv_sec = 5; when.tv_nsec = 0;
		timeout(&when, retry, (void*)&args);
	}
	pthread_mutex_unlock(&lock);

	/*
		some process...
	*/
	printf("main thread is still running...\n");

	sleep(6);
	printf("result value of args: %d\n", args);
	pthread_mutexattr_destroy(&mutexattr);
	pthread_mutex_destroy(&lock);
	exit(EXIT_SUCCESS);
}

mythreadgetenv1.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define BUFSIZE 4096

/*
        一种非线程安全获取环境变量值的getenv函数实现
*/
static char envbuf[BUFSIZE];
extern char** environ;

char* mygetenv(const char* name) {
        size_t len = strlen(name);

        for (int i = 0; environ[i] != NULL; ++i) {
                if (strncmp(environ[i], name, len) == 0 && environ[i][len] == '=') {
                        strncpy(envbuf, &environ[i][len + 1], BUFSIZE);
                        return envbuf;
                }
        }
        return NULL;
}

int makeDetachedThread(void* (*thread_func)(void*), void* args) {
        pthread_attr_t attr;
        pthread_t tid;
        int err;

        if ((err = pthread_attr_init(&attr)) != 0)
                return err;
        if ((err = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED)) == 0)
                err = pthread_create(&tid, &attr, thread_func, args);
        pthread_attr_destroy(&attr);
        return err;
}

void* thread_func(void* args) {
	const char* name = (char*)args;
	int i = 100;

	while (i--)
		printf("thread(0x%lx): %s = %s\n", pthread_self(),
			name, mygetenv(name));
	return (void*)NULL;
}

int main(int argc, char* argv[])
{
	if (argc < 2)
		err_sys("usage: find <NAME...>");

	for (int i = 1; i < argc; ++i)
		makeDetachedThread(thread_func, (void*)argv[i]);
	sleep(1);

	return 0;
}

mythreadgetenv2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define MYBUFSIZE 1024

/*
        具有线程安全性且异步信号安全的getenv函数实现
*/
pthread_mutex_t env_mutex;

static pthread_once_t init_done = PTHREAD_ONCE_INIT;

static void env_mutexinit(void) {
        pthread_mutexattr_t mutexattr;

        pthread_mutexattr_init(&mutexattr);
        //这里不适用递归锁，也可以保证mygetenv_r函数具有线程安全性，但则并不能保证异步信号安全
        pthread_mutexattr_settype(&mutexattr, PTHREAD_MUTEX_RECURSIVE);
        pthread_mutex_init(&env_mutex, &mutexattr);
        pthread_mutexattr_destroy(&mutexattr);
}

extern char** environ;

int mygetenv_r(const char* name, char* buf, int buflen) {
        int len, keylen;

        len = strlen(name);
        //只有最初执行的线程会对执行env_mutexinit例程，后面的线程不会执行之
        pthread_once(&init_done, env_mutexinit);
        pthread_mutex_lock(&env_mutex);
        for (int i = 0; environ[i] != NULL; ++i) {
                if (strncmp(name, environ[i], len) == 0 && environ[i][len] == '=') {
                        keylen = strlen(&environ[i][len + 1]);
                        if (keylen >= buflen) {
                                pthread_mutex_unlock(&env_mutex);
                                return ENOSPC;
                        }
                        else {
                                strncpy(buf, &environ[i][len + 1], buflen);
                                pthread_mutex_unlock(&env_mutex);
                                return 0;
                        }
                }
        }
        pthread_mutex_unlock(&env_mutex);
        return ENOENT;
}


int makeDetachedThread(void* (*thread_func)(void*), void* args) {
        pthread_attr_t attr;
        pthread_t tid;
        int err;

        if ((err = pthread_attr_init(&attr)) != 0)
                return err;
        if ((err = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED)) == 0)
                err = pthread_create(&tid, &attr, thread_func, args);
        pthread_attr_destroy(&attr);
        return err;
}

void* thread_func(void* args) {
	const char* name = (const char*)args;
	char buf[MYBUFSIZE];
	int err;

	for (int i = 0; i < 100; i++) {
		if ((err = mygetenv_r(name, buf, MYBUFSIZE)) != 0)
			pthread_exit((void*)NULL);
		printf("thread(0x%lx): %s = %s\n", pthread_self(), name, buf);
	}
	pthread_exit((void*)NULL);
}


int main(int argc, char* argv[]) {
	if (argc < 2)
		err_sys("usage: find <NAME...>");

	for (int i = 1; i < argc; ++i)
		makeDetachedThread(thread_func, (void*)argv[i]);
	sleep(1);

	exit(EXIT_SUCCESS);
}

mythreadputenv.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

extern char** environ;


inline static size_t NameLen(const char* str) {
	size_t len = 0;

	for (; *str != '='; ++str) {
		if (*str == '\0')return 0;
		++len;
	}
	return len;
}


inline static size_t environSize(char* const* env) {
	size_t sz = 0;

	for (; env[sz] != NULL; ++sz);
	return sz;
}


int myputenv(const char* str) {
	char** newenv;
	char* newstr;
	size_t oldenvlen;
	size_t namelen;
	size_t strsz;

	if ((namelen = NameLen(str)) == 0)
		return -1;
	strsz = strlen(str);
	for (int i = 0; environ[i] != NULL; ++i) {
		/*
			若原本存在该变量
		*/
		if (strncmp(str, environ[i], namelen) == 0 && environ[i][namelen] == '=') {
			if (strlen(environ[i]) >= strsz) {
				strcpy(&environ[i][namelen + 1], &str[namelen + 1]);
			}
			else {
				if ((newstr = malloc(sizeof(char) * (strsz + 1))) == NULL)
					return -1;
				strcpy(newstr, str);
				environ[i] = newstr;
			}
			return 0;
		}
	}

	/*
		若原本不存在该变量
	*/
	oldenvlen = environSize(environ);
	if ((newenv = malloc(sizeof(char*) * (oldenvlen + 2))) == NULL)
		return -1;
	if ((newstr = malloc(sizeof(char) * (strsz + 1))) == NULL) {
		free(newenv);
		return -1;
	}
	memcpy(newenv, environ, sizeof(char*) * oldenvlen);
	strcpy(newstr, str);
	newenv[oldenvlen] = newstr;
	newenv[oldenvlen + 1] = NULL;
	environ = newenv;
	return 0;
}


int main(void)
{
	myputenv("USER=MYDAD");
	myputenv("PATH=(null)");
	myputenv("SHOW=CODE");
	myputenv("LS_COLORS=(null)");
	myputenv("HELLO=WORLD");
	for (int i = 0; environ[i] != NULL; ++i)
		printf("%s\n", environ[i]);

	return 0;
}

mythreadkey.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define DEBUG
#define MAXSTRINGSZ 1024

static pthread_key_t key;
static pthread_once_t once_done;
pthread_mutex_t env_lock = PTHREAD_MUTEX_INITIALIZER;

extern char** environ;

static void Free(void* p) {
	printf("free\n");
	free(p);
}

static void key_init(void) {
#ifdef DEBUG
	pthread_key_create(&key, Free);
#else
	pthread_key_create(&key, free);
#endif
}


/*
	具有线程安全但不具有异步信号安全性的getenv函数实现，
	之所以不具有异步信号安全性是由于malloc本身就不是异步
	信号安全函数
*/
char* Getenv(const char* name) {
	size_t len;
	char* envbuf;

	pthread_once(&once_done, key_init);
	pthread_mutex_lock(&env_lock);
	if ((envbuf = pthread_getspecific(key)) == NULL) {
#ifdef DEBUG
		printf("thread(0x%lx) malloc and set specific key\n", pthread_self());
#endif
		//线程创建一个线程私有数据然后与键key相关联
		envbuf = malloc(sizeof(char) * MAXSTRINGSZ);
		if (envbuf == NULL) {
			pthread_mutex_unlock(&env_lock);
			return NULL;
		}
		pthread_setspecific(key, envbuf);
	}

	len = strlen(name);
	for (int i = 0; environ[i] != NULL; ++i) {
		if (strncmp(name, environ[i], len) == 0 && environ[i][len] == '=') {
			strncpy(envbuf, &environ[i][len + 1], MAXSTRINGSZ);
			pthread_mutex_unlock(&env_lock);
			return envbuf;
		}
	}
	pthread_mutex_unlock(&env_lock);
	return NULL;
}


int makeDetachedThread(void* (*thread_func)(void*), void* args) {
        pthread_attr_t attr;
        pthread_t tid;
        int err;

        if ((err = pthread_attr_init(&attr)) != 0)
                return err;
        if ((err = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED)) == 0)
                err = pthread_create(&tid, &attr, thread_func, args);
        pthread_attr_destroy(&attr);
        return err;
}

void* thread_func(void* args) {
	const char* name = (const char*)args;

	for (int i = 0; i < 100; i++)
		printf("thread(0x%lx): %s = %s\n", pthread_self(),
			name, Getenv(name));
	pthread_exit((void*)NULL);
}


int main(int argc, char* argv[])
{
	if (argc < 2)
		err_sys("usage: find <NAME>");

	for (int i = 1; i < argc; ++i)
		makeDetachedThread(thread_func, (void*)argv[i]);
	sleep(1);
	exit(EXIT_SUCCESS);
}

mythreadsigmask.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int quitflag;
sigset_t mask;

pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t waitloc = PTHREAD_COND_INITIALIZER;


/*
	专门处理信号的线程
*/
void* thread_func(void* args) {
	int err, signo;

	while (1) {
		//解除对SIGINT/SIGQUIT信号的阻塞，并处理这两个信号
		if ((err = sigwait(&mask, &signo)) != 0)
			printf("%d, %s\n", err, "sigwait error");
		switch (signo) {
		case SIGINT:
			printf("interrupt\n");
			break;
		case SIGQUIT:
			pthread_mutex_lock(&lock);
			quitflag = 1;
			pthread_mutex_unlock(&lock);
			pthread_cond_signal(&waitloc);
			return (void*)NULL;
		default:
			printf("unexpected signal %d\n", signo);
			exit(EXIT_FAILURE);
		}
	}
}

int main(void)
{
	pthread_t tid;
	sigset_t oldmask;
	int err;

	sigemptyset(&mask);
	sigaddset(&mask, SIGINT);
	sigaddset(&mask, SIGQUIT);
	if ((err = pthread_sigmask(SIG_BLOCK, &mask, &oldmask)) != 0)
		printf("%d, %s\n", err, "pthread_sigmask");

	//新建线程会继承创建者线程的信号屏蔽字
	pthread_create(&tid, NULL, thread_func, (void*)NULL);

	pthread_mutex_lock(&lock);
	while (quitflag == 0)
		pthread_cond_wait(&waitloc, &lock);
	pthread_mutex_unlock(&lock);
	quitflag = 0;

	if (sigprocmask(SIG_SETMASK, &oldmask, NULL) < 0)
		err_sys("sigprocmask error\n");
	exit(EXIT_SUCCESS);
}

mythreadatfork1.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

pthread_mutex_t lock1;
pthread_mutex_t lock2;

void prepare(void) {
	int err;

	printf("preparing locks...\n");
	if ((err = pthread_mutex_lock(&lock1)) != 0)
		printf("%d, %s\n", err, "can't lock lock1 in prepare handler");
	if ((err = pthread_mutex_lock(&lock2)) != 0)
		printf("%d, %s\n", err, "can't lock lock2 in prepare handler");
	printf("all locks locked\n");
}

void parent(void) {
	int err;

	printf("parent unlocking locks...\n");
	if ((err = pthread_mutex_unlock(&lock1)) != 0)
		printf("%d, %s\n", err, "can't unlock lock1 in parent handler");
	if ((err = pthread_mutex_unlock(&lock2)) != 0)
		printf("%d, %s\n", err, "can't unlock lock2 in parent handler");
	printf("parent unlocks all locks\n");
}

void child(void) {
	int err;

	printf("child unlocking locks...\n");
	if ((err = pthread_mutex_unlock(&lock1)) != 0)
		printf("%d, %s\n", err, "can't unlock lock1 in child handler");
	if ((err = pthread_mutex_unlock(&lock2)) != 0)
		printf("%d, %s\n", err, "can't unlock lock2 in child handler");
	printf("child unlocks all locks\n");
}

void* thread_func(void* args) {
	printf("thread(0x%lx) begin\n", pthread_self());
	pthread_mutex_lock(&lock1);
	sleep(1);
	pthread_mutex_unlock(&lock1);
	printf("thread(0x%lx) end\n", pthread_self());

	return (void*)NULL;
}

int main(void)
{
	int err;
	pid_t pid;
	pthread_t tid;

	/*
		fork处理程序可以使得当某一个线程需要fork出一个新进程的时候，必须执行pthread_atfork中
		注册的fork处理程序，先对进程中所有的互斥量进行加锁，然后再fork子进程，等创建完成之后父
		子进程都知道需要对进程中所有的锁进行解锁，这样就避免了子进程不知道需要对哪些锁进行解锁
		操作的麻烦
	*/
	if ((err = pthread_atfork(prepare, parent, child)) != 0)
		printf("%d, %s\n", err, "pthread_atfork error");
	if ((err = pthread_create(&tid, NULL, thread_func, (void*)NULL)) != 0)
		printf("%d, %s\n", err, "pthread_create error");

	sleep(1);
	printf("parent about to fork...\n");

	if ((pid = fork()) < 0)
		err_sys("fork failed\n");
	else if (pid == 0)
		printf("child return from fork\n");
	else
		printf("parent returned from fork\n");
	printf("process(%d) end\n", getpid());

	exit(EXIT_SUCCESS);
}

mythreadatfork2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

pthread_mutex_t mutex1 = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t mutex2 = PTHREAD_MUTEX_INITIALIZER;

static void prepare(void)
{
	int err;
	printf("preparing locks......\n");
	if((err = pthread_mutex_lock(&mutex1)) != 0){
		perror("prepare pthread_mutex_lock mutex1 error");
	}
	if((err = pthread_mutex_lock(&mutex2)) != 0){
		perror("prepare pthread_mutex_lock mutex2 error");
	}
}

static void parent(void)
{
	int err;
	printf("parent unlock1......\n");
	if((err = pthread_mutex_unlock(&mutex1)) != 0){
		perror("parent pthread_mutex_unlock mutex1 error");
	}
	printf("parent unlock2......\n");
	if((err = pthread_mutex_unlock(&mutex2)) != 0){
		perror("parent pthread_mutex_unlock mutex2 error");
	}	
}

static void child(void)
{
	int err;
	printf("child unlock1......\n");
	if((err = pthread_mutex_unlock(&mutex1)) != 0){
		perror("child pthread_mutex_unlock mutex1 error");
	}
	printf("child unlock2......\n");
	if((err = pthread_mutex_unlock(&mutex2)) != 0){
		perror("child pthread_mutex_unlock mutex2 error");
	}	
}

void *thr_fn(void *arg)
{
	printf("thread start......\n");
	pause();
	return((void *)0);
}

int main(int argc, char const *argv[])
{
	int 		err;
	pid_t		pid;
	pthread_t   tid;

	if((err = pthread_atfork(prepare, parent, child)) != 0){
		perror("pthread_atfork error");
		return -1;
	}

	if((err = pthread_create(&tid, NULL, thr_fn, 0)) != 0){
		perror("pthread_create error");
		return -1;
	}
	sleep(2);
	printf("ready to call fork......\n");
	if((pid = fork()) < 0){
		perror("fork error");
		return -1;
	}else if(pid == 0){
		printf("running child process......\n");
	}else{
		printf("running father process......\n");
	}
	return 0;
}

mythreadflockfile.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define LOOPTIME 100

int makeDetachedThread(void* (*thread_func)(void*), void* args) {
        pthread_attr_t attr;
        pthread_t tid;
        int err;

        if ((err = pthread_attr_init(&attr)) != 0)
                return err;
        if ((err = pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED)) == 0)
                err = pthread_create(&tid, &attr, thread_func, args);
        pthread_attr_destroy(&attr);
        return err;
}

void* thread_func(void* args) {
	/*在当前线程获得FILE对象相关联的锁后，该线程可以保证
		只有线程自身能够有机会向该FILE对象输出数据*/
	flockfile(stdout);
	//flockfile(stdout);
	for (int i = 0; i < LOOPTIME; ++i)
		printf("thread(0x%lx) output %2d\n", pthread_self(), i);
	//funlockfile(stdout);
	funlockfile(stdout);

	return (void*)NULL;
}


int main(int argc,char*argv[])
{
	int err;
	int tc = 5;
	if (argc == 2)
		tc = atoi(argv[1]);

	for (int i = 0; i < tc; i++) {
		if ((err = makeDetachedThread(thread_func, (void*)NULL)) != 0)
			printf("%d, %s\n", err, "makeDetachedThread error");
	}
	sleep(1);
	exit(EXIT_SUCCESS);
}

守护进程
1. 守护进程

    守护进程daemon：生存期长的一种进程
        它们经常在系统引导启动时启动，仅在系统关闭时终止
        它们没有控制终端，因此是在后台运行的
        UNIX系统有很多守护进程，它们执行日常事务活动

    常见的守护进程：

        通过ps命令可以查看系统的各个进程。选项-a显示所有用户的进程；-x显示没有控制终端的进程；-j显示与作业有关的信息

        kthreadd守护进程：是其他内核进程的父进程。

            内核进程是特殊的，它存在于操作系统的整个生命周期中。它们以超级用户特权运行，无控制终端，无命令行

        常用的内核守护进程有：
            kswapd守护进程：内存换页守护进程。它支持虚拟内存子系统在经过一段时间后将脏页面慢慢写回磁盘来回收这些页面。
            flush守护进程：在可用内存达到设置的最小阈值时，将脏页面冲洗至磁盘。它也定期地将脏页面冲洗回磁盘来减少在系统出现故障时发生数据丢失。
                多个flush守护进程可以同时存在，每个写回设备都有一个flush守护进程
            sync_supers守护进程：定期将文件系统元数据冲洗至磁盘
            jbd守护进程：辅助实现了ext4文件系统中的日志功能

        init守护进程：系统守护进程。主要负责启动个运行层次特定的系统服务。这些服务通常是在它们自己拥有的守护进程的帮助下实现的。

        rpcbind守护进程：提供将远程过程调用RPC程序号映射为网络端口号的服务

        rsyslogd守护进程：提供系统消息日志管理服务

        inetd守护进程：侦听网络接口，以便取得来自网络的对各种网络服务进程的请求

        cron守护进程：定期安排的日期和时间来执行命令

        atd守护进程：类似cron，但是它只允许每个任务执行一次，而不是周期性的反复执行

        cupsd守护进程：打印假脱机进程，它处理对系统提出的各个打印请求

        sshd守护进程：提供了安全的远程登录和执行设施

    大多数守护进程都是以root特权运行
        所有的守护进程都没有控制终端，在ps显示的信息中，其终端名为问号
            内核守护进程以无终端的方式启动
            用户层守护进程通过调用setsid来设置无终端
        大多数用户层守护进程都是进程组的组长进程，以及会话的首进程，而且是这些进程组和会话中的唯一进程
        用户层守护进程的父进程是init进程

    编写守护进程时需要遵循一些基本规则，以防止产生不必要的交互（如信号处理，终端处理等）
        首先调用umask将文件模式创建屏蔽字设置为一个已知值（通常是0）

        因为继承而来的文件模式创建屏蔽字很可能会被设置为拒绝某些权限。如果守护进程要创建文件，那么它可能需要设置特定的权限。

        然后调用fork，然后使父进程exit。这样做实现了下面几点：
            如果该守护进程是作为一条简单shell命令启动的，那么父进程终止会让shell认为这条命令已经执行完毕
            虽然子进程继承了父进程的进程组ID，但是获得了一个新的进程ID，这就保证了子进程不是一个进程组的组长ID，这就是后面的setsid调用的先决条件

        然后调用setsid创建一个新会话。执行完setsid之后，调用进程将成为新会话的首进程，而且它也是一个新进程组的组长进程，同时没有控制终端

        将当前工作目录改为根目录/

            这是因为守护进程要求在系统重启/关闭之前是一直存在的。所以如果守护进程的当前工作目录在一个挂载的文件系统中，则该文件系统就不能被卸载。而从父进程中继承过来的当前工作目录可能就在一个挂在的文件系统中。

        当然某些守护进程可能会将当前工作目录更改到某个指定位置（不一定是/）

        关闭不再需要的文件描述符。这使得守护进程不再持有从其父进程继承而来的任何文件描述符。

            可以先判断最高文件描述符值，然后关闭直到该值的所有描述符

        某些守护进程打开/dev/null/使其具有文件描述符0,1,2。这样任何试图读标准输入、写标准输出、写标准错误的库例程都不会产生任何效果。

            因为守护进程并不与任何终端关联，所以其输出无处显示，也无法获得用户的输入。

2. 出错记录

    守护进程的一个问题是如何处理出错信息。因为守护进程没有控制终端，所以不能只是简单的写到标准错误上。BSD的syslog设施提供了一个解决方案：

    有三种产生日志消息的方式：
        内核例程可以调用log函数来产生日志消息。
            任何一个用户进程都可以通过打开并读取/dev/klog设备来读取这些内核日志消息
        大多数用户进程（包括收获进程）调用syslog函数来产生日志消息。这些消息被发送至UNIX域数据包套接字/dev/log
        无论一个用户进程是在当前主机，还是通过TCP/IP网络连接到此主机上，都可以将日志消息发送到UDP端口号514。

        syslog函数并不产生这些UDP数据报，你必须显式的进行网络编程

    通常syslogd守护进程读取所有三种格式的日志信息。此守护进程在启动时读取一个配置文件，文件名一般为/etc/syslog.conf，该文件决定了不同种类的消息应该送往何处。

    syslog设施的接口函数如下：

    #include<syslog.h>
    void openlog(const char *ident,int option,int facility);
    void syslog(int priority,const char *format,...);
    void closelog(void);
    int setlogmask(int maskpri);

        openlog函数用于打开设施。该函数是可选的，如果你不调用openlog，则在第一次调用syslog时自动调用openlog。其参数为：

            ident：一个前缀字符串。这个字符串将被追加到每条日志消息中。通常用程序的名字来做ident

            option：指定各种选项的位屏蔽。可以为以下常量或者按位或：
                LOG_CONS：若日志消息不能通过UNIX域数据报发送至syslogd，则将该消息写到控制台
                LOG_NDELAY：立即打开到syslogd守护进程的UNIX域数据报套接字，而不要等到第一条消息已经被记录时才打开
                LOG_NOWAIT：不要等待在将消息记入日志过程中可能已创建的子进程
                LOG_ODELAY：延迟打开到syslogd守护进程的UNIX域数据报套接字，直到第一条消息已经被记录时才打开
                LOG_PERROR：除了将日志消息发送给syslogd以外，还将它写到标准出错
                LOG_PID：记录的每条消息都要包含进程ID

            facility：指定消息类别。提供该参数的原因是为了让syslogd的配置文件说明：来自不同设施的不同类别信息将以不同的方式进行处理。

                如果不调用openlog，则默认facility=0

            常用的为：
                LOG_AUDIT：审计设施
                LOG_AUTH：授权程序
                LOG_CONSOLE：消息写入/dev/console
                LOG_CRON：cron和at
                LOG_DAEMON：系统守护进程，如inetd,routed等
                LOG_FTP：ftpd守护进程
                LOG_KERN：内核产生的消息
                LOG_MAIL：邮件系统
                LOG_SYSLOG：syslogd本身产生的信息
                LOG_USER：由其他用户进程的消息（默认）

        closelog函数用于关闭设施。该函数也是可选的，它只是关闭那个用于与syslogd守护进程通信的描述符（由openlog打开的）。

        syslog函数调用是，会产生一条日志消息。其参数为：
            priority：优先级参数。它是facility和level的组合。level值按照优先级从高到低依次为：
                LOG_EMERG：紧急（系统不可使用）（最高优先级）
                LOG_ALERT：必须立即修复的情况
                LOG_CRIT：严重情况（如硬件设备出错）
                LOG_ERR：出错情况
                lOG_WARNING：警告情况
                LOG_NOTICE：正常但是重要的情况
                LOG_INFO：信息性消息
                LOG_DEBUG：调试消息（最低优先级）
            format以及其他参数：被传递到vsprintf函数以便进行格式化。在format中，每个出现的%m字符串都先被替代成errno值对应的出错消息字符串（相当于替代成了strerror(errno)）

        setlogmask函数用于设置进程的记录优先级屏蔽字。它返回调用它之前的屏蔽字。

        当设置了记录优先级屏蔽字时，各条信息除非已经在记录优先级屏蔽字中进行了设置，否则将不被记录。

            试图将记录优先级屏蔽字设置为 0 并没有什么卵用

    通常如果我们在openlog()函数中，指定了一个非零的facility，则在syslog()函数中，priority可以仅仅提供level。如果我们没有调用openlog()，或者以facility=0调用openlog()，则我们在syslog()函数中，priority可以必须提供level和facility的或值。

    大多数syslog的实现将消息短时间内处于队列中。如果在这段时间内，有重复消息到达，那么syslog守护进程并不会将重复的信息写入到日志记录中，而是会打印输出一条类似“上一条消息重复了 N 次”的消息。

3. 单例守护进程

    为了正常运行，某些守护进程要求实现为单例模式：任何时刻只能运行一个该守护进程。

    为了创建单例守护进程，可以使用文件和记录锁。
        如果为守护进程创建一个固定名字的文件，并且在该文件的整体上加一把写锁，那么只允许创建一把这样的写锁。在此之后创建写锁的任何尝试都将失败。
        如果某个守护进程对该文件创建写锁失败，则说明已经存在了一个守护进程的副本
        当持有文件写锁的守护进程终止时，这把锁将被自动删除

    UNIX守护进程遵循下列通用惯例：

        如果守护进程使用锁文件，则该文件通常存储于/var/run目录中。锁文件的名字通常是name.pid，其中name是该守护进程或者服务的名字

            守护进程可能需要具有超级用户的权限才能在此目录下创建文件

        如果守护进程支持配置选项，则配置文件通常存在于/etc目录下。配置文件的名字通常是name.conf，其中name是该守护进程或者服务的名字

        守护进程可以用命令行启动，但是通常它们是由系统初始化脚本之一（/etc/rc*或者/etc/init.d/*）启动的

        如果在守护进程终止时，需要自动重启它，则我们可以在/etc/inittab中为该守护进程包括respawn记录项，这样init将会重启该守护进程

        如果一个守护进程有一个配置文件，则当该守护进程启动时会读取该文件，但在此之后一般就不再查看该文件了。

        如果后来管理员修改了配置文件，那么你可以先停止守护进程，然后重启守护进程。

        为了避免这种麻烦，某些守护进程将捕捉SIGHUP信号。当它们接收到SIGHUP信号时，会重新读取配置文件。

            因为守护进程没有终端，因此守护进程并不期望收到SIGHUP。所以用SIGHUP作为守护进程的配置文件变更的信号是合适的

mydaemon1.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define ERROR_EXIT(m)\
do\
{\
    perror(m);\
    exit(EXIT_FAILURE);\
}\
while(0)


static void daemonize(const char *cmd)
{
	int i, fd0, fd1, fd2;
	pid_t pid;
	struct rlimit rl;
	struct sigaction sa;
	/* 清除文件掩模和改变工作目录 */
	umask(0);
	if(chdir("/") < 0)
		ERROR_EXIT("chdir error");

	/* 获取文件描述符上限并关闭所有文件描述符 */
	if(getrlimit(RLIMIT_NOFILE, &rl) < 0)
		ERROR_EXIT("getrlimit error");
	if(rl.rlim_max == RLIM_INFINITY)
		rl.rlim_max = 1024;
	for(i=0; i<rl.rlim_max; i++)
		close(i);

	/* 第一次fork父进程退出,子进程脱离当前控制终端 */
	if((pid = fork()) < 0)
		ERROR_EXIT("first fork error");
	else if(pid > 0)
		exit(0);

	/* 子进程成为会话组长 */
	setsid();

	/* 处理SIGHUP信号 */
	sa.sa_handler = SIG_IGN;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;
	if(sigaction(SIGHUP, &sa, NULL) < 0)
		ERROR_EXIT("sigaction error");

	/* 第二次fork子进程退出,孙进程不再是会话组长,无权开启终端(与终端彻底隔离) */
	if((pid = fork()) < 0)
		ERROR_EXIT("second fork error");
	else if(pid > 0)
		exit(0);

	/* 将 0,1,2重定向到/dev/null */
	fd0 = open("/dev/null", O_RDWR);
	fd1 = dup(0);
	fd2 = dup(0);

	/* 初始化log file */
	openlog(cmd, LOG_CONS, LOG_DAEMON);
	if(fd0 != 0 || fd1 != 1 || fd2 != 2){
		syslog(LOG_ERR, "unexpected file descriptors %d %d %d", fd0, fd1, fd2);
		exit(1);
	}
}

int main(int argc, char const *argv[])
{
	daemonize("hello stone");
	sleep(60);
	return 0;
}

mydaemon2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

void daemonize(const char* cmd) {
	struct rlimit rl;
	struct sigaction sa;
	int fd0, fd1, fd2;
	pid_t pid;

	//1、设置文件模式创建屏蔽字
	umask(0);
	if (getrlimit(RLIMIT_NOFILE, &rl) < 0) {
		printf("%s: can't get file limit", cmd); exit(1);
	}
	//2、调用fork，将父进程exit
	if ((pid = fork()) < 0) {
		printf("%s: can't fork", cmd); exit(1);
	}
	else if (pid > 0)
		exit(EXIT_SUCCESS);
	//3、调用setsid创建一个新的会话
	setsid();

	//4、新进程组（此时只有一个进程，即是会话首进程），先注册信号处理程序，
	//   防止进程组过会成为孤儿进程组时子子进程收到systemd的SIGHUP信号而终止
	sa.sa_handler = SIG_IGN;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;
	if (sigaction(SIGHUP, &sa, NULL) != 0) {
		printf("%s: can't ignore SIGHUP", cmd); exit(1);
	}
	//5、再次创建一个新子进程，这个子进程绝对不会是会话首进程，因此不能获得
	//	 控制终端
	if ((pid = fork()) < 0) {
		printf("%s: can't fork", cmd); exit(1);
	}
	else if (pid > 0)
		exit(EXIT_SUCCESS);

	//6、改变工作目录为/
	if (chdir("/") != 0) {
		printf("%s: can't chdir", cmd); exit(1);
	}
	if (rl.rlim_max == RLIM_INFINITY)
		rl.rlim_max = 1024;
	//7、关闭所有不需要的文件描述符
	for (int i = 0; i < rl.rlim_max; ++i)
		close(i);

	//8、使stdout、stdin、stderr指向/dev/null
	fd0 = open("/dev/null", O_RDWR);
	fd1 = dup(fd0);
	fd2 = dup(fd0);

	//9、初始化log文件
	openlog(cmd, LOG_CONS, LOG_DAEMON);
	if (fd0 != 0 || fd1 != 1 || fd2 != 2) {
		syslog(LOG_ERR, "unexpected file descritors %d %d %d",
			fd0, fd1, fd2);
		exit(EXIT_FAILURE);
	}
}


int main(void)
{
	daemonize("date");
	pause();
}

mydaemon3.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define LOGFILE "/tmp/logfile"

void daemonize(const char* cmd) {
	struct rlimit rl;
	struct sigaction sa;
	int fd0, fd1, fd2;
	pid_t pid;

	//1、设置文件模式创建屏蔽字
	umask(0);
	if (getrlimit(RLIMIT_NOFILE, &rl) < 0) {
		printf("%s: can't get file limit", cmd); exit(1);
	}
	//2、调用fork，将父进程exit
	if ((pid = fork()) < 0) {
		printf("%s: can't fork", cmd); exit(1);
	}
	else if (pid > 0)
		exit(EXIT_SUCCESS);
	//3、调用setsid创建一个新的会话
	setsid();

	//4、新进程组（此时只有一个进程，即是会话首进程），先注册信号处理程序，
	//   防止进程组过会成为孤儿进程组时子子进程收到systemd的SIGHUP信号而终止
	sa.sa_handler = SIG_IGN;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;
	if (sigaction(SIGHUP, &sa, NULL) != 0) {
		printf("%s: can't ignore SIGHUP", cmd); exit(1);
	}
	//5、再次创建一个新子进程，这个子进程绝对不会是会话首进程，因此不能获得
	//	 控制终端
	if ((pid = fork()) < 0) {
		printf("%s: can't fork", cmd); exit(1);
	}
	else if (pid > 0)
		exit(EXIT_SUCCESS);

	//6、改变工作目录为/
	if (chdir("/") != 0) {
		printf("%s: can't chdir", cmd); exit(1);
	}
	if (rl.rlim_max == RLIM_INFINITY)
		rl.rlim_max = 1024;
	//7、关闭所有不需要的文件描述符
	for (int i = 0; i < rl.rlim_max; ++i)
		close(i);

	//8、使stdout、stdin、stderr指向/dev/null
	fd0 = open("/dev/null", O_RDWR);
	fd1 = dup(fd0);
	fd2 = dup(fd0);

	//9、初始化log文件
	openlog(cmd, LOG_CONS, LOG_DAEMON);
	if (fd0 != 0 || fd1 != 1 || fd2 != 2) {
		syslog(LOG_ERR, "unexpected file descritors %d %d %d",
			fd0, fd1, fd2);
		exit(EXIT_FAILURE);
	}
}

int main(int argc, char* argv[])
{
	char* username;
	char* cmd;
	FILE* fp;

	if ((cmd = strrchr(argv[0], '/')) == NULL)
		cmd = argv[0];
	else
		cmd++;

	daemonize(cmd);
	username = getlogin();
	if ((fp = fopen(LOGFILE, "w")) != NULL) {
		if (username == NULL)
			fprintf(fp, "no login name\n");
		else
			fprintf(fp, "login name: %s\n", username);
		fclose(fp);
	}

	exit(EXIT_SUCCESS);
}

mydaemon4.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int main(void)
{
	setlogmask(LOG_UPTO(LOG_WARNING));
	errno = EACCES;
	openlog("test", LOG_PERROR, LOG_DAEMON);
	openlog("test notice", LOG_PERROR, LOG_DAEMON);
	syslog(LOG_ERR, "log from test: %m");
	syslog(LOG_INFO, "log from notice: %m");
	closelog();
	exit(EXIT_SUCCESS);
}

mydaemon5.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define DEBUG
#define LOCKFILE "/tmp/daemon.pid"
#define LOCKMODE (S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)

int lock_reg(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        return fcntl(fd, cmd, &flockbuf);
}

#define write_lock(fd, offset, whence, len) lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define lockfile(fd) write_lock((fd), 0, SEEK_SET, 0)

int already_running(void) {
	int fd;
	char buf[16];

	openlog("already_running", LOG_PERROR, LOG_DAEMON);
	fd = open(LOCKFILE, O_RDWR | O_CREAT, LOCKMODE);
	if (fd < 0) {
		syslog(LOG_ERR, "open error");
		exit(EXIT_FAILURE);
	}

	//使用文件锁，使得只有单个守护进程副本能够访问同一个文件
	if (lockfile(fd) < 0) {
		if (errno == EACCES || errno == EAGAIN) {
			close(fd);
#ifdef DEBUG
			fprintf(stderr, "lockfile error: %s\n", strerror(errno));
#endif
			return 1;
		}
		syslog(LOG_ERR, "can't lock %s: %m", LOCKFILE);
		exit(EXIT_FAILURE);
	}
	ftruncate(fd, 0);
	sprintf(buf, "%d", getpid());
	write(fd, buf, strlen(buf) + 1);
	return 0;
}


int main(void)
{
	pid_t pid;

	if ((pid = fork()) < 0)
		err_sys("fork error");
	else if (pid == 0) {
		sleep(1);
		printf("child: %d\n", getpid());
		already_running();
	}
	else {
		printf("parent: %d\n", getpid());
		already_running();
		if (waitpid(pid, NULL, 0) != pid)
			err_sys("waitpid error");
	}

	exit(EXIT_SUCCESS);
}

mydaemon6.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define LOCKFILE "/tmp/mytestdaemon.pid"
#define CONFFILE "/tmp/mytestdaemon.conf"
#define LOGFILE "/tmp/mytestdaemon.outfile"
#define DEFAULTMODE (S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)
#define LOCKMODE (S_IRUSR|S_IWUSR|S_IRGRP|S_IROTH)

#define DEBUG
#ifdef BUFSIZE
#undef BUFSIZE
#define BUFSIZE 256
#endif

sigset_t mask;
char daemonbuf[BUFSIZE];


/**
 * 守护进程重读配置文件
 */
void reread(void) {
	int fd;
	int err;

	if ((fd = open(CONFFILE, O_RDONLY)) < 0) {
		syslog(LOG_INFO, "reread can't open CONFFILE");
		strcpy(daemonbuf, "NULL");
		daemonbuf[4] = '\0';
		close(fd);
		return;
	}
	if ((err = read(fd, daemonbuf, BUFSIZE - 1)) < 0) {
		syslog(LOG_WARNING, "read of reread error");
		strcpy(daemonbuf, "NULL");
		daemonbuf[4] = '\0';
		close(fd);
		return;
	}
	daemonbuf[err] = '\0';
	close(fd);
}


/**
 * 守护进程中专门处理信号的线程函数
 * @param args 不使用
 * @return 无太多意义
 */
void* sigthread(void* args) {
	int err, signo;

	while (1) {
		if ((err = sigwait(&mask, &signo)) != 0) {
			syslog(LOG_ERR, "sigwait failed");
			exit(EXIT_FAILURE);
		}
		switch (signo) {
		case SIGHUP:
			syslog(LOG_INFO, "Re-reading configuration file");
			reread();
			break;
		case SIGQUIT:
			syslog(LOG_INFO, "got SIGTERM: exiting");
			exit(EXIT_SUCCESS);
		default:
			syslog(LOG_INFO, "unexpected singal %d\n", signo);
		}
	}
	return (void*)NULL;
}

void daemonize(const char* cmd) {
	struct rlimit rl;
	struct sigaction sa;
	int fd0, fd1, fd2;
	pid_t pid;

	//1、设置文件模式创建屏蔽字
	umask(0);
	if (getrlimit(RLIMIT_NOFILE, &rl) < 0) {
		printf("%s: can't get file limit", cmd); exit(1);
	}
	//2、调用fork，将父进程exit
	if ((pid = fork()) < 0) {
		printf("%s: can't fork", cmd); exit(1);
	}
	else if (pid > 0)
		exit(EXIT_SUCCESS);
	//3、调用setsid创建一个新的会话
	setsid();

	//4、新进程组（此时只有一个进程，即是会话首进程），先注册信号处理程序，
	//   防止进程组过会成为孤儿进程组时子子进程收到systemd的SIGHUP信号而终止
	sa.sa_handler = SIG_IGN;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;
	if (sigaction(SIGHUP, &sa, NULL) != 0) {
		printf("%s: can't ignore SIGHUP", cmd); exit(1);
	}
	//5、再次创建一个新子进程，这个子进程绝对不会是会话首进程，因此不能获得
	//	 控制终端
	if ((pid = fork()) < 0) {
		printf("%s: can't fork", cmd); exit(1);
	}
	else if (pid > 0)
		exit(EXIT_SUCCESS);

	//6、改变工作目录为/
	if (chdir("/") != 0) {
		printf("%s: can't chdir", cmd); exit(1);
	}
	if (rl.rlim_max == RLIM_INFINITY)
		rl.rlim_max = 1024;
	//7、关闭所有不需要的文件描述符
	for (int i = 0; i < rl.rlim_max; ++i)
		close(i);

	//8、使stdout、stdin、stderr指向/dev/null
	fd0 = open("/dev/null", O_RDWR);
	fd1 = dup(fd0);
	fd2 = dup(fd0);

	//9、初始化log文件
	openlog(cmd, LOG_CONS, LOG_DAEMON);
	if (fd0 != 0 || fd1 != 1 || fd2 != 2) {
		syslog(LOG_ERR, "unexpected file descritors %d %d %d",
			fd0, fd1, fd2);
		exit(EXIT_FAILURE);
	}
}

int singleDaemon(const char* file) {
        int fd;
        char buf[16];

        if ((fd = open(file, O_CREAT | O_RDWR, LOCKMODE)) < 0) {
                syslog(LOG_ERR, "can't open lockfile %s: %m", file);
                exit(EXIT_FAILURE);
        }

        if (lockfile(fd) < 0) {
                if (errno == EACCES || errno == EAGAIN) {
                        close(fd);
#ifdef DEBUG
                        fprintf("process %d can't lock this file\n", getpid());
#endif
                        return 1;
                }
                syslog(LOG_ERR, "can't lock %s: %m", file);
                exit(EXIT_FAILURE);
        }
        ftruncate(fd, 0);
        sprintf(buf, "%d", getpid());
        write(fd, buf, strlen(buf) + 1);
        return 0;
}

int main(int argc, char* argv[])
{
	struct sigaction sa;
	pthread_t thd;
	char* cmd;
	int err;
	int fd;

	if ((cmd = strrchr(argv[0], '/')) == NULL)
		cmd = argv[0];
	else
		cmd++;

	//守护进程初始化，并确保只有单实例守护进程副本在运行
	daemonize(cmd);
	if (singleDaemon(LOCKFILE) != 0) {
		syslog(LOG_ERR, "daemon already running");
		exit(EXIT_FAILURE);
	}

	//使守护进程恢复对SIGHUP的默认处理动作，主线程阻塞所有信号，
	//但是专门处理信号的线程会处理之
	sa.sa_handler = SIG_DFL;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;
	sigfillset(&mask);
	if (sigaction(SIGHUP, &sa, NULL) != 0) {
		printf("%s: can't restore SIGHUP default", cmd); exit(1);
	}
	if ((err = pthread_sigmask(SIG_BLOCK, &mask, NULL)) != 0) {
		printf(err, "SIG_BLOCK error"); exit(1);
	}

	//创建处理信号的线程
	if ((err = pthread_create(&thd, NULL, sigthread, (void*)NULL)) != 0) {
		printf(err, "can't create thread"); exit(1);
	}

	//持续将conf文件中的数据输出到log文件
	if ((fd = open(LOGFILE, O_CREAT | O_WRONLY | O_TRUNC, DEFAULTMODE)) < 0) {
		printf("%s: can't open LOFILE", cmd); exit(1);
	}
	reread();
	while (1) {
		write(fd, daemonbuf, strlen(daemonbuf));
		sleep(10);
	}

	exit(EXIT_SUCCESS);
}

高级 IO
非阻塞 IO

    非阻塞IO能够使得我们可以在执行open、read、write等操作时永远不会阻塞。如果这些操作不能立即完成，则调用立即返回失败。

    对于一个给定的描述符，有两种方法为其指定非阻塞IO的方法：
        对于尚未打开的描述符，如果调用open获取描述符，则可以对open函数指定O_NONBLOCK标志
        对于已经打开的描述符，则可以调用fcntl函数，通过该函数打开O_NONBLOCK文件状态标志

            fcntl(fd,F_SETFL,O_NONBLOCK)

    有时我们可以将应用程序设计成多线程的，从而避免使用非阻塞IO。我们在单个线程中执行IO调用阻塞，但是在另外线程中可以继续执行。
        这种方法的优点是能简化应用程序的设计
        缺点是：线程间的同步开销有时候可能增加复杂性

记录锁

    当多个进程同时修改同一个文件时，该文件的最后状态取决于写该文件的最后一个进程。记录锁record locking的功能是：当第一个进程正在读或者修改文件的某个部分时，使用记录锁可以阻止其他进程修改同一个文件区。

        其实UNIX文件并没有记录这个概念，更合适的称呼是“字节范围锁”

    POSIX.1中，通过fcntl设置文件记录锁：

    #include<fcntl.h>
    int fcntl(int fd,int cmd,.../*struct flock *flockptr */);

        参数：
            fd：待处理的文件描述符
            cmd：指示操作的命令常量
            flockptr：指向struct flock的指针，用于加锁

        返回值：
            成功：返回值依赖于cmd
            失败：返回 -1

        fcntl的其他功能参见第三章“文件IO”

    对于记录锁，cmd可以为：
        F_GETLK：判断由flockptr所描述的锁能否顺利创建（如果不满足互斥规则，则无法创建）
            如果无法顺利创建，则将现有的锁（它阻止了flockptr所描述的锁的创建）的信息重写入flockptr指向的内存
            如果可以顺利创建，则将flockptr结构的l_type设置为F_UNLCK，其他信息保持不变

            如果l_type本身就是F_UNLCK，则F_GETLK会失败，errno报告为Invalid Argument

        F_SETLK：设置由flockptr所描述的锁。如果不满足兼容性规则从而无法加锁，则fcntl会立即失败返回，此时errno设置为EACCESS或者EAGAIN
            如果flockptr的l_type为F_UNLCK，则为清除由flockptr所描述的锁
        F_SETLKW：这个命令是F_SETLK的阻塞版本。W表示wait。
            如果所请求的读锁或者写锁因为另一个进程对当前锁的请求区域的某个部分已经进行了加锁而不能完成，则调用线程会被设置为睡眠。
            如果请求创建的锁已经可用，或者休眠由信号中断，则该进程被唤醒。

    flock结构为：

    struct flock{
    	short l_type;// 指示锁的类型，如F_RDLCK(共享性读锁),F_WRLCK(独占性写锁),F_UNLCK(解锁)
    	short l_whence;// 指示锁的相对位置，如 SEEK_SET,SEEK_CUR,SEEK_END
    	off_t l_start; // 锁的起点相对于相对位置的字节数
    	off_t l_len;   // 锁的长度，0表示锁的长度直到 EOF
    	pid_t l_pid;   // 由 F_GETLK 返回，表示持有锁的进程的 ID
    }

    注意：
        指定锁的范围起始偏移量的两个元素l_whence,l_start与lseek函数中最后两个参数类似
        锁可以在当前文件尾端处开始，或者越过尾端处开始，但是不能在文件起始位置之前开始
        如果l_len为 0 ，则表示锁的范围可以扩展到最大可能偏移量。这意味着不论向该文件中追加写了多少数据，它们都可以处于锁的范围内
        为了对整个文件加锁，我们可以设置l_whence,l_start指向文件的起始位置，并指定l_len为 0

    有两种类型的锁：共享性读锁(l_type=F_RDLCK)，独占性写锁(l_type=F_WRLCK)。互斥规则为：
        任意多个进程可以在一个给定的字节上有一把共享性读锁
        在一个给定字节上只能有一个进程有一把独占性写锁

    即：如果在一个给定字节上已经有了一把或者多把读锁，则不能在该字节上添加写锁； 如果在一个给定字节上已经有了一把写锁，则不能在该字节上添加任何读锁或者写锁。

    注意：该规则适用于不同进程提出的锁请求，不适合单个进程提出的多个锁请求。如果某个进程对一个文件区间已经有了一把锁，后来该进程又企图在同一个文件区间再加一把锁，则新锁将会替换旧锁。（此处读锁可以替换写锁/读锁；写锁也可以替换写锁/读锁）

    加读锁时，该文件描述符必须是读打开的；加写锁时，该文件描述符必须是写打开的。
    在这两种情况下，F_GETLK都报告正常，因为F_GETLK只是检测在指定区域的字节数是否有另外的进程加锁使得本进程无法加锁！

    通常使用F_GETLK命令来测试能否建立一把锁，然后用F_SETLK或者F_SETLKW试图建立那把锁。但是注意到：这二者不是一个原子操作！因此不能保证在这两次fcntl调用之间，可能另有一个进程插入并建立一把相同的锁从而导致本进程建立锁的过程失败。

    当进程A在文件的某个区间设置了一把读锁时，如果进程B试图在同一个区间设置一把写锁，则进程B会被阻塞。现在如果有另外进程C试图在同一个区间设置一把读锁，则进程C能不能顺利加读锁？POSIX.1并没有说明这一情况。

    如果进程C允许添加读锁，则很可能后续大量的读锁被添加从而导致进程B的写锁得不到设置从而进程B被饿死。

    在某个进程设置和释放文件上的一把锁时，系统会按照要求来组合和分裂相邻区域。
        第 100～199 字节加读锁： read_lock
        解锁第150 字节，分裂成两个区域 read_lock_2
        第150字节加读锁，合并成一个区域 read_lock
        第150～249字节加写锁： write_lock

    由于调用进程绝对不会阻塞在自己持有的记录锁上，因此F_GETLK命令绝不会报告调用进程自己持有的记录锁

    记录锁的隐含继承和释放：
        记录锁与进程和文件两者相关联
            当一个进程终止时，它所建立的所有记录锁全部被释放
            无论一个文件描述符何时关闭，该进程通过这个描述符所引用的文件上的任何一把锁都将被释放（这些锁都是该进程设置的）

            文件描述符是和进程关联的。文件是和进程无关的

        fork产生的子进程并不继承父进程所设置的记录锁。这是因为父进程与子进程是不同的进程，而记录锁是与进程和文件两者相关联

            子进程想获得记录锁，可以在继承而来的文件描述符上调用fcntl函数来设置记录锁。

        在执行exec后，新程序可以继承原程序的记录锁。但注意：如果对一个文件描述符设置了执行时关闭标志，则作为exec的一部分关闭该文件描述符时，将释放相应文件的所有锁。

        记录锁与进程和文件两者相关联： - 每个lockf结构描述了一个给定进程的一个加锁区域 - 在v结点中，存有该文件的lockf链表的指针 
        某个进程A，如果fd1,fd2,fd3都指向同一个文件表项，则关闭fd1,fd2,fd3中的任何一个都将释放由进程A设置的锁。
        关闭fd1,fd2,fd3中的任何一个时，内核会从该描述符所关联的v结点开始，逐个检查lockf链表中的各项，并释放由调用进程持有的各把锁。

        内核并不清楚（也不关心）进程A是用这三个描述符中的哪个来设置这把锁的

    在文件尾端加锁/解锁时要注意：
        当执行fcntl(fd, F_SETLK,flockptr)，而flockptr->l_type=F_WRLCK， flockptr->l_whence=SEEK_END，flockptr->l_start=0，flockptr->l_len=0 时，表示从当前文件尾端开始，包括以后所有可能追加写到该文件的任何字节都将加写锁
        然后执行write一个字节时，该字节将被加锁
        当执行 fcntl(fd, F_SETLK,flockptr)，而flockptr->l_type=F_UNLCK， flockptr->l_whence=SEEK_END，flockptr->l_start=0，flockptr->l_len=0 时，表示从当前文件尾端开始解锁，但是之前刚写入的一个字节仍然保持在加锁状态！！

    如果你想解除的锁包括之前刚写入的一个字节，则应该flockptr->l_len=-1 ， 负的长度值表示在指定偏移量之前的字节数。

    当对文件的一部分加锁时，内核将指定的偏移量变换成绝对文件偏移量。这是因为当前偏移量和文件尾端可能不断变化，但是这种变化不应该影响已经存在的锁的状态，所以内核必须独立于当前文件偏移量和文件尾端而记住锁的位置。

    建议性锁和强制性锁：
        建议性锁：并不能阻止对文件有读写权限的任何其他进程不使用记录锁而访问文件
        强制性锁：内核会检查每一个open,read,write等操作，验证调用进程是否违背了正在访问的文件上的某一把锁

    对于一个特定文件，打开其设置组ID位，同时关闭其组执行位，就开启了对该文件的强制性锁机制。

        因为当组执行位关闭时，设置组ID位不再有意义（设置组ID位的目的就是为了那些需要特殊组执行权限）

    如果一个进程试图read/write一个强制性锁起作用的文件，但是将要读/写的部分又由其他进程上了锁，则结果取决于三方面的因素：操作类型read/write，其他进程在该区域上持有的记录锁的类型（读锁/写锁），read/write文件描述符是阻塞的还是非阻塞的
    其他进程在该区域上
    持有的现有锁的类型 	阻塞描述符 	非阻塞描述符
    			read	write	read	write
    读锁			允许	阻塞	允许	EAGAIN
    写锁			阻塞	阻塞	EAGAIN	EAGAIN

    除了read/write函数外，open函数也会受到另一个进程持有的强制性锁的影响：
        通常，即使正在打开的文件具有强制性记录锁，open也会成功，随后的read/write遵从上表中的规则
        但是，如果open调用中的标志指定了O_TRUNC或者O_CREAT，且正在打开的文件具有强制性记录锁，则不论是否指定O_NONBLOCK，open都将出错返回，errno设置为EAGAIN

        一个恶意用户可以使用强制性记录锁，对大家都可读的文件加一把读锁，这样就能阻止任何人写该文件。

    强制性锁是可以设法避开的：强制性锁机制对unlink函数没有影响，因此你可以先将内容写到一个临时文件中，然后删除 原文件，最后将临时文件改名为原文件名。

IO多路转换

    当从多个描述符读，然后又写到一另一个描述符时，有多种技术：
        阻塞式读写+多进程：每个进程负责阻塞式读取一个描述符。缺点是进程间通信太复杂
        阻塞式读写+多线程：每个线程负责阻塞式读取一个描述符。缺点是线程将通信太复杂
        采用轮询+非阻塞式读写：将每个描述符都设置为非阻塞的，然后轮询读取这些描述符。缺点是浪费CPU时间
        异步IO：内核在IO准备好的时候，向进程发送信号。缺点是：
            可执行性较差：某些操作系统不支持
            这种信号对每个进程而言只有一个。进程在接收到信号时，无法分辨到底是哪一个描述符准备好了（我们仍然需要将描述符设置为非阻塞的，并在接收到信号之后，顺序尝试执行IO）
        IO多路转换IO multiplexing：使用poll/pselect/select这三个函数。这三个函数的原理是：
            先构建一张我们感兴趣的描述符（通常不止一个）的列表
            然后调用上述函数之一
            直到这些描述符中的一个已准备好进行IO时，该函数才返回

select

    select函数：执行IO多路转换

    #include<sys/select.h>
    int select(int maxfdp1,fd_set *restrict readfds,fd_set *restrict writefds,
    		fd_set *restrict exceptfds,struct timeval *restrict tvptr);

        参数：
            maxfdp1：最大的描述符编号值加1。考虑readfds,writefds,exceptfds所指定的描述符集，在这三个描述符集中找出最大描述符编号值，然后该值加 1 就是 maxfdp1 参数值。
                通过指定该参数，内核就在该参数范围内寻找就绪的描述符
                之所以加1，是因为描述符编号从 0 开始。因此该参数的真实意义是：要检查的描述符个数。如maxfdp1=100，则检查描述符0~99一共100个

                你也可以设置maxfdp1为FD_SETSIZE常量，它指定了最大描述符书来那个（通常是1024）。对于大多数应用而言，该常量指定的描述符太大了

            readfds：指向fd_set类型，其中存放的是我们关心的需要读取的描述符列表。如果为NULL，则表示不关心可读的描述符
            writefds：指向fd_set类型，其中存放的是我们关心的需要写入的描述符列表。如果为NULL，则表示不关心可写的描述符
            exceptfds：指向fd_set类型，其中存放的是我们关心的可能发生异常的描述符列表。如果为NULL，则表示不关心发生异常的描述符
            tvptr：指向timeval结构，存放的是我们愿意等待的时间长度
                如果为NULL，则表示永远等待。当发生以下条件时，函数会返回：
                    如果捕捉到一个信号则中断此无限期等待，函数返回-1，errno设置为EINTR
                    如果所指定的描述符中的一个已经准备好，则函数返回
                如果tvptr->tv_sec==0而且tvptr->tv_usec==0，则根本不等待。此时函数会测试所有指定的描述符并立即返回
                其他情况：等待指定的秒数加微秒数。当发生以下条件时，函数会返回：
                    如果超时则函数返回，此时函数的返回值是 0（表示没有描述符准备好）
                    如果所指定的描述符中的一个已经准备好，则函数返回

        返回值：
            成功：返回准备就绪的描述符的数量。该值是三个描述符集中已经准备好的描述符之和

                如果某个描述符同时位于readfds和writefds，一旦该描述符同时可读可写，则返回值中会对其计数两次

            失败：
                若超时则返回 0（此时表示没有描述符准备好）
                若出错则返回 -1（如select阻塞期间被信号中断）

    POSIX中select的语义为：
        我们通过传递给select的参数告诉内核：
            我们所关心的描述符
            对于每个描述符，我们所关心的条件：是描述符可读？还是描述符可写？还是描述符出现异常？
            我们愿意等多久
        从select返回时，内核告诉我们：
            已经准备好的描述符的总数量（通过select返回）
            对于可读、可写、发生异常这三个条件中的每一个，哪些描述符已准备好（通过readfds,writefds,exceptfds返回）

    注意：准备好的语义为：
        如果对readfds中的一个描述符进行的read操作不会阻塞，则认为该描述符是准备好的
        如果对writefds中的一个描述符进行的write操作不会阻塞，则认为该描述符是准备好的
        如果对exceptfds中的一个描述符有一个未决异常条件，则认为该描述符是准备好的。未决异常条件包括：
            在网络连接上到达带外数据
            处于数据包模式的伪终端上发生了 某些条件
        对于读、写和异常条件，普通文件的文件描述符总是返回准备好

    fd_set数据类型：它是描述符集类型。其数据类型是由具体实现定义的，可以为每一个可能的描述符保持一位

        我们可以认为它是一个很大的字节数组，每个可能的描述符占一个比特位

    对于fd_set类型，只支持下列操作：
        分配一个fd_set类型的变量
        将fd_set类型的变量赋给同类型的另一个变量
        对fd_set类型的变量使用下列函数中的一个（这些函数接口可能实现为宏或者函数）：
            FD_ISSET(fd,fdset)：判断 fd_set变量的指定位（由fd指定）是否为 1
            FD_CLR(fd,fdset)：将fd_set变量的指定位（由fd指定）设置为 0
            FD_SET(fd,fdset):将fd_set变量的指定位（由fd指定）设置为 1
            FD_ZERO(fdset)：将fd_set变量的所有位设置为 0

            这里的fdset为fd_set *

    #include<sys/select.h>
    int FD_ISSET(int fd,fd_set *fdset);
    void FD_CLR(int fd,fd_set *fdset);
    void FD_SET(int fd,fd_set *fdset);
    void FD_ZERO(fd_set *fdset);

        参数：
            fd：待测试的位（通常是一个描述符）
            fdset：指向待测试的fd_set变量的指针
        返回值：
            对于FD_ISSET函数：如果fd在描述符集中，则返回非零值；否则返回 0

    如果select的readfds,writefds,exceptfds均为NULL，则该函数就成了一个比sleep精度更高的定时器

    一个描述符阻塞并不影响select是否阻塞。

    如果在一个描述符上碰到了文件尾端，则select认为该描述符是可读的（因为调用read会返回0）

    POSIX.1也定义了一个pselect函数，它是select的变体：

    #include<sys/select.h>
    int pselect(int maxfdp1,fd_set *restrict readfds,fd_set *restrict writefds,
    		fd_set *restrict exceptfds,const struct timespec *restrict tsptr,
    		const sigset_t *restrict sigmask);

    除了下列几点外，pselect与select完全相同：
        select的超时值用timeval结构指定，而pselect的超时值用timespec结构（它以秒加纳秒表示超时值，而非秒加微秒）
        pselect的超时值被声明为const
        pselect可使用可选信号屏蔽字：
            若sigmask为NULL，则关于信号有关的方面，pselect与select相同
            否则sigmask指向一个信号屏蔽字。在调用pselect时，以原子操作的方式安装该信号屏蔽字。在返回时，以原子操作的方式恢复以前的信号屏蔽字

poll

    函数poll类似于select，但是接口不同。其原型为：

    #include<poll.h>
    int poll(struct pollfd fdarray[],nfds_t nfds,int timeout);

        参数
            fdarray：pollfd结构数组的地址，其长度由nfds指定
            nfds：pollfd结构数组的长度
            timeout：指定我们愿意等多长时间，单位为毫秒。
                如果为 -1， 表示永远等待。当发生以下条件时，函数会返回：
                    如果捕捉到一个信号则中断此无限期等待，函数返回-1，errno设置为EINTR
                    如果所指定的描述符中的一个已经准备好，则函数返回
                如果为 0 ，则表示不等待，此时函数会测试所有指定的描述符并立即返回。
                如果大于 0， 则等待指定的毫秒数。当发生以下条件时，函数会返回：
                    如果超时则函数返回，此时函数的返回值是 0（表示没有描述符准备好）
                    如果所指定的描述符中的一个已经准备好，则函数返回准备就绪的描述符的数量
        返回值：
            成功：返回准备就绪的描述符数目
            失败：
                超时：返回 0
                出错：返回 -1

    与select不同，poll不是为每个条件（可读性、可写性、异常条件）构造一个描述符集，而是构造一个pollfd结构的数组，每个数组元素指定一个描述符编号以及我们对该描述符感兴趣的条件：

    struct pollfd{
    	int fd;         // 待检查的描述符，如果小于零则忽略之
    	short events;    // 对fd上感兴趣的条件
    	short revents;   // 在fd上发生的条件
    }

    events成员指定了我们对该描述符感兴趣的条件，由用户设置。可以为下列常量的一个或者几个：
        POLLIN：可以不阻塞地读取高优先级数据以外的数据（等价于POLLRDNORM|POLLRDBAND）
        POLLRDNORM：可以不阻塞地读取普通数据
        POLLRDBAND：可以不阻塞地读取优先级数据
        POLLPRI：可以不阻塞地读取高优先级数据
        POLLOUT：可以不阻塞地写普通数据
        POLLWRNORM：与POLLOUT相同
        POLLWRBAND:可以不阻塞地写优先级数据

    revents成员指示了描述符上发生了哪些事件，由内核设置。可以为下列常量的一个或者几个：
        events的取值常量
        POLLERR：已出错
        POLLHUP：已挂断
        POLLNVAL：描述符没有引用一个打开的文件

    当一个描述符被挂断之后（POLLHUP），就不能再写该描述符，但是仍有可能从描述符读取到数据。 注意文件尾端和挂断的区别：
        如果到达文件尾端，则POLLIN事件会发生，我们可以读到EOF（此时read返回 0）
        如果正在读调制解调器，并且电话线已挂断，则将发生POLLHUP事件

    一个描述符是否阻塞不影响poll是否阻塞

    select和poll的可中断性：目前各种实现在接收到信号时都不会自动重启poll和select，即使在建立信号处理程序时指定SA_RESTART标志时也是如此。

异步IO

    信号机制提供了一种以异步形式通知某种事件已发生的方法。由BSD和System V派生的所有系统都提供了某种形式的异步IO，使用一个信号通知进程：对某个描述符所关注的某个事件已经发生了
        System V中是SIGPOLL信号
        BSD中是SIGIO信号

    信号机制的异步IO是有限制的：
        它们并不能够用在所有的文件类型上
        只能使用一个信号。如果要对一个以上的描述符进行异步IO，则在进程接收到该信号时，并不知道这一信号对应于哪个描述符

    使用POSIX异步IO接口有三个麻烦：
        每个异步操作都有三处可能产生错误的地方：
            在提交异步操作时
            在异步操作本身执行IO时
            在获取异步操作结果状态时
        与传统的方法相比，POSIX异步IO本身涉及大量的额外设置和处理规则
        从错误中恢复可能会比较困难。假设提交了多个异步写操作，其中一个失败了，那么是撤销失败的写操作，还是撤销所有的写操作？

POSIX 异步 IO

    POSIX异步IO接口为不同类型的文件进行异步IO提供了一套一致的方法。这些异步IO接口使用AIO控制块来描述IO操作。

    aiocb结构定义了AIO控制块，其结构至少包括下面这些字段：

    struct aiocb{
    	int aio_fildes;            // 文件描述符
    	off_t aio_offset;           // 文件偏移量
    	volatile void* aio_buf;     // IO缓冲区
    	size_t aio_nbytes;          // 传输的字节数
    	int aio_reqprio;            // 优先级
    	struct sigevent aio_sigevent;// 信号信息
    	int aio_lio_opcode;           // IO操作列表
    }

        aio_fildes：表示被打开用来读或者写的文件描述符

        aio_offset：读或者写操作从该字段指定的偏移量开始

        aio_buf：
            对于读操作，它指定了从文件中读取内容存放的缓冲区
            对于写操作，它指定了将要向文件写入内容存放的缓冲区

        aio_nbytes：指定了要读或者写的字节数

        aio_reqprio：指定了异步IO的优先级，操作系统根据该优先级来安排执行顺序。但是操作系统对于该顺序只有有限的控制能力，因此不一定能够遵循该提示

        aio_lio_opcode：参见lio_listio函数的说明。它指定了该AIO控制块是用于读操作、写操作、还是空操作

        aio_sigevent：指定IO事件完成后，如何通知应用程序：

         struct sigevent{
         	int sigev_notify;         // 通知类型
         	int sigev_signo;          // 信号编号
         	union sigval sigev_value;                   // 通知的参数
         	void (*sigev_notify_function)(union sigval);// 作为线程执行的函数
         	pthread_attr_t *sigev_notify_attributes;    // 线程属性

            sigev_notify：指定了通知的类型，可以为下列三种之一
                SIGEV_NONE：异步IO请求完成后，不通知进程
                SIGEV_SIGNAL：异步IO请求完成后，产生由sigev_signo字段指定的信号。如果应用程序选择捕捉此信号，且在建立信号处理程序时，指定了SA_SIGINFO标志，则该信号将被入队列（如果实现支持排队信号）。信号处理程序将被传递一个siginfo结构，该结构的si_value字段将被设置成sigev_value
                SIGEV_THREAD：当异步IO请求完成后，由sigev_notify_function字段指定的函数被调用成为一个子线程。sigev_value字段被传入作为其参数。如果sigev_notify_attributes为NULL，则该线程为分离状态；如果sigev_notify_attributes不是NULL，则该线程的属性由sigev_notify_attributes指定

                sigev_value是个union，其结构一般为：

            union sigval { int sival_int; void *sival_ptr; }


    在进行异步IO之前，需要先初始化AIO控制块，然后再进行异步读写操作

    aio_read/aio_write函数：异步读/写操作

    #include<aio.h>
    int aio_read(struct aiocb *aiocb);
    int aio_write(struct aiocb *aiocb);

        参数：
            aiocb：指向AIO控制块
        返回值：
            成功：返回 0
            失败： 返回 -1

    当这些函数返回成功时，异步IO请求就已经被操作系统放入等待处理的队列中了。这些返回值与实际IO操作的结果没有任何关系。

    注意：IO操作在等待时，必须确保AIO控制块和数据缓冲区保持稳定。它们下面对应的内存必须始终是合法的，除非IO操作完成，这些内存不应该被复用

    如果想强制所有等待中的异步操作不等待而写入持久化的存储（如硬盘）中，可以设立一个AIO控制块并调用aio_fsync函数：

    #include<aio.h>
    int aio_fsync(int op,struct aiocb *aiocb);

        参数：
            op：指定模式：
                O_DSYNC：操作执行起来就像是调用了fdatasync一样
                O_SYNC：操作执行起来就像是调用了fsync一样
            aiocb：指向AIO控制块
        返回值：
            成功：返回 0
            失败： 返回 -1

    AIO控制块中的aio_fildes字段指定了其异步写操作不等待而写入持久化的存储的那个文件。

    就像aio_read/aio_write函数一样，在安排了同步时，aio_fsync操作立即返回。在异步的同步操作完成之前，数据不会被持久化。AIO控制块控制我们如何被通知

        异步的同步操作：指的是将数据修改同步到硬盘上的这个操作是异步执行的。数据持久化：指的是将数据修改同步到硬盘上

    aio_error函数：获取一个异步读、写或者同步操作的完成状态

    #include<aio.h>
    int aio_error(const struct aiocb *aiocb);

        参数：
            aiocb：指向AIO控制块
        返回值：
            成功：返回 0 。表示异步操作完成，此时需要调用aio_return函数获取操作返回值
            失败： 返回 -1。对aio_error的调用失败，此时errno会告诉我们发生了什么
            EINPROGRESS：对异步读、写、同步操作仍在等待
            其他情况：其他任何返回值是相关的异步操作失败返回的错误码

    aio_return函数：如果异步操作成功，该函数获取异步操作的返回值

    #include<aio.h>
    ssize_t aio_return(const struct aiocb *aiocb);

        参数：
            aiocb：指向AIO控制块
        返回值：
            失败： 返回 -1。对aio_return的调用失败，此时errno会告诉我们发生了什么
            其他情况：返回异步读、写、同步操作的结果

    直到异步操作完成之前，都要小心的不要调用aio_return函数。操作完成之前，该函数调用的结果是未定义的。

    还需要小心地对每个异步操作只调用一次aio_return函数，一旦调用了该函数，操作系统就可以释放掉包含IO操作返回值的记录。

    如果想等待异步操作的完成，则可以使用aio_suspend函数：

    #include<aio.h>
    int aio_suspend(const struct aiocb *const list[],int nent,
    				const struct timespec *timeout);

        参数：
            list：AIO控制块指针的数组。每个元素指向了要等待完成的异步操作
                如果数组元素为NULL，则跳过空指针
                如果数组元素非NULL，则它必须是已经初始化的异步IO操作的AIO控制块
            nent：该数组的长度
            timeout：指定超时时间。如果想永不超时，则设定它为NULL

        返回值：
            成功：返回 0
            失败： 返回 -1

    aio_suspend可能返回三种结果：
        如果被一个信号中断，则返回-1 ，并将errno设置为EINTR
        如果list指定的异步IO中，没有任何IO操作完成的情况下，超时时间到达，则返回-1 ，并将errno设置为EAGAIN
        如果list指定的异步IO中，有任何IO操作完成，则返回 0

    aio_cancel函数：取消异步IO：

    #include<aio.h>
    int aio_cancel(int fd,struct aiocb *aiocb);

        参数：
            fd：指定了那个未完成异步IO操作的文件描述符
            aiocb：指向AIO控制块
        返回值：
            失败： 返回 -1。对aio_cacel的调用失败，此时errno会告诉我们发生了什么
            AIO_ALLDONE：所有异步操作在尝试取消它们之前已经完成
            AIO_CANCELED：所有要求的异步操作已经取消
            AIO_NOTCANCELED：至少有一个异步操作没有被取消

    如果aiocb为NULL，则系统将尝试取消所有在fd文件上未完成的异步IO操作。其他情况下尝试取消由AIO控制块描述的单个异步IO操作。之所以说尝试，是因为无法保证系统能够取消正在进行中的任何异步操作。

    如果异步IO操作被成功取消，则对应的AIO控制块调用aio_error函数将会返回错误ECANCELED。

    如果异步IO操作不能被取消，那么相应的AIO控制块不会被修改。

    lio_listio函数：提交一系列由一个AIO控制块列表描述的IO请求

    #include<aio.h>
    int lio_listio(int mode,struct aiocb *restrict const list[restrict_arr],
    	int nent,struct sigenvent* restrict sigev);

        参数：
            mode：决定了IO是否同步的。其值可以为：
                LIO_WAIT：lio_listio函数将在所有的由列表指定的IO操作完成后返回。此时sigev参数被忽略。这是同步操作
                LIO_NOWAIT：lio_listio函数将在所有的由列表指定的IO操作请求入队立即返回（不等到完成）。进程将在所有IO操作完成后，根据sigev参数指定的方式，被异步的通知（如果不想被通知，则将sigev设置为NULL）

                    每个AIO控制块本身也可能启动了在各自操作完成时的异步通知。sigev指定的异步通知是额外加的，并且只会在所有的IO操作完成后发送

            list：AIO控制块指针的数组，该数组指定了要允许的IO操作。如果数组包含空指针，则跳过这些空指针
            nent：数组的长度
            sigev：指定了当所有IO操作完成后，发送的异步通知（如果不想被通知，则将sigev设置为NULL）。只有当mode=LIO_NOWAIT才有意义
        返回值：
            成功： 返回 0
            失败： 返回 -1

    在每个AIO控制块中，aio_lio_opcode字段指定了该操作是一个读操作LIO_READ、写操作LIO_WRITE，还是将被忽略的空操作LIO_NOP。
        读操作对应的AIO控制块将被传递给aio_read函数来处理
        写操作对应的AIO控制块将被传递给aio_write函数来处理

        在Linux上测试，该函数总是抛出异常中断了进程！

    异步IO的数量有限制，这些限制都是运行时不变量。
        可以通过sysconf函数并把name设置为_SC_IO_LISTIO_MAX来设定AIO_LISTIO_MAX的值
        可以通过sysconf函数并把name设置为_SC_AIO_MAX来设定AIO_MAX的值
        可以通过sysconf函数并把name设置为_SC_AIO_PRIO_DELTA_MAX来设定AIO_PRIO_DELTA_MAX的值

    这些常量的意义为：
        AIO_LISTIO_MAX：单个列表IO调用中的最大IO操作数量
        AIO_MAX：未完成的异步IO操作的最大数量
        AIO_PRIO_DELTA_MAX：进程可以减少的其异步IO优先级的最大值

readv/writev

    readv和writev用于在一次函数调用中读、写多个非连续缓冲区。也称它们为散布读与聚集写

    #include<sys/uio.h>
    ssize_t readv(int fd,const struct iovec *iov,int iovcnt);
    ssize_t writev(int fd,const struct iovec *iov,int iovcnt);

        参数：
            fd：打开的文件描述符，用于读/写
            iov：指向iovec结构数组
            iovcnt：iovec结构数组的元素个数，其值最大为IOV_MAX
        返回值：
            成功：返回已读/已写的字节数量
            失败：返回 -1

    这两个函数的iov参数是指向iovec结构数组的一个指针：
        对于readv，该结构存放的是从文件中读入的内容
        对于writev，该结构存放的是想文件中写入的内容

    struct iovec{
    	void *iov_base;  // 缓冲区开始地址
    	size_t iov_len;  // 缓冲区长度
    }

    对于writev函数，从缓冲区中聚集输出数据到文件的顺序是iov[0],iov[1],...iov[iovcnt-1]。它返回总的输出字节数，通常应该等于所有缓冲区长度之和。

    对于readv函数，从文件中读取的数据依次输出到缓冲区iov[0],iov[1],...iov[iovcnt-1]。它返回总的读取字节数，通常应该等于所有缓冲区长度之和。如果遇到文件尾端，已无数据可读，则返回 0

    管道、FIFO 以及某些设备有下列两个性质：
        一次read操作所返回的数据可能少于所要求的数据，即使还没有达到文件尾端也可能是这样。这不是一次错误，应当继续读该设备
        一次write操作的返回值也可能少于指定输出的字节数。这可能是由于某个因素造成的（如内核输出缓冲区满）。这也不是一个错误，应当继续写余下的数据

        在读、写磁盘文件时，从来未见到上述两种情况，除非文件系统用完了空间，或者接近了配额限制从而不能将要求写的数据全部写出

存储映射 IO

    存储映射IO（memory-mapped IO） 能将一个磁盘文件映射到存储空间中的一个缓冲区上。于是：
        当从缓冲区中读取数据时，就相当于读文件中的相应字节
        当数据存入缓冲区时，相应字节就自动写入文件

        这样就能够在不使用read和write的情况下执行IO

    mmap函数：将一个给定的文件映射到一个存储区域中：

    #include<sys/mman.h>
    void *mmap(void *addr,size_t len,int prot,int flag,int fd,off_t off);

        参数：

            addr：用于指定映射存储区的起始地址。如果为 0，则表示由系统选择该映射区的起始地址

            len：指定要映射的字节数

            prot：指定了映射存储区的保护要求，可以为下列之一：
                PROT_READ：映射区可读
                PROT_WRITE：映射区可写
                PROT_EXEC：映射区可执行
                PROT_NONE：映射区不可访问

            也可以为PROT_READ、PROT_WRITE、PROT_EXEC的按位或。

            flag：影响映射存储区的多种属性：
                MAP_FIXED：返回值必须等于addr。因为这不利于可移植性，所以不鼓励使用此标志。

                如果未指定此标志，且addr非 0，则内核只是将addr视为在何处设置映射区的一个建议，但是不保证会使用所要求的地址。将addr设为 0，可以获取最大可移植性

                MAP_SHARED：它描述了本进程对于映射区所进行的存储操作的配置。此标志指定存储操作将修改底层的映射文件（即存储操作相当于对底层的映射文件进行write）
                MAP_PRIVATE：它描述了本进程对于映射区所进行的存储操作的配置。此标志指定存储操作将不会修改底层的映射文件，而是创建该底层的映射文件的一个私有副本。所有后续的对该映射区的引用都是引用该副本

                此标志的一个用途是用于调试程序，它将程序文件的正文部分映射到存储区，但运行用户修改其中的指令。任何修改只影响程序文件的副本，而不影响源文件

            fd：指定要被映射文件的描述符。在文件映射到地址空间之前，必须先打开该文件

            off：要映射字节在文件中的起始偏移量
        返回值：
            成功：返回映射区的起始地址
            失败：返回 MAP_FAILED

    注意：
        prot不能超过文件open模式访问权限。如：如果该文件是只读打开的，则对于映射存储区就不能指定PROT_WRITE
        flag的标志中，MAP_SHARED和MAP_PRIVATE必须指定一个，而且二者不能同时指定
        flag的标志中，每种实现可能会自定义一些MAP_XXX标志值，它们是那些实现特有的
        off的值和addr的值（如果指定了MAP_FIXED）通常被要求是系统虚拟存储页长度的倍数。因为off和addr通常指定为 0 ，所以这种要求一般并不重要

            虚拟存储页长可以用带参数_SC_PAGESIZE或者_SC_PAGE_SIZE的sysconf函数得到

- MAP_SHARED时，对存储映射区的修改反映到底层文件中
- MAP_PRIVATE时，对存储映射区的修改并不会反映到底层文件中
- 一旦将底层文件映射到存储映射区，则关闭fd并不会关闭存储映射区

    假设文件长度为 12 字节，系统页长为 512 字节，则系统通常会提供 512 字节的映射区，其中后 500字节被设置为0 。可以修改后面的这 500 字节，但是任何变动都不会在文件中反映出来。
        我们可以先加长该文件，使得能够将后面500字节的改动反映到文件中去

    与映射区相关的信号有：SIGSEGV和SIGBUS
        SIGSEGV：通常用于指示进程试图访问对它不可用的存储区。如果映射存储区被mmap指定成了只读的，则进程试图将数据存入这个映射存储区时，也产生此信号
        SIGBUS：如果映射区的某个部分在访问时不存在，则产生SIGBUS信号

            如：用文件长度映射了一个文件，但在引用该映射区之前，另一个进程已将该文件截断，此时如果进程视图访问被截断部分对应的映射区，则接收到SIGBUS信号

注意：如果open时，用O_RDONLY，则mmap时只能用PROT_READ。如果用PROT_WRITE，则会返回权限错误Permission denied。

    子进程能够通过fork继承存储映射区（因为子进程复制了父进程地址空间，而存储映射区是该地址空间的组成部分）。但是一旦子进程调用了exec，则新程序不再拥有存储映射区了

    mprotect函数：修改一个现有映射区的权限：

    #include<sys/mman.h>
    int mprotect(void *addr,size_t len,int prot);

        参数：
            addr：存储映射区的地址
            len：存储映射区的长度
            prot：存储映射区的修改后的权限，与mmap中的prot一样
        返回值：
            成功： 返回 0
            失败： 返回 -1

    如果修改的页是通过MAP_SHARED 标志映射到地址空间的，那么对内存映射区的修改并不会立即写回到底层文件中。何时写回脏页（即被修改的页）由内核的守护进程决定，决定的依据有两个：
        系统负载
        用来限制在系统失败事件中的数据损失的配置参数

    因此，如果只修改了一页中的一个字节，当修改被写回到文件中时，整个页都被写回。

    如果共享映射中的页已修改，则可以调用msync函数将该页冲洗到底层文件中。它类似于fsync，但是作用于存储映射区：

    #include<sys/mman.h>
    int msync(void *addr,size_t len,int flags);

        参数：
            addr：存储映射区的地址
            len：存储映射区的长度
            flags：用于控制如何冲洗存储区。下列两个常量二选一
                MS_ASYNC：简单的调试要写的页
                MS_SYNC：在返回之前等待写操作完成
        返回值：
            成功： 返回 0
            失败： 返回 -1

    如果存储映射是私有的，则不修改底层的文件。

    当进程终止时，会自动解除存储映射区的映射。你也可以直接调用munmap函数来手动解除映射区。

    #include<sys/mman.h>
    int nummap(void* addr,size_t len);

        参数：
            addr：存储映射区的地址
            len：存储映射区的长度
        返回值：
            成功： 返回 0
            失败： 返回 -1

    munmap并不影响被映射的对象。即调用munmap并不会使映射区的内容写到磁盘文件上。
        对于MAP_SHARED存储映射区的磁盘文件的更新：会在我们将数据写到存储映射区后的某个时刻，由内核虚拟存储算法自动运行
        对于MAP_PRIVATE存储映射区：对其做出的修改会被丢弃

    注意：对于创建存储映射区时使用的文件描述符，如果关闭该描述符，并不会解除映射区

myfcntl1.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define MAX 500000

char buf[MAX];

/**
 * 设置一个文件描述符指向的文件表项中的一个或多个文件状态标志
 */
int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

/**
 * 清除一个文件描述符指向的文件表项中的一个或多个文件状态标志
 */
int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

int main(void)
{
	char* ptr;
	int nread, nwrite;

	nread = read(STDIN_FILENO, buf, sizeof(buf));
	fprintf(stderr, "read %d bytes\n", nread);

	set_fl(STDOUT_FILENO, O_NONBLOCK);

	ptr = buf;
	while (nread > 0) {
		errno = 0;
		nwrite = write(STDOUT_FILENO, buf, nread);
		fprintf(stderr, "nwrite = %d, errno = %d\n", nwrite, errno);
		
		if (nwrite > 0) {
			ptr += nwrite;
			nread -= nwrite;
		}
	}

	clr_fl(STDOUT_FILENO, O_NONBLOCK);
	exit(EXIT_SUCCESS);
}

myfcntl2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int lock_reg(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        return fcntl(fd, cmd, &flockbuf);
}

int lock_test(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        if (fcntl(fd, F_GETLK, &flockbuf) < 0)
                err_sys("fcntl error");
        if (flockbuf.l_type == F_UNLCK)
                return 0;
        return flockbuf.l_pid;
}

#define read_lock(fd, offset, whence, len) \
              lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
#define readw_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
#define write_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define writew_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
#define un_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))

#define lockfile(fd) write_lock((fd), 0, SEEK_SET, 0)

//是否可设置读锁
#define is_read_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_RDLCK, (offset), (whence), (len)) == 0)
//是否可设置写锁
#define is_write_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_WRLCK, (offset), (whence), (len)) == 0)

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

#define DEFAULT_FILEPATH "/tmp/testfile"

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

void rwPStat(const char* target, const char* stat) {
	printf("%12s proccess(%ld) %5s, %s\n",
		target, (long)getpid(), stat, currTime(NULL));
}

int main(void)
{
	int fd;
	pid_t pid1, pid2;

	if ((fd = open(DEFAULT_FILEPATH, O_CREAT | O_RDWR | O_TRUNC, FILE_MODE)) < 0)
		err_sys("open error");
	/* 父进程在指定文件上获取记录读锁（以非阻塞方式），大约持续3秒 */
	rwPStat("read lock", "start");
	if (read_lock(fd, 0, SEEK_SET, 0) == -1)
		err_sys("read_lock error");
	rwPStat("read lock", "locks");

	/* 创建第一个子进程，并让该子进程试图对指定文件获取记录写锁
		（以阻塞方式），同样持续3秒 */
	if ((pid1 = fork()) < 0)
		err_sys("fork error");
	else if (pid1 == 0) {
		rwPStat("write lock", "start");
		if (writew_lock(fd, 0, SEEK_SET, 0) == -1)
			err_sys("writew_lock error");
		rwPStat("write lock", "locks");

		sleep(3);
		exit(EXIT_SUCCESS);
	}

	/* 创建第二个子进程，并让该子进程试图对指定文件获取记录读锁
		（以阻塞方式）同样持续3秒 */
	if ((pid2 = fork()) < 0)
		err_sys("fork error");
	else if (pid2 == 0) {
		rwPStat("read lock", "start");
		if (readw_lock(fd, 0, SEEK_SET, 0) == -1)
			err_sys("readw_lock error");
		rwPStat("read lock", "locks");

		sleep(3);
		exit(EXIT_SUCCESS);
	}

	sleep(3);
	exit(EXIT_SUCCESS);
}

myfcntl3.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int lock_reg(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        return fcntl(fd, cmd, &flockbuf);
}

int lock_test(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        if (fcntl(fd, F_GETLK, &flockbuf) < 0)
                err_sys("fcntl error");
        if (flockbuf.l_type == F_UNLCK)
                return 0;
        return flockbuf.l_pid;
}

#define read_lock(fd, offset, whence, len) \
              lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
#define readw_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
#define write_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define writew_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
#define un_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))

#define lockfile(fd) write_lock((fd), 0, SEEK_SET, 0)

//是否可设置读锁
#define is_read_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_RDLCK, (offset), (whence), (len)) == 0)
//是否可设置写锁
#define is_write_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_WRLCK, (offset), (whence), (len)) == 0)

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

static sigset_t newmask, oldmask, zeromask;
static volatile sig_atomic_t sigflag;

static void sig_usr(int signo) {
        sigflag = 1;
}

void TELL_WAIT(void) {
        if (signal(SIGUSR1, sig_usr) == SIG_ERR)
                err_sys("signal error\n");
        if (signal(SIGUSR2, sig_usr) == SIG_ERR)
                err_sys("signal error\n");
        sigemptyset(&newmask);
        sigemptyset(&zeromask);
        sigaddset(&newmask, SIGUSR1);
        sigaddset(&newmask, SIGUSR2);

        //是当前进程对SIGUSRx信号进行阻塞
        if (sigprocmask(SIG_BLOCK, &newmask, &oldmask) == -1)
                err_sys("sigprocmask error\n");
}

void TELL_PARENT(pid_t pid) {
        kill(pid, SIGUSR2);
}

void TELL_CHILD(pid_t pid) {
        kill(pid, SIGUSR1);
}

void WAIT_CHILD(void) {
        while (sigflag == 0)
                sigsuspend(&zeromask);//暂时解除阻塞并休眠，直到子进程发送SIGUSR2信号过来
        sigflag = 0;

        if (sigprocmask(SIG_SETMASK, &oldmask, NULL) == -1)
                err_sys("sigprocmask error\n");
}

void WAIT_PARENT(void) {
        while (sigflag == 0)
                sigsuspend(&zeromask);
        sigflag = 0;

        if (sigprocmask(SIG_SETMASK, &oldmask, NULL) == -1)
                err_sys("sigprocmask error\n");
}

int main(int argc, char* argv[])
{
	if (argc != 2) {
		fprintf(stderr, "usage: %s filename\n", argv[0]);
		exit(EXIT_FAILURE);
	}

	pid_t pid;
	int fd;

	TELL_WAIT();
	if ((fd = open(argv[1], O_CREAT | O_WRONLY | O_APPEND, FILE_MODE)) < 0)
		err_sys("open erorr");
	if ((pid = fork()) < 0)
		err_sys("fork error");
	else if (pid == 0) {
		//子进程获取文件记录写锁
		write_lock(fd, 0, SEEK_SET, 0);
		TELL_PARENT(getppid());
		WAIT_PARENT();
		write(fd, "hello world from child\n", 24);
	}
	else {
		//父进程将文件描述符设置为非阻塞
		set_fl(fd, O_NONBLOCK);

		WAIT_CHILD();
		write(fd, "hello world from parent\n", 25);
		TELL_CHILD(pid);
		if (waitpid(pid, NULL, 0) != pid)
			err_sys("waitpid error");
	}

	exit(EXIT_SUCCESS);
}

myfcntl4.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int lock_reg(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        return fcntl(fd, cmd, &flockbuf);
}

int lock_test(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        if (fcntl(fd, F_GETLK, &flockbuf) < 0)
                err_sys("fcntl error");
        if (flockbuf.l_type == F_UNLCK)
                return 0;
        return flockbuf.l_pid;
}

#define read_lock(fd, offset, whence, len) \
              lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
#define readw_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
#define write_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define writew_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
#define un_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))

#define lockfile(fd) write_lock((fd), 0, SEEK_SET, 0)

//是否可设置读锁
#define is_read_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_RDLCK, (offset), (whence), (len)) == 0)
//是否可设置写锁
#define is_write_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_WRLCK, (offset), (whence), (len)) == 0)

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

static sigset_t newmask, oldmask, zeromask;
static volatile sig_atomic_t sigflag;

static void sig_usr(int signo) {
        sigflag = 1;
}

void TELL_WAIT(void) {
        if (signal(SIGUSR1, sig_usr) == SIG_ERR)
                err_sys("signal error\n");
        if (signal(SIGUSR2, sig_usr) == SIG_ERR)
                err_sys("signal error\n");
        sigemptyset(&newmask);
        sigemptyset(&zeromask);
        sigaddset(&newmask, SIGUSR1);
        sigaddset(&newmask, SIGUSR2);

        //是当前进程对SIGUSRx信号进行阻塞
        if (sigprocmask(SIG_BLOCK, &newmask, &oldmask) == -1)
                err_sys("sigprocmask error\n");
}

void TELL_PARENT(pid_t pid) {
        kill(pid, SIGUSR2);
}

void TELL_CHILD(pid_t pid) {
        kill(pid, SIGUSR1);
}

void WAIT_CHILD(void) {
        while (sigflag == 0)
                sigsuspend(&zeromask);//暂时解除阻塞并休眠，直到子进程发送SIGUSR2信号过来
        sigflag = 0;

        if (sigprocmask(SIG_SETMASK, &oldmask, NULL) == -1)
                err_sys("sigprocmask error\n");
}

void WAIT_PARENT(void) {
        while (sigflag == 0)
                sigsuspend(&zeromask);
        sigflag = 0;

        if (sigprocmask(SIG_SETMASK, &oldmask, NULL) == -1)
                err_sys("sigprocmask error\n");
}

int main(int argc, char* argv[])
{
	struct stat statbuf;
	char buf[5];
	pid_t pid;
	int fd;

	if (argc != 2) {
		fprintf(stderr, "usage: %s filename\n", argv[0]);
		exit(EXIT_FAILURE);
	}

	//创建一个文件并设置其文件记录锁类型为强制性锁
	if ((fd = open(argv[1], O_RDWR | O_CREAT | O_TRUNC, FILE_MODE)) < 0)
		err_sys("open error");
	if (write(fd, "abcdef", 6) != 6)
		err_sys("write error");

	if (fstat(fd, &statbuf) < 0)
		err_sys("fstat error");
	if (fchmod(fd, (statbuf.st_mode & ~S_IXGRP) | S_ISGID) < 0)
		err_sys("fchmod error");

	//父进程持有记录写锁，子进程则试图去获取记录读锁和执行read函数
	TELL_WAIT();
	if ((pid = fork()) < 0)
		err_sys("fork error");
	else if (pid != 0) {
		if (write_lock(fd, 0, SEEK_SET, 0) < 0)
			err_sys("write_lock error");
		TELL_CHILD(pid);
		if (waitpid(pid, NULL, 0) != pid)
			err_sys("waitpid error");
	}
	else {
		WAIT_PARENT();
		set_fl(fd, O_NONBLOCK);

		if (read_lock(fd, 0, SEEK_SET, 0) != -1)
			err_sys("child: read_lock succeeded");
		printf("read_lock of already-locked region returns %d\n", errno);

		if (lseek(fd, 0, SEEK_SET) == -1)
			err_sys("lseek error");
		//若支持强制性锁，则子进程的非阻塞read会返回-1，并设置errno为EAGAIN
		if (read(fd, buf, 2) < 0)
			err_sys("read failed (mandatory locking works)");
		else
			printf("read OK(no mandatory locking), buf = %2.2s\n",
				buf);
	}

	exit(EXIT_SUCCESS);
}

myfcntl5.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int lock_reg(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        return fcntl(fd, cmd, &flockbuf);
}

int lock_test(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        if (fcntl(fd, F_GETLK, &flockbuf) < 0)
                err_sys("fcntl error");
        if (flockbuf.l_type == F_UNLCK)
                return 0;
        return flockbuf.l_pid;
}

#define read_lock(fd, offset, whence, len) \
              lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
#define readw_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
#define write_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define writew_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
#define un_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))

#define lockfile(fd) write_lock((fd), 0, SEEK_SET, 0)

//是否可设置读锁
#define is_read_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_RDLCK, (offset), (whence), (len)) == 0)
//是否可设置写锁
#define is_write_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_WRLCK, (offset), (whence), (len)) == 0)

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

static void lockbyte(const char *name, int fd, off_t offset)
{
	if(writew_lock(fd, offset, SEEK_SET, 1) < 0){
		perror("writew_lock error");
		return;
	}
	printf("%s:got a lock, byte %lld\n", name, (long long)offset);
}

int main(int argc, char const *argv[])
{
	int 	fd;
	pid_t	pid;

	if((fd = open("./templock", O_RDWR|O_CREAT)) < 0){
		perror("open error");
		return -1;
	}

	if(write(fd, "ab", 2) != 2){
		perror("write error");
		return -1;
	}

	if((pid = fork()) < 0){
		perror("fork error");
		return -1;
	}else if(pid == 0){
		sleep(2);//让父进程先锁住
		//lockbyte("child", fd, 0);
		printf("%d\n", __LINE__);
		lockbyte("child", fd, 1);
		printf("%d\n", __LINE__);
		return 0;
	}else{
		lockbyte("father", fd, 1);
		lockbyte("father", fd, 0);
		printf("%d\n", __LINE__);
		lockbyte("father", fd, 1);
		lockbyte("father", fd, 0);	
		printf("%d\n", __LINE__);
	}
	wait(NULL);
	return 0;
}

myfcntl6.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int lock_reg(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        return fcntl(fd, cmd, &flockbuf);
}

int lock_test(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        if (fcntl(fd, F_GETLK, &flockbuf) < 0)
                err_sys("fcntl error");
        if (flockbuf.l_type == F_UNLCK)
                return 0;
        return flockbuf.l_pid;
}

#define read_lock(fd, offset, whence, len) \
              lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
#define readw_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
#define write_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define writew_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
#define un_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))

#define lockfile(fd) write_lock((fd), 0, SEEK_SET, 0)

//是否可设置读锁
#define is_read_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_RDLCK, (offset), (whence), (len)) == 0)
//是否可设置写锁
#define is_write_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_WRLCK, (offset), (whence), (len)) == 0)

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

void sig_int(int signo)
{
	;//只是为了唤醒pause()
}

int main(int argc, char const *argv[])
{
	int 	pid1, pid2, pid3;
	int 	fd;
	setbuf(stdout, NULL);
	signal(SIGINT, sig_int);

	if((fd = open("lockfile", O_RDWR|O_CREAT, 0666)) < 0){
		perror("open error");
		return -1;
	}

	/* 进程1获得文件读锁 */
	if((pid1 = fork()) < 0){
		perror("fork1 error");
		return -1;
	}else if(pid1 == 0){
		if(read_lock(fd, 0, SEEK_SET, 0) < 0){
			perror("read_lock 1 error");
			return -1;
		}
		printf("child1: got a read lock on file\n");
		pause();
		printf("child1: exit from pause\n");
		un_lock(fd, 0, SEEK_SET, 0);
		exit(0);
	}else{
		sleep(2);
	}

	/* 进程2获得文件读锁 */
	if((pid2 = fork()) < 0){
		perror("fork2 error");
		return -1;
	}else if(pid2 == 0){
		if(read_lock(fd, 0, SEEK_SET, 0) < 0){
			perror("read_lock 2 error");
			return -1;
		}
		printf("child2: got a read lock on file\n");
		pause();
		printf("child2: exit from pause\n");
		un_lock(fd, 0, SEEK_SET, 0);
		exit(0);
	}else{
		sleep(2);
	}	

	/* 进程3获取文件写锁 */
	if((pid3 = fork()) < 0){
		perror("fork3 error");
		return -1;
	}else if(pid3 == 0){
		if(writew_lock(fd, 0, SEEK_SET, 0) < 0)
			printf("child3: can't got write lock:%s\n", strerror(errno));
		else{
			printf("child3: got a writelock success!\n");
		}	
		pause();
		printf("child3: exit from pause\n");	
		un_lock(fd, 0, SEEK_SET, 0);		
		exit(0);
	}else{
		sleep(2);
	}	


	/* 查看如果一个获取写锁被阻塞时,后面的获取读锁是否能成功 */
	if(read_lock(fd, 0, SEEK_SET, 0) < 0) {
		printf("last child: can't got read lock:%s\n", strerror(errno));
	}
	else {
		printf("after writelock pending, the readlock can also got!!\n");
		un_lock(fd, 0, SEEK_SET, 0);
	}

	printf("kill child1...\n");
	kill(pid1, SIGINT);
	printf("kill child2...\n");
	kill(pid2, SIGINT);
	sleep(2);
	printf("kill child3...\n");
	kill(pid3, SIGINT);
	return 0;
}

myselect1.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/epoll.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

int main(int argc, char* argv[])
{
	int ret;
	int fd1, fd2;
	fd_set writefds;

	if (argc!= 2) {
		fprintf(stderr, "usage: %s filename\n", argv[1]);
		exit(EXIT_FAILURE);
	}

	if ((fd1 = open(argv[1], O_CREAT | O_WRONLY | O_TRUNC, FILE_MODE)) < 0)
		err_sys("open error");
	fd2 = dup(fd1);
	FD_ZERO(&writefds);
	FD_SET(fd1, &writefds);
	FD_SET(fd2, &writefds);
	if ((ret = select(fd2 + 1, NULL, &writefds, NULL, NULL)) > 0) {
		if (FD_ISSET(fd1, &writefds)) {
			printf("fd1 is useful\n");
			write(fd1, "hello world from fd1\n", 22);
		}
		if (FD_ISSET(fd2, &writefds)) {
			printf("fd2 is useful\n");
			write(fd2, "hello world from fd2\n", 22);
		}
	}
	else {
		printf("ret = %d: %s\n", ret, strerror(errno));
		printf("get here?\n");
	}

	close(fd1);
	close(fd2);
	exit(EXIT_SUCCESS);
}

myselect2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/epoll.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

#define SEC2US 1000000L

typedef long int usec_t;

static void sleep_us(usec_t us) {
	struct timeval tval;
	
	tval.tv_usec = us % SEC2US;
	tval.tv_sec = us / SEC2US;
	select(1, NULL, NULL, NULL, &tval);
}

int main(int argc, char* argv[])
{
	usec_t us;

	if (argc != 2 || strncmp(argv[1], "--help", 6) == 0) {
		printf("usage: %s <useconds>", argv[0]); exit(1);
	}

	us = (usec_t)atol(argv[1]);
	printf("time: %s\n", currTime(NULL));
	sleep_us(us);
	printf("time: %s\n", currTime(NULL));
	exit(EXIT_SUCCESS);
}

mypoll1.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/select.h>

#define __USE_GNU

#include <sys/poll.h>
#include <sys/epoll.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

#define SEC2NSEC 1000000000L
#define USEC2NSEC 1000L
#define SEC2USEC 1000000L

typedef long usec_t;

static void sleep_us(usec_t us) {
	struct timespec timesp;

	timesp.tv_nsec = us % SEC2USEC * USEC2NSEC;
	timesp.tv_sec = us / SEC2USEC;
	ppoll(NULL, 0, &timesp, NULL);
}


int main(int argc, char* argv[])
{
	usec_t us;

	if (argc != 2 || strncmp(argv[1], "--help", 6) == 0) {
		printf("usage: %s <useconds>", argv[0]); exit(1);
	}

	us = (usec_t)atol(argv[1]);
	printf("time: %s\n", currTime(NULL));
	sleep_us(us);
	printf("time: %s\n", currTime(NULL));
	exit(EXIT_SUCCESS);
}

myaio1.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

#define BUFSIZE 4096
unsigned char buf[BUFSIZE];

unsigned char translate(unsigned char ch) {
	if (isalpha(ch)) {
		if (ch >= 'n')
			ch -= 13;
		else if (ch >= 'a')
			ch += 13;
		else if (ch >= 'N')
			ch -= 13;
		else
			ch += 13;
	}
	return ch;
}


int main(int argc, char* argv[])
{
	int ifd, ofd;
	int rval, wval;
	
	if (argc != 3) {
		printf("usage: rot13 infile outfile"); exit(1);
	}
	if ((ifd = open(argv[1], O_RDONLY)) < 0) {
		printf("can't open file %s", argv[1]); exit(1);
	}
	if ((ofd = open(argv[2], O_CREAT | O_TRUNC | O_WRONLY, FILE_MODE)) < 0) {
		printf("can't create file %s", argv[2]); exit(1);
	}

	while ((rval = read(ifd, buf, BUFSIZE)) > 0) {
		for (int i = 0; i < rval; ++i)
			buf[i] = translate(buf[i]);
		if ((wval = write(ofd, buf, rval)) != rval) {
			if (wval < 0) {
				printf("write error"); exit(1);
			}
			else {
				printf("short write (%d/%d)", wval / rval); exit(1);
			}
		}
	}

	close(ifd);
	close(ofd);
	exit(EXIT_SUCCESS);
}

myaio2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

#define BUFSIZE 4096

#define NBUF 8

//异步I/O缓冲区状态
enum AioStat {
	UNUSED,
	READ_PENDING,
	WRITE_PENDING
};


//异步I/O缓冲区
typedef struct AIOBuf {
	unsigned char data[BUFSIZE];
	struct aiocb aiocb_buf;
	enum AioStat status;
	int last;
}AIOBuf;

AIOBuf bufs[NBUF];


unsigned char translate(unsigned char ch) {
	if (isalpha(ch)) {
		if (ch >= 'n')
			ch -= 13;
		else if (ch < 'n')
			ch += 13;
		else if (ch >= 'N')
			ch -= 13;
		else
			ch += 13;
	}
	return(ch);
}


int main(int argc, char* argv[])
{
	const struct aiocb* aiolist[NBUF];
	int numop, err, retval;
	struct stat statbuf;
	int ifd, ofd;
	off_t off = 0;

	if (argc != 3) {
		printf("usage: %s infile outfile", argv[0]); exit(1);
	}
	if ((ifd = open(argv[1], O_RDONLY)) < 0) {
		printf("can't open file %s", argv[1]); exit(1);
	}
	if ((ofd = open(argv[2], O_CREAT | O_WRONLY | O_TRUNC, FILE_MODE)) < 0) {
		printf("can't create file %s", argv[2]); exit(1);
	}
	if (fstat(ifd, &statbuf) < 0)
		err_sys("fstat error");

	//初始化异步I/O缓冲区中的异步I/O控制块和异步I/O列表
	for (int i = 0; i < NBUF; ++i) {
		bufs[i].last = 0;
		bufs[i].status = UNUSED;
		bufs[i].aiocb_buf.aio_buf = bufs[i].data;
		bufs[i].aiocb_buf.aio_sigevent.sigev_notify = SIGEV_NONE;
		aiolist[i] = NULL;

	}

	/*
	 * 每一轮让主进程并不停止：
	   1.若遇到状态为UNUSED的异步I/O缓冲区，则向其分配从输入文件中异步读取数据的任务
	   2.若遇到状态为READ_PENDING的异步I/O缓冲区，则检测是否读取完毕。若无跳过，否则
	     向其分配一个数据处理+异步写入到输出文件的任务
	   3.若遇到一个WRITE_PENDING的异步I/O缓冲区，则检测是否写入完毕。若无跳过，否则
	     向其重新将该缓冲区置为UNUSED状态
	   当主进程完成一轮的事务后发现总任务还没有完成，不管是否是否真的完成异步读/写的工作，
	   都会调用aio_suspend函数等待上一轮中分配的异步I/O先完成再开始下一轮（否则进程无法
	   继续下一轮的分配异步I/O的事务）
	 */
	numop = 0;
	while (1) {
		for (int i = 0; i < NBUF; ++i) {
			switch (bufs[i].status) {
			case UNUSED:
				if (off <= statbuf.st_size) {
					bufs[i].status = READ_PENDING;
					bufs[i].aiocb_buf.aio_fildes = ifd;
					bufs[i].aiocb_buf.aio_offset = off;
					bufs[i].aiocb_buf.aio_nbytes = BUFSIZE;
					off += BUFSIZE;
					if (off >= statbuf.st_size)
						bufs[i].last = 1;

					//发出一个异步读取的请求给操作系统
					if (aio_read(&bufs[i].aiocb_buf) < 0)
						err_sys("aio_read error");
					aiolist[i] = &bufs[i].aiocb_buf;
					numop++;
				}
				break;
			case READ_PENDING:
				//检测是否完成异步读取的任务
				if ((err = aio_error(&bufs[i].aiocb_buf)) == EINPROGRESS)
					continue;
				if (err != 0) {
					if (err == -1)
					{
						err_sys("aio_error error");
					}
					else {
						printf("%d, %s\n", err, "read error"); exit(1);
					}
				}

				if ((retval = aio_return(&bufs[i].aiocb_buf)) < 0) {
					err_sys("aio_return error");
				}
				if (retval != BUFSIZE && !bufs[i].last) {
					printf("short read (%d/%d)", retval, BUFSIZE); exit(1);
				}

				//翻译字符
				for (int j = 0; j < BUFSIZE; ++j)
					bufs[i].data[j] = translate(bufs[i].data[j]);

				//开启一个异步写入的请求给操作系统
				bufs[i].status = WRITE_PENDING;
				bufs[i].aiocb_buf.aio_fildes = ofd;
				bufs[i].aiocb_buf.aio_nbytes = retval;
				if (aio_write(&bufs[i].aiocb_buf) < 0)
					err_sys("aio_write error");
				break;
			case WRITE_PENDING:
				//检测异步写入是否完成
				if ((err = aio_error(&bufs[i].aiocb_buf)) == EINPROGRESS)
					continue;
				if (err != 0) {
					if (err == -1)
					{
						err_sys("aio_error error");
					}
					else {
						printf("%d, %s\n", err, "write error"); exit(1);
					}
				}

				if ((retval = aio_return(&bufs[i].aiocb_buf)) < 0) {
					err_sys("aio_return error");
				}
				if (retval != bufs[i].aiocb_buf.aio_nbytes) {
					printf("short write (%d/%d)", retval, bufs[i].aiocb_buf.aio_nbytes); exit(1);
				}

				//将异步I/O缓冲区状态转换回UNUSED状态
				bufs[i].status = UNUSED;
				aiolist[i] = NULL;
				numop--;
				break;
			}
		}
		if (numop == 0) {
			if (off >= statbuf.st_size)
				break;
		}
		else {
			//等待上一轮中的异步I/O操作完成，以使得后续的异步操作可以得到正常的分配
			if (aio_suspend(aiolist, NBUF, NULL) < 0)
				err_sys("aio_suspend error");
		}
	}

	//要求暂存在内核中的写入数据强制同步写入到硬盘中
	bufs[0].aiocb_buf.aio_fildes = ofd;
	if (aio_fsync(O_SYNC, &bufs[0].aiocb_buf) < 0)
		err_sys("aio_fsync error");
	exit(EXIT_SUCCESS);
}

myuio.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

#define BUFSIZE 4096

int main(int argc, char const *argv[])
{
	int fd;
	char buf1[10] = "HELLO,";
	char buf2[10] = "Mrs.tree\n";
	char ret1[10] = {0};
	char ret2[10] = {0};
	struct iovec iov[2];
	struct iovec retiov[2];
	iov[0].iov_base = buf1;
	iov[0].iov_len  = sizeof(buf1);
	iov[1].iov_base = buf2;
	iov[1].iov_len  = sizeof(buf2);

	retiov[0].iov_base = ret1;
	retiov[0].iov_len  = sizeof(ret1);
	retiov[1].iov_base = ret2;
	retiov[1].iov_len  = sizeof(ret2);

	if((fd = open("./text.txt", O_RDWR | O_CREAT, 0777)) < 0){
		perror("open error");
		return -1;
	}
	/* 将不连续内存的数据写到文件中 */
	if(writev(fd, iov, 2) < 0){
		perror("writev error");
		return -1;
	}
	close(fd);

	if((fd = open("./text.txt", O_RDWR | O_CREAT, 0777)) < 0){
		perror("open second error");
		return -1;
	}
	/* 将文件中的数据读到不连续的内存中 */
	if(readv(fd, retiov, 2) < 0){
		perror("writev error");
		return -1;
	}
	printf("retiov[0]:%s\n", (char *)retiov[0].iov_base);
	printf("retiov[1]:%s\n", (char *)retiov[1].iov_base);
	close(fd);
	return 0;
}

mymmap1.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

#define BUFSIZE 4096
#define COPYSIZE (1024*1024)  // 一次拷贝1M大小(因为程序要用它来计算off值,所以必须是4096的整数倍)

int main(int argc, char const *argv[])
{
	int 		fin, fout;
	void		*src, *dst;
	size_t 		copysz;
	struct stat	sbuf;
	off_t 		fsz = 0;
	printf("page_size:%d\n", getpagesize());

	if(argc != 3){
		printf("usage: %s <fromfile> <tofile>\n", argv[0]);
		return -1;
	}

	if((fin = open(argv[1], O_RDWR)) < 0){
		perror("open error");
		return -1;
	}

	if((fout = open(argv[2], O_RDWR | O_CREAT | O_TRUNC, 0777)) < 0){
		perror("open error");
		return -1;
	}

	if(fstat(fin, &sbuf) < 0){
		perror("fstat error");
		return -1;
	}

	if(ftruncate(fout, sbuf.st_size) < 0){
		perror("ftruncate error");
		return -1;
	}
	printf("total size:%ld\n", sbuf.st_size);
	while(fsz < sbuf.st_size){
		if((sbuf.st_size - fsz) > COPYSIZE)
			copysz = COPYSIZE;
		else
			copysz = sbuf.st_size -fsz;
		printf("copysz:%d fsz:%ld\n", copysz, fsz);
		if((src = mmap(NULL, copysz, PROT_READ, MAP_SHARED, fin, fsz)) == MAP_FAILED){
			perror("map fin error");
			return -1;
		}
		
		printf("copysz:%d fsz:%ld\n", copysz, fsz);
		if((dst = mmap(NULL, copysz, PROT_WRITE, MAP_SHARED, fout, fsz)) == MAP_FAILED){
			perror("map fin error");
			return -1;
		}

		memcpy(dst, src, copysz);
		munmap(src, copysz);
		munmap(dst, copysz);
		fsz += copysz;
		printf("\tremain size:%ld bytes\n", sbuf.st_size - fsz);		
	}
	return 0;
}

mymmap2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

#define BUFSIZE 4096
#define COPYINCR (1024*1024*1024)
#define DEBUG

int main(int argc, char* argv[])
{
	off_t fsz = 0;
	int ifd, ofd;
	size_t copysize;
	void* src, * dest;
	struct stat statbuf;

	//打开输入文件并创建输出文件，设置其长度
	if (argc != 3)
		err_quit("usage: %s <srcfile> <targetfile>", argv[0]);
	if ((ifd = open(argv[1], O_RDONLY)) < 0)
		err_sys("can't open infile %s for reading", argv[1]);
	if ((ofd = open(argv[2], O_RDWR | O_CREAT | O_TRUNC, FILE_MODE)) < 0)
		err_sys("can't open outfile %d for writing", argv[2]);
	if (fstat(ifd, &statbuf) < 0)
		err_sys("fstat error");
	if (ftruncate(ofd, statbuf.st_size) < 0)
		err_sys("ftruncate error");

	while (fsz < statbuf.st_size) {
		if ((statbuf.st_size - fsz) > COPYINCR)
			copysize = COPYINCR;
		else
			copysize = statbuf.st_size - fsz;
#ifdef DEBUG
		printf("copysize = %lu\n", copysize);
#endif

		//分配存储映射区，将磁盘文件映射到缓冲区中
		if ((src = mmap(0, copysize, PROT_READ, MAP_SHARED, ifd, fsz)) == MAP_FAILED)
			err_sys("mmap error for input");
		if ((dest = mmap(0, copysize, PROT_WRITE | PROT_READ, MAP_SHARED, ofd, fsz)) == MAP_FAILED)
			err_sys("mmap error for output");
		
#ifdef DEBUG
		printf("dest = %p, dest mod PAGESIZE = %ld\n", dest, (long)dest % getpagesize());
#endif
		//从输入文件存储映射区拷贝数据到输出文件存储映射区
		memcpy(dest, src, copysize);
		munmap(src, copysize);
		munmap(dest, copysize);
		fsz += copysize;
	}

	exit(EXIT_SUCCESS);
}


进程间通信

管道

管道只能在具有公共祖先的两个进程之间使用。通常，一个管道由一个进程创建，在进程调用fork后，这个管道就能在父进程和子进程之间使用了。

管道是通过调用pipe函数创建的：

#include <unistd.h>
int pipe(int fd[2]);
经由参数fd返回两个文件描述符：fd[0]为读而打开，fd[1]为写而打开。fd[1]是输出，fd[0]是输入。

函数popen和pclose

这两个函数实现的操作是：创建一个管道，fork一个子进程，关闭未使用的管道端，执行一个shell运行命令，然后等待命令终止。

#include <stdio.h>
FILE *popen(const char *cmdstring,const char *type);
int pclose(FILE *fp);
函数popen先执行fork，然后调用exec执行cmdstring，并且返回一个标准I/O文件指针。

如果type是“r”，则文件指针连接到cmdstring的标准输出；如果type是“w”，则文件指针连接到cmdstring的标准输入。

pclose函数关闭标准I/O流，等待命令终止，然后返回shell的终止状态。

协同进程

UNIX系统过滤程序从标准输入读取数据，向标准输出写数据。

当一个过滤程序既产生某个过滤程序的输入，又读取该过滤程序的输出时，它就变成了协同进程。

FIFO

FIFO有时被称为命名管道。与未命名管道不一样：通过FIFO，不相关的进程也能交换数据。

FIFO是一种文件类型，创建FIFO类似于创建文件

#include <sys/stat.h>
int mkfifo(const char *path,mode_t mode);
int mkfifoat(int fd,const char *path,mode_t mode);

消息队列、信号量以及共享存储器，它们有如下相类似的特征：

1.标识符和键

2.权限结构

3.结构限制

消息队列

消息队列是消息的链接表，存储在内核中，由消息队列标识符标识。

信号量

信号量是一个计数器，用于为多个进程提供对共享数据对象的访问。

共享存储

共享存储允许两个或多个进程共享一个给定的存储区。

mypipe1.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define BUFSIZE 4096

int main(void)
{
	int fds[2];
	int ret, sum = 0;
	char buf[BUFSIZE];

	memset(buf, (int)'a', sizeof(buf));
	if (pipe(fds) == -1)
		err_sys("pipe error");
	if (set_fl(fds[1], O_NONBLOCK) == -1)
		err_sys("set_fl error");

	//每一次写入一个字节也是可以的
	while ((ret = write(fds[1], buf, sizeof(buf))) > 0) {
		sum += ret;
		printf("write %d chars to pipe buffer\n", ret);
	}
	printf("nonblock write set errno: %s\n", strerror(errno));
	printf("pipe buffer size: %d\n", sum);

	exit(EXIT_SUCCESS);
}

mypipe2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define BUFSIZE 4096

static int pfds1[2], pfds2[2];

void TELL_WAIT1(void) {
	if (pipe(pfds1) < 0 || pipe(pfds2) < 0)
		err_sys("pipe error");
}


void TELL_PARENT1(pid_t pid) {
	if (write(pfds1[1], "c", 1) != 1)
		err_sys("write error");
}

void TELL_CHILD1(pid_t pid) {
	if (write(pfds2[1], "p", 1) != 1)
		err_sys("write error");
}

void WAIT_PARENT1(void) {
	char c;

	if (read(pfds2[0], &c, 1) != 1)
		err_sys("read error");
	if (c != 'p')
		err_sys("WAIT_PARENT1: incorrent data");
}

void WAIT_CHILD1(void) {
	char c;

	if (read(pfds1[0], &c, 1) != 1)
		err_sys("read error");
	if (c != 'c')
		err_sys("WAIT_CHILD1: incorrent data");
}

int main(void)
{
	pid_t pid;

	TELL_WAIT1();
	if ((pid = fork()) < 0)
		err_sys("fork error");
	else if (pid == 0) {
		printf("hello world from child\n");
		TELL_PARENT1(getppid());
	}
	else {
		WAIT_CHILD1();
		printf("hello world from parent\n");
		if (waitpid(pid, NULL, 0) != pid)
			err_sys("waitpid error");
	}

	exit(EXIT_SUCCESS);

}

mypipe3.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define BUFSIZE 4096
#define PAGER "${PAGER:-more}"

int main(int argc, char* argv[])
{
	char databuf[BUFSIZE];
	FILE* fpin, *fpout;

	if (argc != 2) {
		printf("usage: %s <filename>", argv[0]); exit(1);
	}

	if ((fpin = fopen(argv[1], "r")) == NULL)
		err_sys("fopen error");
	//创建管道并fork shell程序执行cmdstring命令
	if ((fpout = popen(PAGER, "w")) == NULL)
		err_sys("popen error");

	//将数据写入到popen返回的输出文件指针中
	while (fgets(databuf, BUFSIZE, fpin) != NULL) {
		if (fputs(databuf, fpout) == EOF)
			err_sys("fputs error");
	}
	if (ferror(fpin))
		err_sys("fgets error");
	if (pclose(fpout) < 0)
		err_sys("pclose error");
	if (fclose(fpin) < 0)
		err_sys("fclose error");

	exit(EXIT_SUCCESS);
}

mypipe4.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define BUFSIZE 4096

#define DEFAULT_PAGER "/usr/bin/more"

int main(int argc, char* argv[])
{
	pid_t pid;
	int fds[2];
	int val, ifd;
	char* pager, *argv0;
	char databuf[BUFSIZE];

	if (argc != 2) {
		printf("usage: %s <filename>", argv[0]); exit(1);
	}
	if ((ifd = open(argv[1], O_RDONLY)) < 0)
		err_sys("open error");
	if (pipe(fds) < 0)
		err_sys("pipe error");
	
	if ((pid = fork()) < 0)
		err_sys("fork error");
	else if (pid > 0) {
		close(fds[0]);

		//父进程将指定文件输入到管道之中
		while ((val = read(ifd, databuf, BUFSIZE)) > 0) {
			if (write(fds[1], databuf, val) != val)
				err_sys("write error");
		}
		if (val < 0)
			err_sys("read error");
		close(fds[1]);

		//if (waitpid(pid, NULL, 0) != pid)
		//	err_sys("waitpid error");
	}
	else {
		close(fds[1]);
		
		//子进程关闭原来的stdin，并使其指向fds[0]文件描述符原来指向的文件
		if (fds[0] != STDIN_FILENO) {
			if (dup2(fds[0], STDIN_FILENO) != STDIN_FILENO)
				err_sys("dup2 error");
			close(fds[0]);
		}
		//检测是否有设置相关的环境变量，若设置了则优先使用环境变量指定的内容
		if ((pager = getenv("PAGER")) == NULL)
			pager = DEFAULT_PAGER;
		if ((argv0 = strrchr(pager, '/')) == NULL)
			argv0 = pager;
		else argv0++;
		if (execlp(pager, argv0, (char*)NULL) < 0)
			err_sys("execlp error");
	}

	exit(EXIT_SUCCESS);
}

mypipe5.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define BUFSIZE 4096

#define DEFAULT_PAGER "${PAGER:-more}"

int main(int argc, char* argv[])
{
	char DataBuf[BUFSIZE];
	FILE* fpin, * fpout;

	if (argc != 2) {
		printf("usage: %s <filename>", argv[0]); exit(1);
	}
	if ((fpin = fopen(argv[1], "r")) == NULL)
		err_sys("fopen error");
	if ((fpout = popen(DEFAULT_PAGER, "w")) == NULL)
		err_sys("popen error");

	while (fgets(DataBuf, BUFSIZE, fpin) != NULL) {
		if (fputs(DataBuf, fpout) == EOF)
			err_sys("fputs error");
	}
	if (ferror(fpin))
		err_sys("fgets error");
	if (pclose(fpout) < 0)
		err_sys("pclose error");
	if (fclose(fpin) < 0)
		err_sys("fclose error");

	exit(EXIT_SUCCESS);
}

mypipe6.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define BUFSIZE 4096

static void sig_pipe(int signo) {
	fprintf(stderr, "caught SIGPIPE\n");
	exit(EXIT_FAILURE);
}

int main(void)
{
	FILE* fp;

	if (signal(SIGPIPE, sig_pipe) == SIG_ERR)
		err_sys("signal error");
	/**
	 * 若popen是以r模式打开的，则popen中执行的cmdstring进程终止了会导致
	 * 管道中的读者进程收到文件结束标志。
	 * 但是若popen是以w模式打开的，则popen中执行的cmdstring进程终止后会
	 * 导致管道读文件描述符被关闭，此时写者进程继续向管道中写入数据会接收
	 * 到SIGPIPE信号
	 */
	if ((fp = popen("date", "w")) == NULL)
		err_sys("popen error");
	sleep(1);
	if (fputs("hello world\n", fp) == EOF)
		err_sys("fputs error");

	exit(EXIT_SUCCESS);
}

mypipe7.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int main(void)
{
	FILE* fp;
	int err;

	if ((fp = popen("fuck", "r")) == NULL)
		err_sys("popen error");
	err = pclose(fp);
	fprintf(stderr, "pclose return cmdstring's status: %d\n", err);
	exit(EXIT_SUCCESS);
}

mypipe8.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define BUFSIZE 4096

int main(int argc, char* argv[])
{
	char buf[BUFSIZE];
	size_t len;
	FILE* fp;

	if (argc != 2 || strcmp(argv[1], "--help") == 0) {
		printf("usage: %s <cmdstring>\n", argv[0]); exit(1);
	}

	if ((fp = popen(argv[1], "r")) == NULL)
		err_sys("popen error");
	while (fgets(buf, BUFSIZE, fp) != NULL) {
		len = strlen(buf);
		if (write(STDOUT_FILENO, buf, len) != len)
			err_sys("write error");
	}
	if (ferror(fp))
		err_sys("fgets error");
	pclose(fp);

	exit(EXIT_SUCCESS);
}

mypipe9.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define BUFSIZE 4096

int main(void)
{
	int ret;
	int fds[2];
	pid_t pid;
	char buf[BUFSIZE];

	if (pipe(fds) < 0)
		err_sys("pipe error");
	if ((pid = fork()) < 0)
		err_sys("fork error");
	else if (pid == 0) {
		close(fds[1]);
		ret = read(fds[0], buf, sizeof(buf));
		write(STDOUT_FILENO, buf, ret);
	}
	else {
		close(fds[0]);
		write(fds[1], "hello world\n", 13);
	}

	exit(EXIT_SUCCESS);
}

mypipe10.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define BUFSIZE 4096

int main(void)
{
	int fds[2];
	pid_t pid;

	if (pipe(fds) == -1)
		err_sys("pipe error");

	if ((pid = fork()) < 0)
		err_sys("fork error");
	else if (pid == 0) {
		char buf[BUFSIZ];
		fd_set rset;
		size_t nread;

		close(fds[1]);
		for (;;) {
			FD_ZERO(&rset);
			FD_SET(fds[0], &rset);

			if (select(fds[0] + 1, &rset, NULL, NULL, NULL) == -1)
				err_sys("select error");
			if (FD_ISSET(fds[0], &rset)) {
				memset(buf, 0, sizeof(buf));
				if ((nread = read(fds[0], buf, BUFSIZ)) < 0)
					err_sys("read error");
				else if (nread == 0) {
					/* 若子进程从管道读端读取到文件结束标志，则表示
						父进程关闭了与子进程通过管道的连接 */
					fprintf(stderr, "child: parent close his pipe writer fd, so I exit!\n");
					exit(EXIT_FAILURE);
				}
				if (write(STDOUT_FILENO, buf, nread) != nread)
					err_sys("write error");
			}
		}
	}
	else {
		close(fds[0]);
		if (write(fds[1], "before parent close pipe writer\n", 32) != 32)
			err_sys("write error");
		sleep(2);
		close(fds[1]);
		fprintf(stderr, "parent: I close pipe writer\n");
		if (waitpid(pid, NULL, 0) != pid)
			err_sys("waitpid error");
	}

	exit(EXIT_SUCCESS);
}

mypipe11.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define BUFSIZE 4096

int main(void)
{
	int fds[2];
	pid_t pid;

	if (pipe(fds) == -1)
		err_sys("pipe error");

	if ((pid = fork()) < 0)
		err_sys("fork error");
	else if (pid == 0) {
		struct pollfd pfds[1];
		char buf[BUFSIZ];
		size_t nread;

		close(fds[1]);
		pfds[0].fd = fds[0];
		pfds[0].events = POLLIN | POLLHUP;
		pfds[0].revents = 0;
		for (;;) {
			if (poll(pfds, 1, -1) == -1)
				err_sys("poll error");
			for (int i = 0; i < 1; ++i) {
				if (pfds[i].revents & (POLLIN | POLLHUP)) {
					pfds[i].revents = 0;
					if ((nread = read(pfds[i].fd, buf, BUFSIZ)) < 0)
						err_sys("read error");
					else if (nread == 0) {
						/* 若子进程从与父进程连接的管道中读取到文件结束标志，则表示父进程
							关闭了与子进程通过管道的连接。在Linux中若管道的写端描述符被关
							闭，则处在另一读端的poll函数会返回POLLHUP事件(而不是像select一
							样被当成可读事件一样返回)，所以events中仅仅设置POLLIN是会导致
							poll这端的进程一直阻塞的！*/
						fprintf(stderr, "child: parent close his pipe writer fd, so I exit!\n");
						exit(EXIT_FAILURE);
					}
					if (write(STDOUT_FILENO, buf, nread) != nread)
						err_sys("write error");
				}
			}
		}
	}
	else {
		close(fds[0]);
		if (write(fds[1], "before parent close pipe writer\n", 32) != 32)
			err_sys("write error");
		sleep(2);
		close(fds[1]);
		fprintf(stderr, "parent: I close pipe writer\n");
		if (waitpid(pid, NULL, 0) != pid)
			err_sys("waitpid error");
	}

	exit(EXIT_SUCCESS);
}

mypipe12.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define BUFSIZE 4096

#define MAXLINE 1024

static void sig_pipe(int signo) {
	printf("SIGPIPE caught\n");
	exit(EXIT_FAILURE);
}

int main(void)
{
	int val, fd1[2], fd2[2];
	char line[MAXLINE];
	pid_t pid;

	//设置信号处理程序并创建与子进程之间的两条管道
	if (signal(SIGPIPE, sig_pipe) == SIG_ERR)
		err_sys("signal error");
	if (pipe(fd1) < 0 || pipe(fd2) < 0)
		err_sys("pipe error");
	
	//创建子进程
	if ((pid = fork()) < 0) {
		for (int i = 0; i < 2; i++) {
			close(fd1[i]); close(fd2[i]);
		}
		err_sys("fork error");
	}
	else if (pid == 0) {
		close(fd1[1]);
		close(fd2[0]);

		if (fd1[0] != STDIN_FILENO) {
			if (dup2(fd1[0], STDIN_FILENO) != STDIN_FILENO)
				err_sys("dup2 error");
			close(fd1[0]);
		}
		if (fd2[1] != STDOUT_FILENO) {
			if (dup2(fd2[1], STDOUT_FILENO) != STDOUT_FILENO)
				err_sys("dup2 error");
			close(fd2[1]);
		}

		if (execl("./myadd2", "myadd2", (char*)NULL) < 0)
			err_sys("execl error");
	}
	else {
		close(fd1[0]);
		close(fd2[1]);

		/**
		 * 父进程读取stdin并将其通过一条管道发送给协同进程，然后从另一条
		 * 管道中读取协同进程处理好后的数据，并将其输出到自己的stdout中
		 */
		while (fgets(line, MAXLINE, stdin) != NULL) {
			val = strlen(line);
			if (write(fd1[1], line, val) != val)
				err_sys("write error");
			if ((val = read(fd2[0], line, MAXLINE)) <= 0) {
				if (val == 0) {
					printf("child coprocess closed pipe/terminated");
					break;
				}
				err_sys("read error");
			}
			line[val] = '\0';
			if (fputs(line, stdout) == EOF)
				err_sys("fputs error");
		}

		if (ferror(stdin))
			err_sys("ferror error");
	}

	exit(EXIT_SUCCESS);
}

mypipe13.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define BUFSIZE 4096

#define MAXLINE 1024

static void sig_pipe(int signo) {
	fprintf(stderr, "caught SIGPIPE\n");
	exit(EXIT_FAILURE);
}


int main(void)
{
	FILE* fp_PipeIn, * fp_PipeOut;
	int fds1[2], fds2[2];
	char buf[MAXLINE];
	pid_t pid;

	if (signal(SIGPIPE, sig_pipe) == SIG_ERR)
		err_sys("signal error");
	if (pipe(fds1) == -1 || pipe(fds2) == -1)
		err_sys("pipe error");

	if ((pid = fork()) < 0)
		err_sys("fork error");
	else if (pid > 0) {
		close(fds1[0]);
		close(fds2[1]);
		/* 以标准I/O的方式打开指向管道读写端的文件描述符 */
		if ((fp_PipeOut = fdopen(fds1[1], "w")) == NULL)
			err_sys("fdopen error");
		if ((fp_PipeIn = fdopen(fds2[0], "r")) == NULL)
			err_sys("fdopen error");

		while (fgets(buf, MAXLINE, stdin) != NULL) {
			if (fputs(buf, fp_PipeOut) == EOF)
				err_sys("fputs error");
			//当然最好的方式是在前面调用setvbuf()改变流缓冲区类型
			fflush(fp_PipeOut);
			if (fgets(buf, MAXLINE, fp_PipeIn) == NULL)
				err_sys("fgets error");
			if (fputs(buf, stdout) == EOF)
				err_sys("fputs error");
		}
		if (ferror(stdin))
			err_sys("fgets error");
	}
	else {
		close(fds1[1]);
		close(fds2[0]);
		if (fds1[0] != STDIN_FILENO) {
			if (dup2(fds1[0], STDIN_FILENO) != STDIN_FILENO)
				err_sys("dup2 error");
			close(fds1[0]);
		}
		if (fds2[1] != STDOUT_FILENO) {
			if (dup2(fds2[1], STDOUT_FILENO) != STDOUT_FILENO)
				err_sys("dup2 error");
			close(fds2[1]);
		}

		if (execl("./myadd2", "myadd2", (char*)NULL) == -1)
			err_sys("execl error");
	}

	exit(EXIT_SUCCESS);
}

myadd2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define MAXLINE 1024

int main(void)
{
	int val, int1, int2;
	char line[MAXLINE];

	while ((val = read(STDIN_FILENO, line, MAXLINE)) > 0) {
		line[val] = '\0';
		if (sscanf(line, "%d%d", &int1, &int2) == 2) {
			sprintf(line, "%d\n", int1 + int2);
			val = strlen(line);
			if (write(STDOUT_FILENO, line, val) != val)
				err_sys("write error");
		}
		else {
			if (write(STDOUT_FILENO, "invalid args\n", 14) != 14)
				err_sys("write error");
		}
	}

	exit(EXIT_SUCCESS);
}

myhistory.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define MAXLINE 1024

int main(void)
{
	char buf[MAXLINE];
	FILE* outfile;

	if (setvbuf(stdin, buf, _IOLBF, MAXLINE) != 0)
		err_sys("setvbuf error");
	if ((outfile = fopen("/tmp/history", "a")) == NULL)
		err_sys("fopen outfile error");

	while (fgets(buf, MAXLINE, stdin) !=NULL) {
		fputs(buf, outfile);
		fputs(buf, stdout);
		fflush(NULL);
	}

	if (fclose(outfile) == EOF)
		err_sys("fclose error");
	exit(EXIT_SUCCESS);
}

myuclc.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int main(void)
{
	int ch;

	while ((ch = getchar()) != EOF) {
		if (isupper(ch))
			ch = tolower(ch);
		if (putchar(ch) == EOF)
			err_sys("output error");
		if (ch == '\n')
			fflush(stdout);
	}

	exit(EXIT_SUCCESS);
}

myuclc_reader.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define BUFSIZE 4096

int main(void)
{
	char DataBuf[BUFSIZE];
	FILE* fpin;

	if ((fpin = popen("./myuclc", "r")) == NULL)
		err_sys("popen error");
	while (1) {
		fputs("prompt> ", stdout);
		fflush(stdout);
		if (fgets(DataBuf, BUFSIZE, fpin) == NULL)
			break;
		if (fputs(DataBuf, stdout) == EOF)
			err_sys("fputs error to pipe");
	}
	if (pclose(fpin) < 0)
		err_sys("Pclose error");
	putchar('\n');

	exit(EXIT_SUCCESS);
}

myfifo1.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define BUFSIZE 4096

#define FIFOBUFSIZE 64

int main(int argc, char* argv[])
{
	int fd, nread;
	char buf[FIFOBUFSIZE];

	if (argc != 2 || strcmp(argv[1], "--help") == 0) {
		printf("usage: %s <FIFOName>", argv[0]); exit(1);
	}
	
	if ((fd = open(argv[1], O_NONBLOCK | O_RDWR)) < 0)
		err_sys("open fifo eror");
	if (write(fd, "hello world\n", 12) != 12)
		err_sys("write error");
	fprintf(stderr, "%s write message(%dbytes) to FIFO\n", argv[0], 12);
	if ((nread = read(fd, buf, FIFOBUFSIZE)) < 0)
		err_sys("read error");

	buf[nread] = 0;
	close(fd);
	fprintf(stderr, "%s read message(%dbytes) from FIFO: %s", argv[0], nread, buf);

	exit(EXIT_SUCCESS);
}
显示结果如下
$ mkfifo testfifo
$ myfifo1 testfifo
myfifo1 write message(12bytes) to FIFO
myfifo1 read message(12bytes) from FIFO: hello world

myfifo2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define BUFSIZE 4096

#define FIFOFILE "temp.fifo"

int main(void)
{
	int fd;

	if (mkfifo(FIFOFILE, FILE_MODE) == -1)
		err_sys("mkfifo error");
	if ((fd = open(FIFOFILE, O_RDONLY | O_NONBLOCK)) < 0)
		err_sys("open error");
	if ((fd = open(FIFOFILE, O_WRONLY)) < 0)
		err_sys("open error");
	if (clr_fd(fd, O_NONBLOCK) == -1)
		err_sys("clr_fd error");

	exit(EXIT_SUCCESS);
}

myipc1.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define BUFSIZE 4096

#define LOOPTIME 5
#define IPC_PERM 0666
#define DEFAULT_PATH	 "/tmp"
#define DEFAULT_PRJID 32
#define MSGSIZE 256

struct mymsg {
	long mtype;
	char mtext[MSGSIZE];
};

int main(void)
{
	struct mymsg msgbuf;
	int msqid;
	key_t key;

	if ((key = ftok(DEFAULT_PATH, DEFAULT_PRJID)) == -1)
		err_sys("ftok error");

	msgbuf.mtype = 1;
	strcpy(msgbuf.mtext, "talk is cheap, show me the code!");
	for (int i = 0; i < LOOPTIME; ++i) {
		if ((msqid = msgget(key, IPC_CREAT | IPC_EXCL)) == -1)
			err_sys("msgget error");
		printf("Message Queue(id: %d) has been created.\n", msqid);
		if (msgctl(msqid, IPC_RMID, NULL) == -1)
			err_sys("msgctl error");
	}
	for (int i = 0; i < LOOPTIME; ++i) {
		if ((msqid = msgget(IPC_PRIVATE, 0666)) == -1)
			err_sys("msgget error");
		printf("Message Queue(id: %d) has been created.\n", msqid);
		if (msgsnd(msqid, &msgbuf, sizeof(msgbuf.mtext), 0) == -1)
			err_sys("msgsnd error");
	}

	exit(EXIT_SUCCESS);
}

myipc2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define BUFSIZE 4096

#define DEFAULT_PERM (S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)
#define DEFAULT_PATH "/tmp"
#define DEFAULT_PROID 24
#define MSGSIZE 256

struct message {
	long mtype;
	char mtext[MSGSIZE];
} msg;


int main(void)
{
	key_t mykey;
	int msqid;

	//试图引用一个已经存在的消息队列
	if ((mykey = ftok(DEFAULT_PATH, DEFAULT_PROID)) == -1)
		err_sys("ftok error");
	if ((msqid = msgget(mykey, IPC_CREAT | IPC_EXCL | DEFAULT_PERM)) == -1) {
		if (errno == EEXIST) {
			if ((msqid = msgget(mykey, 0)) == -1)
				err_sys("msgget error");
		}
		else {
			err_sys("msgget error");
		}
	}

	//从stdin获取输入并将其发送给服务端，然后从中得到回应
	while (fgets(msg.mtext, MSGSIZE, stdin) != NULL) {
		msg.mtype = 1;
		if (msgsnd(msqid, (void*)&msg, sizeof(msg.mtext), 0) == -1)
			err_sys("msgsnd error");

		if (msgrcv(msqid, (void*)&msg, sizeof(msg.mtext), 0, MSG_NOERROR) == -1)
			err_sys("msgrcv error");
		if (strncmp(msg.mtext, "server end", 10) == 0) {
			fputs("client end\n", stderr);
			break;
		}
		printf("server: %s", msg.mtext);
		fflush(stdout);
	}
	if (ferror(stdin))
		err_sys("fgets error");

	exit(EXIT_SUCCESS);
}

myipc3.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define BUFSIZE 4096

#define DEFAULT_PERM (S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)
#define DEFAULT_PATH "/tmp"
#define DEFAULT_PROID 24
#define MSGSIZE 256

struct message {
	long mtype;
	char mtext[MSGSIZE];
} msg;


int main(void)
{
	key_t mykey;
	int msqid;

	//创建system v 消息队列，若该消息队列已存在则先删除原来的消息队列
	if ((mykey = ftok(DEFAULT_PATH, DEFAULT_PROID)) == -1)
		err_sys("ftok error");
	while ((msqid = msgget(mykey, IPC_CREAT | IPC_EXCL | DEFAULT_PERM)) == -1) {
		if (errno == EEXIST) {
			if ((msqid = msgget(mykey, 0)) == -1)
				err_sys("msgget error");
			if ((msgctl(msqid, IPC_RMID, NULL)) == -1)
				err_sys("msgctl error");
			fprintf(stderr, "old message queue (id=%d) removed\n", msqid);
		}
		else {
			err_sys("msgget error");
		}
	}

	//从消息队列中获取消息并对客户端进行回应
	while (msgrcv(msqid, (void*)&msg, sizeof(msg.mtext), 0, MSG_NOERROR) != -1) {
		if (strncmp(msg.mtext, "server end", 10) == 0) {
			fputs(msg.mtext, stderr);
			msgsnd(msqid, (void*)&msg, sizeof(msg.mtext), 0);
			msgctl(msqid, IPC_RMID, NULL);
			break;
		}
		printf("client: %s", msg.mtext);
		fflush(stdout);

		strcpy(msg.mtext, "hello world from server\n");
		if (msgsnd(msqid, (void*)&msg, sizeof(msg.mtext), 0) == -1)
			err_sys("msgsnd error");
	}

	exit(EXIT_SUCCESS);
}

myipc4.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define BUFSIZE 4096

#define IPC_PERM 0666

#define DEFAULT_PATH "/tmp"
#define DEFAULT_PROID 1

union semun {
        int val;
        struct semid_ds* buf;
        unsigned short* array;
};


typedef int lock_t;

/**
 * 创建或引用一个二值信号量，然后对其调用semop函数设置其值为1，改变
 * 与信号量相关的semid_ds中的sem_otime，防止竞态条件的发生。在创建
 * 信号量进程还没有改变sem_time之前别的进程是无法对该信号量进行操作的
 */
int BSem_Create(lock_t* lock, const char* path, int projid) {
        key_t semkey;
        union semun arg;
        struct sembuf sbuf;
        struct semid_ds dsbuf;
        const int MAX_TRIES = 10;

        if (path == NULL || projid < 0 || projid>255) {
                path = DEFAULT_PATH;
                projid = DEFAULT_PROID;
        }
        if ((semkey = ftok(path, projid)) == -1)
                return -1;
        if ((*lock = semget(semkey, 1, IPC_CREAT | IPC_EXCL | IPC_PERM)) != -1) {
                arg.val = 0;
                sbuf.sem_num = 0;
                sbuf.sem_op = 1;

                if (semctl(*lock, 0, SETVAL, arg) == -1)
                        return -1;
                if (semop(*lock, &sbuf, 1) == -1)
                        return -1;
        }
        else {
                if (errno != EEXIST)
                        return -1;

                arg.buf = &dsbuf;
                if ((*lock = semget(semkey, 0, 0)) == -1)
                        return -1;
                for (int i = 0; i < MAX_TRIES; ++i) {
                        if (semctl(*lock, 0, IPC_STAT, arg) == -1)
                                return -1;
                        if (arg.buf->sem_otime != 0)
                                break;
                        sleep(1);
                }
                if (arg.buf->sem_otime == 0)
                        return -1;
        }
        return 0;
}


/**
 * 另一种创建二值信号量的方式，但是没有做出进程间竞态条件的
 * 防范措施，但是在多线程进程中使用还是够用的
 */
int BSem_Create1(lock_t* lock, const char* path, int projid) {
        key_t semkey;

        if (path == NULL || projid < 0 || projid>255)
                *lock = semget(IPC_PRIVATE, 1, IPC_CREAT | IPC_EXCL | IPC_PERM);
        else {
                if ((semkey = ftok(path, projid)) == -1)
                        return -1;
                *lock = semget(semkey, 1, IPC_CREAT | IPC_EXCL | IPC_PERM);
        }
        if (*lock == -1)
                return -1;
        return 0;
}


/**
 * 初始化二值信号量的值为指定值
 */
int BSem_Init(lock_t* lock, int initv) {
        union semun arg;

        arg.val = initv;
        return semctl(*lock, 0, SETVAL, arg);
}


/**
 * 删除指定二值信号量
 */
int BSem_Destroy(lock_t* lock) {
        return semctl(*lock, 0, IPC_RMID);
}


/**
 * 试图对信号量值-1，信号调整值+1
 */
int BSem_Sub(lock_t* lock) {
        struct sembuf sbuf;

        sbuf.sem_num = 0;
        sbuf.sem_op = -1;
        sbuf.sem_flg = SEM_UNDO;
        return semop(*lock, &sbuf, 1);
}


/**
 * 试图对信号量+1，信号量-1
 */
int BSem_Add(lock_t* lock) {
        struct sembuf sbuf;

        sbuf.sem_num = 0;
        sbuf.sem_op = 1;
        sbuf.sem_flg = SEM_UNDO;
        return semop(*lock, &sbuf, 1);
}

#define DEFAULT_CNT 10000

struct SharedVal {
	void* pmm;
	lock_t lock;
} svalue;


static void pro_do(struct SharedVal*psv) {
	int temp;
	char buf[BUFSIZE];

	for (int i = 0; i < DEFAULT_CNT; ++i) {
		if (BSem_Sub(&psv->lock) == -1)
			err_sys("lock error");
		
		strcpy(buf, psv->pmm);
		temp = atoi(buf);
		sprintf(buf, "%d\n", ++temp);
		strcpy(psv->pmm, buf);

		if (BSem_Add(&psv->lock) == -1)
			err_sys("unlock error");
	}
}


int main(int argc, char* argv[])
{
	int fd;
	pid_t pid;

	if (argc != 2) {
		printf("usage: %s <filename>", argv[0]); exit(1);
	}

	//创建或者打开文件
	if ((fd = open(argv[1], O_CREAT | O_RDWR | O_TRUNC, FILE_MODE)) < 0)
		err_sys("open error");
	if (ftruncate(fd, 64) == -1)
		err_sys("ftruncate error");
	if (write(fd, "0", 2) != 2)
		err_sys("write error");

	//初始化System V二值信号量
	if (BSem_Create(&svalue.lock,NULL,-1) == -1)
		err_sys("lock create error");
	if (BSem_Init(&svalue.lock, 1) == -1)
		err_sys("lock init error");
	if ((svalue.pmm = mmap(0, BUFSIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0)) == MAP_FAILED)
		err_sys("mmap error");

	//创建父子进程共同递增映射存储区中的数值
	if ((pid = fork()) < 0)
		err_sys("fork error");
	else if (pid == 0) {
		pro_do(&svalue);
		_exit(EXIT_SUCCESS);
	}
	else {
		pro_do(&svalue);
		if (waitpid(pid, NULL, 0) != pid)
			err_sys("waitpid error");
		printf("svalue final result: %d\n", atoi(svalue.pmm));
		if (msync(svalue.pmm, BUFSIZE, MS_SYNC) == -1)
			err_sys("msync error");
		if (munmap(svalue.pmm, BUFSIZE) == -1)
			err_sys("munmap error");
		if (BSem_Destroy(&svalue.lock) == -1)
			err_sys("lock destroy error");
	}
	
	exit(EXIT_SUCCESS);
}

myipc5.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}


const char* transformTime(time_t t, const char* format)
{
	static char buf[128];
	struct tm* ptm;

	if ((ptm = localtime(&t)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define BUFSIZE 4096

union semun {
	int val;
	struct semid_ds* buf;
	unsigned short* array;
};

int main(int argc, char* argv[])
{
	struct semid_ds dsbuf;
	union semun arg, dummy;
	int semid;

	if (argc != 2 || strncmp("--help", argv[1], 6) == 0) {
		printf("usage: %s <semid>", argv[0]); exit(1);
	}

	semid = atoi(argv[1]);
	arg.buf = &dsbuf;
	//获取指定信号量集的状态
	if (semctl(semid, 0, IPC_STAT, arg) == -1)
		err_sys("semctl error");
	printf("Semaphore changed: %s\n", transformTime(dsbuf.sem_ctime, NULL));
	printf("Semaphore last op: %s\n", transformTime(dsbuf.sem_otime, NULL));

	//获取每一个信号量上的值
	arg.array = calloc(dsbuf.sem_nsems, sizeof(unsigned short));
	if (arg.array == NULL)
		err_sys("calloc error");
	if (semctl(semid, 0, GETALL, arg) == -1)
		err_sys("semctl error");
	printf("Sem #  Value  SEMPID  SEMCNT  SEMZCNT\n");
	for (int i = 0; i < dsbuf.sem_nsems; ++i)
		printf("%3d   %5d   %5d   %5d    %5d\n", i, arg.array[i],
			semctl(semid, i, GETPID, dummy),
			semctl(semid, i, GETNCNT, dummy),
			semctl(semid, i, GETZCNT, dummy));
	
	exit(EXIT_SUCCESS);
}

myipc6.h
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <semaphore.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}


const char* transformTime(time_t t, const char* format)
{
	static char buf[128];
	struct tm* ptm;

	if ((ptm = localtime(&t)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define BUFSIZE 4096

#define ARRAY_SIZE 40000
#define MALLOC_SIZE 100000
#define SHM_SIZE 100000
#define SHM_MODE 0666

char array[ARRAY_SIZE];

int main(void)
{
	int shmid;
	char* ptr, * shmptr;

	printf("array[] from %p to %p\n", (void*)&array[0],
			(void*)&array[ARRAY_SIZE]);
	printf("stack around %p\n", (void*)&shmid);

	if ((ptr = malloc(MALLOC_SIZE)) == NULL)
		err_sys("malloc error");
	printf("malloced from %p to %p\n", (void*)ptr,
			(void*)ptr+MALLOC_SIZE);

	if ((shmid = shmget(IPC_PRIVATE, SHM_SIZE, IPC_CREAT | IPC_EXCL | SHM_MODE)) == -1)
		err_sys("shmget error");
	if ((shmptr = shmat(shmid, 0, 0)) == (void*)-1)
		err_sys("shmat error");
	printf("shared memory attached from %p to %p\n", (void*)shmptr,
		(void*)shmptr + SHM_SIZE);
	if (shmctl(shmid, IPC_RMID, NULL) == -1)
		err_sys("shmctl error");

	exit(EXIT_SUCCESS);
}

myipc7.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <semaphore.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}


const char* transformTime(time_t t, const char* format)
{
	static char buf[128];
	struct tm* ptm;

	if ((ptm = localtime(&t)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

static sigset_t newmask, oldmask, zeromask;
static volatile sig_atomic_t sigflag;

static void sig_usr(int signo) {
        sigflag = 1;
}

void TELL_WAIT(void) {
        if (signal(SIGUSR1, sig_usr) == SIG_ERR)
                err_sys("signal error\n");
        if (signal(SIGUSR2, sig_usr) == SIG_ERR)
                err_sys("signal error\n");
        sigemptyset(&newmask);
        sigemptyset(&zeromask);
        sigaddset(&newmask, SIGUSR1);
        sigaddset(&newmask, SIGUSR2);

        //是当前进程对SIGUSRx信号进行阻塞
        if (sigprocmask(SIG_BLOCK, &newmask, &oldmask) == -1)
                err_sys("sigprocmask error\n");
}

void TELL_PARENT(pid_t pid) {
        kill(pid, SIGUSR2);
}

void TELL_CHILD(pid_t pid) {
        kill(pid, SIGUSR1);
}

void WAIT_CHILD(void) {
        while (sigflag == 0)
                sigsuspend(&zeromask);//暂时解除阻塞并休眠，直到子进程发送SIGUSR2信号过来
        sigflag = 0;

        if (sigprocmask(SIG_SETMASK, &oldmask, NULL) == -1)
                err_sys("sigprocmask error\n");
}

void WAIT_PARENT(void) {
        while (sigflag == 0)
                sigsuspend(&zeromask);
        sigflag = 0;

        if (sigprocmask(SIG_SETMASK, &oldmask, NULL) == -1)
                err_sys("sigprocmask error\n");
}

#define BUFSIZE 4096

#define NLOOPS 1000
#define SIZE sizeof(long)
#define SHM_PERM 0666

static int update(long* ptr) {
	return (*ptr)++;
}

int main(void)
{
	int shmid, counter;
	pid_t pid;
	void* area;

	if ((shmid = shmget(IPC_PRIVATE, SIZE, IPC_CREAT | IPC_EXCL | SHM_PERM)) == -1)
		err_sys("shmget error");
	if ((area = shmat(shmid, 0, 0)) == (void*)-1)
		err_sys("shmat error");
	*(long*)area = 0L;
	printf("original value: %ld\n", *(long*)area);

	/* 对存储映射区中的数据交替由父子进程递增 */
	TELL_WAIT();
	if ((pid = fork()) < 0)
		err_sys("fork error");
	else if (pid == 0) {
		for (int i = 0; i < NLOOPS; i += 2) {
			if ((counter = update((long*)area)) != i) {
				printf("child: expected %d, got %d", i, counter); exit(1);
			}
			
			TELL_PARENT(getppid());
			WAIT_PARENT();
		}
	}
	else {
		for (int i = 1; i < NLOOPS; i += 2) {
			WAIT_CHILD();

			if ((counter = update((long*)area)) != i) {
				printf("parent: expected %d, got %d", i, counter); exit(1);
			}

			TELL_CHILD(pid);
		}
		if (waitpid(pid, NULL, 0) != pid)
			err_sys("waitpid error");
		printf("final value: %ld\n", *(long*)area);
		if (shmctl(shmid, IPC_RMID, NULL) == -1)
			err_sys("shmctl error");
	}

	exit(EXIT_SUCCESS);
}

myipc8.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <semaphore.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}


const char* transformTime(time_t t, const char* format)
{
	static char buf[128];
	struct tm* ptm;

	if ((ptm = localtime(&t)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

static sigset_t newmask, oldmask, zeromask;
static volatile sig_atomic_t sigflag;

static void sig_usr(int signo) {
        sigflag = 1;
}

void TELL_WAIT(void) {
        if (signal(SIGUSR1, sig_usr) == SIG_ERR)
                err_sys("signal error\n");
        if (signal(SIGUSR2, sig_usr) == SIG_ERR)
                err_sys("signal error\n");
        sigemptyset(&newmask);
        sigemptyset(&zeromask);
        sigaddset(&newmask, SIGUSR1);
        sigaddset(&newmask, SIGUSR2);

        //是当前进程对SIGUSRx信号进行阻塞
        if (sigprocmask(SIG_BLOCK, &newmask, &oldmask) == -1)
                err_sys("sigprocmask error\n");
}

void TELL_PARENT(pid_t pid) {
        kill(pid, SIGUSR2);
}

void TELL_CHILD(pid_t pid) {
        kill(pid, SIGUSR1);
}

void WAIT_CHILD(void) {
        while (sigflag == 0)
                sigsuspend(&zeromask);//暂时解除阻塞并休眠，直到子进程发送SIGUSR2信号过来
        sigflag = 0;

        if (sigprocmask(SIG_SETMASK, &oldmask, NULL) == -1)
                err_sys("sigprocmask error\n");
}

void WAIT_PARENT(void) {
        while (sigflag == 0)
                sigsuspend(&zeromask);
        sigflag = 0;

        if (sigprocmask(SIG_SETMASK, &oldmask, NULL) == -1)
                err_sys("sigprocmask error\n");
}

#define BUFSIZE 4096

#define NLOOPS 1000
#define SIZE sizeof(long)
#define IPC_PERM 0666

static long update(long* ptr) {
	return (*ptr)++;
}

int main(void)
{
	int shmid, counter;
	long* area;
	pid_t pid;

	if ((shmid = shmget(IPC_PRIVATE, SIZE, IPC_CREAT | IPC_EXCL | IPC_PERM)) == -1)
		err_sys("shmget error");
	if ((area = shmat(shmid, 0, 0)) == (void*)-1)
		err_sys("shmat error");
	memset(area, 0, SIZE);
	printf("original value: %ld\n", *area);

	TELL_WAIT();
	if ((pid = fork()) < 0)
		err_sys("fork error");
	else if (pid == 0) {
		for (int i = 0; i < NLOOPS; i += 2) {
			if ((counter = update(area)) != i) {
				printf("child: expected %d, but got %ld", i, counter); exit(1);
			}
			TELL_PARENT(getppid());
			WAIT_PARENT();
		}
		exit(EXIT_SUCCESS);
	}
	else {
		for (int i = 1; i < NLOOPS; i += 2) {
			WAIT_CHILD();
			if ((counter = update(area)) != i) {
				printf("parent: expected %d, but got %ld", i, counter); exit(1);
			}
			TELL_CHILD(pid);
		}
	}
	printf("final result: %ld\n", *area);

	if (shmctl(shmid, IPC_RMID, 0) == -1)
		err_sys("shmctl error");
	exit(EXIT_SUCCESS);
}

myipc9.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <semaphore.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}


const char* transformTime(time_t t, const char* format)
{
	static char buf[128];
	struct tm* ptm;

	if ((ptm = localtime(&t)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

static sigset_t newmask, oldmask, zeromask;
static volatile sig_atomic_t sigflag;

static void sig_usr(int signo) {
        sigflag = 1;
}

void TELL_WAIT(void) {
        if (signal(SIGUSR1, sig_usr) == SIG_ERR)
                err_sys("signal error\n");
        if (signal(SIGUSR2, sig_usr) == SIG_ERR)
                err_sys("signal error\n");
        sigemptyset(&newmask);
        sigemptyset(&zeromask);
        sigaddset(&newmask, SIGUSR1);
        sigaddset(&newmask, SIGUSR2);

        //是当前进程对SIGUSRx信号进行阻塞
        if (sigprocmask(SIG_BLOCK, &newmask, &oldmask) == -1)
                err_sys("sigprocmask error\n");
}

void TELL_PARENT(pid_t pid) {
        kill(pid, SIGUSR2);
}

void TELL_CHILD(pid_t pid) {
        kill(pid, SIGUSR1);
}

void WAIT_CHILD(void) {
        while (sigflag == 0)
                sigsuspend(&zeromask);//暂时解除阻塞并休眠，直到子进程发送SIGUSR2信号过来
        sigflag = 0;

        if (sigprocmask(SIG_SETMASK, &oldmask, NULL) == -1)
                err_sys("sigprocmask error\n");
}

void WAIT_PARENT(void) {
        while (sigflag == 0)
                sigsuspend(&zeromask);
        sigflag = 0;

        if (sigprocmask(SIG_SETMASK, &oldmask, NULL) == -1)
                err_sys("sigprocmask error\n");
}

#define BUFSIZE 4096

#define IPC_PERM 0666

#define DEFAULT_PATH "/tmp"
#define DEFAULT_PROID 1

union semun {
        int val;
        struct semid_ds* buf;
        unsigned short* array;
};


typedef int lock_t;

/**
 * 创建或引用一个二值信号量，然后对其调用semop函数设置其值为1，改变
 * 与信号量相关的semid_ds中的sem_otime，防止竞态条件的发生。在创建
 * 信号量进程还没有改变sem_time之前别的进程是无法对该信号量进行操作的
 */
int BSem_Create(lock_t* lock, const char* path, int projid) {
        key_t semkey;
        union semun arg;
        struct sembuf sbuf;
        struct semid_ds dsbuf;
        const int MAX_TRIES = 10;

        if (path == NULL || projid < 0 || projid>255) {
                path = DEFAULT_PATH;
                projid = DEFAULT_PROID;
        }
        if ((semkey = ftok(path, projid)) == -1)
                return -1;
        if ((*lock = semget(semkey, 1, IPC_CREAT | IPC_EXCL | IPC_PERM)) != -1) {
                arg.val = 0;
                sbuf.sem_num = 0;
                sbuf.sem_op = 1;

                if (semctl(*lock, 0, SETVAL, arg) == -1)
                        return -1;
                if (semop(*lock, &sbuf, 1) == -1)
                        return -1;
        }
        else {
                if (errno != EEXIST)
                        return -1;

                arg.buf = &dsbuf;
                if ((*lock = semget(semkey, 0, 0)) == -1)
                        return -1;
                for (int i = 0; i < MAX_TRIES; ++i) {
                        if (semctl(*lock, 0, IPC_STAT, arg) == -1)
                                return -1;
                        if (arg.buf->sem_otime != 0)
                                break;
                        sleep(1);
                }
                if (arg.buf->sem_otime == 0)
                        return -1;
        }
        return 0;
}


/**
 * 另一种创建二值信号量的方式，但是没有做出进程间竞态条件的
 * 防范措施，但是在多线程进程中使用还是够用的
 */
int BSem_Create1(lock_t* lock, const char* path, int projid) {
        key_t semkey;

        if (path == NULL || projid < 0 || projid>255)
                *lock = semget(IPC_PRIVATE, 1, IPC_CREAT | IPC_EXCL | IPC_PERM);
        else {
                if ((semkey = ftok(path, projid)) == -1)
                        return -1;
                *lock = semget(semkey, 1, IPC_CREAT | IPC_EXCL | IPC_PERM);
        }
        if (*lock == -1)
                return -1;
        return 0;
}


/**
 * 初始化二值信号量的值为指定值
 */
int BSem_Init(lock_t* lock, int initv) {
        union semun arg;

        arg.val = initv;
        return semctl(*lock, 0, SETVAL, arg);
}


/**
 * 删除指定二值信号量
 */
int BSem_Destroy(lock_t* lock) {
        return semctl(*lock, 0, IPC_RMID);
}


/**
 * 试图对信号量值-1，信号调整值+1
 */
int BSem_Sub(lock_t* lock) {
        struct sembuf sbuf;

        sbuf.sem_num = 0;
        sbuf.sem_op = -1;
        sbuf.sem_flg = SEM_UNDO;
        return semop(*lock, &sbuf, 1);
}


/**
 * 试图对信号量+1，信号量-1
 */
int BSem_Add(lock_t* lock) {
        struct sembuf sbuf;

        sbuf.sem_num = 0;
        sbuf.sem_op = 1;
        sbuf.sem_flg = SEM_UNDO;
        return semop(*lock, &sbuf, 1);
}


#define NLOOPS 1000

struct Shared {
	int value;
	lock_t lock;
};

static inline int update(int* ptr) {
	return (*ptr)++;
}


int main(void)
{
	struct Shared* sptr;
	int shmid;
	pid_t pid;

	if ((shmid = shmget(IPC_PRIVATE, sizeof(struct Shared), IPC_CREAT | IPC_PERM)) == -1)
		err_sys("shmget error");
	if ((sptr = shmat(shmid, 0, 0)) == (void*)-1)
		err_sys("shmat error");
	memset(sptr, 0, sizeof(struct Shared));
	if (BSem_Create(&sptr->lock, NULL, -1) == -1)
		err_sys("BSem_Create error");
	if (BSem_Init(&sptr->lock, 1) == -1)
		err_sys("BSem_Init error");
	printf("original value: %d\n", sptr->value);

	if ((pid = fork()) < 0)
		err_sys("fork error");
	else if (pid == 0) {
		//这里我就不设置进程间的谁先谁后
		for (int i = 0; i < NLOOPS; i += 2) {
			if (BSem_Sub(&sptr->lock) == -1)
				err_sys("BSem_Sub error");
			update(&sptr->value);
			if (BSem_Add(&sptr->lock) == -1)
				err_sys("BSem_Add error");
		}
		exit(EXIT_SUCCESS);
	}
	else {
		for (int i = 1; i < NLOOPS; i += 2) {
			if (BSem_Sub(&sptr->lock) == -1)
				err_sys("BSem_Sub error");
			update(&sptr->value);
			if (BSem_Add(&sptr->lock) == -1)
				err_sys("BSem_Add error");
		}
		if (waitpid(pid, NULL, 0) != pid)
			err_sys("waitpid error");
	}

	printf("final result: %d\n", sptr->value);
	if (BSem_Destroy(&sptr->lock) == -1)
		err_sys("BSem_Destroy error");
	if (shmctl(shmid, IPC_RMID, NULL) == -1)
		err_sys("shmctl error");
	exit(EXIT_SUCCESS);
}

myipc10.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <semaphore.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}


const char* transformTime(time_t t, const char* format)
{
	static char buf[128];
	struct tm* ptm;

	if ((ptm = localtime(&t)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

static sigset_t newmask, oldmask, zeromask;
static volatile sig_atomic_t sigflag;

static void sig_usr(int signo) {
        sigflag = 1;
}

void TELL_WAIT(void) {
        if (signal(SIGUSR1, sig_usr) == SIG_ERR)
                err_sys("signal error\n");
        if (signal(SIGUSR2, sig_usr) == SIG_ERR)
                err_sys("signal error\n");
        sigemptyset(&newmask);
        sigemptyset(&zeromask);
        sigaddset(&newmask, SIGUSR1);
        sigaddset(&newmask, SIGUSR2);

        //是当前进程对SIGUSRx信号进行阻塞
        if (sigprocmask(SIG_BLOCK, &newmask, &oldmask) == -1)
                err_sys("sigprocmask error\n");
}

void TELL_PARENT(pid_t pid) {
        kill(pid, SIGUSR2);
}

void TELL_CHILD(pid_t pid) {
        kill(pid, SIGUSR1);
}

void WAIT_CHILD(void) {
        while (sigflag == 0)
                sigsuspend(&zeromask);//暂时解除阻塞并休眠，直到子进程发送SIGUSR2信号过来
        sigflag = 0;

        if (sigprocmask(SIG_SETMASK, &oldmask, NULL) == -1)
                err_sys("sigprocmask error\n");
}

void WAIT_PARENT(void) {
        while (sigflag == 0)
                sigsuspend(&zeromask);
        sigflag = 0;

        if (sigprocmask(SIG_SETMASK, &oldmask, NULL) == -1)
                err_sys("sigprocmask error\n");
}

#define BUFSIZE 4096

#define IPC_PERM 0666

#define DEFAULT_PATH "/tmp"
#define DEFAULT_PROID 1

union semun {
        int val;
        struct semid_ds* buf;
        unsigned short* array;
};


typedef int lock_t;

/**
 * 创建或引用一个二值信号量，然后对其调用semop函数设置其值为1，改变
 * 与信号量相关的semid_ds中的sem_otime，防止竞态条件的发生。在创建
 * 信号量进程还没有改变sem_time之前别的进程是无法对该信号量进行操作的
 */
int BSem_Create(lock_t* lock, const char* path, int projid) {
        key_t semkey;
        union semun arg;
        struct sembuf sbuf;
        struct semid_ds dsbuf;
        const int MAX_TRIES = 10;

        if (path == NULL || projid < 0 || projid>255) {
                path = DEFAULT_PATH;
                projid = DEFAULT_PROID;
        }
        if ((semkey = ftok(path, projid)) == -1)
                return -1;
        if ((*lock = semget(semkey, 1, IPC_CREAT | IPC_EXCL | IPC_PERM)) != -1) {
                arg.val = 0;
                sbuf.sem_num = 0;
                sbuf.sem_op = 1;

                if (semctl(*lock, 0, SETVAL, arg) == -1)
                        return -1;
                if (semop(*lock, &sbuf, 1) == -1)
                        return -1;
        }
        else {
                if (errno != EEXIST)
                        return -1;

                arg.buf = &dsbuf;
                if ((*lock = semget(semkey, 0, 0)) == -1)
                        return -1;
                for (int i = 0; i < MAX_TRIES; ++i) {
                        if (semctl(*lock, 0, IPC_STAT, arg) == -1)
                                return -1;
                        if (arg.buf->sem_otime != 0)
                                break;
                        sleep(1);
                }
                if (arg.buf->sem_otime == 0)
                        return -1;
        }
        return 0;
}


/**
 * 另一种创建二值信号量的方式，但是没有做出进程间竞态条件的
 * 防范措施，但是在多线程进程中使用还是够用的
 */
int BSem_Create1(lock_t* lock, const char* path, int projid) {
        key_t semkey;

        if (path == NULL || projid < 0 || projid>255)
                *lock = semget(IPC_PRIVATE, 1, IPC_CREAT | IPC_EXCL | IPC_PERM);
        else {
                if ((semkey = ftok(path, projid)) == -1)
                        return -1;
                *lock = semget(semkey, 1, IPC_CREAT | IPC_EXCL | IPC_PERM);
        }
        if (*lock == -1)
                return -1;
        return 0;
}


/**
 * 初始化二值信号量的值为指定值
 */
int BSem_Init(lock_t* lock, int initv) {
        union semun arg;

        arg.val = initv;
        return semctl(*lock, 0, SETVAL, arg);
}


/**
 * 删除指定二值信号量
 */
int BSem_Destroy(lock_t* lock) {
        return semctl(*lock, 0, IPC_RMID);
}


/**
 * 试图对信号量值-1，信号调整值+1
 */
int BSem_Sub(lock_t* lock) {
        struct sembuf sbuf;

        sbuf.sem_num = 0;
        sbuf.sem_op = -1;
        sbuf.sem_flg = SEM_UNDO;
        return semop(*lock, &sbuf, 1);
}


/**
 * 试图对信号量+1，信号量-1
 */
int BSem_Add(lock_t* lock) {
        struct sembuf sbuf;

        sbuf.sem_num = 0;
        sbuf.sem_op = 1;
        sbuf.sem_flg = SEM_UNDO;
        return semop(*lock, &sbuf, 1);
}

//使用POSIX信号量封装出的二值信号量
#define PBSem_Init(lock, pshared) \
                sem_init((lock), (pshared), 1)
#define PBSem_Destroy(lock) \
                sem_destroy(lock)
#define PBSem_Lock(lock)         \
                sem_wait(lock)
#define PBSem_Trylock(lock) \
                sem_trywait(lock)
#define PBSem_Timedwait(lock, tsptr)     \
                sem_timedwait((lock), (tsptr))
#define PBSem_Unlock(lock) \
                sem_post((lock))

#define NLOOPS 1000

struct Shared {
	int value;
	sem_t lock;
};

static inline int update(int* ptr) {
	return (*ptr)++;
}

int main(void)
{
	struct Shared* sptr;
	int shmid;
	pid_t pid;

	if ((shmid = shmget(IPC_PRIVATE, sizeof(struct Shared), IPC_CREAT | IPC_PERM)) == -1)
		err_sys("shmget error");
	if ((sptr = shmat(shmid, 0, 0)) == (void*)-1)
		err_sys("shmat error");
	memset(sptr, 0, sizeof(struct Shared));
	if (PBSem_Init(&sptr->lock, 1) == -1)
		err_sys("PBSem_Init error");
	printf("original value: %d\n", sptr->value);

	if ((pid = fork()) < 0)
		err_sys("fork error");
	else if (pid == 0) {
		for (int i = 0; i < NLOOPS; i += 2) {
			if (PBSem_Lock(&sptr->lock) == -1)
				err_sys("PBSem_Lock error");
			update(&sptr->value);
			if (PBSem_Unlock(&sptr->lock) == -1)
				err_sys("PBSem_Unlock error");
		}
		exit(EXIT_SUCCESS);
	}
	else {
		for (int i = 1; i < NLOOPS; i += 2) {
			if (PBSem_Lock(&sptr->lock) == -1)
				err_sys("PBSem_Lock error");
			update(&sptr->value);
			if (PBSem_Unlock(&sptr->lock) == -1)
				err_sys("PBSem_Unlock error");
		}
		if (waitpid(pid, NULL, 0) != pid)
			err_sys("waitpid error");
	}

	printf("final result: %d\n", sptr->value);
	if (PBSem_Destroy(&sptr->lock) == -1)
		err_sys("PBSem_Destroy error");
	if (shmctl(shmid, IPC_RMID, NULL) == -1)
		err_sys("shmctl error");
	exit(EXIT_SUCCESS);
}

myipc11.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <semaphore.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int lock_reg(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        return fcntl(fd, cmd, &flockbuf);
}

int lock_test(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        if (fcntl(fd, F_GETLK, &flockbuf) < 0)
                err_sys("fcntl error");
        if (flockbuf.l_type == F_UNLCK)
                return 0;
        return flockbuf.l_pid;
}

#define read_lock(fd, offset, whence, len) \
              lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
#define readw_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
#define write_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define writew_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
#define un_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))

#define lockfile(fd) write_lock((fd), 0, SEEK_SET, 0)

//是否可设置读锁
#define is_read_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_RDLCK, (offset), (whence), (len)) == 0)
//是否可设置写锁
#define is_write_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_WRLCK, (offset), (whence), (len)) == 0)

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}


const char* transformTime(time_t t, const char* format)
{
	static char buf[128];
	struct tm* ptm;

	if ((ptm = localtime(&t)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

static sigset_t newmask, oldmask, zeromask;
static volatile sig_atomic_t sigflag;

static void sig_usr(int signo) {
        sigflag = 1;
}

void TELL_WAIT(void) {
        if (signal(SIGUSR1, sig_usr) == SIG_ERR)
                err_sys("signal error\n");
        if (signal(SIGUSR2, sig_usr) == SIG_ERR)
                err_sys("signal error\n");
        sigemptyset(&newmask);
        sigemptyset(&zeromask);
        sigaddset(&newmask, SIGUSR1);
        sigaddset(&newmask, SIGUSR2);

        //是当前进程对SIGUSRx信号进行阻塞
        if (sigprocmask(SIG_BLOCK, &newmask, &oldmask) == -1)
                err_sys("sigprocmask error\n");
}

void TELL_PARENT(pid_t pid) {
        kill(pid, SIGUSR2);
}

void TELL_CHILD(pid_t pid) {
        kill(pid, SIGUSR1);
}

void WAIT_CHILD(void) {
        while (sigflag == 0)
                sigsuspend(&zeromask);//暂时解除阻塞并休眠，直到子进程发送SIGUSR2信号过来
        sigflag = 0;

        if (sigprocmask(SIG_SETMASK, &oldmask, NULL) == -1)
                err_sys("sigprocmask error\n");
}

void WAIT_PARENT(void) {
        while (sigflag == 0)
                sigsuspend(&zeromask);
        sigflag = 0;

        if (sigprocmask(SIG_SETMASK, &oldmask, NULL) == -1)
                err_sys("sigprocmask error\n");
}

#define BUFSIZE 4096

#define IPC_PERM 0666

#define DEFAULT_PATH "/tmp"
#define DEFAULT_PROID 1

union semun {
        int val;
        struct semid_ds* buf;
        unsigned short* array;
};


typedef int lock_t;

/**
 * 创建或引用一个二值信号量，然后对其调用semop函数设置其值为1，改变
 * 与信号量相关的semid_ds中的sem_otime，防止竞态条件的发生。在创建
 * 信号量进程还没有改变sem_time之前别的进程是无法对该信号量进行操作的
 */
int BSem_Create(lock_t* lock, const char* path, int projid) {
        key_t semkey;
        union semun arg;
        struct sembuf sbuf;
        struct semid_ds dsbuf;
        const int MAX_TRIES = 10;

        if (path == NULL || projid < 0 || projid>255) {
                path = DEFAULT_PATH;
                projid = DEFAULT_PROID;
        }
        if ((semkey = ftok(path, projid)) == -1)
                return -1;
        if ((*lock = semget(semkey, 1, IPC_CREAT | IPC_EXCL | IPC_PERM)) != -1) {
                arg.val = 0;
                sbuf.sem_num = 0;
                sbuf.sem_op = 1;

                if (semctl(*lock, 0, SETVAL, arg) == -1)
                        return -1;
                if (semop(*lock, &sbuf, 1) == -1)
                        return -1;
        }
        else {
                if (errno != EEXIST)
                        return -1;

                arg.buf = &dsbuf;
                if ((*lock = semget(semkey, 0, 0)) == -1)
                        return -1;
                for (int i = 0; i < MAX_TRIES; ++i) {
                        if (semctl(*lock, 0, IPC_STAT, arg) == -1)
                                return -1;
                        if (arg.buf->sem_otime != 0)
                                break;
                        sleep(1);
                }
                if (arg.buf->sem_otime == 0)
                        return -1;
        }
        return 0;
}


/**
 * 另一种创建二值信号量的方式，但是没有做出进程间竞态条件的
 * 防范措施，但是在多线程进程中使用还是够用的
 */
int BSem_Create1(lock_t* lock, const char* path, int projid) {
        key_t semkey;

        if (path == NULL || projid < 0 || projid>255)
                *lock = semget(IPC_PRIVATE, 1, IPC_CREAT | IPC_EXCL | IPC_PERM);
        else {
                if ((semkey = ftok(path, projid)) == -1)
                        return -1;
                *lock = semget(semkey, 1, IPC_CREAT | IPC_EXCL | IPC_PERM);
        }
        if (*lock == -1)
                return -1;
        return 0;
}


/**
 * 初始化二值信号量的值为指定值
 */
int BSem_Init(lock_t* lock, int initv) {
        union semun arg;

        arg.val = initv;
        return semctl(*lock, 0, SETVAL, arg);
}


/**
 * 删除指定二值信号量
 */
int BSem_Destroy(lock_t* lock) {
        return semctl(*lock, 0, IPC_RMID);
}


/**
 * 试图对信号量值-1，信号调整值+1
 */
int BSem_Sub(lock_t* lock) {
        struct sembuf sbuf;

        sbuf.sem_num = 0;
        sbuf.sem_op = -1;
        sbuf.sem_flg = SEM_UNDO;
        return semop(*lock, &sbuf, 1);
}


/**
 * 试图对信号量+1，信号量-1
 */
int BSem_Add(lock_t* lock) {
        struct sembuf sbuf;

        sbuf.sem_num = 0;
        sbuf.sem_op = 1;
        sbuf.sem_flg = SEM_UNDO;
        return semop(*lock, &sbuf, 1);
}

//使用POSIX信号量封装出的二值信号量
#define PBSem_Init(lock, pshared) \
                sem_init((lock), (pshared), 1)
#define PBSem_Destroy(lock) \
                sem_destroy(lock)
#define PBSem_Lock(lock)         \
                sem_wait(lock)
#define PBSem_Trylock(lock) \
                sem_trywait(lock)
#define PBSem_Timedwait(lock, tsptr)     \
                sem_timedwait((lock), (tsptr))
#define PBSem_Unlock(lock) \
                sem_post((lock))

#define NLOOPS 1000
#define SIZE sizeof(int)
#define LOCKFILEPATH "tempfile"

static inline int update(int* ptr) {
	return (*ptr)++;
}


int main(void)
{
	int shmid, fd, * sptr;
	pid_t pid;

	if ((fd = open(LOCKFILEPATH, O_CREAT | O_WRONLY, FILE_MODE)) < 0)
		err_sys("open error");
	if ((shmid = shmget(IPC_PRIVATE, SIZE, IPC_CREAT | IPC_PERM)) == -1)
		err_sys("shmget error");
	if ((sptr = shmat(shmid, 0, 0)) == (void*)-1)
		err_sys("shmat error");
	memset(sptr, 0, SIZE);
	printf("original value: %d\n", *sptr);

	if ((pid = fork()) < 0)
		err_sys("fork error");
	else if (pid == 0) {
		for (int i = 0; i < NLOOPS; i += 2) {
			if (writew_lock(fd, 0, SEEK_SET, 0) == -1)
				err_sys("writew_lock error");
			update(sptr);
			if (un_lock(fd, 0, SEEK_SET, 0) == -1)
				err_sys("un_lock error");
		}
		exit(EXIT_SUCCESS);
	}
	else {
		for (int i = 1; i < NLOOPS; i += 2) {
			if (writew_lock(fd, 0, SEEK_SET, 0) == -1)
				err_sys("writew_lock error");
			update(sptr);
			if (un_lock(fd, 0, SEEK_SET, 0) == -1)
				err_sys("un_lock error");
		}
		if (waitpid(pid, NULL, 0) != pid)
			err_sys("waitpid error");
	}

	printf("final result: %d\n", *sptr);
	if (close(fd) == -1)
		err_sys("close error");
	if (unlink(LOCKFILEPATH) == -1)
		err_sys("unlink error");
	if (shmctl(shmid, IPC_RMID, NULL) == -1)
		err_sys("shmctl error");
	exit(EXIT_SUCCESS);
}

myipc12.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <semaphore.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int lock_reg(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        return fcntl(fd, cmd, &flockbuf);
}

int lock_test(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        if (fcntl(fd, F_GETLK, &flockbuf) < 0)
                err_sys("fcntl error");
        if (flockbuf.l_type == F_UNLCK)
                return 0;
        return flockbuf.l_pid;
}

#define read_lock(fd, offset, whence, len) \
              lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
#define readw_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
#define write_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define writew_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
#define un_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))

#define lockfile(fd) write_lock((fd), 0, SEEK_SET, 0)

//是否可设置读锁
#define is_read_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_RDLCK, (offset), (whence), (len)) == 0)
//是否可设置写锁
#define is_write_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_WRLCK, (offset), (whence), (len)) == 0)

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}


const char* transformTime(time_t t, const char* format)
{
	static char buf[128];
	struct tm* ptm;

	if ((ptm = localtime(&t)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

static sigset_t newmask, oldmask, zeromask;
static volatile sig_atomic_t sigflag;

static void sig_usr(int signo) {
        sigflag = 1;
}

void TELL_WAIT(void) {
        if (signal(SIGUSR1, sig_usr) == SIG_ERR)
                err_sys("signal error\n");
        if (signal(SIGUSR2, sig_usr) == SIG_ERR)
                err_sys("signal error\n");
        sigemptyset(&newmask);
        sigemptyset(&zeromask);
        sigaddset(&newmask, SIGUSR1);
        sigaddset(&newmask, SIGUSR2);

        //是当前进程对SIGUSRx信号进行阻塞
        if (sigprocmask(SIG_BLOCK, &newmask, &oldmask) == -1)
                err_sys("sigprocmask error\n");
}

void TELL_PARENT(pid_t pid) {
        kill(pid, SIGUSR2);
}

void TELL_CHILD(pid_t pid) {
        kill(pid, SIGUSR1);
}

void WAIT_CHILD(void) {
        while (sigflag == 0)
                sigsuspend(&zeromask);//暂时解除阻塞并休眠，直到子进程发送SIGUSR2信号过来
        sigflag = 0;

        if (sigprocmask(SIG_SETMASK, &oldmask, NULL) == -1)
                err_sys("sigprocmask error\n");
}

void WAIT_PARENT(void) {
        while (sigflag == 0)
                sigsuspend(&zeromask);
        sigflag = 0;

        if (sigprocmask(SIG_SETMASK, &oldmask, NULL) == -1)
                err_sys("sigprocmask error\n");
}

#define BUFSIZE 4096

#define IPC_PERM 0666

#define DEFAULT_PATH "/tmp"
#define DEFAULT_PROID 1

union semun {
        int val;
        struct semid_ds* buf;
        unsigned short* array;
};


typedef int lock_t;

/**
 * 创建或引用一个二值信号量，然后对其调用semop函数设置其值为1，改变
 * 与信号量相关的semid_ds中的sem_otime，防止竞态条件的发生。在创建
 * 信号量进程还没有改变sem_time之前别的进程是无法对该信号量进行操作的
 */
int BSem_Create(lock_t* lock, const char* path, int projid) {
        key_t semkey;
        union semun arg;
        struct sembuf sbuf;
        struct semid_ds dsbuf;
        const int MAX_TRIES = 10;

        if (path == NULL || projid < 0 || projid>255) {
                path = DEFAULT_PATH;
                projid = DEFAULT_PROID;
        }
        if ((semkey = ftok(path, projid)) == -1)
                return -1;
        if ((*lock = semget(semkey, 1, IPC_CREAT | IPC_EXCL | IPC_PERM)) != -1) {
                arg.val = 0;
                sbuf.sem_num = 0;
                sbuf.sem_op = 1;

                if (semctl(*lock, 0, SETVAL, arg) == -1)
                        return -1;
                if (semop(*lock, &sbuf, 1) == -1)
                        return -1;
        }
        else {
                if (errno != EEXIST)
                        return -1;

                arg.buf = &dsbuf;
                if ((*lock = semget(semkey, 0, 0)) == -1)
                        return -1;
                for (int i = 0; i < MAX_TRIES; ++i) {
                        if (semctl(*lock, 0, IPC_STAT, arg) == -1)
                                return -1;
                        if (arg.buf->sem_otime != 0)
                                break;
                        sleep(1);
                }
                if (arg.buf->sem_otime == 0)
                        return -1;
        }
        return 0;
}


/**
 * 另一种创建二值信号量的方式，但是没有做出进程间竞态条件的
 * 防范措施，但是在多线程进程中使用还是够用的
 */
int BSem_Create1(lock_t* lock, const char* path, int projid) {
        key_t semkey;

        if (path == NULL || projid < 0 || projid>255)
                *lock = semget(IPC_PRIVATE, 1, IPC_CREAT | IPC_EXCL | IPC_PERM);
        else {
                if ((semkey = ftok(path, projid)) == -1)
                        return -1;
                *lock = semget(semkey, 1, IPC_CREAT | IPC_EXCL | IPC_PERM);
        }
        if (*lock == -1)
                return -1;
        return 0;
}


/**
 * 初始化二值信号量的值为指定值
 */
int BSem_Init(lock_t* lock, int initv) {
        union semun arg;

        arg.val = initv;
        return semctl(*lock, 0, SETVAL, arg);
}


/**
 * 删除指定二值信号量
 */
int BSem_Destroy(lock_t* lock) {
        return semctl(*lock, 0, IPC_RMID);
}


/**
 * 试图对信号量值-1，信号调整值+1
 */
int BSem_Sub(lock_t* lock) {
        struct sembuf sbuf;

        sbuf.sem_num = 0;
        sbuf.sem_op = -1;
        sbuf.sem_flg = SEM_UNDO;
        return semop(*lock, &sbuf, 1);
}


/**
 * 试图对信号量+1，信号量-1
 */
int BSem_Add(lock_t* lock) {
        struct sembuf sbuf;

        sbuf.sem_num = 0;
        sbuf.sem_op = 1;
        sbuf.sem_flg = SEM_UNDO;
        return semop(*lock, &sbuf, 1);
}

//使用POSIX信号量封装出的二值信号量
#define PBSem_Init(lock, pshared) \
                sem_init((lock), (pshared), 1)
#define PBSem_Destroy(lock) \
                sem_destroy(lock)
#define PBSem_Lock(lock)         \
                sem_wait(lock)
#define PBSem_Trylock(lock) \
                sem_trywait(lock)
#define PBSem_Timedwait(lock, tsptr)     \
                sem_timedwait((lock), (tsptr))
#define PBSem_Unlock(lock) \
                sem_post((lock))

#define NLOOPS 1000
#define SIZE sizeof(long)

static int update(long* ptr) {
	return (*ptr)++;
}

int main(void)
{
	int fd, counter;
	pid_t pid;
	void* area;

	if ((fd = open("/dev/zero", O_RDWR)) < 0)
		err_sys("open error");
	if ((area = mmap(0, SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0)) == MAP_FAILED)
		err_sys("mmap error");
	close(fd);

	/* 对存储映射区中的数据交替由父子进程递增 */
	TELL_WAIT();
	if ((pid = fork()) < 0)
		err_sys("fork error");
	else if (pid == 0) {
		for (int i = 0; i < NLOOPS; i += 2) {
			if ((counter = update((long*)area)) != i) {
				printf("child: expected %d, got %d", i, counter); exit(1);
			}
			
			TELL_PARENT(getppid());
			WAIT_PARENT();
		}
	}
	else {
		for (int i = 1; i < NLOOPS; i += 2) {
			WAIT_CHILD();

			if ((counter = update((long*)area)) != i) {
				printf("parent: expected %d, got %d", i, counter); exit(1);
			}

			TELL_CHILD(pid);
		}
		if (waitpid(pid, NULL, 0) != pid)
			err_sys("waitpid error");
		printf("final value: %ld\n", *(long*)area);
	}

	exit(EXIT_SUCCESS);
}

myipc13.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <semaphore.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int lock_reg(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        return fcntl(fd, cmd, &flockbuf);
}

int lock_test(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        if (fcntl(fd, F_GETLK, &flockbuf) < 0)
                err_sys("fcntl error");
        if (flockbuf.l_type == F_UNLCK)
                return 0;
        return flockbuf.l_pid;
}

#define read_lock(fd, offset, whence, len) \
              lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
#define readw_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
#define write_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define writew_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
#define un_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))

#define lockfile(fd) write_lock((fd), 0, SEEK_SET, 0)

//是否可设置读锁
#define is_read_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_RDLCK, (offset), (whence), (len)) == 0)
//是否可设置写锁
#define is_write_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_WRLCK, (offset), (whence), (len)) == 0)

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}


const char* transformTime(time_t t, const char* format)
{
	static char buf[128];
	struct tm* ptm;

	if ((ptm = localtime(&t)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

static sigset_t newmask, oldmask, zeromask;
static volatile sig_atomic_t sigflag;

static void sig_usr(int signo) {
        sigflag = 1;
}

void TELL_WAIT(void) {
        if (signal(SIGUSR1, sig_usr) == SIG_ERR)
                err_sys("signal error\n");
        if (signal(SIGUSR2, sig_usr) == SIG_ERR)
                err_sys("signal error\n");
        sigemptyset(&newmask);
        sigemptyset(&zeromask);
        sigaddset(&newmask, SIGUSR1);
        sigaddset(&newmask, SIGUSR2);

        //是当前进程对SIGUSRx信号进行阻塞
        if (sigprocmask(SIG_BLOCK, &newmask, &oldmask) == -1)
                err_sys("sigprocmask error\n");
}

void TELL_PARENT(pid_t pid) {
        kill(pid, SIGUSR2);
}

void TELL_CHILD(pid_t pid) {
        kill(pid, SIGUSR1);
}

void WAIT_CHILD(void) {
        while (sigflag == 0)
                sigsuspend(&zeromask);//暂时解除阻塞并休眠，直到子进程发送SIGUSR2信号过来
        sigflag = 0;

        if (sigprocmask(SIG_SETMASK, &oldmask, NULL) == -1)
                err_sys("sigprocmask error\n");
}

void WAIT_PARENT(void) {
        while (sigflag == 0)
                sigsuspend(&zeromask);
        sigflag = 0;

        if (sigprocmask(SIG_SETMASK, &oldmask, NULL) == -1)
                err_sys("sigprocmask error\n");
}

#define BUFSIZE 4096

#define IPC_PERM 0666

#define DEFAULT_PATH "/tmp"
#define DEFAULT_PROID 1

union semun {
        int val;
        struct semid_ds* buf;
        unsigned short* array;
};


typedef int lock_t;

/**
 * 创建或引用一个二值信号量，然后对其调用semop函数设置其值为1，改变
 * 与信号量相关的semid_ds中的sem_otime，防止竞态条件的发生。在创建
 * 信号量进程还没有改变sem_time之前别的进程是无法对该信号量进行操作的
 */
int BSem_Create(lock_t* lock, const char* path, int projid) {
        key_t semkey;
        union semun arg;
        struct sembuf sbuf;
        struct semid_ds dsbuf;
        const int MAX_TRIES = 10;

        if (path == NULL || projid < 0 || projid>255) {
                path = DEFAULT_PATH;
                projid = DEFAULT_PROID;
        }
        if ((semkey = ftok(path, projid)) == -1)
                return -1;
        if ((*lock = semget(semkey, 1, IPC_CREAT | IPC_EXCL | IPC_PERM)) != -1) {
                arg.val = 0;
                sbuf.sem_num = 0;
                sbuf.sem_op = 1;

                if (semctl(*lock, 0, SETVAL, arg) == -1)
                        return -1;
                if (semop(*lock, &sbuf, 1) == -1)
                        return -1;
        }
        else {
                if (errno != EEXIST)
                        return -1;

                arg.buf = &dsbuf;
                if ((*lock = semget(semkey, 0, 0)) == -1)
                        return -1;
                for (int i = 0; i < MAX_TRIES; ++i) {
                        if (semctl(*lock, 0, IPC_STAT, arg) == -1)
                                return -1;
                        if (arg.buf->sem_otime != 0)
                                break;
                        sleep(1);
                }
                if (arg.buf->sem_otime == 0)
                        return -1;
        }
        return 0;
}


/**
 * 另一种创建二值信号量的方式，但是没有做出进程间竞态条件的
 * 防范措施，但是在多线程进程中使用还是够用的
 */
int BSem_Create1(lock_t* lock, const char* path, int projid) {
        key_t semkey;

        if (path == NULL || projid < 0 || projid>255)
                *lock = semget(IPC_PRIVATE, 1, IPC_CREAT | IPC_EXCL | IPC_PERM);
        else {
                if ((semkey = ftok(path, projid)) == -1)
                        return -1;
                *lock = semget(semkey, 1, IPC_CREAT | IPC_EXCL | IPC_PERM);
        }
        if (*lock == -1)
                return -1;
        return 0;
}


/**
 * 初始化二值信号量的值为指定值
 */
int BSem_Init(lock_t* lock, int initv) {
        union semun arg;

        arg.val = initv;
        return semctl(*lock, 0, SETVAL, arg);
}


/**
 * 删除指定二值信号量
 */
int BSem_Destroy(lock_t* lock) {
        return semctl(*lock, 0, IPC_RMID);
}


/**
 * 试图对信号量值-1，信号调整值+1
 */
int BSem_Sub(lock_t* lock) {
        struct sembuf sbuf;

        sbuf.sem_num = 0;
        sbuf.sem_op = -1;
        sbuf.sem_flg = SEM_UNDO;
        return semop(*lock, &sbuf, 1);
}


/**
 * 试图对信号量+1，信号量-1
 */
int BSem_Add(lock_t* lock) {
        struct sembuf sbuf;

        sbuf.sem_num = 0;
        sbuf.sem_op = 1;
        sbuf.sem_flg = SEM_UNDO;
        return semop(*lock, &sbuf, 1);
}

//使用POSIX信号量封装出的二值信号量
#define PBSem_Init(lock, pshared) \
                sem_init((lock), (pshared), 1)
#define PBSem_Destroy(lock) \
                sem_destroy(lock)
#define PBSem_Lock(lock)         \
                sem_wait(lock)
#define PBSem_Trylock(lock) \
                sem_trywait(lock)
#define PBSem_Timedwait(lock, tsptr)     \
                sem_timedwait((lock), (tsptr))
#define PBSem_Unlock(lock) \
                sem_post((lock))

#define NLOOPS 1000
#define SIZE sizeof(long)

static int update(long* ptr) {
	return (*ptr)++;
}

int main(void)
{
	int counter;
	pid_t pid;
	void* area;

	if ((area = mmap(0, SIZE, PROT_READ | PROT_WRITE, MAP_ANON | MAP_SHARED, -1, 0)) == MAP_FAILED)
		err_sys("mmap error");
	*(long*)area = 0;

	/* 对存储映射区中的数据交替由父子进程递增 */
	TELL_WAIT();
	if ((pid = fork()) < 0)
		err_sys("fork error");
	else if (pid == 0) {
		for (int i = 0; i < NLOOPS; i += 2) {
			if ((counter = update((long*)area)) != i) {
				printf("child: expected %d, got %d", i, counter); exit(1);
			}
			
			TELL_PARENT(getppid());
			WAIT_PARENT();
		}
	}
	else {
		for (int i = 1; i < NLOOPS; i += 2) {
			WAIT_CHILD();

			if ((counter = update((long*)area)) != i) {
				printf("parent: expected %d, got %d", i, counter); exit(1);
			}

			TELL_CHILD(pid);
		}
		if (waitpid(pid, NULL, 0) != pid)
			err_sys("waitpid error");
		printf("final value: %ld\n", *(long*)area);
	}

	exit(EXIT_SUCCESS);
}

myipc14.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <semaphore.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int lock_reg(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        return fcntl(fd, cmd, &flockbuf);
}

int lock_test(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        if (fcntl(fd, F_GETLK, &flockbuf) < 0)
                err_sys("fcntl error");
        if (flockbuf.l_type == F_UNLCK)
                return 0;
        return flockbuf.l_pid;
}

#define read_lock(fd, offset, whence, len) \
              lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
#define readw_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
#define write_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define writew_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
#define un_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))

#define lockfile(fd) write_lock((fd), 0, SEEK_SET, 0)

//是否可设置读锁
#define is_read_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_RDLCK, (offset), (whence), (len)) == 0)
//是否可设置写锁
#define is_write_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_WRLCK, (offset), (whence), (len)) == 0)

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}


const char* transformTime(time_t t, const char* format)
{
	static char buf[128];
	struct tm* ptm;

	if ((ptm = localtime(&t)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

static sigset_t newmask, oldmask, zeromask;
static volatile sig_atomic_t sigflag;

static void sig_usr(int signo) {
        sigflag = 1;
}

void TELL_WAIT(void) {
        if (signal(SIGUSR1, sig_usr) == SIG_ERR)
                err_sys("signal error\n");
        if (signal(SIGUSR2, sig_usr) == SIG_ERR)
                err_sys("signal error\n");
        sigemptyset(&newmask);
        sigemptyset(&zeromask);
        sigaddset(&newmask, SIGUSR1);
        sigaddset(&newmask, SIGUSR2);

        //是当前进程对SIGUSRx信号进行阻塞
        if (sigprocmask(SIG_BLOCK, &newmask, &oldmask) == -1)
                err_sys("sigprocmask error\n");
}

void TELL_PARENT(pid_t pid) {
        kill(pid, SIGUSR2);
}

void TELL_CHILD(pid_t pid) {
        kill(pid, SIGUSR1);
}

void WAIT_CHILD(void) {
        while (sigflag == 0)
                sigsuspend(&zeromask);//暂时解除阻塞并休眠，直到子进程发送SIGUSR2信号过来
        sigflag = 0;

        if (sigprocmask(SIG_SETMASK, &oldmask, NULL) == -1)
                err_sys("sigprocmask error\n");
}

void WAIT_PARENT(void) {
        while (sigflag == 0)
                sigsuspend(&zeromask);
        sigflag = 0;

        if (sigprocmask(SIG_SETMASK, &oldmask, NULL) == -1)
                err_sys("sigprocmask error\n");
}

#define BUFSIZE 4096

#define IPC_PERM 0666

#define DEFAULT_PATH "/tmp"
#define DEFAULT_PROID 1

union semun {
        int val;
        struct semid_ds* buf;
        unsigned short* array;
};


typedef int lock_t;

/**
 * 创建或引用一个二值信号量，然后对其调用semop函数设置其值为1，改变
 * 与信号量相关的semid_ds中的sem_otime，防止竞态条件的发生。在创建
 * 信号量进程还没有改变sem_time之前别的进程是无法对该信号量进行操作的
 */
int BSem_Create(lock_t* lock, const char* path, int projid) {
        key_t semkey;
        union semun arg;
        struct sembuf sbuf;
        struct semid_ds dsbuf;
        const int MAX_TRIES = 10;

        if (path == NULL || projid < 0 || projid>255) {
                path = DEFAULT_PATH;
                projid = DEFAULT_PROID;
        }
        if ((semkey = ftok(path, projid)) == -1)
                return -1;
        if ((*lock = semget(semkey, 1, IPC_CREAT | IPC_EXCL | IPC_PERM)) != -1) {
                arg.val = 0;
                sbuf.sem_num = 0;
                sbuf.sem_op = 1;

                if (semctl(*lock, 0, SETVAL, arg) == -1)
                        return -1;
                if (semop(*lock, &sbuf, 1) == -1)
                        return -1;
        }
        else {
                if (errno != EEXIST)
                        return -1;

                arg.buf = &dsbuf;
                if ((*lock = semget(semkey, 0, 0)) == -1)
                        return -1;
                for (int i = 0; i < MAX_TRIES; ++i) {
                        if (semctl(*lock, 0, IPC_STAT, arg) == -1)
                                return -1;
                        if (arg.buf->sem_otime != 0)
                                break;
                        sleep(1);
                }
                if (arg.buf->sem_otime == 0)
                        return -1;
        }
        return 0;
}


/**
 * 另一种创建二值信号量的方式，但是没有做出进程间竞态条件的
 * 防范措施，但是在多线程进程中使用还是够用的
 */
int BSem_Create1(lock_t* lock, const char* path, int projid) {
        key_t semkey;

        if (path == NULL || projid < 0 || projid>255)
                *lock = semget(IPC_PRIVATE, 1, IPC_CREAT | IPC_EXCL | IPC_PERM);
        else {
                if ((semkey = ftok(path, projid)) == -1)
                        return -1;
                *lock = semget(semkey, 1, IPC_CREAT | IPC_EXCL | IPC_PERM);
        }
        if (*lock == -1)
                return -1;
        return 0;
}


/**
 * 初始化二值信号量的值为指定值
 */
int BSem_Init(lock_t* lock, int initv) {
        union semun arg;

        arg.val = initv;
        return semctl(*lock, 0, SETVAL, arg);
}


/**
 * 删除指定二值信号量
 */
int BSem_Destroy(lock_t* lock) {
        return semctl(*lock, 0, IPC_RMID);
}


/**
 * 试图对信号量值-1，信号调整值+1
 */
int BSem_Sub(lock_t* lock) {
        struct sembuf sbuf;

        sbuf.sem_num = 0;
        sbuf.sem_op = -1;
        sbuf.sem_flg = SEM_UNDO;
        return semop(*lock, &sbuf, 1);
}


/**
 * 试图对信号量+1，信号量-1
 */
int BSem_Add(lock_t* lock) {
        struct sembuf sbuf;

        sbuf.sem_num = 0;
        sbuf.sem_op = 1;
        sbuf.sem_flg = SEM_UNDO;
        return semop(*lock, &sbuf, 1);
}

//使用POSIX信号量封装出的二值信号量
#define PBSem_Init(lock, pshared) \
                sem_init((lock), (pshared), 1)
#define PBSem_Destroy(lock) \
                sem_destroy(lock)
#define PBSem_Lock(lock)         \
                sem_wait(lock)
#define PBSem_Trylock(lock) \
                sem_trywait(lock)
#define PBSem_Timedwait(lock, tsptr)     \
                sem_timedwait((lock), (tsptr))
#define PBSem_Unlock(lock) \
                sem_post((lock))

#define NLOOPS 100000

struct slock {
	sem_t* semp;
	char name[128];
};

struct slock* myslock;
static volatile int svalue;


/**
 * 分配一个二值信号量
 */
struct slock* s_alloc(void) {
	struct slock* sp;
	static int cnt;

	if ((sp = malloc(sizeof(struct slock))) == NULL)
		return NULL;
	do {
		snprintf(sp->name, sizeof(sp->name), "%d.%d", getpid(), cnt++);
		sp->semp = sem_open(sp->name, O_CREAT | O_EXCL, S_IRWXU, 1);
	} while ((sp->semp == SEM_FAILED) && (errno = EEXIST));
	if (sp->semp == SEM_FAILED) {
		free(sp);
		return NULL;
	}
	/* 成功之后立即断开与信号量的连接，删除名字，防止其他
		进程对其的引用，简化进程终止后的清理工作 */
	sem_unlink(sp->name);
	return sp;
}


/**
 * 释放信号量相关的资源
 */
void s_free(struct slock* sp) {
	sem_close(sp->semp);
	free(sp);
}


int s_lock(struct slock* sp) {
	return sem_wait(sp->semp);
}


int s_unlock(struct slock* sp) {
	return sem_post(sp->semp);
}


void* thread_func(void* args) {
	for (int i = 0; i < NLOOPS; ++i) {
		if (s_lock(myslock) == -1) {
			printf("thread(0x%lx) s_lock error", pthread_self()); exit(1);
		}
		svalue++;
		if (s_unlock(myslock) == -1) {
			printf("thread(0x%lx) s_unlock error", pthread_self()); exit(1);
		}
	}
	pthread_exit((void*)NULL);
}


int main(void)
{
	pthread_t tid1, tid2;

	if ((myslock = s_alloc()) == NULL)
		err_sys("s_alloc error");
	if (pthread_create(&tid1, NULL, thread_func, (void*)NULL) == -1)
		err_sys("pthread_create error");
	if (pthread_create(&tid2, NULL, thread_func, (void*)NULL) == -1)
		err_sys("pthread_create error");
	if (pthread_join(tid1, NULL) == -1)
		err_sys("pthread_join error");
	if (pthread_join(tid2, NULL) == -1)
		err_sys("pthread_join error");
	printf("final svalue: %d\n", svalue);
	s_free(myslock);

	exit(EXIT_SUCCESS);
}

myipc15.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <semaphore.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int lock_reg(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        return fcntl(fd, cmd, &flockbuf);
}

int lock_test(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        if (fcntl(fd, F_GETLK, &flockbuf) < 0)
                err_sys("fcntl error");
        if (flockbuf.l_type == F_UNLCK)
                return 0;
        return flockbuf.l_pid;
}

#define read_lock(fd, offset, whence, len) \
              lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
#define readw_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
#define write_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define writew_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
#define un_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))

#define lockfile(fd) write_lock((fd), 0, SEEK_SET, 0)

//是否可设置读锁
#define is_read_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_RDLCK, (offset), (whence), (len)) == 0)
//是否可设置写锁
#define is_write_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_WRLCK, (offset), (whence), (len)) == 0)

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}


const char* transformTime(time_t t, const char* format)
{
	static char buf[128];
	struct tm* ptm;

	if ((ptm = localtime(&t)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

static sigset_t newmask, oldmask, zeromask;
static volatile sig_atomic_t sigflag;

static void sig_usr(int signo) {
        sigflag = 1;
}

void TELL_WAIT(void) {
        if (signal(SIGUSR1, sig_usr) == SIG_ERR)
                err_sys("signal error\n");
        if (signal(SIGUSR2, sig_usr) == SIG_ERR)
                err_sys("signal error\n");
        sigemptyset(&newmask);
        sigemptyset(&zeromask);
        sigaddset(&newmask, SIGUSR1);
        sigaddset(&newmask, SIGUSR2);

        //是当前进程对SIGUSRx信号进行阻塞
        if (sigprocmask(SIG_BLOCK, &newmask, &oldmask) == -1)
                err_sys("sigprocmask error\n");
}

void TELL_PARENT(pid_t pid) {
        kill(pid, SIGUSR2);
}

void TELL_CHILD(pid_t pid) {
        kill(pid, SIGUSR1);
}

void WAIT_CHILD(void) {
        while (sigflag == 0)
                sigsuspend(&zeromask);//暂时解除阻塞并休眠，直到子进程发送SIGUSR2信号过来
        sigflag = 0;

        if (sigprocmask(SIG_SETMASK, &oldmask, NULL) == -1)
                err_sys("sigprocmask error\n");
}

void WAIT_PARENT(void) {
        while (sigflag == 0)
                sigsuspend(&zeromask);
        sigflag = 0;

        if (sigprocmask(SIG_SETMASK, &oldmask, NULL) == -1)
                err_sys("sigprocmask error\n");
}

#define BUFSIZE 4096

#define IPC_PERM 0666

#define DEFAULT_PATH "/tmp"
#define DEFAULT_PROID 1

union semun {
        int val;
        struct semid_ds* buf;
        unsigned short* array;
};


typedef int lock_t;

/**
 * 创建或引用一个二值信号量，然后对其调用semop函数设置其值为1，改变
 * 与信号量相关的semid_ds中的sem_otime，防止竞态条件的发生。在创建
 * 信号量进程还没有改变sem_time之前别的进程是无法对该信号量进行操作的
 */
int BSem_Create(lock_t* lock, const char* path, int projid) {
        key_t semkey;
        union semun arg;
        struct sembuf sbuf;
        struct semid_ds dsbuf;
        const int MAX_TRIES = 10;

        if (path == NULL || projid < 0 || projid>255) {
                path = DEFAULT_PATH;
                projid = DEFAULT_PROID;
        }
        if ((semkey = ftok(path, projid)) == -1)
                return -1;
        if ((*lock = semget(semkey, 1, IPC_CREAT | IPC_EXCL | IPC_PERM)) != -1) {
                arg.val = 0;
                sbuf.sem_num = 0;
                sbuf.sem_op = 1;

                if (semctl(*lock, 0, SETVAL, arg) == -1)
                        return -1;
                if (semop(*lock, &sbuf, 1) == -1)
                        return -1;
        }
        else {
                if (errno != EEXIST)
                        return -1;

                arg.buf = &dsbuf;
                if ((*lock = semget(semkey, 0, 0)) == -1)
                        return -1;
                for (int i = 0; i < MAX_TRIES; ++i) {
                        if (semctl(*lock, 0, IPC_STAT, arg) == -1)
                                return -1;
                        if (arg.buf->sem_otime != 0)
                                break;
                        sleep(1);
                }
                if (arg.buf->sem_otime == 0)
                        return -1;
        }
        return 0;
}


/**
 * 另一种创建二值信号量的方式，但是没有做出进程间竞态条件的
 * 防范措施，但是在多线程进程中使用还是够用的
 */
int BSem_Create1(lock_t* lock, const char* path, int projid) {
        key_t semkey;

        if (path == NULL || projid < 0 || projid>255)
                *lock = semget(IPC_PRIVATE, 1, IPC_CREAT | IPC_EXCL | IPC_PERM);
        else {
                if ((semkey = ftok(path, projid)) == -1)
                        return -1;
                *lock = semget(semkey, 1, IPC_CREAT | IPC_EXCL | IPC_PERM);
        }
        if (*lock == -1)
                return -1;
        return 0;
}


/**
 * 初始化二值信号量的值为指定值
 */
int BSem_Init(lock_t* lock, int initv) {
        union semun arg;

        arg.val = initv;
        return semctl(*lock, 0, SETVAL, arg);
}


/**
 * 删除指定二值信号量
 */
int BSem_Destroy(lock_t* lock) {
        return semctl(*lock, 0, IPC_RMID);
}


/**
 * 试图对信号量值-1，信号调整值+1
 */
int BSem_Sub(lock_t* lock) {
        struct sembuf sbuf;

        sbuf.sem_num = 0;
        sbuf.sem_op = -1;
        sbuf.sem_flg = SEM_UNDO;
        return semop(*lock, &sbuf, 1);
}


/**
 * 试图对信号量+1，信号量-1
 */
int BSem_Add(lock_t* lock) {
        struct sembuf sbuf;

        sbuf.sem_num = 0;
        sbuf.sem_op = 1;
        sbuf.sem_flg = SEM_UNDO;
        return semop(*lock, &sbuf, 1);
}

//使用POSIX信号量封装出的二值信号量
#define PBSem_Init(lock, pshared) \
                sem_init((lock), (pshared), 1)
#define PBSem_Destroy(lock) \
                sem_destroy(lock)
#define PBSem_Lock(lock)         \
                sem_wait(lock)
#define PBSem_Trylock(lock) \
                sem_trywait(lock)
#define PBSem_Timedwait(lock, tsptr)     \
                sem_timedwait((lock), (tsptr))
#define PBSem_Unlock(lock) \
                sem_post((lock))

#define NLOOPS 100000

typedef sem_t plock_t;

plock_t lock;
static volatile int svalue;


void* thread_func(void* args) {
	for (int i = 0; i < NLOOPS; ++i) {
		if (PBSem_Lock(&lock) == -1) {
			printf("thread(0x%lx) s_lock error", pthread_self()); exit(1);
		}
		svalue++;
		if (PBSem_Unlock(&lock) == -1) {
			printf("thread(0x%lx) s_unlock error", pthread_self()); exit(1);
		}
	}
	pthread_exit((void*)NULL);
}


int main(void)
{
	pthread_t tid1, tid2;

	if (PBSem_Init(&lock, 0) == -1)
		err_sys("PBSem_Init error");
	if (pthread_create(&tid1, NULL, thread_func, (void*)NULL) == -1)
		err_sys("pthread_create error");
	if (pthread_create(&tid2, NULL, thread_func, (void*)NULL) == -1)
		err_sys("pthread_create error");
	if (pthread_join(tid1, NULL) == -1)
		err_sys("pthread_join error");
	if (pthread_join(tid2, NULL) == -1)
		err_sys("pthread_join error");
	printf("final svalue: %d\n", svalue);
	if (PBSem_Destroy(&lock) == -1)
		err_sys("PBSem_Destroy error");

	exit(EXIT_SUCCESS);
}

mystrsignal.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <syslog.h>
#include <aio.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int main(int argc, char* argv[])
{
	int err;

	if (argc != 2) {
		printf("usage: %s <signo>", argv[0]); exit(1);
	}
	err = atoi(argv[1]);
	printf("signal(%d): %s\n", err, strsignal(err));
	exit(EXIT_SUCCESS);
}



消息队列、信号灯、共享内存常用在Linux服务端编程的进程间通信环境中。而此三类编程函数在实际项目中都是用System V IPC函数实现的。

			消息队列			信号灯		共享内存区
头文件			<sys/msg.h>		<sys/sem.h>	<sys/shm.h>
创建或打开IPC函数	msgget			semget		shmget
控制IPC操作的函数	msgctl			semctl		shmctl
IPC操作函数		msgsnd,msgrcv		semop		shmat,shmdt

key_t键和ftok函数
函数ftok把一个已存在的路径名和一个整数标识符转换成一个key_t值（也称IPC key键值）。ftok函数原型及说明如下：
所需头文件	#include <sys/types.h>
		#include <sys/ipc.h>
函数说明		把从pathname导出的信息与id的低序8位组合成一个整数IPC键
函数原型		key_t ftok(const char *pathname, int proj_id)
函数传入值	pathname：指定的文件，此文件必须存在且可存取
		proj_id：计划代号（project ID）
函数返回值	成功：返回key_t值（即IPC 键值）
		出错：-1，错误原因存于errno中
附加说明		key_t一般为32位的int型的重定义

ftok的典型实现是调用stat函数，然后组合以下三个值：
①    pathname所在的文件系统的信息（stat结构的st_dev成员）。
②    该文件在本文件系统内的索引节点号(stat结构的st_ino成员)。
③    proj_id的低序8位（不能为0）。
上述三个值的组合产生一个32位键。

ftok返回的是根据文件（pathname）信息和计划编号（proj_id）合成的IPC key键值，从而避免用户使用key值的冲突。proj_id值的意义让一个文件也能生成多个IPC key键值。
ftok利用同一文件最多可得到IPC key键值0xff（即256）个，因为ftok只取proj_id值二进制的后8位，即16进制的后两位与文件信息合成IPC key键值。

IPC键值与IPC标识符
（1）key值选择方式
对于key值，应用程序有如下三种选择：
①    调用ftok，给它传递pathname和proj_id，操作系统根据两者合成key值。
②    指定key为IPC_PRIVATE，内核保证创建一个新的、唯一的IPC对象，IPC标识符与内存中的标识符不会冲突。IPC_PRIVATE为宏定义，其值等于0。
③    指定key为大于0的常数，这需要用户自行保证生成的IPC key值不与系统中存在的冲突，而前两种是操作系统保证的。
（2）IPC标识符
给semget、msgget、shmget传入key值，它们返回的都是相应的IPC对象标识符。注意IPC键值和IPC标识符是两个概念，后者是建立在前者之上。
key为IPC键值，由ftok函数生成；ipc_id为IPC标识符，由semget、msgget、shmget函数生成。ipc_id在信号量函数中称为semid，在消息队列函数中称为msgid，在共享内存函数中称为shmid，它们表示的是各自IPC对象标识符。

ipc_perm结构说明
系统为每一个IPC对象保存一个ipc_perm结构体，该结构说明了IPC对象的权限和所有者，并确定了一个IPC操作是否可以访问该IPC对象。
struct ipc_perm {
     	key_t   key ;          /* 此IPC对象的key键 */
	uid_t   uid ;          /* 此IPC对象用户ID */
	gid_t   gid ;          /* 此IPC对象组ID */
	uid_t   cuid ;         /* IPC对象创建进程的有效用户ID */
	gid_t   cgid ;         /* IPC对象创建进程的有效组ID */
	mode_t   mode ;        /* 此IPC的读写权限 */
	ulong_t  seq ;         /* IPC对象的序列号 */
} ;
ipc_perm中mode的含义，其含义与文件访问权限相似。当调用IPC对象创建函数（semget、msgget、shmget）时，会对ipc_perm结构变量的每一个成员赋值，
其中mode的值来源于IPC对象创建函数最右边的形参flag（msgget中为msgflg、semget中为semflg、shmget中shmflg）。如需修改这几个成员变量则需调用相应的控制函数（msgctl、semctl、shmctl）。        

IPC对象的创建权限
msgget、semget、shmget函数最右边的形参flag（msgget中为msgflg、semget中为semflg、shmget中shmflg）为IPC对象创建权限，三种xxxget函数中flag的作用基本相同。
IPC对象创建权限(即flag）格式为0xxxxx，其中0表示8位制，低三位为用户、属组、其他的读、写、执行权限(执行位不使用)，其含义与ipc_perm的mode相同。
在这里姑且把IPC对象创建权限格式的低三位称为“IPC对象存取权限”。如0600代表只有此用户下的进程才有可读可写权限。IPC对象存取权限常与下面IPC_CREAT、IPC_EXCL两种标志进行或（|）运算完成对IPC对象创建的管理，
在这里姑且把IPC_CREAT、IPC_EXCL两种标志称为IPC创建模式标志。下面是两种创建模式标志在<sys/ipc.h>头文件中的宏定义。
#define IPC_CREAT    01000    /* Create key if key does not exist. */
#define IPC_EXCL     02000     /* Fail if key exists.  */
综上所述，flag标志由两部分组成，一为IPC对象存取权限（含义同ipc_perm中的mode）,一为IPC对象创建模式标志（IPC_CREAT、IPC_EXCL），两者进行|运算合成IPC对象创建权限。
创建或打开IPC对象流程图
semget、msgget、shmget函数的作用是创建一个新的IPC对象或者访问一个已存在的IPC对象。其创建或访问的规则如下：
①    指定key为IPC_PRIVATE操作系统保证创建一个唯一的IPC对象。
②    设置flag参数的IPC_CREAT位但不设置它的IPC_EXCL位时，如果所指定key键的IPC对象不存在，那就是创建一个新的对象；否则返回该对象。
③    同时设置flag的IPC_CREAT和IPC_EXCL位时，如果所指定key键的IPC对象不存在，那就创建一个新的对象；否则返回一个EEXIST错误，因为该对象已存在。
flag创建模式标志			不存在			已存在
无特殊标志			出错，errno=ENOENT	成功，引用已存在对象
IPC_CREAT			成功，创建新对象		成功，引用已存在对象
IPC_CREAT|IPC_EXCL		成功，创建新对象		出错，errno=EEXIST

使用semget、msgget、shmget创建一个IPC对象时，需要指定flag标志，在key不等于IPC_PRIVATE情况下，flag标志决定了创建方式和创建后IPC对象的存取权限。
在key等于IPC_PRIVATE情况下，flag标志决定了创建后IPC对象的存取权限。如果只是引用一个已经存在的IPC对象只需把flag标志设为0即可。
有关该函数的三个常见问题：
1.pathname是目录还是文件的具体路径，是否可以随便设置
2.pathname指定的目录或文件的权限是否有要求
3.proj_id是否可以随便设定，有什么限制条件
解答：
   1、ftok根据路径名，提取文件信息，再根据这些文件信息及project ID合成key，该路径可以随便设置。
    2、该路径是必须存在的，ftok只是根据文件inode在系统内的唯一性来取一个数值，和文件的权限无关。
    3、proj_id是可以根据自己的约定，随意设置。这个数字,有的称之为project ID; 在UNIX系统上,它的取值是1到255;
关于ftok()函数的一个陷阱
     在使用ftok()函数时，里面有两个参数，即fname和id，fname为指定的文件名，而id为子序列号，这个函数的返回值就是key，它与指定的文件的索引节点号和子序列号id有关，
     这样就会给我们一个误解，即只要文件的路径，名称和子序列号不变，那么得到的key值永远就不会变。
     事实上，这种认识是错误的，想想一下，假如存在这样一种情况：在访问同一共享内存的多个进程先后调用ftok()时间段中，如果fname指向的文件或者目录被删除而且又重新创建，
     那么文件系统会赋予这个同名文件新的i节点信息，于是这些进程调用的ftok()都能正常返回，但键值key却不一定相同了。
     由此可能造成的后果是，原本这些进程意图访问一个相同的共享内存对象，然而由于它们各自得到的键值不同，实际上进程指向的共享内存不再一致；
     如果这些共享内存都得到创建，则在整个应用运行的过程中表面上不会报出任何错误，然而通过一个共享内存对象进行数据传输的目的将无法实现。
     这是一个很重要的问题，希望能谨记！！！
     所以要确保key值不变，要么确保ftok()的文件不被删除，要么不用ftok()，指定一个固定的key值。

消息队列本质上是位于内核空间的链表，链表的每个节点都是一条消息。每一条消息都有自己的消息类型，消息类型用整数来表示，而且必须大于 0。
每种类型的消息都被对应的链表所维护，实际上，消息类型为 0 的链表记录了所有消息加入队列的顺序。

消息队列相关的函数
// 创建和获取 ipc 内核对象
int msgget(key_t key, int flags);
// 将消息发送到消息队列
int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
// 从消息队列获取消息
ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
// 查看、设置、删除 ipc 内核对象（用法和 shmctl 一样）
int msgctl(int msqid, int cmd, struct msqid_ds *buf);

消息数据格式
无论你是发送还是接收消息，消息的格式都必须按照规范来。简单的说，它一般长成下面这个样子：

struct Msg{
    long type; // 消息类型。这个是必须的，而且值必须 > 0，这个值被系统使用
    // 消息正文，多少字节随你而定
    // ...
};
所以，只要你保证首4字节(32 位 linux 下的 long)是一个整数就行了。
举个例子：

struct Msg {
    long type;
    char name[20];
    int age;
} msg;

struct Msg {
    long type;
    int start;
    int end;
} msg;
从上面可以看出，正文部分是什么数据类型都没关系，因为消息队列传递的是 2 进制数据，不一定非得是文本。

msgsnd 函数
msgsnd 函数用于将数据发送到消息队列。如果该函数被信号打断，会设置 errno 为 EINTR。

int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
参数 msqid：ipc 内核对象 id
参数 msgp：消息数据地址
参数 msgsz：消息正文部分的大小（不包含消息类型）
参数 msgflg：可选项
该值为 0：如果消息队列空间不够，msgsnd 会阻塞。
IPC_NOWAIT：直接返回，如果空间不够，会设置 errno 为 EAGIN.

返回值：0 表示成功，-1 失败并设置 errno。

msgrcv 函数
msgrcv 函数从消息队列取出消息后，并将其从消息队列里删除。

ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
参数 msqid：ipc 内核对象 id
参数 msgp：用来接收消息数据地址
参数 msgsz：消息正文部分的大小（不包含消息类型）
参数 msgtyp：指定获取哪种类型的消息
msgtyp = 0：获取消息队列中的第一条消息
msgtyp > 0：获取类型为 msgtyp 的第一条消息，除非指定了 msgflg 为MSG_EXCEPT，这表示获取除了 msgtyp 类型以外的第一条消息。
msgtyp < 0：获取类型 <=msgtyp绝对值的第一条消息。
参数 msgflg：可选项。
如果为 0 表示没有消息就阻塞。
IPC_NOWAIT：如果指定类型的消息不存在就立即返回，同时设置 errno 为 ENOMSG
MSG_EXCEPT：仅用于 msgtyp > 0 的情况。表示获取类型不为 msgtyp 的消息
MSG_NOERROR：如果消息数据正文内容大于 msgsz，就将消息数据截断为 msgsz

msgctl函数
获取和设置消息队列的属性

int msgctl(int msqid, int cmd, struct msqid_ds *buf);
msqid：消息队列标识符
cmd：控制指令
IPC_STAT:获得msgid的消息队列头数据到buf中
IPC_SET：设置消息队列的属性，要设置的属性需先存储在buf中，可设置的属性包括：msg_perm.uid、msg_perm.gid、msg_perm.mode以及msg_qbytes
buf：消息队列管理结构体。

返回值：
成功：0
出错：-1，错误原因存于errno中
EACCESS：参数cmd为IPC_STAT时，表示无权限读取该消息队列
EFAULT：参数buf指向无效的内存地址
EIDRM：标识符为msqid的消息队列已被删除
EINVAL：无效的参数cmd或msqid
EPERM：参数cmd为IPC_SET或IPC_RMID，却无足够的权限执行

信号量介绍

作用：实现进程间的同步和互斥。
信号量，确切地说是信号量集，集合里有≥1个信号量成员。可以把信号量集比作数组，信号量当做数组用的元素。
但是，常用的信号量集都只有一个信号量成员。所以，平常说的信号量一般都指只有1个信号量成员的信号量集。
个人理解：信号量类似标志位。平常的标志位是这样的，初始flag =1. 如果flag=0则去执行某些操作，在程序的某些地方使flag置0。
不同的是，标志位只能用来实现当前进程的同步和互斥，而信号量是用来实现不同进程间的同步和互斥
什么是PV操作？
p操作（wait）：申请一个单位资源，进程进入
v操作（signal）：释放一个单位资源，进程出来
个人理解：进程的信号量有点像线程的互斥锁，P操作相当于上锁，V操作相当于解锁。

二、信号量函数由semget、semop、semctl三个函数组成。

1. semget函数
函数原型：
int semget(key_t key, int nsems, int semflg);

作用：创建一个新的信号量集或是获得一个已存在的信号量集的标识符

第一个参数key：  由ftok函数返回得到的IPC键值（常用）；或者0(IPC_PRIVATE)—— 创建一个只有创建进程可以访问的信号量

第二个参数nsems：创建的信号量集合中信号量的个数。（通常为1，表示单信号量）

第三个参数semflg：0表示获取已存在的信号量标识符；

                                IPC_CREAT 表示key对应的信号量不存在则创建，存在则直接返回该信号量的标识符；

                                IPC_CREAT|IPC_EXCL 表示key对应的信号量不存在则创建，存在则报错。

分析：  semflg是一个32位的整数，像IPC_CREAT和IPC_EXCL其实只用到了高24位表示，

低8位是权限位。一般用0666（6的二进制是110，表示可读，可写，不可执行，三个6分别对应当前用户，group组用户，其他用户）

返回值：成功返回信号量集的标识符，失败返回-1。

2. semop函数
函数原型：

int semop(int semid, struct sembuf *sops, unsigned nsops);

作用: 改变信号量的值

第一个参数semid：由semget返回得到的信号量标识符

第二个参数sops：
	struct sembuf {
		unsigned short sem_num;		//通常为0
		short sem_op;			//通常为±1，-1表示P操作，+1表示V操作
		short sem_flg;			//通常为SEM_UNDO
	}
	sem_num：信号量集数组的下标，表示某一个信号量。0表示第1个信号量（通常为0，一般只用单信号量）
	sem_op：信号量的变化量值。
（可以任意改变信号量值，而不只是1）但通常情况下中使用两个值，-1是P操作，用来等待一个信号量变得可用，而+1是V操作，用来通知一个信号量可用。
	sem_flg：通常为SEM_UNDO，表示调用该信号量的进程退出时，恢复相应信号量的计数值。
		例如信号量初始值是20，进程a以SEM_UNDO方式操作信号量加1；在进程未退出时，信号量变成21；在进程退出时，信号量的值恢复20。
 第三个参数nsops：进行操作信号量的个数，即sops结构变量的个数。通常设为1，只完成对一个信号量的操作。
返回值：成功返回0，失败返回-1。


3. semctl函数
函数原型：

int semctl(int semid, int semnum, int cmd, ...);

作用：执行在信号量集上的控制操作

第一个参数semid：由semget返回得到的信号量标识符

第二个参数sem_num：信号量集数组的下标，表示某一个信号量。（通常为0）

第三个参数cmd：对信号量所执行的命令，常用命令有：SETVAL / GETVAL ：设置/获取信号量的值；IPC_RMID 从内核中删除信号量

第四个不定参数：有些cmd命令需要额外的参数，一般都是union semun arg 形式

union semun {
	int              val;    		/* Value for SETVAL */
	struct semid_ds *buf;    		/* Buffer for IPC_STAT, IPC_SET */
	unsigned short  *array; 		/* Array for GETALL, SETALL */
	struct seminfo  *__buf;  		/* Buffer for IPC_INFO */
};
 返回值：成功返回一个≥0的整数，具体哪个数值与执行的cmd有关； 失败返回-1。
（比如：cmd为GETVAL，返回值就是get得到的信号量的值;而cmd为SETVAL时,返回值为0表示指令执行成功）


三、通常的执行过程如下：
进程1（sem）：

①调用semget创建信号量；

②调用semctl的SETVAL给信号量设置一个初始值；

③调用semop，执行P操作和V操作

进程2（sem2）：

①调用semget获取已存在的信号量的标识符semid；

②调用semop，执行P操作和V操作。

（注意：如果有另外一进程也使用了该信号量，并且执行了P操作使信号量的值-1，那么此时本进程执行P操作时会阻塞等待直到另一进城执行V操作+1释放资源）

   分析：P操作相当于上锁，V操作相当于解锁。

共享内存是三个IPC机制中的一个。它允许两个不相关的进程访问同一个逻辑内存。共享内存是在两个正在进行的进程之间传递数据的一种非常有效的方式。
 
大多数的共享内存的实现，都把由不同进程之间共享的内存安排为同一段物理内存
首先我们都知道我们执行的每一个程序，它看到的内存其实都是虚拟内存，虚拟内存需要进行页表的映射将进程地址映射到物理内存
 
共享内存特点和优势
 
当中共享内存的大致原理就是让两个进程地址通过页表映射到同一片物理地址以便于通信，你可以给一个区域里面写入数据，理所当然你就可以从中拿取数据，这也就构成了进程间的双向通信。
而且共享内存是IPC通信当中传输速度最快的通信方式没有之一，理由很简单，客户进程和服务进程传递的数据直接从内存里存取、放入数据不需要在两进程间复制，没有什么操作比这简单了。
再者用共享内存进行数据通信，它对数据也没啥限制。最后就是共享内存的生命周期随内核。即所有访问共享内存区域对象的进程都已经正常结束，共享内存区域对象仍然在内核中存在(除非显式删除共享内存区域对象)，
在内核重新引导之前,对该共享内存区域对象的任何改写操作都将一直保留。简单地说，共享内存区域对象的生命周期跟系统内核的生命周期是一致的，而且共享内存区域对象的作用域范围就是在整个系统内核的生命周期之内。
 
 
缺陷
 
但是，共享内存也并不完美，共享内存并未提供同步机制，也就是说，在一个服务进程结束对共享内存的写操作之前，并没有自动机制可以阻止另一个进程（客户进程）开始对它进行读取。
这明显还达不到我们想要的，我们不单是在两进程间交互数据，还想实现多个进程对共享内存的同步访问，这也正是使用共享内存的窍门所在。
基于此，我们通常会用信号量来实现对共享内存同步访问控制。

相关函数

创建共享内存shmget

原型：int shmget(key_t key, size_t size, int shmflg)

返回值:　创建成功，则返回一个非负整数，即共享内存标识；
 　　　　如果失败，则返回-1.
参数：

　　key:    //程序需要提供一个参数key，它为共享内存段提供一个外部名。（每个IPC对象都与一个键 即key相关联，然后此键再由内核变换为标识符）。
	还有一个特殊的键值IPC_PRIVATE, 它用于创建一个只属于该创建进程的新共享内存，通常不会用到；
　　size: 　 //以字节为单位指定需要共享的内存容量。
　　shmflag: //包含9个比特的权限标志，它们的作用与创建文件时使用的mode标志是一样。由IPC_CREAT定义的一个特殊比特位，同时必须和权限标志按位或才能创建一个新的共享内存段。
（注意：若想创建的新IPC结构没有引用具有同一标识符的现有的IPC结构，就要同时指定IPC_CREAT 和 IPC_EXCL；共享内存属IPC中一种，它同样如此）
 
注:
　　权限标志对共享内存非常有用，因为它允许一个进程创建的共享内存可以被共享内存的创建者所拥有的进程写入，同时其它用户创建的进程只能读取共享内存。
      我们可以利用这个功能来提供一种有效的对数据进行只读访问的方法，通过将数据放共享内存并设置它的权限，就可以避免数据被其他用户修改。

将共享内存端挂载到自己地址空间shmat
　　
第一次创建共享内存段时，它不能被任何进程访问。要想启动对该内存的访问，必须将其连接到一个进程的地址空间

该函数原型：void *shmat(int shmid, const void *shmaddr, int shmflg)　
返回值：调用成功返回挂载的虚拟地址空间起始地址，失败返回NULL

参数：

　　int shmid            //是由shmget函数返回的共享内存标识。
　　const void *shmaddr  //指定共享内存连接到当前进程中的地址位置，通常为0，表示让系统来选择共享内存的地址。
　　int shmflg　　　　　//是一组标志位，通常为0。
它还可取:
SHM_RND,用以决定是否将当前共享内存段连接到指定的shmaddr上。该参数和shm_addr联合使用，用来控制共享内存连接的地址，除非只计划在一种硬件上运行应用程序，否则不要这样指定。填0让操作系统自己选择是更好的方式。
SHM_RDONLY单独使用则是指让它使连接的内存段只读，否则以读写方式连接此内存段
　　　　　　　　　　　　
3. 与共享内存段分离 shmdt　

原型：int shmdt(const void *shmaddr)
参数：
　　shm_addr: shmat返回的地址指针。
成功时，返回0，
失败时，返回-1.
 
NOTE:
 
　　仅仅是共享内存分离但并未删除它，其标识符及其相关数据结构都在；直到某个进程使用IPC_RMID调用shmctl特地删除它为止　　
　　只是使得该共享内存对当前进程不再可用。

4. shmctl 共享内存控制函数

    #include <sys/ipc.h>
    #include <sys/shm.h>

    原型： int shmctl(int shmid, int cmd, struct shmid_ds *buf)
参数：　

　　shm_id : 是shmget返回的共享内存标识符。
 
　　cmd: 它可以取3个值:
　　　　IPC_STAT  把shmid_ds结构中的数据设置为共享内存的当前关联值
　　　　IPC_SET   如果进程有足够的权限就把共享内存的当前关联值设置为shmid_ds结构中给出的值
　　　　IPC_RMID  删除共享内存段
 
　　buf:是一个指针，包含共享内存模式和访问权限的结构。
 
　　buf指向的shmid_ds结构体 一定要包含下列一些参数：
    struct shmid_ds {  
      uid_t shm_perm.uid;  
      uid_t shm_perm.gid;  
      mode_t shm_perm.mode;  
    }

POSIX信号量用sem_init函数创建的，下面是它的说明：
　　#include<semaphore.h>
      int sem_init (sem_t *sem, int pshared, unsigned int value);

      这个函数的作用是对由sem指定的信号量进行初始化，设置好它的共享选项，并指定一个整数类型的初始值。pshared参数控制着信号量的类型。
      如果pshared的值是０，就表示它是当前进程的局部信号量；否则，其它进程就能够共享这个信号量。

　　这两个函数控制着信号量的值，它们的定义如下所示：
　　
　　#include <semaphore.h>
      int sem_wait(sem_t * sem);
      int sem_post(sem_t * sem);
 
        这两个函数都要用一个由sem_init调用初始化的信号量对象的指针做参数。
        sem_post函数的作用是给信号量的值加上一个“1”，它是一个“原子操作”
        sem_wait函数也是一个原子操作，它的作用是从信号量的值减去一个“1”，但它永远会先等待该信号量为一个非零值才开始做减法。
        还有另外一个信号量函数sem_trywait，它是sem_wait的非阻塞搭档。

         最后一个信号量函数是sem_destroy。这个函数的作用是在我们用完信号量对它进行清理。下面的定义：
          #include<semaphore.h>
          int sem_destroy (sem_t *sem);
          这个函数也使用一个信号量指针做参数，归还自己占有的资源。在清理信号量的时候如果还有线程在等待它，用户就会收到一个错误。
         与其它的函数一样，这些函数在成功时都返回0。

创建有名信号量
sem_t *sem sem_open(const char *name, int oflag, mode_t mode,unsinged int value);
int sem_close(sem_t *sem);

基于内存的信号量
int sem_init(sem_t *sem,int shared, unsigned int value);

区别：
1.创建有名信号量必须指定一个与信号量相关链的文件名称，这个name通常是文件系统中的某个文件。基于内存的信号量不需要指定名称。
2.有名信号量sem 是由sem_open分配内存并初始化成value值，基于内存的信号量是由应用程序分配内存，有sem_init初始化成为value值。如果shared为1，则分配的信号量应该在共享内存中。
3.sem_open不需要类似shared的参数，因为有名信号量总是可以在不同进程间共享的，而基于内存的信号量通过shared参数来决定是进程内还是进程间共享，并且必须指定相应的内存。
4.基于内存的信号量不使用任何类似于O_CREAT标志的东西，也就是说，sem_init总是初始化信号量的值，因此，对于一个给定的信号量，我们必须小心保证只调用sem_init一次，对于一个已经初始化过的信号量调用sem_init,结果是未定义的。
5.内存信号量通过sem_destroy删除信号量，有名信号量通过sem_unlink删除

一个进程终止时，内核对其上仍打开的所有有名信号量自动执行关闭操作。不论进程是自愿还是非自愿终止。
关闭一个信号量并没有将他从系统中删除。POSIX 有名信号量是随内核持续的：即使当前没有进程打开着某个信号量，他的值仍保持。
sem_unlink(const char *name)从系统中删除有名信号量
每个信号量有一个引用计数器记录打开的次数，当引用计数大于0时，name 就能从文件系统中删除，然而其信号量的析构（不同于将他的名字从文件系统中删除）却要等到最后一个sem_close发生时为止。

网络进程间通信。

套接字描述符

正如使用文件描述符访问文件，应用程序用套接字描述符访问套接字。

许多处理文件描述符函数（如read和write）可以用于处理套接字描述符。调用socket函数创建一个套接字

#include <sys/socket.h>
int socket(int domain,int type,int protocol);
参数domain（域）确定通信的特性，包括地址格式。
AF_INET		IPv4
AF_INET6	IPv6
AF_UNIX	UNIX domain
参数type确定套接字的类型。
SOCK_DGRAM
SOCK_RAW
SOCK_SEQPACKET
SOCK_STREAM
参数protocol通常是0，表示为给定的域和套接字类型选择默认协议。
IPPROTO_IP
IPPROTO_IPV6
IPPROTO_ICMP
IPPROTO_RAW
IPPROTO_TCP
IPPROTO_UDP
调用socket与调用open相类似。可以调用close来关闭对文件或套接字的访问，并且释放该描述符以便重新使用。
dup和dup2 和一般文件描述符一样复制

套接字通信是双向的。可以采用shutdown函数来禁止一个套接字的I/O

#include <sys/socket.h>
int shutdown(int sockfd,int how);
如果how是SHUT_RD（关闭读端），那么无法从套接字读取数据。

如果how是SHUT_WR（关闭写端），那么无法使用套接字发送数据。

如果how是SHUT_RDWR，则既无法读取数据，又无法发送数据。

使用close函数直到关闭了最后一个引用它的文件描述符才会释放这个套接字，而shutdown允许使用一个套接字处于不活动状态，和引用它的文件描述符数目无关。

字节序

有4个用来处理处理器字节序和网络字节序之间实施转换的函数

#include <arpa/inet.h>
uint32_t htonl(unit32_t hostint32);  //返回值：以网络字节序表示的32位整数
uint16_t htons(unit16_t hostint16); //返回值：以网络字节序表示的16位整数
uint32_t ntohl(unit32_t netint32);  //返回值：以主机字节序表示的32位整数
uint16_t ntohs(unit16_t netint16);  //返回值：以主机字节序表示的16位整数

地址格式

一个地址标识一个特定通信域的套接字端点，地址格式与这个特定的通信域相关。

为使不同的格式地址能够传入到套接字函数，地址会被强制转换成一个通用的地址结构sockaddr(Linux中的定义)：

struct sockaddr{
       sa_family_t sa_family;
       char sa_data[14];
};
因特网地址定义在<netinet/in.h>头文件中。在IPv4因特网域中，套接字地址用结构sockaddr_in表示：

struct in_addr{
       in_addr_t s_addr;
};

struct sockaddr_in{
       sa_family_t sin_family;
       in_port_t sin_port;
       struct in_addr sin_addr;
};
IPv6因特网域套接字地址用结构sockaddr_in6表示：

struct in6_addr{
       uint8_t s6_addr[16];
};

struct sockaddr_in6{
       sa_family_t sin6_family;
       in_port_t sin6_port;
       uint32_t sin6_flowinfo;
       struct in6_addr sin6_addr;
       uint32_t sin6_scope_id;
};
下面两个函数用于二进制地址格式与十进制字符表示（a.b.c.d）之间的相互转换：

#include <arpa/inet.h>
const char * inet_ntop (int domain, const void * restrict addr, char * restrict str, socklen_t size);
int inet_pton ( int domain, const char * restrict str, void * restrict addr);

地址查询

通过调用gethostend，可以找到给定计算机系统的主机信息
#include <netdb.h>

struct hostent *gethostbyname(const char *name);
struct hostent *gethostbyaddr(const void *addr, socklen_t len, int type);
struct hostent *gethostent(void);
void sethostent(int stayopen);
void endhostent(void);

struct netent *getnetbyname(const char *name);
struct netent *getnetbyaddr(uint32_t net, int type);
struct netent *getnetent(void);
void setnetent(int stayopen);
void endnetent(void);

如果主机数据库文件没有打开，gethostent会打开它。函数gethostent返回文件中的下一个条目。

函数sethostent会打开文件，如果文件已经被打开，那么将其回绕。

hostent结构如下至少包含以下成员：

 struct hostent {
        char  *h_name;            /* official name of host */
        char **h_aliases;         /* alias list */
        int    h_addrtype;        /* host address type */
        int    h_length;          /* length of address */
        char **h_addr_list;       /* list of addresses */
};
我们可以用以下函数在协议名字和协议编号之间进行映射：

#include <netdb.h>
struct protoent *getprotobyname(const char *name);
struct protoent *getprotobynumber(int proto);
struct protoent *getprotoent(void);
void setprotoent(int stayopen);
void endprotoent(void);
POSIX.1定义的protoent结构至少包含以下成员：

struct protoent {
        char  *p_name;       /* official protocol name */
        char **p_aliases;    /* alias list */
        int    p_proto;      /* protocol number */
};
可以使用函数getservbyname将一个服务名映射到一个端口号，使用函数getservbyport将一个端口号映射到一个服务名，使用函数getservent顺序扫描服务数据库

#include <netdb.h>
struct servent *getservbyname(const char *name,const char *proto);
struct servent *getservbyport(int port,const char *proto);

struct servent *getservent(void);
void setservent(int stayopen);
void endservent(void);

servent结构至少包含以下成员：

struct servent {
        char  *s_name;       /* official service name */
        char **s_aliases;    /* alias list */
        int    s_port;       /* port number */
        char  *s_proto;      /* protocol to use */
};
POSIX.1定义了若干新的函数，允许一个应用程序将一个主机名和一个服务器名映射到一个地址

#include <sys/socket.h>
#include <netdb.h>
int getaddrinfo(const char *restrict host,
                const char *restrict service,
                const struct addrinfo *restrict hint,
                struct addrinfo **restrict res);
void freeaddrinfo(struct addrinfo *ai);                
需要提供主机名、服务名，或者两者都提供。函数返回一个链表结构addrinfo，可以用freeaddrinfo来释放一个或多个这种结构。

addrinfo结构的定义至少包含以下成员：

 struct addrinfo {
        int              ai_flags;
        int              ai_family;
        int              ai_socktype;
        int              ai_protocol;
        socklen_t        ai_addrlen;
        struct sockaddr *ai_addr;
        char            *ai_canonname;
        struct addrinfo *ai_next;
};
可以提供一个可选的hint来选择符合特定条件的地址。

如果getaddrinfo失败，需要调用gai_strerror将返回的错误码转换成错误消息

#include <netdb.h>
const char *gai_strerror(int error);
getnameinfo函数将一个地址转换成一个主机名和一个服务名

#include <sys/socket.h>
#include <netdb.h>
int getnameinfo(const struct sockaddr *restrict addr,socklen_t alen,
                char *restrict host,socklen_t hostlen,
                char *restrict service,socklen_t servlen,int flags);
套接字地址被翻译为一个主机名和一个服务名。flags参数提供了一些控制翻译的方式。

将套接字与地址关联

使用bind函数来关联地址和套接字

#include <sys/socket.h>
int bind(int sockfd,const struct sockaddr *addr,socklen_t len);
可以调用getsockname函数来发现绑定到套接字上的地址

#include <sys/socket.h>
int getsockname(int sockfd,struct sockaddr *restrict addr,socklen_t *restrict alenp);
如果套接字已经和对等方连接，可以调用getpeername函数找到对方的地址

#include <sys/socket.h>
int getpeername(int sockfd,struct sockaddr *restrict addr,socklen_t *restrict alenp);

建立连接

如果处理一个面向连接的网络服务，那么开始交换数据之前，需要使用connect函数来建立连接

#include <sys/socket.h>
int connect(int sockfd,const struct sockaddr *addr,socklen_t len);
connect中指定的地址是我们想与之通信的服务器地址。

服务器调用listen函数来宣告它愿意接受连接请求

#include <sys/socket.h>
int listen(int sockfd,int backlog);
参数backlog提供了一个提示，提示系统该进程所要入队的未完成连接请求数量。一旦队列满了，系统就会拒绝多余的连接请求。

一旦服务器调用了listen，所用的套接字就能够接受连接请求。使用accept函数获得连接请求并建立连接。

#include <sys/socket.h>
int accept(int fd,struct sockaddr *restrict addr,socklen_t *restrict len); 
函数返回的是一个连接到调用connect的客户端的套接字描述符

数据传输

在建立了连接之后，就可以使用read和write来通过套接字通信。

除此之外，有6个为数据传递而设计的套接字函数（3个用于发送数据，3个用于接收数据）。

最简单的是send，它和write很像，但是可以指定标志来改变处理传输数据的方式

#include <sys/socket.h>
ssize_t send(int sockfd,const void *buf,size_t nbytes,int flags);

函数sendto和send很类似，区别在于sendto可以在无连接的套接字上指定一个目标地址

#include <sys/socket.h>
ssize_t sendto(int sockfd,const void *buf,size_t nbytes,int flags,
               const struct sockaddr *destaddr,socklen_t destlen);
对于面向连接的套接字，目标地址是被忽略的。

通过套接字发送数据时，还有一个选择。可以调用带有msghdr结构的sendmsg来指定多重缓冲区传输数据。

#include <sys/socket.h>
ssize_t sendmsg(int sockfd,const struct msghdr *msg,int flags);
POSIX.1定义了msghdr结构，它至少有以下成员：

struct msghdr {
        void         *msg_name;       /* optional address */
        socklen_t     msg_namelen;    /* size of address */
        struct iovec *msg_iov;        /* scatter/gather array */
        size_t        msg_iovlen;     /* # elements in msg_iov */
        void         *msg_control;    /* ancillary data, see below */
        size_t        msg_controllen; /* ancillary data buffer len */
        int           msg_flags;      /* flags on received message */
};
函数recv和read相似，但是recv可以指定标志来控制如何接收数据

#include <sys/socket.h>
ssize_t recv(int sockfd,void *buf,size_t nbytes,int flags);

如果有兴趣定位发送者，可以使用recvfrom来得到数据发送者的源地址

#include <sys/socket.h>
ssize_t recvfrom(int sockfd,void *restrict buf,size_t len,int flags
                 struct sockaddr *restrict addr,
                 socklen_t *restrict addrlen);
如果addr非空，它将包含数据发送者的套接字端点地址。通常用于无连接的套接字。

为了将接收到的数据送入多个缓冲区，或者想接收辅助数据，可以使用recvmsg

#include <sys/socket.h>
ssize_t recvmsg(int sockfd,struct msghdr *msg,int flags);
返回时，msghdr结构中的msg_flags字段被设为所接收数据的各种特征。

套接字选项

套接字机制提供了设置跟查询套接字选项的接口。可以获取或设置以下3种选项

1.通用选项，工作在所有套接字类型上

2.在套接字层次管理的选项，但是依赖于下层协议的支持

3.特定于某协议的选项，每个协议独有的

可以使用setsockopt函数来设置套接字选项

#include <sys/socket.h>
int setsockopt(int sockfd,int level,int option,const void *val,socklen_t len);
level标识了选项应用的协议：

如果选项是通用的套接字层次选项，则level设置为SOL_SOCKET，否则，level设置成控制这个选项的协议编号。
对于TCP选项，level是IPPROTO_TCP，对于IP，level是IPPROTO_IP。

可以使用getsockopt函数来查看选项的当前值

#include <sys/socket.h>
int getsockopt(int sockfd,int level,int option,void *restrict val,socklen_t restrict lenp);

带外数据

带外数据是一些通信协议所支持的可选特征，允许更加高级的数据比普通数据优先传输。

TCP将带外数据称为紧急数据。TCP仅支持一个字节的紧急数据，但是允许紧急数据在普通数据传递机制数据流之外传输。

为了产生紧急数据，在三个send函数中任何一个指定标志MSG_OOB。如果带MSG_OOB标志传输超过一个字节时，最后一个字节被作为紧急数据字节。

当接收到紧急数据时，那么发送信号SIGURG信号。可以通过调用以下函数安排进程接收套接字的信号：

fcntl(sockfd,F_SETOWN,pid);
F_GETOWN命令可以用来获取当前套接字所有权

owner=fcntl(sockfd,F_GETOWN,0);
为帮助判断是否已经达到紧急标记，可以使用函数sockatmark

#include <sys/socket.h>
int sockatmark(int sockfd);
当下一个要读取的字节在紧急标志处时，sockatmark返回1。

非阻塞和异步I/O

在基于套接字异步I/O中，当能够从套接字中读取数据，或者套接字写队列中的空间变得可用时，可以安排发送信号SIGIO。通过两个步骤来使用异步I/O：

1） 建立套接字拥有者关系，信号可以被传送到合适的进程。

2） 通知套接字当I/O操作不会阻塞时发信号告知。

可以使用三种方式来完成第一个步骤：

A、 在fcntl使用F_SETOWN命令

B、 在ioctl中作用FIOSETOWN命令

C、 在ioctl中使用SIOCSPGRP命令。

     要完成第二个步骤，有两个选择：

A、 在fcntl中使用F_SETFL命令并且启用文件标志O_ASYNC。

B、 在ioctl中使用FIOASYNC

mybytetype.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <semaphore.h>
#include <syslog.h>
#include <aio.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int lock_reg(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        return fcntl(fd, cmd, &flockbuf);
}

int lock_test(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        if (fcntl(fd, F_GETLK, &flockbuf) < 0)
                err_sys("fcntl error");
        if (flockbuf.l_type == F_UNLCK)
                return 0;
        return flockbuf.l_pid;
}

#define read_lock(fd, offset, whence, len) \
              lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
#define readw_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
#define write_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define writew_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
#define un_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))

#define lockfile(fd) write_lock((fd), 0, SEEK_SET, 0)

//是否可设置读锁
#define is_read_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_RDLCK, (offset), (whence), (len)) == 0)
//是否可设置写锁
#define is_write_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_WRLCK, (offset), (whence), (len)) == 0)

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}


const char* transformTime(time_t t, const char* format)
{
	static char buf[128];
	struct tm* ptm;

	if ((ptm = localtime(&t)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

inline static int endian_type(const int* value) {
	//1：小端字节序；0：大端字节序
	return ((*(char*)value) == 0x78) ? 1 : 0;
}

int main(void)
{
	int value = 0x12345678;
	int flag = endian_type(&value);

	printf("  #     MSB     LSB\n");
	printf("Value:   %x\n", value);
	printf("        %s\n", flag ?
		          "HADR   LADR" : "LADR   HADR");
	printf("Type : %s\n", flag ?
		          "little-endian" : "big-endian");

	return 0;
}

myls.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <semaphore.h>
#include <syslog.h>
#include <aio.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int lock_reg(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        return fcntl(fd, cmd, &flockbuf);
}

int lock_test(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        if (fcntl(fd, F_GETLK, &flockbuf) < 0)
                err_sys("fcntl error");
        if (flockbuf.l_type == F_UNLCK)
                return 0;
        return flockbuf.l_pid;
}

#define read_lock(fd, offset, whence, len) \
              lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
#define readw_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
#define write_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define writew_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
#define un_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))

#define lockfile(fd) write_lock((fd), 0, SEEK_SET, 0)

//是否可设置读锁
#define is_read_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_RDLCK, (offset), (whence), (len)) == 0)
//是否可设置写锁
#define is_write_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_WRLCK, (offset), (whence), (len)) == 0)

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}


const char* transformTime(time_t t, const char* format)
{
	static char buf[128];
	struct tm* ptm;

	if ((ptm = localtime(&t)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

const char *getfiletype(const mode_t *mode)
{
	if(NULL == mode)
		return "mode_t has error";
	if(S_ISREG(*mode))
		return "-";
	else if(S_ISDIR(*mode))
		return "d";
	else if(S_ISCHR(*mode))
		return "c";
	else if(S_ISBLK(*mode))
		return "b";
	else if(S_ISFIFO(*mode))
		return "p";
	else if(S_ISLNK(*mode))
		return "l";
	else if(S_ISSOCK(*mode))
		return "s";
	else
		return "-";
}

const char *getfilemode(const mode_t *mode)
{
	static char buf[16];
	memset(buf, 0, sizeof(buf));
	memset(buf, '-', 9);
	if(NULL == mode)
		return "mode_t has error";
	if((*mode) & S_IRUSR)
		buf[0]='r';
	if((*mode) & S_IWUSR)
		buf[1]='w';
	if((*mode) & S_IXUSR)
		buf[2]='x';
	if((*mode) & S_IRGRP)
		buf[3]='r';
	if((*mode) & S_IWGRP)
		buf[4]='w';
	if((*mode) & S_IXGRP)
		buf[5]='x';
	if((*mode) & S_IROTH)
		buf[6]='r';
	if((*mode) & S_IWOTH)
		buf[7]='w';
	if((*mode) & S_IXOTH)
		buf[8]='x';

	return buf;
}

const char* getusername(uid_t uid)
{
	static char buf[64];
	struct passwd* pwd;
	if((pwd=getpwuid(uid))==NULL)
		err_sys("getpwuid error\n");
	memset(buf, 0, sizeof(buf));
	strcpy(buf, pwd->pw_name);
	return buf;
}
const char* getgrpname(gid_t gid)
{
	static char buf[64];
	struct group* pgrp;
	if((pgrp=getgrgid(gid))==NULL)
		err_sys("getgrgid error\n");
	memset(buf, 0, sizeof(buf));
	strcpy(buf, pgrp->gr_name);
	return buf;
}

#define SIZESTEP 1024

/**
 * 将文件字节大小转换为人类易读的表示形式
 */
const char* human_readable(double size, int rflag) {
	static char buf[64];

	if (rflag == 0 || size < SIZESTEP)
		sprintf(buf, "%.f", size);
	else if ((size /= SIZESTEP) < SIZESTEP)
		sprintf(buf, "%.1fK", size);
	else if ((size /= SIZESTEP) < SIZESTEP)
		sprintf(buf, "%.1fM", size);
	else if ((size /= SIZESTEP) < SIZESTEP)
		sprintf(buf, "%.1fG", size);
	else if ((size /= SIZESTEP) < SIZESTEP)
		sprintf(buf, "%.1fT", size);
	return buf;
}


int main(int argc, char* argv[])
{
	const char* dirname = ".";
	int ch, l, i, r, a;
	struct stat statbuf;
	struct dirent* pent;
	DIR* pdir;

	opterr = 0;
	l = i = r = a = 0;
	while ((ch = getopt(argc, argv, "hairl")) != -1) {
		switch (ch) {
		case 'h':
			fprintf(stdout, "usage: myls [-a] [-i] [-l] [-r] [dirname]\n"
					"       myls [-h]\n"
					"i: inode\n"
				    "a: list all\n"
					"h: for help\n"
					"l: for detail information\n"
					"r: make size human readable"); exit(EXIT_SUCCESS); break;
		case 'a':
			a = 1; break;
		case 'i':
			i = 1; break;
		case 'r':
			r = 1; break;
		case 'l':
			l = 1; break;
		case '?':
			printf("unrecognized option: -%c", optopt); exit(1); break;
		}
	}
	/* 若提供了目录名，则将欲遍历目录进行修改 */
	if (optind <= argc - 1)
		dirname = argv[optind];

	if ((pdir = opendir(dirname)) == NULL)
		err_sys("opendir error");
	if (chdir(dirname) == -1)
		err_sys("chdir error");
	while ((pent = readdir(pdir)) != NULL) {
		if (!a && (strcmp(pent->d_name, ".")==0 || strcmp(pent->d_name, "..")==0))
			continue;

		if (lstat(pent->d_name, &statbuf) == -1)
			err_sys("stat error");
		//inode
		i ? printf("%-8lu ", statbuf.st_ino) : 0;
		//detail
		l ? printf("%s%s %3lu %s %s %6s %s ", getfiletype(&(statbuf.st_mode)),
			getfilemode(&(statbuf.st_mode)), statbuf.st_nlink, getusername(statbuf.st_uid),
			getgrpname(statbuf.st_gid), human_readable((double)statbuf.st_size, r),
			transformTime(statbuf.st_atim.tv_sec, "%m-%d %T")) : 0;
		printf("%s\n", pent->d_name);
	}
	if (closedir(pdir) == -1)
		err_sys("closedir error");

	exit(EXIT_SUCCESS);
}

myhtonl.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <semaphore.h>
#include <syslog.h>
#include <aio.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int lock_reg(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        return fcntl(fd, cmd, &flockbuf);
}

int lock_test(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        if (fcntl(fd, F_GETLK, &flockbuf) < 0)
                err_sys("fcntl error");
        if (flockbuf.l_type == F_UNLCK)
                return 0;
        return flockbuf.l_pid;
}

#define read_lock(fd, offset, whence, len) \
              lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
#define readw_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
#define write_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define writew_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
#define un_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))

#define lockfile(fd) write_lock((fd), 0, SEEK_SET, 0)

//是否可设置读锁
#define is_read_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_RDLCK, (offset), (whence), (len)) == 0)
//是否可设置写锁
#define is_write_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_WRLCK, (offset), (whence), (len)) == 0)

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}


const char* transformTime(time_t t, const char* format)
{
	static char buf[128];
	struct tm* ptm;

	if ((ptm = localtime(&t)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

void swap(char* lhs, char* rhs) {
	char tmp = *rhs;
	*rhs = *lhs;
	*lhs = tmp;
}

uint32_t myhtonl(uint32_t hostint32) {
	char* cptr = (char*)&hostint32;
	int low = 0, high = sizeof(uint32_t) - 1;

	while (low < high)
		swap(cptr + low++, cptr + high--);
	return hostint32;
}

int main(void)
{
	uint32_t value = 0x12345678;

	printf("normal order: 0x%x\n", value);
	printf("inet order  : 0x%x\n", htonl(value));
	printf("inet order2 : 0x%x\n", myhtonl(value));
	exit(EXIT_SUCCESS);
}

myprintproto.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <semaphore.h>
#include <syslog.h>
#include <aio.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int lock_reg(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        return fcntl(fd, cmd, &flockbuf);
}

int lock_test(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        if (fcntl(fd, F_GETLK, &flockbuf) < 0)
                err_sys("fcntl error");
        if (flockbuf.l_type == F_UNLCK)
                return 0;
        return flockbuf.l_pid;
}

#define read_lock(fd, offset, whence, len) \
              lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
#define readw_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
#define write_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define writew_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
#define un_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))

#define lockfile(fd) write_lock((fd), 0, SEEK_SET, 0)

//是否可设置读锁
#define is_read_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_RDLCK, (offset), (whence), (len)) == 0)
//是否可设置写锁
#define is_write_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_WRLCK, (offset), (whence), (len)) == 0)

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}


const char* transformTime(time_t t, const char* format)
{
	static char buf[128];
	struct tm* ptm;

	if ((ptm = localtime(&t)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

int main(void)
{
	struct protoent* pent;

	setprotoent(1);
	printf("        procotol           number            altername\n");
	while ((pent = getprotoent()) != NULL) {
		printf("%15s            %3d        %16s\n",
			pent->p_name, pent->p_proto,*pent->p_aliases);
	}
	endprotoent();

	exit(EXIT_SUCCESS);
}

mygethost.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <semaphore.h>
#include <syslog.h>
#include <aio.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int lock_reg(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        return fcntl(fd, cmd, &flockbuf);
}

int lock_test(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        if (fcntl(fd, F_GETLK, &flockbuf) < 0)
                err_sys("fcntl error");
        if (flockbuf.l_type == F_UNLCK)
                return 0;
        return flockbuf.l_pid;
}

#define read_lock(fd, offset, whence, len) \
              lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
#define readw_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
#define write_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define writew_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
#define un_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))

#define lockfile(fd) write_lock((fd), 0, SEEK_SET, 0)

//是否可设置读锁
#define is_read_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_RDLCK, (offset), (whence), (len)) == 0)
//是否可设置写锁
#define is_write_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_WRLCK, (offset), (whence), (len)) == 0)

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}


const char* transformTime(time_t t, const char* format)
{
	static char buf[128];
	struct tm* ptm;

	if ((ptm = localtime(&t)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

int main(int argc, char* argv[])
{
	struct hostent* pent;
	char buf[INET_ADDRSTRLEN];

	if (argc != 2) {
		printf("usage: %s <hostname>", argv[0]); exit(1);
	}

	if ((pent = gethostbyname(argv[1])) == NULL)
		err_sys("gethostbyname error");
	printf("hostname: %s\n", pent->h_name);
	if (pent->h_addrtype == AF_INET && pent->h_addr_list != NULL) {
		for (int i = 0; pent->h_addr_list[i] != NULL; ++i) {
			if (inet_ntop(AF_INET, (struct in_addr*)pent->h_addr_list[i],
					buf, INET_ADDRSTRLEN) == NULL)
				err_sys("inet_ntop error");
			printf("address : %s\n", buf);
		}
	}
	exit(EXIT_SUCCESS);
}

mygetserv.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <semaphore.h>
#include <syslog.h>
#include <aio.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int lock_reg(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        return fcntl(fd, cmd, &flockbuf);
}

int lock_test(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        if (fcntl(fd, F_GETLK, &flockbuf) < 0)
                err_sys("fcntl error");
        if (flockbuf.l_type == F_UNLCK)
                return 0;
        return flockbuf.l_pid;
}

#define read_lock(fd, offset, whence, len) \
              lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
#define readw_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
#define write_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define writew_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
#define un_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))

#define lockfile(fd) write_lock((fd), 0, SEEK_SET, 0)

//是否可设置读锁
#define is_read_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_RDLCK, (offset), (whence), (len)) == 0)
//是否可设置写锁
#define is_write_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_WRLCK, (offset), (whence), (len)) == 0)

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}


const char* transformTime(time_t t, const char* format)
{
	static char buf[128];
	struct tm* ptm;

	if ((ptm = localtime(&t)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

int main(int argc, char* argv[])
{
	struct servent* psvent;
	
	if (argc != 3) {
		printf("usage: %s <server> <protocol>", argv[0]); exit(1);
	}

	if ((psvent = getservbyname(argv[1], argv[2])) == NULL)
		err_sys("getservbyname error");
	printf("server name    : %s\n", psvent->s_name);
	printf("server port    : %d\n", ntohs(psvent->s_port));
	printf("server protocol: %s\n", psvent->s_proto);

	exit(EXIT_SUCCESS);
}

mygetaddr.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <semaphore.h>
#include <syslog.h>
#include <aio.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int lock_reg(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        return fcntl(fd, cmd, &flockbuf);
}

int lock_test(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        if (fcntl(fd, F_GETLK, &flockbuf) < 0)
                err_sys("fcntl error");
        if (flockbuf.l_type == F_UNLCK)
                return 0;
        return flockbuf.l_pid;
}

#define read_lock(fd, offset, whence, len) \
              lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
#define readw_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
#define write_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define writew_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
#define un_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))

#define lockfile(fd) write_lock((fd), 0, SEEK_SET, 0)

//是否可设置读锁
#define is_read_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_RDLCK, (offset), (whence), (len)) == 0)
//是否可设置写锁
#define is_write_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_WRLCK, (offset), (whence), (len)) == 0)

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}


const char* transformTime(time_t t, const char* format)
{
	static char buf[128];
	struct tm* ptm;

	if ((ptm = localtime(&t)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

/**
 * 地址族信息
 */
void print_family(const struct  addrinfo* aip) {
	printf(" family: ");
	switch (aip->ai_family) {
	case AF_INET:
		printf("INET");
		break;
	case AF_INET6:
		printf("INET6");
		break;
	case AF_UNIX:
		printf("UNIX");
		break;
	case AF_UNSPEC:
		printf("UNSPEC");
		break;
	default:
		printf("UNKNOWN");
	}
}


/**
 * 套接字类型
 */
void print_type(const struct addrinfo* aip) {
	printf(" type: ");
	switch (aip->ai_socktype) {
	case SOCK_STREAM:
		printf("STREAM");
		break;
	case SOCK_DGRAM:
		printf("DATAGRAM");
		break;
	case SOCK_SEQPACKET:
		printf("SEQPACKET");
		break;
	case SOCK_RAW:
		printf("RAW");
		break;
	default:
		printf("UNKNOWN (%d)", aip->ai_socktype);
	}
}


/**
 * 协议类型
 */
void print_protocol(const struct addrinfo* aip) {
	printf(" protocol: ");
	switch (aip->ai_protocol) {
	case 0:
		printf("default"); break;
	case IPPROTO_TCP:
		printf("TCP"); break;
	case IPPROTO_UDP:
		printf("UDP"); break;
	case IPPROTO_RAW:
		printf("RAW"); break;
	default:
		printf("UNKNOWN (%d)", aip->ai_protocol);
	}
}

/**
 * 返回的addrinfo中携带了何种信息（标志类型）
 */
void print_flags(const struct addrinfo* aip) {
	printf("flags:");
	if (aip->ai_flags == 0) {
		printf(" 0");
	}
	else {
		//套接字地址用于被动监听
		if (aip->ai_flags & AI_PASSIVE)
			printf(" PASSIVE");
		//规范名
		if (aip->ai_flags & AI_CANONNAME)
			printf(" CANON");
		//数字格式主机地址
		if (aip->ai_flags & AI_NUMERICHOST)
			printf(" NUMHOST");
		//服务以端口号表示
		if (aip->ai_flags & AI_NUMERICSERV)
			printf(" NUMSERV");
		//若没有IPv6地址则返回IPv4地址
		if (aip->ai_flags & AI_V4MAPPED)
			printf(" V4MAPPED");
		//查找所有的IP地址
		if (aip->ai_flags & AI_ALL)
			printf(" ALL");
	}
}


int main(int argc, char* argv[])
{
	char abuf[INET_ADDRSTRLEN];
	struct sockaddr_in* sinp;
	struct addrinfo* ailist;
	struct addrinfo hint;
	const char* addr;
	int err;
	
	if (argc != 3) {
		printf("usage: %s nodename service", argv[0]); exit(1);
	}

	hint.ai_flags = AI_CANONNAME;
	hint.ai_family = AF_INET;
	hint.ai_socktype = 0;
	hint.ai_protocol = 0;
	hint.ai_addrlen = 0;
	hint.ai_canonname = NULL;
	hint.ai_next = NULL;
	hint.ai_addr = NULL;
	if ((err = getaddrinfo(argv[1], argv[2], &hint, &ailist)) != 0) {
		printf("getaddrinfo error: %s", gai_strerror(err)); exit(1);
	}
	for (struct addrinfo* aip = ailist; aip != NULL; aip = aip->ai_next) {
		print_flags(aip);
		print_family(aip);
		print_type(aip);
		print_protocol(aip);
		printf("\n\thost: %s", aip->ai_canonname ? aip->ai_canonname : "-");
		if (aip->ai_family == AF_INET) {
			sinp = (struct sockaddr_in*)aip->ai_addr;
			addr = inet_ntop(AF_INET, &sinp->sin_addr, abuf, INET_ADDRSTRLEN);
			printf(" address: %s", addr ? addr : "unknown");
			printf(" port: %d", ntohs(sinp->sin_port));
		}
		printf("\n");
	}

	exit(EXIT_SUCCESS);
}

ruptimed.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <semaphore.h>
#include <syslog.h>
#include <aio.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int lock_reg(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        return fcntl(fd, cmd, &flockbuf);
}

int lock_test(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        if (fcntl(fd, F_GETLK, &flockbuf) < 0)
                err_sys("fcntl error");
        if (flockbuf.l_type == F_UNLCK)
                return 0;
        return flockbuf.l_pid;
}

#define read_lock(fd, offset, whence, len) \
              lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
#define readw_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
#define write_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define writew_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
#define un_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))

#define lockfile(fd) write_lock((fd), 0, SEEK_SET, 0)

//是否可设置读锁
#define is_read_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_RDLCK, (offset), (whence), (len)) == 0)
//是否可设置写锁
#define is_write_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_WRLCK, (offset), (whence), (len)) == 0)

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}


const char* transformTime(time_t t, const char* format)
{
	static char buf[128];
	struct tm* ptm;

	if ((ptm = localtime(&t)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define ERROR_EXIT(m)\
do\
{\
    perror(m);\
    exit(EXIT_FAILURE);\
}\
while(0)

static void daemonize(const char *cmd)
{
	int i, fd0, fd1, fd2;
	pid_t pid;
	struct rlimit rl;
	struct sigaction sa;
	/* 清除文件掩模和改变工作目录 */
	umask(0);
	if(chdir("/") < 0)
		ERROR_EXIT("chdir error");

	/* 获取文件描述符上限并关闭所有文件描述符 */
	if(getrlimit(RLIMIT_NOFILE, &rl) < 0)
		ERROR_EXIT("getrlimit error");
	if(rl.rlim_max == RLIM_INFINITY)
		rl.rlim_max = 1024;
	for(i=0; i<rl.rlim_max; i++)
		close(i);

	/* 第一次fork父进程退出,子进程脱离当前控制终端 */
	if((pid = fork()) < 0)
		ERROR_EXIT("first fork error");
	else if(pid > 0)
		exit(0);

	/* 子进程成为会话组长 */
	setsid();

	/* 处理SIGHUP信号 */
	sa.sa_handler = SIG_IGN;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;
	if(sigaction(SIGHUP, &sa, NULL) < 0)
		ERROR_EXIT("sigaction error");

	/* 第二次fork子进程退出,孙进程不再是会话组长,无权开启终端(与终端彻底隔离) */
	if((pid = fork()) < 0)
		ERROR_EXIT("second fork error");
	else if(pid > 0)
		exit(0);

	/* 将 0,1,2重定向到/dev/null */
	fd0 = open("/dev/null", O_RDWR);
	fd1 = dup(0);
	fd2 = dup(0);

	/* 初始化log file */
	openlog(cmd, LOG_CONS, LOG_DAEMON);
	if(fd0 != 0 || fd1 != 1 || fd2 != 2){
		syslog(LOG_ERR, "unexpected file descriptors %d %d %d", fd0, fd1, fd2);
		exit(1);
	}
}

#define MAXSLEEP 128

/**
 * 建立与服务进程的Internet套接字的逻辑连接，并在失败时以指数补
 * 偿算法进行重试
 */
int connect_retry(int domain, int type, int protocol, const struct sockaddr* addr, socklen_t alen) {
        int numsec, fd;

        for (numsec = 1; numsec <= MAXSLEEP; numsec <<= 1) {
                if ((fd = socket(domain, type, protocol)) == -1)
                        return -1;
                if (connect(fd, addr, alen) == 0)
                        return fd;
                close(fd);

                if (numsec <= MAXSLEEP / 2)
                        sleep(numsec);
        }
        return -1;
}


/**
 * 完成Internet流式套接字/数据报套接字服务进程初始化一条龙，并且调用
 * setsockopt()使得进程在主机重启之后仍然能够重新绑定该地址
 */
int init_server(int type, const struct sockaddr* addr, socklen_t alen, int qlen) {
        int fd, err = 0;
        int reuse = 1;

        if ((fd = socket(addr->sa_family, type, 0)) < 0)
                return -1;
        if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(int)) < 0)
                goto errout;
        if (bind(fd, addr, alen) < 0)
                goto errout;
        if (type == SOCK_STREAM || type == SOCK_SEQPACKET) {
                if (listen(fd, qlen) < 0)
                        return -1;
        }
        return fd;

errout:
        err = errno;
        close(fd);
        errno = err;
        return -1;
}

#define BUFLEN 128
#define QLEN 10

#ifndef HOST_NAME_MAX
#define HOST_NAME_MAX 256
#endif


void serve(int sockfd) {
	int clfd;
	FILE* fp;
	char buf[BUFLEN];

	//生成子进程时需要自动关闭那些继承而来的文件描述符
	set_cloexec(sockfd);
	for (;;) {
		/* 接受一个连接请求然后创建一个文件（套接字）描述符与客户进程相连 */
		if ((clfd = accept(sockfd, NULL, NULL)) < 0) {
			syslog(LOG_ERR, "ruptimed: accept error: %s", strerror(errno));
			exit(EXIT_FAILURE);
		}
		set_cloexec(clfd);
		if ((fp = popen("ps -aux|wc -l", "r")) == NULL) {//返回给客户进程当前运行进程数
			sprintf(buf, "error: %s\n", strerror(errno));
			send(clfd, buf, strlen(buf), 0);
		}
		else {
			while (fgets(buf, BUFLEN, fp) != NULL)
				send(clfd, buf, strlen(buf), 0);
			pclose(fp);
		}
		close(clfd);
	}
}

int main(int argc, char* argv[])
{
	struct addrinfo* ailist;
	struct addrinfo hint;
	int sockfd, err, n;
	char* host;

	if (argc != 1) {
		printf("usage: %s", argv[0]); exit(1);
	}

	if ((n = sysconf(_SC_HOST_NAME_MAX)) < 0)
		n = HOST_NAME_MAX;
	if ((host = malloc(n)) == NULL)
		err_sys("malloc error");
	if (gethostname(host, n) < 0)
		err_sys("gethostname error");

	daemonize("ruptimed");
	memset(&hint, 0, sizeof(hint));
	hint.ai_flags = AI_CANONNAME;
	hint.ai_socktype = SOCK_STREAM;
	hint.ai_canonname = NULL;
	hint.ai_addr = NULL;
	hint.ai_next = NULL;
	if ((err = getaddrinfo(host, "ruptime", &hint, &ailist)) != 0) {
		syslog(LOG_ERR, "ruptimed: getaddrinfo error: %s", gai_strerror(err));
		exit(EXIT_FAILURE);
	}
	for (struct addrinfo* aip = ailist; aip != NULL; aip = aip->ai_next) {
		if ((sockfd = init_server(SOCK_STREAM, aip->ai_addr, aip->ai_addrlen, QLEN)) >= 0) {
			serve(sockfd);
			exit(EXIT_SUCCESS);
		}
	}
	
	exit(EXIT_FAILURE);
}

ruptime.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <semaphore.h>
#include <syslog.h>
#include <aio.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int lock_reg(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        return fcntl(fd, cmd, &flockbuf);
}

int lock_test(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        if (fcntl(fd, F_GETLK, &flockbuf) < 0)
                err_sys("fcntl error");
        if (flockbuf.l_type == F_UNLCK)
                return 0;
        return flockbuf.l_pid;
}

#define read_lock(fd, offset, whence, len) \
              lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
#define readw_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
#define write_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define writew_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
#define un_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))

#define lockfile(fd) write_lock((fd), 0, SEEK_SET, 0)

//是否可设置读锁
#define is_read_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_RDLCK, (offset), (whence), (len)) == 0)
//是否可设置写锁
#define is_write_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_WRLCK, (offset), (whence), (len)) == 0)

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}


const char* transformTime(time_t t, const char* format)
{
	static char buf[128];
	struct tm* ptm;

	if ((ptm = localtime(&t)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define MAXSLEEP 128

/**
 * 建立与服务进程的Internet套接字的逻辑连接，并在失败时以指数补
 * 偿算法进行重试
 */
int connect_retry(int domain, int type, int protocol, const struct sockaddr* addr, socklen_t alen) {
        int numsec, fd;

        for (numsec = 1; numsec <= MAXSLEEP; numsec <<= 1) {
                if ((fd = socket(domain, type, protocol)) == -1)
                        return -1;
                if (connect(fd, addr, alen) == 0)
                        return fd;
                close(fd);

                if (numsec <= MAXSLEEP / 2)
                        sleep(numsec);
        }
        return -1;
}

#define BUFLEN 128

void print_uptime(int sockfd) {
	int nrecv;
	char buf[BUFLEN];

	while ((nrecv = recv(sockfd, buf, BUFLEN, 0)) > 0)
		write(STDOUT_FILENO, buf, nrecv);
	if (nrecv < 0)
		err_sys("recv error");
}

int main(int argc, char* argv[])
{
	struct addrinfo* ailist, * aip;
	struct addrinfo hint;
	int sockfd, err;

	if (argc != 2) {
		printf("usage: %s <hostname>", argv[0]); exit(1);
	}

	/* 使用getaddrinfo函数根据给定主机名获取目标服务进程
	 * 的地址信息 */
	memset(&hint, 0, sizeof(hint));
	hint.ai_socktype = SOCK_STREAM;
	hint.ai_canonname = NULL;
	hint.ai_addr = NULL;
	hint.ai_next = NULL;
	if ((err = getaddrinfo(argv[1], "ruptime", &hint, &ailist)) != 0) {
		printf("getaddrinfo error: %s", gai_strerror(err)); exit(1);
	}
	for (aip = ailist; aip != NULL; aip = aip->ai_next) {
		if ((sockfd = connect_retry(aip->ai_family, SOCK_STREAM, 0, aip->ai_addr, aip->ai_addrlen)) == -1)
			err = errno;
		else {
			print_uptime(sockfd);
			exit(EXIT_SUCCESS);
		}
	}
	printf("%d, can't connect to %s\n", err, argv[1]); exit(1);
}

1、首先需要在/etc/services文件中加入如下的一条信息：
ruptime         66666/tcp

该信息使得服务进程能够准确的知道自己应该运行的端口和协议类型
2、然后运行如下命令
ruptimed
启动服务端进程

[weiyayun@weiyayun-PC ~]$ ruptime "weiyayun-PC"
启动客户端进程

ruptimed2.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <semaphore.h>
#include <syslog.h>
#include <aio.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int lock_reg(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        return fcntl(fd, cmd, &flockbuf);
}

int lock_test(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        if (fcntl(fd, F_GETLK, &flockbuf) < 0)
                err_sys("fcntl error");
        if (flockbuf.l_type == F_UNLCK)
                return 0;
        return flockbuf.l_pid;
}

#define read_lock(fd, offset, whence, len) \
              lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
#define readw_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
#define write_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define writew_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
#define un_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))

#define lockfile(fd) write_lock((fd), 0, SEEK_SET, 0)

//是否可设置读锁
#define is_read_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_RDLCK, (offset), (whence), (len)) == 0)
//是否可设置写锁
#define is_write_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_WRLCK, (offset), (whence), (len)) == 0)

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}


const char* transformTime(time_t t, const char* format)
{
	static char buf[128];
	struct tm* ptm;

	if ((ptm = localtime(&t)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define ERROR_EXIT(m)\
do\
{\
    perror(m);\
    exit(EXIT_FAILURE);\
}\
while(0)

static void daemonize(const char *cmd)
{
	int i, fd0, fd1, fd2;
	pid_t pid;
	struct rlimit rl;
	struct sigaction sa;
	/* 清除文件掩模和改变工作目录 */
	umask(0);
	if(chdir("/") < 0)
		ERROR_EXIT("chdir error");

	/* 获取文件描述符上限并关闭所有文件描述符 */
	if(getrlimit(RLIMIT_NOFILE, &rl) < 0)
		ERROR_EXIT("getrlimit error");
	if(rl.rlim_max == RLIM_INFINITY)
		rl.rlim_max = 1024;
	for(i=0; i<rl.rlim_max; i++)
		close(i);

	/* 第一次fork父进程退出,子进程脱离当前控制终端 */
	if((pid = fork()) < 0)
		ERROR_EXIT("first fork error");
	else if(pid > 0)
		exit(0);

	/* 子进程成为会话组长 */
	setsid();

	/* 处理SIGHUP信号 */
	sa.sa_handler = SIG_IGN;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;
	if(sigaction(SIGHUP, &sa, NULL) < 0)
		ERROR_EXIT("sigaction error");

	/* 第二次fork子进程退出,孙进程不再是会话组长,无权开启终端(与终端彻底隔离) */
	if((pid = fork()) < 0)
		ERROR_EXIT("second fork error");
	else if(pid > 0)
		exit(0);

	/* 将 0,1,2重定向到/dev/null */
	fd0 = open("/dev/null", O_RDWR);
	fd1 = dup(0);
	fd2 = dup(0);

	/* 初始化log file */
	openlog(cmd, LOG_CONS, LOG_DAEMON);
	if(fd0 != 0 || fd1 != 1 || fd2 != 2){
		syslog(LOG_ERR, "unexpected file descriptors %d %d %d", fd0, fd1, fd2);
		exit(1);
	}
}

#define MAXSLEEP 128

/**
 * 建立与服务进程的Internet套接字的逻辑连接，并在失败时以指数补
 * 偿算法进行重试
 */
int connect_retry(int domain, int type, int protocol, const struct sockaddr* addr, socklen_t alen) {
        int numsec, fd;

        for (numsec = 1; numsec <= MAXSLEEP; numsec <<= 1) {
                if ((fd = socket(domain, type, protocol)) == -1)
                        return -1;
                if (connect(fd, addr, alen) == 0)
                        return fd;
                close(fd);

                if (numsec <= MAXSLEEP / 2)
                        sleep(numsec);
        }
        return -1;
}


/**
 * 完成Internet流式套接字/数据报套接字服务进程初始化一条龙，并且调用
 * setsockopt()使得进程在主机重启之后仍然能够重新绑定该地址
 */
int init_server(int type, const struct sockaddr* addr, socklen_t alen, int qlen) {
        int fd, err = 0;
        int reuse = 1;

        if ((fd = socket(addr->sa_family, type, 0)) < 0)
                return -1;
        if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(int)) < 0)
                goto errout;
        if (bind(fd, addr, alen) < 0)
                goto errout;
        if (type == SOCK_STREAM || type == SOCK_SEQPACKET) {
                if (listen(fd, qlen) < 0)
                        return -1;
        }
        return fd;

errout:
        err = errno;
        close(fd);
        errno = err;
        return -1;
}

#define BUFLEN 128
#define QLEN 10

#ifndef HOST_NAME_MAX
#define HOST_NAME_MAX 256
#endif

void server(int sockfd) {
	int clfd;
	pid_t pid;

	set_cloexec(sockfd);
	for (;;) {
		if ((clfd = accept(sockfd, NULL, NULL)) == -1) {
			syslog(LOG_ERR, "ruptimed: accept error: %s", strerror(errno));
			exit(EXIT_FAILURE);
		}
		if ((pid = fork()) < 0) {
			syslog(LOG_ERR, "ruptimed: fork error: %s", strerror(errno));
			exit(EXIT_FAILURE);
		}
		else if (pid == 0) {
			/* 让执行uptime的子进程的stderr和stdout文件描述符指向accept
				创建的套接字，这样就避免了缓冲区和send这些步骤 */
			if (dup2(clfd, STDOUT_FILENO) != STDOUT_FILENO ||
				dup2(clfd, STDERR_FILENO) != STDERR_FILENO) {
				syslog(LOG_ERR, "ruptimed: unexpected error");
				exit(EXIT_FAILURE);
			}
			close(clfd);
			execl("/usr/bin/uptime", "uptime", (char*)NULL);
			syslog(LOG_ERR, "ruptimed: unexpected return from exec: %s",
				strerror(errno));
		}
		/*else {
			close(clfd);
			waitpid(pid, NULL, 0);
		}*/
	}
}


int main(int argc, char* argv[])
{
	struct addrinfo* ailist;
	struct addrinfo hint;
	int sockfd, err, n;
	char* host;

	if (argc != 1) {
		printf("usage: ruptimed"); exit(1);
	}

	if ((n = sysconf(_SC_HOST_NAME_MAX)) == -1)
		n = HOST_NAME_MAX;
	if ((host = malloc(n)) == NULL)
		err_sys("malloc error");
	if (gethostname(host, n) == -1)
		err_sys("gethostname error");

	daemonize("ruptimed");
	memset(&hint, 0, sizeof(hint));
	hint.ai_flags = AI_CANONNAME;
	hint.ai_socktype = SOCK_STREAM;
	hint.ai_canonname = NULL;
	hint.ai_addr = NULL;
	hint.ai_next = NULL;
	if ((err = getaddrinfo(host, "ruptime", &hint, &ailist)) == -1) {
		syslog(LOG_ERR, "ruptimed: getaddrinfo error: %s",
			gai_strerror(err));
		exit(EXIT_FAILURE);
	}
	for (struct addrinfo* aip = ailist; aip != NULL; aip = aip->ai_next) {
		if ((sockfd = init_server(SOCK_STREAM, aip->ai_addr, aip->ai_addrlen,
			QLEN)) >= 0) {
			server(sockfd);
			exit(EXIT_SUCCESS);
		}
	}

	exit(EXIT_FAILURE);
}

ruptimed3.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <semaphore.h>
#include <syslog.h>
#include <aio.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int lock_reg(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        return fcntl(fd, cmd, &flockbuf);
}

int lock_test(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        if (fcntl(fd, F_GETLK, &flockbuf) < 0)
                err_sys("fcntl error");
        if (flockbuf.l_type == F_UNLCK)
                return 0;
        return flockbuf.l_pid;
}

#define read_lock(fd, offset, whence, len) \
              lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
#define readw_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
#define write_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define writew_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
#define un_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))

#define lockfile(fd) write_lock((fd), 0, SEEK_SET, 0)

//是否可设置读锁
#define is_read_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_RDLCK, (offset), (whence), (len)) == 0)
//是否可设置写锁
#define is_write_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_WRLCK, (offset), (whence), (len)) == 0)

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}


const char* transformTime(time_t t, const char* format)
{
	static char buf[128];
	struct tm* ptm;

	if ((ptm = localtime(&t)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define ERROR_EXIT(m)\
do\
{\
    perror(m);\
    exit(EXIT_FAILURE);\
}\
while(0)

static void daemonize(const char *cmd)
{
	int i, fd0, fd1, fd2;
	pid_t pid;
	struct rlimit rl;
	struct sigaction sa;
	/* 清除文件掩模和改变工作目录 */
	umask(0);
	if(chdir("/") < 0)
		ERROR_EXIT("chdir error");

	/* 获取文件描述符上限并关闭所有文件描述符 */
	if(getrlimit(RLIMIT_NOFILE, &rl) < 0)
		ERROR_EXIT("getrlimit error");
	if(rl.rlim_max == RLIM_INFINITY)
		rl.rlim_max = 1024;
	for(i=0; i<rl.rlim_max; i++)
		close(i);

	/* 第一次fork父进程退出,子进程脱离当前控制终端 */
	if((pid = fork()) < 0)
		ERROR_EXIT("first fork error");
	else if(pid > 0)
		exit(0);

	/* 子进程成为会话组长 */
	setsid();

	/* 处理SIGHUP信号 */
	sa.sa_handler = SIG_IGN;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;
	if(sigaction(SIGHUP, &sa, NULL) < 0)
		ERROR_EXIT("sigaction error");

	/* 第二次fork子进程退出,孙进程不再是会话组长,无权开启终端(与终端彻底隔离) */
	if((pid = fork()) < 0)
		ERROR_EXIT("second fork error");
	else if(pid > 0)
		exit(0);

	/* 将 0,1,2重定向到/dev/null */
	fd0 = open("/dev/null", O_RDWR);
	fd1 = dup(0);
	fd2 = dup(0);

	/* 初始化log file */
	openlog(cmd, LOG_CONS, LOG_DAEMON);
	if(fd0 != 0 || fd1 != 1 || fd2 != 2){
		syslog(LOG_ERR, "unexpected file descriptors %d %d %d", fd0, fd1, fd2);
		exit(1);
	}
}

#define MAXSLEEP 128

/**
 * 建立与服务进程的Internet套接字的逻辑连接，并在失败时以指数补
 * 偿算法进行重试
 */
int connect_retry(int domain, int type, int protocol, const struct sockaddr* addr, socklen_t alen) {
        int numsec, fd;

        for (numsec = 1; numsec <= MAXSLEEP; numsec <<= 1) {
                if ((fd = socket(domain, type, protocol)) == -1)
                        return -1;
                if (connect(fd, addr, alen) == 0)
                        return fd;
                close(fd);

                if (numsec <= MAXSLEEP / 2)
                        sleep(numsec);
        }
        return -1;
}


/**
 * 完成Internet流式套接字/数据报套接字服务进程初始化一条龙，并且调用
 * setsockopt()使得进程在主机重启之后仍然能够重新绑定该地址
 */
int init_server(int type, const struct sockaddr* addr, socklen_t alen, int qlen) {
        int fd, err = 0;
        int reuse = 1;

        if ((fd = socket(addr->sa_family, type, 0)) < 0)
                return -1;
        if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(int)) < 0)
                goto errout;
        if (bind(fd, addr, alen) < 0)
                goto errout;
        if (type == SOCK_STREAM || type == SOCK_SEQPACKET) {
                if (listen(fd, qlen) < 0)
                        return -1;
        }
        return fd;

errout:
        err = errno;
        close(fd);
        errno = err;
        return -1;
}

#define BUFLEN 128
#define QLEN 10

#ifndef HOST_NAME_MAX
#define HOST_NAME_MAX 256
#endif

typedef void Sigfunc(int);

static void sig_child(int signo) {
	while (waitpid((pid_t)-1, NULL, WNOHANG) > 0);
}


/**
 * 使用SA_RESTART标志调用sigaction()函数进行信号处理程序注册，
 * 这样因子进程终止而产生的信号SIG_CHLD即使中断服务进程的系统
 * 调用正常执行，仍然能够重新启动
 */
Sigfunc* signal_restart(int signo, Sigfunc* func) {
	struct sigaction act, oact;
	
	act.sa_handler = func;
	sigemptyset(&act.sa_mask);
	act.sa_flags = 0;
	act.sa_flags |= SA_RESTART;
	if (sigaction(signo, &act, &oact) == -1)
		return SIG_ERR;
	return oact.sa_handler;
}


void server(int sockfd) {
	int clfd;
	pid_t pid;

	if (signal_restart(SIGCHLD, sig_child) == SIG_ERR)
		syslog(LOG_ERR, "signal_restart error");

	set_cloexec(sockfd);
	for (;;) {
		if ((clfd = accept(sockfd, NULL, NULL)) == -1) {
			syslog(LOG_ERR, "ruptimed: accept error: %s", strerror(errno));
			exit(EXIT_FAILURE);
		}
		if ((pid = fork()) < 0) {
			syslog(LOG_ERR, "ruptimed: fork error: %s", strerror(errno));
			exit(EXIT_FAILURE);
		}
		else if (pid == 0) {
			/* 让执行uptime的子进程的stderr和stdout文件描述符指向accept
				创建的套接字，这样就避免了缓冲区和send这些步骤 */
			if (dup2(clfd, STDOUT_FILENO) != STDOUT_FILENO ||
				dup2(clfd, STDERR_FILENO) != STDERR_FILENO) {
				syslog(LOG_ERR, "ruptimed: unexpected error");
				exit(EXIT_FAILURE);
			}
			close(clfd);
			execl("/usr/bin/uptime", "uptime", (char*)NULL);
			syslog(LOG_ERR, "ruptimed: unexpected return from exec: %s",
				strerror(errno));
		}
		else
			close(clfd);
	}
}


int main(int argc, char* argv[])
{
	struct addrinfo* ailist;
	struct addrinfo hint;
	int sockfd, err, n;
	char* host;

	if (argc != 1) {
		printf("usage: ruptimed"); exit(1);
	}

	if ((n = sysconf(_SC_HOST_NAME_MAX)) == -1)
		n = HOST_NAME_MAX;
	if ((host = malloc(n)) == NULL)
		err_sys("malloc error");
	if (gethostname(host, n) == -1)
		err_sys("gethostname error");

	daemonize("ruptimed");
	memset(&hint, 0, sizeof(hint));
	hint.ai_flags = AI_CANONNAME;
	hint.ai_socktype = SOCK_STREAM;
	hint.ai_canonname = NULL;
	hint.ai_addr = NULL;
	hint.ai_next = NULL;
	if ((err = getaddrinfo(host, "ruptime", &hint, &ailist)) == -1) {
		syslog(LOG_ERR, "ruptimed: getaddrinfo error: %s",
			gai_strerror(err));
		exit(EXIT_FAILURE);
	}
	for (struct addrinfo* aip = ailist; aip != NULL; aip = aip->ai_next) {
		if ((sockfd = init_server(SOCK_STREAM, aip->ai_addr, aip->ai_addrlen,
			QLEN)) >= 0) {
			server(sockfd);
			exit(EXIT_SUCCESS);
		}
	}

	exit(EXIT_FAILURE);
}


ruptimed4.c
/**
 * 一个面向无连接的服务进程：
 * 使用前需要在/etc/services文件中添加
 * ruptime	66666/udp
 */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <semaphore.h>
#include <syslog.h>
#include <aio.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int lock_reg(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        return fcntl(fd, cmd, &flockbuf);
}

int lock_test(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        if (fcntl(fd, F_GETLK, &flockbuf) < 0)
                err_sys("fcntl error");
        if (flockbuf.l_type == F_UNLCK)
                return 0;
        return flockbuf.l_pid;
}

#define read_lock(fd, offset, whence, len) \
              lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
#define readw_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
#define write_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define writew_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
#define un_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))

#define lockfile(fd) write_lock((fd), 0, SEEK_SET, 0)

//是否可设置读锁
#define is_read_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_RDLCK, (offset), (whence), (len)) == 0)
//是否可设置写锁
#define is_write_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_WRLCK, (offset), (whence), (len)) == 0)

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}


const char* transformTime(time_t t, const char* format)
{
	static char buf[128];
	struct tm* ptm;

	if ((ptm = localtime(&t)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define ERROR_EXIT(m)\
do\
{\
    perror(m);\
    exit(EXIT_FAILURE);\
}\
while(0)

static void daemonize(const char *cmd)
{
	int i, fd0, fd1, fd2;
	pid_t pid;
	struct rlimit rl;
	struct sigaction sa;
	/* 清除文件掩模和改变工作目录 */
	umask(0);
	if(chdir("/") < 0)
		ERROR_EXIT("chdir error");

	/* 获取文件描述符上限并关闭所有文件描述符 */
	if(getrlimit(RLIMIT_NOFILE, &rl) < 0)
		ERROR_EXIT("getrlimit error");
	if(rl.rlim_max == RLIM_INFINITY)
		rl.rlim_max = 1024;
	for(i=0; i<rl.rlim_max; i++)
		close(i);

	/* 第一次fork父进程退出,子进程脱离当前控制终端 */
	if((pid = fork()) < 0)
		ERROR_EXIT("first fork error");
	else if(pid > 0)
		exit(0);

	/* 子进程成为会话组长 */
	setsid();

	/* 处理SIGHUP信号 */
	sa.sa_handler = SIG_IGN;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;
	if(sigaction(SIGHUP, &sa, NULL) < 0)
		ERROR_EXIT("sigaction error");

	/* 第二次fork子进程退出,孙进程不再是会话组长,无权开启终端(与终端彻底隔离) */
	if((pid = fork()) < 0)
		ERROR_EXIT("second fork error");
	else if(pid > 0)
		exit(0);

	/* 将 0,1,2重定向到/dev/null */
	fd0 = open("/dev/null", O_RDWR);
	fd1 = dup(0);
	fd2 = dup(0);

	/* 初始化log file */
	openlog(cmd, LOG_CONS, LOG_DAEMON);
	if(fd0 != 0 || fd1 != 1 || fd2 != 2){
		syslog(LOG_ERR, "unexpected file descriptors %d %d %d", fd0, fd1, fd2);
		exit(1);
	}
}

#define MAXSLEEP 128

/**
 * 建立与服务进程的Internet套接字的逻辑连接，并在失败时以指数补
 * 偿算法进行重试
 */
int connect_retry(int domain, int type, int protocol, const struct sockaddr* addr, socklen_t alen) {
        int numsec, fd;

        for (numsec = 1; numsec <= MAXSLEEP; numsec <<= 1) {
                if ((fd = socket(domain, type, protocol)) == -1)
                        return -1;
                if (connect(fd, addr, alen) == 0)
                        return fd;
                close(fd);

                if (numsec <= MAXSLEEP / 2)
                        sleep(numsec);
        }
        return -1;
}


/**
 * 完成Internet流式套接字/数据报套接字服务进程初始化一条龙，并且调用
 * setsockopt()使得进程在主机重启之后仍然能够重新绑定该地址
 */
int init_server(int type, const struct sockaddr* addr, socklen_t alen, int qlen) {
        int fd, err = 0;
        int reuse = 1;

        if ((fd = socket(addr->sa_family, type, 0)) < 0)
                return -1;
        if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(int)) < 0)
                goto errout;
        if (bind(fd, addr, alen) < 0)
                goto errout;
        if (type == SOCK_STREAM || type == SOCK_SEQPACKET) {
                if (listen(fd, qlen) < 0)
                        return -1;
        }
        return fd;

errout:
        err = errno;
        close(fd);
        errno = err;
        return -1;
}

#define BUFLEN 128
#define QLEN 10

#ifndef HOST_NAME_MAX
#define HOST_NAME_MAX 256
#endif

#define MAXADDRLEN 256

void serve(int sockfd) {
	int n; socklen_t alen; FILE* fp;
	char buf[BUFLEN], abuf[MAXADDRLEN];
	struct sockaddr* addr = (struct sockaddr*)abuf;

	set_cloexec(sockfd);
	for (;;) {
		alen = MAXADDRLEN;
		/* 先执行recvfrom操作的目的是为了从客户进程发送过来的消息中提取地址等相关信息 */
		if ((n = recvfrom(sockfd, buf, BUFLEN, 0, addr, &alen)) == -1) {
			syslog(LOG_ERR, "ruptimed: recvfrom error: %s",
				strerror(errno));
			exit(EXIT_FAILURE);
		}
		if ((fp = popen("/usr/bin/uptime", "r")) == NULL) {
			sprintf(buf, "error: %s\n", strerror(errno));
			exit(EXIT_FAILURE);
		}
		else {
			if (fgets(buf, BUFLEN, fp) != NULL)
				sendto(sockfd, buf, strlen(buf), 0, addr, alen);
			pclose(fp);
		}
	}
}


int main(int argc, char* argv[])
{
	struct addrinfo* ailist;
	struct addrinfo hint;
	int sockfd, err, n;
	char* host;

	if (argc != 1) {
		printf("usage: %s"); exit(1);
	}

	if ((n = sysconf(_SC_HOST_NAME_MAX)) == -1)
		n = HOST_NAME_MAX;
	if ((host = malloc(n)) == NULL)
		err_sys("malloc error");
	if (gethostname(host, n) == -1)
		err_sys("gethostname error");

	daemonize("ruptimed");
	memset(&hint, 0, sizeof(hint));
	hint.ai_socktype = SOCK_DGRAM;
	hint.ai_flags = AI_CANONNAME;
	hint.ai_canonname = NULL;
	hint.ai_addr = NULL;
	hint.ai_next = NULL;
	if ((err = getaddrinfo(host, "ruptime", &hint, &ailist)) != 0) {
		syslog(LOG_ERR, "ruptimed: getaddrinfo error: %s", gai_strerror(err));
		exit(EXIT_FAILURE);
	}

	for (struct addrinfo* aip = ailist; aip != NULL; aip = aip->ai_next) {
		//这里init_server只做socket和bind操作
		if ((sockfd = init_server(SOCK_DGRAM, aip->ai_addr,
				aip->ai_addrlen, 0)) >= 0) {
			serve(sockfd);
			exit(EXIT_SUCCESS);
		}
	}
	exit(EXIT_FAILURE);
}

ruptime2.c
/**
 * 一个面向无连接的ruptime客户进程
 * */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <semaphore.h>
#include <syslog.h>
#include <aio.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int lock_reg(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        return fcntl(fd, cmd, &flockbuf);
}

int lock_test(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        if (fcntl(fd, F_GETLK, &flockbuf) < 0)
                err_sys("fcntl error");
        if (flockbuf.l_type == F_UNLCK)
                return 0;
        return flockbuf.l_pid;
}

#define read_lock(fd, offset, whence, len) \
              lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
#define readw_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
#define write_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define writew_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
#define un_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))

#define lockfile(fd) write_lock((fd), 0, SEEK_SET, 0)

//是否可设置读锁
#define is_read_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_RDLCK, (offset), (whence), (len)) == 0)
//是否可设置写锁
#define is_write_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_WRLCK, (offset), (whence), (len)) == 0)

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}


const char* transformTime(time_t t, const char* format)
{
	static char buf[128];
	struct tm* ptm;

	if ((ptm = localtime(&t)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define ERROR_EXIT(m)\
do\
{\
    perror(m);\
    exit(EXIT_FAILURE);\
}\
while(0)

static void daemonize(const char *cmd)
{
	int i, fd0, fd1, fd2;
	pid_t pid;
	struct rlimit rl;
	struct sigaction sa;
	/* 清除文件掩模和改变工作目录 */
	umask(0);
	if(chdir("/") < 0)
		ERROR_EXIT("chdir error");

	/* 获取文件描述符上限并关闭所有文件描述符 */
	if(getrlimit(RLIMIT_NOFILE, &rl) < 0)
		ERROR_EXIT("getrlimit error");
	if(rl.rlim_max == RLIM_INFINITY)
		rl.rlim_max = 1024;
	for(i=0; i<rl.rlim_max; i++)
		close(i);

	/* 第一次fork父进程退出,子进程脱离当前控制终端 */
	if((pid = fork()) < 0)
		ERROR_EXIT("first fork error");
	else if(pid > 0)
		exit(0);

	/* 子进程成为会话组长 */
	setsid();

	/* 处理SIGHUP信号 */
	sa.sa_handler = SIG_IGN;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;
	if(sigaction(SIGHUP, &sa, NULL) < 0)
		ERROR_EXIT("sigaction error");

	/* 第二次fork子进程退出,孙进程不再是会话组长,无权开启终端(与终端彻底隔离) */
	if((pid = fork()) < 0)
		ERROR_EXIT("second fork error");
	else if(pid > 0)
		exit(0);

	/* 将 0,1,2重定向到/dev/null */
	fd0 = open("/dev/null", O_RDWR);
	fd1 = dup(0);
	fd2 = dup(0);

	/* 初始化log file */
	openlog(cmd, LOG_CONS, LOG_DAEMON);
	if(fd0 != 0 || fd1 != 1 || fd2 != 2){
		syslog(LOG_ERR, "unexpected file descriptors %d %d %d", fd0, fd1, fd2);
		exit(1);
	}
}

#define MAXSLEEP 128

/**
 * 建立与服务进程的Internet套接字的逻辑连接，并在失败时以指数补
 * 偿算法进行重试
 */
int connect_retry(int domain, int type, int protocol, const struct sockaddr* addr, socklen_t alen) {
        int numsec, fd;

        for (numsec = 1; numsec <= MAXSLEEP; numsec <<= 1) {
                if ((fd = socket(domain, type, protocol)) == -1)
                        return -1;
                if (connect(fd, addr, alen) == 0)
                        return fd;
                close(fd);

                if (numsec <= MAXSLEEP / 2)
                        sleep(numsec);
        }
        return -1;
}


/**
 * 完成Internet流式套接字/数据报套接字服务进程初始化一条龙，并且调用
 * setsockopt()使得进程在主机重启之后仍然能够重新绑定该地址
 */
int init_server(int type, const struct sockaddr* addr, socklen_t alen, int qlen) {
        int fd, err = 0;
        int reuse = 1;

        if ((fd = socket(addr->sa_family, type, 0)) < 0)
                return -1;
        if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(int)) < 0)
                goto errout;
        if (bind(fd, addr, alen) < 0)
                goto errout;
        if (type == SOCK_STREAM || type == SOCK_SEQPACKET) {
                if (listen(fd, qlen) < 0)
                        return -1;
        }
        return fd;

errout:
        err = errno;
        close(fd);
        errno = err;
        return -1;
}

#define BUFLEN 128
#define QLEN 10

#ifndef HOST_NAME_MAX
#define HOST_NAME_MAX 256
#endif

#define MAXADDRLEN 256
#define TIMEOUT 20

void sigalrm(int signo) {}

void print_uptime(int sockfd, struct addrinfo* aip) {
	int nrecv;
	char buf[BUFLEN];

	buf[0] = '\0';
	if (sendto(sockfd, buf, 1, 0, aip->ai_addr, aip->ai_addrlen) < 0)
		err_sys("sendto error");

	/* alarm()函数的作用是防止recvfrom函数长时间阻塞 */
	alarm(TIMEOUT);
	if ((nrecv = recvfrom(sockfd, buf, BUFLEN, 0, NULL, NULL)) < 0) {
		if (errno != EINTR)
			alarm(0);
		err_sys("recv error");
	}
	alarm(0);
	write(STDOUT_FILENO, buf, strlen(buf));
}

int main(int argc, char* argv[])
{
	struct addrinfo* ailist;
	struct addrinfo hint;
	struct sigaction sa;
	int sockfd, err;

	if (argc != 2) {
		printf("usage: %s hostname", argv[0]); exit(1);
	}
	
	//设置信号处理程序
	sa.sa_flags = 0;
	sa.sa_handler = sigalrm;
	sigemptyset(&sa.sa_mask);
	if (sigaction(SIGALRM, &sa, NULL) < 0)
		err_sys("sigaction error");

	//根据给定主机名获取地址相关信息
	memset(&hint, 0, sizeof(hint));
	hint.ai_socktype = SOCK_DGRAM;
	hint.ai_canonname = NULL;
	hint.ai_addr = NULL;
	hint.ai_next = NULL;
	if ((err = getaddrinfo(argv[1], "ruptime", &hint, &ailist)) == -1) {
		printf("getaddrinfo error: %s", gai_strerror(err)); exit(1);
	}

	//创建套接字直接使用sendto函数发送消息并使用recvfrom等待回应
	for (struct addrinfo* aip = ailist; aip != NULL; aip = aip->ai_next) {
		if ((sockfd = socket(aip->ai_family, SOCK_DGRAM, 0)) < 0)
			err = errno;
		else {
			print_uptime(sockfd, aip);
			exit(EXIT_SUCCESS);
		}
	}

	fprintf(stderr, "can't contact %s: %s\n", argv[1], strerror(err));
	exit(EXIT_FAILURE);
}

myudpserver.c
/* 
 * 一个基于数据报(协议为UDP)的服务进程，从客户端获取数据(也同时需要
 * 截取地址端口等信息)，然后将其中的小写字符串转换为大写字符串后发送
 * 给客户端进程
 * 
 */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <semaphore.h>
#include <syslog.h>
#include <aio.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int lock_reg(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        return fcntl(fd, cmd, &flockbuf);
}

int lock_test(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        if (fcntl(fd, F_GETLK, &flockbuf) < 0)
                err_sys("fcntl error");
        if (flockbuf.l_type == F_UNLCK)
                return 0;
        return flockbuf.l_pid;
}

#define read_lock(fd, offset, whence, len) \
              lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
#define readw_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
#define write_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define writew_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
#define un_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))

#define lockfile(fd) write_lock((fd), 0, SEEK_SET, 0)

//是否可设置读锁
#define is_read_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_RDLCK, (offset), (whence), (len)) == 0)
//是否可设置写锁
#define is_write_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_WRLCK, (offset), (whence), (len)) == 0)

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}


const char* transformTime(time_t t, const char* format)
{
	static char buf[128];
	struct tm* ptm;

	if ((ptm = localtime(&t)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define ERROR_EXIT(m)\
do\
{\
    perror(m);\
    exit(EXIT_FAILURE);\
}\
while(0)

static void daemonize(const char *cmd)
{
	int i, fd0, fd1, fd2;
	pid_t pid;
	struct rlimit rl;
	struct sigaction sa;
	/* 清除文件掩模和改变工作目录 */
	umask(0);
	if(chdir("/") < 0)
		ERROR_EXIT("chdir error");

	/* 获取文件描述符上限并关闭所有文件描述符 */
	if(getrlimit(RLIMIT_NOFILE, &rl) < 0)
		ERROR_EXIT("getrlimit error");
	if(rl.rlim_max == RLIM_INFINITY)
		rl.rlim_max = 1024;
	for(i=0; i<rl.rlim_max; i++)
		close(i);

	/* 第一次fork父进程退出,子进程脱离当前控制终端 */
	if((pid = fork()) < 0)
		ERROR_EXIT("first fork error");
	else if(pid > 0)
		exit(0);

	/* 子进程成为会话组长 */
	setsid();

	/* 处理SIGHUP信号 */
	sa.sa_handler = SIG_IGN;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;
	if(sigaction(SIGHUP, &sa, NULL) < 0)
		ERROR_EXIT("sigaction error");

	/* 第二次fork子进程退出,孙进程不再是会话组长,无权开启终端(与终端彻底隔离) */
	if((pid = fork()) < 0)
		ERROR_EXIT("second fork error");
	else if(pid > 0)
		exit(0);

	/* 将 0,1,2重定向到/dev/null */
	fd0 = open("/dev/null", O_RDWR);
	fd1 = dup(0);
	fd2 = dup(0);

	/* 初始化log file */
	openlog(cmd, LOG_CONS, LOG_DAEMON);
	if(fd0 != 0 || fd1 != 1 || fd2 != 2){
		syslog(LOG_ERR, "unexpected file descriptors %d %d %d", fd0, fd1, fd2);
		exit(1);
	}
}

#define MAXSLEEP 128

/**
 * 建立与服务进程的Internet套接字的逻辑连接，并在失败时以指数补
 * 偿算法进行重试
 */
int connect_retry(int domain, int type, int protocol, const struct sockaddr* addr, socklen_t alen) {
        int numsec, fd;

        for (numsec = 1; numsec <= MAXSLEEP; numsec <<= 1) {
                if ((fd = socket(domain, type, protocol)) == -1)
                        return -1;
                if (connect(fd, addr, alen) == 0)
                        return fd;
                close(fd);

                if (numsec <= MAXSLEEP / 2)
                        sleep(numsec);
        }
        return -1;
}


/**
 * 完成Internet流式套接字/数据报套接字服务进程初始化一条龙，并且调用
 * setsockopt()使得进程在主机重启之后仍然能够重新绑定该地址
 */
int init_server(int type, const struct sockaddr* addr, socklen_t alen, int qlen) {
        int fd, err = 0;
        int reuse = 1;

        if ((fd = socket(addr->sa_family, type, 0)) < 0)
                return -1;
        if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(int)) < 0)
                goto errout;
        if (bind(fd, addr, alen) < 0)
                goto errout;
        if (type == SOCK_STREAM || type == SOCK_SEQPACKET) {
                if (listen(fd, qlen) < 0)
                        return -1;
        }
        return fd;

errout:
        err = errno;
        close(fd);
        errno = err;
        return -1;
}

#define BUFLEN 128
#define QLEN 10

#ifndef HOST_NAME_MAX
#define HOST_NAME_MAX 256
#endif

#define MAXADDRLEN 256
#define TIMEOUT 20

#define MAXLINE 128
#define PORT_NUM 12000

int main(int argc, char* argv[])
{
	char buf[MAXLINE], claddrStr[INET_ADDRSTRLEN];
	struct sockaddr_in svaddr, claddr;
	int sockfd, nrecv;
	socklen_t alen;

	if (argc != 1) {
		printf("usage: %s", argv[0]); exit(1);
	}
	if (signal(SIGPIPE, SIG_IGN) == SIG_ERR)
		err_sys("signal error");

	/* 初始化基于UDP的服务器进程 */
	memset(&svaddr, 0, sizeof(struct sockaddr_in));
	svaddr.sin_family = AF_INET;
	svaddr.sin_addr.s_addr = INADDR_ANY;
	svaddr.sin_port = htons(PORT_NUM);
	if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
		err_sys("socket error");
	if (bind(sockfd, (struct sockaddr*)&svaddr, sizeof(struct sockaddr_in)) == -1)
		err_sys("bind error");

	for (;;) {
		/* 接收消息并获取地址端口等信息，并打印这些信息 */
		alen = sizeof(struct sockaddr_in);
		if ((nrecv = recvfrom(sockfd, buf, MAXLINE, 0,
							(struct sockaddr*)&claddr, &alen)) == -1) {
			perror("recvfrom error");
			continue;
		}
		if (inet_ntop(AF_INET, &claddr.sin_addr, claddrStr, INET_ADDRSTRLEN) == NULL)
			err_sys("inet_ntop error");
		printf("Received new datagram from %s:%hu...\n", claddrStr, claddr.sin_port);

		for (int i = 0; i < nrecv; ++i)
			buf[i] = toupper(buf[i]);
		if (sendto(sockfd, buf, nrecv, 0, (struct sockaddr*)&claddr,
					sizeof(struct sockaddr_in)) == -1)
			err_sys("sendto error");
	}
}


myudpclient.c
/* 
 * 一个基于数据报套接字的客户进程，将用户输入的字符串发送给
 * 服务进程，然后从服务进程中接收到响应信息并输出
 */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <semaphore.h>
#include <syslog.h>
#include <aio.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int lock_reg(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        return fcntl(fd, cmd, &flockbuf);
}

int lock_test(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        if (fcntl(fd, F_GETLK, &flockbuf) < 0)
                err_sys("fcntl error");
        if (flockbuf.l_type == F_UNLCK)
                return 0;
        return flockbuf.l_pid;
}

#define read_lock(fd, offset, whence, len) \
              lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
#define readw_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
#define write_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define writew_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
#define un_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))

#define lockfile(fd) write_lock((fd), 0, SEEK_SET, 0)

//是否可设置读锁
#define is_read_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_RDLCK, (offset), (whence), (len)) == 0)
//是否可设置写锁
#define is_write_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_WRLCK, (offset), (whence), (len)) == 0)

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}


const char* transformTime(time_t t, const char* format)
{
	static char buf[128];
	struct tm* ptm;

	if ((ptm = localtime(&t)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define ERROR_EXIT(m)\
do\
{\
    perror(m);\
    exit(EXIT_FAILURE);\
}\
while(0)

static void daemonize(const char *cmd)
{
	int i, fd0, fd1, fd2;
	pid_t pid;
	struct rlimit rl;
	struct sigaction sa;
	/* 清除文件掩模和改变工作目录 */
	umask(0);
	if(chdir("/") < 0)
		ERROR_EXIT("chdir error");

	/* 获取文件描述符上限并关闭所有文件描述符 */
	if(getrlimit(RLIMIT_NOFILE, &rl) < 0)
		ERROR_EXIT("getrlimit error");
	if(rl.rlim_max == RLIM_INFINITY)
		rl.rlim_max = 1024;
	for(i=0; i<rl.rlim_max; i++)
		close(i);

	/* 第一次fork父进程退出,子进程脱离当前控制终端 */
	if((pid = fork()) < 0)
		ERROR_EXIT("first fork error");
	else if(pid > 0)
		exit(0);

	/* 子进程成为会话组长 */
	setsid();

	/* 处理SIGHUP信号 */
	sa.sa_handler = SIG_IGN;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;
	if(sigaction(SIGHUP, &sa, NULL) < 0)
		ERROR_EXIT("sigaction error");

	/* 第二次fork子进程退出,孙进程不再是会话组长,无权开启终端(与终端彻底隔离) */
	if((pid = fork()) < 0)
		ERROR_EXIT("second fork error");
	else if(pid > 0)
		exit(0);

	/* 将 0,1,2重定向到/dev/null */
	fd0 = open("/dev/null", O_RDWR);
	fd1 = dup(0);
	fd2 = dup(0);

	/* 初始化log file */
	openlog(cmd, LOG_CONS, LOG_DAEMON);
	if(fd0 != 0 || fd1 != 1 || fd2 != 2){
		syslog(LOG_ERR, "unexpected file descriptors %d %d %d", fd0, fd1, fd2);
		exit(1);
	}
}

#define MAXSLEEP 128

/**
 * 建立与服务进程的Internet套接字的逻辑连接，并在失败时以指数补
 * 偿算法进行重试
 */
int connect_retry(int domain, int type, int protocol, const struct sockaddr* addr, socklen_t alen) {
        int numsec, fd;

        for (numsec = 1; numsec <= MAXSLEEP; numsec <<= 1) {
                if ((fd = socket(domain, type, protocol)) == -1)
                        return -1;
                if (connect(fd, addr, alen) == 0)
                        return fd;
                close(fd);

                if (numsec <= MAXSLEEP / 2)
                        sleep(numsec);
        }
        return -1;
}


/**
 * 完成Internet流式套接字/数据报套接字服务进程初始化一条龙，并且调用
 * setsockopt()使得进程在主机重启之后仍然能够重新绑定该地址
 */
int init_server(int type, const struct sockaddr* addr, socklen_t alen, int qlen) {
        int fd, err = 0;
        int reuse = 1;

        if ((fd = socket(addr->sa_family, type, 0)) < 0)
                return -1;
        if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(int)) < 0)
                goto errout;
        if (bind(fd, addr, alen) < 0)
                goto errout;
        if (type == SOCK_STREAM || type == SOCK_SEQPACKET) {
                if (listen(fd, qlen) < 0)
                        return -1;
        }
        return fd;

errout:
        err = errno;
        close(fd);
        errno = err;
        return -1;
}

#define BUFLEN 128
#define QLEN 10

#ifndef HOST_NAME_MAX
#define HOST_NAME_MAX 256
#endif

#define MAXADDRLEN 256
#define TIMEOUT 20

#define MAXLINE 128
#define PORT_NUM 12000

int main(int argc, char* argv[])
{
	char buf[MAXLINE], addr[INET_ADDRSTRLEN];
	struct sockaddr_in svaddr;
	in_port_t port;
	int sockfd;
	int ch;

	opterr = 0;
	while ((ch = getopt(argc, argv, "hp:a:")) != -1) {
		switch (ch) {
		case 'h':
			printf("usage: %s [-p port] [-a ipv4-address]\n"
				     "       %s [-h]", argv[0], argv[0]); exit(1); break;
		case 'p':
			port = (in_port_t)atoi(optarg);
			break;
		case 'a':
			strncpy(addr, optarg, INET_ADDRSTRLEN - 1);
			addr[INET_ADDRSTRLEN - 1] = 0;
			break;
		case '?':
			printf("unrecognized option: -%c", optopt); exit(1); break;
		}
	}

	memset(&svaddr, 0, sizeof(struct sockaddr_in));
	svaddr.sin_family = AF_INET;
	svaddr.sin_port = htons(port);
	if (inet_pton(AF_INET, addr, &svaddr.sin_addr) <= 0)
		err_sys("server address convert error");
	if ((sockfd = socket(AF_INET, SOCK_DGRAM, 0)) == -1)
		err_sys("socket error");
	
	printf("Input: "); fflush(stdout);
	if (fgets(buf, MAXLINE, stdin) == NULL)
		err_sys("fgets error");
	if (sendto(sockfd, buf, strlen(buf) + 1, 0, (struct sockaddr*)&svaddr,
			sizeof(struct sockaddr_in)) == -1)
		err_sys("sendto error");
	if (recv(sockfd, buf, MAXLINE, 0) == -1)
		err_sys("recv error");
	printf("Server: %s", buf);

	close(sockfd);
	exit(EXIT_SUCCESS);
}

mytcpserver.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <semaphore.h>
#include <syslog.h>
#include <aio.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int lock_reg(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        return fcntl(fd, cmd, &flockbuf);
}

int lock_test(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        if (fcntl(fd, F_GETLK, &flockbuf) < 0)
                err_sys("fcntl error");
        if (flockbuf.l_type == F_UNLCK)
                return 0;
        return flockbuf.l_pid;
}

#define read_lock(fd, offset, whence, len) \
              lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
#define readw_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
#define write_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define writew_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
#define un_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))

#define lockfile(fd) write_lock((fd), 0, SEEK_SET, 0)

//是否可设置读锁
#define is_read_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_RDLCK, (offset), (whence), (len)) == 0)
//是否可设置写锁
#define is_write_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_WRLCK, (offset), (whence), (len)) == 0)

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}


const char* transformTime(time_t t, const char* format)
{
	static char buf[128];
	struct tm* ptm;

	if ((ptm = localtime(&t)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define ERROR_EXIT(m)\
do\
{\
    perror(m);\
    exit(EXIT_FAILURE);\
}\
while(0)

static void daemonize(const char *cmd)
{
	int i, fd0, fd1, fd2;
	pid_t pid;
	struct rlimit rl;
	struct sigaction sa;
	/* 清除文件掩模和改变工作目录 */
	umask(0);
	if(chdir("/") < 0)
		ERROR_EXIT("chdir error");

	/* 获取文件描述符上限并关闭所有文件描述符 */
	if(getrlimit(RLIMIT_NOFILE, &rl) < 0)
		ERROR_EXIT("getrlimit error");
	if(rl.rlim_max == RLIM_INFINITY)
		rl.rlim_max = 1024;
	for(i=0; i<rl.rlim_max; i++)
		close(i);

	/* 第一次fork父进程退出,子进程脱离当前控制终端 */
	if((pid = fork()) < 0)
		ERROR_EXIT("first fork error");
	else if(pid > 0)
		exit(0);

	/* 子进程成为会话组长 */
	setsid();

	/* 处理SIGHUP信号 */
	sa.sa_handler = SIG_IGN;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;
	if(sigaction(SIGHUP, &sa, NULL) < 0)
		ERROR_EXIT("sigaction error");

	/* 第二次fork子进程退出,孙进程不再是会话组长,无权开启终端(与终端彻底隔离) */
	if((pid = fork()) < 0)
		ERROR_EXIT("second fork error");
	else if(pid > 0)
		exit(0);

	/* 将 0,1,2重定向到/dev/null */
	fd0 = open("/dev/null", O_RDWR);
	fd1 = dup(0);
	fd2 = dup(0);

	/* 初始化log file */
	openlog(cmd, LOG_CONS, LOG_DAEMON);
	if(fd0 != 0 || fd1 != 1 || fd2 != 2){
		syslog(LOG_ERR, "unexpected file descriptors %d %d %d", fd0, fd1, fd2);
		exit(1);
	}
}

#define MAXSLEEP 128

/**
 * 建立与服务进程的Internet套接字的逻辑连接，并在失败时以指数补
 * 偿算法进行重试
 */
int connect_retry(int domain, int type, int protocol, const struct sockaddr* addr, socklen_t alen) {
        int numsec, fd;

        for (numsec = 1; numsec <= MAXSLEEP; numsec <<= 1) {
                if ((fd = socket(domain, type, protocol)) == -1)
                        return -1;
                if (connect(fd, addr, alen) == 0)
                        return fd;
                close(fd);

                if (numsec <= MAXSLEEP / 2)
                        sleep(numsec);
        }
        return -1;
}


/**
 * 完成Internet流式套接字/数据报套接字服务进程初始化一条龙，并且调用
 * setsockopt()使得进程在主机重启之后仍然能够重新绑定该地址
 */
int init_server(int type, const struct sockaddr* addr, socklen_t alen, int qlen) {
        int fd, err = 0;
        int reuse = 1;

        if ((fd = socket(addr->sa_family, type, 0)) < 0)
                return -1;
        if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(int)) < 0)
                goto errout;
        if (bind(fd, addr, alen) < 0)
                goto errout;
        if (type == SOCK_STREAM || type == SOCK_SEQPACKET) {
                if (listen(fd, qlen) < 0)
                        return -1;
        }
        return fd;

errout:
        err = errno;
        close(fd);
        errno = err;
        return -1;
}

#define BUFLEN 128
#define QLEN 10

#ifndef HOST_NAME_MAX
#define HOST_NAME_MAX 256
#endif

#define MAXLINE 256
#define PORT_NUM 12000

int main(int argc, char* argv[])
{
	char claddrStr[INET_ADDRSTRLEN], buf[MAXLINE];
	struct sockaddr_in svaddr, claddr;
	int sockfd, clfd, nrecv;
	socklen_t alen;

	if (argc != 1) {
		printf("usage: %s"); exit(1);
	}
	if (signal(SIGPIPE, SIG_IGN) == SIG_ERR)
		err_sys("signal error");

	/* 初始化服务进程，可接受来自任一地址的连接 */
	memset(&svaddr, 0, sizeof(struct sockaddr_in));
	svaddr.sin_family = AF_INET;
	svaddr.sin_addr.s_addr = INADDR_ANY;
	svaddr.sin_port = htons(PORT_NUM);
	if ((sockfd = init_server(SOCK_STREAM, (struct sockaddr*)&svaddr,
							sizeof(struct sockaddr_in), 1)) == -1)
		err_sys("init_server error");

	for (;;) {
		alen = sizeof(struct sockaddr_in);
		if ((clfd = accept(sockfd, (struct sockaddr*)&claddr, &alen)) == -1) {
			perror("accept error");
			continue;
		}
		//转换为人易读的格式并打印
		if (inet_ntop(AF_INET, &claddr.sin_addr, claddrStr, INET_ADDRSTRLEN) == NULL)
			err_sys("inet_ntop error");
		printf("Accept new connect from %s:%hu...\n", claddrStr, claddr.sin_port);

		while ((nrecv = recv(clfd, buf, MAXLINE, 0)) > 0) {
			for (int i = 0; i < nrecv; i++)
				buf[i] = toupper(buf[i]);
			if (send(clfd, buf, nrecv, 0) == -1)
				err_sys("send error");
		}
		if (nrecv < 0)
			err_sys("recv error");
		close(clfd);
	}
}

mytcpclient.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <semaphore.h>
#include <syslog.h>
#include <aio.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int lock_reg(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        return fcntl(fd, cmd, &flockbuf);
}

int lock_test(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        if (fcntl(fd, F_GETLK, &flockbuf) < 0)
                err_sys("fcntl error");
        if (flockbuf.l_type == F_UNLCK)
                return 0;
        return flockbuf.l_pid;
}

#define read_lock(fd, offset, whence, len) \
              lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
#define readw_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
#define write_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define writew_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
#define un_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))

#define lockfile(fd) write_lock((fd), 0, SEEK_SET, 0)

//是否可设置读锁
#define is_read_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_RDLCK, (offset), (whence), (len)) == 0)
//是否可设置写锁
#define is_write_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_WRLCK, (offset), (whence), (len)) == 0)

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}


const char* transformTime(time_t t, const char* format)
{
	static char buf[128];
	struct tm* ptm;

	if ((ptm = localtime(&t)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define ERROR_EXIT(m)\
do\
{\
    perror(m);\
    exit(EXIT_FAILURE);\
}\
while(0)

static void daemonize(const char *cmd)
{
	int i, fd0, fd1, fd2;
	pid_t pid;
	struct rlimit rl;
	struct sigaction sa;
	/* 清除文件掩模和改变工作目录 */
	umask(0);
	if(chdir("/") < 0)
		ERROR_EXIT("chdir error");

	/* 获取文件描述符上限并关闭所有文件描述符 */
	if(getrlimit(RLIMIT_NOFILE, &rl) < 0)
		ERROR_EXIT("getrlimit error");
	if(rl.rlim_max == RLIM_INFINITY)
		rl.rlim_max = 1024;
	for(i=0; i<rl.rlim_max; i++)
		close(i);

	/* 第一次fork父进程退出,子进程脱离当前控制终端 */
	if((pid = fork()) < 0)
		ERROR_EXIT("first fork error");
	else if(pid > 0)
		exit(0);

	/* 子进程成为会话组长 */
	setsid();

	/* 处理SIGHUP信号 */
	sa.sa_handler = SIG_IGN;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;
	if(sigaction(SIGHUP, &sa, NULL) < 0)
		ERROR_EXIT("sigaction error");

	/* 第二次fork子进程退出,孙进程不再是会话组长,无权开启终端(与终端彻底隔离) */
	if((pid = fork()) < 0)
		ERROR_EXIT("second fork error");
	else if(pid > 0)
		exit(0);

	/* 将 0,1,2重定向到/dev/null */
	fd0 = open("/dev/null", O_RDWR);
	fd1 = dup(0);
	fd2 = dup(0);

	/* 初始化log file */
	openlog(cmd, LOG_CONS, LOG_DAEMON);
	if(fd0 != 0 || fd1 != 1 || fd2 != 2){
		syslog(LOG_ERR, "unexpected file descriptors %d %d %d", fd0, fd1, fd2);
		exit(1);
	}
}

#define MAXSLEEP 128

/**
 * 建立与服务进程的Internet套接字的逻辑连接，并在失败时以指数补
 * 偿算法进行重试
 */
int connect_retry(int domain, int type, int protocol, const struct sockaddr* addr, socklen_t alen) {
        int numsec, fd;

        for (numsec = 1; numsec <= MAXSLEEP; numsec <<= 1) {
                if ((fd = socket(domain, type, protocol)) == -1)
                        return -1;
                if (connect(fd, addr, alen) == 0)
                        return fd;
                close(fd);

                if (numsec <= MAXSLEEP / 2)
                        sleep(numsec);
        }
        return -1;
}


/**
 * 完成Internet流式套接字/数据报套接字服务进程初始化一条龙，并且调用
 * setsockopt()使得进程在主机重启之后仍然能够重新绑定该地址
 */
int init_server(int type, const struct sockaddr* addr, socklen_t alen, int qlen) {
        int fd, err = 0;
        int reuse = 1;

        if ((fd = socket(addr->sa_family, type, 0)) < 0)
                return -1;
        if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(int)) < 0)
                goto errout;
        if (bind(fd, addr, alen) < 0)
                goto errout;
        if (type == SOCK_STREAM || type == SOCK_SEQPACKET) {
                if (listen(fd, qlen) < 0)
                        return -1;
        }
        return fd;

errout:
        err = errno;
        close(fd);
        errno = err;
        return -1;
}

#define BUFLEN 128
#define QLEN 10

#ifndef HOST_NAME_MAX
#define HOST_NAME_MAX 256
#endif

#define MAXLINE 256
#define PORT_NUM 12000

int main(int argc, char* argv[])
{
	char buf[MAXLINE], addr[INET_ADDRSTRLEN];
	struct sockaddr_in svaddr;
	in_port_t port;
	int sockfd;
	int ch;

	opterr = 0;
	while ((ch = getopt(argc, argv, "hp:a:")) != -1) {
		switch(ch) {
		case 'h':
			printf("usage: %s [-p port] [-a ipv4-address]\n"
		             "       %s [-h]", argv[0], argv[0]); exit(1); 
			break;
		case 'p':
			port = (in_port_t)atoi(optarg);
			break;
		case 'a':
			strncpy(addr, optarg, INET_ADDRSTRLEN - 1);
			addr[INET_ADDRSTRLEN - 1] = 0;
			break;
		case '?':
			printf("unrecognized option: -%c", optopt); exit(1);
			break;
		}
	}

	/* 客户进程试图与服务进程进行连接 */
	memset(&svaddr, 0, sizeof(struct sockaddr_in));
	svaddr.sin_family = AF_INET;
	svaddr.sin_port = htons(port);
	if (inet_pton(AF_INET, addr, &svaddr.sin_addr) <= 0)
		err_sys("server address convert error");
	if ((sockfd = connect_retry(AF_INET, SOCK_STREAM, 0,
			(struct sockaddr*)&svaddr, sizeof(struct sockaddr_in))) == -1)
		err_sys("connect_retry error");

	printf("Input: "); fflush(stdout);
	if (fgets(buf, MAXLINE, stdin) == NULL)
		err_sys("fgets error");
	if (send(sockfd, buf, strlen(buf) + 1, 0) == -1)
		err_sys("send error");
	if (recv(sockfd, buf, MAXLINE, 0) == -1)
		err_sys("recv error");
	printf("Server: %s", buf);

	close(sockfd);
	exit(EXIT_SUCCESS);
}

mysocketstat.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <semaphore.h>
#include <syslog.h>
#include <aio.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int lock_reg(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        return fcntl(fd, cmd, &flockbuf);
}

int lock_test(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        if (fcntl(fd, F_GETLK, &flockbuf) < 0)
                err_sys("fcntl error");
        if (flockbuf.l_type == F_UNLCK)
                return 0;
        return flockbuf.l_pid;
}

#define read_lock(fd, offset, whence, len) \
              lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
#define readw_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
#define write_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define writew_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
#define un_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))

#define lockfile(fd) write_lock((fd), 0, SEEK_SET, 0)

//是否可设置读锁
#define is_read_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_RDLCK, (offset), (whence), (len)) == 0)
//是否可设置写锁
#define is_write_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_WRLCK, (offset), (whence), (len)) == 0)

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}


const char* transformTime(time_t t, const char* format)
{
	static char buf[128];
	struct tm* ptm;

	if ((ptm = localtime(&t)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define ERROR_EXIT(m)\
do\
{\
    perror(m);\
    exit(EXIT_FAILURE);\
}\
while(0)

static void daemonize(const char *cmd)
{
	int i, fd0, fd1, fd2;
	pid_t pid;
	struct rlimit rl;
	struct sigaction sa;
	/* 清除文件掩模和改变工作目录 */
	umask(0);
	if(chdir("/") < 0)
		ERROR_EXIT("chdir error");

	/* 获取文件描述符上限并关闭所有文件描述符 */
	if(getrlimit(RLIMIT_NOFILE, &rl) < 0)
		ERROR_EXIT("getrlimit error");
	if(rl.rlim_max == RLIM_INFINITY)
		rl.rlim_max = 1024;
	for(i=0; i<rl.rlim_max; i++)
		close(i);

	/* 第一次fork父进程退出,子进程脱离当前控制终端 */
	if((pid = fork()) < 0)
		ERROR_EXIT("first fork error");
	else if(pid > 0)
		exit(0);

	/* 子进程成为会话组长 */
	setsid();

	/* 处理SIGHUP信号 */
	sa.sa_handler = SIG_IGN;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;
	if(sigaction(SIGHUP, &sa, NULL) < 0)
		ERROR_EXIT("sigaction error");

	/* 第二次fork子进程退出,孙进程不再是会话组长,无权开启终端(与终端彻底隔离) */
	if((pid = fork()) < 0)
		ERROR_EXIT("second fork error");
	else if(pid > 0)
		exit(0);

	/* 将 0,1,2重定向到/dev/null */
	fd0 = open("/dev/null", O_RDWR);
	fd1 = dup(0);
	fd2 = dup(0);

	/* 初始化log file */
	openlog(cmd, LOG_CONS, LOG_DAEMON);
	if(fd0 != 0 || fd1 != 1 || fd2 != 2){
		syslog(LOG_ERR, "unexpected file descriptors %d %d %d", fd0, fd1, fd2);
		exit(1);
	}
}

#define MAXSLEEP 128

/**
 * 建立与服务进程的Internet套接字的逻辑连接，并在失败时以指数补
 * 偿算法进行重试
 */
int connect_retry(int domain, int type, int protocol, const struct sockaddr* addr, socklen_t alen) {
        int numsec, fd;

        for (numsec = 1; numsec <= MAXSLEEP; numsec <<= 1) {
                if ((fd = socket(domain, type, protocol)) == -1)
                        return -1;
                if (connect(fd, addr, alen) == 0)
                        return fd;
                close(fd);

                if (numsec <= MAXSLEEP / 2)
                        sleep(numsec);
        }
        return -1;
}


/**
 * 完成Internet流式套接字/数据报套接字服务进程初始化一条龙，并且调用
 * setsockopt()使得进程在主机重启之后仍然能够重新绑定该地址
 */
int init_server(int type, const struct sockaddr* addr, socklen_t alen, int qlen) {
        int fd, err = 0;
        int reuse = 1;

        if ((fd = socket(addr->sa_family, type, 0)) < 0)
                return -1;
        if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(int)) < 0)
                goto errout;
        if (bind(fd, addr, alen) < 0)
                goto errout;
        if (type == SOCK_STREAM || type == SOCK_SEQPACKET) {
                if (listen(fd, qlen) < 0)
                        return -1;
        }
        return fd;

errout:
        err = errno;
        close(fd);
        errno = err;
        return -1;
}

#define BUFLEN 128
#define QLEN 10

#ifndef HOST_NAME_MAX
#define HOST_NAME_MAX 256
#endif

#define MAXLINE 256
#define PORT_NUM 12000

const char *getfiletype(const mode_t *mode)
{
	if(NULL == mode)
		return "mode_t has error";
	if(S_ISREG(*mode))
		return "-";
	else if(S_ISDIR(*mode))
		return "d";
	else if(S_ISCHR(*mode))
		return "c";
	else if(S_ISBLK(*mode))
		return "b";
	else if(S_ISFIFO(*mode))
		return "p";
	else if(S_ISLNK(*mode))
		return "l";
	else if(S_ISSOCK(*mode))
		return "s";
	else
		return "-";
}

const char *getfilemode(const mode_t *mode)
{
	static char buf[16];
	memset(buf, 0, sizeof(buf));
	memset(buf, '-', 9);
	if(NULL == mode)
		return "mode_t has error";
	if((*mode) & S_IRUSR)
		buf[0]='r';
	if((*mode) & S_IWUSR)
		buf[1]='w';
	if((*mode) & S_IXUSR)
		buf[2]='x';
	if((*mode) & S_IRGRP)
		buf[3]='r';
	if((*mode) & S_IWGRP)
		buf[4]='w';
	if((*mode) & S_IXGRP)
		buf[5]='x';
	if((*mode) & S_IROTH)
		buf[6]='r';
	if((*mode) & S_IWOTH)
		buf[7]='w';
	if((*mode) & S_IXOTH)
		buf[8]='x';

	return buf;
}

int main(void)
{
	struct stat statbuf;
	int sockfd;

	if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) == -1)
		err_sys("socket error");

	if (fstat(sockfd, &statbuf) == -1)
		err_sys("fstat error");
	printf("file type     : %s\n", getfiletype(&(statbuf.st_mode)));
	printf("inode number  : %lu\n", statbuf.st_ino);
	printf("link number   : %lu\n", statbuf.st_nlink);
	printf("file mode     : %s\n", getfilemode(&(statbuf.st_mode)));
	printf("uid           : %u\n", statbuf.st_uid);
	printf("gid           : %u\n", statbuf.st_gid);
	printf("file size     : %ld\n", statbuf.st_size);
	printf("atime         : %s\n", transformTime(statbuf.st_atim.tv_sec,
		                                         "%m-%d %T"));

	close(sockfd);
	exit(EXIT_SUCCESS);
}

mysocketaio.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stddef.h>
#include <stdarg.h>
#include <stdbool.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <alloca.h>
#include <setjmp.h>
#include <errno.h>
#include <error.h>
#include <limits.h>
#include <fcntl.h>
#include <dirent.h>
#include <pwd.h>
#include <shadow.h>
#include <grp.h>
#include <signal.h>
#include <termio.h>
#include <termios.h>
#include <pthread.h>
#include <semaphore.h>
#include <syslog.h>
#include <aio.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <sys/resource.h>
#include <sys/sysmacros.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <sys/utsname.h>
#include <sys/termios.h>
#include <sys/ioctl.h>
#include <sys/uio.h>
#include <sys/mman.h>
#include <sys/select.h>
#include <sys/poll.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/sem.h>
#include <sys/shm.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>

void err_sys(const char* msg) {
	fprintf(stderr, msg);
	exit(1);
}

int lock_reg(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        return fcntl(fd, cmd, &flockbuf);
}

int lock_test(int fd, int cmd, int type, off_t offset, int whence, int len) {
        struct flock flockbuf;

        flockbuf.l_type = type;
        flockbuf.l_whence = whence;
        flockbuf.l_start = offset;
        flockbuf.l_len = len;

        if (fcntl(fd, F_GETLK, &flockbuf) < 0)
                err_sys("fcntl error");
        if (flockbuf.l_type == F_UNLCK)
                return 0;
        return flockbuf.l_pid;
}

#define read_lock(fd, offset, whence, len) \
              lock_reg((fd), F_SETLK, F_RDLCK, (offset), (whence), (len))
#define readw_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_RDLCK, (offset), (whence), (len))
#define write_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_WRLCK, (offset), (whence), (len))
#define writew_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLKW, F_WRLCK, (offset), (whence), (len))
#define un_lock(fd, offset, whence, len) \
                lock_reg((fd), F_SETLK, F_UNLCK, (offset), (whence), (len))

#define lockfile(fd) write_lock((fd), 0, SEEK_SET, 0)

//是否可设置读锁
#define is_read_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_RDLCK, (offset), (whence), (len)) == 0)
//是否可设置写锁
#define is_write_lockable(fd, offset, whence, len) \
        (lock_test((fd), F_GETLK, F_WRLCK, (offset), (whence), (len)) == 0)

#define FILE_MODE       (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#define DIR_MODE        (FILE_MODE | S_IXUSR | S_IXGRP | S_IXOTH)

const char* currTime(const char*format)
{
	static char buf[128];
	struct timeval timevalbuf;
	struct tm* ptm;

	gettimeofday(&timevalbuf, NULL);
	if ((ptm = localtime(&timevalbuf.tv_sec)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}


const char* transformTime(time_t t, const char* format)
{
	static char buf[128];
	struct tm* ptm;

	if ((ptm = localtime(&t)) == NULL)
		err_sys("localtime error\n");
             if (format != NULL) {
		if (strftime(buf, sizeof(buf), format, ptm) == 0)
			err_sys("strftime error\n");
	}
	else {
		if (strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", ptm) == 0)
			err_sys("strftime error\n");	
	}
	return buf;
}

int set_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFD, val);
}


int clr_fd(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFD, val);
}

int set_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val |= flags;
        return fcntl(fd, F_SETFL, val);
}

int set_cloexec(int fd) {
        int val;

        if ((val = fcntl(fd, F_GETFD, 0)) < 0)
                return -1;
        val |= FD_CLOEXEC;
        return fcntl(fd, F_SETFD, val);
}

int clr_fl(int fd, int flags) {
        int val;

        if ((val = fcntl(fd, F_GETFL, 0)) < 0)
                return -1;
        val &= ~flags;
        return fcntl(fd, F_SETFL, val);
}

#define ERROR_EXIT(m)\
do\
{\
    perror(m);\
    exit(EXIT_FAILURE);\
}\
while(0)

static void daemonize(const char *cmd)
{
	int i, fd0, fd1, fd2;
	pid_t pid;
	struct rlimit rl;
	struct sigaction sa;
	/* 清除文件掩模和改变工作目录 */
	umask(0);
	if(chdir("/") < 0)
		ERROR_EXIT("chdir error");

	/* 获取文件描述符上限并关闭所有文件描述符 */
	if(getrlimit(RLIMIT_NOFILE, &rl) < 0)
		ERROR_EXIT("getrlimit error");
	if(rl.rlim_max == RLIM_INFINITY)
		rl.rlim_max = 1024;
	for(i=0; i<rl.rlim_max; i++)
		close(i);

	/* 第一次fork父进程退出,子进程脱离当前控制终端 */
	if((pid = fork()) < 0)
		ERROR_EXIT("first fork error");
	else if(pid > 0)
		exit(0);

	/* 子进程成为会话组长 */
	setsid();

	/* 处理SIGHUP信号 */
	sa.sa_handler = SIG_IGN;
	sigemptyset(&sa.sa_mask);
	sa.sa_flags = 0;
	if(sigaction(SIGHUP, &sa, NULL) < 0)
		ERROR_EXIT("sigaction error");

	/* 第二次fork子进程退出,孙进程不再是会话组长,无权开启终端(与终端彻底隔离) */
	if((pid = fork()) < 0)
		ERROR_EXIT("second fork error");
	else if(pid > 0)
		exit(0);

	/* 将 0,1,2重定向到/dev/null */
	fd0 = open("/dev/null", O_RDWR);
	fd1 = dup(0);
	fd2 = dup(0);

	/* 初始化log file */
	openlog(cmd, LOG_CONS, LOG_DAEMON);
	if(fd0 != 0 || fd1 != 1 || fd2 != 2){
		syslog(LOG_ERR, "unexpected file descriptors %d %d %d", fd0, fd1, fd2);
		exit(1);
	}
}

#define MAXSLEEP 128

/**
 * 建立与服务进程的Internet套接字的逻辑连接，并在失败时以指数补
 * 偿算法进行重试
 */
int connect_retry(int domain, int type, int protocol, const struct sockaddr* addr, socklen_t alen) {
        int numsec, fd;

        for (numsec = 1; numsec <= MAXSLEEP; numsec <<= 1) {
                if ((fd = socket(domain, type, protocol)) == -1)
                        return -1;
                if (connect(fd, addr, alen) == 0)
                        return fd;
                close(fd);

                if (numsec <= MAXSLEEP / 2)
                        sleep(numsec);
        }
        return -1;
}


/**
 * 完成Internet流式套接字/数据报套接字服务进程初始化一条龙，并且调用
 * setsockopt()使得进程在主机重启之后仍然能够重新绑定该地址
 */
int init_server(int type, const struct sockaddr* addr, socklen_t alen, int qlen) {
        int fd, err = 0;
        int reuse = 1;

        if ((fd = socket(addr->sa_family, type, 0)) < 0)
                return -1;
        if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &reuse, sizeof(int)) < 0)
                goto errout;
        if (bind(fd, addr, alen) < 0)
                goto errout;
        if (type == SOCK_STREAM || type == SOCK_SEQPACKET) {
                if (listen(fd, qlen) < 0)
                        return -1;
        }
        return fd;

errout:
        err = errno;
        close(fd);
        errno = err;
        return -1;
}

#define BUFLEN 128
#define QLEN 10

#ifndef HOST_NAME_MAX
#define HOST_NAME_MAX 256
#endif

#define MAXLINE 256
#define PORT_NUM 12000

const char *getfiletype(const mode_t *mode)
{
	if(NULL == mode)
		return "mode_t has error";
	if(S_ISREG(*mode))
		return "-";
	else if(S_ISDIR(*mode))
		return "d";
	else if(S_ISCHR(*mode))
		return "c";
	else if(S_ISBLK(*mode))
		return "b";
	else if(S_ISFIFO(*mode))
		return "p";
	else if(S_ISLNK(*mode))
		return "l";
	else if(S_ISSOCK(*mode))
		return "s";
	else
		return "-";
}

const char *getfilemode(const mode_t *mode)
{
	static char buf[16];
	memset(buf, 0, sizeof(buf));
	memset(buf, '-', 9);
	if(NULL == mode)
		return "mode_t has error";
	if((*mode) & S_IRUSR)
		buf[0]='r';
	if((*mode) & S_IWUSR)
		buf[1]='w';
	if((*mode) & S_IXUSR)
		buf[2]='x';
	if((*mode) & S_IRGRP)
		buf[3]='r';
	if((*mode) & S_IWGRP)
		buf[4]='w';
	if((*mode) & S_IXGRP)
		buf[5]='x';
	if((*mode) & S_IROTH)
		buf[6]='r';
	if((*mode) & S_IWOTH)
		buf[7]='w';
	if((*mode) & S_IXOTH)
		buf[8]='x';

	return buf;
}

int set_sockaio(int sockfd) {
	int val = 1;

	if (fcntl(sockfd, F_SETOWN, getpid()) == -1)
		return -1;
	if (ioctl(sockfd, FIOASYNC, &val) == -1)
		return -1;
	return 0;
}


int clr_sockaio(int sockfd) {
	int val = 0;

	if (ioctl(sockfd, FIOASYNC, &val) == -1)
		return -1;
	return 0;
}


int main(void) {
	return 0;
}

在Linux系统中，有很多进程间通信方式，套接字（Socket）就是其中的一种。但传统的套接字的用法都是基于TCP/IP协议栈的，需要指定IP地址。如果不同主机上的两个进程进行通信，当然这样做没什么问题。
但是，如果只需要在一台机器上的两个不同进程间通信，还要用到IP地址就有点大材小用了。

其实很多人并不一定知道，对于套接字来说，还存在一种叫做Unix域套接字的类别，专门用来解决这个问题。其API的掉用方法基本上和普通TCP/IP的套接字一样，只是有些许差别。

1）socket()

最开始肯定还是要创建一个套接字：

int socket (int domain, int type, int protocol);  
API定义是一样的，不过这里的第一个参数，也就是域一定要设置成AF_UNIX或AF_LOCAL，而不是普通TCP/IP套接字的AF_INET。第二个参数表示套接字的类型，分为流套接字（SOCK_STREAM）和数据包套接字（SOCK_DGRAM）。
不同于普通的AF_INET的Socket，由于都是在本机通过内核通信，所以SOCK_STREAM和SOCK_DGRAM都是可靠的，不会丢包也不会出现发送包的次序和接收包的次序不一致的问题。
它们的区别仅仅是，SOCK_STREAM无论发送多大的数据都不会被截断，而对于SOCK_DGRAM来说，如果发送的数据超过了一个报文的最大长度，则数据会被截断。
而最后一个参数，表示协议，对于Unix域套接字来说，其一定是被设置成0。因此，一般通过下面的方式创建一个Unix域套接字：

int sockfd = socket(AF_UNIX, SOCK_STREAM, 0);  // 流式Unix域套接字  
int sockfd = socket(AF_UNIX,SOCK_DGRAM, 0);    // 数据包式套接字  
2）bind()

对于流式套接字的服务器端来说，在用socket()函数获得了新创建套接字的文件描述符之后，还要将其绑定到一个地址上去：

int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);  
在Unix域套接字中，套接字的地址是以sockaddr_un结构体来表示的，其结构如下：

struct sockaddr_un {  
    sa_family_t sun_family;  
    char sun_path[108];  
}  
结构体中的第一个字段必须要设置成“AF_UNIX”。而第二个字段，表示的是一个路径名。因此，要将一个Unix域套接字绑定到一个本地地址上，需要创建并初始化一个sockaddr_un结构体，
并将指向这个结构体的指针作为addr参数（需要类型转换）传入bind()函数，并将addrlen参数设置成这个结构体的实际大小。

这里还要特别提一下这个路径名，其实还要分为两种，一种是普通路径名，另一种是抽象路径名。

首先来说说普通路径名，这个很好理解，就是一个基本的Linux文件路径，其必须要以NULL（'\0'）结尾。
在绑定一个Unix域套接字时，会在文件系统中的相应位置上创建一个文件，且这个文件的类型被标记为“Socket”，因此这个文件无法用open()函数打开。
当不再需要这个Unix域套接字时，可以使用remove()函数或者unlink()函数将这个对应的文件删除。如果在文件系统中，已经有了一个文件和指定的路径名相同，则绑定会失败（返回错误EADDRINUSE）。
所以，一个套接字只能绑定到一个路径上，同样的，一个路径也只能被一个套接字绑定。

接下来看看什么叫抽象路径名，这其实是Linux特有的一个特性，它允许将一个Unix域套接字绑定到一个名字上，且不会在文件系统中创建这个名字的文件。
如果要创建一个抽象名字空间的绑定，必须要将sun_path字段的第一个字节设置成NULL（'\0'），而且和普通的文件系统名字空间不同的是，系统会用sun_path除第一个字节之后余下的所有字节当做抽象名字。
也就是说在解析抽象路径名时需要用到sun_path字段当中所有的字节，而不是像解析普通路径名一样，解析到第一个NULL就可以停止了。
因为不会再在文件系统中创建文件了，所以对于抽象路径名来说，就不需要担心与文件系统中已存在的文件产生名字冲突的问题了，也不需要在使用完套接字之后删除附带产生的这个文件了，当套接字被关闭之后会自动删除这个抽象名。

最后再提一下权限的问题，因为要在文件系统中创建相应的文件，对于普通路径名来说，调用bind()函数的进程必须要有路径名中目录部分的可写和可访问权限。
还有，在默认情况下，在调用bind()函数时，会给所有者、组和其他用户赋予所有的权限（即777），如果想改变这个行为，可以在bind()之后再修改创建的文件的权限和属性。

3）listen()

对于流式套接字的服务器端来说，listen()函数在TCP/IP套接字和Unix域套接字中调用方式是一样的，没有区别：

int listen(int sockfd, int backlog);  
4）accept()

对于流式套接字的服务器端来说，在调用bind()绑定完本地路径之后，还需要接收客户端的请求，这是通过调用accept()函数来实现的：

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);  
与普通的TCP/IP套接字不同，Unix域套接字不存在客户端地址的问题（都在一台机器上），因此这里的addr和addrlen参数都要设置成NULL。
在这里，不同进程向这个服务器端进程发送的流数据是在内核里面区分的，并绑定到了accept()创建的套接字中了。而数据包套接字就没有这种对应关系，所以还是要在代码中区分出来，后面会介绍。

5）connect()

对于流式套接字的客户端来说，在用socket()函数获得了新创建套接字的文件描述符之后，就可以调用connect()函数连接服务器端了：

int connect(int sockfd, struct sockaddr *addr,int addrlen);  
这个函数在TCP/IP套接字中和在Unix域套接字中调用方式基本相同，只不过和bind()函数一样，地址addr必须是以sockaddr_un结构体来表示。

6）read()和write()

对于流式套接字的服务器端来说，read()和write函数在TCP/IP套接字和Unix域套接字中调用方式是一样的，没有区别：

ssize_t read(int sockfd, void *buf, size_t length);   
ssize_t write(int sockfd, const void *buf, size_t length);  
7）recvfrom()和sendto()

对于数据包事套接字来说，在服务器端recvfrom()用来接收客户端发送的请求，而在客户端这个函数用来接收服务器端发送过来的响应：

int recvfrom(int sockfd, void *buf, int length, unsigned int flags, struct sockaddr *addr, int *addrlen);  
同时，在客户端sendto()用来向服务器端发送请求数据，而服务器端用这个函数来向客户端发送响应数据：
int sendto (int sockfd, const void *buf, int length, unsigned int flags, const struct sockaddr *addr, int addrlen);  
前面也提到了，对于数据包套接字来说，服务器端在发送响应数据时是需要知道客户端到底是哪个的，从而后面可以将相应的响应数据发送给正确的客户端。
而客户端也需要知道到底是向哪个服务器端发送数据，或者说接收到的响应数据到底来自哪个服务器端（当然，如果只保证和一个服务器端通信就没有这个问题）。

但是，按照普通的包套接字创建和连接的流程，只是在服务器端调用bind()函数绑定了一个地址，而客户端并没有地址。
这在流式套接字中没有问题，内核已经在服务器端调用accept()函数接收一个客户端连接时创建了一个新的套接字，从而将一一对应关系绑定到了这个新的套接字上了。
所以，对于包套接字来说，在客户端还需要再调用bind()函数绑定一次，人为地创建一个客户端地址，且这个客户端路径名地址显然不能和服务器端的路径名相同。

剩下的就都和普通的TCP/IP套接字相同了，只不过地址addr必须是以sockaddr_un结构体来表示罢了。

Unix域套接字

Unix域套接字用于同一台电脑上运行的进程通信。虽然TCP/IP协议的套接字很方便，但是在某些情况下需要保证更高的通信效率，所以Unix域套接字更加适合，
因为它是通过内核转发的信息，而网络协议通信需要通过网卡发送，可能效率更低些。
虽然不通过网络传输数据，但是Unix域套接字也有流和数据报两种接口。Unix域套接字就像是套接字和管道的组合，在数据传输上很像管道，但是是以套接字的形式使用。

int socketpair(int domain, int type, int protocol, int socket_vector[2]);

socketpair函数创建一对未命名的已连接的套接字在指定的域（domain）中，并且以指定的类型（type），可选指定协议（protocol），描述符将存放在socket_vector数组中。
需要注意的是，这对套接字实际上是全双工的，在很多Unix实现中，全双工的管道之类的实际上就是通过Unix域套接字实现的。
命名Unix域套接字

前面的socketpair虽然很方便，但是它创建的是未命名的套接字，也就是说不同进程无法使用，在前面的网络套接字章节中讲了套接字如何绑定一个地址和端口，但是我们也可以将其绑定到路径上，使其成为一个文件，这样就能让不同进程使用。

#include "include/apue.h"
#include <sys/socket.h>
#include <sys/un.h>

int main(int argc, char *argv[])
{
    int fd, size;
    struct sockaddr_un un;
    
    un.sun_family = AF_UNIX;
    strcpy(un.sun_path, "foo.socket");
    if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)
        err_sys("socket failed");
    size = offsetof(struct sockaddr_un, sun_path) + strlen(un.sun_path);
    if (bind(fd, (struct sockaddr *)&un, size) < 0)
        err_sys("bind failed");
    printf("UNIX domain socket bound\n");
    exit();
}

上面的例程非常简单，首先是创建一个Unix域地址，使用strcpy函数将地址复制到地址族变量，然后使用socket函数创建一个套接字，然后计算路径成员在结构体中的偏移量加上路径本身的长度，求出size变量，
然后使用bind函数将地址族结构体和套接字绑定在一起。
当我们运行程序完毕，就能在当前目录下看到一个foo.socket文件，可能就有人要问了，为什么程序结束这个文件仍然存在，套接字不是文件描述符吗，不是在程序结束的时候就回收了吗？
实际上，这是搞混了文件描述符和文件的区别，文件描述符只是0、1、2之类的数字，用于指向文件表项，实际上文件的打开是由内核维护的。
套接字也一样，当我们创建套接字的时候，并且将其绑定到具体路径，内核就会帮助我们创建一个S_IFSOCK类型的文件，但是实际上这个文件并没有什么用，它不会用于实际的写入，
不然这不就是和普通的文件一样了吗，所以这个文件纯粹就是个flag，用于标记地址，就跟通常使用的xxx.pid文件这种形式类似。

唯一连接

这小节没什么重要内容，除了三个封装函数，其中有一些内容可能是有困惑的，这里笔者将自己的理解讲一下。首先，我们先需要知道各个平台实际上实现是有差异的，例如sockaddr_un的结构体不同，在Linux和Solaris中，是如下所示：

struct sockaddr_un {
    sa_family_t sun_family;
    char sun_path[108];
};

而在FreeBSD和OSX系统中，是如下的：

struct sockaddr_un {
    unsigned char sun_len;
    sa_family_t sun_family;
    char sun_path[104];
};

先给出serv_listen函数

#include "apue.h"
#include <sys/socket.h>
#include <sys/un.h>
#include <errno.h>

#define QLEN    10

/*
 * Create a server endpoint of a connection.
 * Returns fd if all OK, <0 on error.
 */
int
serv_listen(const char *name)
{
    int                    fd, len, err, rval;
    struct sockaddr_un    un;

    if (strlen(name) >= sizeof(un.sun_path)) {
        errno = ENAMETOOLONG;
        return(-1);
    }

    /* create a UNIX domain stream socket */
    if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)
        return(-2);

    unlink(name);    /* in case it already exists */

    /* fill in socket address structure */
    memset(&un, 0, sizeof(un));
    un.sun_family = AF_UNIX;
    strcpy(un.sun_path, name);
    len = offsetof(struct sockaddr_un, sun_path) + strlen(name);

    /* bind the name to the descriptor */
    if (bind(fd, (struct sockaddr *)&un, len) < 0) {
        rval = -3;
        goto errout;
    }

    if (listen(fd, QLEN) < 0) {    /* tell kernel we're a server */
        rval = -4;
        goto errout;
    }
    return(fd);

errout:
    err = errno;
    close(fd);
    errno = err;
    return(rval);
}

首先是创建一个Unix域套接字，如果文件已经存在则删除原先文件，然后构造sockaddr_un结构体，然后使用bind函数将地址和套接字绑定，系统自动生成套接字文件，然后使用listen函数侦听套接字。这里基本没什么需要讲解的。
然后是serv_accept函数

#include "apue.h"
#include <sys/socket.h>
#include <sys/un.h>
#include <time.h>
#include <errno.h>

#define    STALE    30    /* client's name can't be older than this (sec) */

/*
 * Wait for a client connection to arrive, and accept it.
 * We also obtain the client's user ID from the pathname
 * that it must bind before calling us.
 * Returns new fd if all OK, <0 on error
 */
int
serv_accept(int listenfd, uid_t *uidptr)
{
    int                    clifd, err, rval;
    socklen_t            len;
    time_t                staletime;
    struct sockaddr_un    un;
    struct stat            statbuf;
    char                *name;

    /* allocate enough space for longest name plus terminating null */
    if ((name = malloc(128)) == NULL)
        return(-1);
    len = sizeof(un);
    if ((clifd = accept(listenfd, (struct sockaddr *)&un, &len)) < 0) {
        free(name);
        return(-2);        /* often errno=EINTR, if signal caught */
    }

    /* obtain the client's uid from its calling address */
    len -= offsetof(struct sockaddr_un, sun_path); /* len of pathname */
    memcpy(name, un.sun_path, len);
    name[len] = 0;            /* null terminate */
    if (stat(name, &statbuf) < 0) {
        rval = -3;
        goto errout;
    }

#ifdef    S_ISSOCK    /* not defined for SVR4 */
    if (S_ISSOCK(statbuf.st_mode) == 0) {
        rval = -4;        /* not a socket */
        goto errout;
    }
#endif

    if ((statbuf.st_mode & (S_IRWXG | S_IRWXO)) ||
        (statbuf.st_mode & S_IRWXU) != S_IRWXU) {
          rval = -5;    /* is not rwx------ */
          goto errout;
    }

    staletime = time(NULL) - STALE;
    if (statbuf.st_atime < staletime ||
        statbuf.st_ctime < staletime ||
        statbuf.st_mtime < staletime) {
          rval = -6;    /* i-node is too old */
          goto errout;
    }

    if (uidptr != NULL)
        *uidptr = statbuf.st_uid;    /* return uid of caller */
    unlink(name);        /* we're done with pathname now */
    free(name);
    return(clifd);

errout:
    err = errno;
    close(clifd);
    free(name);
    errno = err;
    return(rval);
}

首先是使用accept函数阻塞等待客户进程连接。当accept返回的时候，返回的是新的套接字描述符，也就是存在连接的套接字，并且从第二个参数得到套接字的路径名，接着复制路径名，最后调用stat函数检查路径名。
其中len -= offsetof(struct sockaddr_un, sun_path);可能有些人不是很明白，这里实际上用了点编码技巧，实际上就是结构体总长度减去sun_path成员的内存偏移量，最终就是sun_path的长度。
还有，accept第二个参数实际上和bind是不一样的，因为这个套接字是已经连接的套接字，所以会包含客户进程ID的名字。

#include "apue.h"
#include <sys/socket.h>
#include <sys/un.h>
#include <errno.h>

#define    CLI_PATH    "/var/tmp/"
#define    CLI_PERM    S_IRWXU            /* rwx for user only */

/*
 * Create a client endpoint and connect to a server.
 * Returns fd if all OK, <0 on error.
 */
int
cli_conn(const char *name)
{
    int                    fd, len, err, rval;
    struct sockaddr_un    un, sun;
    int                    do_unlink = 0;

    if (strlen(name) >= sizeof(un.sun_path)) {
        errno = ENAMETOOLONG;
        return(-1);
    }

    /* create a UNIX domain stream socket */
    if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)
        return(-1);

    /* fill socket address structure with our address */
    memset(&un, 0, sizeof(un));
    un.sun_family = AF_UNIX;
    sprintf(un.sun_path, "%s%05ld", CLI_PATH, (long)getpid());
    printf("file is %s\n", un.sun_path);
    len = offsetof(struct sockaddr_un, sun_path) + strlen(un.sun_path);

    unlink(un.sun_path);        /* in case it already exists */
    if (bind(fd, (struct sockaddr *)&un, len) < 0) {
        rval = -2;
        goto errout;
    }
    if (chmod(un.sun_path, CLI_PERM) < 0) {
        rval = -3;
        do_unlink = 1;
        goto errout;
    }

    /* fill socket address structure with server's address */
    memset(&sun, 0, sizeof(sun));
    sun.sun_family = AF_UNIX;
    strcpy(sun.sun_path, name);
    len = offsetof(struct sockaddr_un, sun_path) + strlen(name);
    if (connect(fd, (struct sockaddr *)&sun, len) < 0) {
        rval = -4;
        do_unlink = 1;
        goto errout;
    }
    return(fd);

errout:
    err = errno;
    close(fd);
    if (do_unlink)
        unlink(un.sun_path);
    errno = err;
    return(rval);
}

首先是创建一个套接字，然后用客户端进程ID附加到路径上，形成自己的套接字路径，并且将这个套接字绑定在地址上，也就是系统会使用这个地址生成客户端的socket文件，
可能有人要奇怪了，为什么不直接使用connect而是要bind地址，因为如果不绑定地址，我们就无法区分连接是属于哪个客户端进程的，也就是类似于网络上客户端特意绑定一个端口连接服务端。

