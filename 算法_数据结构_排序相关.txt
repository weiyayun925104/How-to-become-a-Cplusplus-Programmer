bubble_sort.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
void sort_item_vector_bubble(vector_t *itemVec, int left, int right)
{
	int i;int j;int flag;sort_item_t *one_item;sort_item_t *two_item;if(left>=right){return;}
	for(i = right;i > left;i--)
	{
		flag = 0;
		for(j = left;j < i;j++)
		{
			two_item = itemVec->mem[j];one_item = itemVec->mem[j+1];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				itemVec->mem[j+1] = two_item;itemVec->mem[j] = one_item;
				flag = 1;
			}
		}
		if(flag == 0){break;}
	}
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_bubble(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;sort_item_t *one_item;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_bubble(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

cocktail_sort.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
void sort_item_vector_cocktail(vector_t *itemVec, int left, int right)
{
	int start;int end;int i;int flag;sort_item_t *one_item;sort_item_t *two_item;if(left>=right){return;}
	start = left;end = right;
	while(start < end)
	{
		if(start < end)
		{
			flag = 0;
			for(i = start;i < end;i++)
			{
				two_item = itemVec->mem[i];one_item = itemVec->mem[i+1];
				if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
				{
					itemVec->mem[i+1] = two_item;itemVec->mem[i] = one_item;
					flag = 1;
				}
			}
			end--;
			if(flag == 0){break;}
		}
		if(start < end)
		{
			flag = 0;
			for(i = end;i > start;i--)
			{
				two_item = itemVec->mem[i-1];one_item = itemVec->mem[i];
				if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
				{
					itemVec->mem[i] = two_item;itemVec->mem[i-1] = one_item;
					flag = 1;
				}
			}
			start++;
			if(flag == 0){break;}
		}
	}
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_cocktail(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;sort_item_t *one_item;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_cocktail(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

insert_sort.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
void sort_item_vector_insert(vector_t *itemVec, int left, int right)
{
	int i;int j;sort_item_t *one_item;sort_item_t *two_item;if(left>=right){return;}
	for(i = left+1;i <= right;i++)
	{
		two_item = itemVec->mem[i-1];one_item = itemVec->mem[i];
		if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
		{
			j = (i-1);
			do{itemVec->mem[j+1] = itemVec->mem[j];j -= 1;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
			while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
			if((j+1)!=i){itemVec->mem[j+1] = one_item;}
		}
	}
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_insert(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;sort_item_t *one_item;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_insert(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

shell_sort.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
int binary_search_last_lower_equal(int *array,int count,int value)
{
	int begin;int mid;int end;int last;if(count<=0){return -1;}begin = 0;end = count-1;last = -1;
	while(begin<=end){mid = (begin+(end-begin)/2);if(array[mid]<=value){last = mid;begin = mid +1;}else{end = mid -1;}}
	return last;
}
void sort_item_vector_shell(vector_t *itemVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;sort_item_t *one_item;sort_item_t *two_item;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_item = itemVec->mem[i-two];one_item = itemVec->mem[i];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				j = (i-two);
				do{itemVec->mem[j+two] = itemVec->mem[j];j -= two;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
				while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
				if((j+two)!=i){itemVec->mem[j+two] = one_item;}
			}
		}
	}
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_shell(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;sort_item_t *one_item;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_shell(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

select_sort.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
void sort_item_vector_select(vector_t *itemVec, int left, int right)
{
	int i;int j;int max;sort_item_t *max_item;sort_item_t *one_item;sort_item_t *two_item;if(left>=right){return;}
	for(i = right;i > left;i--)
	{
		max = i;
		for(j = left;j < i;j++)
		{
			two_item = itemVec->mem[j];max_item = itemVec->mem[max];
			if(compareItem(two_item->key, two_item->key_len, max_item->key, max_item->key_len) > 0)
			{
				max = j;
			}
		}
		if(max != i)
		{
			one_item = itemVec->mem[i];max_item = itemVec->mem[max];
			itemVec->mem[i] = max_item;itemVec->mem[max] = one_item;
		}
	}
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_select(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;sort_item_t *one_item;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_select(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

heapsort.h
#ifndef HEAPSORT_H
#define HEAPSORT_H
namespace IntroductionToAlgorithm
{
    namespace SortAlgorithm
    {
        template<typename Iterator,typename CompareType=std::less<typename std::iterator_traits<Iterator>::value_type>>
        class Sort_Heap
        {
        public:
            typedef typename std::iterator_traits<Iterator>::value_type T;

            void operator () (const Iterator from, std::size_t size,CompareType compare=CompareType())
            {
                _from=from;
                _size=size;
                _setupHeap(compare);
                while(_size>1)
                {
                    std::swap(*_from,*(_from+_size-1));
                    _size--;
                    _heapify_down(0,compare);
                }
            }

        protected:
            void _setupHeap(CompareType compare=CompareType())
            {
                if(_size<=1)
                    return;
                int index=0;
                while(index < _size)
                {
                    _heapify_up(index,compare);
                    index++;
                }
            }

            void _heapify_up(std::size_t elementIndex,CompareType compare=CompareType())
            {
                if(elementIndex == 0)
                    return;

                bool parent_valid=true;
                auto parentIndex=_parentIndex(elementIndex,parent_valid);

                if(parent_valid)
                {
                    if( compare(*(_from+parentIndex),*(_from+elementIndex)) )
                    {
                        std::swap(*(_from+parentIndex),*(_from+elementIndex));
                        _heapify_up(parentIndex,compare);
                    }
                }
            }

            void _heapify_down(std::size_t elementIndex,CompareType compare=CompareType())
            {
                if(elementIndex>=_size)
                    return;
                auto maxIndex=elementIndex;
                bool left_valid=true;
                bool right_valid=true;
                auto leftIndex=_lchildIndex(elementIndex,left_valid);
                auto rightIndex=_rchildIndex(elementIndex,right_valid);

                if(left_valid)
                {
                    if( compare(*(_from+maxIndex),*(_from+leftIndex)) )
                        maxIndex=leftIndex;
                }
                if(right_valid)
                {
                    if( compare(*(_from+maxIndex),*(_from+rightIndex)) )
                        maxIndex=rightIndex;
                }
                if(maxIndex!=elementIndex)
                {
                    std::swap(*(_from+elementIndex),*(_from+maxIndex));
                    _heapify_down(maxIndex,compare);
                }
            }

            std::size_t _parentIndex(std::size_t elementIndex,bool& valid)
            {
                if(elementIndex >=_size || elementIndex == 0)
                {
                    valid=false; //
                    return 0;
                }
                valid=true; //
                return (elementIndex-1)/2;
            }

            std::size_t _lchildIndex(std::size_t elementIndex,bool& valid)
            {
                if( (elementIndex * 2)+1 >= _size )
                {
                    valid=false;//
                    return 0;
                }
                valid=true;
                return (elementIndex * 2)+1;
            }

            std::size_t _rchildIndex(std::size_t elementIndex,bool& valid)
            {
                if( (elementIndex * 2)+2 >= _size )
                {
                    valid=false;//
                    return 0;
                }
                valid=true;
                return (elementIndex * 2)+2;
            }
        private:
            Iterator _from;
            std::size_t _size;
        };

    }
}
#endif

heap_sort.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
int sort_get_parent_index(sort_t *sort, int index, int *result_index)
{
	int one_index;if(sort->itemVec.count <= 0){return -1;}if(index < 0 || index >= sort->itemVec.count){return -1;}
	if(index == 0){return 0;}
	one_index = ((index-1)/4);
	if(one_index < 0){return 0;}*result_index = one_index;return 1;
}
int sort_get_child_index_range(sort_t *sort, int index, int *result_begin_index, int *result_end_index)
{
	int begin_index;int end_index;if(sort->itemVec.count <= 0){return -1;}if(index < 0 || index >= sort->itemVec.count){return -1;}
	begin_index = ((4*index)+1);end_index = ((4*index)+4);
	if(begin_index >= sort->itemVec.count){return 0;}if(end_index >= sort->itemVec.count){end_index = (sort->itemVec.count-1);}
	*result_begin_index = begin_index;*result_end_index = end_index;return 1;
}
int sort_get_max_child_index(sort_t *sort, int begin_index, int end_index, int *result_index)
{
	int one_index;sort_item_t *one_item;int max_index;sort_item_t *max_item;if(sort->itemVec.count <= 0){return -1;}
	if(begin_index < 0 || begin_index >= sort->itemVec.count){return -1;}if(end_index < 0 || end_index >= sort->itemVec.count){return -1;}
	if(begin_index > end_index){return -1;}max_index = begin_index;
	for(one_index = (begin_index+1);one_index <= end_index;one_index++)
	{
		one_item = sort->itemVec.mem[one_index];max_item = sort->itemVec.mem[max_index];
		if(compareItem(max_item->key, max_item->key_len, one_item->key, one_item->key_len) < 0)
		{
			max_index = one_index;
		}
	}
	*result_index = max_index;return 1;
}
int sort_up(sort_t *sort, int index)
{
	int one_index;int parent_index;sort_item_t *one_item;sort_item_t *parent_item;if(sort->itemVec.count <= 0){return -1;}
	if(index < 0 || index >= sort->itemVec.count){return -1;}one_index = index;
	while(sort_get_parent_index(sort, one_index, &parent_index) == 1)
	{
		one_item = sort->itemVec.mem[one_index];parent_item = sort->itemVec.mem[parent_index];
		if(compareItem(parent_item->key, parent_item->key_len, one_item->key, one_item->key_len) >= 0){return 1;}
		sort->itemVec.mem[one_index] = parent_item;sort->itemVec.mem[parent_index] = one_item;one_index = parent_index;
	}
	return 1;
}
int sort_down(sort_t *sort, int index)
{
	int begin_index;int end_index;int one_index;int child_index;sort_item_t *one_item;sort_item_t *child_item;
	if(sort->itemVec.count <= 0){return -1;}if(index < 0 || index >= sort->itemVec.count){return -1;}one_index = index;
	while(sort_get_child_index_range(sort, one_index, &begin_index, &end_index) == 1)
	{
		sort_get_max_child_index(sort, begin_index, end_index, &child_index);
		one_item = sort->itemVec.mem[one_index];child_item = sort->itemVec.mem[child_index];
		if(compareItem(one_item->key, one_item->key_len, child_item->key, child_item->key_len) >= 0){return 1;}
		sort->itemVec.mem[one_index] = child_item;sort->itemVec.mem[child_index] = one_item;one_index = child_index;
	}
	return 1;
}
int sort_build(sort_t *sort)
{
	int i;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		sort_up(sort, i);
	}
	return 1;
}
int sort_remove_max(sort_t *sort, sort_item_t **result_item)
{
	int one_index;sort_item_t *one_item;sort_item_t *max_item;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	max_item = sort->itemVec.mem[0];*result_item = max_item;
	if(sort->itemVec.count == 1)
	{
		sort->itemVec.mem[0] = NULL;sort->itemVec.count--;
	}
	else
	{
		one_index = (sort->itemVec.count-1);one_item = sort->itemVec.mem[one_index];
		sort->itemVec.mem[0] = one_item;sort->itemVec.mem[one_index] = NULL;sort->itemVec.count--;
		sort_down(sort, 0);
	}
	return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	sort_item_t *result_item;sort_t one_sort;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&(one_sort.itemVec));if(vector_reserve(&(one_sort.itemVec), sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &(one_sort.itemVec));sort_build(&one_sort);
	while(one_sort.itemVec.count > 0)
	{
		result_item = NULL;sort_remove_max(&one_sort, &result_item);if(result_item != NULL){vector_add(all_item_vec, result_item);}
	}
	vector_free(&(one_sort.itemVec));return 1;
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	sort_item_t *result_item;sort_t one_sort;int one_index;int one_count;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&(one_sort.itemVec));if(vector_reserve(&(one_sort.itemVec), sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &(one_sort.itemVec));sort_build(&one_sort);
	one_index = (one_sort.itemVec.count-1);one_count = one_sort.itemVec.count;
	while(one_sort.itemVec.count > 0)
	{
		result_item = NULL;sort_remove_max(&one_sort, &result_item);
		if(result_item != NULL){one_sort.itemVec.mem[one_index] = result_item;one_index--;}
	}
	one_sort.itemVec.count = one_count;vector_add_vec_two(&(one_sort.itemVec), all_item_vec);
	vector_free(&(one_sort.itemVec));return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

mergesort.h
#ifndef MERGESORT_H
#define MERGESORT_H
#include<vector>
namespace IntroductionToAlgorithm
{
    namespace SortAlgorithm
    {
        template<typename Iterator,typename CompareType=std::less<typename std::iterator_traits<Iterator>::value_type>>
        void merge(const Iterator begin,const Iterator end,const Iterator middle,CompareType compare=CompareType())
        {
            typedef typename std::iterator_traits<Iterator>::value_type T;// 
            if(std::distance(begin,middle)<=0||std::distance(middle,end)<=0) return;
            std::vector<T> result(std::distance(begin,end)); //
            auto current=result.begin();
            auto left_current=begin; //
            auto right_current=middle;//
            while(left_current!=middle && right_current!=end)
            {
                if(compare(*left_current,*right_current))
                {
                    *current++=*left_current++;//

                }else
                {
                    *current++=*right_current++;//
                }
            }
            if(left_current==middle&&right_current!=end) //
            {
                std::copy(right_current,end,current);
            }
            if(right_current==end&&left_current!=middle) //
            {
                std::copy(left_current,middle,current);
            }
            std::copy(result.begin(),result.end(),begin); //
        }

        template<typename Iterator,typename CompareType=std::less<typename std::iterator_traits<Iterator>::value_type>>
        void merge_sort(const Iterator begin,const Iterator end,CompareType compare=CompareType())
        {
            auto size=std::distance(begin,end);
            if(size>1)
            {
                Iterator middle=begin+size/2;
                merge_sort(begin,middle,compare);
                merge_sort(middle,end,compare);
                merge(begin,end,middle,compare);
            }
        }

    }
}
#endif

merge_sort.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;vector_t mergeVec;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));vector_init(&(sort->mergeVec));return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));vector_free(&(sort->mergeVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
void sort_item_vector_step(sort_t *sort, int start, int end, int step)
{
	int i;int j;int one_index;int one_start;int one_end;sort_item_t *one_item;int two_index;int two_start;int two_end;sort_item_t *two_item;
	sort->mergeVec.count = 0;one_start = start;one_end = (start+(step-1));two_start = (start+step);two_end = end;
	one_index = one_start;two_index = two_start;
	while(one_index <= one_end && two_index <= two_end)
	{
		one_item = sort->itemVec.mem[one_index];two_item = sort->itemVec.mem[two_index];
		if(compareItem(one_item->key, one_item->key_len, two_item->key, two_item->key_len) <= 0)
		{
			vector_add(&(sort->mergeVec), one_item);one_index++;
		}
		else
		{
			vector_add(&(sort->mergeVec), two_item);two_index++;
		}
	}
	if(one_index > one_end)
	{
		while(two_index <= two_end)
		{
			two_item = sort->itemVec.mem[two_index];
			vector_add(&(sort->mergeVec), two_item);two_index++;
		}
	}
	else
	{
		while(one_index <= one_end)
		{
			one_item = sort->itemVec.mem[one_index];
			vector_add(&(sort->mergeVec), one_item);one_index++;
		}
	}
	i = 0;j = start;
	while(i < sort->mergeVec.count)
	{
		one_item = sort->mergeVec.mem[i];sort->mergeVec.mem[i] = NULL;
		sort->itemVec.mem[j] = one_item;
		i++;j++;
	}
	sort->mergeVec.count = 0;
}
void sort_item_vector_merge(sort_t *sort, int left, int right)
{
	int start;int end;int step;int one_count;if(left>=right){return;}
	one_count = (right-left+1);if(vector_reserve(&(sort->mergeVec), one_count) == 0){return ;}
	step = 1;
	while((left+step) <= right)
	{
		start = left;
		while((start+step) <= right)
		{
			end = (start+((step*2)-1));if(end > right){end = right;}
			sort_item_vector_step(sort, start, end, step);
			start = (end+1);
		}
		step *= 2;
	}
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	sort_t one_sort;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&(one_sort.itemVec));vector_init(&(one_sort.mergeVec));if(vector_reserve(&(one_sort.itemVec), sort->itemVec.count) == 0){return 0;}
	if(vector_reserve(&(one_sort.mergeVec), sort->itemVec.count) == 0){vector_free(&(one_sort.itemVec));return 0;}
	vector_copy_vec_two(&(sort->itemVec), &(one_sort.itemVec));sort_item_vector_merge(&one_sort, 0, (one_sort.itemVec.count-1));
	vector_add_vec_two(&(one_sort.itemVec), all_item_vec);
	vector_free(&(one_sort.itemVec));vector_free(&(one_sort.mergeVec));return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	int i;sort_item_t *one_item;sort_t one_sort;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&(one_sort.itemVec));vector_init(&(one_sort.mergeVec));if(vector_reserve(&(one_sort.itemVec), sort->itemVec.count) == 0){return 0;}
	if(vector_reserve(&(one_sort.mergeVec), sort->itemVec.count) == 0){vector_free(&(one_sort.itemVec));return 0;}
	vector_copy_vec_two(&(sort->itemVec), &(one_sort.itemVec));sort_item_vector_merge(&one_sort, 0, (one_sort.itemVec.count-1));
	for(i = (one_sort.itemVec.count-1);i >= 0;i--)
	{
		one_item = one_sort.itemVec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&(one_sort.itemVec));vector_free(&(one_sort.mergeVec));return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

quicksort.h
#ifndef QUICKSORT_H
#define QUICKSORT_H
#include<assert.h>
namespace IntroductionToAlgorithm
{
    namespace SortAlgorithm
    {
        template<typename Iterator,typename CompareType=std::less<typename std::iterator_traits<Iterator>::value_type>>
        Iterator partition(const Iterator begin,const Iterator end,const Iterator partition_iter,CompareType compare=CompareType())
        {
            auto size=std::distance(begin,end);
            assert(size>=0);
            assert(std::distance(begin,partition_iter)>=0 &&std::distance(partition_iter,end)>0);
            if(size==0) return end;
            if(size==1) return begin;

            auto smaller_next=begin;
            auto current=begin;  //
            std::swap(*partition_iter,*(end-1));//partition
            while(current!=end-1)
            {
                if( compare(*current,*(end-1)) )
                {
                    std::swap(*smaller_next,*current);
                    smaller_next++;
                }
                current++;
            }
            std::swap(*smaller_next,*(end-1));//partition
            return smaller_next;
        }

        template<typename Iterator,typename CompareType=std::less<typename std::iterator_traits<Iterator>::value_type>>
        void quick_sort(const Iterator begin,const Iterator end,CompareType compare=CompareType())
        {
            auto size=std::distance(begin,end);
            if(size<=1)
                return;
            auto partitioned_iter=partition(begin,end,end-1,compare);
            quick_sort(begin,partitioned_iter,compare);
            quick_sort(partitioned_iter+1,end,compare);
        }

    }
}
#endif

quick_sort.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
void sort_item_vector_quick(vector_t *itemVec, int left, int right)
{
	int one_index;int two_index;sort_item_t *one_item;sort_item_t *two_item;sort_item_t *pivot_item;if(left>=right){return;}
	one_index = left;two_index = right;pivot_item = itemVec->mem[left];
	while(one_index < two_index)
	{
		while(one_index < two_index)
		{
			two_item = itemVec->mem[two_index];
			if(compareItem(two_item->key, two_item->key_len, pivot_item->key, pivot_item->key_len) > 0)
			{
				two_index--;
			}
			else
			{
				itemVec->mem[one_index] = two_item;one_index++;
				break;
			}
		}
		while(one_index < two_index)
		{
			one_item = itemVec->mem[one_index];
			if(compareItem(one_item->key, one_item->key_len, pivot_item->key, pivot_item->key_len) <= 0)
			{
				one_index++;
			}
			else
			{
				itemVec->mem[two_index] = one_item;two_index--;
				break;
			}
		}
	}
	itemVec->mem[one_index] = pivot_item;
	sort_item_vector_quick(itemVec, left, (one_index-1));
	sort_item_vector_quick(itemVec, (one_index+1), right);
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_quick(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;sort_item_t *one_item;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_quick(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

quick_sort_two_pivot.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
int binary_search_last_lower_equal(int *array,int count,int value)
{
	int begin;int mid;int end;int last;if(count<=0){return -1;}begin = 0;end = count-1;last = -1;
	while(begin<=end){mid = (begin+(end-begin)/2);if(array[mid]<=value){last = mid;begin = mid +1;}else{end = mid -1;}}
	return last;
}
void sort_item_vector_shell(vector_t *itemVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;sort_item_t *one_item;sort_item_t *two_item;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_item = itemVec->mem[i-two];one_item = itemVec->mem[i];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				j = (i-two);
				do{itemVec->mem[j+two] = itemVec->mem[j];j -= two;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
				while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
				if((j+two)!=i){itemVec->mem[j+two] = one_item;}
			}
		}
	}
}
void sort_item_vector_prepare(vector_t *itemVec, int left, int right, int *result_equal)
{
	int i;int one_index;sort_item_t *one_item;sort_item_t *two_item;sort_item_t *temp_item;int one_result;int temp_result;
	*result_equal = 0;if(left>=right){return;}if((right-left+1) < 16){return;}
	one_index = (left+(right-left)/3);one_item = itemVec->mem[one_index];itemVec->mem[one_index] = itemVec->mem[left];itemVec->mem[left] = one_item;
	one_index = (right-(right-left)/3);one_item = itemVec->mem[one_index];itemVec->mem[one_index] = itemVec->mem[right];itemVec->mem[right] = one_item;
	one_item = itemVec->mem[left];two_item = itemVec->mem[right];
	one_result = compareItem(one_item->key, one_item->key_len, two_item->key, two_item->key_len);
	if(one_result < 0){return;}
	else if(one_result > 0){itemVec->mem[left] = two_item;itemVec->mem[right] = one_item;return;}
	else
	{
		i = (left + 1);
		while(i < right)
		{
			temp_item = itemVec->mem[i];temp_result = compareItem(temp_item->key, temp_item->key_len, two_item->key, two_item->key_len);
			if(temp_result < 0)
			{
				itemVec->mem[left] = temp_item;itemVec->mem[i] = one_item;
				break;
			}
			else if(temp_result > 0)
			{
				itemVec->mem[right] = temp_item;itemVec->mem[i] = two_item;
				break;
			}
			else{i++;}
		}
		if(i == right){*result_equal = 1;}
		return;
	}
}
void sort_item_vector_quick(vector_t *itemVec, int left, int right)
{
	int i;int result_equal;int one_result;sort_item_t *one_item;sort_item_t *temp_item;sort_item_t *left_pivot_item;sort_item_t *right_pivot_item;
	int lower_index;int lower_equal_index;int upper_index;int upper_equal_index;if(left>=right){return;}
	if((right-left+1) < 16){sort_item_vector_shell(itemVec, left, right);return;}
	result_equal = 0;sort_item_vector_prepare(itemVec, left, right, &result_equal);if(result_equal == 1){return;}
	left_pivot_item = itemVec->mem[left];right_pivot_item = itemVec->mem[right];
	i = (left+1);lower_index = (left+1);lower_equal_index = (left+1);upper_index = (right-1);upper_equal_index = (right-1);
	while(i <= upper_equal_index)
	{
		one_item = itemVec->mem[i];
		one_result = compareItem(one_item->key, one_item->key_len, left_pivot_item->key, left_pivot_item->key_len);
		if(one_result <= 0)
		{
			if(i != lower_equal_index)
			{
				temp_item = itemVec->mem[i];itemVec->mem[i] = itemVec->mem[lower_equal_index];itemVec->mem[lower_equal_index] = temp_item;
			}
			if(one_result < 0)
			{
				if(lower_equal_index != lower_index)
				{
					temp_item = itemVec->mem[lower_equal_index];itemVec->mem[lower_equal_index] = itemVec->mem[lower_index];itemVec->mem[lower_index] = temp_item;
				}
				lower_index++;
			}
			lower_equal_index++;i++;
		}
		else
		{
			one_result = compareItem(one_item->key, one_item->key_len, right_pivot_item->key, right_pivot_item->key_len);
			if(one_result >= 0)
			{
				if(i != upper_equal_index)
				{
					temp_item = itemVec->mem[i];itemVec->mem[i] = itemVec->mem[upper_equal_index];itemVec->mem[upper_equal_index] = temp_item;
				}
				if(one_result > 0)
				{
					if(upper_equal_index != upper_index)
					{
						temp_item = itemVec->mem[upper_equal_index];itemVec->mem[upper_equal_index] = itemVec->mem[upper_index];itemVec->mem[upper_index] = temp_item;
					}
					upper_index--;
				}
				upper_equal_index--;
			}
			else
			{
				i++;
			}
		}
	}
	lower_index--;lower_equal_index--;upper_index++;upper_equal_index++;
	if(lower_index != left)
	{
		temp_item = itemVec->mem[lower_index];itemVec->mem[lower_index] = itemVec->mem[left];itemVec->mem[left] = temp_item;
	}
	if(upper_index != right)
	{
		temp_item = itemVec->mem[upper_index];itemVec->mem[upper_index] = itemVec->mem[right];itemVec->mem[right] = temp_item;
	}
	sort_item_vector_quick(itemVec, left, (lower_index-1));
	sort_item_vector_quick(itemVec, (lower_equal_index+1), (upper_equal_index-1));
	sort_item_vector_quick(itemVec, (upper_index+1), right);
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	vector_t one_item_vec;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_quick(&one_item_vec, 0, (one_item_vec.count-1));
	vector_add_vec_two(&one_item_vec, all_item_vec);
	vector_free(&one_item_vec);return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	int i;vector_t one_item_vec;sort_item_t *one_item;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&one_item_vec);if(vector_reserve(&one_item_vec, sort->itemVec.count) == 0){return 0;}
	vector_copy_vec_two(&(sort->itemVec), &one_item_vec);sort_item_vector_quick(&one_item_vec, 0, (one_item_vec.count-1));
	for(i = (one_item_vec.count-1);i >= 0;i--)
	{
		one_item = one_item_vec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&one_item_vec);return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}

merge_sort_tim.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {int start;int length;} sort_run_t;
typedef struct {int count;int max;sort_run_t *mem;} sort_run_vector_t;
typedef struct {byte_t *key;word_t key_len;void *value;} sort_item_t;
typedef struct {vector_t itemVec;vector_t mergeVec;sort_run_vector_t runVec;int min_run;int start_index;} sort_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
void sort_run_vector_init(sort_run_vector_t *run_vec)
{
	run_vec->count = 0;run_vec->max = 0;run_vec->mem = NULL;
}
void sort_run_vector_free(sort_run_vector_t *run_vec)
{
	if(run_vec->mem != NULL){free(run_vec->mem);run_vec->mem = NULL;}sort_run_vector_init(run_vec);
}
int sort_run_vector_get(sort_run_vector_t *run_vec, int index, sort_run_t *one_run)
{
	if(index < 0 || index >= run_vec->count){return 0;}*one_run = run_vec->mem[index];return 1;
}
int sort_run_vector_set(sort_run_vector_t *run_vec, int index, sort_run_t *one_run)
{
	if(index < 0 || index >= run_vec->count){return 0;}run_vec->mem[index] = *one_run;return 1;
}
int sort_run_vector_reserve(sort_run_vector_t *run_vec, int size)
{
	int max;void *temp;
	if(size <= run_vec->max){return 1;}
	else if(run_vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(run_vec->max > 0 && size > run_vec->max){max = run_vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(run_vec->mem, (max*sizeof(sort_run_t)));if(temp == NULL){return 0;}
	run_vec->mem = temp;run_vec->max = max;return 1;
}
int sort_run_vector_add(sort_run_vector_t *run_vec, sort_run_t *one_run)
{
	if(sort_run_vector_reserve(run_vec, (run_vec->count+1)) == 1)
	{
		run_vec->mem[run_vec->count] = *one_run;run_vec->count++;return 1;
	}
	else{return 0;}
}
int sort_run_vector_insert(sort_run_vector_t *run_vec, int index, sort_run_t *one_run)
{
	int i;if(index < 0 || index > run_vec->count){return 0;}
	if(sort_run_vector_reserve(run_vec, (run_vec->count+1)) == 1)
	{
		if(index == run_vec->count){run_vec->mem[run_vec->count] = *one_run;run_vec->count++;return 1;}
		else
		{
			for(i = run_vec->count;i > index;i--){run_vec->mem[i] = run_vec->mem[i-1];}run_vec->mem[index] = *one_run;run_vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int sort_run_vector_delete(sort_run_vector_t *run_vec, int index, sort_run_t *one_run)
{
	int i;sort_run_t temp_run;temp_run.start = 0;temp_run.length = 0;
	if(index < 0 || index >= run_vec->count){return 0;}if(one_run != NULL){*one_run = run_vec->mem[index];}
	if(index < run_vec->count-1){for(i = index; i < run_vec->count-1; i++){run_vec->mem[i] = run_vec->mem[i+1];}}
	run_vec->mem[run_vec->count-1] = temp_run;run_vec->count--;return 1;
}
int sort_run_vector_delete_min_max(sort_run_vector_t *run_vec, int min_index, int max_index)
{
	int i;int j;int count;sort_run_t temp_run;temp_run.start = 0;temp_run.length = 0;
	if(min_index < 0 || min_index >= run_vec->count){return 0;}if(max_index < 0 || max_index >= run_vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (run_vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < run_vec->count){run_vec->mem[j] = run_vec->mem[i];i++;j++;}
		for(i = j;i < run_vec->count;i++){run_vec->mem[i] = temp_run;}
	}
	else{for(i = min_index;i < run_vec->count;i++){run_vec->mem[i] = temp_run;}}
	run_vec->count -= count;return 1;
}
void sort_run_vector_set_run_vec(sort_run_vector_t *a, sort_run_vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int sort_item_init(sort_item_t *item){item->key = NULL;item->key_len = 0;item->value = NULL;return 1;}
sort_item_t * sort_item_alloc()
{
  size_t size;sort_item_t *item;size = sizeof(sort_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  sort_item_init(item);return item;
}
void sort_item_free(sort_item_t *item){if(item != NULL){sort_item_init(item);free(item);}}
sort_t * sort_alloc()
{
	size_t size;sort_t *sort;size = sizeof(sort_t);sort = NULL;sort = malloc(size);if(sort == NULL){return NULL;}
	vector_init(&(sort->itemVec));vector_init(&(sort->mergeVec));sort_run_vector_init(&(sort->runVec));
	sort->min_run = 0;sort->start_index = 0;
	return sort;
}
void sort_destroy(sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_free(item);}sort->itemVec.mem[i] = NULL;
	}
	vector_free(&(sort->itemVec));vector_free(&(sort->mergeVec));sort_run_vector_free(&(sort->runVec));free(sort);
}
int sort_insert(sort_t *sort, byte_t *key, word_t key_len, void *value)
{
	sort_item_t *one_item;if(sort == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	one_item = sort_item_alloc();if(one_item == NULL){return 0;}one_item->key = key;one_item->key_len = key_len;one_item->value = value;
	vector_add(&(sort->itemVec), one_item);return 1;
}
int binary_search_last_lower_equal(int *array,int count,int value)
{
	int begin;int mid;int end;int last;if(count<=0){return -1;}begin = 0;end = count-1;last = -1;
	while(begin<=end){mid = (begin+(end-begin)/2);if(array[mid]<=value){last = mid;begin = mid +1;}else{end = mid -1;}}
	return last;
}
void sort_item_vector_shell(vector_t *itemVec, int left, int right)
{
	static int arrIncre[16]={1, 4, 10, 23, 57, 132, 301, 701, 1750, 4376, 10941, 27353, 68383, 170958, 427396, 1068491};int nIncre;
	int i;int j;int k;int one;int two;sort_item_t *one_item;sort_item_t *two_item;if(left>=right){return;}
	one = (right-left+1)/2;nIncre = binary_search_last_lower_equal(arrIncre,16,one);
	for(k = nIncre;k >= 0;k--)
	{
		two = arrIncre[k];
		for(i = left+two;i <= right;i++)
		{
			two_item = itemVec->mem[i-two];one_item = itemVec->mem[i];
			if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0)
			{
				j = (i-two);
				do{itemVec->mem[j+two] = itemVec->mem[j];j -= two;if(j >= left){two_item = itemVec->mem[j];}else{two_item = NULL;}}
				while(two_item != NULL && compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0);
				if((j+two)!=i){itemVec->mem[j+two] = one_item;}
			}
		}
	}
}
void sort_item_vector_reverse(vector_t *itemVec, int left, int right)
{
  sort_item_t *one_item;if(left >= right){return;}while(left < right){one_item = itemVec->mem[left];itemVec->mem[left] = itemVec->mem[right];itemVec->mem[right] = one_item;left++;right--;}
}
int clzll(unsigned long long x)
{
  int n;n = 0;
  if (x == 0){return 64;}
  if (x >= 0x8000000000000000ULL) {return 0;}
  if (x <= 0x00000000FFFFFFFFULL) {n = n + 32; x = x << 32;}
  if (x <= 0x0000FFFFFFFFFFFFULL) {n = n + 16; x = x << 16;}
  if (x <= 0x00FFFFFFFFFFFFFFULL) {n = n + 8; x = x << 8;}
  if (x <= 0x0FFFFFFFFFFFFFFFULL) {n = n + 4; x = x << 4;}
  if (x <= 0x3FFFFFFFFFFFFFFFULL) {n = n + 2; x = x << 2;}
  if (x <= 0x7FFFFFFFFFFFFFFFULL) {n = n + 1;}
  return n;
}
int compute_minrun(int count)
{
  int oneNum;int shiftNum;int minrun;unsigned long long mask;unsigned long long one;one=(unsigned long long)count;
  oneNum = 64 - clzll(one);if(oneNum<=6){shiftNum = 0;}else{shiftNum = oneNum - 6;}
  minrun = (int)(one>>shiftNum);mask = ((1ULL<<shiftNum)-1);if((mask&one)){minrun+=1;}
  return minrun;
}
int sort_item_vector_get_run(vector_t *itemVec, int left, int count)
{
  sort_item_t *one_item;sort_item_t *two_item;
  sort_item_t *pos_one_item;sort_item_t *pos_two_item;
  int pos;pos = (left+2);if(left >= count){return 0;}if(left == (count-1)){return 1;}
  if(left == (count-2))
  {
	two_item = itemVec->mem[count-2];one_item = itemVec->mem[count-1];
	if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) > 0){sort_item_vector_reverse(itemVec, count-2, count-1);}
	return 2;
  }
  two_item = itemVec->mem[left];one_item = itemVec->mem[left+1];
  if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) <= 0)
  {
	while(pos<=(count-1))
	{
		pos_two_item = itemVec->mem[pos-1];pos_one_item = itemVec->mem[pos];
		if(compareItem(pos_two_item->key, pos_two_item->key_len, pos_one_item->key, pos_one_item->key_len) > 0)
		{
			break;
		}
		pos++;
	}
	return (pos-left);
  }
  else
  {
	while(pos<=(count-1))
	{
		pos_two_item = itemVec->mem[pos-1];pos_one_item = itemVec->mem[pos];
		if(compareItem(pos_two_item->key, pos_two_item->key_len, pos_one_item->key, pos_one_item->key_len) <= 0)
		{
			break;
		}
		pos++;
	}
	sort_item_vector_reverse(itemVec, left, pos-1);
	return (pos-left);
  }
}
int sort_run_vector_check_run(sort_run_vector_t *run_vec)
{
  int A;int B;int C;int D;int ABC;int BCD;int CD;int one_count;
  if(run_vec->count < 2){return 1;}one_count = run_vec->count;
  if (one_count == 2){A = run_vec->mem[0].length;B = run_vec->mem[1].length;if(A <= B){return 0;}else{return 1;}}
  A = 0;B = run_vec->mem[one_count-3].length;C = run_vec->mem[one_count-2].length;D = run_vec->mem[one_count-1].length;if(one_count >= 4){A = run_vec->mem[one_count-4].length;}
  if(A > 0){ABC = (A <= (B + C));}else{ABC = 0;}BCD = (B <= (C + D));CD = (C <= D);
  if(CD || BCD || ABC){return 0;}else{return 1;}
}
void sort_merge(sort_t *sort)
{
  int A;int B;int i;int j;int k;int pos;int one_count;sort_run_vector_t *run_vec;vector_t *itemVec;vector_t *mergeVec;
  sort_item_t *one_item;sort_item_t *two_item;if(sort->runVec.count < 2){return ;}
  one_count = sort->runVec.count;run_vec = &(sort->runVec);itemVec = &(sort->itemVec);mergeVec = &(sort->mergeVec);
  A = run_vec->mem[one_count-2].length;B = run_vec->mem[one_count-1].length;pos = run_vec->mem[one_count-2].start;
  if(A < B)
  {
    vector_copy_vec_min_max_two(itemVec, pos, pos + (A -1), mergeVec);
    i = 0;j = (pos+A);k = pos;
    while(k<(pos+A+B))
    {
      if((i<A)&&(j<(pos+A+B)))
      {
	two_item = mergeVec->mem[i];one_item = itemVec->mem[j];
	if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) <= 0)
	{
		itemVec->mem[k] = two_item;
		i++;k++;
	}
	else
	{
		if(k!=j){itemVec->mem[k]=one_item;}
		j++;k++;
	}
      }
      else if((i<A)&&(j>=(pos+A+B)))
      {
	itemVec->mem[k] = mergeVec->mem[i];
	i++;k++;
      }
      else if((i>=A)&&(j<(pos+A+B)))
      {
	if(k!=j){itemVec->mem[k] = itemVec->mem[j];}
	j++;k++;
      }
      else if((i>=A)&&(j>=(pos+A+B))){break;}
    }
  }
  else
  {
    vector_copy_vec_min_max_two(itemVec, pos + A, pos + (A + B -1), mergeVec);
    i = (B-1);j = (pos+A-1);k = (pos+A+B-1);
    while(k>=pos)
    {
      if((i>=0)&&(j>=pos))
      {
	two_item = mergeVec->mem[i];one_item = itemVec->mem[j];
	if(compareItem(two_item->key, two_item->key_len, one_item->key, one_item->key_len) < 0)
	{
		if(k!=j){itemVec->mem[k]=one_item;}
		j--;k--;
	}
	else
	{
		itemVec->mem[k]=two_item;
		i--;k--;
	}
      }
      else if((i>=0)&&(j<pos))
      {
	itemVec->mem[k]=mergeVec->mem[i];
	i--;k--;
      }
      else if((i<0)&&(j>=pos))
      {
	if(k!=j){itemVec->mem[k]=itemVec->mem[j];}
	j--;k--;
      }
      else if((i<0)&&(j<pos)){break;}
    }
  }
}
void sort_collapse(sort_t *sort)
{
  int A;int B;int C;int D;int ABC;int BCD;int CD;int one;int count;sort_run_vector_t *run_vec;vector_t *itemVec;sort_run_t one_run;int one_run_count;
  if(sort->runVec.count < 2){return ;}
  count = sort->itemVec.count;run_vec = &(sort->runVec);itemVec = &(sort->itemVec);
  while(run_vec->count >= 2)
  {
    if((run_vec->count == 2)&&((run_vec->mem[0].length+run_vec->mem[1].length) >= count))
    {
	sort_merge(sort);run_vec->mem[0].length += run_vec->mem[1].length;
	sort_run_vector_delete(run_vec, 1, &one_run);
	break;
    }
    else if((run_vec->count == 2)&&((run_vec->mem[0].length+run_vec->mem[1].length) < count)&&(run_vec->mem[0].length <= run_vec->mem[1].length))
    {
	sort_merge(sort);run_vec->mem[0].length += run_vec->mem[1].length;
	sort_run_vector_delete(run_vec, 1, &one_run);
	break;
    }
    else if (run_vec->count == 2) {break;}
    one_run_count = run_vec->count;
    A = 0;B = run_vec->mem[one_run_count-3].length;C = run_vec->mem[one_run_count-2].length;D = run_vec->mem[one_run_count-1].length;
    if(one_run_count >= 4){A = run_vec->mem[one_run_count-4].length;}
    if(A > 0){ABC = (A <= (B + C));}else{ABC = 0;}BCD = (B <= (C + D));CD = (C <= D);
    if(CD || BCD || ABC)
    {
    	if(CD)
	{
		sort_merge(sort);run_vec->mem[one_run_count - 2].length += run_vec->mem[one_run_count - 1].length;
		sort_run_vector_delete(run_vec, one_run_count - 1, &one_run);
	}
    	else if(!CD && (BCD || ABC))
    	{
    		one = run_vec->count;run_vec->count--;sort_merge(sort);run_vec->count = one;
		run_vec->mem[one_run_count - 3].length += run_vec->mem[one_run_count - 2].length;
		run_vec->mem[one_run_count - 2] = run_vec->mem[one_run_count - 1];
		sort_run_vector_delete(run_vec, one_run_count - 1, &one_run);
    	}
    }
    else{break;}
  }
  return ;
}
int sort_push(sort_t *sort)
{
  int length;int run;int count;sort_run_vector_t *run_vec;vector_t *itemVec;sort_run_t one_run;int one_run_count;
  count = sort->itemVec.count;run_vec = &(sort->runVec);itemVec = &(sort->itemVec);
  if(sort->start_index >= count){return 0;}length = sort_item_vector_get_run(itemVec, sort->start_index, count);run = sort->min_run;
  if(run > (count - sort->start_index)){run = count - sort->start_index;}if(run > length) {sort_item_vector_shell(itemVec, sort->start_index, sort->start_index+(run-1));length = run;}
  one_run.start = sort->start_index;one_run.length = length;
  sort_run_vector_add(run_vec, &one_run);
  sort->start_index += length;
  if(sort->start_index >= count)
  {
    while(run_vec->count >= 2)
    {
	one_run_count = run_vec->count;
	sort_merge(sort);run_vec->mem[one_run_count - 2].length += run_vec->mem[one_run_count - 1].length;
	sort_run_vector_delete(run_vec, one_run_count - 1, NULL);
    }
    return 0;
  }
  return 1;
}
void sort_item_vector_tim(sort_t *sort)
{
  int count;sort_run_vector_t *run_vec;vector_t *itemVec;count = sort->itemVec.count;run_vec = &(sort->runVec);itemVec = &(sort->itemVec);
  if(count <= 1) {return;}if(count < 64){sort_item_vector_shell(itemVec, 0, count-1);return;}
  sort->min_run = compute_minrun(count);sort->start_index = 0;
  if(!sort_push(sort)){return;}if(!sort_push(sort)){return;}if(!sort_push(sort)){return;}
  if(!sort_run_vector_check_run(run_vec)){sort_collapse(sort);}while(sort_push(sort)){if(!sort_run_vector_check_run(run_vec)){sort_collapse(sort);}}
}
int sort_inorder_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	sort_t one_sort;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&(one_sort.itemVec));vector_init(&(one_sort.mergeVec));sort_run_vector_init(&(one_sort.runVec));
	one_sort.min_run = 0;one_sort.start_index = 0;
	if(vector_reserve(&(one_sort.itemVec), sort->itemVec.count) == 0){return 0;}
	if(vector_reserve(&(one_sort.mergeVec), sort->itemVec.count) == 0){vector_free(&(one_sort.itemVec));return 0;}
	vector_copy_vec_two(&(sort->itemVec), &(one_sort.itemVec));sort_item_vector_tim(&one_sort);
	vector_add_vec_two(&(one_sort.itemVec), all_item_vec);
	vector_free(&(one_sort.itemVec));vector_free(&(one_sort.mergeVec));sort_run_vector_free(&(one_sort.runVec));return 1;
}
int sort_inorder_reverse_get_all_item(sort_t *sort, vector_t *all_item_vec)
{
	int i;sort_item_t *one_item;sort_t one_sort;if(sort == NULL){return -1;}if(sort->itemVec.count <= 0){return -1;}
	vector_init(&(one_sort.itemVec));vector_init(&(one_sort.mergeVec));sort_run_vector_init(&(one_sort.runVec));
	one_sort.min_run = 0;one_sort.start_index = 0;
	if(vector_reserve(&(one_sort.itemVec), sort->itemVec.count) == 0){return 0;}
	if(vector_reserve(&(one_sort.mergeVec), sort->itemVec.count) == 0){vector_free(&(one_sort.itemVec));return 0;}
	vector_copy_vec_two(&(sort->itemVec), &(one_sort.itemVec));sort_item_vector_tim(&one_sort);
	for(i = (one_sort.itemVec.count-1);i >= 0;i--)
	{
		one_item = one_sort.itemVec.mem[i];vector_add(all_item_vec, one_item);
	}
	vector_free(&(one_sort.itemVec));vector_free(&(one_sort.mergeVec));sort_run_vector_free(&(one_sort.runVec));return 1;
}
void sort_item_dump(FILE *fd, sort_item_t *item)
{
	fprintf(fd, "%s <--> %s", ((char *)(item->key)), ((char *)(item->value)));
}
void sort_dump(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	for(i = 0;i < sort->itemVec.count;i++)
	{
		item = sort->itemVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
}
void sort_dump_inorder(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void sort_dump_inorder_reverse(FILE *fd, sort_t *sort)
{
	int i;sort_item_t *item;vector_t oneVec;vector_init(&oneVec);if(sort == NULL){return ;}if(sort->itemVec.count <= 0){return ;}
	if(vector_reserve(&oneVec, sort->itemVec.count) == 0){return ;}sort_inorder_reverse_get_all_item(sort, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){sort_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;sort_t *sort;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 82;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4);memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4);memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4);memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4);memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4);memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4);memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4);memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4);memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4);memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4);memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	memcpy(arrKeyStr[32],"xxxx",4);memcpy(arrValStr[32],"xx",2);
	memcpy(arrKeyStr[33],"yyyy",4);memcpy(arrValStr[33],"yy",2);
	memcpy(arrKeyStr[34],"zzzz",4);memcpy(arrValStr[34],"zz",2);
	memcpy(arrKeyStr[35],"AAAA",4);memcpy(arrValStr[35],"AA",2);
	memcpy(arrKeyStr[36],"BBBB",4);memcpy(arrValStr[36],"BB",2);
	memcpy(arrKeyStr[37],"CCCC",4);memcpy(arrValStr[37],"CC",2);
	memcpy(arrKeyStr[38],"DDDD",4);memcpy(arrValStr[38],"DD",2);
	memcpy(arrKeyStr[39],"EEEE",4);memcpy(arrValStr[39],"EE",2);
	memcpy(arrKeyStr[40],"FFFF",4);memcpy(arrValStr[40],"FF",2);
	memcpy(arrKeyStr[41],"GGGG",4);memcpy(arrValStr[41],"GG",2);
	memcpy(arrKeyStr[42],"HHHH",4);memcpy(arrValStr[42],"HH",2);
	memcpy(arrKeyStr[43],"IIII",4);memcpy(arrValStr[43],"II",2);
	memcpy(arrKeyStr[44],"JJJJ",4);memcpy(arrValStr[44],"JJ",2);
	memcpy(arrKeyStr[45],"KKKK",4);memcpy(arrValStr[45],"KK",2);
	memcpy(arrKeyStr[46],"LLLL",4);memcpy(arrValStr[46],"LL",2);
	memcpy(arrKeyStr[47],"MMMM",4);memcpy(arrValStr[47],"MM",2);
	memcpy(arrKeyStr[48],"NNNN",4);memcpy(arrValStr[48],"NN",2);
	memcpy(arrKeyStr[49],"OOOO",4);memcpy(arrValStr[49],"OO",2);
	memcpy(arrKeyStr[50],"PPPP",4);memcpy(arrValStr[50],"PP",2);
	memcpy(arrKeyStr[51],"QQQQ",4);memcpy(arrValStr[51],"QQ",2);
	memcpy(arrKeyStr[52],"RRRR",4);memcpy(arrValStr[52],"RR",2);
	memcpy(arrKeyStr[53],"SSSS",4);memcpy(arrValStr[53],"SS",2);
	memcpy(arrKeyStr[54],"TTTT",4);memcpy(arrValStr[54],"TT",2);
	memcpy(arrKeyStr[55],"UUUU",4);memcpy(arrValStr[55],"UU",2);
	memcpy(arrKeyStr[56],"VVVV",4);memcpy(arrValStr[56],"VV",2);
	memcpy(arrKeyStr[57],"WWWW",4);memcpy(arrValStr[57],"WW",2);
	memcpy(arrKeyStr[58],"XXXX",4);memcpy(arrValStr[58],"XX",2);
	memcpy(arrKeyStr[59],"YYYY",4);memcpy(arrValStr[59],"YY",2);
	memcpy(arrKeyStr[60],"ZZZZ",4);memcpy(arrValStr[60],"ZZ",2);
	memcpy(arrKeyStr[61],"1222",4);memcpy(arrValStr[61],"12",2);
	memcpy(arrKeyStr[62],"1333",4);memcpy(arrValStr[62],"13",2);
	memcpy(arrKeyStr[63],"1444",4);memcpy(arrValStr[63],"14",2);
	memcpy(arrKeyStr[64],"1555",4);memcpy(arrValStr[64],"15",2);
	memcpy(arrKeyStr[65],"1666",4);memcpy(arrValStr[65],"16",2);
	memcpy(arrKeyStr[66],"1777",4);memcpy(arrValStr[66],"17",2);
	memcpy(arrKeyStr[67],"1888",4);memcpy(arrValStr[67],"18",2);
	memcpy(arrKeyStr[68],"1999",4);memcpy(arrValStr[68],"19",2);
	memcpy(arrKeyStr[69],"1aaa",4);memcpy(arrValStr[69],"1a",2);
	memcpy(arrKeyStr[70],"1bbb",4);memcpy(arrValStr[70],"1b",2);
	memcpy(arrKeyStr[71],"2GGG",4);memcpy(arrValStr[71],"2G",2);
	memcpy(arrKeyStr[72],"2HHH",4);memcpy(arrValStr[72],"2H",2);
	memcpy(arrKeyStr[73],"2III",4);memcpy(arrValStr[73],"2I",2);
	memcpy(arrKeyStr[74],"2JJJ",4);memcpy(arrValStr[74],"2J",2);
	memcpy(arrKeyStr[75],"2KKK",4);memcpy(arrValStr[75],"2K",2);
	memcpy(arrKeyStr[76],"2LLL",4);memcpy(arrValStr[76],"2L",2);
	memcpy(arrKeyStr[77],"2MMM",4);memcpy(arrValStr[77],"2M",2);
	memcpy(arrKeyStr[78],"2NNN",4);memcpy(arrValStr[78],"2N",2);
	memcpy(arrKeyStr[79],"2OOO",4);memcpy(arrValStr[79],"2O",2);
	memcpy(arrKeyStr[80],"2PPP",4);memcpy(arrValStr[80],"2P",2);
	memcpy(arrKeyStr[81],"2QQQ",4);memcpy(arrValStr[81],"2Q",2);
	sort = sort_alloc();if(sort == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    sort_insert(sort, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	sort_dump(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	sort_dump_inorder_reverse(fd, sort);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	sort_destroy(sort);
}

int main()
{
	build();
	return 0;
}
