binary_search.c
int binary_search_first_equal(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]==target)
		{
			last = mid;
			high = mid -1;
		}
		else if(pData[mid]>target)
		{
			high = mid -1;
		}
		else
		{
			low = mid +1;
		}
	}

	return last;
}

int binary_search_last_equal(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]==target)
		{
			last = mid;
			low = mid +1;
		}
		else if(pData[mid]>target)
		{
			high = mid -1;
		}
		else
		{
			low = mid +1;
		}
	}

	return last;
}

int binary_search_first_upper(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]>target)
		{
			last = mid;
			high = mid -1;
		}
		else
		{
			low = mid +1;
		}
	}

	return last;
}

int binary_search_last_upper(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]>target)
		{
			last = mid;
			low = mid +1;
		}
		else
		{
			low = mid +1;
		}
	}

	return last;
}

int binary_search_first_upper_equal(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]>=target)
		{
			last = mid;
			high = mid -1;
		}
		else
		{
			low = mid +1;
		}
	}

	return last;
}

int binary_search_last_upper_equal(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]>=target)
		{
			last = mid;
			low = mid +1;
		}
		else
		{
			low = mid +1;
		}
	}

	return last;
}

int binary_search_first_lower(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]<target)
		{
			last = mid;
			high = mid -1;
		}
		else
		{
			high = mid -1;
		}
	}

	return last;
}

int binary_search_last_lower(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]<target)
		{
			last = mid;
			low = mid +1;
		}
		else
		{
			high = mid -1;
		}
	}

	return last;
}

int binary_search_first_lower_equal(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]<=target)
		{
			last = mid;
			high = mid -1;
		}
		else
		{
			high = mid -1;
		}
	}

	return last;
}

int binary_search_last_lower_equal(int* pData,int nLength,int target)
{
	int low = 0;
	int mid = 0;
	int high = 0;
	int last = 0;

	if(nLength<=0)
	{
		return -1;
	}

	low = 0;
	high = nLength-1;
	last = -1;

	while (low<=high)
	{
		mid = low +(high-low)/2;
		if (pData[mid]<=target)
		{
			last = mid;
			low = mid +1;
		}
		else
		{
			high = mid -1;
		}
	}

	return last;
}


avl_tree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} avl_tree_item_t;
typedef struct avl_tree_node {
	int type;int depth;int count;int item_count;int index;struct avl_tree_node *parent;avl_tree_item_t *item;struct avl_tree_node *childArray[2];
} avl_tree_node_t;
typedef struct {avl_tree_node_t *root;} avl_tree_t;
typedef struct {avl_tree_t *tree;int vec_index;vector_t all_item_vec;avl_tree_item_t *item;} avl_tree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int avl_tree_item_init(avl_tree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
avl_tree_item_t * avl_tree_item_alloc()
{
  size_t size;avl_tree_item_t *item;size = sizeof(avl_tree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  avl_tree_item_init(item);return item;
}
int avl_tree_item_other_free(avl_tree_item_t *item){vector_free(&(item->dataVec));avl_tree_item_init(item);return 1;}
void avl_tree_item_free(avl_tree_item_t *item){if(item != NULL){avl_tree_item_other_free(item);free(item);}}
int avl_tree_node_init(avl_tree_node_t *node)
{
	node->type = 0;node->depth = 0;node->count = 0;node->item_count = 0;node->index = 0;node->parent = NULL;
	node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
avl_tree_node_t * avl_tree_node_alloc()
{
	size_t size;avl_tree_node_t *node;size = sizeof(avl_tree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	avl_tree_node_init(node);return node;
}
int avl_tree_node_other_free(avl_tree_node_t *node)
{
	if(node->item != NULL){avl_tree_item_free(node->item);node->item = NULL;}avl_tree_node_init(node);return 1;
}
void avl_tree_node_free(avl_tree_node_t *node)
{
	if(node != NULL){avl_tree_node_other_free(node);free(node);}
}
void avl_tree_node_destroy(avl_tree_node_t **node)
{
	avl_tree_node_t **avl_tree_node;avl_tree_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	if(one_node->childArray[0] != NULL){avl_tree_node = &(one_node->childArray[0]);avl_tree_node_destroy(avl_tree_node);one_node->childArray[0] = NULL;}
	if(one_node->childArray[1] != NULL){avl_tree_node = &(one_node->childArray[1]);avl_tree_node_destroy(avl_tree_node);one_node->childArray[1] = NULL;}
	avl_tree_node_free((*node));*node = NULL;
}
void avl_tree_node_get_all_item(avl_tree_node_t *node, vector_t *all_item_vec)
{
	if(node == NULL){return ;}
	if(node->childArray[0] != NULL){avl_tree_node_get_all_item(node->childArray[0], all_item_vec);}
	if(node->item != NULL){vector_add(all_item_vec, node->item);}
	if(node->childArray[1] != NULL){avl_tree_node_get_all_item(node->childArray[1], all_item_vec);}
}
int avl_tree_inorder_get_all_item(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(check_node == last_node->parent)
			{
				if(last_node == check_node->childArray[0])
				{
					if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
					if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
					else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
				}
				else
				{
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else{return -1;}
		}
	}
	return 1;
}
int avl_tree_inorder_reverse_get_all_item(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
	else
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}else{return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(check_node == last_node->parent)
			{
				if(last_node == check_node->childArray[1])
				{
					if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
					if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
					else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
				}
				else
				{
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else{return -1;}
		}
	}
	return 1;
}
int avl_tree_inorder_get_next_node(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t **result_node)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	*result_node = NULL;check_node = node;
	if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}else{return -1;}
			}
		}
		else
		{
			if(check_node == last_node->parent)
			{
				if(last_node == check_node->childArray[0])
				{
					if(check_node->item != NULL){*result_node = check_node;return 1;}else{return -1;}
				}
				else
				{
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else{return -1;}
		}
	}
	return 1;
}
int avl_tree_inorder_get_prev_node(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t **result_node)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	*result_node = NULL;check_node = node;
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}else{return -1;}
			}
		}
		else
		{
			if(check_node == last_node->parent)
			{
				if(last_node == check_node->childArray[1])
				{
					if(check_node->item != NULL){*result_node = check_node;return 1;}else{return -1;}
				}
				else
				{
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else{return -1;}
		}
	}
	return 1;
}
avl_tree_t * avl_tree_alloc()
{
	size_t size;avl_tree_t *tree;size = sizeof(avl_tree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;return tree;
}
void avl_tree_destroy(avl_tree_t *tree)
{
	avl_tree_node_t **avl_tree_node;if(tree == NULL){return ;}if(tree->root == NULL){free(tree);return ;}
	avl_tree_node = &(tree->root);avl_tree_node_destroy(avl_tree_node);tree->root = NULL;free(tree);
}
int avl_tree_node_rotate_left_child(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t *left_child)
{
	int index;avl_tree_node_t *parent;avl_tree_node_t *right_child;avl_tree_node_t *left_left_child;avl_tree_node_t *left_right_child;
	int right_depth;int left_left_depth;int left_right_depth;int right_count;int left_left_count;int left_right_count;
	int right_item_count;int left_left_item_count;int left_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(left_child == NULL){return -1;}if(node->childArray[0] != left_child){return -1;}
	if(node->item == NULL){return -1;}if(left_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	right_child = node->childArray[1];left_left_child = left_child->childArray[0];left_right_child = left_child->childArray[1];
	if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
	else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
	if(left_left_child == NULL){left_left_depth = -1;left_left_count = 0;left_left_item_count = 0;}
	else{left_left_depth = left_left_child->depth;left_left_count = left_left_child->count;left_left_item_count = left_left_child->item_count;}
	if(left_right_child == NULL){left_right_depth = -1;left_right_count = 0;left_right_item_count = 0;}
	else{left_right_depth = left_right_child->depth;left_right_count = left_right_child->count;left_right_item_count = left_right_child->item_count;}
	if(parent == NULL){tree->root = left_child;left_child->index = 0;left_child->parent = NULL;}
	else{parent->childArray[index] = left_child;left_child->index = index;left_child->parent = parent;}
	left_child->childArray[1] = node;node->index = 1;node->parent = left_child;
	node->childArray[0] = left_right_child;if(left_right_child != NULL){left_right_child->index = 0;left_right_child->parent = node;}
	node->type = (right_depth-left_right_depth);node->depth = max((left_right_depth+1), (right_depth+1));
	node->count = node->item->dataVec.count;node->count += left_right_count;node->count += right_count;
	node->item_count = 1;node->item_count += left_right_item_count;node->item_count += right_item_count;
	left_child->type = (node->depth-left_left_depth);left_child->depth = max((left_left_depth+1), (node->depth+1));
	left_child->count = left_child->item->dataVec.count;left_child->count += left_left_count;left_child->count += node->count;
	left_child->item_count = 1;left_child->item_count += left_left_item_count;left_child->item_count += node->item_count;
	return 1;
}
int avl_tree_node_rotate_right_child(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t *right_child)
{
	int index;avl_tree_node_t *parent;avl_tree_node_t *left_child;avl_tree_node_t *right_left_child;avl_tree_node_t *right_right_child;
	int left_depth;int right_left_depth;int right_right_depth;int left_count;int right_left_count;int right_right_count;
	int left_item_count;int right_left_item_count;int right_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(right_child == NULL){return -1;}if(node->childArray[1] != right_child){return -1;}
	if(node->item == NULL){return -1;}if(right_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	left_child = node->childArray[0];right_left_child = right_child->childArray[0];right_right_child = right_child->childArray[1];
	if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
	else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
	if(right_left_child == NULL){right_left_depth = -1;right_left_count = 0;right_left_item_count = 0;}
	else{right_left_depth = right_left_child->depth;right_left_count = right_left_child->count;right_left_item_count = right_left_child->item_count;}
	if(right_right_child == NULL){right_right_depth = -1;right_right_count = 0;right_right_item_count = 0;}
	else{right_right_depth = right_right_child->depth;right_right_count = right_right_child->count;right_right_item_count = right_right_child->item_count;}
	if(parent == NULL){tree->root = right_child;right_child->index = 0;right_child->parent = NULL;}
	else{parent->childArray[index] = right_child;right_child->index = index;right_child->parent = parent;}
	right_child->childArray[0] = node;node->index = 0;node->parent = right_child;
	node->childArray[1] = right_left_child;if(right_left_child != NULL){right_left_child->index = 1;right_left_child->parent = node;}
	node->type = (right_left_depth-left_depth);node->depth = max((left_depth+1), (right_left_depth+1));
	node->count = node->item->dataVec.count;node->count += left_count;node->count += right_left_count;
	node->item_count = 1;node->item_count += left_item_count;node->item_count += right_left_item_count;
	right_child->type = (right_right_depth-node->depth);right_child->depth = max((node->depth+1), (right_right_depth+1));
	right_child->count = right_child->item->dataVec.count;right_child->count += node->count;right_child->count += right_right_count;
	right_child->item_count = 1;right_child->item_count += node->item_count;right_child->item_count += right_right_item_count;
	return 1;	
}
int avl_tree_node_rotate(avl_tree_t *tree, avl_tree_node_t *node)
{
	int index;avl_tree_node_t *parent;avl_tree_node_t *one_node;avl_tree_node_t *one_left_child;avl_tree_node_t *one_right_child;
	avl_tree_node_t *left_child;avl_tree_node_t *right_child;avl_tree_node_t *left_left_child;avl_tree_node_t *left_right_child;
	avl_tree_node_t *right_left_child;avl_tree_node_t *right_right_child;int left_depth;int right_depth;int left_left_depth;
	int left_right_depth;int right_left_depth;int right_right_depth;int one_left_depth;int one_right_depth;int one_left_count;
	int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(node->type == 0){return 0;}index = node->index;parent = node->parent;
	if(node->type < 0)
	{
		if(node->childArray[0] == NULL){return -1;}left_child = node->childArray[0];if(left_child->item == NULL){return -1;}
		if(left_child->type > 0)
		{
			if(left_child->childArray[1] == NULL){return -1;}left_right_child = left_child->childArray[1];if(left_right_child->item == NULL){return -1;}
			if(node->childArray[1] == NULL){right_depth = -1;}else{right_depth = node->childArray[1]->depth;}
			left_right_depth = left_right_child->depth;
			if(right_depth >= left_right_depth){return 0;}
			avl_tree_node_rotate_right_child(tree, left_child, left_right_child);
			one_left_child = node->childArray[0];one_right_child = node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			node->type = (one_right_depth-one_left_depth);node->depth = max((one_left_depth+1), (one_right_depth+1));
			node->count = node->item->dataVec.count;node->count += one_left_count;node->count += one_right_count;
			node->item_count = 1;node->item_count += one_left_item_count;node->item_count += one_right_item_count;
			avl_tree_node_rotate_left_child(tree, node, one_left_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];avl_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];avl_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_depth-one_left_depth);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			avl_tree_node_rotate(tree, one_node);return 1;
		}
		else
		{
			left_left_child = left_child->childArray[0];
			if(node->childArray[1] == NULL){right_depth = -1;}else{right_depth = node->childArray[1]->depth;}
			if(left_left_child == NULL){left_left_depth = -1;}else{left_left_depth = left_left_child->depth;}
			if(right_depth >= left_left_depth){return 0;}
			avl_tree_node_rotate_left_child(tree, node, left_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];avl_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];avl_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_depth-one_left_depth);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			avl_tree_node_rotate(tree, one_node);return 1;
		}
	}
	else if(node->type > 0)
	{
		if(node->childArray[1] == NULL){return -1;}right_child = node->childArray[1];if(right_child->item == NULL){return -1;}
		if(right_child->type < 0)
		{
			if(right_child->childArray[0] == NULL){return -1;}right_left_child = right_child->childArray[0];if(right_left_child->item == NULL){return -1;}
			if(node->childArray[0] == NULL){left_depth = -1;}else{left_depth = node->childArray[0]->depth;}
			right_left_depth = right_left_child->depth;
			if(left_depth >= right_left_depth){return 0;}
			avl_tree_node_rotate_left_child(tree, right_child, right_left_child);
			one_left_child = node->childArray[0];one_right_child = node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			node->type = (one_right_depth-one_left_depth);node->depth = max((one_left_depth+1), (one_right_depth+1));
			node->count = node->item->dataVec.count;node->count += one_left_count;node->count += one_right_count;
			node->item_count = 1;node->item_count += one_left_item_count;node->item_count += one_right_item_count;
			avl_tree_node_rotate_right_child(tree, node, one_right_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];avl_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];avl_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_depth-one_left_depth);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			avl_tree_node_rotate(tree, one_node);return 1;
		}
		else
		{
			right_right_child = right_child->childArray[1];
			if(node->childArray[0] == NULL){left_depth = -1;}else{left_depth = node->childArray[0]->depth;}
			if(right_right_child == NULL){right_right_depth = -1;}else{right_right_depth = right_right_child->depth;}
			if(left_depth >= right_right_depth){return 0;}			
			avl_tree_node_rotate_right_child(tree, node, right_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];avl_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];avl_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_depth-one_left_depth);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			avl_tree_node_rotate(tree, one_node);return 1;
		}
	}
	return 0;
}
int avl_tree_find_rank(avl_tree_t *tree, avl_tree_node_t *node, int rank, avl_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count)
{
	avl_tree_node_t *left_child;int left_count;int left_item_count;avl_tree_node_t *check_node;int check_count;int check_item_count;
	int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(rank < 1){return -1;}if(rank > tree->root->count){return -1;}*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;
	check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}if((rank-rank_count) > check_node->count){return -1;}left_child = check_node->childArray[0];
		if(left_child == NULL){left_count = 0;left_item_count = 0;}else{left_count = left_child->count;left_item_count = left_child->item_count;}
		check_count = (left_count+(check_node->item->dataVec.count));check_item_count = (left_item_count+1);
		if((rank-rank_count) > check_count)
		{
			rank_count += check_count;rank_item_count += check_item_count;
			if(check_node->childArray[1] == NULL){return 2;}else{check_node = check_node->childArray[1];}
		}
		else if((rank-rank_count) <= left_count)
		{
			if(check_node->childArray[0] == NULL){return 2;}else{check_node = check_node->childArray[0];}			
		}
		else
		{
			rank_count += check_count;rank_item_count += check_item_count;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}		
	}
	return 0;
}
int avl_tree_find_base(avl_tree_t *tree, avl_tree_node_t *node, byte_t *key, word_t key_len, avl_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count, int *result_index)
{
	int one;avl_tree_item_t *item;avl_tree_node_t *check_node;int rank_count;int rank_item_count;avl_tree_node_t *one_child;
	int one_count;int one_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;*result_index = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			if(check_node->childArray[1] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 1;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 0;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}
	}
	return 0;
}
int avl_tree_find_max(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t **result_node)
{
	avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[1] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[1];}
	}
	return 0;
}
int avl_tree_find_min(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t **result_node)
{
	avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[0] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[0];}
	}
	return 0;
}
int avl_tree_find_first_upper_equal(avl_tree_t *tree, avl_tree_node_t *node, byte_t *key, word_t key_len, avl_tree_node_t **result_node)
{
	avl_tree_node_t *one_node;int one_rank_count;int one_rank_item_count;int one_index;int temp_result;
	avl_tree_node_t *upper_node;avl_tree_node_t *lower_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}*result_node = NULL;one_node = NULL;one_rank_count = 0;one_rank_item_count = 0;one_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &one_node, &one_rank_count, &one_rank_item_count, &one_index);
	if(temp_result == -1){return -1;}if(one_node == NULL){return 0;}
	if(temp_result == 1)
	{
		*result_node = one_node;return 1;
	}
	else if(temp_result == 2)
	{
		if(one_index == 0)
		{
			upper_node = one_node;lower_node = NULL;
			temp_result = avl_tree_inorder_get_prev_node(tree, upper_node, &lower_node);if(temp_result == -1){return -1;}
			*result_node = upper_node;
		}
		else
		{
			upper_node = NULL;lower_node = one_node;
			temp_result = avl_tree_inorder_get_next_node(tree, lower_node, &upper_node);if(temp_result == -1){return -1;}
			if(upper_node == NULL){return 0;}else{*result_node = upper_node;}
		}
		return 1;
	}
	else{return 0;}
}
int avl_tree_find_last_lower_equal(avl_tree_t *tree, avl_tree_node_t *node, byte_t *key, word_t key_len, avl_tree_node_t **result_node)
{
	avl_tree_node_t *one_node;int one_rank_count;int one_rank_item_count;int one_index;int temp_result;
	avl_tree_node_t *upper_node;avl_tree_node_t *lower_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}*result_node = NULL;one_node = NULL;one_rank_count = 0;one_rank_item_count = 0;one_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &one_node, &one_rank_count, &one_rank_item_count, &one_index);
	if(temp_result == -1){return -1;}if(one_node == NULL){return 0;}
	if(temp_result == 1)
	{
		*result_node = one_node;return 1;
	}
	else if(temp_result == 2)
	{
		if(one_index == 0)
		{
			upper_node = one_node;lower_node = NULL;
			temp_result = avl_tree_inorder_get_prev_node(tree, upper_node, &lower_node);if(temp_result == -1){return -1;}
			if(lower_node == NULL){return 0;}else{*result_node = lower_node;}
		}
		else
		{
			upper_node = NULL;lower_node = one_node;
			temp_result = avl_tree_inorder_get_next_node(tree, lower_node, &upper_node);if(temp_result == -1){return -1;}
			*result_node = lower_node;
		}
		return 1;
	}
	else{return 0;}
}
int avl_tree_get_min_max_item(avl_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *all_item_vec)
{
	avl_tree_node_t *result_node;int temp_result;avl_tree_node_t *check_node;avl_tree_node_t *min_node;avl_tree_node_t *max_node;
	avl_tree_node_t *next_node;vector_t one_item_vec;vector_init(&one_item_vec);
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = avl_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = avl_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node){vector_add(all_item_vec, min_node->item);vector_free(&one_item_vec);return 1;}
	vector_add(&one_item_vec, min_node->item);
	next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, min_node, &next_node);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_item_vec, check_node->item);
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;
	}
	vector_add(&one_item_vec, max_node->item);vector_add_vec_two(&one_item_vec, all_item_vec);vector_free(&one_item_vec);return 1;
}
int avl_tree_get_min_max_item_two(avl_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *all_item_vec)
{
	avl_tree_node_t *result_node;int temp_result;avl_tree_node_t *check_node;avl_tree_node_t *min_node;avl_tree_node_t *max_node;
	avl_tree_node_t *next_node;vector_t one_item_vec;vector_init(&one_item_vec);
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = avl_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = avl_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
		vector_add(&one_item_vec, min_node->item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
		vector_free(&one_item_vec);return 1;
	}
	vector_add(&one_item_vec, min_node->item);
	next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, min_node, &next_node);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_item_vec, check_node->item);
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;
	}
	vector_add(&one_item_vec, max_node->item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
	vector_free(&one_item_vec);return 1;
}
int avl_tree_inorder_get_all_item_other(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *result_node;int temp_result;avl_tree_node_t *check_node;avl_tree_node_t *next_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;
	temp_result = avl_tree_find_min(tree, tree->root, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
		if(temp_result == -1){return -1;}if(next_node == NULL){return 1;}check_node = next_node;
	}
	return 1;
}
int avl_tree_inorder_get_all_item_other_two(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int temp_result;avl_tree_node_t *check_node;avl_tree_node_t *next_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, 1, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
		if(temp_result == -1){return -1;}if(next_node == NULL){return 1;}check_node = next_node;
	}
	return 1;	
}
int avl_tree_inorder_get_all_item_another(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *result_node;int temp_result;avl_tree_node_t *check_node;avl_tree_node_t *prev_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;
	temp_result = avl_tree_find_max(tree, tree->root, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		prev_node = NULL;temp_result = avl_tree_inorder_get_prev_node(tree, check_node, &prev_node);
		if(temp_result == -1){return -1;}if(prev_node == NULL){return 1;}check_node = prev_node;
	}
	return 1;
}
int avl_tree_inorder_get_all_item_another_two(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int temp_result;avl_tree_node_t *check_node;avl_tree_node_t *prev_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, tree->root->count, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		prev_node = NULL;temp_result = avl_tree_inorder_get_prev_node(tree, check_node, &prev_node);
		if(temp_result == -1){return -1;}if(prev_node == NULL){return 1;}check_node = prev_node;
	}
	return 1;
}
int avl_tree_get_rank(avl_tree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int avl_tree_check_exist(avl_tree_t *tree, byte_t *key, word_t key_len)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}return 1;
}
int avl_tree_get(avl_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	avl_tree_item_t *item;avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(item->dataVec), result_data_vec);}return 1;
}
int avl_tree_insert(avl_tree_t *tree, byte_t *key, word_t key_len, void *value)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;avl_tree_item_t *one_item;
	avl_tree_node_t *one_node;avl_tree_node_t *check_node;avl_tree_node_t *check_parent;avl_tree_node_t *left_child;avl_tree_node_t *right_child;
	int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = avl_tree_item_alloc();if(one_item == NULL){return 0;}
		one_node = avl_tree_node_alloc();if(one_node == NULL){avl_tree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;one_node->index = 0;one_node->parent = NULL;
		one_node->item = one_item;tree->root = one_node;return 1;
	}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->item;vector_add(&(one_item->dataVec), value);check_node = result_node;
		while(check_node != NULL){check_node->count++;check_node = check_node->parent;}return 1;
	}
	one_item = avl_tree_item_alloc();if(one_item == NULL){return 0;}
	one_node = avl_tree_node_alloc();if(one_node == NULL){avl_tree_item_free(one_item);return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;
	one_node->index = result_index;one_node->parent = result_node;one_node->item = one_item;
	result_node->childArray[result_index] = one_node;check_node = result_node;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_depth-left_depth);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		avl_tree_node_rotate(tree, check_node);
		check_node = check_parent;
	}
	return 1;
}
int avl_tree_remove(avl_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	avl_tree_node_t *one_node;avl_tree_item_t *one_item;int one_count;avl_tree_node_t *one_child;int one_index;avl_tree_node_t *one_parent;
	avl_tree_node_t *replace_node;avl_tree_item_t *replace_item;avl_tree_node_t *check_node;avl_tree_node_t *check_parent;
	avl_tree_node_t *left_child;avl_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	if(result_node->childArray[0] != NULL && result_node->childArray[1] != NULL)
	{
		one_node = result_node->childArray[0];replace_node = NULL;temp_result = avl_tree_find_max(tree, one_node, &replace_node);
		if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(replace_node == NULL){return 0;}replace_item = replace_node->item;
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		one_count = ((replace_item->dataVec.count)-(one_item->dataVec.count));avl_tree_item_free(one_item);
		result_node->item = replace_item;replace_node->item = NULL;check_node = result_node;
		while(check_node != NULL){check_node->count += one_count;check_node = check_node->parent;}result_node = replace_node;
	}
	else
	{
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		avl_tree_item_free(one_item);result_node->item = NULL;
	}
	one_index = result_node->index;one_parent = result_node->parent;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] == NULL)
	{
		one_child = result_node->childArray[0];result_node->childArray[0] = NULL;avl_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else if(result_node->childArray[0] == NULL && result_node->childArray[1] != NULL)
	{
		one_child = result_node->childArray[1];result_node->childArray[1] = NULL;avl_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else
	{
		one_child = NULL;result_node->childArray[0] = NULL;result_node->childArray[1] = NULL;avl_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;}else{one_parent->childArray[one_index] = one_child;}
	}
	if(one_parent == NULL){return 1;}check_node = one_parent;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_depth-left_depth);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		avl_tree_node_rotate(tree, check_node);
		check_node = check_parent;
	}
	return 1;
}
int avl_tree_get_rank_min_max_item(avl_tree_t *tree, int min_rank, int max_rank, vector_t *all_item_vec)
{
	vector_t one_item_vec;avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int temp_result;
	avl_tree_node_t *check_node;avl_tree_node_t *next_node;avl_tree_node_t *min_node;avl_tree_node_t *max_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}max_node = result_node;
	vector_init(&one_item_vec);
	if(min_node == max_node){vector_add(all_item_vec, min_node->item);vector_free(&one_item_vec);return 1;}
	vector_add(&one_item_vec, min_node->item);
	next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, min_node, &next_node);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_item_vec, check_node->item);
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;
	}
	vector_add(&one_item_vec, max_node->item);vector_add_vec_two(&one_item_vec, all_item_vec);vector_free(&one_item_vec);return 1;
}
int avl_tree_get_rank_min_max_item_two(avl_tree_t *tree, int min_rank, int max_rank, vector_t *all_item_vec)
{
	vector_t one_item_vec;avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int temp_result;
	avl_tree_node_t *check_node;avl_tree_node_t *next_node;avl_tree_node_t *min_node;avl_tree_node_t *max_node;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}max_node = result_node;
	vector_init(&one_item_vec);
	if(min_node == max_node)
	{
		vector_add(&one_item_vec, min_node->item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
		vector_free(&one_item_vec);return 1;
	}
	vector_add(&one_item_vec, min_node->item);
	next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, min_node, &next_node);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_item_vec, check_node->item);
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;
	}
	vector_add(&one_item_vec, max_node->item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
	vector_free(&one_item_vec);return 1;
}
int avl_tree_rank_min_max_remove(avl_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;avl_tree_node_t *one_node;vector_t one_node_vec;avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;
	int temp_result;avl_tree_node_t *check_node;avl_tree_node_t *next_node;avl_tree_node_t *min_node;avl_tree_node_t *max_node;	
	int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}min_node = result_node;
	one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}max_node = result_node;
	one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	vector_init(&one_node_vec);
	if(min_node != max_node)
	{
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, min_node, &next_node);
		if(temp_result == -1){vector_free(&one_node_vec);return -1;}if(next_node == NULL){vector_free(&one_node_vec);return 0;}
		check_node = next_node;
		while(check_node != NULL && check_node != max_node)
		{
			vector_add(&one_node_vec, check_node);
			next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
			if(temp_result == -1){vector_free(&one_node_vec);return -1;}if(next_node == NULL){vector_free(&one_node_vec);return 0;}
			check_node = next_node;
		}
	}
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	avl_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
    	vector_free(&one_node_vec);return 1;
    }
    else
    {
    	one_count = (max_rank-min_rank+1);
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank));check_node = min_node;
    	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
    	vector_free(&one_node_vec);return 1;
    }
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  	avl_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (upper_min_rank-min_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));check_node = min_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	avl_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  	avl_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (max_rank-lower_max_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	vector_delete_min_max(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank));check_node = max_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
	vector_free(&one_node_vec);return 1;
}
int avl_tree_rank_min_max_get(avl_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;avl_tree_node_t *one_node;vector_t one_node_vec;avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;
	int temp_result;avl_tree_node_t *check_node;avl_tree_node_t *next_node;avl_tree_node_t *min_node;avl_tree_node_t *max_node;	
	int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}min_node = result_node;
	one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}max_node = result_node;
	one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	vector_init(&one_node_vec);
	if(min_node != max_node)
	{
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, min_node, &next_node);
		if(temp_result == -1){vector_free(&one_node_vec);return -1;}if(next_node == NULL){vector_free(&one_node_vec);return 0;}
		check_node = next_node;
		while(check_node != NULL && check_node != max_node)
		{
			vector_add(&one_node_vec, check_node);
			next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
			if(temp_result == -1){vector_free(&one_node_vec);return -1;}if(next_node == NULL){vector_free(&one_node_vec);return 0;}
			check_node = next_node;
		}
	}
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	vector_free(&one_node_vec);return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_free(&one_node_vec);return 1;
    }
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_node_vec);return 1;
}
int avl_tree_min_max_remove(avl_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;avl_tree_node_t *one_node;vector_t one_node_vec;avl_tree_node_t *result_node;int temp_result;avl_tree_node_t *check_node;
	avl_tree_node_t *next_node;avl_tree_node_t *min_node;avl_tree_node_t *max_node;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = avl_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = avl_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}max_node = result_node;
	vector_init(&one_node_vec);
	if(min_node != max_node)
	{
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, min_node, &next_node);
		if(temp_result == -1){vector_free(&one_node_vec);return -1;}if(next_node == NULL){vector_free(&one_node_vec);return 0;}
		check_node = next_node;
		while(check_node != NULL && check_node != max_node)
		{
			vector_add(&one_node_vec, check_node);
			next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
			if(temp_result == -1){vector_free(&one_node_vec);return -1;}if(next_node == NULL){vector_free(&one_node_vec);return 0;}
			check_node = next_node;
		}
	}
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    avl_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
    vector_free(&one_node_vec);return 1;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  avl_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	avl_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  avl_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
	vector_free(&one_node_vec);return 1;
}
int avl_tree_min_max_get(avl_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;avl_tree_node_t *one_node;vector_t one_node_vec;avl_tree_node_t *result_node;int temp_result;avl_tree_node_t *check_node;
	avl_tree_node_t *next_node;avl_tree_node_t *min_node;avl_tree_node_t *max_node;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = avl_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = avl_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}max_node = result_node;
	vector_init(&one_node_vec);
	if(min_node != max_node)
	{
		next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, min_node, &next_node);
		if(temp_result == -1){vector_free(&one_node_vec);return -1;}if(next_node == NULL){vector_free(&one_node_vec);return 0;}
		check_node = next_node;
		while(check_node != NULL && check_node != max_node)
		{
			vector_add(&one_node_vec, check_node);
			next_node = NULL;temp_result = avl_tree_inorder_get_next_node(tree, check_node, &next_node);
			if(temp_result == -1){vector_free(&one_node_vec);return -1;}if(next_node == NULL){vector_free(&one_node_vec);return 0;}
			check_node = next_node;
		}
	}
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    vector_free(&one_node_vec);return 1;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
	vector_free(&one_node_vec);return 1;
}
int avl_tree_iterator_init(avl_tree_t *tree, avl_tree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return 0;}avl_tree_node_get_all_item(tree->root, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
avl_tree_iterator_t * avl_tree_iterator_alloc(avl_tree_t *tree)
{
	size_t size;avl_tree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(avl_tree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(avl_tree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void avl_tree_iterator_free(avl_tree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int avl_tree_iterator_next(avl_tree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}
}
void avl_tree_item_dump(FILE *fd, avl_tree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void avl_tree_dump(FILE *fd, avl_tree_t *tree)
{
	avl_tree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = avl_tree_iterator_alloc(tree);if(iterator == NULL){return ;}
	avl_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(avl_tree_iterator_next(iterator) == 1){avl_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	avl_tree_iterator_free(iterator);
}
void avl_tree_dump_inorder(FILE *fd, avl_tree_t *tree)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return ;}avl_tree_inorder_get_all_item(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void avl_tree_dump_inorder_reverse(FILE *fd, avl_tree_t *tree)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return ;}avl_tree_inorder_reverse_get_all_item(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void avl_tree_dump_inorder_other(FILE *fd, avl_tree_t *tree)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return ;}avl_tree_inorder_get_all_item_other(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void avl_tree_dump_inorder_other_two(FILE *fd, avl_tree_t *tree)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return ;}avl_tree_inorder_get_all_item_other_two(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void avl_tree_dump_inorder_another(FILE *fd, avl_tree_t *tree)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return ;}avl_tree_inorder_get_all_item_another(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void avl_tree_dump_inorder_another_two(FILE *fd, avl_tree_t *tree)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return ;}avl_tree_inorder_get_all_item_another_two(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void avl_tree_dump_inorder_min_max(FILE *fd, avl_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	avl_tree_get_min_max_item_two(tree, min_key, min_key_len, max_key, max_key_len, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);	
}
void avl_tree_dump_inorder_rank_min_max(FILE *fd, avl_tree_t *tree, int min_rank, int max_rank)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	avl_tree_get_rank_min_max_item_two(tree, min_rank, max_rank, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);	
}
void avl_tree_dot_node_dump(FILE *fd, avl_tree_node_t *node, int *nDump)
{
	int i;avl_tree_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n%d:%d\\n",oneDump, node->type, node->depth, node->index, node->count, node->item_count);
	*nDump = (oneDump+1);
	if(node->item != NULL){fprintf(fd, "%s:%d\\n",((char *)(node->item->key)),node->item->dataVec.count);}
	fprintf(fd, "\"];\n");
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			avl_tree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void avl_tree_dot_dump(avl_tree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("avl_tree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph avl_tree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");avl_tree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;avl_tree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = avl_tree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    avl_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	avl_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_reverse(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_other(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_other_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_another(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_another_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_min_max(fd, tree, (byte_t *)(arrKeyStr[3]), strlen(arrKeyStr[3]), (byte_t *)(arrKeyStr[9]), strlen(arrKeyStr[9]));
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_rank_min_max(fd, tree, 3, 9);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 2; i < 7; ++i)
	{
	    avl_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	avl_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_reverse(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_other(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_other_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_another(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_another_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_min_max(fd, tree, (byte_t *)(arrKeyStr[3]), strlen(arrKeyStr[3]), (byte_t *)(arrKeyStr[9]), strlen(arrKeyStr[9]));
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_rank_min_max(fd, tree, 3, 9);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	avl_tree_dot_dump(tree);
	avl_tree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

red_black_tree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

#define RED_COLOR   (1)
#define BLACK_COLOR (-1)

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} red_black_tree_item_t;
typedef struct red_black_tree_node {
	int type;int depth;int count;int item_count;int index;struct red_black_tree_node *parent;red_black_tree_item_t *item;struct red_black_tree_node *childArray[2];
} red_black_tree_node_t;
typedef struct {red_black_tree_node_t *root;} red_black_tree_t;
typedef struct {red_black_tree_t *tree;int vec_index;vector_t all_item_vec;red_black_tree_item_t *item;} red_black_tree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int red_black_tree_item_init(red_black_tree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
red_black_tree_item_t * red_black_tree_item_alloc()
{
  size_t size;red_black_tree_item_t *item;size = sizeof(red_black_tree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  red_black_tree_item_init(item);return item;
}
int red_black_tree_item_other_free(red_black_tree_item_t *item){vector_free(&(item->dataVec));red_black_tree_item_init(item);return 1;}
void red_black_tree_item_free(red_black_tree_item_t *item){if(item != NULL){red_black_tree_item_other_free(item);free(item);}}
int red_black_tree_node_init(red_black_tree_node_t *node)
{
	node->type = 0;node->depth = 0;node->count = 0;node->item_count = 0;node->index = 0;node->parent = NULL;
	node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
red_black_tree_node_t * red_black_tree_node_alloc()
{
	size_t size;red_black_tree_node_t *node;size = sizeof(red_black_tree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	red_black_tree_node_init(node);return node;
}
int red_black_tree_node_other_free(red_black_tree_node_t *node)
{
	if(node->item != NULL){red_black_tree_item_free(node->item);node->item = NULL;}red_black_tree_node_init(node);return 1;
}
void red_black_tree_node_free(red_black_tree_node_t *node)
{
	if(node != NULL){red_black_tree_node_other_free(node);free(node);}
}
void red_black_tree_node_destroy(red_black_tree_node_t **node)
{
	red_black_tree_node_t **red_black_tree_node;red_black_tree_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	if(one_node->childArray[0] != NULL){red_black_tree_node = &(one_node->childArray[0]);red_black_tree_node_destroy(red_black_tree_node);one_node->childArray[0] = NULL;}
	if(one_node->childArray[1] != NULL){red_black_tree_node = &(one_node->childArray[1]);red_black_tree_node_destroy(red_black_tree_node);one_node->childArray[1] = NULL;}
	red_black_tree_node_free((*node));*node = NULL;
}
void red_black_tree_node_get_all_item(red_black_tree_node_t *node, vector_t *all_item_vec)
{
	if(node == NULL){return ;}
	if(node->childArray[0] != NULL){red_black_tree_node_get_all_item(node->childArray[0], all_item_vec);}
	if(node->item != NULL){vector_add(all_item_vec, node->item);}
	if(node->childArray[1] != NULL){red_black_tree_node_get_all_item(node->childArray[1], all_item_vec);}
}
int red_black_tree_preorder_get_all_item(red_black_tree_t *tree, vector_t *all_item_vec)
{
	red_black_tree_node_t *last_node;red_black_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else{if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int red_black_tree_inorder_get_next_item(red_black_tree_t *tree, red_black_tree_node_t *node, red_black_tree_node_t **result_node)
{
	red_black_tree_node_t *last_node;red_black_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int red_black_tree_inorder_get_all_item(red_black_tree_t *tree, vector_t *all_item_vec)
{
	red_black_tree_node_t *last_node;red_black_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int red_black_tree_postorder_get_all_item(red_black_tree_t *tree, vector_t *all_item_vec)
{
	red_black_tree_node_t *last_node;red_black_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{		
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
		else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else
				{
					if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
red_black_tree_t * red_black_tree_alloc()
{
	size_t size;red_black_tree_t *tree;size = sizeof(red_black_tree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;return tree;
}
void red_black_tree_destroy(red_black_tree_t *tree)
{
	red_black_tree_node_t **red_black_tree_node;if(tree == NULL){return ;}if(tree->root == NULL){free(tree);return ;}
	red_black_tree_node = &(tree->root);red_black_tree_node_destroy(red_black_tree_node);tree->root = NULL;free(tree);
}
int red_black_tree_node_rotate_left_child(red_black_tree_t *tree, red_black_tree_node_t *node, red_black_tree_node_t *left_child)
{
	int index;red_black_tree_node_t *parent;red_black_tree_node_t *right_child;red_black_tree_node_t *left_left_child;red_black_tree_node_t *left_right_child;
	int right_depth;int left_left_depth;int left_right_depth;int right_count;int left_left_count;int left_right_count;
	int right_item_count;int left_left_item_count;int left_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(left_child == NULL){return -1;}if(node->childArray[0] != left_child){return -1;}
	if(node->item == NULL){return -1;}if(left_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	right_child = node->childArray[1];left_left_child = left_child->childArray[0];left_right_child = left_child->childArray[1];
	if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
	else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
	if(left_left_child == NULL){left_left_depth = -1;left_left_count = 0;left_left_item_count = 0;}
	else{left_left_depth = left_left_child->depth;left_left_count = left_left_child->count;left_left_item_count = left_left_child->item_count;}
	if(left_right_child == NULL){left_right_depth = -1;left_right_count = 0;left_right_item_count = 0;}
	else{left_right_depth = left_right_child->depth;left_right_count = left_right_child->count;left_right_item_count = left_right_child->item_count;}
	if(parent == NULL){tree->root = left_child;left_child->index = 0;left_child->parent = NULL;}
	else{parent->childArray[index] = left_child;left_child->index = index;left_child->parent = parent;}
	left_child->childArray[1] = node;node->index = 1;node->parent = left_child;
	node->childArray[0] = left_right_child;if(left_right_child != NULL){left_right_child->index = 0;left_right_child->parent = node;}
	node->depth = max((left_right_depth+1), (right_depth+1));
	node->count = node->item->dataVec.count;node->count += left_right_count;node->count += right_count;
	node->item_count = 1;node->item_count += left_right_item_count;node->item_count += right_item_count;
	left_child->depth = max((left_left_depth+1), (node->depth+1));
	left_child->count = left_child->item->dataVec.count;left_child->count += left_left_count;left_child->count += node->count;
	left_child->item_count = 1;left_child->item_count += left_left_item_count;left_child->item_count += node->item_count;
	return 1;
}
int red_black_tree_node_rotate_right_child(red_black_tree_t *tree, red_black_tree_node_t *node, red_black_tree_node_t *right_child)
{
	int index;red_black_tree_node_t *parent;red_black_tree_node_t *left_child;red_black_tree_node_t *right_left_child;red_black_tree_node_t *right_right_child;
	int left_depth;int right_left_depth;int right_right_depth;int left_count;int right_left_count;int right_right_count;
	int left_item_count;int right_left_item_count;int right_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(right_child == NULL){return -1;}if(node->childArray[1] != right_child){return -1;}
	if(node->item == NULL){return -1;}if(right_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	left_child = node->childArray[0];right_left_child = right_child->childArray[0];right_right_child = right_child->childArray[1];
	if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
	else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
	if(right_left_child == NULL){right_left_depth = -1;right_left_count = 0;right_left_item_count = 0;}
	else{right_left_depth = right_left_child->depth;right_left_count = right_left_child->count;right_left_item_count = right_left_child->item_count;}
	if(right_right_child == NULL){right_right_depth = -1;right_right_count = 0;right_right_item_count = 0;}
	else{right_right_depth = right_right_child->depth;right_right_count = right_right_child->count;right_right_item_count = right_right_child->item_count;}
	if(parent == NULL){tree->root = right_child;right_child->index = 0;right_child->parent = NULL;}
	else{parent->childArray[index] = right_child;right_child->index = index;right_child->parent = parent;}
	right_child->childArray[0] = node;node->index = 0;node->parent = right_child;
	node->childArray[1] = right_left_child;if(right_left_child != NULL){right_left_child->index = 1;right_left_child->parent = node;}
	node->depth = max((left_depth+1), (right_left_depth+1));
	node->count = node->item->dataVec.count;node->count += left_count;node->count += right_left_count;
	node->item_count = 1;node->item_count += left_item_count;node->item_count += right_left_item_count;
	right_child->depth = max((node->depth+1), (right_right_depth+1));
	right_child->count = right_child->item->dataVec.count;right_child->count += node->count;right_child->count += right_right_count;
	right_child->item_count = 1;right_child->item_count += node->item_count;right_child->item_count += right_right_item_count;
	return 1;	
}
int red_black_tree_find_rank(red_black_tree_t *tree, red_black_tree_node_t *node, int rank, red_black_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count)
{
	red_black_tree_node_t *left_child;int left_count;int left_item_count;red_black_tree_node_t *check_node;int check_count;int check_item_count;
	int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(rank < 1){return -1;}if(rank > tree->root->count){return -1;}*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;
	check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}if((rank-rank_count) > check_node->count){return -1;}left_child = check_node->childArray[0];
		if(left_child == NULL){left_count = 0;left_item_count = 0;}else{left_count = left_child->count;left_item_count = left_child->item_count;}
		check_count = (left_count+(check_node->item->dataVec.count));check_item_count = (left_item_count+1);
		if((rank-rank_count) > check_count)
		{
			rank_count += check_count;rank_item_count += check_item_count;
			if(check_node->childArray[1] == NULL){return 2;}else{check_node = check_node->childArray[1];}
		}
		else if((rank-rank_count) <= left_count)
		{
			if(check_node->childArray[0] == NULL){return 2;}else{check_node = check_node->childArray[0];}			
		}
		else
		{
			rank_count += check_count;rank_item_count += check_item_count;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}		
	}
	return 0;
}
int red_black_tree_find_base(red_black_tree_t *tree, red_black_tree_node_t *node, byte_t *key, word_t key_len, red_black_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count, int *result_index)
{
	int one;red_black_tree_item_t *item;red_black_tree_node_t *check_node;int rank_count;int rank_item_count;red_black_tree_node_t *one_child;
	int one_count;int one_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;*result_index = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			if(check_node->childArray[1] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 1;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 0;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}
	}
	return 0;
}
int red_black_tree_find_max(red_black_tree_t *tree, red_black_tree_node_t *node, red_black_tree_node_t **result_node)
{
	red_black_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[1] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[1];}
	}
	return 0;
}
int red_black_tree_find_min(red_black_tree_t *tree, red_black_tree_node_t *node, red_black_tree_node_t **result_node)
{
	red_black_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[0] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[0];}
	}
	return 0;
}
int red_black_tree_find_first_upper_equal(red_black_tree_t *tree, red_black_tree_node_t *node, byte_t *key, word_t key_len, red_black_tree_node_t **result_node)
{
	int one;red_black_tree_item_t *item;red_black_tree_node_t *check_node;red_black_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[0];}			
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int red_black_tree_find_last_lower_equal(red_black_tree_t *tree, red_black_tree_node_t *node, byte_t *key, word_t key_len, red_black_tree_node_t **result_node)
{
	int one;red_black_tree_item_t *item;red_black_tree_node_t *check_node;red_black_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[0];}			
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int red_black_tree_get_rank(red_black_tree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	red_black_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = red_black_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int red_black_tree_check_exist(red_black_tree_t *tree, byte_t *key, word_t key_len)
{
	red_black_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = red_black_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}return 1;
}
int red_black_tree_get(red_black_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	red_black_tree_item_t *item;red_black_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = red_black_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(item->dataVec), result_data_vec);}return 1;
}
int red_black_tree_insert(red_black_tree_t *tree, byte_t *key, word_t key_len, void *value)
{
	red_black_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;red_black_tree_item_t *one_item;
	red_black_tree_node_t *one_node;red_black_tree_node_t *one_child;red_black_tree_node_t *check_child;red_black_tree_node_t *check_other_child;
	red_black_tree_node_t *check_node;red_black_tree_node_t *check_other_node;red_black_tree_node_t *check_parent;red_black_tree_node_t *check_grandparent;
	red_black_tree_node_t *left_child;red_black_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;
	int right_item_count;if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = red_black_tree_item_alloc();if(one_item == NULL){return 0;}
		one_node = red_black_tree_node_alloc();if(one_node == NULL){red_black_tree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_node->type = BLACK_COLOR;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;
		one_node->index = 0;one_node->parent = NULL;one_node->item = one_item;tree->root = one_node;return 1;
	}
	tree->root->type = BLACK_COLOR;result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = red_black_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->item;vector_add(&(one_item->dataVec), value);check_node = result_node;
		while(check_node != NULL){check_node->count++;check_node = check_node->parent;}return 1;		
	}
	one_item = red_black_tree_item_alloc();if(one_item == NULL){return 0;}
	one_node = red_black_tree_node_alloc();if(one_node == NULL){red_black_tree_item_free(one_item);return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	one_node->type = RED_COLOR;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;
	one_node->index = result_index;one_node->parent = result_node;one_node->item = one_item;
	result_node->childArray[result_index] = one_node;check_child = one_node;check_node = result_node;check_parent = check_node->parent;
	while(check_node != NULL)
	{
		left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		if(check_child != NULL && check_child->type == RED_COLOR && check_node->type == RED_COLOR && check_parent != NULL && check_parent->type == BLACK_COLOR)
		{
			left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
			if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
			else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
			if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
			else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
			check_parent->depth = max((left_depth+1), (right_depth+1));
			check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
			check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
			if(check_node == check_parent->childArray[0])
			{
				check_other_node = check_parent->childArray[1];
				if(check_other_node != NULL && check_other_node->type == RED_COLOR)
				{
					check_grandparent = check_parent->parent;
					if(check_child == check_node->childArray[1])
					{
						red_black_tree_node_rotate_right_child(tree, check_node, check_child);
						left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
						if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
						else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
						if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
						else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
						check_parent->depth = max((left_depth+1), (right_depth+1));
						check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
						check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
						left_child->type = BLACK_COLOR;right_child->type = BLACK_COLOR;
						if(check_grandparent == NULL)
						{
							check_parent->type = BLACK_COLOR;
							check_child = NULL;check_node = check_grandparent;check_parent = NULL;check_grandparent = NULL;
						}
						else
						{
							if(check_grandparent->type == BLACK_COLOR)
							{
								check_parent->type = RED_COLOR;
								check_child = check_parent;check_node = check_grandparent;check_parent = check_node->parent;check_grandparent = NULL;
							}
							else
							{
								check_parent->type = RED_COLOR;
								check_child = check_parent;check_node = check_grandparent;check_parent = check_node->parent;check_grandparent = NULL;
							}
						}
					}
					else
					{
						left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
						left_child->type = BLACK_COLOR;right_child->type = BLACK_COLOR;
						if(check_grandparent == NULL)
						{
							check_parent->type = BLACK_COLOR;
							check_child = NULL;check_node = check_grandparent;check_parent = NULL;check_grandparent = NULL;
						}
						else
						{
							if(check_grandparent->type == BLACK_COLOR)
							{
								check_parent->type = RED_COLOR;
								check_child = check_parent;check_node = check_grandparent;check_parent = check_node->parent;check_grandparent = NULL;
							}
							else
							{
								check_parent->type = RED_COLOR;
								check_child = check_parent;check_node = check_grandparent;check_parent = check_node->parent;check_grandparent = NULL;
							}
						}
					}
				}
				else
				{
					check_grandparent = check_parent->parent;
					if(check_child == check_node->childArray[1])
					{
						red_black_tree_node_rotate_right_child(tree, check_node, check_child);
						left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
						if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
						else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
						if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
						else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
						check_parent->depth = max((left_depth+1), (right_depth+1));
						check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
						check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
						one_child = check_parent->childArray[0];red_black_tree_node_rotate_left_child(tree, check_parent, one_child);
						one_child->type = BLACK_COLOR;check_parent->type = RED_COLOR;
						check_child = NULL;check_node = check_grandparent;check_parent = NULL;check_grandparent = NULL;
					}
					else
					{
						one_child = check_parent->childArray[0];red_black_tree_node_rotate_left_child(tree, check_parent, one_child);
						one_child->type = BLACK_COLOR;check_parent->type = RED_COLOR;
						check_child = NULL;check_node = check_grandparent;check_parent = NULL;check_grandparent = NULL;
					}
				}
			}
			else
			{
				check_other_node = check_parent->childArray[0];
				if(check_other_node != NULL && check_other_node->type == RED_COLOR)
				{
					check_grandparent = check_parent->parent;
					if(check_child == check_node->childArray[0])
					{
						red_black_tree_node_rotate_left_child(tree, check_node, check_child);
						left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
						if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
						else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
						if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
						else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
						check_parent->depth = max((left_depth+1), (right_depth+1));
						check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
						check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
						left_child->type = BLACK_COLOR;right_child->type = BLACK_COLOR;
						if(check_grandparent == NULL)
						{
							check_parent->type = BLACK_COLOR;
							check_child = NULL;check_node = check_grandparent;check_parent = NULL;check_grandparent = NULL;
						}
						else
						{
							if(check_grandparent->type == BLACK_COLOR)
							{
								check_parent->type = RED_COLOR;
								check_child = check_parent;check_node = check_grandparent;check_parent = check_node->parent;check_grandparent = NULL;
							}
							else
							{
								check_parent->type = RED_COLOR;
								check_child = check_parent;check_node = check_grandparent;check_parent = check_node->parent;check_grandparent = NULL;
							}
						}						
					}
					else
					{
						left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
						left_child->type = BLACK_COLOR;right_child->type = BLACK_COLOR;
						if(check_grandparent == NULL)
						{
							check_parent->type = BLACK_COLOR;
							check_child = NULL;check_node = check_grandparent;check_parent = NULL;check_grandparent = NULL;
						}
						else
						{
							if(check_grandparent->type == BLACK_COLOR)
							{
								check_parent->type = RED_COLOR;
								check_child = check_parent;check_node = check_grandparent;check_parent = check_node->parent;check_grandparent = NULL;
							}
							else
							{
								check_parent->type = RED_COLOR;
								check_child = check_parent;check_node = check_grandparent;check_parent = check_node->parent;check_grandparent = NULL;
							}
						}						
					}
				}
				else
				{
					check_grandparent = check_parent->parent;
					if(check_child == check_node->childArray[0])
					{
						red_black_tree_node_rotate_left_child(tree, check_node, check_child);
						left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
						if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
						else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
						if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
						else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
						check_parent->depth = max((left_depth+1), (right_depth+1));
						check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
						check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
						one_child = check_parent->childArray[1];red_black_tree_node_rotate_right_child(tree, check_parent, one_child);
						one_child->type = BLACK_COLOR;check_parent->type = RED_COLOR;
						check_child = NULL;check_node = check_grandparent;check_parent = NULL;check_grandparent = NULL;
					}
					else
					{
						one_child = check_parent->childArray[1];red_black_tree_node_rotate_right_child(tree, check_parent, one_child);
						one_child->type = BLACK_COLOR;check_parent->type = RED_COLOR;
						check_child = NULL;check_node = check_grandparent;check_parent = NULL;check_grandparent = NULL;
					}
				}
			}
		}
		else if(check_child != NULL && check_child->type == RED_COLOR && check_node->type == BLACK_COLOR)
		{
			check_child = NULL;check_node = check_node->parent;check_parent = NULL;check_grandparent = NULL;
		}
		else
		{
			check_child = NULL;check_node = check_node->parent;check_parent = NULL;check_grandparent = NULL;
		}
	}
	if(tree->root != NULL){tree->root->type = BLACK_COLOR;}return 1;
}
int red_black_tree_remove(red_black_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	red_black_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;int temp_flag;
	red_black_tree_node_t *one_node;red_black_tree_item_t *one_item;int one_count;red_black_tree_node_t *one_child;int one_index;
	red_black_tree_node_t *one_parent;red_black_tree_node_t *replace_node;red_black_tree_item_t *replace_item;red_black_tree_node_t *check_node;
	red_black_tree_node_t *check_other_node;red_black_tree_node_t *check_parent;int check_child_index;red_black_tree_node_t *check_other_child;
	red_black_tree_node_t *check_other_left_child;red_black_tree_node_t *check_other_right_child;red_black_tree_node_t *left_child;
	red_black_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}tree->root->type = BLACK_COLOR;result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = red_black_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	if(result_node->childArray[0] != NULL && result_node->childArray[1] != NULL)
	{
		one_node = result_node->childArray[0];replace_node = NULL;temp_result = red_black_tree_find_max(tree, one_node, &replace_node);
		if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(replace_node == NULL){return 0;}replace_item = replace_node->item;
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		one_count = ((replace_item->dataVec.count)-(one_item->dataVec.count));red_black_tree_item_free(one_item);
		result_node->item = replace_item;replace_node->item = NULL;check_node = result_node;
		while(check_node != NULL){check_node->count += one_count;check_node = check_node->parent;}result_node = replace_node;
	}
	else
	{
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		red_black_tree_item_free(one_item);result_node->item = NULL;
	}
	one_index = result_node->index;one_parent = result_node->parent;temp_flag = 0;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] == NULL)
	{
		one_child = result_node->childArray[0];result_node->childArray[0] = NULL;
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
		if(result_node->type == RED_COLOR){red_black_tree_node_free(result_node);temp_flag = 1;}
		else
		{
			if(one_child != NULL && one_child->type == RED_COLOR)
			{
				one_child->type = BLACK_COLOR;red_black_tree_node_free(result_node);temp_flag = 1;
			}
			else{red_black_tree_node_free(result_node);}
		}
	}
	else if(result_node->childArray[0] == NULL && result_node->childArray[1] != NULL)
	{
		one_child = result_node->childArray[1];result_node->childArray[1] = NULL;
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
		if(result_node->type == RED_COLOR){red_black_tree_node_free(result_node);temp_flag = 1;}
		else
		{
			if(one_child != NULL && one_child->type == RED_COLOR)
			{
				one_child->type = BLACK_COLOR;red_black_tree_node_free(result_node);temp_flag = 1;
			}
			else{red_black_tree_node_free(result_node);}
		}
	}
	else
	{
		one_child = NULL;result_node->childArray[0] = NULL;result_node->childArray[1] = NULL;
		if(one_parent == NULL){tree->root = one_child;}else{one_parent->childArray[one_index] = one_child;}
		if(result_node->type == RED_COLOR){red_black_tree_node_free(result_node);temp_flag = 1;}
		else
		{
			if(one_child != NULL && one_child->type == RED_COLOR)
			{
				one_child->type = BLACK_COLOR;red_black_tree_node_free(result_node);temp_flag = 1;
			}
			else{red_black_tree_node_free(result_node);}
		}
	}
	if(one_parent == NULL){if(tree->root != NULL){tree->root->type = BLACK_COLOR;}return 1;}check_node = one_parent;check_child_index = one_index;
	while(check_node != NULL)
	{
		left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		if(temp_flag == 0)
		{
			if(check_child_index == 0)
			{
				check_other_child = check_node->childArray[1];
				if(check_other_child != NULL && check_other_child->type == RED_COLOR)
				{
					red_black_tree_node_rotate_right_child(tree, check_node, check_other_child);check_parent = check_other_child;
					check_other_child->type = BLACK_COLOR;check_node->type = RED_COLOR;check_other_child	= check_node->childArray[1];
					if(check_other_child != NULL && check_other_child->type == BLACK_COLOR)
					{
						if((check_other_child->childArray[0] == NULL || check_other_child->childArray[0]->type == BLACK_COLOR) && 
							 (check_other_child->childArray[1] == NULL || check_other_child->childArray[1]->type == BLACK_COLOR))
						{
							check_node->type = BLACK_COLOR;check_other_child->type = RED_COLOR;
							temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
						}
						else
						{
							if(check_other_child->childArray[1] != NULL && check_other_child->childArray[1]->type == RED_COLOR)
							{
								check_other_right_child = check_other_child->childArray[1];red_black_tree_node_rotate_right_child(tree, check_node, check_other_child);
								check_other_child->type = check_node->type;
								check_node->type = BLACK_COLOR;check_other_right_child->type = BLACK_COLOR;
								left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
								if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
								else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
								if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
								else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
								check_parent->depth = max((left_depth+1), (right_depth+1));
								check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
								check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
								temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
							}
							else if(check_other_child->childArray[0] != NULL && check_other_child->childArray[0]->type == RED_COLOR)
							{
								int temp_type;
								check_other_left_child = check_other_child->childArray[0];red_black_tree_node_rotate_left_child(tree, check_other_child, check_other_left_child);
								temp_type = check_other_left_child->type;check_other_left_child->type = check_other_child->type;check_other_child->type = temp_type;
								left_child = check_node->childArray[0];right_child = check_node->childArray[1];
								if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
								else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
								if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
								else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
								check_node->depth = max((left_depth+1), (right_depth+1));
								check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
								check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
								check_other_child = check_node->childArray[1];
								check_other_right_child = check_other_child->childArray[1];red_black_tree_node_rotate_right_child(tree, check_node, check_other_child);
								check_other_child->type = check_node->type;
								check_node->type = BLACK_COLOR;check_other_right_child->type = BLACK_COLOR;
								left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
								if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
								else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
								if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
								else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
								check_parent->depth = max((left_depth+1), (right_depth+1));
								check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
								check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
								temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
							}
							else
							{
								temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
							}
						}
					}
					else
					{
						temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
					}
				}
				else if(check_other_child != NULL && check_other_child->type == BLACK_COLOR)
				{
					if((check_other_child->childArray[0] == NULL || check_other_child->childArray[0]->type == BLACK_COLOR) && 
						 (check_other_child->childArray[1] == NULL || check_other_child->childArray[1]->type == BLACK_COLOR))
					{
						if(check_node->type == RED_COLOR)
						{
							check_node->type = BLACK_COLOR;check_other_child->type = RED_COLOR;
							temp_flag = 1;check_child_index = check_node->index;check_node = check_node->parent;

						}
						else
						{
							check_other_child->type = RED_COLOR;
							check_child_index = check_node->index;check_node = check_node->parent;
						}
					}
					else
					{
						if(check_other_child->childArray[1] != NULL && check_other_child->childArray[1]->type == RED_COLOR)
						{
							check_other_right_child = check_other_child->childArray[1];red_black_tree_node_rotate_right_child(tree, check_node, check_other_child);
							check_other_child->type = check_node->type;
							check_node->type = BLACK_COLOR;check_other_right_child->type = BLACK_COLOR;
							temp_flag = 1;check_child_index = check_other_child->index;check_node = check_other_child->parent;
						}
						else if(check_other_child->childArray[0] != NULL && check_other_child->childArray[0]->type == RED_COLOR)
						{
							int temp_type;
							check_other_left_child = check_other_child->childArray[0];red_black_tree_node_rotate_left_child(tree, check_other_child, check_other_left_child);
							temp_type = check_other_left_child->type;check_other_left_child->type = check_other_child->type;check_other_child->type = temp_type;
							left_child = check_node->childArray[0];right_child = check_node->childArray[1];
							if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
							else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
							if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
							else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
							check_node->depth = max((left_depth+1), (right_depth+1));
							check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
							check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
							check_other_child = check_node->childArray[1];
							check_other_right_child = check_other_child->childArray[1];red_black_tree_node_rotate_right_child(tree, check_node, check_other_child);
							check_other_child->type = check_node->type;
							check_node->type = BLACK_COLOR;check_other_right_child->type = BLACK_COLOR;
							temp_flag = 1;check_child_index = check_other_child->index;check_node = check_other_child->parent;								
						}
						else
						{
							temp_flag = 1;check_child_index = check_node->index;check_node = check_node->parent;
						}
					}
				}
				else
				{
					temp_flag = 1;check_child_index = check_node->index;check_node = check_node->parent;
				}
			}
			else
			{
				check_other_child = check_node->childArray[0];
				if(check_other_child != NULL && check_other_child->type == RED_COLOR)
				{
					red_black_tree_node_rotate_left_child(tree, check_node, check_other_child);check_parent = check_other_child;
					check_other_child->type = BLACK_COLOR;check_node->type = RED_COLOR;check_other_child	= check_node->childArray[0];
					if(check_other_child != NULL && check_other_child->type == BLACK_COLOR)
					{
						if((check_other_child->childArray[0] == NULL || check_other_child->childArray[0]->type == BLACK_COLOR) && 
							 (check_other_child->childArray[1] == NULL || check_other_child->childArray[1]->type == BLACK_COLOR))
						{
							check_node->type = BLACK_COLOR;check_other_child->type = RED_COLOR;
							temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
						}
						else
						{
							if(check_other_child->childArray[0] != NULL && check_other_child->childArray[0]->type == RED_COLOR)
							{
								check_other_left_child = check_other_child->childArray[0];red_black_tree_node_rotate_left_child(tree, check_node, check_other_child);
								check_other_child->type = check_node->type;
								check_node->type = BLACK_COLOR;check_other_left_child->type = BLACK_COLOR;
								left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
								if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
								else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
								if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
								else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
								check_parent->depth = max((left_depth+1), (right_depth+1));
								check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
								check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
								temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
							}
							else if(check_other_child->childArray[1] != NULL && check_other_child->childArray[1]->type == RED_COLOR)
							{
								int temp_type;
								check_other_right_child = check_other_child->childArray[1];red_black_tree_node_rotate_right_child(tree, check_other_child, check_other_right_child);
								temp_type = check_other_right_child->type;check_other_right_child->type = check_other_child->type;check_other_child->type = temp_type;
								left_child = check_node->childArray[0];right_child = check_node->childArray[1];
								if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
								else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
								if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
								else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
								check_node->depth = max((left_depth+1), (right_depth+1));
								check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
								check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
								check_other_child = check_node->childArray[0];
								check_other_left_child = check_other_child->childArray[0];red_black_tree_node_rotate_left_child(tree, check_node, check_other_child);
								check_other_child->type = check_node->type;
								check_node->type = BLACK_COLOR;check_other_left_child->type = BLACK_COLOR;
								left_child = check_parent->childArray[0];right_child = check_parent->childArray[1];
								if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
								else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
								if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
								else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
								check_parent->depth = max((left_depth+1), (right_depth+1));
								check_parent->count = check_parent->item->dataVec.count;check_parent->count += left_count;check_parent->count += right_count;
								check_parent->item_count = 1;check_parent->item_count += left_item_count;check_parent->item_count += right_item_count;
								temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
							}
							else
							{
								temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
							}
						}
					}
					else
					{
						temp_flag = 1;check_child_index = check_parent->index;check_node = check_parent->parent;
					}
				}
				else if(check_other_child != NULL && check_other_child->type == BLACK_COLOR)
				{
					if((check_other_child->childArray[0] == NULL || check_other_child->childArray[0]->type == BLACK_COLOR) && 
						 (check_other_child->childArray[1] == NULL || check_other_child->childArray[1]->type == BLACK_COLOR))
					{
						if(check_node->type == RED_COLOR)
						{
							check_node->type = BLACK_COLOR;check_other_child->type = RED_COLOR;
							temp_flag = 1;check_child_index = check_node->index;check_node = check_node->parent;

						}
						else
						{
							check_other_child->type = RED_COLOR;
							check_child_index = check_node->index;check_node = check_node->parent;
						}
					}
					else
					{

						if(check_other_child->childArray[0] != NULL && check_other_child->childArray[0]->type == RED_COLOR)
						{
							check_other_left_child = check_other_child->childArray[0];red_black_tree_node_rotate_left_child(tree, check_node, check_other_child);
							check_other_child->type = check_node->type;
							check_node->type = BLACK_COLOR;check_other_left_child->type = BLACK_COLOR;
							temp_flag = 1;check_child_index = check_other_child->index;check_node = check_other_child->parent;
						}
						else if(check_other_child->childArray[1] != NULL && check_other_child->childArray[1]->type == RED_COLOR)
						{
							int temp_type;
							check_other_right_child = check_other_child->childArray[1];red_black_tree_node_rotate_right_child(tree, check_other_child, check_other_right_child);
							temp_type = check_other_right_child->type;check_other_right_child->type = check_other_child->type;check_other_child->type = temp_type;
							left_child = check_node->childArray[0];right_child = check_node->childArray[1];
							if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
							else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
							if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
							else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
							check_node->depth = max((left_depth+1), (right_depth+1));
							check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
							check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
							check_other_child = check_node->childArray[0];
							check_other_left_child = check_other_child->childArray[0];red_black_tree_node_rotate_left_child(tree, check_node, check_other_child);
							check_other_child->type = check_node->type;
							check_node->type = BLACK_COLOR;check_other_left_child->type = BLACK_COLOR;
							temp_flag = 1;check_child_index = check_other_child->index;check_node = check_other_child->parent;								
						}
						else
						{
							temp_flag = 1;check_child_index = check_node->index;check_node = check_node->parent;
						}
					}
				}
				else
				{
					temp_flag = 1;check_child_index = check_node->index;check_node = check_node->parent;
				}
			}
		}
		else
		{
			check_node = check_node->parent;
		}
	}
	if(tree->root != NULL){tree->root->type = BLACK_COLOR;}return 1;
}
int red_black_tree_inorder_get_all_item_other(red_black_tree_t *tree, vector_t *all_item_vec)
{
	red_black_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;red_black_tree_node_t *check_node;
	red_black_tree_node_t *next_node;int temp_result;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = red_black_tree_find_rank(tree, tree->root, 1, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}next_node = NULL;
		temp_result = red_black_tree_inorder_get_next_item(tree, check_node, &next_node);if(next_node == NULL){return 1;}check_node = next_node;
	}
	return 1;
}
int red_black_tree_rank_min_max_remove(red_black_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;red_black_tree_node_t *one_node;vector_t one_node_vec;red_black_tree_node_t *min_node;red_black_tree_node_t *max_node;
	red_black_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;red_black_tree_node_t *check_node;
	red_black_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = red_black_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = red_black_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	red_black_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
    }
    else
    {
    	one_count = (max_rank-min_rank+1);
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank));check_node = min_node;
    	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = red_black_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = red_black_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  	red_black_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (upper_min_rank-min_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));check_node = min_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	red_black_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  	red_black_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (max_rank-lower_max_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	vector_delete_min_max(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank));check_node = max_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
	vector_free(&one_node_vec);return 1;
}
int red_black_tree_rank_min_max_get(red_black_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;red_black_tree_node_t *one_node;vector_t one_node_vec;red_black_tree_node_t *min_node;red_black_tree_node_t *max_node;
	red_black_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;red_black_tree_node_t *check_node;
	red_black_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = red_black_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = red_black_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = red_black_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = red_black_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_node_vec);return 1;
}
int red_black_tree_min_max_remove(red_black_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;red_black_tree_node_t *one_node;vector_t one_node_vec;red_black_tree_node_t *min_node;red_black_tree_node_t *max_node;
	red_black_tree_node_t *result_node;red_black_tree_node_t *check_node;red_black_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = red_black_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = red_black_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    red_black_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = red_black_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = red_black_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  red_black_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	red_black_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  red_black_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
	vector_free(&one_node_vec);return 1;	
}
int red_black_tree_min_max_get(red_black_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;red_black_tree_node_t *one_node;vector_t one_node_vec;red_black_tree_node_t *min_node;red_black_tree_node_t *max_node;
	red_black_tree_node_t *result_node;red_black_tree_node_t *check_node;red_black_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = red_black_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = red_black_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = red_black_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = red_black_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
	vector_free(&one_node_vec);return 1;	
}
int red_black_tree_iterator_init(red_black_tree_t *tree, red_black_tree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return 0;}red_black_tree_node_get_all_item(tree->root, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
red_black_tree_iterator_t * red_black_tree_iterator_alloc(red_black_tree_t *tree)
{
	size_t size;red_black_tree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(red_black_tree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(red_black_tree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void red_black_tree_iterator_free(red_black_tree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int red_black_tree_iterator_next(red_black_tree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;		
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}	
}
void red_black_tree_item_dump(FILE *fd, red_black_tree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void red_black_tree_dump(FILE *fd, red_black_tree_t *tree)
{
	red_black_tree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = red_black_tree_iterator_alloc(tree);if(iterator == NULL){return ;}
	red_black_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(red_black_tree_iterator_next(iterator) == 1){red_black_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	red_black_tree_iterator_free(iterator);
}
void red_black_tree_dot_node_dump(FILE *fd, red_black_tree_node_t *node, int *nDump)
{
	int i;red_black_tree_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n%d:%d\\n",oneDump, node->type, node->depth, node->index, node->count, node->item_count);
	*nDump = (oneDump+1);
	if(node->item != NULL){fprintf(fd, "%s:%d\\n",((char *)(node->item->key)),node->item->dataVec.count);}
	if(node->type == RED_COLOR){fprintf(fd, "\", style=filled, fillcolor=hotpink];\n");}else{fprintf(fd, "\", style=filled, fillcolor=gray];\n");}
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			red_black_tree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void red_black_tree_dot_dump(red_black_tree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("red_black_tree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph red_black_tree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");red_black_tree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;red_black_tree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = red_black_tree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    red_black_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	red_black_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    red_black_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	red_black_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	red_black_tree_dot_dump(tree);
	red_black_tree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

btree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {int count;void *mem[5];} btree_array_t;
typedef struct {int span_count;int span_item_count;} btree_span_t;
typedef struct {int count;int max;btree_span_t *mem;} btree_span_vector_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} btree_item_t;
typedef struct btree_node {int type;int level;int index;struct btree_node *parent;btree_span_vector_t spanVec;btree_array_t itemArray;vector_t childVec;} btree_node_t;
typedef struct {int count;int item_count;btree_node_t *root;int check_item_count;} btree_t;
typedef struct {btree_t *tree;int vec_index;vector_t all_item_vec;btree_item_t *item;} btree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int btree_child_vector_insert(vector_t *vec, int index, void *item)
{
	btree_node_t *one_node;int i;if(index < 0 || index > vec->count){return 0;}if(item == NULL){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){one_node = vec->mem[i-1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
			vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int btree_child_vector_delete(vector_t *vec, int index, void **item)
{
	btree_node_t *one_node;int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1)
	{
		for(i = index; i < vec->count-1; i++){one_node = vec->mem[i+1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
	}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
void btree_array_init(btree_array_t *array)
{
	array->count = 0;array->mem[0] = NULL;array->mem[1] = NULL;array->mem[2] = NULL;array->mem[3] = NULL;array->mem[4] = NULL;
}
int btree_array_get(btree_array_t *array, int index, void **item){if(index < 0 || index >= array->count){return 0;}*item = array->mem[index];return 1;}
int btree_array_set(btree_array_t *array, int index, void *item){if(index < 0 || index >= array->count){return 0;}array->mem[index] = item;return 1;}
int btree_array_add(btree_array_t *array, void *item){if(array->count < 5){array->mem[array->count] = item;array->count++;return 1;}else{return 0;}}
int btree_array_insert(btree_array_t *array, int index, void *item)
{
	int i;if(index < 0 || index > array->count){return 0;}if(array->count >= 5){return 0;}
	if(index == array->count){array->mem[array->count] = item;array->count++;return 1;}
	else
	{
		for(i = array->count;i > index;i--){array->mem[i] = array->mem[i-1];}array->mem[index] = item;array->count++;return 1;
	}
}
int btree_array_delete(btree_array_t *array, int index, void **item)
{
	int i;if(index < 0 || index >= array->count){return 0;}if(item != NULL){*item = array->mem[index];}
	if(index < array->count-1){for(i = index; i < array->count-1; i++){array->mem[i] = array->mem[i+1];}}
	array->mem[array->count-1] = NULL;array->count--;return 1;
}
int btree_array_add_vec_two(btree_array_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int btree_array_add_vec_min_max_two(btree_array_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void btree_span_vector_init(btree_span_vector_t *span_vec)
{
	span_vec->count = 0;span_vec->max = 0;span_vec->mem = NULL;
}
void btree_span_vector_free(btree_span_vector_t *span_vec)
{
	if(span_vec->mem != NULL){free(span_vec->mem);span_vec->mem = NULL;}btree_span_vector_init(span_vec);
}
int btree_span_vector_get(btree_span_vector_t *span_vec, int index, btree_span_t *one_span)
{
	if(index < 0 || index >= span_vec->count){return 0;}*one_span = span_vec->mem[index];return 1;
}
int btree_span_vector_set(btree_span_vector_t *span_vec, int index, btree_span_t *one_span)
{
	if(index < 0 || index >= span_vec->count){return 0;}span_vec->mem[index] = *one_span;return 1;
}
int btree_span_vector_reserve(btree_span_vector_t *span_vec, int size)
{
	int max;void *temp;
	if(size <= span_vec->max){return 1;}
	else if(span_vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(span_vec->max > 0 && size > span_vec->max){max = span_vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(span_vec->mem, (max*sizeof(btree_span_t)));if(temp == NULL){return 0;}
	span_vec->mem = temp;span_vec->max = max;return 1;
}
int btree_span_vector_add(btree_span_vector_t *span_vec, btree_span_t *one_span)
{
	if(btree_span_vector_reserve(span_vec, (span_vec->count+1)) == 1)
	{
		span_vec->mem[span_vec->count] = *one_span;span_vec->count++;return 1;
	}
	else{return 0;}
}
int btree_span_vector_insert(btree_span_vector_t *span_vec, int index, btree_span_t *one_span)
{
	int i;if(index < 0 || index > span_vec->count){return 0;}
	if(btree_span_vector_reserve(span_vec, (span_vec->count+1)) == 1)
	{
		if(index == span_vec->count){span_vec->mem[span_vec->count] = *one_span;span_vec->count++;return 1;}
		else
		{
			for(i = span_vec->count;i > index;i--){span_vec->mem[i] = span_vec->mem[i-1];}span_vec->mem[index] = *one_span;span_vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int btree_span_vector_delete(btree_span_vector_t *span_vec, int index, btree_span_t *one_span)
{
	int i;btree_span_t temp_span;temp_span.span_count = 0;temp_span.span_item_count = 0;
	if(index < 0 || index >= span_vec->count){return 0;}if(one_span != NULL){*one_span = span_vec->mem[index];}
	if(index < span_vec->count-1){for(i = index; i < span_vec->count-1; i++){span_vec->mem[i] = span_vec->mem[i+1];}}
	span_vec->mem[span_vec->count-1] = temp_span;span_vec->count--;return 1;
}
int btree_span_vector_delete_min_max(btree_span_vector_t *span_vec, int min_index, int max_index)
{
	int i;int j;int count;btree_span_t temp_span;temp_span.span_count = 0;temp_span.span_item_count = 0;
	if(min_index < 0 || min_index >= span_vec->count){return 0;}if(max_index < 0 || max_index >= span_vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (span_vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < span_vec->count){span_vec->mem[j] = span_vec->mem[i];i++;j++;}
		for(i = j;i < span_vec->count;i++){span_vec->mem[i] = temp_span;}
	}
	else{for(i = min_index;i < span_vec->count;i++){span_vec->mem[i] = temp_span;}}
	span_vec->count -= count;return 1;
}
void btree_span_vector_set_span_vec(btree_span_vector_t *a, btree_span_vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int btree_item_array_binary_search(btree_array_t *array, byte_t *key, word_t key_len, int *result_index)
{
	btree_item_t *item;int low;int high;int mid;int one;int last;if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(array->count <= 0){return -1;}
	low = 0;high = (array->count-1);last = -1;
	while(low <= high)
	{
		mid = (low +(high-low)/2);item = array->mem[mid];one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0){last = mid;low = (mid+1);}else if(one > 0){high = (mid-1);}else{*result_index = mid;return 1;}
	}
	*result_index = last;return 0;
}
int btree_node_rank_search(btree_t *tree, btree_node_t *node, int rank, int *result_index)
{
	int i;btree_span_t *one_span;btree_item_t *one_item;int one_span_count;int one_count;int rank_count;int all_count;int index;btree_node_t *parent;	
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(node->parent == NULL){all_count = tree->count;}else{index = node->index;parent = node->parent;one_span = &(parent->spanVec.mem[index]);all_count = one_span->span_count;}
	if(rank < 1){return -1;}if(rank > all_count){return -1;}rank_count = 0;
	if(node->type == 0)
	{
		for(i = 0;i < node->itemArray.count;i++)
		{
			one_item = node->itemArray.mem[i];one_count = one_item->dataVec.count;
			if(rank >= (rank_count+1) && rank <= (rank_count+one_count)){*result_index = i;return 1;}
			rank_count += one_count;
		}
	}
	else
	{
		for(i = 0;i < node->itemArray.count;i++)
		{
			one_span = &(node->spanVec.mem[i]);one_item = node->itemArray.mem[i];
			one_span_count = one_span->span_count;one_count = one_item->dataVec.count;
			if(rank >= (rank_count+1) && rank <= (rank_count+one_span_count)){*result_index = i;return 0;}
			rank_count += one_span_count;
			if(rank >= (rank_count+1) && rank <= (rank_count+one_count)){*result_index = i;return 1;}
			rank_count += one_count;
		}
		one_span = &(node->spanVec.mem[i]);one_span_count = one_span->span_count;
		if(rank >= (rank_count+1) && rank <= (rank_count+one_span_count)){*result_index = i;return 0;}
		rank_count += one_span_count;
	}
	return -1;
}
int btree_item_init(btree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
btree_item_t * btree_item_alloc()
{
  size_t size;btree_item_t *item;size = sizeof(btree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  btree_item_init(item);return item;
}
int btree_item_other_free(btree_item_t *item){vector_free(&(item->dataVec));btree_item_init(item);return 1;}
void btree_item_free(btree_item_t *item){if(item != NULL){btree_item_other_free(item);free(item);}}
int btree_node_init(btree_node_t *node)
{
	node->type = 0;node->level = 0;node->index = 0;node->parent = NULL;btree_span_vector_init(&(node->spanVec));
	btree_array_init(&(node->itemArray));vector_init(&(node->childVec));return 1;
}
btree_node_t * btree_node_alloc(btree_t *tree, int type)
{
	int i;btree_span_vector_t oneVec;vector_t twoVec;btree_span_t temp_span;size_t size;btree_node_t *node;
	size = sizeof(btree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	if(type == 0)
	{
		btree_node_init(node);node->type = 0;btree_span_vector_init(&(node->spanVec));vector_init(&(node->childVec));
	}
	else
	{
		temp_span.span_count = 0;temp_span.span_item_count = 0;btree_span_vector_init(&oneVec);vector_init(&twoVec);
		if(btree_span_vector_reserve(&oneVec, (tree->check_item_count+2)) == 0){free(node);node = NULL;return node;}
		if(vector_reserve(&twoVec, (tree->check_item_count+2)) == 0){btree_span_vector_free(&oneVec);free(node);node = NULL;return node;}
		for(i = 0;i < oneVec.max;i++){oneVec.mem[i] = temp_span;}for(i = 0;i < twoVec.max;i++){twoVec.mem[i] = NULL;}
		btree_node_init(node);node->type = 1;
		btree_span_vector_set_span_vec(&oneVec, &(node->spanVec));btree_span_vector_init(&oneVec);
		vector_set_vec(&twoVec, &(node->childVec));vector_init(&twoVec);
	}
	return node;
}
int btree_node_other_free(btree_node_t *node)
{
	int i;btree_item_t *item;btree_array_t *array;array = &(node->itemArray);
	if(node->type == 0)
	{
		for(i = 0;i < array->count;i++){item = array->mem[i];if(item != NULL){btree_item_free(item);}array->mem[i] = NULL;}
	}
	else
	{
		for(i = 0;i < array->count;i++){item = array->mem[i];if(item != NULL){btree_item_free(item);}array->mem[i] = NULL;}
		btree_span_vector_free(&(node->spanVec));vector_free(&(node->childVec));
	}
	btree_node_init(node);return 1;
}
void btree_node_free(btree_node_t *node)
{
	if(node != NULL){btree_node_other_free(node);free(node);}
}
void btree_node_destroy(btree_node_t **node)
{
	int i;btree_node_t **btree_node;btree_node_t *one_node;btree_span_t temp_span;btree_span_vector_t *span_vec;vector_t *vec;
	if(node == NULL || *node == NULL){return ;}one_node = (*node);if(one_node->type == 0){btree_node_free((*node));*node = NULL;return ;}
	temp_span.span_count = 0;temp_span.span_item_count = 0;span_vec = &(one_node->spanVec);vec = &(one_node->childVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			btree_node = (btree_node_t **)(&(vec->mem[i]));btree_node_destroy(btree_node);vec->mem[i] = NULL;span_vec->mem[i] = temp_span;
		}
	}
	btree_node_free((*node));*node = NULL;
}
void btree_node_get_all_item(btree_node_t *node, vector_t *all_item_vec)
{
	int i;btree_node_t *one_node;btree_item_t *one_item;if(node == NULL){return ;}if(node->itemArray.count <= 0){return ;}
	if(node->type == 0)
	{
		btree_array_add_vec_two(&(node->itemArray), all_item_vec);
	}
	else
	{
		for(i = 0;i < node->itemArray.count;i++)
		{
			one_node = node->childVec.mem[i];one_item = node->itemArray.mem[i];
			if(one_node != NULL){btree_node_get_all_item(one_node, all_item_vec);}if(one_item != NULL){vector_add(all_item_vec, one_item);}
		}
		one_node = node->childVec.mem[i];if(one_node != NULL){btree_node_get_all_item(one_node, all_item_vec);}
	}
}
int btree_inorder_get_all_item(btree_t *tree, vector_t *all_item_vec)
{
	btree_node_t *last_node;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->type == 0){btree_array_add_vec_two(&(check_node->itemArray), all_item_vec);return 1;}
	else{last_node = check_node;check_node = check_node->childVec.mem[0];}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->type == 0)
			{
				btree_array_add_vec_two(&(check_node->itemArray), all_item_vec);last_node = check_node;check_node = check_node->parent;
			}
			else{last_node = check_node;check_node = check_node->childVec.mem[0];}
		}
		else
		{
			if(check_node == last_node->parent)
			{
				if(last_node->index < check_node->itemArray.count)
				{
					check_item_index = last_node->index;check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
					last_node = check_node;check_node = check_node->childVec.mem[check_item_index+1];
				}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else{return -1;}
		}
	}
	return 1;
}
int btree_inorder_get_all_item_two(btree_t *tree, vector_t *all_item_vec)
{
	btree_node_t *last_node;btree_node_t *check_node;int last_item_index;int check_item_index;btree_item_t *check_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->type == 0)
	{
		check_item_index = 0;check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		last_node = check_node;last_item_index = check_item_index;
	}
	else{last_node = check_node;check_node = check_node->childVec.mem[0];}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->type == 0)
			{
				check_item_index = 0;check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
				last_node = check_node;last_item_index = check_item_index;
			}
			else{last_node = check_node;check_node = check_node->childVec.mem[0];}
		}
		else
		{
			if(check_node == last_node->parent)
			{
				if(last_node->index < check_node->itemArray.count)
				{
					check_item_index = last_node->index;check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
					last_node = check_node;check_node = check_node->childVec.mem[check_item_index+1];
				}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(last_node == check_node)
				{
					if(check_node->type == 0)
					{
						if(last_item_index < (check_node->itemArray.count-1))
						{
							check_item_index = (last_item_index+1);check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
							last_node = check_node;last_item_index = check_item_index;
						}
						else
						{
							if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
						}
					}
					else{return -1;}
				}
				else{return -1;}
			}
		}
	}
	return 1;
}
int btree_inorder_get_next_node_item(btree_t *tree, btree_node_t *node, int item_index, btree_node_t **result_node, int *result_item_index)
{
	btree_node_t *last_node;btree_node_t *check_node;int last_item_index;int check_item_index;if(tree == NULL){return -1;}
	if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(item_index < 0 || item_index >= node->itemArray.count){return -1;}*result_node = NULL;check_node = node;check_item_index = item_index;
	if(check_node->type == 0){last_node = check_node;last_item_index = check_item_index;}
	else{last_node = check_node;check_node = check_node->childVec.mem[check_item_index+1];}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->type == 0)
			{
				check_item_index = 0;*result_node = check_node;*result_item_index = check_item_index;return 1;
			}
			else{last_node = check_node;check_node = check_node->childVec.mem[0];}
		}
		else
		{
			if(check_node == last_node->parent)
			{
				if(last_node->index < check_node->itemArray.count)
				{
					check_item_index = last_node->index;*result_node = check_node;*result_item_index = check_item_index;return 1;
				}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(last_node == check_node)
				{
					if(check_node->type == 0)
					{
						if(last_item_index < (check_node->itemArray.count-1))
						{
							check_item_index = (last_item_index+1);*result_node = check_node;*result_item_index = check_item_index;return 1;
						}
						else
						{
							if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
						}
					}
					else{return -1;}
				}
				else{return -1;}
			}
		}
	}
	return 1;
}
int btree_inorder_get_prev_node_item(btree_t *tree, btree_node_t *node, int item_index, btree_node_t **result_node, int *result_item_index)
{
	btree_node_t *last_node;btree_node_t *check_node;int last_item_index;int check_item_index;if(tree == NULL){return -1;}
	if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(item_index < 0 || item_index >= node->itemArray.count){return -1;}*result_node = NULL;check_node = node;check_item_index = item_index;
	if(check_node->type == 0){last_node = check_node;last_item_index = check_item_index;}
	else{last_node = check_node;check_node = check_node->childVec.mem[check_item_index];}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->type == 0)
			{
				check_item_index = (check_node->itemArray.count-1);*result_node = check_node;*result_item_index = check_item_index;return 1;
			}
			else{last_node = check_node;check_node = check_node->childVec.mem[check_node->childVec.count-1];}
		}
		else
		{
			if(check_node == last_node->parent)
			{
				if(last_node->index > 0)
				{
					check_item_index = (last_node->index-1);*result_node = check_node;*result_item_index = check_item_index;return 1;
				}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(last_node == check_node)
				{
					if(check_node->type == 0)
					{
						if(last_item_index > 0)
						{
							check_item_index = (last_item_index-1);*result_node = check_node;*result_item_index = check_item_index;return 1;
						}
						else
						{
							if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
						}
					}
					else{return -1;}
				}
				else{return -1;}
			}
		}
	}
	return 1;
}
btree_t * btree_alloc()
{
	size_t size;btree_t *tree;size = sizeof(btree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;tree->count = 0;tree->item_count = 0;tree->check_item_count = 3;return tree;
}
void btree_destroy(btree_t *tree)
{
	btree_node_t **btree_node;if(tree == NULL){return ;}if(tree->root == NULL){free(tree);return ;}
	btree_node = &(tree->root);btree_node_destroy(btree_node);tree->root = NULL;free(tree);
}
int btree_find_rank(btree_t *tree, btree_node_t *node, int rank, btree_node_t **result_node, int *result_item_index, int *result_rank_count, int *result_rank_item_count)
{
	btree_node_t *check_node;int check_result;int check_index;void *child;int temp_result;int i;btree_span_t *one_span;btree_item_t *one_item;
	int one_span_count;int one_count;int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}if(rank < 1){return -1;}if(rank > tree->count){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= 0){return -1;}
		if(check_node->childVec.count <= 0)
		{
			check_result = btree_node_rank_search(tree, check_node, (rank-rank_count), &check_index);
			if(check_result == -1){return -1;}
			else if(check_result == 1)
			{
				for(i = 0;i <= check_index;i++)
				{
					one_item = check_node->itemArray.mem[i];one_count = one_item->dataVec.count;rank_count += one_count;rank_item_count += 1;
				}
				*result_node = check_node;*result_item_index = check_index;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
			}
			else
			{
				return 0;
			}
		}
		else
		{
			check_result = btree_node_rank_search(tree, check_node, (rank-rank_count), &check_index);
			if(check_result == -1){return -1;}
			else if(check_result == 1)
			{
				for(i = 0;i <= check_index;i++)
				{
					one_span = &(check_node->spanVec.mem[i]);one_item = check_node->itemArray.mem[i];
					one_span_count = one_span->span_count;one_count = one_item->dataVec.count;
					rank_count += one_span_count;rank_item_count += one_span->span_item_count;
					rank_count += one_count;rank_item_count += 1;
				}
				*result_node = check_node;*result_item_index = check_index;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
			}
			else
			{
				for(i = 0;i < check_index;i++)
				{
					one_span = &(check_node->spanVec.mem[i]);one_item = check_node->itemArray.mem[i];
					one_span_count = one_span->span_count;one_count = one_item->dataVec.count;
					rank_count += one_span_count;rank_item_count += one_span->span_item_count;
					rank_count += one_count;rank_item_count += 1;					
				}
				temp_result = vector_get(&(check_node->childVec), check_index, &child);if(temp_result == 0){return -1;}else{check_node = child;}
			}
		}
	}
	if(check_node == NULL){return -1;}return 0;
}
int btree_find_base(btree_t *tree, btree_node_t *node, byte_t *key, word_t key_len, btree_node_t **result_node, int *result_item_index, int *result_rank_count, int *result_rank_item_count)
{
	btree_node_t *check_node;int check_result;int check_index;btree_array_t *array;void *child;int temp_result;int i;btree_span_t *one_span;btree_item_t *one_item;
	int one_span_count;int one_count;int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= 0){return -1;}
		if(check_node->childVec.count <= 0)
		{
			array = &(check_node->itemArray);check_result = btree_item_array_binary_search(array, key, key_len, &check_index);
			if(check_result == -1){return -1;}
			else if(check_result == 1)
			{
				for(i = 0;i <= check_index;i++)
				{
					one_item = check_node->itemArray.mem[i];one_count = one_item->dataVec.count;rank_count += one_count;rank_item_count += 1;
				}
				*result_node = check_node;*result_item_index = check_index;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
			}
			else
			{
				for(i = 0;i <= check_index;i++)
				{
					one_item = check_node->itemArray.mem[i];one_count = one_item->dataVec.count;rank_count += one_count;rank_item_count += 1;
				}
				*result_node = check_node;*result_item_index = check_index;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 0;
			}
		}
		else
		{
			array = &(check_node->itemArray);check_result = btree_item_array_binary_search(array, key, key_len, &check_index);
			if(check_result == -1){return -1;}
			else if(check_result == 1)
			{
				for(i = 0;i <= check_index;i++)
				{
					one_span = &(check_node->spanVec.mem[i]);one_item = check_node->itemArray.mem[i];
					one_span_count = one_span->span_count;one_count = one_item->dataVec.count;
					rank_count += one_span_count;rank_item_count += one_span->span_item_count;
					rank_count += one_count;rank_item_count += 1;
				}
				*result_node = check_node;*result_item_index = check_index;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
			}
			else
			{
				for(i = 0;i <= check_index;i++)
				{
					one_span = &(check_node->spanVec.mem[i]);one_item = check_node->itemArray.mem[i];
					one_span_count = one_span->span_count;one_count = one_item->dataVec.count;
					rank_count += one_span_count;rank_item_count += one_span->span_item_count;
					rank_count += one_count;rank_item_count += 1;					
				}
				temp_result = vector_get(&(check_node->childVec), (check_index+1), &child);if(temp_result == 0){return -1;}else{check_node = child;}
			}
		}
	}
	if(check_node == NULL){return -1;}return 0;
}
int btree_get_rank(btree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int btree_check_exist(btree_t *tree, byte_t *key, word_t key_len)
{
	btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}return 1;
}
int btree_get(btree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;btree_item_t *result_item;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	result_item = result_node->itemArray.mem[result_item_index];if(result_data_vec != NULL){vector_copy_vec(&(result_item->dataVec), result_data_vec);}
	return 1;
}
int btree_find_max(btree_t *tree, btree_node_t *node, btree_node_t **result_node, int *result_item_index)
{
	btree_node_t *check_node;int check_index;void *child;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= 0){return -1;}
		if(check_node->childVec.count <= 0)
		{
			*result_node = check_node;*result_item_index = (check_node->itemArray.count-1);return 1;
		}
		else
		{
			check_index = (check_node->itemArray.count-1);
			temp_result = vector_get(&(check_node->childVec), (check_index+1), &child);if(temp_result == 0){return -1;}else{check_node = child;}
		}
	}
	if(check_node == NULL){return -1;}return 0;
}
int btree_find_min(btree_t *tree, btree_node_t *node, btree_node_t **result_node, int *result_item_index)
{
	btree_node_t *check_node;int check_index;void *child;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= 0){return -1;}
		if(check_node->childVec.count <= 0)
		{
			*result_node = check_node;*result_item_index = 0;return 1;
		}
		else
		{
			check_index = 0;
			temp_result = vector_get(&(check_node->childVec), check_index, &child);if(temp_result == 0){return -1;}else{check_node = child;}
		}
	}
	if(check_node == NULL){return -1;}return 0;	
}
int btree_find_first_upper_equal(btree_t *tree, btree_node_t *node, byte_t *key, word_t key_len, btree_node_t **result_node, int *result_item_index)
{	
	btree_node_t *one_node;int one_item_index;int one_rank_count;int one_rank_item_count;int temp_result;
	btree_node_t *upper_node;int upper_item_index;btree_node_t *lower_node;int lower_item_index;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}*result_node = NULL;one_node = NULL;one_rank_count = 0;one_rank_item_count = 0;
	temp_result = btree_find_base(tree, tree->root, key, key_len, &one_node, &one_item_index, &one_rank_count, &one_rank_item_count);
	if(temp_result == -1){return -1;}if(one_node == NULL){return 0;}
	if(temp_result == 1)
	{
		*result_node = one_node;*result_item_index = one_item_index;return 1;
	}
	if(one_item_index < 0)
	{
		upper_node = one_node;upper_item_index = 0;lower_node = NULL;
		temp_result = btree_inorder_get_prev_node_item(tree, upper_node, upper_item_index, &lower_node, &lower_item_index);if(temp_result == -1){return -1;}
		*result_node = upper_node;*result_item_index = upper_item_index;
	}
	else if(one_item_index >= (one_node->itemArray.count-1))
	{
		upper_node = NULL;lower_node = one_node;lower_item_index = one_item_index;
		temp_result = btree_inorder_get_next_node_item(tree, lower_node, lower_item_index, &upper_node, &upper_item_index);if(temp_result == -1){return -1;}
		if(upper_node == NULL){return 0;}else{*result_node = upper_node;*result_item_index = upper_item_index;}
	}
	else
	{
		upper_node = one_node;upper_item_index = (one_item_index+1);lower_node = one_node;lower_item_index = one_item_index;
		*result_node = upper_node;*result_item_index = upper_item_index;
	}
	return 1;
}
int btree_find_last_lower_equal(btree_t *tree, btree_node_t *node, byte_t *key, word_t key_len, btree_node_t **result_node, int *result_item_index)
{
	btree_node_t *one_node;int one_item_index;int one_rank_count;int one_rank_item_count;int temp_result;
	btree_node_t *upper_node;int upper_item_index;btree_node_t *lower_node;int lower_item_index;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}*result_node = NULL;one_node = NULL;one_rank_count = 0;one_rank_item_count = 0;
	temp_result = btree_find_base(tree, tree->root, key, key_len, &one_node, &one_item_index, &one_rank_count, &one_rank_item_count);
	if(temp_result == -1){return -1;}if(one_node == NULL){return 0;}
	if(temp_result == 1)
	{
		*result_node = one_node;*result_item_index = one_item_index;return 1;
	}
	if(one_item_index < 0)
	{
		upper_node = one_node;upper_item_index = 0;lower_node = NULL;
		temp_result = btree_inorder_get_prev_node_item(tree, upper_node, upper_item_index, &lower_node, &lower_item_index);if(temp_result == -1){return -1;}
		if(lower_node == NULL){return 0;}else{*result_node = lower_node;*result_item_index = lower_item_index;}
	}
	else if(one_item_index >= (one_node->itemArray.count-1))
	{
		upper_node = NULL;lower_node = one_node;lower_item_index = one_item_index;
		temp_result = btree_inorder_get_next_node_item(tree, lower_node, lower_item_index, &upper_node, &upper_item_index);if(temp_result == -1){return -1;}
		*result_node = lower_node;*result_item_index = lower_item_index;
	}
	else
	{
		upper_node = one_node;upper_item_index = (one_item_index+1);lower_node = one_node;lower_item_index = one_item_index;
		*result_node = lower_node;*result_item_index = lower_item_index;
	}
	return 1;
}
int btree_get_min_max_item(btree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *all_item_vec)
{
	btree_node_t *result_node;int result_item_index;int temp_result;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;
	btree_node_t *min_node;int min_item_index;btree_item_t *min_item;btree_node_t *max_node;int max_item_index;btree_item_t *max_item;
	btree_node_t *next_node;int next_item_index;vector_t one_item_vec;vector_init(&one_item_vec);
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = btree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;temp_result = btree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	if(min_item == max_item){vector_add(all_item_vec, min_item);vector_free(&one_item_vec);return 1;}
	vector_add(&one_item_vec, min_item);
	next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	while(check_item != NULL && check_item != max_item)
	{
		vector_add(&one_item_vec, check_item);
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	}
	vector_add(&one_item_vec, max_item);vector_add_vec_two(&one_item_vec, all_item_vec);vector_free(&one_item_vec);return 1;
}
int btree_get_min_max_item_two(btree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *all_item_vec)
{
	btree_node_t *result_node;int result_item_index;int temp_result;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;
	btree_node_t *min_node;int min_item_index;btree_item_t *min_item;btree_node_t *max_node;int max_item_index;btree_item_t *max_item;
	btree_node_t *next_node;int next_item_index;vector_t one_item_vec;vector_init(&one_item_vec);
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = btree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;temp_result = btree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	if(min_item == max_item)
	{
		vector_add(&one_item_vec, min_item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
		vector_free(&one_item_vec);return 1;
	}
	vector_add(&one_item_vec, min_item);
	next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	while(check_item != NULL && check_item != max_item)
	{
		vector_add(&one_item_vec, check_item);
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	}
	vector_add(&one_item_vec, max_item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
	vector_free(&one_item_vec);return 1;
}
int btree_inorder_get_all_item_other(btree_t *tree, vector_t *all_item_vec)
{
	btree_node_t *result_node;int result_item_index;int temp_result;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;
	btree_node_t *next_node;int next_item_index;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;
	temp_result = btree_find_min(tree, tree->root, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	check_node = result_node;check_item_index = result_item_index;
	while(check_node != NULL)
	{
		check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){return -1;}if(next_node == NULL){return 1;}check_node = next_node;check_item_index = next_item_index;
	}
	return 1;
}
int btree_inorder_get_all_item_other_two(btree_t *tree, vector_t *all_item_vec)
{
	btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;
	btree_node_t *check_node;int check_item_index;btree_item_t *check_item;btree_node_t *next_node;int next_item_index;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, 1, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	check_node = result_node;check_item_index = result_item_index;
	while(check_node != NULL)
	{
		check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){return -1;}if(next_node == NULL){return 1;}check_node = next_node;check_item_index = next_item_index;
	}
	return 1;	
}
int btree_inorder_get_all_item_another(btree_t *tree, vector_t *all_item_vec)
{
	btree_node_t *result_node;int result_item_index;int temp_result;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;
	btree_node_t *prev_node;int prev_item_index;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;
	temp_result = btree_find_max(tree, tree->root, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	check_node = result_node;check_item_index = result_item_index;
	while(check_node != NULL)
	{
		check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		prev_node = NULL;temp_result = btree_inorder_get_prev_node_item(tree, check_node, check_item_index, &prev_node, &prev_item_index);
		if(temp_result == -1){return -1;}if(prev_node == NULL){return 1;}check_node = prev_node;check_item_index = prev_item_index;
	}
	return 1;
}
int btree_inorder_get_all_item_another_two(btree_t *tree, vector_t *all_item_vec)
{
	btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;
	btree_node_t *check_node;int check_item_index;btree_item_t *check_item;btree_node_t *prev_node;int prev_item_index;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, tree->count, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	check_node = result_node;check_item_index = result_item_index;
	while(check_node != NULL)
	{
		check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		prev_node = NULL;temp_result = btree_inorder_get_prev_node_item(tree, check_node, check_item_index, &prev_node, &prev_item_index);
		if(temp_result == -1){return -1;}if(prev_node == NULL){return 1;}check_node = prev_node;check_item_index = prev_item_index;
	}
	return 1;
}
int btree_node_give_left(btree_t *tree, btree_node_t *node, btree_node_t *left_node)
{
	int index;btree_node_t *parent;btree_item_t *parent_item;btree_item_t *one_item;btree_node_t *one_node;int one_count;
	btree_span_t one_span;btree_span_t *temp_span;btree_item_t *temp_item;int i;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(left_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != left_node->type){return -1;}
	index = node->index;parent = node->parent;parent_item = parent->itemArray.mem[index-1];one_count = left_node->itemArray.count;
	if(node->type == 0)
	{
		one_item = node->itemArray.mem[0];btree_array_delete(&(node->itemArray), 0, NULL);parent->itemArray.mem[index-1] = one_item;
		btree_array_insert(&(left_node->itemArray), one_count, parent_item);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < left_node->itemArray.count;i++)
		{
			temp_item = left_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index-1] = one_span;
	}
	else
	{
		one_item = node->itemArray.mem[0];btree_array_delete(&(node->itemArray), 0, NULL);parent->itemArray.mem[index-1] = one_item;
		btree_array_insert(&(left_node->itemArray), one_count, parent_item);
		one_node = node->childVec.mem[0];btree_child_vector_delete(&(node->childVec), 0, NULL);
		btree_child_vector_insert(&(left_node->childVec), (one_count+1), one_node);one_node->index = (one_count+1);one_node->parent = left_node;
		one_span = node->spanVec.mem[0];btree_span_vector_delete(&(node->spanVec), 0, NULL);
		btree_span_vector_insert(&(left_node->spanVec), (one_count+1), &one_span);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < left_node->itemArray.count;i++)
		{
			temp_span = &(left_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = left_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(left_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index-1] = one_span;
	}
	return 1;
}
int btree_node_give_right(btree_t *tree, btree_node_t *node, btree_node_t *right_node)
{
	int index;btree_node_t *parent;btree_item_t *parent_item;btree_item_t *one_item;btree_node_t *one_node;int one_count;
	btree_span_t one_span;btree_span_t *temp_span;btree_item_t *temp_item;int i;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(right_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != right_node->type){return -1;}
	index = node->index;parent = node->parent;parent_item = parent->itemArray.mem[index];one_count = node->itemArray.count;
	if(node->type == 0)
	{
		one_item = node->itemArray.mem[one_count-1];btree_array_delete(&(node->itemArray), (one_count-1), NULL);parent->itemArray.mem[index] = one_item;
		btree_array_insert(&(right_node->itemArray), 0, parent_item);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < right_node->itemArray.count;i++)
		{
			temp_item = right_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index+1] = one_span;
	}
	else
	{
		one_item = node->itemArray.mem[one_count-1];btree_array_delete(&(node->itemArray), (one_count-1), NULL);parent->itemArray.mem[index] = one_item;
		btree_array_insert(&(right_node->itemArray), 0, parent_item);
		one_node = node->childVec.mem[one_count];btree_child_vector_delete(&(node->childVec), one_count, NULL);
		btree_child_vector_insert(&(right_node->childVec), 0, one_node);one_node->index = 0;one_node->parent = right_node;
		one_span = node->spanVec.mem[one_count];btree_span_vector_delete(&(node->spanVec), one_count, NULL);
		btree_span_vector_insert(&(right_node->spanVec), 0, &one_span);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < right_node->itemArray.count;i++)
		{
			temp_span = &(right_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = right_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(right_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index+1] = one_span;
	}
	return 1;	
}
int btree_node_split(btree_t *tree, btree_node_t *node, btree_node_t *split_node, btree_node_t *root_node)
{
	int i;int j;int mid;btree_item_t *split_item;int index;btree_node_t *parent;btree_node_t *one_node;btree_item_t *one_item;
	int child_count;int one_child_count;int level;btree_span_t one_span;btree_span_t init_span;btree_span_t *temp_span;btree_item_t *temp_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(split_node == NULL){return -1;}
	if(node->itemArray.count <= tree->check_item_count){return -1;}if(node->parent == NULL && root_node == NULL){return -1;}
	if(node->parent != NULL && root_node != NULL){return -1;}if(node->type != split_node->type){return -1;}
	if(root_node != NULL && root_node->type == 0){return -1;}
	if(node->type == 0)
	{
		if(node->parent != NULL)
		{
			mid = (node->itemArray.count/2);split_item = node->itemArray.mem[mid];node->itemArray.mem[mid] = NULL;
			index = node->index;parent = node->parent;level = node->level;
			split_node->level = level;split_node->index = (index+1);split_node->parent = parent;
			i = (mid+1);j = 0;
			while(i < node->itemArray.count)
			{
				one_item = node->itemArray.mem[i];split_node->itemArray.mem[j] = one_item;node->itemArray.mem[i] = NULL;
				i++;j++;
			}
			node->itemArray.count = mid;split_node->itemArray.count = j;
			btree_array_insert(&(parent->itemArray), index, split_item);btree_child_vector_insert(&(parent->childVec), (index+1), split_node);
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < split_node->itemArray.count;i++)
			{
				temp_item = split_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			btree_span_vector_insert(&(parent->spanVec), (index+1), &one_span);
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < node->itemArray.count;i++)
			{
				temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			parent->spanVec.mem[index] = one_span;
		}
		else
		{
			mid = (node->itemArray.count/2);split_item = node->itemArray.mem[mid];node->itemArray.mem[mid] = NULL;
			level = node->level;root_node->level = (level+1);root_node->index = 0;root_node->parent = NULL;
			node->index = 0;node->parent = root_node;split_node->level = level;split_node->index = 1;split_node->parent = root_node;
			i = (mid+1);j = 0;
			while(i < node->itemArray.count)
			{
				one_item = node->itemArray.mem[i];split_node->itemArray.mem[j] = one_item;node->itemArray.mem[i] = NULL;
				i++;j++;
			}
			node->itemArray.count = mid;split_node->itemArray.count = j;
			root_node->itemArray.mem[0]	= split_item;root_node->childVec.mem[0] = node;root_node->childVec.mem[1] = split_node;
			root_node->itemArray.count = 1;root_node->childVec.count = 2;tree->root = root_node;
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < node->itemArray.count;i++)
			{
				temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			root_node->spanVec.mem[0] = one_span;
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < split_node->itemArray.count;i++)
			{
				temp_item = split_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			root_node->spanVec.mem[1] = one_span;root_node->spanVec.count = 2;
		}
	}
	else
	{
		if(node->parent != NULL)
		{
			mid = (node->itemArray.count/2);split_item = node->itemArray.mem[mid];node->itemArray.mem[mid] = NULL;
			child_count = node->childVec.count;one_child_count = 0;index = node->index;parent = node->parent;level = node->level;
			split_node->level = level;split_node->index = (index+1);split_node->parent = parent;
			i = (mid+1);j = 0;init_span.span_count = 0;init_span.span_item_count = 0;
			while(i < node->itemArray.count)
			{
				one_item = node->itemArray.mem[i];split_node->itemArray.mem[j] = one_item;node->itemArray.mem[i] = NULL;
				one_node = node->childVec.mem[i];split_node->childVec.mem[j] = one_node;node->childVec.mem[i] = NULL;
				if(one_node != NULL){one_node->index = j;one_node->parent = split_node;one_child_count++;}
				one_span = node->spanVec.mem[i];split_node->spanVec.mem[j] = one_span;node->spanVec.mem[i] = init_span;
				i++;j++;
			}
			one_node = node->childVec.mem[i];split_node->childVec.mem[j] = one_node;node->childVec.mem[i] = NULL;
			if(one_node != NULL){one_node->index = j;one_node->parent = split_node;one_child_count++;}
			one_span = node->spanVec.mem[i];split_node->spanVec.mem[j] = one_span;node->spanVec.mem[i] = init_span;
			node->itemArray.count = mid;split_node->itemArray.count = j;
			node->childVec.count = (child_count-one_child_count);split_node->childVec.count = one_child_count;
			node->spanVec.count = (child_count-one_child_count);split_node->spanVec.count = one_child_count;
			btree_array_insert(&(parent->itemArray), index, split_item);btree_child_vector_insert(&(parent->childVec), (index+1), split_node);
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < split_node->itemArray.count;i++)
			{
				temp_span = &(split_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				temp_item = split_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			temp_span = &(split_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			btree_span_vector_insert(&(parent->spanVec), (index+1), &one_span);
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < node->itemArray.count;i++)
			{
				temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			parent->spanVec.mem[index] = one_span;
		}
		else
		{
			mid = (node->itemArray.count/2);split_item = node->itemArray.mem[mid];node->itemArray.mem[mid] = NULL;
			child_count = node->childVec.count;one_child_count = 0;
			level = node->level;root_node->level = (level+1);root_node->index = 0;root_node->parent = NULL;
			node->index = 0;node->parent = root_node;split_node->level = level;split_node->index = 1;split_node->parent = root_node;
			i = (mid+1);j = 0;init_span.span_count = 0;init_span.span_item_count = 0;
			while(i < node->itemArray.count)
			{
				one_item = node->itemArray.mem[i];split_node->itemArray.mem[j] = one_item;node->itemArray.mem[i] = NULL;
				one_node = node->childVec.mem[i];split_node->childVec.mem[j] = one_node;node->childVec.mem[i] = NULL;
				if(one_node != NULL){one_node->index = j;one_node->parent = split_node;one_child_count++;}
				one_span = node->spanVec.mem[i];split_node->spanVec.mem[j] = one_span;node->spanVec.mem[i] = init_span;
				i++;j++;
			}
			one_node = node->childVec.mem[i];split_node->childVec.mem[j] = one_node;node->childVec.mem[i] = NULL;
			if(one_node != NULL){one_node->index = j;one_node->parent = split_node;one_child_count++;}
			one_span = node->spanVec.mem[i];split_node->spanVec.mem[j] = one_span;node->spanVec.mem[i] = init_span;
			node->itemArray.count = mid;split_node->itemArray.count = j;
			node->childVec.count = (child_count-one_child_count);split_node->childVec.count = one_child_count;
			node->spanVec.count = (child_count-one_child_count);split_node->spanVec.count = one_child_count;
			root_node->itemArray.mem[0]	= split_item;root_node->childVec.mem[0] = node;root_node->childVec.mem[1] = split_node;
			root_node->itemArray.count = 1;root_node->childVec.count = 2;tree->root = root_node;
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < node->itemArray.count;i++)
			{
				temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			root_node->spanVec.mem[0] = one_span;
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < split_node->itemArray.count;i++)
			{
				temp_span = &(split_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				temp_item = split_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			temp_span = &(split_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			root_node->spanVec.mem[1] = one_span;root_node->spanVec.count = 2;
		}
	}
	return 1;
}
int btree_insert(btree_t *tree, byte_t *key, word_t key_len, void *value)
{
	int i;int j;int one_type_array[64];btree_node_t *one_node_array[64];int one_node_index;int one_node_count;int give_result;int give_level;
	btree_item_t *one_item;btree_node_t *one_node;btree_node_t *check_node;int check_index;btree_node_t *check_parent;int check_count;
	btree_node_t *left_node;btree_node_t *right_node;btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;btree_span_t one_span;btree_span_t *temp_span;btree_item_t *temp_item;
	if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = btree_item_alloc();if(one_item == NULL){return 0;}
		one_node = btree_node_alloc(tree, 0);if(one_node == NULL){btree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_node->level = 0;one_node->index = 0;one_node->parent = NULL;one_node->itemArray.mem[0] = one_item;one_node->itemArray.count = 1;
		tree->root = one_node;tree->count = 1;tree->item_count = 1;return 1;
	}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->itemArray.mem[result_item_index];vector_add(&(one_item->dataVec), value);tree->count++;
		check_node = result_node;
		while(check_node != NULL)
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
					temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		return 1;
	}
	one_node_count = 0;give_result = 0;give_level = 0;check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count < tree->check_item_count){break;}
		if(check_node->parent != NULL)
		{
			check_index = check_node->index;check_parent = check_node->parent;check_count = check_parent->itemArray.count;left_node = NULL;right_node = NULL;
			if(check_index <= 0){left_node = NULL;right_node = check_parent->childVec.mem[check_index+1];}
			else if(check_index >= check_count){left_node = check_parent->childVec.mem[check_index-1];right_node = NULL;}
			else{left_node = check_parent->childVec.mem[check_index-1];right_node = check_parent->childVec.mem[check_index+1];}
			if(left_node == NULL && right_node == NULL){return -1;}
			if(left_node != NULL && left_node->itemArray.count < tree->check_item_count)
			{
				give_result = -1;give_level = check_node->level;break;
			}
			else
			{
				if(right_node != NULL && right_node->itemArray.count < tree->check_item_count)
				{
					give_result = 1;give_level = check_node->level;break;
				}
				else
				{
					one_type_array[one_node_count] = check_node->type;one_node_count += 1;check_node = check_node->parent;
				}
			}
		}
		else{one_type_array[one_node_count] = check_node->type;one_type_array[one_node_count+1] = 1;one_node_count += 2;break;}
	}
	if(one_node_count == 0 && give_result == 0)
	{
		one_item = btree_item_alloc();if(one_item == NULL){return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		btree_array_insert(&(result_node->itemArray), (result_item_index+1), one_item);
		tree->count++;tree->item_count++;
		check_node = result_node;
		while(check_node != NULL)
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
					temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		return 1;
	}
	for(i = 0;i < one_node_count;i++){one_node = btree_node_alloc(tree, one_type_array[i]);if(one_node == NULL){break;}one_node_array[i] = one_node;}
	if(i != one_node_count){for(j = 0;j < i;j++){one_node = one_node_array[j];if(one_node != NULL){btree_node_free(one_node);}}return 0;}
	one_item = btree_item_alloc();
	if(one_item == NULL){for(j = 0;j < one_node_count;j++){one_node = one_node_array[j];if(one_node != NULL){btree_node_free(one_node);}}return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	btree_array_insert(&(result_node->itemArray), (result_item_index+1), one_item);
	tree->count++;tree->item_count++;one_node_index = 0;check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= tree->check_item_count)
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
					temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		else
		{
			if(check_node->parent != NULL)
			{
				if(give_result != 0 && give_level == check_node->level)
				{
					if(give_result == -1)
					{
						check_index = check_node->index;check_parent = check_node->parent;left_node = check_parent->childVec.mem[check_index-1];
						btree_node_give_left(tree, check_node, left_node);check_node = check_parent;
					}
					else
					{
						check_index = check_node->index;check_parent = check_node->parent;right_node = check_parent->childVec.mem[check_index+1];
						btree_node_give_right(tree, check_node, right_node);check_node = check_parent;
					}
				}
				else
				{
					btree_node_split(tree, check_node, one_node_array[one_node_index], NULL);one_node_index += 1;check_node = check_node->parent;
				}
			}
			else
			{
				btree_node_split(tree, check_node, one_node_array[one_node_index], one_node_array[one_node_index+1]);one_node_index += 2;break;
			}
		}
	}
	return 1;
}
int btree_node_borrow_left(btree_t *tree, btree_node_t *node, btree_node_t *left_node)
{
	int index;btree_node_t *parent;btree_item_t *parent_item;btree_item_t *one_item;btree_node_t *one_node;int one_count;
	btree_span_t one_span;btree_span_t *temp_span;btree_item_t *temp_item;int i;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(left_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != left_node->type){return -1;}
	index = node->index;parent = node->parent;parent_item = parent->itemArray.mem[index-1];one_count = left_node->itemArray.count;
	if(node->type == 0)
	{
		one_item = left_node->itemArray.mem[one_count-1];
		btree_array_delete(&(left_node->itemArray), (one_count-1), NULL);parent->itemArray.mem[index-1] = one_item;
		btree_array_insert(&(node->itemArray), 0, parent_item);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < left_node->itemArray.count;i++)
		{
			temp_item = left_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index-1] = one_span;
	}
	else
	{
		one_item = left_node->itemArray.mem[one_count-1];
		btree_array_delete(&(left_node->itemArray), (one_count-1), NULL);parent->itemArray.mem[index-1] = one_item;
		btree_array_insert(&(node->itemArray), 0, parent_item);
		one_node = left_node->childVec.mem[one_count];
		btree_child_vector_delete(&(left_node->childVec), one_count, NULL);
		btree_child_vector_insert(&(node->childVec), 0, one_node);one_node->index = 0;one_node->parent = node;
		one_span = left_node->spanVec.mem[one_count];btree_span_vector_delete(&(left_node->spanVec), one_count, NULL);
		btree_span_vector_insert(&(node->spanVec), 0, &one_span);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < left_node->itemArray.count;i++)
		{
			temp_span = &(left_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = left_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(left_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index-1] = one_span;
	}
	return 1;
}
int btree_node_borrow_right(btree_t *tree, btree_node_t *node, btree_node_t *right_node)
{
	int index;btree_node_t *parent;btree_item_t *parent_item;btree_item_t *one_item;btree_node_t *one_node;int one_count;
	btree_span_t one_span;btree_span_t *temp_span;btree_item_t *temp_item;int i;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(right_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != right_node->type){return -1;}
	index = node->index;parent = node->parent;parent_item = parent->itemArray.mem[index];one_count = node->itemArray.count;
	if(node->type == 0)
	{
		one_item = right_node->itemArray.mem[0];
		btree_array_delete(&(right_node->itemArray), 0, NULL);parent->itemArray.mem[index] = one_item;
		btree_array_insert(&(node->itemArray), one_count, parent_item);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < right_node->itemArray.count;i++)
		{
			temp_item = right_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index+1] = one_span;
	}
	else
	{
		one_item = right_node->itemArray.mem[0];
		btree_array_delete(&(right_node->itemArray), 0, NULL);parent->itemArray.mem[index] = one_item;
		btree_array_insert(&(node->itemArray), one_count, parent_item);
		one_node = right_node->childVec.mem[0];
		btree_child_vector_delete(&(right_node->childVec), 0, NULL);
		btree_child_vector_insert(&(node->childVec), (one_count+1), one_node);one_node->index = (one_count+1);one_node->parent = node;
		one_span = right_node->spanVec.mem[0];btree_span_vector_delete(&(right_node->spanVec), 0, NULL);
		btree_span_vector_insert(&(node->spanVec), (one_count+1), &one_span);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < right_node->itemArray.count;i++)
		{
			temp_span = &(right_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = right_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(right_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index+1] = one_span;

	}
	return 1;	
}
int btree_node_merge_right(btree_t *tree, btree_node_t *node, btree_node_t *right_node)
{
	int i;int j;int index;btree_node_t *parent;btree_item_t *parent_item;btree_node_t *one_node;btree_item_t *one_item;int one_count;int two_count;
	int one_child_count;int two_child_count;btree_span_t one_span;btree_span_t init_span;btree_span_t *temp_span;btree_item_t *temp_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(right_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != right_node->type){return -1;}
	index = node->index;parent = node->parent;parent_item = parent->itemArray.mem[index];
	if(node->type == 0)
	{
		one_count = node->itemArray.count;two_count = right_node->itemArray.count;node->itemArray.mem[one_count] = parent_item;
		j = (one_count+1);i = 0;
		while(i < two_count)
		{
			one_item = right_node->itemArray.mem[i];node->itemArray.mem[j] = one_item;right_node->itemArray.mem[i] = NULL;
			i++;j++;
		}
		node->itemArray.count = (one_count+1+two_count);right_node->itemArray.count = 0;btree_node_free(right_node);
		btree_array_delete(&(parent->itemArray), index, NULL);btree_child_vector_delete(&(parent->childVec), (index+1), NULL);
		btree_span_vector_delete(&(parent->spanVec), (index+1), NULL);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
	}
	else
	{
		one_count = node->itemArray.count;two_count = right_node->itemArray.count;node->itemArray.mem[one_count] = parent_item;
		one_child_count = node->childVec.count;two_child_count = right_node->childVec.count;
		j = (one_count+1);i = 0;init_span.span_count = 0;init_span.span_item_count = 0;
		while(i < two_count)
		{
			one_item = right_node->itemArray.mem[i];node->itemArray.mem[j] = one_item;right_node->itemArray.mem[i] = NULL;
			one_node = right_node->childVec.mem[i];node->childVec.mem[j] = one_node;right_node->childVec.mem[i] = NULL;
			if(one_node != NULL){one_node->index = j;one_node->parent = node;}
			one_span = right_node->spanVec.mem[i];node->spanVec.mem[j] = one_span;right_node->spanVec.mem[i] = init_span;
			i++;j++;
		}
		one_node = right_node->childVec.mem[i];node->childVec.mem[j] = one_node;right_node->childVec.mem[i] = NULL;
		if(one_node != NULL){one_node->index = j;one_node->parent = node;}
		one_span = right_node->spanVec.mem[i];node->spanVec.mem[j] = one_span;right_node->spanVec.mem[i] = init_span;
		node->itemArray.count = (one_count+1+two_count);right_node->itemArray.count = 0;
		node->childVec.count = (one_child_count+two_child_count);right_node->childVec.count = 0;
		node->spanVec.count = (one_child_count+two_child_count);right_node->spanVec.count = 0;btree_node_free(right_node);
		btree_array_delete(&(parent->itemArray), index, NULL);btree_child_vector_delete(&(parent->childVec), (index+1), NULL);
		btree_span_vector_delete(&(parent->spanVec), (index+1), NULL);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		parent->spanVec.mem[index] = one_span;		
	}
	return 1;
}
int btree_remove(btree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;btree_item_t *result_item;btree_node_t *replace_node;
	int replace_item_index;btree_item_t *replace_item;btree_node_t *left_node;btree_node_t *right_node;btree_node_t *check_node;int check_index;
	btree_node_t *check_parent;int check_count;int temp_result;btree_node_t *one_node;btree_node_t *root_node;btree_span_t one_span;
	btree_span_t init_span;btree_span_t *temp_span;btree_item_t *temp_item;int i;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}check_node = NULL;
	if(result_node->level <= 0)
	{
		result_item = result_node->itemArray.mem[result_item_index];if(result_data_vec != NULL){vector_copy_vec(&(result_item->dataVec), result_data_vec);}
		tree->count -= result_item->dataVec.count;tree->item_count -= 1;btree_item_free(result_item);
		btree_array_delete(&(result_node->itemArray), result_item_index, NULL);check_node = result_node;
	}
	else
	{
		one_node = result_node->childVec.mem[result_item_index];replace_node = NULL;
		temp_result = btree_find_max(tree, one_node, &replace_node, &replace_item_index);if(temp_result == -1){return -1;}
		if(temp_result == 0){return 0;}if(replace_node == NULL){return 0;}replace_item = replace_node->itemArray.mem[replace_item_index];
		result_item = result_node->itemArray.mem[result_item_index];if(result_data_vec != NULL){vector_copy_vec(&(result_item->dataVec), result_data_vec);}
		tree->count -= result_item->dataVec.count;tree->item_count -= 1;btree_item_free(result_item);
		result_node->itemArray.mem[result_item_index] = replace_item;
		btree_array_delete(&(replace_node->itemArray), replace_item_index, NULL);
		check_node = result_node;
		while(check_node != NULL)
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
					temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		check_node = replace_node;
	}
	if(check_node == NULL){return -1;}
	while(check_node != NULL)
	{
		if(check_node->itemArray.count >= (tree->check_item_count/2))
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
					temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		else
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;check_count = check_parent->itemArray.count;left_node = NULL;right_node = NULL;
				if(check_index <= 0){left_node = NULL;right_node = check_parent->childVec.mem[check_index+1];}
				else if(check_index >= check_count){left_node = check_parent->childVec.mem[check_index-1];right_node = NULL;}
				else{left_node = check_parent->childVec.mem[check_index-1];right_node = check_parent->childVec.mem[check_index+1];}
				if(left_node == NULL && right_node == NULL){return -1;}
				if(left_node != NULL && left_node->itemArray.count > (tree->check_item_count/2))
				{
					btree_node_borrow_left(tree, check_node, left_node);check_node = check_parent;
				}
				else
				{
					if(right_node != NULL && right_node->itemArray.count > (tree->check_item_count/2))
					{
						btree_node_borrow_right(tree, check_node, right_node);check_node = check_parent;
					}
					else
					{
						if(left_node != NULL){btree_node_merge_right(tree, left_node, check_node);check_node = check_parent;}
						else{btree_node_merge_right(tree, check_node, right_node);check_node = check_parent;}
					}
				}
			}
			else
			{
				if(check_node->itemArray.count <= 0)
				{
					if(check_node->childVec.count <= 0)
					{
						btree_node_free(check_node);tree->root = NULL;break;
					}
					else
					{
						root_node = check_node->childVec.mem[0];check_node->childVec.mem[0] = NULL;check_node->childVec.count = 0;
						init_span.span_count = 0;init_span.span_item_count = 0;check_node->spanVec.mem[0] = init_span;check_node->spanVec.count = 0;
						btree_node_free(check_node);
						if(root_node != NULL){root_node->index = 0;root_node->parent = NULL;}tree->root = root_node;break;
					}
				}
				else
				{
					break;
				}
			}			
		}
	}
	return 1;
}
int btree_get_rank_min_max_item(btree_t *tree, int min_rank, int max_rank, vector_t *all_item_vec)
{
	vector_t one_item_vec;btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;btree_node_t *next_node;int next_item_index;
	btree_node_t *min_node;int min_item_index;btree_item_t *min_item;btree_node_t *max_node;int max_item_index;btree_item_t *max_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, min_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, max_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	vector_init(&one_item_vec);
	if(min_item == max_item){vector_add(all_item_vec, min_item);vector_free(&one_item_vec);return 1;}
	vector_add(&one_item_vec, min_item);
	next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	while(check_item != NULL && check_item != max_item)
	{
		vector_add(&one_item_vec, check_item);
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	}
	vector_add(&one_item_vec, max_item);vector_add_vec_two(&one_item_vec, all_item_vec);vector_free(&one_item_vec);return 1;
}
int btree_get_rank_min_max_item_two(btree_t *tree, int min_rank, int max_rank, vector_t *all_item_vec)
{
	vector_t one_item_vec;btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;btree_node_t *next_node;int next_item_index;
	btree_node_t *min_node;int min_item_index;btree_item_t *min_item;btree_node_t *max_node;int max_item_index;btree_item_t *max_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, min_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, max_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	vector_init(&one_item_vec);
	if(min_item == max_item)
	{
		vector_add(&one_item_vec, min_item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
		vector_free(&one_item_vec);return 1;
	}
	vector_add(&one_item_vec, min_item);
	next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	while(check_item != NULL && check_item != max_item)
	{
		vector_add(&one_item_vec, check_item);
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	}
	vector_add(&one_item_vec, max_item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
	vector_free(&one_item_vec);return 1;
}
int btree_lower_upper_remove(btree_t *tree, byte_t *key, word_t key_len, int lower_index, int upper_index)
{
	btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;btree_item_t *check_item;
	int one_count;btree_node_t *check_node;int check_index;btree_node_t *check_parent;btree_span_t one_span;btree_span_t *temp_span;
	btree_item_t *temp_item;int i;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	if(lower_index < 0){return -1;}if(upper_index < 0){return -1;}if(lower_index > upper_index){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	check_item = result_node->itemArray.mem[result_item_index];one_count = check_item->dataVec.count;
	if(lower_index >= one_count){return -1;}if(upper_index >= one_count){return -1;}one_count = (upper_index-lower_index+1);
	vector_delete_min_max(&(check_item->dataVec), lower_index, upper_index);
	tree->count -= one_count;check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->parent != NULL)
		{
			check_index = check_node->index;check_parent = check_node->parent;
			one_span.span_count = 0;one_span.span_item_count = 0;
			if(check_node->type == 0)
			{
				for(i = 0;i < check_node->itemArray.count;i++)
				{
					temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
				}
			}
			else
			{
				for(i = 0;i < check_node->itemArray.count;i++)
				{
					temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
					temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
				}
				temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			}
			check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
		}
		else{break;}
	}
	return 1;
}
int btree_rank_min_max_remove(btree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;btree_item_t *one_item;vector_t one_item_vec;btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;btree_node_t *next_node;int next_item_index;
	int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;btree_node_t *min_node;int min_item_index;
	btree_item_t *min_item;btree_node_t *max_node;int max_item_index;btree_item_t *max_item;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, min_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	one_count = min_item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, max_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	one_count = max_item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	vector_init(&one_item_vec);
	if(min_item != max_item)
	{
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		while(check_item != NULL && check_item != max_item)
		{
			vector_add(&one_item_vec, check_item);
			next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
			if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
			check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		}
	}
	if(min_item == max_item)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_item->dataVec), result_data_vec);}
    	btree_remove(tree, min_item->key, min_item->key_len, NULL);
    	vector_free(&one_item_vec);return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	btree_lower_upper_remove(tree, min_item->key, min_item->key_len, (min_rank-lower_min_rank), (max_rank-lower_min_rank));
    	vector_free(&one_item_vec);return 1;
    }
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_item->dataVec), result_data_vec);}
  	btree_remove(tree, min_item->key, min_item->key_len, NULL);
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	btree_lower_upper_remove(tree, min_item->key, min_item->key_len, (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));
  }
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  	btree_remove(tree, one_item->key, one_item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_item->dataVec), result_data_vec);}
  	btree_remove(tree, max_item->key, max_item->key_len, NULL);
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	btree_lower_upper_remove(tree, max_item->key, max_item->key_len, 0, (max_rank-lower_max_rank));
  }
	vector_free(&one_item_vec);return 1;
}
int btree_rank_min_max_get(btree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;btree_item_t *one_item;vector_t one_item_vec;btree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;btree_node_t *check_node;int check_item_index;btree_item_t *check_item;btree_node_t *next_node;int next_item_index;
	int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;btree_node_t *min_node;int min_item_index;
	btree_item_t *min_item;btree_node_t *max_node;int max_item_index;btree_item_t *max_item;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, min_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	one_count = min_item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = btree_find_rank(tree, tree->root, max_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	one_count = max_item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	vector_init(&one_item_vec);
	if(min_item != max_item)
	{
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		while(check_item != NULL && check_item != max_item)
		{
			vector_add(&one_item_vec, check_item);
			next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
			if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
			check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		}
	}
	if(min_item == max_item)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_item->dataVec), result_data_vec);}
    	vector_free(&one_item_vec);return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_free(&one_item_vec);return 1;
    }
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_item_vec);return 1;
}
int btree_min_max_remove(btree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;btree_item_t *one_item;vector_t one_item_vec;btree_node_t *result_node;int result_item_index;int temp_result;btree_node_t *check_node;
	int check_item_index;btree_item_t *check_item;btree_node_t *next_node;int next_item_index;btree_node_t *min_node;int min_item_index;
	btree_item_t *min_item;btree_node_t *max_node;int max_item_index;btree_item_t *max_item;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = btree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;temp_result = btree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	vector_init(&one_item_vec);
	if(min_item != max_item)
	{
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		while(check_item != NULL && check_item != max_item)
		{
			vector_add(&one_item_vec, check_item);
			next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
			if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
			check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		}
	}
	if(min_item == max_item)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_item->dataVec), result_data_vec);}
    btree_remove(tree, min_item->key, min_item->key_len, NULL);
    vector_free(&one_item_vec);return 1;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_item->dataVec), result_data_vec);}
  btree_remove(tree, min_item->key, min_item->key_len, NULL);
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  	btree_remove(tree, one_item->key, one_item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_item->dataVec), result_data_vec);}
  btree_remove(tree, max_item->key, max_item->key_len, NULL);
	vector_free(&one_item_vec);return 1;
}
int btree_min_max_get(btree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;btree_item_t *one_item;vector_t one_item_vec;btree_node_t *result_node;int result_item_index;int temp_result;btree_node_t *check_node;
	int check_item_index;btree_item_t *check_item;btree_node_t *next_node;int next_item_index;btree_node_t *min_node;int min_item_index;
	btree_item_t *min_item;btree_node_t *max_node;int max_item_index;btree_item_t *max_item;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = btree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;temp_result = btree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	vector_init(&one_item_vec);
	if(min_item != max_item)
	{
		next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		while(check_item != NULL && check_item != max_item)
		{
			vector_add(&one_item_vec, check_item);
			next_node = NULL;temp_result = btree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
			if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
			check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		}
	}
	if(min_item == max_item)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_item->dataVec), result_data_vec);}
    vector_free(&one_item_vec);return 1;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_item->dataVec), result_data_vec);}
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_item->dataVec), result_data_vec);}
	vector_free(&one_item_vec);return 1;
}
int btree_iterator_init(btree_t *tree, btree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return 0;}btree_node_get_all_item(tree->root, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
btree_iterator_t * btree_iterator_alloc(btree_t *tree)
{
	size_t size;btree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(btree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(btree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void btree_iterator_free(btree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int btree_iterator_next(btree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;		
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}	
}
void btree_item_dump(FILE *fd, btree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void btree_dump(FILE *fd, btree_t *tree)
{
	btree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = btree_iterator_alloc(tree);if(iterator == NULL){return ;}
	btree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(btree_iterator_next(iterator) == 1){btree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	btree_iterator_free(iterator);
}
void btree_dump_inorder(FILE *fd, btree_t *tree)
{
	int i;btree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}btree_inorder_get_all_item(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){btree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void btree_dump_inorder_two(FILE *fd, btree_t *tree)
{
	int i;btree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}btree_inorder_get_all_item_two(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){btree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void btree_dump_inorder_other(FILE *fd, btree_t *tree)
{
	int i;btree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}btree_inorder_get_all_item_other(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){btree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void btree_dump_inorder_other_two(FILE *fd, btree_t *tree)
{
	int i;btree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}btree_inorder_get_all_item_other_two(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){btree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void btree_dump_inorder_another(FILE *fd, btree_t *tree)
{
	int i;btree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}btree_inorder_get_all_item_another(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){btree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void btree_dump_inorder_another_two(FILE *fd, btree_t *tree)
{
	int i;btree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}btree_inorder_get_all_item_another_two(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){btree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void btree_dump_inorder_min_max(FILE *fd, btree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len)
{
	int i;btree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	btree_get_min_max_item_two(tree, min_key, min_key_len, max_key, max_key_len, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){btree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);	
}
void btree_dump_inorder_rank_min_max(FILE *fd, btree_t *tree, int min_rank, int max_rank)
{
	int i;btree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	btree_get_rank_min_max_item_two(tree, min_rank, max_rank, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){btree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);	
}
void btree_dot_node_dump(FILE *fd, btree_node_t *node, int *nDump)
{
	int i;btree_node_t *one_node;btree_item_t *one_item;btree_span_t *one_span;int one_count;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n",oneDump, node->type, node->level, node->index);*nDump = (oneDump+1);
	one_count = node->itemArray.count;
	for(i = 0;i < one_count;i++)
	{
		one_item = node->itemArray.mem[i];if(one_item != NULL){fprintf(fd, "%s:%d\\n",((char *)(one_item->key)),one_item->dataVec.count);}
	}
	fprintf(fd, "\"];\n");
	one_count = node->childVec.count;
	for(i = 0;i < one_count;i++)
	{
		one_node = node->childVec.mem[i];one_span = &(node->spanVec.mem[i]);
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d] [%d:%d]\", color=\"blue\"];\n", oneDump, twoDump, i, one_span->span_count, one_span->span_item_count);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			btree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void btree_dot_dump(btree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("btree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph btree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");btree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;btree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = btree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    btree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	btree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_other(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_other_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_another(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_another_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_min_max(fd, tree, (byte_t *)(arrKeyStr[3]), strlen(arrKeyStr[3]), (byte_t *)(arrKeyStr[9]), strlen(arrKeyStr[9]));
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_rank_min_max(fd, tree, 3, 9);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    btree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	btree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_other(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_other_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_another(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_another_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_min_max(fd, tree, (byte_t *)(arrKeyStr[3]), strlen(arrKeyStr[3]), (byte_t *)(arrKeyStr[9]), strlen(arrKeyStr[9]));
	fprintf(fd, "\n");fprintf(fd, "\n");
	btree_dump_inorder_rank_min_max(fd, tree, 3, 9);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	btree_dot_dump(tree);
	btree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

bplustree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {int count;void *mem[64];} bplustree_array_t;
typedef struct {int span_count;int span_item_count;} bplustree_span_t;
typedef struct {int count;int max;bplustree_span_t *mem;} bplustree_span_vector_t;
typedef struct list_link {struct list_link *prev;struct list_link *next;} list_link_t;
typedef struct {int count;list_link_t head;} list_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} bplustree_item_t;
typedef struct bplustree_node {
	int type;int level;int index;struct bplustree_node *parent;bplustree_span_vector_t spanVec;bplustree_array_t itemArray;vector_t childVec;list_link_t link;
} bplustree_node_t;
typedef struct {int level;int count;int item_count;bplustree_node_t *root;int check_item_count;list_t listArray[64];} bplustree_t;
typedef struct {bplustree_t *tree;int vec_index;vector_t all_item_vec;bplustree_item_t *item;} bplustree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_insert_vec_two(vector_t *a, vector_t *b, int b_index)
{
	int i;int j;int one;if(b_index < 0 || b_index > b->count){return 0;}one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	if(b_index == b->count){i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}}
	else
	{
		i = (b->count-1);j = (one-1);while(i >= b_index){b->mem[j] = b->mem[i];;i--;j--;}
		i = 0;j = b_index;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int bplustree_child_vector_insert(vector_t *vec, int index, void *item)
{
	bplustree_node_t *one_node;int i;if(index < 0 || index > vec->count){return 0;}if(item == NULL){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){one_node = vec->mem[i-1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
			vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int bplustree_child_vector_delete(vector_t *vec, int index, void **item)
{
	bplustree_node_t *one_node;int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1)
	{
		for(i = index; i < vec->count-1; i++){one_node = vec->mem[i+1];vec->mem[i] = one_node;if(one_node != NULL){one_node->index = i;}}
	}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
void bplustree_array_init(bplustree_array_t *array)
{
	int i;array->count = 0;for(i = 0; i < 64; i++) { array->mem[i] = NULL;}
}
int bplustree_array_get(bplustree_array_t *array, int index, void **item){if(index < 0 || index >= array->count){return 0;}*item = array->mem[index];return 1;}
int bplustree_array_set(bplustree_array_t *array, int index, void *item){if(index < 0 || index >= array->count){return 0;}array->mem[index] = item;return 1;}
int bplustree_array_add(bplustree_array_t *array, void *item){if(array->count < 64){array->mem[array->count] = item;array->count++;return 1;}else{return 0;}}
int bplustree_array_insert(bplustree_array_t *array, int index, void *item)
{
	int i;if(index < 0 || index > array->count){return 0;}if(array->count >= 64){return 0;}
	if(index == array->count){array->mem[array->count] = item;array->count++;return 1;}
	else
	{
		for(i = array->count;i > index;i--){array->mem[i] = array->mem[i-1];}array->mem[index] = item;array->count++;return 1;
	}
}
int bplustree_array_delete(bplustree_array_t *array, int index, void **item)
{
	int i;if(index < 0 || index >= array->count){return 0;}if(item != NULL){*item = array->mem[index];}
	if(index < array->count-1){for(i = index; i < array->count-1; i++){array->mem[i] = array->mem[i+1];}}
	array->mem[array->count-1] = NULL;array->count--;return 1;
}
int bplustree_array_add_vec_two(bplustree_array_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int bplustree_array_add_vec_min_max_two(bplustree_array_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void bplustree_span_vector_init(bplustree_span_vector_t *span_vec)
{
	span_vec->count = 0;span_vec->max = 0;span_vec->mem = NULL;
}
void bplustree_span_vector_free(bplustree_span_vector_t *span_vec)
{
	if(span_vec->mem != NULL){free(span_vec->mem);span_vec->mem = NULL;}bplustree_span_vector_init(span_vec);
}
int bplustree_span_vector_get(bplustree_span_vector_t *span_vec, int index, bplustree_span_t *one_span)
{
	if(index < 0 || index >= span_vec->count){return 0;}*one_span = span_vec->mem[index];return 1;
}
int bplustree_span_vector_set(bplustree_span_vector_t *span_vec, int index, bplustree_span_t *one_span)
{
	if(index < 0 || index >= span_vec->count){return 0;}span_vec->mem[index] = *one_span;return 1;
}
int bplustree_span_vector_reserve(bplustree_span_vector_t *span_vec, int size)
{
	int max;void *temp;
	if(size <= span_vec->max){return 1;}
	else if(span_vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(span_vec->max > 0 && size > span_vec->max){max = span_vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(span_vec->mem, (max*sizeof(bplustree_span_t)));if(temp == NULL){return 0;}
	span_vec->mem = temp;span_vec->max = max;return 1;
}
int bplustree_span_vector_add(bplustree_span_vector_t *span_vec, bplustree_span_t *one_span)
{
	if(bplustree_span_vector_reserve(span_vec, (span_vec->count+1)) == 1)
	{
		span_vec->mem[span_vec->count] = *one_span;span_vec->count++;return 1;
	}
	else{return 0;}
}
int bplustree_span_vector_insert(bplustree_span_vector_t *span_vec, int index, bplustree_span_t *one_span)
{
	int i;if(index < 0 || index > span_vec->count){return 0;}
	if(bplustree_span_vector_reserve(span_vec, (span_vec->count+1)) == 1)
	{
		if(index == span_vec->count){span_vec->mem[span_vec->count] = *one_span;span_vec->count++;return 1;}
		else
		{
			for(i = span_vec->count;i > index;i--){span_vec->mem[i] = span_vec->mem[i-1];}span_vec->mem[index] = *one_span;span_vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int bplustree_span_vector_delete(bplustree_span_vector_t *span_vec, int index, bplustree_span_t *one_span)
{
	int i;bplustree_span_t temp_span;temp_span.span_count = 0;temp_span.span_item_count = 0;
	if(index < 0 || index >= span_vec->count){return 0;}if(one_span != NULL){*one_span = span_vec->mem[index];}
	if(index < span_vec->count-1){for(i = index; i < span_vec->count-1; i++){span_vec->mem[i] = span_vec->mem[i+1];}}
	span_vec->mem[span_vec->count-1] = temp_span;span_vec->count--;return 1;
}
int bplustree_span_vector_delete_min_max(bplustree_span_vector_t *span_vec, int min_index, int max_index)
{
	int i;int j;int count;bplustree_span_t temp_span;temp_span.span_count = 0;temp_span.span_item_count = 0;
	if(min_index < 0 || min_index >= span_vec->count){return 0;}if(max_index < 0 || max_index >= span_vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (span_vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < span_vec->count){span_vec->mem[j] = span_vec->mem[i];i++;j++;}
		for(i = j;i < span_vec->count;i++){span_vec->mem[i] = temp_span;}
	}
	else{for(i = min_index;i < span_vec->count;i++){span_vec->mem[i] = temp_span;}}
	span_vec->count -= count;return 1;
}
void bplustree_span_vector_set_span_vec(bplustree_span_vector_t *a, bplustree_span_vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
void list_link_init(list_link_t *link){link->prev = link;link->next = link;}
void list_link_add(list_link_t *link, list_link_t *prev, list_link_t *next){link->next = next;link->prev = prev;next->prev = link;prev->next = link;}
void list_link_del(list_link_t *link, list_link_t *prev, list_link_t *next){prev->next = next;next->prev = prev;list_link_init(link);}
void list_init(list_t *list){list->count = 0;list_link_init(&(list->head));}
void list_link_get_node(list_link_t *one, bplustree_node_t **node)
{
	*node = NULL;if(one == NULL){return ;}*node = ((bplustree_node_t *)((unsigned char *)(one) - (int)(&(((bplustree_node_t *)0)->link))));
}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int bplustree_item_array_binary_search(bplustree_array_t *array, byte_t *key, word_t key_len, int *result_index)
{
	bplustree_item_t *item;int low;int high;int mid;int one;int last;if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(array->count <= 0){return -1;}
	low = 0;high = (array->count-1);last = -1;
	while(low <= high)
	{
		mid = (low +(high-low)/2);item = array->mem[mid];one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0){last = mid;low = (mid+1);}else if(one > 0){high = (mid-1);}else{*result_index = mid;return 1;}
	}
	*result_index = last;return 0;
}
int bplustree_node_rank_search(bplustree_t *tree, bplustree_node_t *node, int rank, int *result_index)
{
	int i;bplustree_span_t *one_span;bplustree_item_t *one_item;int one_span_count;int one_count;int rank_count;int all_count;int index;bplustree_node_t *parent;	
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(node->parent == NULL){all_count = tree->count;}else{index = node->index;parent = node->parent;one_span = &(parent->spanVec.mem[index]);all_count = one_span->span_count;}
	if(rank < 1){return -1;}if(rank > all_count){return -1;}rank_count = 0;
	if(node->type == 0)
	{
		for(i = 0;i < node->itemArray.count;i++)
		{
			one_item = node->itemArray.mem[i];one_count = one_item->dataVec.count;
			if(rank >= (rank_count+1) && rank <= (rank_count+one_count)){*result_index = i;return 1;}
			rank_count += one_count;
		}
	}
	else
	{
		for(i = 0;i < node->itemArray.count;i++)
		{
			one_span = &(node->spanVec.mem[i]);one_span_count = one_span->span_count;
			if(rank >= (rank_count+1) && rank <= (rank_count+one_span_count)){*result_index = i;return 1;}
			rank_count += one_span_count;
		}
	}
	return -1;
}
int bplustree_item_init(bplustree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
bplustree_item_t * bplustree_item_alloc()
{
  size_t size;bplustree_item_t *item;size = sizeof(bplustree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  bplustree_item_init(item);return item;
}
int bplustree_item_other_free(bplustree_item_t *item){vector_free(&(item->dataVec));bplustree_item_init(item);return 1;}
void bplustree_item_free(bplustree_item_t *item){if(item != NULL){bplustree_item_other_free(item);free(item);}}
int bplustree_node_init(bplustree_node_t *node)
{
	node->type = 0;node->level = 0;node->index = 0;node->parent = NULL;bplustree_span_vector_init(&(node->spanVec));
	bplustree_array_init(&(node->itemArray));vector_init(&(node->childVec));list_link_init(&(node->link));return 1;
}
bplustree_node_t * bplustree_node_alloc(bplustree_t *tree, int type)
{
	int i;bplustree_span_vector_t oneVec;vector_t twoVec;bplustree_span_t temp_span;size_t size;bplustree_node_t *node;
	size = sizeof(bplustree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	if(type == 0)
	{
		bplustree_node_init(node);node->type = 0;bplustree_span_vector_init(&(node->spanVec));vector_init(&(node->childVec));
	}
	else
	{
		temp_span.span_count = 0;temp_span.span_item_count = 0;bplustree_span_vector_init(&oneVec);vector_init(&twoVec);
		if(bplustree_span_vector_reserve(&oneVec, (tree->check_item_count+1)) == 0){free(node);node = NULL;return node;}
		if(vector_reserve(&twoVec, (tree->check_item_count+1)) == 0){bplustree_span_vector_free(&oneVec);free(node);node = NULL;return node;}
		for(i = 0;i < oneVec.max;i++){oneVec.mem[i] = temp_span;}for(i = 0;i < twoVec.max;i++){twoVec.mem[i] = NULL;}
		bplustree_node_init(node);node->type = 1;
		bplustree_span_vector_set_span_vec(&oneVec, &(node->spanVec));bplustree_span_vector_init(&oneVec);
		vector_set_vec(&twoVec, &(node->childVec));vector_init(&twoVec);
	}
	return node;
}
int bplustree_node_other_free(bplustree_node_t *node)
{
	int i;bplustree_item_t *item;bplustree_array_t *array;array = &(node->itemArray);
	if(node->type == 0)
	{
		for(i = 0;i < array->count;i++){item = array->mem[i];if(item != NULL){bplustree_item_free(item);}array->mem[i] = NULL;}
	}
	else
	{
		for(i = 0;i < array->count;i++){array->mem[i] = NULL;}
		bplustree_span_vector_free(&(node->spanVec));vector_free(&(node->childVec));
	}
	bplustree_node_init(node);return 1;
}
void bplustree_node_free(bplustree_node_t *node)
{
	if(node != NULL){bplustree_node_other_free(node);free(node);}
}
void bplustree_node_destroy(bplustree_node_t **node)
{
	int i;bplustree_node_t **bplustree_node;bplustree_node_t *one_node;bplustree_span_t temp_span;bplustree_span_vector_t *span_vec;vector_t *vec;
	if(node == NULL || *node == NULL){return ;}one_node = (*node);if(one_node->type == 0){bplustree_node_free((*node));*node = NULL;return ;}
	temp_span.span_count = 0;temp_span.span_item_count = 0;span_vec = &(one_node->spanVec);vec = &(one_node->childVec);
	for(i = 0;i < vec->count;i++)
	{
		if(vec->mem[i] != NULL)
		{
			bplustree_node = (bplustree_node_t **)(&(vec->mem[i]));bplustree_node_destroy(bplustree_node);vec->mem[i] = NULL;span_vec->mem[i] = temp_span;
		}
	}
	bplustree_node_free((*node));*node = NULL;
}
int bplustree_inorder_get_all_item(bplustree_t *tree, vector_t *all_item_vec)
{
	bplustree_node_t *node;list_t *list;list_link_t *link;list_link_t *next;list_link_t *end;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	list = &(tree->listArray[0]);link = list->head.next;next = link->next;end = &(list->head);
	while(link != end)
	{
		node = NULL;list_link_get_node(link, &node);if(node != NULL){bplustree_array_add_vec_two(&(node->itemArray), all_item_vec);}
		link = next;next = link->next;
	}
	return 1;
}
int bplustree_inorder_get_next_node_item(bplustree_t *tree, bplustree_node_t *node, int item_index, bplustree_node_t **result_node, int *result_item_index)
{
	bplustree_node_t *check_node;int check_item_index;bplustree_node_t *one_node;list_t *list;list_link_t *link;list_link_t *next;list_link_t *end;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(node->level > 0){return -1;}if(item_index < 0 || item_index >= node->itemArray.count){return -1;}
	*result_node = NULL;check_node = node;check_item_index = item_index;
	list = &(tree->listArray[0]);link = &(check_node->link);next = link->next;end = &(list->head);
	if(check_item_index < (check_node->itemArray.count-1))
	{
		*result_node = check_node;*result_item_index = (check_item_index+1);
	}
	else
	{
		link = next;next = link->next;if(link == end){return 0;}one_node = NULL;list_link_get_node(link, &one_node);if(one_node == NULL){return 0;}
		*result_node = one_node;*result_item_index = 0;		
	}
	return 1;
}
int bplustree_inorder_get_prev_node_item(bplustree_t *tree, bplustree_node_t *node, int item_index, bplustree_node_t **result_node, int *result_item_index)
{
	bplustree_node_t *check_node;int check_item_index;bplustree_node_t *one_node;list_t *list;list_link_t *link;list_link_t *prev;list_link_t *end;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(node->level > 0){return -1;}if(item_index < 0 || item_index >= node->itemArray.count){return -1;}
	*result_node = NULL;check_node = node;check_item_index = item_index;
	list = &(tree->listArray[0]);link = &(check_node->link);prev = link->prev;end = &(list->head);
	if(check_item_index > 0)
	{
		*result_node = check_node;*result_item_index = (check_item_index-1);
	}
	else
	{
		link = prev;prev = link->prev;if(link == end){return 0;}one_node = NULL;list_link_get_node(link, &one_node);if(one_node == NULL){return 0;}
		*result_node = one_node;*result_item_index = (one_node->itemArray.count-1);
	}
	return 1;
}
bplustree_t * bplustree_alloc()
{
	int i;size_t size;bplustree_t *tree;size = sizeof(bplustree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;for(i = 0;i < 64;i++){list_init(&(tree->listArray[i]));}
	tree->level = 0;tree->count = 0;tree->item_count = 0;tree->check_item_count = 63;return tree;
}
void bplustree_destroy(bplustree_t *tree)
{
	int i;int level;bplustree_node_t **bplustree_node;if(tree == NULL){return ;}level = tree->level;
	for(i = 0;i < level;i++){list_init(&(tree->listArray[i]));}if(tree->root == NULL){free(tree);return ;}
	bplustree_node = &(tree->root);bplustree_node_destroy(bplustree_node);tree->root = NULL;free(tree);
}
int bplustree_find_rank(bplustree_t *tree, bplustree_node_t *node, int rank, bplustree_node_t **result_node, int *result_item_index, int *result_rank_count, int *result_rank_item_count)
{
	bplustree_node_t *check_node;int check_result;int check_index;void *child;int temp_result;int i;bplustree_span_t *one_span;bplustree_item_t *one_item;
	int one_span_count;int one_count;int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}if(rank < 1){return -1;}if(rank > tree->count){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= 0){return -1;}
		if(check_node->childVec.count <= 0)
		{
			check_result = bplustree_node_rank_search(tree, check_node, (rank-rank_count), &check_index);
			if(check_result == -1){return -1;}
			else if(check_result == 1)
			{
				for(i = 0;i <= check_index;i++)
				{
					one_item = check_node->itemArray.mem[i];one_count = one_item->dataVec.count;rank_count += one_count;rank_item_count += 1;
				}
				*result_node = check_node;*result_item_index = check_index;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
			}
			else
			{
				return 0;
			}
		}
		else
		{
			check_result = bplustree_node_rank_search(tree, check_node, (rank-rank_count), &check_index);
			if(check_result == -1){return -1;}
			else if(check_result == 1)
			{
				for(i = 0;i < check_index;i++)
				{
					one_span = &(check_node->spanVec.mem[i]);one_span_count = one_span->span_count;
					rank_count += one_span_count;rank_item_count += one_span->span_item_count;
				}
				temp_result = vector_get(&(check_node->childVec), check_index, &child);if(temp_result == 0){return -1;}else{check_node = child;}
			}
			else
			{
				return 0;
			}
		}
	}
	if(check_node == NULL){return -1;}return 0;
}
int bplustree_find_base(bplustree_t *tree, bplustree_node_t *node, byte_t *key, word_t key_len, bplustree_node_t **result_node, int *result_item_index, int *result_rank_count, int *result_rank_item_count)
{
	bplustree_node_t *check_node;int check_result;int check_index;bplustree_array_t *array;void *child;int temp_result;int i;bplustree_span_t *one_span;bplustree_item_t *one_item;
	int one_span_count;int one_count;int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= 0){return -1;}
		if(check_node->childVec.count <= 0)
		{
			array = &(check_node->itemArray);check_result = bplustree_item_array_binary_search(array, key, key_len, &check_index);
			if(check_result == -1){return -1;}
			else if(check_result == 1)
			{
				for(i = 0;i <= check_index;i++)
				{
					one_item = check_node->itemArray.mem[i];one_count = one_item->dataVec.count;rank_count += one_count;rank_item_count += 1;
				}
				*result_node = check_node;*result_item_index = check_index;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
			}
			else
			{
				for(i = 0;i <= check_index;i++)
				{
					one_item = check_node->itemArray.mem[i];one_count = one_item->dataVec.count;rank_count += one_count;rank_item_count += 1;
				}
				*result_node = check_node;*result_item_index = check_index;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 0;
			}
		}
		else
		{
			array = &(check_node->itemArray);check_result = bplustree_item_array_binary_search(array, key, key_len, &check_index);
			if(check_result == -1){return -1;}
			else if(check_result == 1)
			{
				for(i = 0;i < check_index;i++)
				{
					one_span = &(check_node->spanVec.mem[i]);one_span_count = one_span->span_count;
					rank_count += one_span_count;rank_item_count += one_span->span_item_count;
				}
				temp_result = vector_get(&(check_node->childVec), check_index, &child);if(temp_result == 0){return -1;}else{check_node = child;}
			}
			else
			{
				if(check_index == -1){check_index = 0;}
				for(i = 0;i < check_index;i++)
				{
					one_span = &(check_node->spanVec.mem[i]);one_span_count = one_span->span_count;
					rank_count += one_span_count;rank_item_count += one_span->span_item_count;
				}
				temp_result = vector_get(&(check_node->childVec), check_index, &child);if(temp_result == 0){return -1;}else{check_node = child;}
			}
		}
	}
	if(check_node == NULL){return -1;}return 0;
}
int bplustree_get_rank(bplustree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	*result_rank = result_rank_count;return 1;
}
int bplustree_check_exist(bplustree_t *tree, byte_t *key, word_t key_len)
{
	bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}return 1;
}
int bplustree_get(bplustree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;bplustree_item_t *result_item;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	result_item = result_node->itemArray.mem[result_item_index];if(result_data_vec != NULL){vector_copy_vec(&(result_item->dataVec), result_data_vec);}
	return 1;
}
int bplustree_find_max(bplustree_t *tree, bplustree_node_t *node, bplustree_node_t **result_node, int *result_item_index)
{
	bplustree_node_t *check_node;int check_index;void *child;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= 0){return -1;}
		if(check_node->childVec.count <= 0)
		{
			*result_node = check_node;*result_item_index = (check_node->itemArray.count-1);return 1;
		}
		else
		{
			check_index = (check_node->childVec.count-1);
			temp_result = vector_get(&(check_node->childVec), check_index, &child);if(temp_result == 0){return -1;}else{check_node = child;}
		}
	}
	if(check_node == NULL){return -1;}return 0;
}
int bplustree_find_min(bplustree_t *tree, bplustree_node_t *node, bplustree_node_t **result_node, int *result_item_index)
{
	bplustree_node_t *check_node;int check_index;void *child;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= 0){return -1;}
		if(check_node->childVec.count <= 0)
		{
			*result_node = check_node;*result_item_index = 0;return 1;
		}
		else
		{
			check_index = 0;
			temp_result = vector_get(&(check_node->childVec), check_index, &child);if(temp_result == 0){return -1;}else{check_node = child;}
		}
	}
	if(check_node == NULL){return -1;}return 0;	
}
int bplustree_find_first_upper_equal(bplustree_t *tree, bplustree_node_t *node, byte_t *key, word_t key_len, bplustree_node_t **result_node, int *result_item_index)
{	
	bplustree_node_t *one_node;int one_item_index;int one_rank_count;int one_rank_item_count;int temp_result;
	bplustree_node_t *upper_node;int upper_item_index;bplustree_node_t *lower_node;int lower_item_index;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}*result_node = NULL;one_node = NULL;one_rank_count = 0;one_rank_item_count = 0;
	temp_result = bplustree_find_base(tree, tree->root, key, key_len, &one_node, &one_item_index, &one_rank_count, &one_rank_item_count);
	if(temp_result == -1){return -1;}if(one_node == NULL){return 0;}if(one_node->level > 0){return 0;}
	if(temp_result == 1)
	{
		*result_node = one_node;*result_item_index = one_item_index;return 1;
	}
	if(one_item_index < 0)
	{
		upper_node = one_node;upper_item_index = 0;lower_node = NULL;
		temp_result = bplustree_inorder_get_prev_node_item(tree, upper_node, upper_item_index, &lower_node, &lower_item_index);if(temp_result == -1){return -1;}
		*result_node = upper_node;*result_item_index = upper_item_index;
	}
	else if(one_item_index >= (one_node->itemArray.count-1))
	{
		upper_node = NULL;lower_node = one_node;lower_item_index = one_item_index;
		temp_result = bplustree_inorder_get_next_node_item(tree, lower_node, lower_item_index, &upper_node, &upper_item_index);if(temp_result == -1){return -1;}
		if(upper_node == NULL){return 0;}else{*result_node = upper_node;*result_item_index = upper_item_index;}
	}
	else
	{
		upper_node = one_node;upper_item_index = (one_item_index+1);lower_node = one_node;lower_item_index = one_item_index;
		*result_node = upper_node;*result_item_index = upper_item_index;
	}
	return 1;
}
int bplustree_find_last_lower_equal(bplustree_t *tree, bplustree_node_t *node, byte_t *key, word_t key_len, bplustree_node_t **result_node, int *result_item_index)
{
	bplustree_node_t *one_node;int one_item_index;int one_rank_count;int one_rank_item_count;int temp_result;
	bplustree_node_t *upper_node;int upper_item_index;bplustree_node_t *lower_node;int lower_item_index;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->itemArray.count <= 0){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}*result_node = NULL;one_node = NULL;one_rank_count = 0;one_rank_item_count = 0;
	temp_result = bplustree_find_base(tree, tree->root, key, key_len, &one_node, &one_item_index, &one_rank_count, &one_rank_item_count);
	if(temp_result == -1){return -1;}if(one_node == NULL){return 0;}if(one_node->level > 0){return 0;}
	if(temp_result == 1)
	{
		*result_node = one_node;*result_item_index = one_item_index;return 1;
	}
	if(one_item_index < 0)
	{
		upper_node = one_node;upper_item_index = 0;lower_node = NULL;
		temp_result = bplustree_inorder_get_prev_node_item(tree, upper_node, upper_item_index, &lower_node, &lower_item_index);if(temp_result == -1){return -1;}
		if(lower_node == NULL){return 0;}else{*result_node = lower_node;*result_item_index = lower_item_index;}
	}
	else if(one_item_index >= (one_node->itemArray.count-1))
	{
		upper_node = NULL;lower_node = one_node;lower_item_index = one_item_index;
		temp_result = bplustree_inorder_get_next_node_item(tree, lower_node, lower_item_index, &upper_node, &upper_item_index);if(temp_result == -1){return -1;}
		*result_node = lower_node;*result_item_index = lower_item_index;
	}
	else
	{
		upper_node = one_node;upper_item_index = (one_item_index+1);lower_node = one_node;lower_item_index = one_item_index;
		*result_node = lower_node;*result_item_index = lower_item_index;
	}
	return 1;
}
int bplustree_get_min_max_item(bplustree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *all_item_vec)
{
	bplustree_node_t *result_node;int result_item_index;int temp_result;bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;
	bplustree_node_t *min_node;int min_item_index;bplustree_item_t *min_item;bplustree_node_t *max_node;int max_item_index;bplustree_item_t *max_item;
	bplustree_node_t *next_node;int next_item_index;vector_t one_item_vec;vector_init(&one_item_vec);
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = bplustree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;temp_result = bplustree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	if(min_item == max_item){vector_add(all_item_vec, min_item);vector_free(&one_item_vec);return 1;}
	vector_add(&one_item_vec, min_item);
	next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	while(check_item != NULL && check_item != max_item)
	{
		vector_add(&one_item_vec, check_item);
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	}
	vector_add(&one_item_vec, max_item);vector_add_vec_two(&one_item_vec, all_item_vec);vector_free(&one_item_vec);return 1;
}
int bplustree_get_min_max_item_two(bplustree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *all_item_vec)
{
	bplustree_node_t *result_node;int result_item_index;int temp_result;bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;
	bplustree_node_t *min_node;int min_item_index;bplustree_item_t *min_item;bplustree_node_t *max_node;int max_item_index;bplustree_item_t *max_item;
	bplustree_node_t *next_node;int next_item_index;vector_t one_item_vec;vector_init(&one_item_vec);
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = bplustree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;temp_result = bplustree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	if(min_item == max_item)
	{
		vector_add(&one_item_vec, min_item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
		vector_free(&one_item_vec);return 1;
	}
	vector_add(&one_item_vec, min_item);
	next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	while(check_item != NULL && check_item != max_item)
	{
		vector_add(&one_item_vec, check_item);
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	}
	vector_add(&one_item_vec, max_item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
	vector_free(&one_item_vec);return 1;
}
int bplustree_inorder_get_all_item_other(bplustree_t *tree, vector_t *all_item_vec)
{
	bplustree_node_t *result_node;int result_item_index;int temp_result;bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;
	bplustree_node_t *next_node;int next_item_index;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;
	temp_result = bplustree_find_min(tree, tree->root, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	check_node = result_node;check_item_index = result_item_index;
	while(check_node != NULL)
	{
		check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){return -1;}if(next_node == NULL){return 1;}check_node = next_node;check_item_index = next_item_index;
	}
	return 1;
}
int bplustree_inorder_get_all_item_other_two(bplustree_t *tree, vector_t *all_item_vec)
{
	bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;
	bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;bplustree_node_t *next_node;int next_item_index;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, 1, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	check_node = result_node;check_item_index = result_item_index;
	while(check_node != NULL)
	{
		check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){return -1;}if(next_node == NULL){return 1;}check_node = next_node;check_item_index = next_item_index;
	}
	return 1;	
}
int bplustree_inorder_get_all_item_another(bplustree_t *tree, vector_t *all_item_vec)
{
	bplustree_node_t *result_node;int result_item_index;int temp_result;bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;
	bplustree_node_t *prev_node;int prev_item_index;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;
	temp_result = bplustree_find_max(tree, tree->root, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	check_node = result_node;check_item_index = result_item_index;
	while(check_node != NULL)
	{
		check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		prev_node = NULL;temp_result = bplustree_inorder_get_prev_node_item(tree, check_node, check_item_index, &prev_node, &prev_item_index);
		if(temp_result == -1){return -1;}if(prev_node == NULL){return 1;}check_node = prev_node;check_item_index = prev_item_index;
	}
	return 1;
}
int bplustree_inorder_get_all_item_another_two(bplustree_t *tree, vector_t *all_item_vec)
{
	bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;
	bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;bplustree_node_t *prev_node;int prev_item_index;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, tree->count, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	check_node = result_node;check_item_index = result_item_index;
	while(check_node != NULL)
	{
		check_item = check_node->itemArray.mem[check_item_index];vector_add(all_item_vec, check_item);
		prev_node = NULL;temp_result = bplustree_inorder_get_prev_node_item(tree, check_node, check_item_index, &prev_node, &prev_item_index);
		if(temp_result == -1){return -1;}if(prev_node == NULL){return 1;}check_node = prev_node;check_item_index = prev_item_index;
	}
	return 1;
}
int bplustree_node_give_left(bplustree_t *tree, bplustree_node_t *node, bplustree_node_t *left_node)
{
	int index;bplustree_node_t *parent;bplustree_item_t *one_item;bplustree_node_t *one_node;int one_count;
	bplustree_span_t one_span;bplustree_span_t *temp_span;bplustree_item_t *temp_item;int i;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(left_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != left_node->type){return -1;}
	index = node->index;parent = node->parent;one_count = left_node->itemArray.count;
	if(node->type == 0)
	{
		one_item = node->itemArray.mem[0];bplustree_array_delete(&(node->itemArray), 0, NULL);
		bplustree_array_insert(&(left_node->itemArray), one_count, one_item);
		parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index-1] = left_node->itemArray.mem[0];
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < left_node->itemArray.count;i++)
		{
			temp_item = left_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index-1] = one_span;
	}
	else
	{
		one_item = node->itemArray.mem[0];bplustree_array_delete(&(node->itemArray), 0, NULL);
		bplustree_array_insert(&(left_node->itemArray), one_count, one_item);
		parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index-1] = left_node->itemArray.mem[0];
		one_node = node->childVec.mem[0];bplustree_child_vector_delete(&(node->childVec), 0, NULL);
		bplustree_child_vector_insert(&(left_node->childVec), one_count, one_node);one_node->index = one_count;one_node->parent = left_node;
		one_span = node->spanVec.mem[0];bplustree_span_vector_delete(&(node->spanVec), 0, NULL);
		bplustree_span_vector_insert(&(left_node->spanVec), one_count, &one_span);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < left_node->itemArray.count;i++)
		{
			temp_span = &(left_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index-1] = one_span;
	}
	return 1;
}
int bplustree_node_give_right(bplustree_t *tree, bplustree_node_t *node, bplustree_node_t *right_node)
{
	int index;bplustree_node_t *parent;bplustree_item_t *one_item;bplustree_node_t *one_node;int one_count;
	bplustree_span_t one_span;bplustree_span_t *temp_span;bplustree_item_t *temp_item;int i;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(right_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != right_node->type){return -1;}
	index = node->index;parent = node->parent;one_count = node->itemArray.count;
	if(node->type == 0)
	{
		one_item = node->itemArray.mem[one_count-1];bplustree_array_delete(&(node->itemArray), (one_count-1), NULL);
		bplustree_array_insert(&(right_node->itemArray), 0, one_item);
		parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index+1] = right_node->itemArray.mem[0];
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < right_node->itemArray.count;i++)
		{
			temp_item = right_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index+1] = one_span;
	}
	else
	{
		one_item = node->itemArray.mem[one_count-1];bplustree_array_delete(&(node->itemArray), (one_count-1), NULL);
		bplustree_array_insert(&(right_node->itemArray), 0, one_item);
		parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index+1] = right_node->itemArray.mem[0];
		one_node = node->childVec.mem[one_count-1];bplustree_child_vector_delete(&(node->childVec), (one_count-1), NULL);
		bplustree_child_vector_insert(&(right_node->childVec), 0, one_node);one_node->index = 0;one_node->parent = right_node;
		one_span = node->spanVec.mem[one_count-1];bplustree_span_vector_delete(&(node->spanVec), (one_count-1), NULL);
		bplustree_span_vector_insert(&(right_node->spanVec), 0, &one_span);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < right_node->itemArray.count;i++)
		{
			temp_span = &(right_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index+1] = one_span;
	}
	return 1;	
}
int bplustree_node_split(bplustree_t *tree, bplustree_node_t *node, bplustree_node_t *split_node, bplustree_node_t *root_node)
{
	int i;int j;int mid;bplustree_item_t *split_item;int index;bplustree_node_t *parent;bplustree_node_t *one_node;bplustree_item_t *one_item;
	int child_count;int one_child_count;int level;list_link_t *link;list_link_t *prev;list_link_t *next;list_t *list;
	bplustree_span_t one_span;bplustree_span_t init_span;bplustree_span_t *temp_span;bplustree_item_t *temp_item;	
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(split_node == NULL){return -1;}
	if(node->itemArray.count <= tree->check_item_count){return -1;}if(node->parent == NULL && root_node == NULL){return -1;}
	if(node->parent != NULL && root_node != NULL){return -1;}if(node->type != split_node->type){return -1;}
	if(root_node != NULL && root_node->type == 0){return -1;}	
	if(node->type == 0)
	{
		if(node->parent != NULL)
		{
			mid = (node->itemArray.count/2);split_item = node->itemArray.mem[mid];
			index = node->index;parent = node->parent;level = node->level;
			split_node->level = level;split_node->index = (index+1);split_node->parent = parent;
			i = mid;j = 0;
			while(i < node->itemArray.count)
			{
				one_item = node->itemArray.mem[i];split_node->itemArray.mem[j] = one_item;node->itemArray.mem[i] = NULL;
				i++;j++;
			}
			node->itemArray.count = mid;split_node->itemArray.count = j;
			list = &(tree->listArray[level]);link = &(split_node->link);prev = &(node->link);next = node->link.next;
			list_link_add(link, prev, next);list->count++;
			bplustree_array_insert(&(parent->itemArray), (index+1), split_item);bplustree_child_vector_insert(&(parent->childVec), (index+1), split_node);
			parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index+1] = split_node->itemArray.mem[0];
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < split_node->itemArray.count;i++)
			{
				temp_item = split_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			bplustree_span_vector_insert(&(parent->spanVec), (index+1), &one_span);
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < node->itemArray.count;i++)
			{
				temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			parent->spanVec.mem[index] = one_span;
		}
		else
		{
			mid = (node->itemArray.count/2);split_item = node->itemArray.mem[mid];level = node->level;
			root_node->level = (level+1);root_node->index = 0;root_node->parent = NULL;
			node->index = 0;node->parent = root_node;split_node->level = level;split_node->index = 1;split_node->parent = root_node;
			i = mid;j = 0;
			while(i < node->itemArray.count)
			{
				one_item = node->itemArray.mem[i];split_node->itemArray.mem[j] = one_item;node->itemArray.mem[i] = NULL;
				i++;j++;
			}
			node->itemArray.count = mid;split_node->itemArray.count = j;
			list = &(tree->listArray[level]);link = &(split_node->link);prev = &(node->link);next = node->link.next;
			list_link_add(link, prev, next);list->count++;
			root_node->itemArray.mem[0]	= node->itemArray.mem[0];root_node->itemArray.mem[1]	= split_item;
			root_node->childVec.mem[0] = node;root_node->childVec.mem[1] = split_node;
			root_node->itemArray.count = 2;root_node->childVec.count = 2;tree->root = root_node;tree->level++;
			list = &(tree->listArray[level+1]);link = &(root_node->link);prev = &(list->head);next = &(list->head);
			list_link_add(link, prev, next);list->count = 1;
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < node->itemArray.count;i++)
			{
				temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			root_node->spanVec.mem[0] = one_span;
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < split_node->itemArray.count;i++)
			{
				temp_item = split_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
			}
			root_node->spanVec.mem[1] = one_span;root_node->spanVec.count = 2;
		}
	}
	else
	{
		if(node->parent != NULL)
		{
			mid = (node->itemArray.count/2);split_item = node->itemArray.mem[mid];
			child_count = node->childVec.count;one_child_count = 0;index = node->index;parent = node->parent;level = node->level;
			split_node->level = level;split_node->index = (index+1);split_node->parent = parent;
			i = mid;j = 0;init_span.span_count = 0;init_span.span_item_count = 0;
			while(i < node->itemArray.count)
			{
				one_item = node->itemArray.mem[i];split_node->itemArray.mem[j] = one_item;node->itemArray.mem[i] = NULL;
				one_node = node->childVec.mem[i];split_node->childVec.mem[j] = one_node;node->childVec.mem[i] = NULL;
				if(one_node != NULL){one_node->index = j;one_node->parent = split_node;one_child_count++;}
				one_span = node->spanVec.mem[i];split_node->spanVec.mem[j] = one_span;node->spanVec.mem[i] = init_span;
				i++;j++;
			}
			node->itemArray.count = mid;split_node->itemArray.count = j;
			node->childVec.count = (child_count-one_child_count);split_node->childVec.count = one_child_count;
			node->spanVec.count = (child_count-one_child_count);split_node->spanVec.count = one_child_count;
			list = &(tree->listArray[level]);link = &(split_node->link);prev = &(node->link);next = node->link.next;
			list_link_add(link, prev, next);list->count++;
			bplustree_array_insert(&(parent->itemArray), (index+1), split_item);bplustree_child_vector_insert(&(parent->childVec), (index+1), split_node);
			parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index+1] = split_node->itemArray.mem[0];
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < split_node->itemArray.count;i++)
			{
				temp_span = &(split_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			}
			bplustree_span_vector_insert(&(parent->spanVec), (index+1), &one_span);
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < node->itemArray.count;i++)
			{
				temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			}
			parent->spanVec.mem[index] = one_span;
		}
		else
		{
			mid = (node->itemArray.count/2);split_item = node->itemArray.mem[mid];level = node->level;
			child_count = node->childVec.count;one_child_count = 0;
			root_node->level = (level+1);root_node->index = 0;root_node->parent = NULL;
			node->index = 0;node->parent = root_node;split_node->level = level;split_node->index = 1;split_node->parent = root_node;
			i = mid;j = 0;init_span.span_count = 0;init_span.span_item_count = 0;
			while(i < node->itemArray.count)
			{
				one_item = node->itemArray.mem[i];split_node->itemArray.mem[j] = one_item;node->itemArray.mem[i] = NULL;
				one_node = node->childVec.mem[i];split_node->childVec.mem[j] = one_node;node->childVec.mem[i] = NULL;
				if(one_node != NULL){one_node->index = j;one_node->parent = split_node;one_child_count++;}
				one_span = node->spanVec.mem[i];split_node->spanVec.mem[j] = one_span;node->spanVec.mem[i] = init_span;
				i++;j++;
			}
			node->itemArray.count = mid;split_node->itemArray.count = j;
			node->childVec.count = (child_count-one_child_count);split_node->childVec.count = one_child_count;
			node->spanVec.count = (child_count-one_child_count);split_node->spanVec.count = one_child_count;
			list = &(tree->listArray[level]);link = &(split_node->link);prev = &(node->link);next = node->link.next;
			list_link_add(link, prev, next);list->count++;
			root_node->itemArray.mem[0]	= node->itemArray.mem[0];root_node->itemArray.mem[1]	= split_item;
			root_node->childVec.mem[0] = node;root_node->childVec.mem[1] = split_node;
			root_node->itemArray.count = 2;root_node->childVec.count = 2;tree->root = root_node;tree->level++;
			list = &(tree->listArray[level+1]);link = &(root_node->link);prev = &(list->head);next = &(list->head);
			list_link_add(link, prev, next);list->count = 1;
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < node->itemArray.count;i++)
			{
				temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			}
			root_node->spanVec.mem[0] = one_span;
			one_span.span_count = 0;one_span.span_item_count = 0;
			for(i = 0;i < split_node->itemArray.count;i++)
			{
				temp_span = &(split_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
			}
			root_node->spanVec.mem[1] = one_span;root_node->spanVec.count = 2;
		}
	}
	return 1;
}
int bplustree_insert(bplustree_t *tree, byte_t *key, word_t key_len, void *value)
{
	int i;int j;int one_type_array[64];bplustree_node_t *one_node_array[64];int one_node_index;int one_node_count;int give_result;int give_level;
	bplustree_item_t *one_item;bplustree_node_t *one_node;bplustree_node_t *check_node;int check_index;bplustree_node_t *check_parent;int check_count;
	bplustree_node_t *left_node;bplustree_node_t *right_node;bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;bplustree_span_t one_span;bplustree_span_t *temp_span;bplustree_item_t *temp_item;
	list_link_t *link;list_link_t *prev;list_link_t *next;list_t *list;
	if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = bplustree_item_alloc();if(one_item == NULL){return 0;}
		one_node = bplustree_node_alloc(tree, 0);if(one_node == NULL){bplustree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_node->level = 0;one_node->index = 0;one_node->parent = NULL;one_node->itemArray.mem[0] = one_item;one_node->itemArray.count = 1;
		list = &(tree->listArray[0]);link = &(one_node->link);prev = &(list->head);next = &(list->head);
		list_link_add(link, prev, next);list->count = 1;
		tree->root = one_node;tree->level = 1;tree->count = 1;tree->item_count = 1;return 1;
	}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->itemArray.mem[result_item_index];vector_add(&(one_item->dataVec), value);tree->count++;
		check_node = result_node;
		while(check_node != NULL)
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
					}
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		return 1;
	}
	one_node_count = 0;give_result = 0;give_level = 0;check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count < tree->check_item_count){break;}
		if(check_node->parent != NULL)
		{
			check_index = check_node->index;check_parent = check_node->parent;check_count = check_parent->itemArray.count;left_node = NULL;right_node = NULL;
			if(check_index <= 0){left_node = NULL;right_node = check_parent->childVec.mem[check_index+1];}
			else if(check_index >= (check_count-1)){left_node = check_parent->childVec.mem[check_index-1];right_node = NULL;}
			else{left_node = check_parent->childVec.mem[check_index-1];right_node = check_parent->childVec.mem[check_index+1];}
			if(left_node == NULL && right_node == NULL){return -1;}
			if(left_node != NULL && left_node->itemArray.count < tree->check_item_count)
			{
				give_result = -1;give_level = check_node->level;break;
			}
			else
			{
				if(right_node != NULL && right_node->itemArray.count < tree->check_item_count)
				{
					give_result = 1;give_level = check_node->level;break;
				}
				else
				{
					one_type_array[one_node_count] = check_node->type;one_node_count += 1;check_node = check_node->parent;
				}
			}			
		}
		else{one_type_array[one_node_count] = check_node->type;one_type_array[one_node_count+1] = 1;one_node_count += 2;break;}
	}
	if(one_node_count == 0 && give_result == 0)
	{
		one_item = bplustree_item_alloc();if(one_item == NULL){return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		bplustree_array_insert(&(result_node->itemArray), (result_item_index+1), one_item);
		tree->count++;tree->item_count++;
		check_node = result_node;
		while(check_node != NULL)
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				check_parent->itemArray.mem[check_index] = check_node->itemArray.mem[0];
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
					}
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		return 1;
	}
	for(i = 0;i < one_node_count;i++){one_node = bplustree_node_alloc(tree, one_type_array[i]);if(one_node == NULL){break;}one_node_array[i] = one_node;}
	if(i != one_node_count){for(j = 0;j < i;j++){one_node = one_node_array[j];if(one_node != NULL){bplustree_node_free(one_node);}}return 0;}
	one_item = bplustree_item_alloc();
	if(one_item == NULL){for(j = 0;j < one_node_count;j++){one_node = one_node_array[j];if(one_node != NULL){bplustree_node_free(one_node);}}return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	bplustree_array_insert(&(result_node->itemArray), (result_item_index+1), one_item);
	tree->count++;tree->item_count++;one_node_index = 0;check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count <= tree->check_item_count)
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				check_parent->itemArray.mem[check_index] = check_node->itemArray.mem[0];
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
					}
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		else
		{
			if(check_node->parent != NULL)
			{
				if(give_result != 0 && give_level == check_node->level)
				{
					if(give_result == -1)
					{
						check_index = check_node->index;check_parent = check_node->parent;left_node = check_parent->childVec.mem[check_index-1];
						bplustree_node_give_left(tree, check_node, left_node);check_node = check_parent;
					}
					else
					{
						check_index = check_node->index;check_parent = check_node->parent;right_node = check_parent->childVec.mem[check_index+1];
						bplustree_node_give_right(tree, check_node, right_node);check_node = check_parent;
					}
				}
				else
				{
					bplustree_node_split(tree, check_node, one_node_array[one_node_index], NULL);one_node_index += 1;check_node = check_node->parent;
				}
			}
			else
			{
				bplustree_node_split(tree, check_node, one_node_array[one_node_index], one_node_array[one_node_index+1]);one_node_index += 2;break;
			}
		}
	}
	return 1;
}
int bplustree_node_borrow_left(bplustree_t *tree, bplustree_node_t *node, bplustree_node_t *left_node)
{
	int index;bplustree_node_t *parent;bplustree_item_t *one_item;bplustree_node_t *one_node;int one_count;
	bplustree_span_t one_span;bplustree_span_t *temp_span;bplustree_item_t *temp_item;int i;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(left_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != left_node->type){return -1;}
	index = node->index;parent = node->parent;one_count = left_node->itemArray.count;
	if(node->type == 0)
	{
		one_item = left_node->itemArray.mem[one_count-1];bplustree_array_delete(&(left_node->itemArray), (one_count-1), NULL);
		bplustree_array_insert(&(node->itemArray), 0, one_item);
		parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index-1] = left_node->itemArray.mem[0];
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < left_node->itemArray.count;i++)
		{
			temp_item = left_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index-1] = one_span;
	}
	else
	{
		one_item = left_node->itemArray.mem[one_count-1];bplustree_array_delete(&(left_node->itemArray), (one_count-1), NULL);
		bplustree_array_insert(&(node->itemArray), 0, one_item);
		parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index-1] = left_node->itemArray.mem[0];		
		one_node = left_node->childVec.mem[one_count-1];bplustree_child_vector_delete(&(left_node->childVec), (one_count-1), NULL);
		bplustree_child_vector_insert(&(node->childVec), 0, one_node);one_node->index = 0;one_node->parent = node;
		one_span = left_node->spanVec.mem[one_count-1];bplustree_span_vector_delete(&(left_node->spanVec), (one_count-1), NULL);
		bplustree_span_vector_insert(&(node->spanVec), 0, &one_span);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < left_node->itemArray.count;i++)
		{
			temp_span = &(left_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index-1] = one_span;
	}
	return 1;
}
int bplustree_node_borrow_right(bplustree_t *tree, bplustree_node_t *node, bplustree_node_t *right_node)
{
	int index;bplustree_node_t *parent;bplustree_item_t *one_item;bplustree_node_t *one_node;int one_count;
	bplustree_span_t one_span;bplustree_span_t *temp_span;bplustree_item_t *temp_item;int i;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(right_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != right_node->type){return -1;}
	index = node->index;parent = node->parent;one_count = node->itemArray.count;
	if(node->type == 0)
	{
		one_item = right_node->itemArray.mem[0];bplustree_array_delete(&(right_node->itemArray), 0, NULL);
		bplustree_array_insert(&(node->itemArray), one_count, one_item);
		parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index+1] = right_node->itemArray.mem[0];
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < right_node->itemArray.count;i++)
		{
			temp_item = right_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index+1] = one_span;
	}
	else
	{
		one_item = right_node->itemArray.mem[0];bplustree_array_delete(&(right_node->itemArray), 0, NULL);
		bplustree_array_insert(&(node->itemArray), one_count, one_item);
		parent->itemArray.mem[index] = node->itemArray.mem[0];parent->itemArray.mem[index+1] = right_node->itemArray.mem[0];
		one_node = right_node->childVec.mem[0];bplustree_child_vector_delete(&(right_node->childVec), 0, NULL);
		bplustree_child_vector_insert(&(node->childVec), one_count, one_node);one_node->index = one_count;one_node->parent = node;
		one_span = right_node->spanVec.mem[0];bplustree_span_vector_delete(&(right_node->spanVec), 0, NULL);
		bplustree_span_vector_insert(&(node->spanVec), one_count, &one_span);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index] = one_span;
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < right_node->itemArray.count;i++)
		{
			temp_span = &(right_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index+1] = one_span;
	}
	return 1;	
}
int bplustree_node_merge_right(bplustree_t *tree, bplustree_node_t *node, bplustree_node_t *right_node)
{
	int i;int j;int index;bplustree_node_t *parent;bplustree_node_t *one_node;bplustree_item_t *one_item;int one_count;int two_count;
	int one_child_count;int two_child_count;int level;list_link_t *link;list_link_t *prev;list_link_t *next;list_t *list;
	bplustree_span_t one_span;bplustree_span_t init_span;bplustree_span_t *temp_span;bplustree_item_t *temp_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(right_node == NULL){return -1;}
	if(node->parent == NULL){return -1;}if(node->type != right_node->type){return -1;}
	index = node->index;parent = node->parent;level = node->level;
	if(node->type == 0)
	{
		one_count = node->itemArray.count;two_count = right_node->itemArray.count;
		j = one_count;i = 0;
		while(i < two_count)
		{
			one_item = right_node->itemArray.mem[i];node->itemArray.mem[j] = one_item;right_node->itemArray.mem[i] = NULL;
			i++;j++;
		}
		node->itemArray.count = (one_count+two_count);right_node->itemArray.count = 0;
		list = &(tree->listArray[level]);link = &(right_node->link);prev = &(node->link);next = right_node->link.next;
		list_link_del(link, prev, next);list->count--;if(list->count <= 0){list_init(list);}bplustree_node_free(right_node);
		bplustree_array_delete(&(parent->itemArray), (index+1), NULL);bplustree_child_vector_delete(&(parent->childVec), (index+1), NULL);
		parent->itemArray.mem[index] = node->itemArray.mem[0];
		bplustree_span_vector_delete(&(parent->spanVec), (index+1), NULL);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_item = node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
		}
		parent->spanVec.mem[index] = one_span;
	}
	else
	{
		one_count = node->itemArray.count;two_count = right_node->itemArray.count;
		one_child_count = node->childVec.count;two_child_count = right_node->childVec.count;
		j = one_count;i = 0;init_span.span_count = 0;init_span.span_item_count = 0;
		while(i < two_count)
		{
			one_item = right_node->itemArray.mem[i];node->itemArray.mem[j] = one_item;right_node->itemArray.mem[i] = NULL;
			one_node = right_node->childVec.mem[i];node->childVec.mem[j] = one_node;right_node->childVec.mem[i] = NULL;
			if(one_node != NULL){one_node->index = j;one_node->parent = node;}
			one_span = right_node->spanVec.mem[i];node->spanVec.mem[j] = one_span;right_node->spanVec.mem[i] = init_span;
			i++;j++;
		}
		node->itemArray.count = (one_count+two_count);right_node->itemArray.count = 0;
		node->childVec.count = (one_child_count+two_child_count);right_node->childVec.count = 0;
		node->spanVec.count = (one_child_count+two_child_count);right_node->spanVec.count = 0;
		list = &(tree->listArray[level]);link = &(right_node->link);prev = &(node->link);next = right_node->link.next;
		list_link_del(link, prev, next);list->count--;if(list->count <= 0){list_init(list);}bplustree_node_free(right_node);
		bplustree_array_delete(&(parent->itemArray), (index+1), NULL);bplustree_child_vector_delete(&(parent->childVec), (index+1), NULL);
		parent->itemArray.mem[index] = node->itemArray.mem[0];
		bplustree_span_vector_delete(&(parent->spanVec), (index+1), NULL);
		one_span.span_count = 0;one_span.span_item_count = 0;
		for(i = 0;i < node->itemArray.count;i++)
		{
			temp_span = &(node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
		}
		parent->spanVec.mem[index] = one_span;		
	}
	return 1;
}
int bplustree_remove(bplustree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;bplustree_item_t *result_item;
	bplustree_node_t *left_node;bplustree_node_t *right_node;bplustree_node_t *check_node;int check_index;bplustree_node_t *check_parent;
	int check_count;int temp_result;bplustree_node_t *root_node;bplustree_span_t one_span;bplustree_span_t init_span;
	bplustree_span_t *temp_span;bplustree_item_t *temp_item;int i;int level;list_link_t *link;list_link_t *prev;list_link_t *next;list_t *list;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	result_item = result_node->itemArray.mem[result_item_index];if(result_data_vec != NULL){vector_copy_vec(&(result_item->dataVec), result_data_vec);}
	tree->count -= result_item->dataVec.count;tree->item_count -= 1;bplustree_item_free(result_item);
	bplustree_array_delete(&(result_node->itemArray), result_item_index, NULL);check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->itemArray.count >= ((tree->check_item_count+1)/2))
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;
				check_parent->itemArray.mem[check_index] = check_node->itemArray.mem[0];
				one_span.span_count = 0;one_span.span_item_count = 0;
				if(check_node->type == 0)
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
					}
				}
				else
				{
					for(i = 0;i < check_node->itemArray.count;i++)
					{
						temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
					}
				}
				check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
			}
			else{break;}
		}
		else
		{
			if(check_node->parent != NULL)
			{
				check_index = check_node->index;check_parent = check_node->parent;check_count = check_parent->itemArray.count;left_node = NULL;right_node = NULL;
				if(check_index <= 0){left_node = NULL;right_node = check_parent->childVec.mem[check_index+1];}
				else if(check_index >= (check_count-1)){left_node = check_parent->childVec.mem[check_index-1];right_node = NULL;}
				else{left_node = check_parent->childVec.mem[check_index-1];right_node = check_parent->childVec.mem[check_index+1];}
				if(left_node == NULL && right_node == NULL){return -1;}
				if(left_node != NULL && left_node->itemArray.count > ((tree->check_item_count+1)/2))
				{
					bplustree_node_borrow_left(tree, check_node, left_node);check_node = check_parent;
				}
				else
				{
					if(right_node != NULL && right_node->itemArray.count > ((tree->check_item_count+1)/2))
					{
						bplustree_node_borrow_right(tree, check_node, right_node);check_node = check_parent;
					}
					else
					{
						if(left_node != NULL){bplustree_node_merge_right(tree, left_node, check_node);check_node = check_parent;}
						else{bplustree_node_merge_right(tree, check_node, right_node);check_node = check_parent;}
					}
				}
			}
			else
			{
				if(check_node->itemArray.count <= 1)
				{
					if(check_node->childVec.count <= 0)
					{
						if(check_node->itemArray.count <= 0)
						{
							level = check_node->level;list = &(tree->listArray[level]);link = &(check_node->link);prev = &(list->head);next = &(list->head);
							list_link_del(link, prev, next);list->count--;if(list->count <= 0){list_init(list);}
							bplustree_node_free(check_node);tree->root = NULL;tree->level = 0;break;
						}
						else
						{
							break;
						}						
					}
					else
					{
						root_node = check_node->childVec.mem[0];check_node->childVec.mem[0] = NULL;check_node->childVec.count = 0;
						check_node->itemArray.mem[0] = NULL;check_node->itemArray.count = 0;init_span.span_count = 0;init_span.span_item_count = 0;
						check_node->spanVec.mem[0] = init_span;check_node->spanVec.count = 0;
						level = check_node->level;list = &(tree->listArray[level]);link = &(check_node->link);prev = &(list->head);next = &(list->head);
						list_link_del(link, prev, next);list->count--;if(list->count <= 0){list_init(list);}
						bplustree_node_free(check_node);tree->level--;
						if(root_node != NULL){root_node->index = 0;root_node->parent = NULL;}tree->root = root_node;break;
					}
				}
				else
				{
					break;
				}
			}
		}
	}
	return 1;
}
int bplustree_get_rank_min_max_item(bplustree_t *tree, int min_rank, int max_rank, vector_t *all_item_vec)
{
	vector_t one_item_vec;bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;bplustree_node_t *next_node;int next_item_index;
	bplustree_node_t *min_node;int min_item_index;bplustree_item_t *min_item;bplustree_node_t *max_node;int max_item_index;bplustree_item_t *max_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, min_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, max_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	vector_init(&one_item_vec);
	if(min_item == max_item){vector_add(all_item_vec, min_item);vector_free(&one_item_vec);return 1;}
	vector_add(&one_item_vec, min_item);
	next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	while(check_item != NULL && check_item != max_item)
	{
		vector_add(&one_item_vec, check_item);
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	}
	vector_add(&one_item_vec, max_item);vector_add_vec_two(&one_item_vec, all_item_vec);vector_free(&one_item_vec);return 1;
}
int bplustree_get_rank_min_max_item_two(bplustree_t *tree, int min_rank, int max_rank, vector_t *all_item_vec)
{
	vector_t one_item_vec;bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;bplustree_node_t *next_node;int next_item_index;
	bplustree_node_t *min_node;int min_item_index;bplustree_item_t *min_item;bplustree_node_t *max_node;int max_item_index;bplustree_item_t *max_item;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, min_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, max_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	vector_init(&one_item_vec);
	if(min_item == max_item)
	{
		vector_add(&one_item_vec, min_item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
		vector_free(&one_item_vec);return 1;
	}
	vector_add(&one_item_vec, min_item);
	next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
	if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
	check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	while(check_item != NULL && check_item != max_item)
	{
		vector_add(&one_item_vec, check_item);
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
	}
	vector_add(&one_item_vec, max_item);vector_set_vec(&one_item_vec, all_item_vec);vector_init(&one_item_vec);
	vector_free(&one_item_vec);return 1;
}
int bplustree_lower_upper_remove(bplustree_t *tree, byte_t *key, word_t key_len, int lower_index, int upper_index)
{
	bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;int temp_result;bplustree_item_t *check_item;
	int one_count;bplustree_node_t *check_node;int check_index;bplustree_node_t *check_parent;bplustree_span_t one_span;bplustree_span_t *temp_span;
	bplustree_item_t *temp_item;int i;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	if(lower_index < 0){return -1;}if(upper_index < 0){return -1;}if(lower_index > upper_index){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_base(tree, tree->root, key, key_len, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	check_item = result_node->itemArray.mem[result_item_index];one_count = check_item->dataVec.count;
	if(lower_index >= one_count){return -1;}if(upper_index >= one_count){return -1;}one_count = (upper_index-lower_index+1);
	vector_delete_min_max(&(check_item->dataVec), lower_index, upper_index);
	tree->count -= one_count;check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->parent != NULL)
		{
			check_index = check_node->index;check_parent = check_node->parent;
			one_span.span_count = 0;one_span.span_item_count = 0;
			if(check_node->type == 0)
			{
				for(i = 0;i < check_node->itemArray.count;i++)
				{
					temp_item = check_node->itemArray.mem[i];one_span.span_count += temp_item->dataVec.count;one_span.span_item_count += 1;
				}
			}
			else
			{
				for(i = 0;i < check_node->itemArray.count;i++)
				{
					temp_span = &(check_node->spanVec.mem[i]);one_span.span_count += temp_span->span_count;one_span.span_item_count += temp_span->span_item_count;
				}
			}
			check_parent->spanVec.mem[check_index] = one_span;check_node = check_parent;
		}
		else{break;}
	}
	return 1;
}
int bplustree_rank_min_max_remove(bplustree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;bplustree_item_t *one_item;vector_t one_item_vec;bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;bplustree_node_t *next_node;int next_item_index;
	int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;bplustree_node_t *min_node;int min_item_index;
	bplustree_item_t *min_item;bplustree_node_t *max_node;int max_item_index;bplustree_item_t *max_item;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, min_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	one_count = min_item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, max_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	one_count = max_item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	vector_init(&one_item_vec);
	if(min_item != max_item)
	{
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		while(check_item != NULL && check_item != max_item)
		{
			vector_add(&one_item_vec, check_item);
			next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
			if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
			check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		}
	}
	if(min_item == max_item)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_item->dataVec), result_data_vec);}
    	bplustree_remove(tree, min_item->key, min_item->key_len, NULL);
    	vector_free(&one_item_vec);return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	bplustree_lower_upper_remove(tree, min_item->key, min_item->key_len, (min_rank-lower_min_rank), (max_rank-lower_min_rank));
    	vector_free(&one_item_vec);return 1;
    }
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_item->dataVec), result_data_vec);}
  	bplustree_remove(tree, min_item->key, min_item->key_len, NULL);
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	bplustree_lower_upper_remove(tree, min_item->key, min_item->key_len, (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));
  }
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  	bplustree_remove(tree, one_item->key, one_item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_item->dataVec), result_data_vec);}
  	bplustree_remove(tree, max_item->key, max_item->key_len, NULL);
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	bplustree_lower_upper_remove(tree, max_item->key, max_item->key_len, 0, (max_rank-lower_max_rank));
  }
	vector_free(&one_item_vec);return 1;
}
int bplustree_rank_min_max_get(bplustree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;bplustree_item_t *one_item;vector_t one_item_vec;bplustree_node_t *result_node;int result_item_index;int result_rank_count;int result_rank_item_count;
	int temp_result;bplustree_node_t *check_node;int check_item_index;bplustree_item_t *check_item;bplustree_node_t *next_node;int next_item_index;
	int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;bplustree_node_t *min_node;int min_item_index;
	bplustree_item_t *min_item;bplustree_node_t *max_node;int max_item_index;bplustree_item_t *max_item;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->count){return -1;}
	if(max_rank < 1){return -1;}if(max_rank > tree->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, min_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);	
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	one_count = min_item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = bplustree_find_rank(tree, tree->root, max_rank, &result_node, &result_item_index, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	one_count = max_item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	vector_init(&one_item_vec);
	if(min_item != max_item)
	{
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		while(check_item != NULL && check_item != max_item)
		{
			vector_add(&one_item_vec, check_item);
			next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
			if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
			check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		}
	}
	if(min_item == max_item)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_item->dataVec), result_data_vec);}
    	vector_free(&one_item_vec);return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_free(&one_item_vec);return 1;
    }
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_item_vec);return 1;
}
int bplustree_min_max_remove(bplustree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;bplustree_item_t *one_item;vector_t one_item_vec;bplustree_node_t *result_node;int result_item_index;int temp_result;bplustree_node_t *check_node;
	int check_item_index;bplustree_item_t *check_item;bplustree_node_t *next_node;int next_item_index;bplustree_node_t *min_node;int min_item_index;
	bplustree_item_t *min_item;bplustree_node_t *max_node;int max_item_index;bplustree_item_t *max_item;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = bplustree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;temp_result = bplustree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	vector_init(&one_item_vec);
	if(min_item != max_item)
	{
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		while(check_item != NULL && check_item != max_item)
		{
			vector_add(&one_item_vec, check_item);
			next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
			if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
			check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		}
	}
	if(min_item == max_item)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_item->dataVec), result_data_vec);}
    bplustree_remove(tree, min_item->key, min_item->key_len, NULL);
    vector_free(&one_item_vec);return 1;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_item->dataVec), result_data_vec);}
  bplustree_remove(tree, min_item->key, min_item->key_len, NULL);
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  	bplustree_remove(tree, one_item->key, one_item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_item->dataVec), result_data_vec);}
  bplustree_remove(tree, max_item->key, max_item->key_len, NULL);
	vector_free(&one_item_vec);return 1;
}
int bplustree_min_max_get(bplustree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;bplustree_item_t *one_item;vector_t one_item_vec;bplustree_node_t *result_node;int result_item_index;int temp_result;bplustree_node_t *check_node;
	int check_item_index;bplustree_item_t *check_item;bplustree_node_t *next_node;int next_item_index;bplustree_node_t *min_node;int min_item_index;
	bplustree_item_t *min_item;bplustree_node_t *max_node;int max_item_index;bplustree_item_t *max_item;if(result_data_vec != NULL){vector_free(result_data_vec);}
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = bplustree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	min_node = result_node;min_item_index = result_item_index;min_item = min_node->itemArray.mem[min_item_index];
	result_node = NULL;temp_result = bplustree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node, &result_item_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}if(result_node->level > 0){return 0;}
	max_node = result_node;max_item_index = result_item_index;max_item = max_node->itemArray.mem[max_item_index];
	vector_init(&one_item_vec);
	if(min_item != max_item)
	{
		next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, min_node, min_item_index, &next_node, &next_item_index);
		if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
		check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		while(check_item != NULL && check_item != max_item)
		{
			vector_add(&one_item_vec, check_item);
			next_node = NULL;temp_result = bplustree_inorder_get_next_node_item(tree, check_node, check_item_index, &next_node, &next_item_index);
			if(temp_result == -1){vector_free(&one_item_vec);return -1;}if(next_node == NULL){vector_free(&one_item_vec);return 0;}
			check_node = next_node;check_item_index = next_item_index;check_item = check_node->itemArray.mem[check_item_index];
		}
	}
	if(min_item == max_item)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_item->dataVec), result_data_vec);}
    vector_free(&one_item_vec);return 1;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_item->dataVec), result_data_vec);}
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_item->dataVec), result_data_vec);}
	vector_free(&one_item_vec);return 1;
}
int bplustree_iterator_init(bplustree_t *tree, bplustree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return 0;}bplustree_inorder_get_all_item(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
bplustree_iterator_t * bplustree_iterator_alloc(bplustree_t *tree)
{
	size_t size;bplustree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(bplustree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(bplustree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void bplustree_iterator_free(bplustree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int bplustree_iterator_next(bplustree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;		
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}	
}
void bplustree_item_dump(FILE *fd, bplustree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void bplustree_dump(FILE *fd, bplustree_t *tree)
{
	bplustree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = bplustree_iterator_alloc(tree);if(iterator == NULL){return ;}
	bplustree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(bplustree_iterator_next(iterator) == 1){bplustree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	bplustree_iterator_free(iterator);
}
void bplustree_dump_inorder_other(FILE *fd, bplustree_t *tree)
{
	int i;bplustree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}bplustree_inorder_get_all_item_other(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){bplustree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void bplustree_dump_inorder_other_two(FILE *fd, bplustree_t *tree)
{
	int i;bplustree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}bplustree_inorder_get_all_item_other_two(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){bplustree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void bplustree_dump_inorder_another(FILE *fd, bplustree_t *tree)
{
	int i;bplustree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}bplustree_inorder_get_all_item_another(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){bplustree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void bplustree_dump_inorder_another_two(FILE *fd, bplustree_t *tree)
{
	int i;bplustree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->item_count) == 0){return ;}bplustree_inorder_get_all_item_another_two(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){bplustree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void bplustree_dump_inorder_min_max(FILE *fd, bplustree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len)
{
	int i;bplustree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	bplustree_get_min_max_item_two(tree, min_key, min_key_len, max_key, max_key_len, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){bplustree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);	
}
void bplustree_dump_inorder_rank_min_max(FILE *fd, bplustree_t *tree, int min_rank, int max_rank)
{
	int i;bplustree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	bplustree_get_rank_min_max_item_two(tree, min_rank, max_rank, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){bplustree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);	
}
void bplustree_list_node_dump(FILE *fd, bplustree_node_t *node)
{
	int i;bplustree_span_t *one_span;bplustree_item_t *one_item;fprintf(fd, "[ ");
	if(node->type == 0)
	{
		for(i = 0;i < node->itemArray.count;i++)
		{
			one_item = node->itemArray.mem[i];if(one_item != NULL){bplustree_item_dump(fd, one_item);}
			if(i < (node->itemArray.count-1)){fprintf(fd, " | ");}
		}
	}
	else
	{
		for(i = 0;i < node->itemArray.count;i++)
		{
			one_span = &(node->spanVec.mem[i]);fprintf(fd, "%d : %d , ", one_span->span_count, one_span->span_item_count);
			one_item = node->itemArray.mem[i];if(one_item != NULL){bplustree_item_dump(fd, one_item);}
			if(i < (node->itemArray.count-1)){fprintf(fd, " | ");}
		}
	}
	fprintf(fd, " ]");
}
void bplustree_one_list_dump(FILE *fd, list_t *list)
{
	bplustree_node_t *node;list_link_t *link;list_link_t *next;list_link_t *end;
	link = list->head.next;next = link->next;end = &(list->head);fprintf(fd, "{ ");
	while(link != end)
	{
		node = NULL;list_link_get_node(link, &node);if(node != NULL){bplustree_list_node_dump(fd, node);}if(next != end){fprintf(fd, " , ");}
		link = next;next = link->next;
	}
	fprintf(fd, " }\n");	
}
void bplustree_all_list_dump(FILE *fd, bplustree_t *tree)
{
	int i;int level;list_t *list;if(tree == NULL){return ;}if(tree->root == NULL){return ;}level = tree->level;
	for(i = (level-1); i >= 0; i--)
	{
		fprintf(fd, "[%d] ", i);list = &(tree->listArray[i]);bplustree_one_list_dump(fd, list);
	}
	fprintf(fd, "\n");
}
void bplustree_dot_node_dump(FILE *fd, bplustree_node_t *node, int *nDump)
{
	int i;bplustree_node_t *one_node;bplustree_item_t *one_item;bplustree_span_t *one_span;int one_count;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n",oneDump, node->type, node->level, node->index);*nDump = (oneDump+1);
	one_count = node->itemArray.count;
	for(i = 0;i < one_count;i++)
	{
		one_item = node->itemArray.mem[i];if(one_item != NULL){fprintf(fd, "%s:%d\\n",((char *)(one_item->key)),one_item->dataVec.count);}
	}
	fprintf(fd, "\"];\n");
	one_count = node->childVec.count;
	for(i = 0;i < one_count;i++)
	{
		one_node = node->childVec.mem[i];one_span = &(node->spanVec.mem[i]);
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d] [%d:%d]\", color=\"blue\"];\n", oneDump, twoDump, i, one_span->span_count, one_span->span_item_count);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			bplustree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void bplustree_dot_dump(bplustree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("bplustree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph bplustree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");
	bplustree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;bplustree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = bplustree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    bplustree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	bplustree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_other(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_other_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_another(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_another_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_min_max(fd, tree, (byte_t *)(arrKeyStr[3]), strlen(arrKeyStr[3]), (byte_t *)(arrKeyStr[9]), strlen(arrKeyStr[9]));
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_rank_min_max(fd, tree, 3, 9);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_all_list_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    bplustree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	bplustree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_other(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_other_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_another(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_another_two(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_min_max(fd, tree, (byte_t *)(arrKeyStr[3]), strlen(arrKeyStr[3]), (byte_t *)(arrKeyStr[9]), strlen(arrKeyStr[9]));
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_dump_inorder_rank_min_max(fd, tree, 3, 9);
	fprintf(fd, "\n");fprintf(fd, "\n");
	bplustree_all_list_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	bplustree_dot_dump(tree);
	bplustree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

size_balance_tree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} size_balance_tree_item_t;
typedef struct size_balance_tree_node {
	int type;int depth;int count;int item_count;int index;struct size_balance_tree_node *parent;size_balance_tree_item_t *item;struct size_balance_tree_node *childArray[2];
} size_balance_tree_node_t;
typedef struct {size_balance_tree_node_t *root;} size_balance_tree_t;
typedef struct {size_balance_tree_t *tree;int vec_index;vector_t all_item_vec;size_balance_tree_item_t *item;} size_balance_tree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int size_balance_tree_item_init(size_balance_tree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
size_balance_tree_item_t * size_balance_tree_item_alloc()
{
  size_t size;size_balance_tree_item_t *item;size = sizeof(size_balance_tree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  size_balance_tree_item_init(item);return item;
}
int size_balance_tree_item_other_free(size_balance_tree_item_t *item){vector_free(&(item->dataVec));size_balance_tree_item_init(item);return 1;}
void size_balance_tree_item_free(size_balance_tree_item_t *item){if(item != NULL){size_balance_tree_item_other_free(item);free(item);}}
int size_balance_tree_node_init(size_balance_tree_node_t *node)
{
	node->type = 0;node->depth = 0;node->count = 0;node->item_count = 0;node->index = 0;node->parent = NULL;
	node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
size_balance_tree_node_t * size_balance_tree_node_alloc()
{
	size_t size;size_balance_tree_node_t *node;size = sizeof(size_balance_tree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	size_balance_tree_node_init(node);return node;
}
int size_balance_tree_node_other_free(size_balance_tree_node_t *node)
{
	if(node->item != NULL){size_balance_tree_item_free(node->item);node->item = NULL;}size_balance_tree_node_init(node);return 1;
}
void size_balance_tree_node_free(size_balance_tree_node_t *node)
{
	if(node != NULL){size_balance_tree_node_other_free(node);free(node);}
}
void size_balance_tree_node_destroy(size_balance_tree_node_t **node)
{
	size_balance_tree_node_t **size_balance_tree_node;size_balance_tree_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	if(one_node->childArray[0] != NULL){size_balance_tree_node = &(one_node->childArray[0]);size_balance_tree_node_destroy(size_balance_tree_node);one_node->childArray[0] = NULL;}
	if(one_node->childArray[1] != NULL){size_balance_tree_node = &(one_node->childArray[1]);size_balance_tree_node_destroy(size_balance_tree_node);one_node->childArray[1] = NULL;}
	size_balance_tree_node_free((*node));*node = NULL;
}
void size_balance_tree_node_get_all_item(size_balance_tree_node_t *node, vector_t *all_item_vec)
{
	if(node == NULL){return ;}
	if(node->childArray[0] != NULL){size_balance_tree_node_get_all_item(node->childArray[0], all_item_vec);}
	if(node->item != NULL){vector_add(all_item_vec, node->item);}
	if(node->childArray[1] != NULL){size_balance_tree_node_get_all_item(node->childArray[1], all_item_vec);}
}
int size_balance_tree_preorder_get_all_item(size_balance_tree_t *tree, vector_t *all_item_vec)
{
	size_balance_tree_node_t *last_node;size_balance_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else{if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int size_balance_tree_inorder_get_next_item(size_balance_tree_t *tree, size_balance_tree_node_t *node, size_balance_tree_node_t **result_node)
{
	size_balance_tree_node_t *last_node;size_balance_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}			
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int size_balance_tree_inorder_get_all_item(size_balance_tree_t *tree, vector_t *all_item_vec)
{
	size_balance_tree_node_t *last_node;size_balance_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int size_balance_tree_postorder_get_all_item(size_balance_tree_t *tree, vector_t *all_item_vec)
{
	size_balance_tree_node_t *last_node;size_balance_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{		
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
		else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else
				{
					if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
size_balance_tree_t * size_balance_tree_alloc()
{
	size_t size;size_balance_tree_t *tree;size = sizeof(size_balance_tree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;return tree;
}
void size_balance_tree_destroy(size_balance_tree_t *tree)
{
	size_balance_tree_node_t **size_balance_tree_node;if(tree == NULL){return ;}if(tree->root == NULL){free(tree);return ;}
	size_balance_tree_node = &(tree->root);size_balance_tree_node_destroy(size_balance_tree_node);tree->root = NULL;free(tree);
}
int size_balance_tree_node_rotate_left_child(size_balance_tree_t *tree, size_balance_tree_node_t *node, size_balance_tree_node_t *left_child)
{
	int index;size_balance_tree_node_t *parent;size_balance_tree_node_t *right_child;size_balance_tree_node_t *left_left_child;size_balance_tree_node_t *left_right_child;
	int right_depth;int left_left_depth;int left_right_depth;int right_count;int left_left_count;int left_right_count;
	int right_item_count;int left_left_item_count;int left_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(left_child == NULL){return -1;}if(node->childArray[0] != left_child){return -1;}
	if(node->item == NULL){return -1;}if(left_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	right_child = node->childArray[1];left_left_child = left_child->childArray[0];left_right_child = left_child->childArray[1];
	if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
	else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
	if(left_left_child == NULL){left_left_depth = -1;left_left_count = 0;left_left_item_count = 0;}
	else{left_left_depth = left_left_child->depth;left_left_count = left_left_child->count;left_left_item_count = left_left_child->item_count;}
	if(left_right_child == NULL){left_right_depth = -1;left_right_count = 0;left_right_item_count = 0;}
	else{left_right_depth = left_right_child->depth;left_right_count = left_right_child->count;left_right_item_count = left_right_child->item_count;}
	if(parent == NULL){tree->root = left_child;left_child->index = 0;left_child->parent = NULL;}
	else{parent->childArray[index] = left_child;left_child->index = index;left_child->parent = parent;}
	left_child->childArray[1] = node;node->index = 1;node->parent = left_child;
	node->childArray[0] = left_right_child;if(left_right_child != NULL){left_right_child->index = 0;left_right_child->parent = node;}
	node->type = (right_item_count-left_right_item_count);node->depth = max((left_right_depth+1), (right_depth+1));
	node->count = node->item->dataVec.count;node->count += left_right_count;node->count += right_count;
	node->item_count = 1;node->item_count += left_right_item_count;node->item_count += right_item_count;
	left_child->type = (node->item_count-left_left_item_count);left_child->depth = max((left_left_depth+1), (node->depth+1));
	left_child->count = left_child->item->dataVec.count;left_child->count += left_left_count;left_child->count += node->count;
	left_child->item_count = 1;left_child->item_count += left_left_item_count;left_child->item_count += node->item_count;
	return 1;
}
int size_balance_tree_node_rotate_right_child(size_balance_tree_t *tree, size_balance_tree_node_t *node, size_balance_tree_node_t *right_child)
{
	int index;size_balance_tree_node_t *parent;size_balance_tree_node_t *left_child;size_balance_tree_node_t *right_left_child;size_balance_tree_node_t *right_right_child;
	int left_depth;int right_left_depth;int right_right_depth;int left_count;int right_left_count;int right_right_count;
	int left_item_count;int right_left_item_count;int right_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(right_child == NULL){return -1;}if(node->childArray[1] != right_child){return -1;}
	if(node->item == NULL){return -1;}if(right_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	left_child = node->childArray[0];right_left_child = right_child->childArray[0];right_right_child = right_child->childArray[1];
	if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
	else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
	if(right_left_child == NULL){right_left_depth = -1;right_left_count = 0;right_left_item_count = 0;}
	else{right_left_depth = right_left_child->depth;right_left_count = right_left_child->count;right_left_item_count = right_left_child->item_count;}
	if(right_right_child == NULL){right_right_depth = -1;right_right_count = 0;right_right_item_count = 0;}
	else{right_right_depth = right_right_child->depth;right_right_count = right_right_child->count;right_right_item_count = right_right_child->item_count;}
	if(parent == NULL){tree->root = right_child;right_child->index = 0;right_child->parent = NULL;}
	else{parent->childArray[index] = right_child;right_child->index = index;right_child->parent = parent;}
	right_child->childArray[0] = node;node->index = 0;node->parent = right_child;
	node->childArray[1] = right_left_child;if(right_left_child != NULL){right_left_child->index = 1;right_left_child->parent = node;}
	node->type = (right_left_item_count-left_item_count);node->depth = max((left_depth+1), (right_left_depth+1));
	node->count = node->item->dataVec.count;node->count += left_count;node->count += right_left_count;
	node->item_count = 1;node->item_count += left_item_count;node->item_count += right_left_item_count;
	right_child->type = (right_right_item_count-node->item_count);right_child->depth = max((node->depth+1), (right_right_depth+1));
	right_child->count = right_child->item->dataVec.count;right_child->count += node->count;right_child->count += right_right_count;
	right_child->item_count = 1;right_child->item_count += node->item_count;right_child->item_count += right_right_item_count;
	return 1;	
}
int size_balance_tree_node_rotate(size_balance_tree_t *tree, size_balance_tree_node_t *node)
{
	int index;size_balance_tree_node_t *parent;size_balance_tree_node_t *one_node;size_balance_tree_node_t *one_left_child;size_balance_tree_node_t *one_right_child;
	size_balance_tree_node_t *left_child;size_balance_tree_node_t *right_child;size_balance_tree_node_t *left_left_child;size_balance_tree_node_t *left_right_child;
	size_balance_tree_node_t *right_left_child;size_balance_tree_node_t *right_right_child;int left_item_count;int right_item_count;int left_left_item_count;
	int left_right_item_count;int right_left_item_count;int right_right_item_count;int one_left_depth;int one_right_depth;int one_left_count;
	int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(node->type == 0){return 0;}index = node->index;parent = node->parent;
	if(node->type < 0)
	{
		if(node->childArray[0] == NULL){return -1;}left_child = node->childArray[0];if(left_child->item == NULL){return -1;}
		if(left_child->type > 0)
		{
			if(left_child->childArray[1] == NULL){return -1;}left_right_child = left_child->childArray[1];if(left_right_child->item == NULL){return -1;}
			if(node->childArray[1] == NULL){right_item_count = 0;}else{right_item_count = node->childArray[1]->item_count;}
			left_right_item_count = left_right_child->item_count;
			if(right_item_count >= left_right_item_count){return 0;}
			size_balance_tree_node_rotate_right_child(tree, left_child, left_right_child);
			one_left_child = node->childArray[0];one_right_child = node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			node->type = (one_right_item_count-one_left_item_count);node->depth = max((one_left_depth+1), (one_right_depth+1));
			node->count = node->item->dataVec.count;node->count += one_left_count;node->count += one_right_count;
			node->item_count = 1;node->item_count += one_left_item_count;node->item_count += one_right_item_count;
			size_balance_tree_node_rotate_left_child(tree, node, one_left_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];size_balance_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];size_balance_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_item_count-one_left_item_count);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			size_balance_tree_node_rotate(tree, one_node);return 1;
		}
		else
		{
			left_left_child = left_child->childArray[0];
			if(node->childArray[1] == NULL){right_item_count = 0;}else{right_item_count = node->childArray[1]->item_count;}
			if(left_left_child == NULL){left_left_item_count = 0;}else{left_left_item_count = left_left_child->item_count;}
			if(right_item_count >= left_left_item_count){return 0;}
			size_balance_tree_node_rotate_left_child(tree, node, left_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];size_balance_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];size_balance_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_item_count-one_left_item_count);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			size_balance_tree_node_rotate(tree, one_node);return 1;
		}
	}
	else if(node->type > 0)
	{
		if(node->childArray[1] == NULL){return -1;}right_child = node->childArray[1];if(right_child->item == NULL){return -1;}
		if(right_child->type < 0)
		{
			if(right_child->childArray[0] == NULL){return -1;}right_left_child = right_child->childArray[0];if(right_left_child->item == NULL){return -1;}
			if(node->childArray[0] == NULL){left_item_count = 0;}else{left_item_count = node->childArray[0]->item_count;}
			right_left_item_count = right_left_child->item_count;
			if(left_item_count >= right_left_item_count){return 0;}
			size_balance_tree_node_rotate_left_child(tree, right_child, right_left_child);
			one_left_child = node->childArray[0];one_right_child = node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			node->type = (one_right_item_count-one_left_item_count);node->depth = max((one_left_depth+1), (one_right_depth+1));
			node->count = node->item->dataVec.count;node->count += one_left_count;node->count += one_right_count;
			node->item_count = 1;node->item_count += one_left_item_count;node->item_count += one_right_item_count;
			size_balance_tree_node_rotate_right_child(tree, node, one_right_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];size_balance_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];size_balance_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_item_count-one_left_item_count);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			size_balance_tree_node_rotate(tree, one_node);return 1;
		}
		else
		{
			right_right_child = right_child->childArray[1];
			if(node->childArray[0] == NULL){left_item_count = 0;}else{left_item_count = node->childArray[0]->item_count;}
			if(right_right_child == NULL){right_right_item_count = 0;}else{right_right_item_count = right_right_child->item_count;}
			if(left_item_count >= right_right_item_count){return 0;}			
			size_balance_tree_node_rotate_right_child(tree, node, right_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];size_balance_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];size_balance_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_item_count-one_left_item_count);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			size_balance_tree_node_rotate(tree, one_node);return 1;
		}
	}
	return 0;
}
int size_balance_tree_find_rank(size_balance_tree_t *tree, size_balance_tree_node_t *node, int rank, size_balance_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count)
{
	size_balance_tree_node_t *left_child;int left_count;int left_item_count;size_balance_tree_node_t *check_node;int check_count;int check_item_count;
	int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(rank < 1){return -1;}if(rank > tree->root->count){return -1;}*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;
	check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}if((rank-rank_count) > check_node->count){return -1;}left_child = check_node->childArray[0];
		if(left_child == NULL){left_count = 0;left_item_count = 0;}else{left_count = left_child->count;left_item_count = left_child->item_count;}
		check_count = (left_count+(check_node->item->dataVec.count));check_item_count = (left_item_count+1);
		if((rank-rank_count) > check_count)
		{
			rank_count += check_count;rank_item_count += check_item_count;
			if(check_node->childArray[1] == NULL){return 2;}else{check_node = check_node->childArray[1];}
		}
		else if((rank-rank_count) <= left_count)
		{
			if(check_node->childArray[0] == NULL){return 2;}else{check_node = check_node->childArray[0];}			
		}
		else
		{
			rank_count += check_count;rank_item_count += check_item_count;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}		
	}
	return 0;
}
int size_balance_tree_find_base(size_balance_tree_t *tree, size_balance_tree_node_t *node, byte_t *key, word_t key_len, size_balance_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count, int *result_index)
{
	int one;size_balance_tree_item_t *item;size_balance_tree_node_t *check_node;int rank_count;int rank_item_count;size_balance_tree_node_t *one_child;
	int one_count;int one_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;*result_index = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			if(check_node->childArray[1] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 1;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 0;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}
	}
	return 0;
}
int size_balance_tree_find_max(size_balance_tree_t *tree, size_balance_tree_node_t *node, size_balance_tree_node_t **result_node)
{
	size_balance_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[1] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[1];}
	}
	return 0;
}
int size_balance_tree_find_min(size_balance_tree_t *tree, size_balance_tree_node_t *node, size_balance_tree_node_t **result_node)
{
	size_balance_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[0] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[0];}
	}
	return 0;
}
int size_balance_tree_find_first_upper_equal(size_balance_tree_t *tree, size_balance_tree_node_t *node, byte_t *key, word_t key_len, size_balance_tree_node_t **result_node)
{
	int one;size_balance_tree_item_t *item;size_balance_tree_node_t *check_node;size_balance_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int size_balance_tree_find_last_lower_equal(size_balance_tree_t *tree, size_balance_tree_node_t *node, byte_t *key, word_t key_len, size_balance_tree_node_t **result_node)
{
	int one;size_balance_tree_item_t *item;size_balance_tree_node_t *check_node;size_balance_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int size_balance_tree_get_rank(size_balance_tree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	size_balance_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = size_balance_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int size_balance_tree_check_exist(size_balance_tree_t *tree, byte_t *key, word_t key_len)
{
	size_balance_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = size_balance_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}return 1;
}
int size_balance_tree_get(size_balance_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	size_balance_tree_item_t *item;size_balance_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = size_balance_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(item->dataVec), result_data_vec);}return 1;
}
int size_balance_tree_insert(size_balance_tree_t *tree, byte_t *key, word_t key_len, void *value)
{
	size_balance_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;size_balance_tree_item_t *one_item;
	size_balance_tree_node_t *one_node;size_balance_tree_node_t *check_node;size_balance_tree_node_t *check_parent;size_balance_tree_node_t *left_child;size_balance_tree_node_t *right_child;
	int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = size_balance_tree_item_alloc();if(one_item == NULL){return 0;}
		one_node = size_balance_tree_node_alloc();if(one_node == NULL){size_balance_tree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;one_node->index = 0;one_node->parent = NULL;
		one_node->item = one_item;tree->root = one_node;return 1;
	}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = size_balance_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->item;vector_add(&(one_item->dataVec), value);check_node = result_node;
		while(check_node != NULL){check_node->count++;check_node = check_node->parent;}return 1;		
	}
	one_item = size_balance_tree_item_alloc();if(one_item == NULL){return 0;}
	one_node = size_balance_tree_node_alloc();if(one_node == NULL){size_balance_tree_item_free(one_item);return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;
	one_node->index = result_index;one_node->parent = result_node;one_node->item = one_item;
	result_node->childArray[result_index] = one_node;check_node = result_node;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_item_count-left_item_count);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		size_balance_tree_node_rotate(tree, check_node);
		check_node = check_parent;
	}
	return 1;
}
int size_balance_tree_remove(size_balance_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	size_balance_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	size_balance_tree_node_t *one_node;size_balance_tree_item_t *one_item;int one_count;size_balance_tree_node_t *one_child;int one_index;size_balance_tree_node_t *one_parent;
	size_balance_tree_node_t *replace_node;size_balance_tree_item_t *replace_item;size_balance_tree_node_t *check_node;size_balance_tree_node_t *check_parent;
	size_balance_tree_node_t *left_child;size_balance_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = size_balance_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	if(result_node->childArray[0] != NULL && result_node->childArray[1] != NULL)
	{
		one_node = result_node->childArray[0];replace_node = NULL;temp_result = size_balance_tree_find_max(tree, one_node, &replace_node);
		if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(replace_node == NULL){return 0;}replace_item = replace_node->item;
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		one_count = ((replace_item->dataVec.count)-(one_item->dataVec.count));size_balance_tree_item_free(one_item);
		result_node->item = replace_item;replace_node->item = NULL;check_node = result_node;
		while(check_node != NULL){check_node->count += one_count;check_node = check_node->parent;}result_node = replace_node;
	}
	else
	{
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		size_balance_tree_item_free(one_item);result_node->item = NULL;
	}
	one_index = result_node->index;one_parent = result_node->parent;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] == NULL)
	{
		one_child = result_node->childArray[0];result_node->childArray[0] = NULL;size_balance_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else if(result_node->childArray[0] == NULL && result_node->childArray[1] != NULL)
	{
		one_child = result_node->childArray[1];result_node->childArray[1] = NULL;size_balance_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else
	{
		one_child = NULL;result_node->childArray[0] = NULL;result_node->childArray[1] = NULL;size_balance_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;}else{one_parent->childArray[one_index] = one_child;}
	}
	if(one_parent == NULL){return 1;}check_node = one_parent;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_item_count-left_item_count);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		size_balance_tree_node_rotate(tree, check_node);
		check_node = check_parent;
	}
	return 1;
}
int size_balance_tree_inorder_get_all_item_other(size_balance_tree_t *tree, vector_t *all_item_vec)
{
	size_balance_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;size_balance_tree_node_t *check_node;
	size_balance_tree_node_t *next_node;int temp_result;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = size_balance_tree_find_rank(tree, tree->root, 1, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}next_node = NULL;
		temp_result = size_balance_tree_inorder_get_next_item(tree, check_node, &next_node);if(next_node == NULL){return 1;}check_node = next_node;
	}
	return 1;
}
int size_balance_tree_rank_min_max_remove(size_balance_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;size_balance_tree_node_t *one_node;vector_t one_node_vec;size_balance_tree_node_t *min_node;size_balance_tree_node_t *max_node;
	size_balance_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;size_balance_tree_node_t *check_node;
	size_balance_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = size_balance_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = size_balance_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	size_balance_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
    }
    else
    {
    	one_count = (max_rank-min_rank+1);
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank));check_node = min_node;
    	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = size_balance_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = size_balance_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  	size_balance_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (upper_min_rank-min_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));check_node = min_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	size_balance_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  	size_balance_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (max_rank-lower_max_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	vector_delete_min_max(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank));check_node = max_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
	vector_free(&one_node_vec);return 1;
}
int size_balance_tree_rank_min_max_get(size_balance_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;size_balance_tree_node_t *one_node;vector_t one_node_vec;size_balance_tree_node_t *min_node;size_balance_tree_node_t *max_node;
	size_balance_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;size_balance_tree_node_t *check_node;
	size_balance_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = size_balance_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = size_balance_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = size_balance_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = size_balance_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_node_vec);return 1;
}
int size_balance_tree_min_max_remove(size_balance_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;size_balance_tree_node_t *one_node;vector_t one_node_vec;size_balance_tree_node_t *min_node;size_balance_tree_node_t *max_node;
	size_balance_tree_node_t *result_node;size_balance_tree_node_t *check_node;size_balance_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = size_balance_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = size_balance_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    size_balance_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = size_balance_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = size_balance_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  size_balance_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	size_balance_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  size_balance_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
	vector_free(&one_node_vec);return 1;	
}
int size_balance_tree_min_max_get(size_balance_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;size_balance_tree_node_t *one_node;vector_t one_node_vec;size_balance_tree_node_t *min_node;size_balance_tree_node_t *max_node;
	size_balance_tree_node_t *result_node;size_balance_tree_node_t *check_node;size_balance_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = size_balance_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = size_balance_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = size_balance_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = size_balance_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
	vector_free(&one_node_vec);return 1;	
}
int size_balance_tree_iterator_init(size_balance_tree_t *tree, size_balance_tree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return 0;}size_balance_tree_node_get_all_item(tree->root, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
size_balance_tree_iterator_t * size_balance_tree_iterator_alloc(size_balance_tree_t *tree)
{
	size_t size;size_balance_tree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(size_balance_tree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(size_balance_tree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void size_balance_tree_iterator_free(size_balance_tree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int size_balance_tree_iterator_next(size_balance_tree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;		
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}	
}
void size_balance_tree_item_dump(FILE *fd, size_balance_tree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void size_balance_tree_dump(FILE *fd, size_balance_tree_t *tree)
{
	size_balance_tree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = size_balance_tree_iterator_alloc(tree);if(iterator == NULL){return ;}
	size_balance_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(size_balance_tree_iterator_next(iterator) == 1){size_balance_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	size_balance_tree_iterator_free(iterator);
}
void size_balance_tree_dot_node_dump(FILE *fd, size_balance_tree_node_t *node, int *nDump)
{
	int i;size_balance_tree_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n%d:%d\\n",oneDump, node->type, node->depth, node->index, node->count, node->item_count);
	*nDump = (oneDump+1);
	if(node->item != NULL){fprintf(fd, "%s:%d\\n",((char *)(node->item->key)),node->item->dataVec.count);}
	fprintf(fd, "\"];\n");
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			size_balance_tree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void size_balance_tree_dot_dump(size_balance_tree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("size_balance_tree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph size_balance_tree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");size_balance_tree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;size_balance_tree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = size_balance_tree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    size_balance_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	size_balance_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    size_balance_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	size_balance_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	size_balance_tree_dot_dump(tree);
	size_balance_tree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

skiplist.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct list_link {struct list_link *prev;struct list_link *next;} list_link_t;
typedef struct {int span_count;int span_item_count;list_link_t link;} list_span_link_t;
typedef struct {int count;list_link_t head;} list_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} skiplist_item_t;
typedef struct {int level;skiplist_item_t *item;list_span_link_t linkArray[0];} skiplist_node_t;
typedef struct {int level;int count;int item_count;list_t listArray[64];} skiplist_t;
typedef struct {skiplist_t *skiplist;int vec_index;vector_t all_item_vec;skiplist_item_t *item;} skiplist_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
void list_link_init(list_link_t *link){link->prev = link;link->next = link;}
void list_link_add(list_link_t *link, list_link_t *prev, list_link_t *next){link->next = next;link->prev = prev;next->prev = link;prev->next = link;}
void list_link_del(list_link_t *link, list_link_t *prev, list_link_t *next){prev->next = next;next->prev = prev;list_link_init(link);}
void list_init(list_t *list){list->count = 0;list_link_init(&(list->head));}
void list_link_get_span_link(list_link_t *one, list_span_link_t **span_link)
{
	*span_link = NULL;if(one == NULL){return ;}*span_link = ((list_span_link_t *)((unsigned char *)(one) - (int)(&(((list_span_link_t *)0)->link))));
}
void span_link_get_node(list_span_link_t *span_link, int level, skiplist_node_t **node)
{
	*node = NULL;if(span_link == NULL){return ;}*node = ((skiplist_node_t *)((unsigned char *)(span_link) - (int)(&(((skiplist_node_t *)0)->linkArray[level]))));
}
void list_link_get_node_low_link(list_link_t *one, list_link_t **low_link)
{
	list_span_link_t *span_link;*low_link = NULL;if(one == NULL){return ;}
	span_link = NULL;list_link_get_span_link(one, &span_link);if(span_link == NULL){return ;}span_link--;*low_link = &(span_link->link);
}
void list_link_get_node_high_link(list_link_t *one, list_link_t **high_link)
{
	list_span_link_t *span_link;*high_link = NULL;if(one == NULL){return ;}
	span_link = NULL;list_link_get_span_link(one, &span_link);if(span_link == NULL){return ;}span_link++;*high_link = &(span_link->link);	
}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int random_level()
{
  int level;int mask;double p;level = 1;mask = 0xFFFF;p = 0.25;while((rand() & mask) < (p * mask)){level++;}if(level > 64){return 64;}else{return level;}
}
int skiplist_item_init(skiplist_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
skiplist_item_t * skiplist_item_alloc()
{
  size_t size;skiplist_item_t *item;size = sizeof(skiplist_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  skiplist_item_init(item);return item;
}
int skiplist_item_other_free(skiplist_item_t *item){vector_free(&(item->dataVec));skiplist_item_init(item);return 1;}
void skiplist_item_free(skiplist_item_t *item){if(item != NULL){skiplist_item_other_free(item);free(item);}}
int skiplist_node_init(skiplist_node_t *node, int level)
{
	int i;list_span_link_t *span_link;if(level < 1 || level > 64){return -1;}node->level = level;node->item = NULL;
	for(i = 0;i < level;i++)
	{
		span_link = &(node->linkArray[i]);span_link->span_count = 0;span_link->span_item_count = 0;list_link_init(&(span_link->link));
	}
	return 1;
}
skiplist_node_t * skiplist_node_alloc(int level)
{
	size_t size;skiplist_node_t *node;if(level < 1 || level > 64){return NULL;}size = sizeof(skiplist_node_t);size += (level * sizeof(list_span_link_t));
	node = NULL;node = malloc(size);if(node == NULL){return NULL;}skiplist_node_init(node, level);return node;
}
int skiplist_node_other_free(skiplist_node_t *node)
{
	int i;list_span_link_t *span_link;int level;if(node->item != NULL){skiplist_item_free(node->item);}node->item = NULL;level = node->level;
	for(i = 0;i < level;i++)
	{
		span_link = &(node->linkArray[i]);span_link->span_count = 0;span_link->span_item_count = 0;list_link_init(&(span_link->link));
	}
	return 1;
}
void skiplist_node_free(skiplist_node_t *node)
{
	if(node != NULL){skiplist_node_other_free(node);free(node);}
}
skiplist_t * skiplist_alloc()
{
	int i;size_t size;skiplist_t *skiplist;size = sizeof(skiplist_t);skiplist = NULL;skiplist = malloc(size);if(skiplist == NULL){return NULL;}
	for(i = 0;i < 64;i++){list_init(&(skiplist->listArray[i]));}skiplist->level = 0;skiplist->count = 0;skiplist->item_count = 0;return skiplist;
}
int skiplist_destroy(skiplist_t *skiplist)
{
	int i;int level;skiplist_node_t *node;list_t *list;list_link_t *link;list_link_t *next;list_link_t *end;list_span_link_t *span_link;
	if(skiplist == NULL){return -1;}if(skiplist->level <= 0){free(skiplist);return 1;}
	level = skiplist->level;list = &(skiplist->listArray[0]);link = list->head.next;next = link->next;end = &(list->head);
	while(link != end)
	{
		span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
		node = NULL;span_link_get_node(span_link, 0, &node);if(node == NULL){return -1;}
		skiplist_node_free(node);link = next;next = link->next;
	}
	for(i = 0;i < level;i++){list_init(&(skiplist->listArray[i]));}free(skiplist);return 1;
}
int skiplist_get_all_item(skiplist_t *skiplist, vector_t *all_item_vec)
{
	skiplist_node_t *node;list_t *list;list_link_t *link;list_link_t *next;list_link_t *end;list_span_link_t *span_link;
	if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}
	list = &(skiplist->listArray[0]);link = list->head.next;next = link->next;end = &(list->head);
	while(link != end)
	{
		span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
		node = NULL;span_link_get_node(span_link, 0, &node);if(node == NULL){return -1;}
		vector_add(all_item_vec, node->item);link = next;next = link->next;
	}
	return 1;
}
int skiplist_find_base(skiplist_t *skiplist, byte_t *key, word_t key_len, skiplist_node_t **result_node, int *result_rank_count, int *result_rank_count_array, int *result_rank_item_count_array, list_link_t **result_link_array)
{
	int i;int level;int check_result;skiplist_node_t *check_node;skiplist_item_t *check_item;int rank_count;int rank_count_array[64];
	int rank_item_count_array[64];list_link_t *link_array[64];list_t *list;list_link_t *link;list_link_t *next;list_link_t *end;list_t *downlist;
	list_span_link_t *span_link;list_link_t *low_link;if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}if(result_node == NULL){return -1;}level = skiplist->level;*result_node = NULL;rank_count = 0;
	for(i = (level-1);i >= 0;i--){rank_count_array[i] = 0;rank_item_count_array[i] = 0;link_array[i] = NULL;}
	i = (level-1);list = &(skiplist->listArray[level-1]);link = list->head.next;next = link->next;end = &(list->head);
	while(i >= 0)
	{
		list = &(skiplist->listArray[i]);if(i < (level-1)){rank_count_array[i] = rank_count_array[i+1];rank_item_count_array[i] = rank_item_count_array[i+1];}
		if(link == end)
		{
			link = end->prev;link_array[i] = end;
			if(i >= 1)
			{
				if(link == &(list->head)){downlist = &(skiplist->listArray[i-1]);link = &(downlist->head);}
				else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
				if(end == &(list->head)){downlist = &(skiplist->listArray[i-1]);end = &(downlist->head);}
				else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
				link = link->next;next = link->next;
			}
		}
		else
		{
			while(link != end)
			{
				span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
				check_node = NULL;span_link_get_node(span_link, i, &check_node);if(check_node == NULL){return -1;}if(check_node->item == NULL){return -1;}
				check_item = check_node->item;check_result = compareItem(check_item->key, check_item->key_len, key, key_len);
				if(check_result < 0)
				{
					rank_count += span_link->span_count;rank_count_array[i] += span_link->span_count;rank_item_count_array[i] += span_link->span_item_count; 
					if(next == end)
					{
						link_array[i] = end;
						if(i >= 1)
						{
							if(link == &(list->head)){downlist = &(skiplist->listArray[i-1]);link = &(downlist->head);}
							else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
							if(end == &(list->head)){downlist = &(skiplist->listArray[i-1]);end = &(downlist->head);}
							else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
							link = link->next;next = link->next;
						}
						break;
					}
					else
					{
						link = next;next = link->next;
					}
				}
				else if(check_result > 0)
				{
					end = link;link = end->prev;link_array[i] = end;
					if(i >= 1)
					{
						if(link == &(list->head)){downlist = &(skiplist->listArray[i-1]);link = &(downlist->head);}
						else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
						if(end == &(list->head)){downlist = &(skiplist->listArray[i-1]);end = &(downlist->head);}
						else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
						link = link->next;next = link->next;
					}
					break;
				}
				else
				{
					*result_node = check_node;rank_count += span_link->span_count;break;
				}
			}
			if(*result_node != NULL){break;}
		}
		i--;
	}
	if(result_rank_count != NULL){*result_rank_count = rank_count;}
	for(i = (level-1);i >= 0;i--)
	{
		if(result_rank_count_array != NULL){result_rank_count_array[i] = rank_count_array[i];}
		if(result_rank_item_count_array != NULL){result_rank_item_count_array[i] = rank_item_count_array[i];}
		if(result_link_array != NULL){result_link_array[i] = link_array[i];}
	}
	if(*result_node != NULL){return 1;}else{return 0;}
}
int skiplist_find_first_upper_equal(skiplist_t *skiplist, byte_t *min_key, word_t min_key_len, skiplist_node_t **min_node)
{
	int i;int level;int check_result;skiplist_node_t *check_node;skiplist_item_t *check_item;list_t *list;list_link_t *link;list_link_t *next;list_link_t *end;list_t *downlist;
	list_span_link_t *span_link;list_link_t *low_link;if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}
	if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(min_node == NULL){return -1;}level = skiplist->level;*min_node = NULL;
	i = (level-1);list = &(skiplist->listArray[level-1]);link = list->head.next;next = link->next;end = &(list->head);
	while(i >= 0)
	{
		list = &(skiplist->listArray[i]);
		if(link == end)
		{
			link = end->prev;
			if(i >= 1)
			{
				if(link == &(list->head)){downlist = &(skiplist->listArray[i-1]);link = &(downlist->head);}
				else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
				if(end == &(list->head)){downlist = &(skiplist->listArray[i-1]);end = &(downlist->head);}
				else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
				link = link->next;next = link->next;
			}
		}
		else
		{
			while(link != end)
			{
				span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
				check_node = NULL;span_link_get_node(span_link, i, &check_node);if(check_node == NULL){return -1;}if(check_node->item == NULL){return -1;}
				check_item = check_node->item;check_result = compareItem(check_item->key, check_item->key_len, min_key, min_key_len);
				if(check_result < 0)
				{
					if(next == end)
					{
						if(i >= 1)
						{
							if(link == &(list->head)){downlist = &(skiplist->listArray[i-1]);link = &(downlist->head);}
							else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
							if(end == &(list->head)){downlist = &(skiplist->listArray[i-1]);end = &(downlist->head);}
							else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
							link = link->next;next = link->next;
						}
						break;
					}
					else
					{
						link = next;next = link->next;
					}
				}
				else
				{
					link = link->prev;
					if(i >= 1)
					{						
						if(link == &(list->head)){downlist = &(skiplist->listArray[i-1]);link = &(downlist->head);}
						else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
						if(end == &(list->head)){downlist = &(skiplist->listArray[i-1]);end = &(downlist->head);}
						else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
						link = link->next;next = link->next;
					}
					else
					{
						*min_node = check_node;
					}
					break;
				}
			}
			if(*min_node != NULL){break;}
		}
		i--;
	}
	if(*min_node != NULL){return 1;}else{return 0;}
}
int skiplist_find_last_lower_equal(skiplist_t *skiplist, byte_t *max_key, word_t max_key_len, skiplist_node_t **max_node)
{
	int i;int level;int check_result;skiplist_node_t *check_node;skiplist_item_t *check_item;list_t *list;list_link_t *link;list_link_t *prev;list_link_t *end;list_t *downlist;
	list_span_link_t *span_link;list_link_t *low_link;if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}
	if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}if(max_node == NULL){return -1;}level = skiplist->level;*max_node = NULL;
	i = (level-1);list = &(skiplist->listArray[level-1]);link = list->head.prev;prev = link->prev;end = &(list->head);
	while(i >= 0)
	{
		list = &(skiplist->listArray[i]);
		if(link == end)
		{
			link = end->next;
			if(i >= 1)
			{
				if(link == &(list->head)){downlist = &(skiplist->listArray[i-1]);link = &(downlist->head);}
				else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
				if(end == &(list->head)){downlist = &(skiplist->listArray[i-1]);end = &(downlist->head);}
				else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
				link = link->prev;prev = link->prev;
			}
		}
		else
		{
			while(link != end)
			{
				span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
				check_node = NULL;span_link_get_node(span_link, i, &check_node);if(check_node == NULL){return -1;}if(check_node->item == NULL){return -1;}
				check_item = check_node->item;check_result = compareItem(check_item->key, check_item->key_len, max_key, max_key_len);
				if(check_result > 0)
				{
					if(prev == end)
					{
						if(i >= 1)
						{
							if(link == &(list->head)){downlist = &(skiplist->listArray[i-1]);link = &(downlist->head);}
							else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
							if(end == &(list->head)){downlist = &(skiplist->listArray[i-1]);end = &(downlist->head);}
							else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
							link = link->prev;prev = link->prev;
						}
						break;
					}
					else
					{
						link = prev;prev = link->prev;
					}
				}
				else
				{
					link = link->next;
					if(i >= 1)
					{						
						if(link == &(list->head)){downlist = &(skiplist->listArray[i-1]);link = &(downlist->head);}
						else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
						if(end == &(list->head)){downlist = &(skiplist->listArray[i-1]);end = &(downlist->head);}
						else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
						link = link->prev;prev = link->prev;
					}
					else
					{
						*max_node = check_node;
					}
					break;
				}
			}
			if(*max_node != NULL){break;}
		}
		i--;
	}
	if(*max_node != NULL){return 1;}else{return 0;}	
}
int skiplist_get_min_max_item(skiplist_t *skiplist, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *all_item_vec)
{
	skiplist_node_t *min_node;skiplist_node_t *max_node;int temp_result;skiplist_node_t *one_node;list_link_t *link;list_link_t *next;list_link_t *end;
	list_span_link_t *span_link;if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}if(min_key == NULL){return -1;}
	if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}if(max_key_len <= 0){return -1;}
	if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	min_node = NULL;temp_result = skiplist_find_first_upper_equal(skiplist, min_key, min_key_len, &min_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(min_node == NULL){return 0;}
	max_node = NULL;temp_result = skiplist_find_last_lower_equal(skiplist, max_key, max_key_len, &max_node);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(max_node == NULL){return 0;}
	if(min_node == max_node)
	{
		vector_add(all_item_vec, min_node->item);return 1;
	}
	vector_add(all_item_vec, min_node->item);
	span_link = &(min_node->linkArray[0]);link = span_link->link.next;next = link->next;
	span_link = &(max_node->linkArray[0]);end = &(span_link->link);
	while(link != end)
	{
		span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
		one_node = NULL;span_link_get_node(span_link, 0, &one_node);if(one_node == NULL){return -1;}if(one_node->item == NULL){return -1;}
		vector_add(all_item_vec, one_node->item);link = next;next = link->next;
	}
	vector_add(all_item_vec, max_node->item);return 1;	
}
int skiplist_check_exist(skiplist_t *skiplist, byte_t *key, word_t key_len)
{
	skiplist_node_t *result_node;int temp_result;result_node = NULL;if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}temp_result = skiplist_find_base(skiplist, key, key_len, &result_node, NULL, NULL, NULL, NULL);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}return 1;
}
int skiplist_get(skiplist_t *skiplist, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	skiplist_node_t *result_node;skiplist_item_t *result_item;int temp_result;result_node = NULL;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}
	if(key == NULL){return -1;}if(key_len <= 0){return -1;}temp_result = skiplist_find_base(skiplist, key, key_len, &result_node, NULL, NULL, NULL, NULL);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}result_item = result_node->item;
	if(result_data_vec != NULL){vector_copy_vec_two(&(result_item->dataVec), result_data_vec);}return 1;
}
int skiplist_get_rank(skiplist_t *skiplist, byte_t *key, word_t key_len, int *result_rank)
{
	skiplist_node_t *result_node;int result_rank_count;int temp_result;result_node = NULL;result_rank_count = 0;if(skiplist == NULL){return -1;}
	if(skiplist->level <= 0){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(result_rank == NULL){return -1;}
	temp_result = skiplist_find_base(skiplist, key, key_len, &result_node, &result_rank_count, NULL, NULL, NULL);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int skiplist_find_rank(skiplist_t *skiplist, int rank, skiplist_node_t **result_node, int *result_rank_count)
{
	int i;int level;skiplist_node_t *check_node;skiplist_item_t *check_item;int rank_count;int span_count;int one_count;
	list_t *list;list_link_t *link;list_link_t *next;list_link_t *end;list_t *downlist;list_span_link_t *span_link;list_link_t *low_link;
	if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}if(rank < 1){return -1;}if(rank > skiplist->count){return -1;}
	if(result_node == NULL){return -1;}level = skiplist->level;*result_node = NULL;rank_count = 0;
	i = (level-1);list = &(skiplist->listArray[level-1]);link = list->head.next;next = link->next;end = &(list->head);
	while(i >= 0)
	{
		list = &(skiplist->listArray[i]);
		if(link == end)
		{
			link = end->prev;
			if(i >= 1)
			{
				if(link == &(list->head)){downlist = &(skiplist->listArray[i-1]);link = &(downlist->head);}
				else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
				if(end == &(list->head)){downlist = &(skiplist->listArray[i-1]);end = &(downlist->head);}
				else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
				link = link->next;next = link->next;
			}
		}
		else
		{
			while(link != end)
			{
				span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
				check_node = NULL;span_link_get_node(span_link, i, &check_node);if(check_node == NULL){return -1;}if(check_node->item == NULL){return -1;}
				check_item = check_node->item;span_count = span_link->span_count;one_count = (span_count-(check_item->dataVec.count-1));
				if(rank > (rank_count+span_count))
				{
					rank_count += span_link->span_count;
					if(next == end)
					{
						if(i >= 1)
						{
							if(link == &(list->head)){downlist = &(skiplist->listArray[i-1]);link = &(downlist->head);}
							else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
							if(end == &(list->head)){downlist = &(skiplist->listArray[i-1]);end = &(downlist->head);}
							else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
							link = link->next;next = link->next;
						}
						break;
					}
					else
					{
						link = next;next = link->next;
					}
				}
				else if(rank < (rank_count+one_count))
				{
					end = link;link = end->prev;
					if(i >= 1)
					{
						if(link == &(list->head)){downlist = &(skiplist->listArray[i-1]);link = &(downlist->head);}
						else{low_link = NULL;list_link_get_node_low_link(link, &low_link);if(low_link == NULL){return -1;}link = low_link;}
						if(end == &(list->head)){downlist = &(skiplist->listArray[i-1]);end = &(downlist->head);}
						else{low_link = NULL;list_link_get_node_low_link(end, &low_link);if(low_link == NULL){return -1;}end = low_link;}
						link = link->next;next = link->next;
					}
					break;
				}
				else
				{
					*result_node = check_node;rank_count += span_link->span_count;break;
				}
			}
			if(*result_node != NULL){break;}
		}
		i--;
	}
	if(result_rank_count != NULL){*result_rank_count = rank_count;}
	if(*result_node != NULL){return 1;}else{return 0;}
}
int skiplist_insert(skiplist_t *skiplist, byte_t *key, word_t key_len, void *value)
{
	int i;int one_level;int skiplist_level;int node_level;int temp_result;skiplist_node_t *one_node;skiplist_item_t *one_item;skiplist_node_t *result_node;
	int result_rank_count;int result_rank_count_array[64];int result_rank_item_count_array[64];list_link_t *result_link_array[64];
	list_t *list;list_link_t *link;list_link_t *prev;list_link_t *next;list_link_t *end;list_span_link_t *span_link;list_span_link_t *other_span_link;
	if(skiplist == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(skiplist->level <= 0)
	{
		node_level = random_level();if(node_level < 1 || node_level > 64){return 0;}
		one_item = skiplist_item_alloc();if(one_item == NULL){return 0;}
		one_node = skiplist_node_alloc(node_level);if(one_node == NULL){skiplist_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_node->level = node_level;one_node->item = one_item;
		for(i = 0;i < node_level;i++)
		{
			list = &(skiplist->listArray[i]);span_link = &(one_node->linkArray[i]);link = &(span_link->link);prev = &(list->head);next = &(list->head);
			list_link_add(link, prev, next);list->count = 1;span_link->span_count = 1;span_link->span_item_count = 1;
		}
		skiplist->level = node_level;skiplist->count = 1;skiplist->item_count = 1;return 1;
	}
	result_node = NULL;result_rank_count = 0;
	for(i = 0;i < 64;i++){result_rank_count_array[i] = 0;result_rank_item_count_array[i] = 0;result_link_array[i] = NULL;}
	temp_result = skiplist_find_base(skiplist, key, key_len, &result_node, &result_rank_count, result_rank_count_array, result_rank_item_count_array, result_link_array);
	if(temp_result == -1){return -1;}
	if(result_node != NULL)
	{
		skiplist_level = skiplist->level;node_level = result_node->level;one_item = result_node->item;vector_add(&(one_item->dataVec), value);
		for(i = 0;i < skiplist_level;i++)
		{
			if(i < node_level){span_link = &(result_node->linkArray[i]);span_link->span_count++;}
			else
			{
				list = &(skiplist->listArray[i]);end = &(list->head);next = result_link_array[i];
				if(next != end)
				{
					other_span_link = NULL;list_link_get_span_link(next, &other_span_link);if(other_span_link == NULL){return -1;}other_span_link->span_count++;
				}				
			}
		}
		skiplist->count++;return 1;
	}
	node_level = random_level();if(node_level < 1 || node_level > 64){return 0;}
	one_item = skiplist_item_alloc();if(one_item == NULL){return 0;}
	one_node = skiplist_node_alloc(node_level);if(one_node == NULL){skiplist_item_free(one_item);return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	one_node->level = node_level;one_node->item = one_item;skiplist_level = skiplist->level;one_level = max(skiplist_level, node_level);
	if(node_level > skiplist_level)
	{
		for(i = 0;i < node_level;i++)
		{
			if(i < skiplist_level)
			{
				list = &(skiplist->listArray[i]);span_link = &(one_node->linkArray[i]);end = &(list->head);
				link = &(span_link->link);next = result_link_array[i];prev = next->prev;
				if(next != end)
				{
					other_span_link = NULL;list_link_get_span_link(next, &other_span_link);if(other_span_link == NULL){return -1;}
					other_span_link->span_count -= (result_rank_count_array[0]-result_rank_count_array[i]);
					other_span_link->span_item_count -= (result_rank_item_count_array[0]-result_rank_item_count_array[i]);
				}
				list_link_add(link, prev, next);list->count++;
				span_link->span_count = ((result_rank_count_array[0]-result_rank_count_array[i])+1);
				span_link->span_item_count = ((result_rank_item_count_array[0]-result_rank_item_count_array[i])+1);
			}
			else
			{
				list = &(skiplist->listArray[i]);span_link = &(one_node->linkArray[i]);
				link = &(span_link->link);prev = &(list->head);next = &(list->head);list_link_add(link, prev, next);list->count = 1;
				span_link->span_count = (result_rank_count_array[0]+1);span_link->span_item_count = (result_rank_item_count_array[0]+1);
			}
		}
	}
	else
	{
		for(i = 0; i < skiplist_level;i++)
		{
			if(i < node_level)
			{
				list = &(skiplist->listArray[i]);span_link = &(one_node->linkArray[i]);end = &(list->head);
				link = &(span_link->link);next = result_link_array[i];prev = next->prev;
				if(next != end)
				{
					other_span_link = NULL;list_link_get_span_link(next, &other_span_link);if(other_span_link == NULL){return -1;}
					other_span_link->span_count -= (result_rank_count_array[0]-result_rank_count_array[i]);
					other_span_link->span_item_count -= (result_rank_item_count_array[0]-result_rank_item_count_array[i]);
				}
				list_link_add(link, prev, next);list->count++;
				span_link->span_count = ((result_rank_count_array[0]-result_rank_count_array[i])+1);
				span_link->span_item_count = ((result_rank_item_count_array[0]-result_rank_item_count_array[i])+1);				
			}
			else
			{
				list = &(skiplist->listArray[i]);end = &(list->head);next = result_link_array[i];
				if(next != end)
				{
					other_span_link = NULL;list_link_get_span_link(next, &other_span_link);if(other_span_link == NULL){return -1;}
					other_span_link->span_count++;other_span_link->span_item_count++;					
				}
			}
		}
	}
	skiplist->level = one_level;skiplist->count++;skiplist->item_count++;return 1;
}
int skiplist_remove(skiplist_t *skiplist, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	int i;int one_level;int skiplist_level;int node_level;int temp_result;skiplist_item_t *one_item;int one_count;int one_span_count;
	int one_span_item_count;skiplist_node_t *result_node;int result_rank_count;int result_rank_count_array[64];int result_rank_item_count_array[64];
	list_link_t *result_link_array[64];list_t *list;list_link_t *link;list_link_t *prev;list_link_t *next;list_link_t *end;list_span_link_t *span_link;
	list_span_link_t *other_span_link;if(result_data_vec != NULL){vector_free(result_data_vec);}if(skiplist == NULL){return -1;}
	if(skiplist->level <= 0){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;
	for(i = 0;i < 64;i++){result_rank_count_array[i] = 0;result_rank_item_count_array[i] = 0;result_link_array[i] = NULL;}
	temp_result = skiplist_find_base(skiplist, key, key_len, &result_node, &result_rank_count, result_rank_count_array, result_rank_item_count_array, result_link_array);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	skiplist_level = skiplist->level;node_level = result_node->level;one_level = skiplist_level;
	one_item = result_node->item;one_count = one_item->dataVec.count;
	for(i = 0;i < skiplist_level;i++)
	{
		if(i < node_level)
		{			
			list = &(skiplist->listArray[i]);span_link = &(result_node->linkArray[i]);end = &(list->head);
			link = &(span_link->link);next = link->next;prev = link->prev;
			one_span_count = span_link->span_count;one_span_item_count = span_link->span_item_count;
			if(next != end)
			{
				other_span_link = NULL;list_link_get_span_link(next, &other_span_link);if(other_span_link == NULL){return -1;}
				other_span_link->span_count += (one_span_count-one_count);
				other_span_link->span_item_count += (one_span_item_count-1);
			}
			list_link_del(link, prev, next);list->count--;if(list->count <= 0){one_level--;}
			span_link->span_count = 0;span_link->span_item_count = 0;			
		}
		else
		{
			list = &(skiplist->listArray[i]);end = &(list->head);next = result_link_array[i];
			if(next != end)
			{
				other_span_link = NULL;list_link_get_span_link(next, &other_span_link);if(other_span_link == NULL){return -1;}
				other_span_link->span_count -= one_count;other_span_link->span_item_count -= 1;					
			}
		}
	}
	if(result_data_vec != NULL){vector_copy_vec_two(&(one_item->dataVec), result_data_vec);}skiplist_item_free(one_item);result_node->item = NULL;
	skiplist_node_free(result_node);skiplist->level = one_level;skiplist->count -= one_count;skiplist->item_count -= 1;return 1;
}
int skiplist_lower_upper_remove(skiplist_t *skiplist, byte_t *key, word_t key_len, int lower_index, int upper_index)
{
	int i;int skiplist_level;int node_level;int temp_result;skiplist_item_t *one_item;int one_count;skiplist_node_t *result_node;
	int result_rank_count;int result_rank_count_array[64];int result_rank_item_count_array[64];list_link_t *result_link_array[64];
	list_t *list;list_link_t *next;list_link_t *end;list_span_link_t *span_link;list_span_link_t *other_span_link;
	if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	if(lower_index < 0){return -1;}if(upper_index < 0){return -1;}if(lower_index > upper_index){return -1;}
	result_node = NULL;result_rank_count = 0;
	for(i = 0;i < 64;i++){result_rank_count_array[i] = 0;result_rank_item_count_array[i] = 0;result_link_array[i] = NULL;}
	temp_result = skiplist_find_base(skiplist, key, key_len, &result_node, &result_rank_count, result_rank_count_array, result_rank_item_count_array, result_link_array);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	skiplist_level = skiplist->level;node_level = result_node->level;one_item = result_node->item;one_count = one_item->dataVec.count;
	if(lower_index >= one_count){return -1;}if(upper_index >= one_count){return -1;}one_count = (upper_index-lower_index+1);
	vector_delete_min_max(&(one_item->dataVec), lower_index, upper_index);
	for(i = 0;i < skiplist_level;i++)
	{
		if(i < node_level)
		{			
			span_link = &(result_node->linkArray[i]);span_link->span_count -= one_count;
		}
		else
		{
			list = &(skiplist->listArray[i]);end = &(list->head);next = result_link_array[i];
			if(next != end)
			{
				other_span_link = NULL;list_link_get_span_link(next, &other_span_link);if(other_span_link == NULL){return -1;}
				other_span_link->span_count -= one_count;
			}
		}
	}
	skiplist->count -= one_count;return 1;	
}
int skiplist_rank_min_max_remove(skiplist_t *skiplist, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;skiplist_item_t *one_item;vector_t one_item_vec;skiplist_node_t *one_node;skiplist_node_t *min_node;skiplist_node_t *max_node;
	skiplist_node_t *result_node;int result_rank_count;int temp_result;int one_count;list_link_t *link;list_link_t *next;list_link_t *end;
	list_span_link_t *span_link;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}
	if(min_rank < 1){return -1;}if(min_rank > skiplist->count){return -1;}if(max_rank < 1){return -1;}if(max_rank > skiplist->count){return -1;}
	if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;temp_result = skiplist_find_rank(skiplist, min_rank, &result_node, &result_rank_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	one_count = result_node->item->dataVec.count;min_node = result_node;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;temp_result = skiplist_find_rank(skiplist, max_rank, &result_node, &result_rank_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	one_count = result_node->item->dataVec.count;max_node = result_node;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	skiplist_remove(skiplist, min_node->item->key, min_node->item->key_len, NULL);return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	skiplist_lower_upper_remove(skiplist, min_node->item->key, min_node->item->key_len, (min_rank-lower_min_rank), (max_rank-lower_min_rank));
    	return 1;
    }
	}
	vector_init(&one_item_vec);span_link = &(min_node->linkArray[0]);link = span_link->link.next;next = link->next;
	span_link = &(max_node->linkArray[0]);end = &(span_link->link);
	while(link != end)
	{
		span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
		one_node = NULL;span_link_get_node(span_link, 0, &one_node);if(one_node == NULL){return -1;}if(one_node->item == NULL){return -1;}
		vector_add(&one_item_vec, one_node->item);link = next;next = link->next;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  	skiplist_remove(skiplist, min_node->item->key, min_node->item->key_len, NULL);
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	skiplist_lower_upper_remove(skiplist, min_node->item->key, min_node->item->key_len, (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));
  }
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  	skiplist_remove(skiplist, one_item->key, one_item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  	skiplist_remove(skiplist, max_node->item->key, max_node->item->key_len, NULL);
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	skiplist_lower_upper_remove(skiplist, max_node->item->key, max_node->item->key_len, 0, (max_rank-lower_max_rank));
  }
	vector_free(&one_item_vec);return 1;
}
int skiplist_rank_min_max_get(skiplist_t *skiplist, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;skiplist_item_t *one_item;vector_t one_item_vec;skiplist_node_t *one_node;skiplist_node_t *min_node;skiplist_node_t *max_node;
	skiplist_node_t *result_node;int result_rank_count;int temp_result;int one_count;list_link_t *link;list_link_t *next;list_link_t *end;
	list_span_link_t *span_link;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(skiplist == NULL){return -1;}if(skiplist->level <= 0){return -1;}
	if(min_rank < 1){return -1;}if(min_rank > skiplist->count){return -1;}if(max_rank < 1){return -1;}if(max_rank > skiplist->count){return -1;}
	if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;temp_result = skiplist_find_rank(skiplist, min_rank, &result_node, &result_rank_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	one_count = result_node->item->dataVec.count;min_node = result_node;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;temp_result = skiplist_find_rank(skiplist, max_rank, &result_node, &result_rank_count);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	one_count = result_node->item->dataVec.count;max_node = result_node;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	return 1;
    }
	}
	vector_init(&one_item_vec);span_link = &(min_node->linkArray[0]);link = span_link->link.next;next = link->next;
	span_link = &(max_node->linkArray[0]);end = &(span_link->link);
	while(link != end)
	{
		span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return -1;}
		one_node = NULL;span_link_get_node(span_link, 0, &one_node);if(one_node == NULL){return -1;}if(one_node->item == NULL){return -1;}
		vector_add(&one_item_vec, one_node->item);link = next;next = link->next;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_item_vec.count;i++)
  {
  	one_item = one_item_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_item_vec);return 1;
}
int skiplist_min_max_remove(skiplist_t *skiplist, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;skiplist_item_t *one_item;vector_t one_item_vec;if(result_data_vec != NULL){vector_free(result_data_vec);}if(skiplist == NULL){return -1;}
	if(skiplist->level <= 0){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}vector_init(&one_item_vec);
	skiplist_get_min_max_item(skiplist, min_key, min_key_len, max_key, max_key_len, &one_item_vec);
	if(one_item_vec.count <= 0){vector_free(&one_item_vec);return 0;}
	for(i = 0;i < one_item_vec.count;i++)
	{
		one_item = one_item_vec.mem[i];
		if(one_item != NULL)
		{
			if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
			skiplist_remove(skiplist, one_item->key, one_item->key_len, NULL);
		}
	}
	vector_free(&one_item_vec);return 1;
}
int skiplist_min_max_get(skiplist_t *skiplist, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;skiplist_item_t *one_item;vector_t one_item_vec;if(result_data_vec != NULL){vector_free(result_data_vec);}if(skiplist == NULL){return -1;}
	if(skiplist->level <= 0){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}vector_init(&one_item_vec);
	skiplist_get_min_max_item(skiplist, min_key, min_key_len, max_key, max_key_len, &one_item_vec);
	if(one_item_vec.count <= 0){vector_free(&one_item_vec);return 0;}
	for(i = 0;i < one_item_vec.count;i++)
	{
		one_item = one_item_vec.mem[i];
		if(one_item != NULL)
		{
			if(result_data_vec != NULL){vector_add_vec_two(&(one_item->dataVec), result_data_vec);}
		}
	}
	vector_free(&one_item_vec);return 1;
}
int skiplist_iterator_init(skiplist_t *skiplist, skiplist_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(skiplist == NULL){return 0;}if(skiplist->level <= 0){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, skiplist->item_count) == 0){return 0;}skiplist_get_all_item(skiplist, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->skiplist = skiplist;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
skiplist_iterator_t * skiplist_iterator_alloc(skiplist_t *skiplist)
{
	size_t size;skiplist_iterator_t *iterator;if(skiplist == NULL){return NULL;}if(skiplist->level <= 0){return NULL;}
	size = sizeof(skiplist_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(skiplist_iterator_init(skiplist, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void skiplist_iterator_free(skiplist_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int skiplist_iterator_next(skiplist_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;		
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}	
}
void skiplist_item_dump(FILE *fd, skiplist_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void skiplist_dump(FILE *fd, skiplist_t *skiplist)
{
	skiplist_iterator_t *iterator;if(skiplist == NULL){return ;}if(skiplist->level <= 0){return ;}
	iterator = skiplist_iterator_alloc(skiplist);if(iterator == NULL){return ;}
	skiplist_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(skiplist_iterator_next(iterator) == 1){skiplist_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	skiplist_iterator_free(iterator);
}
void skiplist_one_node_dump(FILE *fd, skiplist_node_t *node, int level)
{
	skiplist_item_t *item;list_span_link_t *span_link;item = node->item;span_link = &(node->linkArray[level]);
	fprintf(fd, "[ ");skiplist_item_dump(fd, item);fprintf(fd, " | %d : %d", span_link->span_count, span_link->span_item_count);fprintf(fd, " ]");
}
void skiplist_one_list_dump(FILE *fd, list_t *list, int level)
{
	skiplist_node_t *node;list_link_t *link;list_link_t *next;list_link_t *end;list_span_link_t *span_link;
	link = list->head.next;next = link->next;end = &(list->head);fprintf(fd, "{ ");
	while(link != end)
	{
		span_link = NULL;list_link_get_span_link(link, &span_link);if(span_link == NULL){return ;}
		node = NULL;span_link_get_node(span_link, level, &node);if(node == NULL){return ;}
		skiplist_one_node_dump(fd, node, level);if(next != end){fprintf(fd, " , ");}
		link = next;next = link->next;
	}
	fprintf(fd, " }\n");	
}
void skiplist_all_list_dump(FILE *fd, skiplist_t *skiplist)
{
	int i;int level;list_t *list;if(skiplist == NULL){return ;}if(skiplist->level <= 0){return ;}level = skiplist->level;
	for(i = (level-1); i >= 0; i--)
	{
		fprintf(fd, "[%d] ", i);list = &(skiplist->listArray[i]);skiplist_one_list_dump(fd, list, i);
	}
	fprintf(fd, "\n");
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;skiplist_t *skiplist;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	skiplist = skiplist_alloc();if(skiplist == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    skiplist_insert(skiplist, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	skiplist_dump(fd, skiplist);
	fprintf(fd, "\n");fprintf(fd, "\n");
	skiplist_all_list_dump(fd, skiplist);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    skiplist_remove(skiplist, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	skiplist_dump(fd, skiplist);
	fprintf(fd, "\n");fprintf(fd, "\n");
	skiplist_all_list_dump(fd, skiplist);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	skiplist_destroy(skiplist);
}

int main()
{
	build();
	return 0;
}

avl_splay_tree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} avl_tree_item_t;
typedef struct avl_tree_node {
	int type;int depth;int count;int item_count;int index;struct avl_tree_node *parent;avl_tree_item_t *item;struct avl_tree_node *childArray[2];
} avl_tree_node_t;
typedef struct {avl_tree_node_t *root;} avl_tree_t;
typedef struct {avl_tree_t *tree;int vec_index;vector_t all_item_vec;avl_tree_item_t *item;} avl_tree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int avl_tree_item_init(avl_tree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
avl_tree_item_t * avl_tree_item_alloc()
{
  size_t size;avl_tree_item_t *item;size = sizeof(avl_tree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  avl_tree_item_init(item);return item;
}
int avl_tree_item_other_free(avl_tree_item_t *item){vector_free(&(item->dataVec));avl_tree_item_init(item);return 1;}
void avl_tree_item_free(avl_tree_item_t *item){if(item != NULL){avl_tree_item_other_free(item);free(item);}}
int avl_tree_node_init(avl_tree_node_t *node)
{
	node->type = 0;node->depth = 0;node->count = 0;node->item_count = 0;node->index = 0;node->parent = NULL;
	node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
avl_tree_node_t * avl_tree_node_alloc()
{
	size_t size;avl_tree_node_t *node;size = sizeof(avl_tree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	avl_tree_node_init(node);return node;
}
int avl_tree_node_other_free(avl_tree_node_t *node)
{
	if(node->item != NULL){avl_tree_item_free(node->item);node->item = NULL;}avl_tree_node_init(node);return 1;
}
void avl_tree_node_free(avl_tree_node_t *node)
{
	if(node != NULL){avl_tree_node_other_free(node);free(node);}
}
void avl_tree_node_destroy(avl_tree_node_t **node)
{
	avl_tree_node_t **avl_tree_node;avl_tree_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	if(one_node->childArray[0] != NULL){avl_tree_node = &(one_node->childArray[0]);avl_tree_node_destroy(avl_tree_node);one_node->childArray[0] = NULL;}
	if(one_node->childArray[1] != NULL){avl_tree_node = &(one_node->childArray[1]);avl_tree_node_destroy(avl_tree_node);one_node->childArray[1] = NULL;}
	avl_tree_node_free((*node));*node = NULL;
}
void avl_tree_node_get_all_item(avl_tree_node_t *node, vector_t *all_item_vec)
{
	if(node == NULL){return ;}
	if(node->childArray[0] != NULL){avl_tree_node_get_all_item(node->childArray[0], all_item_vec);}
	if(node->item != NULL){vector_add(all_item_vec, node->item);}
	if(node->childArray[1] != NULL){avl_tree_node_get_all_item(node->childArray[1], all_item_vec);}
}
int avl_tree_preorder_get_all_item(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else{if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int avl_tree_inorder_get_next_item(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t **result_node)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}			
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int avl_tree_inorder_get_prev_item(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t **result_node)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[1])
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int avl_tree_inorder_get_all_item(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int avl_tree_postorder_get_all_item(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *last_node;avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{		
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
		else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else
				{
					if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
avl_tree_t * avl_tree_alloc()
{
	size_t size;avl_tree_t *tree;size = sizeof(avl_tree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;return tree;
}
void avl_tree_destroy(avl_tree_t *tree)
{
	avl_tree_node_t **avl_tree_node;if(tree == NULL){return ;}if(tree->root == NULL){free(tree);return ;}
	avl_tree_node = &(tree->root);avl_tree_node_destroy(avl_tree_node);tree->root = NULL;free(tree);
}
int avl_tree_node_rotate_left_child(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t *left_child)
{
	int index;avl_tree_node_t *parent;avl_tree_node_t *right_child;avl_tree_node_t *left_left_child;avl_tree_node_t *left_right_child;
	int right_depth;int left_left_depth;int left_right_depth;int right_count;int left_left_count;int left_right_count;
	int right_item_count;int left_left_item_count;int left_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(left_child == NULL){return -1;}if(node->childArray[0] != left_child){return -1;}
	if(node->item == NULL){return -1;}if(left_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	right_child = node->childArray[1];left_left_child = left_child->childArray[0];left_right_child = left_child->childArray[1];
	if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
	else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
	if(left_left_child == NULL){left_left_depth = -1;left_left_count = 0;left_left_item_count = 0;}
	else{left_left_depth = left_left_child->depth;left_left_count = left_left_child->count;left_left_item_count = left_left_child->item_count;}
	if(left_right_child == NULL){left_right_depth = -1;left_right_count = 0;left_right_item_count = 0;}
	else{left_right_depth = left_right_child->depth;left_right_count = left_right_child->count;left_right_item_count = left_right_child->item_count;}
	if(parent == NULL){tree->root = left_child;left_child->index = 0;left_child->parent = NULL;}
	else{parent->childArray[index] = left_child;left_child->index = index;left_child->parent = parent;}
	left_child->childArray[1] = node;node->index = 1;node->parent = left_child;
	node->childArray[0] = left_right_child;if(left_right_child != NULL){left_right_child->index = 0;left_right_child->parent = node;}
	node->type = (right_depth-left_right_depth);node->depth = max((left_right_depth+1), (right_depth+1));
	node->count = node->item->dataVec.count;node->count += left_right_count;node->count += right_count;
	node->item_count = 1;node->item_count += left_right_item_count;node->item_count += right_item_count;
	left_child->type = (node->depth-left_left_depth);left_child->depth = max((left_left_depth+1), (node->depth+1));
	left_child->count = left_child->item->dataVec.count;left_child->count += left_left_count;left_child->count += node->count;
	left_child->item_count = 1;left_child->item_count += left_left_item_count;left_child->item_count += node->item_count;
	return 1;
}
int avl_tree_node_rotate_right_child(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t *right_child)
{
	int index;avl_tree_node_t *parent;avl_tree_node_t *left_child;avl_tree_node_t *right_left_child;avl_tree_node_t *right_right_child;
	int left_depth;int right_left_depth;int right_right_depth;int left_count;int right_left_count;int right_right_count;
	int left_item_count;int right_left_item_count;int right_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(right_child == NULL){return -1;}if(node->childArray[1] != right_child){return -1;}
	if(node->item == NULL){return -1;}if(right_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	left_child = node->childArray[0];right_left_child = right_child->childArray[0];right_right_child = right_child->childArray[1];
	if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
	else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
	if(right_left_child == NULL){right_left_depth = -1;right_left_count = 0;right_left_item_count = 0;}
	else{right_left_depth = right_left_child->depth;right_left_count = right_left_child->count;right_left_item_count = right_left_child->item_count;}
	if(right_right_child == NULL){right_right_depth = -1;right_right_count = 0;right_right_item_count = 0;}
	else{right_right_depth = right_right_child->depth;right_right_count = right_right_child->count;right_right_item_count = right_right_child->item_count;}
	if(parent == NULL){tree->root = right_child;right_child->index = 0;right_child->parent = NULL;}
	else{parent->childArray[index] = right_child;right_child->index = index;right_child->parent = parent;}
	right_child->childArray[0] = node;node->index = 0;node->parent = right_child;
	node->childArray[1] = right_left_child;if(right_left_child != NULL){right_left_child->index = 1;right_left_child->parent = node;}
	node->type = (right_left_depth-left_depth);node->depth = max((left_depth+1), (right_left_depth+1));
	node->count = node->item->dataVec.count;node->count += left_count;node->count += right_left_count;
	node->item_count = 1;node->item_count += left_item_count;node->item_count += right_left_item_count;
	right_child->type = (right_right_depth-node->depth);right_child->depth = max((node->depth+1), (right_right_depth+1));
	right_child->count = right_child->item->dataVec.count;right_child->count += node->count;right_child->count += right_right_count;
	right_child->item_count = 1;right_child->item_count += node->item_count;right_child->item_count += right_right_item_count;
	return 1;	
}
int avl_tree_node_rotate(avl_tree_t *tree, avl_tree_node_t *node)
{
	int index;avl_tree_node_t *parent;avl_tree_node_t *one_node;avl_tree_node_t *one_left_child;avl_tree_node_t *one_right_child;
	avl_tree_node_t *left_child;avl_tree_node_t *right_child;avl_tree_node_t *left_left_child;avl_tree_node_t *left_right_child;
	avl_tree_node_t *right_left_child;avl_tree_node_t *right_right_child;int left_depth;int right_depth;int left_left_depth;
	int left_right_depth;int right_left_depth;int right_right_depth;int one_left_depth;int one_right_depth;int one_left_count;
	int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(node->type == 0){return 0;}index = node->index;parent = node->parent;
	if(node->type < 0)
	{
		if(node->childArray[0] == NULL){return -1;}left_child = node->childArray[0];if(left_child->item == NULL){return -1;}
		if(left_child->type > 0)
		{
			if(left_child->childArray[1] == NULL){return -1;}left_right_child = left_child->childArray[1];if(left_right_child->item == NULL){return -1;}
			if(node->childArray[1] == NULL){right_depth = -1;}else{right_depth = node->childArray[1]->depth;}
			left_right_depth = left_right_child->depth;
			if(right_depth >= left_right_depth){return 0;}
			avl_tree_node_rotate_right_child(tree, left_child, left_right_child);
			one_left_child = node->childArray[0];one_right_child = node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			node->type = (one_right_depth-one_left_depth);node->depth = max((one_left_depth+1), (one_right_depth+1));
			node->count = node->item->dataVec.count;node->count += one_left_count;node->count += one_right_count;
			node->item_count = 1;node->item_count += one_left_item_count;node->item_count += one_right_item_count;
			avl_tree_node_rotate_left_child(tree, node, one_left_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];avl_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];avl_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_depth-one_left_depth);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			avl_tree_node_rotate(tree, one_node);return 1;
		}
		else
		{
			left_left_child = left_child->childArray[0];
			if(node->childArray[1] == NULL){right_depth = -1;}else{right_depth = node->childArray[1]->depth;}
			if(left_left_child == NULL){left_left_depth = -1;}else{left_left_depth = left_left_child->depth;}
			if(right_depth >= left_left_depth){return 0;}
			avl_tree_node_rotate_left_child(tree, node, left_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];avl_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];avl_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_depth-one_left_depth);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			avl_tree_node_rotate(tree, one_node);return 1;
		}
	}
	else if(node->type > 0)
	{
		if(node->childArray[1] == NULL){return -1;}right_child = node->childArray[1];if(right_child->item == NULL){return -1;}
		if(right_child->type < 0)
		{
			if(right_child->childArray[0] == NULL){return -1;}right_left_child = right_child->childArray[0];if(right_left_child->item == NULL){return -1;}
			if(node->childArray[0] == NULL){left_depth = -1;}else{left_depth = node->childArray[0]->depth;}
			right_left_depth = right_left_child->depth;
			if(left_depth >= right_left_depth){return 0;}
			avl_tree_node_rotate_left_child(tree, right_child, right_left_child);
			one_left_child = node->childArray[0];one_right_child = node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			node->type = (one_right_depth-one_left_depth);node->depth = max((one_left_depth+1), (one_right_depth+1));
			node->count = node->item->dataVec.count;node->count += one_left_count;node->count += one_right_count;
			node->item_count = 1;node->item_count += one_left_item_count;node->item_count += one_right_item_count;
			avl_tree_node_rotate_right_child(tree, node, one_right_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];avl_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];avl_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_depth-one_left_depth);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			avl_tree_node_rotate(tree, one_node);return 1;
		}
		else
		{
			right_right_child = right_child->childArray[1];
			if(node->childArray[0] == NULL){left_depth = -1;}else{left_depth = node->childArray[0]->depth;}
			if(right_right_child == NULL){right_right_depth = -1;}else{right_right_depth = right_right_child->depth;}
			if(left_depth >= right_right_depth){return 0;}			
			avl_tree_node_rotate_right_child(tree, node, right_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];avl_tree_node_rotate(tree, one_left_child);
			one_right_child = one_node->childArray[1];avl_tree_node_rotate(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_depth-one_left_depth);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			avl_tree_node_rotate(tree, one_node);return 1;
		}
	}
	return 0;
}
int avl_tree_node_splay(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t *final_parent)
{
	int check_index;avl_tree_node_t *check_parent;avl_tree_node_t *check_node;avl_tree_node_t *one_left_child;avl_tree_node_t *one_right_child;
	int one_left_depth;int one_right_depth;int one_left_count;int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(node->parent == NULL){return 0;}if(node->parent == final_parent){return 0;}check_node = node;
	while(check_node != NULL && check_node->parent != NULL && check_node->parent != final_parent)
	{
		check_index = check_node->index;check_parent = check_node->parent;
		one_left_child = check_parent->childArray[0];one_right_child = check_parent->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_parent->type = (one_right_depth-one_left_depth);check_parent->depth = max((one_left_depth+1), (one_right_depth+1));
		check_parent->count = check_parent->item->dataVec.count;check_parent->count += one_left_count;check_parent->count += one_right_count;
		check_parent->item_count = 1;check_parent->item_count += one_left_item_count;check_parent->item_count += one_right_item_count;
		if(check_index == 0){avl_tree_node_rotate_left_child(tree, check_parent, check_node);}else{avl_tree_node_rotate_right_child(tree, check_parent, check_node);}
	}
	if(check_node->parent == NULL){return 1;}else{check_node = check_node->parent;}
	while(check_node != NULL)
	{
		check_parent = check_node->parent;
		one_left_child = check_node->childArray[0];one_right_child = check_node->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_node->type = (one_right_depth-one_left_depth);check_node->depth = max((one_left_depth+1), (one_right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += one_left_count;check_node->count += one_right_count;
		check_node->item_count = 1;check_node->item_count += one_left_item_count;check_node->item_count += one_right_item_count;
		check_node = check_parent;
	}
	return 1;
}
int avl_tree_find_rank(avl_tree_t *tree, avl_tree_node_t *node, int rank, avl_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count)
{
	avl_tree_node_t *left_child;int left_count;int left_item_count;avl_tree_node_t *check_node;int check_count;int check_item_count;
	int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(rank < 1){return -1;}if(rank > tree->root->count){return -1;}*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;
	check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}if((rank-rank_count) > check_node->count){return -1;}left_child = check_node->childArray[0];
		if(left_child == NULL){left_count = 0;left_item_count = 0;}else{left_count = left_child->count;left_item_count = left_child->item_count;}
		check_count = (left_count+(check_node->item->dataVec.count));check_item_count = (left_item_count+1);
		if((rank-rank_count) > check_count)
		{
			rank_count += check_count;rank_item_count += check_item_count;
			if(check_node->childArray[1] == NULL){return 2;}else{check_node = check_node->childArray[1];}
		}
		else if((rank-rank_count) <= left_count)
		{
			if(check_node->childArray[0] == NULL){return 2;}else{check_node = check_node->childArray[0];}			
		}
		else
		{
			rank_count += check_count;rank_item_count += check_item_count;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}		
	}
	return 0;
}
int avl_tree_find_base(avl_tree_t *tree, avl_tree_node_t *node, byte_t *key, word_t key_len, avl_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count, int *result_index)
{
	int one;avl_tree_item_t *item;avl_tree_node_t *check_node;int rank_count;int rank_item_count;avl_tree_node_t *one_child;
	int one_count;int one_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;*result_index = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			if(check_node->childArray[1] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 1;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 0;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}
	}
	return 0;
}
int avl_tree_find_max(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t **result_node)
{
	avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[1] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[1];}
	}
	return 0;
}
int avl_tree_find_min(avl_tree_t *tree, avl_tree_node_t *node, avl_tree_node_t **result_node)
{
	avl_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[0] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[0];}
	}
	return 0;
}
int avl_tree_find_first_upper_equal(avl_tree_t *tree, avl_tree_node_t *node, byte_t *key, word_t key_len, avl_tree_node_t **result_node)
{
	int one;avl_tree_item_t *item;avl_tree_node_t *check_node;avl_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int avl_tree_find_last_lower_equal(avl_tree_t *tree, avl_tree_node_t *node, byte_t *key, word_t key_len, avl_tree_node_t **result_node)
{
	int one;avl_tree_item_t *item;avl_tree_node_t *check_node;avl_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int avl_tree_get_rank(avl_tree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int avl_tree_check_exist(avl_tree_t *tree, byte_t *key, word_t key_len)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}return 1;
}
int avl_tree_get(avl_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	avl_tree_item_t *item;avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(item->dataVec), result_data_vec);}return 1;
}
int avl_tree_splay(avl_tree_t *tree, byte_t *key, word_t key_len)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	avl_tree_node_splay(tree, result_node, NULL);return 1;
}
int avl_tree_insert(avl_tree_t *tree, byte_t *key, word_t key_len, void *value)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;avl_tree_item_t *one_item;
	avl_tree_node_t *one_node;avl_tree_node_t *check_node;avl_tree_node_t *check_parent;avl_tree_node_t *left_child;avl_tree_node_t *right_child;
	int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = avl_tree_item_alloc();if(one_item == NULL){return 0;}
		one_node = avl_tree_node_alloc();if(one_node == NULL){avl_tree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;one_node->index = 0;one_node->parent = NULL;
		one_node->item = one_item;tree->root = one_node;return 1;
	}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->item;vector_add(&(one_item->dataVec), value);check_node = result_node;
		while(check_node != NULL){check_node->count++;check_node = check_node->parent;}return 1;		
	}
	one_item = avl_tree_item_alloc();if(one_item == NULL){return 0;}
	one_node = avl_tree_node_alloc();if(one_node == NULL){avl_tree_item_free(one_item);return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;
	one_node->index = result_index;one_node->parent = result_node;one_node->item = one_item;
	result_node->childArray[result_index] = one_node;check_node = result_node;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_depth-left_depth);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		avl_tree_node_rotate(tree, check_node);
		check_node = check_parent;
	}
	return 1;
}
int avl_tree_remove(avl_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	avl_tree_node_t *one_node;avl_tree_item_t *one_item;int one_count;avl_tree_node_t *one_child;int one_index;avl_tree_node_t *one_parent;
	avl_tree_node_t *replace_node;avl_tree_item_t *replace_item;avl_tree_node_t *check_node;avl_tree_node_t *check_parent;
	avl_tree_node_t *left_child;avl_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = avl_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	if(result_node->childArray[0] != NULL && result_node->childArray[1] != NULL)
	{
		one_node = result_node->childArray[0];replace_node = NULL;temp_result = avl_tree_find_max(tree, one_node, &replace_node);
		if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(replace_node == NULL){return 0;}replace_item = replace_node->item;
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		one_count = ((replace_item->dataVec.count)-(one_item->dataVec.count));avl_tree_item_free(one_item);
		result_node->item = replace_item;replace_node->item = NULL;check_node = result_node;
		while(check_node != NULL){check_node->count += one_count;check_node = check_node->parent;}result_node = replace_node;
	}
	else
	{
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		avl_tree_item_free(one_item);result_node->item = NULL;
	}
	one_index = result_node->index;one_parent = result_node->parent;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] == NULL)
	{
		one_child = result_node->childArray[0];result_node->childArray[0] = NULL;avl_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else if(result_node->childArray[0] == NULL && result_node->childArray[1] != NULL)
	{
		one_child = result_node->childArray[1];result_node->childArray[1] = NULL;avl_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else
	{
		one_child = NULL;result_node->childArray[0] = NULL;result_node->childArray[1] = NULL;avl_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;}else{one_parent->childArray[one_index] = one_child;}
	}
	if(one_parent == NULL){return 1;}check_node = one_parent;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_depth-left_depth);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		avl_tree_node_rotate(tree, check_node);
		check_node = check_parent;
	}
	return 1;
}
int avl_tree_inorder_get_all_item_other(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;avl_tree_node_t *check_node;
	avl_tree_node_t *next_node;int temp_result;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, 1, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}next_node = NULL;
		temp_result = avl_tree_inorder_get_next_item(tree, check_node, &next_node);if(next_node == NULL){return 1;}check_node = next_node;
	}
	return 1;
}
int avl_tree_inorder_get_all_item_another(avl_tree_t *tree, vector_t *all_item_vec)
{
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;avl_tree_node_t *check_node;
	avl_tree_node_t *prev_node;int temp_result;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, tree->root->count, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}prev_node = NULL;
		temp_result = avl_tree_inorder_get_prev_item(tree, check_node, &prev_node);if(prev_node == NULL){return 1;}check_node = prev_node;
	}
	return 1;
}
int avl_tree_rank_min_max_remove(avl_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;avl_tree_node_t *one_node;vector_t one_node_vec;avl_tree_node_t *min_node;avl_tree_node_t *max_node;
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;avl_tree_node_t *check_node;
	avl_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	avl_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
    }
    else
    {
    	one_count = (max_rank-min_rank+1);
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank));check_node = min_node;
    	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = avl_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = avl_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  	avl_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (upper_min_rank-min_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));check_node = min_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	avl_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  	avl_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (max_rank-lower_max_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	vector_delete_min_max(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank));check_node = max_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
	vector_free(&one_node_vec);return 1;
}
int avl_tree_rank_min_max_get(avl_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;avl_tree_node_t *one_node;vector_t one_node_vec;avl_tree_node_t *min_node;avl_tree_node_t *max_node;
	avl_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;avl_tree_node_t *check_node;
	avl_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = avl_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = avl_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = avl_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_node_vec);return 1;
}
int avl_tree_min_max_remove(avl_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;avl_tree_node_t *one_node;vector_t one_node_vec;avl_tree_node_t *min_node;avl_tree_node_t *max_node;
	avl_tree_node_t *result_node;avl_tree_node_t *check_node;avl_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = avl_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = avl_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    avl_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = avl_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = avl_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  avl_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	avl_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  avl_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
	vector_free(&one_node_vec);return 1;	
}
int avl_tree_min_max_get(avl_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;avl_tree_node_t *one_node;vector_t one_node_vec;avl_tree_node_t *min_node;avl_tree_node_t *max_node;
	avl_tree_node_t *result_node;avl_tree_node_t *check_node;avl_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = avl_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = avl_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = avl_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = avl_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
	vector_free(&one_node_vec);return 1;	
}
int avl_tree_iterator_init(avl_tree_t *tree, avl_tree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return 0;}avl_tree_node_get_all_item(tree->root, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
avl_tree_iterator_t * avl_tree_iterator_alloc(avl_tree_t *tree)
{
	size_t size;avl_tree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(avl_tree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(avl_tree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void avl_tree_iterator_free(avl_tree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int avl_tree_iterator_next(avl_tree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}
}
void avl_tree_item_dump(FILE *fd, avl_tree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void avl_tree_dump(FILE *fd, avl_tree_t *tree)
{
	avl_tree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = avl_tree_iterator_alloc(tree);if(iterator == NULL){return ;}
	avl_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(avl_tree_iterator_next(iterator) == 1){avl_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	avl_tree_iterator_free(iterator);
}
void avl_tree_dump_inorder_other(FILE *fd, avl_tree_t *tree)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return ;}avl_tree_inorder_get_all_item_other(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void avl_tree_dump_inorder_another(FILE *fd, avl_tree_t *tree)
{
	int i;avl_tree_item_t *item;vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return ;}avl_tree_inorder_get_all_item_another(tree, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return ;}
	for(i = 0;i < oneVec.count;i++)
	{
		item = oneVec.mem[i];if(item != NULL){avl_tree_item_dump(fd, item);fprintf(fd, "\n");}
	}
	vector_free(&oneVec);
}
void avl_tree_dot_node_dump(FILE *fd, avl_tree_node_t *node, int *nDump)
{
	int i;avl_tree_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n%d:%d\\n",oneDump, node->type, node->depth, node->index, node->count, node->item_count);
	*nDump = (oneDump+1);
	if(node->item != NULL){fprintf(fd, "%s:%d\\n",((char *)(node->item->key)),node->item->dataVec.count);}
	fprintf(fd, "\"];\n");
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			avl_tree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void avl_tree_dot_dump(avl_tree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("avl_tree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph avl_tree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");avl_tree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;avl_tree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = avl_tree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    avl_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	avl_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    avl_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	avl_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_splay(tree, (byte_t *)(arrKeyStr[27]), strlen(arrKeyStr[27]));
	for(i = 5; i < 8; ++i)
	{
	    avl_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	avl_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_splay(tree, (byte_t *)(arrKeyStr[27]), strlen(arrKeyStr[27]));
	for(i = 5; i < 8; ++i)
	{
	    avl_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	avl_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fprintf(fd, "------\n");
	avl_tree_dump_inorder_other(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	avl_tree_dump_inorder_another(fd, tree);
	fprintf(fd, "------\n");
	fflush(fd);
	fclose(fd);
	avl_tree_dot_dump(tree);
	avl_tree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

treap.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

#define MT_32_W 32
#define MT_32_N 624
#define MT_32_M 397
#define MT_32_R 31
#define MT_32_A 0x9908B0DFU
#define MT_32_U 11
#define MT_32_D 0xFFFFFFFFU
#define MT_32_S 7
#define MT_32_B 0x9D2C5680U
#define MT_32_T 15
#define MT_32_C 0xEFC60000U
#define MT_32_L 18
#define MT_32_F 0x6C078965U
#define MT_32_UPPER_MASK 0x80000000U
#define MT_32_LOWER_MASK 0x7FFFFFFFU

typedef struct {uint32_t mt[MT_32_N];int index;} mt_32_gen_t;

void mt_32_seed(mt_32_gen_t *mt_32_gen, uint32_t seed)
{
	int i;mt_32_gen->mt[0] = seed;
	for(i = 1;i < MT_32_N;i++){mt_32_gen->mt[i] = ((MT_32_F * (mt_32_gen->mt[i-1] ^ (mt_32_gen->mt[i-1] >> (MT_32_W - 2)))) + i);}
	mt_32_gen->index = MT_32_N;
}
void mt_32_twist(mt_32_gen_t *mt_32_gen)
{
	int i;uint32_t y;uint32_t one;
	for(i = 0;i < MT_32_N;i++)
	{
		y = ((mt_32_gen->mt[i] & MT_32_UPPER_MASK) + (mt_32_gen->mt[(i+1) % MT_32_N] & MT_32_LOWER_MASK));
		one = (y >> 1);if(y % 2 != 0){one = (one ^ MT_32_A);}
		mt_32_gen->mt[i] = (mt_32_gen->mt[(i + MT_32_M) % MT_32_N] ^ one);
	}
	mt_32_gen->index = 0;
}
uint32_t mt_32_next(mt_32_gen_t *mt_32_gen)
{
	uint32_t y;if(mt_32_gen->index >= MT_32_N){mt_32_twist(mt_32_gen);}
	y = mt_32_gen->mt[mt_32_gen->index];
	y = (y ^ ((y >> MT_32_U) & MT_32_D));
	y = (y ^ ((y << MT_32_S) & MT_32_B));
	y = (y ^ ((y << MT_32_T) & MT_32_C));
	y = (y ^ (y >> MT_32_L));
	mt_32_gen->index++;return y;
}

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} treap_tree_item_t;
typedef struct treap_tree_node {
	int type;int depth;int count;int item_count;uint64_t priority;int index;struct treap_tree_node *parent;treap_tree_item_t *item;struct treap_tree_node *childArray[2];
} treap_tree_node_t;
typedef struct {treap_tree_node_t *root;mt_32_gen_t prior_gen;} treap_tree_t;
typedef struct {treap_tree_t *tree;int vec_index;vector_t all_item_vec;treap_tree_item_t *item;} treap_tree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int treap_tree_item_init(treap_tree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
treap_tree_item_t * treap_tree_item_alloc()
{
  size_t size;treap_tree_item_t *item;size = sizeof(treap_tree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  treap_tree_item_init(item);return item;
}
int treap_tree_item_other_free(treap_tree_item_t *item){vector_free(&(item->dataVec));treap_tree_item_init(item);return 1;}
void treap_tree_item_free(treap_tree_item_t *item){if(item != NULL){treap_tree_item_other_free(item);free(item);}}
int treap_tree_node_init(treap_tree_node_t *node)
{
	node->type = 0;node->depth = 0;node->count = 0;node->item_count = 0;node->priority = 0;node->index = 0;node->parent = NULL;
	node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
treap_tree_node_t * treap_tree_node_alloc()
{
	size_t size;treap_tree_node_t *node;size = sizeof(treap_tree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	treap_tree_node_init(node);return node;
}
int treap_tree_node_other_free(treap_tree_node_t *node)
{
	if(node->item != NULL){treap_tree_item_free(node->item);node->item = NULL;}treap_tree_node_init(node);return 1;
}
void treap_tree_node_free(treap_tree_node_t *node)
{
	if(node != NULL){treap_tree_node_other_free(node);free(node);}
}
void treap_tree_node_destroy(treap_tree_node_t **node)
{
	treap_tree_node_t **treap_tree_node;treap_tree_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	if(one_node->childArray[0] != NULL){treap_tree_node = &(one_node->childArray[0]);treap_tree_node_destroy(treap_tree_node);one_node->childArray[0] = NULL;}
	if(one_node->childArray[1] != NULL){treap_tree_node = &(one_node->childArray[1]);treap_tree_node_destroy(treap_tree_node);one_node->childArray[1] = NULL;}
	treap_tree_node_free((*node));*node = NULL;
}
void treap_tree_node_get_all_item(treap_tree_node_t *node, vector_t *all_item_vec)
{
	if(node == NULL){return ;}
	if(node->childArray[0] != NULL){treap_tree_node_get_all_item(node->childArray[0], all_item_vec);}
	if(node->item != NULL){vector_add(all_item_vec, node->item);}
	if(node->childArray[1] != NULL){treap_tree_node_get_all_item(node->childArray[1], all_item_vec);}
}
int treap_tree_preorder_get_all_item(treap_tree_t *tree, vector_t *all_item_vec)
{
	treap_tree_node_t *last_node;treap_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else{if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int treap_tree_inorder_get_next_item(treap_tree_t *tree, treap_tree_node_t *node, treap_tree_node_t **result_node)
{
	treap_tree_node_t *last_node;treap_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}			
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int treap_tree_inorder_get_all_item(treap_tree_t *tree, vector_t *all_item_vec)
{
	treap_tree_node_t *last_node;treap_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int treap_tree_postorder_get_all_item(treap_tree_t *tree, vector_t *all_item_vec)
{
	treap_tree_node_t *last_node;treap_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
		else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else
				{
					if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
treap_tree_t * treap_tree_alloc()
{
	size_t size;treap_tree_t *tree;size = sizeof(treap_tree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;mt_32_seed(&(tree->prior_gen), 3331);return tree;
}
void treap_tree_destroy(treap_tree_t *tree)
{
	treap_tree_node_t **treap_tree_node;if(tree == NULL){return ;}if(tree->root == NULL){free(tree);return ;}
	treap_tree_node = &(tree->root);treap_tree_node_destroy(treap_tree_node);tree->root = NULL;free(tree);
}
int treap_tree_node_rotate_left_child(treap_tree_t *tree, treap_tree_node_t *node, treap_tree_node_t *left_child)
{
	int index;treap_tree_node_t *parent;treap_tree_node_t *right_child;treap_tree_node_t *left_left_child;treap_tree_node_t *left_right_child;
	int right_depth;int left_left_depth;int left_right_depth;int right_count;int left_left_count;int left_right_count;
	int right_item_count;int left_left_item_count;int left_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(left_child == NULL){return -1;}if(node->childArray[0] != left_child){return -1;}
	if(node->item == NULL){return -1;}if(left_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	right_child = node->childArray[1];left_left_child = left_child->childArray[0];left_right_child = left_child->childArray[1];
	if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
	else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
	if(left_left_child == NULL){left_left_depth = -1;left_left_count = 0;left_left_item_count = 0;}
	else{left_left_depth = left_left_child->depth;left_left_count = left_left_child->count;left_left_item_count = left_left_child->item_count;}
	if(left_right_child == NULL){left_right_depth = -1;left_right_count = 0;left_right_item_count = 0;}
	else{left_right_depth = left_right_child->depth;left_right_count = left_right_child->count;left_right_item_count = left_right_child->item_count;}
	if(parent == NULL){tree->root = left_child;left_child->index = 0;left_child->parent = NULL;}
	else{parent->childArray[index] = left_child;left_child->index = index;left_child->parent = parent;}
	left_child->childArray[1] = node;node->index = 1;node->parent = left_child;
	node->childArray[0] = left_right_child;if(left_right_child != NULL){left_right_child->index = 0;left_right_child->parent = node;}
	node->type = (right_depth-left_right_depth);node->depth = max((left_right_depth+1), (right_depth+1));
	node->count = node->item->dataVec.count;node->count += left_right_count;node->count += right_count;
	node->item_count = 1;node->item_count += left_right_item_count;node->item_count += right_item_count;
	left_child->type = (node->depth-left_left_depth);left_child->depth = max((left_left_depth+1), (node->depth+1));
	left_child->count = left_child->item->dataVec.count;left_child->count += left_left_count;left_child->count += node->count;
	left_child->item_count = 1;left_child->item_count += left_left_item_count;left_child->item_count += node->item_count;
	return 1;
}
int treap_tree_node_rotate_right_child(treap_tree_t *tree, treap_tree_node_t *node, treap_tree_node_t *right_child)
{
	int index;treap_tree_node_t *parent;treap_tree_node_t *left_child;treap_tree_node_t *right_left_child;treap_tree_node_t *right_right_child;
	int left_depth;int right_left_depth;int right_right_depth;int left_count;int right_left_count;int right_right_count;
	int left_item_count;int right_left_item_count;int right_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(right_child == NULL){return -1;}if(node->childArray[1] != right_child){return -1;}
	if(node->item == NULL){return -1;}if(right_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	left_child = node->childArray[0];right_left_child = right_child->childArray[0];right_right_child = right_child->childArray[1];
	if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
	else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
	if(right_left_child == NULL){right_left_depth = -1;right_left_count = 0;right_left_item_count = 0;}
	else{right_left_depth = right_left_child->depth;right_left_count = right_left_child->count;right_left_item_count = right_left_child->item_count;}
	if(right_right_child == NULL){right_right_depth = -1;right_right_count = 0;right_right_item_count = 0;}
	else{right_right_depth = right_right_child->depth;right_right_count = right_right_child->count;right_right_item_count = right_right_child->item_count;}
	if(parent == NULL){tree->root = right_child;right_child->index = 0;right_child->parent = NULL;}
	else{parent->childArray[index] = right_child;right_child->index = index;right_child->parent = parent;}
	right_child->childArray[0] = node;node->index = 0;node->parent = right_child;
	node->childArray[1] = right_left_child;if(right_left_child != NULL){right_left_child->index = 1;right_left_child->parent = node;}
	node->type = (right_left_depth-left_depth);node->depth = max((left_depth+1), (right_left_depth+1));
	node->count = node->item->dataVec.count;node->count += left_count;node->count += right_left_count;
	node->item_count = 1;node->item_count += left_item_count;node->item_count += right_left_item_count;
	right_child->type = (right_right_depth-node->depth);right_child->depth = max((node->depth+1), (right_right_depth+1));
	right_child->count = right_child->item->dataVec.count;right_child->count += node->count;right_child->count += right_right_count;
	right_child->item_count = 1;right_child->item_count += node->item_count;right_child->item_count += right_right_item_count;
	return 1;	
}
int treap_tree_node_rotate_up(treap_tree_t *tree, treap_tree_node_t *node)
{
	int check_index;treap_tree_node_t *check_parent;treap_tree_node_t *check_node;treap_tree_node_t *one_left_child;treap_tree_node_t *one_right_child;
	int one_left_depth;int one_right_depth;int one_left_count;int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(node->parent == NULL){return 0;}if(node->parent->priority >= node->priority){return 0;}check_node = node;
	while(check_node != NULL && check_node->parent != NULL && check_node->parent->priority < check_node->priority)
	{
		check_index = check_node->index;check_parent = check_node->parent;
		one_left_child = check_parent->childArray[0];one_right_child = check_parent->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_parent->type = (one_right_depth-one_left_depth);check_parent->depth = max((one_left_depth+1), (one_right_depth+1));
		check_parent->count = check_parent->item->dataVec.count;check_parent->count += one_left_count;check_parent->count += one_right_count;
		check_parent->item_count = 1;check_parent->item_count += one_left_item_count;check_parent->item_count += one_right_item_count;
		if(check_index == 0){treap_tree_node_rotate_left_child(tree, check_parent, check_node);}else{treap_tree_node_rotate_right_child(tree, check_parent, check_node);}
	}
	if(check_node->parent == NULL){return 1;}else{check_node = check_node->parent;}
	while(check_node != NULL)
	{
		check_parent = check_node->parent;
		one_left_child = check_node->childArray[0];one_right_child = check_node->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_node->type = (one_right_depth-one_left_depth);check_node->depth = max((one_left_depth+1), (one_right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += one_left_count;check_node->count += one_right_count;
		check_node->item_count = 1;check_node->item_count += one_left_item_count;check_node->item_count += one_right_item_count;
		check_node = check_parent;
	}
	return 1;
}
int treap_tree_node_rotate_down(treap_tree_t *tree, treap_tree_node_t *node)
{
	treap_tree_node_t *check_parent;treap_tree_node_t *check_node;treap_tree_node_t *left_child;treap_tree_node_t *right_child;treap_tree_node_t *one_left_child;
	treap_tree_node_t *one_right_child;int one_left_depth;int one_right_depth;int one_left_count;int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}check_node = node;
	while(check_node != NULL)
	{
		left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child != NULL && right_child != NULL)
		{
			if(left_child->priority >= right_child->priority)
			{
				if(check_node->priority >= left_child->priority){break;}else{treap_tree_node_rotate_left_child(tree, check_node, left_child);}
			}
			else
			{
				if(check_node->priority >= right_child->priority){break;}else{treap_tree_node_rotate_right_child(tree, check_node, right_child);}
			}
		}
		else if(left_child != NULL && right_child == NULL)
		{
			if(check_node->priority >= left_child->priority){break;}else{treap_tree_node_rotate_left_child(tree, check_node, left_child);}
		}
		else if(left_child == NULL && right_child != NULL)
		{
			if(check_node->priority >= right_child->priority){break;}else{treap_tree_node_rotate_right_child(tree, check_node, right_child);}
		}
		else{break;}
	}
	while(check_node != NULL)
	{
		check_parent = check_node->parent;
		one_left_child = check_node->childArray[0];one_right_child = check_node->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_node->type = (one_right_depth-one_left_depth);check_node->depth = max((one_left_depth+1), (one_right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += one_left_count;check_node->count += one_right_count;
		check_node->item_count = 1;check_node->item_count += one_left_item_count;check_node->item_count += one_right_item_count;
		check_node = check_parent;
	}
	return 1;	
}
int treap_tree_find_rank(treap_tree_t *tree, treap_tree_node_t *node, int rank, treap_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count)
{
	treap_tree_node_t *left_child;int left_count;int left_item_count;treap_tree_node_t *check_node;int check_count;int check_item_count;
	int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(rank < 1){return -1;}if(rank > tree->root->count){return -1;}*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;
	check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}if((rank-rank_count) > check_node->count){return -1;}left_child = check_node->childArray[0];
		if(left_child == NULL){left_count = 0;left_item_count = 0;}else{left_count = left_child->count;left_item_count = left_child->item_count;}
		check_count = (left_count+(check_node->item->dataVec.count));check_item_count = (left_item_count+1);
		if((rank-rank_count) > check_count)
		{
			rank_count += check_count;rank_item_count += check_item_count;
			if(check_node->childArray[1] == NULL){return 2;}else{check_node = check_node->childArray[1];}
		}
		else if((rank-rank_count) <= left_count)
		{
			if(check_node->childArray[0] == NULL){return 2;}else{check_node = check_node->childArray[0];}			
		}
		else
		{
			rank_count += check_count;rank_item_count += check_item_count;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}		
	}
	return 0;
}
int treap_tree_find_base(treap_tree_t *tree, treap_tree_node_t *node, byte_t *key, word_t key_len, treap_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count, int *result_index)
{
	int one;treap_tree_item_t *item;treap_tree_node_t *check_node;int rank_count;int rank_item_count;treap_tree_node_t *one_child;
	int one_count;int one_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;*result_index = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			if(check_node->childArray[1] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 1;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 0;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}
	}
	return 0;
}
int treap_tree_find_max(treap_tree_t *tree, treap_tree_node_t *node, treap_tree_node_t **result_node)
{
	treap_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[1] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[1];}
	}
	return 0;
}
int treap_tree_find_min(treap_tree_t *tree, treap_tree_node_t *node, treap_tree_node_t **result_node)
{
	treap_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[0] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[0];}
	}
	return 0;
}
int treap_tree_find_first_upper_equal(treap_tree_t *tree, treap_tree_node_t *node, byte_t *key, word_t key_len, treap_tree_node_t **result_node)
{
	int one;treap_tree_item_t *item;treap_tree_node_t *check_node;treap_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int treap_tree_find_last_lower_equal(treap_tree_t *tree, treap_tree_node_t *node, byte_t *key, word_t key_len, treap_tree_node_t **result_node)
{
	int one;treap_tree_item_t *item;treap_tree_node_t *check_node;treap_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int treap_tree_get_rank(treap_tree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	treap_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = treap_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int treap_tree_check_exist(treap_tree_t *tree, byte_t *key, word_t key_len)
{
	treap_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = treap_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}return 1;
}
int treap_tree_get(treap_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	treap_tree_item_t *item;treap_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = treap_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(item->dataVec), result_data_vec);}return 1;
}
int treap_tree_insert(treap_tree_t *tree, byte_t *key, word_t key_len, void *value)
{
	treap_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;treap_tree_item_t *one_item;
	treap_tree_node_t *one_node;uint64_t one_priority;treap_tree_node_t *check_node;treap_tree_node_t *check_parent;treap_tree_node_t *up_node;
	treap_tree_node_t *left_child;treap_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = treap_tree_item_alloc();if(one_item == NULL){return 0;}
		one_node = treap_tree_node_alloc();if(one_node == NULL){treap_tree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_priority = 0;one_priority = mt_32_next(&(tree->prior_gen));
		one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;one_node->priority = one_priority;
		one_node->index = 0;one_node->parent = NULL;one_node->item = one_item;tree->root = one_node;return 1;
	}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = treap_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->item;vector_add(&(one_item->dataVec), value);check_node = result_node;
		while(check_node != NULL){check_node->count++;check_node = check_node->parent;}return 1;		
	}
	one_item = treap_tree_item_alloc();if(one_item == NULL){return 0;}
	one_node = treap_tree_node_alloc();if(one_node == NULL){treap_tree_item_free(one_item);return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	one_priority = 0;one_priority = mt_32_next(&(tree->prior_gen));
	one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;one_node->priority = one_priority;
	one_node->index = result_index;one_node->parent = result_node;one_node->item = one_item;up_node = one_node;
	result_node->childArray[result_index] = one_node;check_node = result_node;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_depth-left_depth);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		check_node = check_parent;
	}
	treap_tree_node_rotate_up(tree, up_node);
	return 1;
}
int treap_tree_remove(treap_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	treap_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	treap_tree_node_t *one_node;treap_tree_item_t *one_item;int one_count;treap_tree_node_t *one_child;int one_index;treap_tree_node_t *one_parent;
	treap_tree_node_t *replace_node;treap_tree_item_t *replace_item;treap_tree_node_t *check_node;treap_tree_node_t *check_parent;
             treap_tree_node_t *up_node;treap_tree_node_t *down_node;
	treap_tree_node_t *left_child;treap_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = treap_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}up_node = NULL;down_node = NULL;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] != NULL)
	{
		one_node = result_node->childArray[0];replace_node = NULL;temp_result = treap_tree_find_max(tree, one_node, &replace_node);
		if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(replace_node == NULL){return 0;}replace_item = replace_node->item;
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		one_count = ((replace_item->dataVec.count)-(one_item->dataVec.count));treap_tree_item_free(one_item);
		result_node->item = replace_item;replace_node->item = NULL;
		if(replace_node->priority < result_node->priority){down_node = result_node;}
		else if(replace_node->priority > result_node->priority){up_node = result_node;}
		result_node->priority = replace_node->priority;replace_node->priority = 0;check_node = result_node;
		while(check_node != NULL){check_node->count += one_count;check_node = check_node->parent;}result_node = replace_node;
	}
	else
	{
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		treap_tree_item_free(one_item);result_node->item = NULL;result_node->priority = 0;
	}
	one_index = result_node->index;one_parent = result_node->parent;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] == NULL)
	{
		one_child = result_node->childArray[0];result_node->childArray[0] = NULL;treap_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else if(result_node->childArray[0] == NULL && result_node->childArray[1] != NULL)
	{
		one_child = result_node->childArray[1];result_node->childArray[1] = NULL;treap_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else
	{
		one_child = NULL;result_node->childArray[0] = NULL;result_node->childArray[1] = NULL;treap_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;}else{one_parent->childArray[one_index] = one_child;}
	}
	if(one_parent == NULL){return 1;}check_node = one_parent;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_depth-left_depth);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		check_node = check_parent;
	}
	if(down_node != NULL){treap_tree_node_rotate_down(tree, down_node);}
	else if(up_node != NULL){treap_tree_node_rotate_up(tree, up_node);}
	return 1;
}
int treap_tree_inorder_get_all_item_other(treap_tree_t *tree, vector_t *all_item_vec)
{
	treap_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;treap_tree_node_t *check_node;
	treap_tree_node_t *next_node;int temp_result;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = treap_tree_find_rank(tree, tree->root, 1, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}next_node = NULL;
		temp_result = treap_tree_inorder_get_next_item(tree, check_node, &next_node);if(next_node == NULL){return 1;}check_node = next_node;
	}
	return 1;
}
int treap_tree_rank_min_max_remove(treap_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;treap_tree_node_t *one_node;vector_t one_node_vec;treap_tree_node_t *min_node;treap_tree_node_t *max_node;
	treap_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;treap_tree_node_t *check_node;
	treap_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = treap_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = treap_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	treap_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
    }
    else
    {
    	one_count = (max_rank-min_rank+1);
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank));check_node = min_node;
    	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = treap_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = treap_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  	treap_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (upper_min_rank-min_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));check_node = min_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	treap_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  	treap_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (max_rank-lower_max_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	vector_delete_min_max(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank));check_node = max_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
	vector_free(&one_node_vec);return 1;
}
int treap_tree_rank_min_max_get(treap_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;treap_tree_node_t *one_node;vector_t one_node_vec;treap_tree_node_t *min_node;treap_tree_node_t *max_node;
	treap_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;treap_tree_node_t *check_node;
	treap_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = treap_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = treap_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = treap_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = treap_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_node_vec);return 1;
}
int treap_tree_min_max_remove(treap_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;treap_tree_node_t *one_node;vector_t one_node_vec;treap_tree_node_t *min_node;treap_tree_node_t *max_node;
	treap_tree_node_t *result_node;treap_tree_node_t *check_node;treap_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = treap_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = treap_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    treap_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = treap_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = treap_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  treap_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	treap_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  treap_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
	vector_free(&one_node_vec);return 1;	
}
int treap_tree_min_max_get(treap_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;treap_tree_node_t *one_node;vector_t one_node_vec;treap_tree_node_t *min_node;treap_tree_node_t *max_node;
	treap_tree_node_t *result_node;treap_tree_node_t *check_node;treap_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = treap_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = treap_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = treap_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = treap_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
	vector_free(&one_node_vec);return 1;	
}
int treap_tree_iterator_init(treap_tree_t *tree, treap_tree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return 0;}treap_tree_node_get_all_item(tree->root, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
treap_tree_iterator_t * treap_tree_iterator_alloc(treap_tree_t *tree)
{
	size_t size;treap_tree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(treap_tree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(treap_tree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void treap_tree_iterator_free(treap_tree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int treap_tree_iterator_next(treap_tree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;		
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}	
}
void treap_tree_item_dump(FILE *fd, treap_tree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void treap_tree_dump(FILE *fd, treap_tree_t *tree)
{
	treap_tree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = treap_tree_iterator_alloc(tree);if(iterator == NULL){return ;}
	treap_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(treap_tree_iterator_next(iterator) == 1){treap_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	treap_tree_iterator_free(iterator);
}
void treap_tree_dot_node_dump(FILE *fd, treap_tree_node_t *node, int *nDump)
{
	int i;treap_tree_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n%d:%d\\n%I64x\\n",oneDump, node->type, node->depth, node->index, node->count, node->item_count, node->priority);
	*nDump = (oneDump+1);
	if(node->item != NULL){fprintf(fd, "%s:%d\\n",((char *)(node->item->key)),node->item->dataVec.count);}
	fprintf(fd, "\"];\n");
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			treap_tree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void treap_tree_dot_dump(treap_tree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("treap_tree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph treap_tree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");treap_tree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;treap_tree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = treap_tree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    treap_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	treap_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    treap_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	treap_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    treap_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	treap_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    treap_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	treap_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	treap_tree_dot_dump(tree);
	treap_tree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

scapegoat_tree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;} scapegoat_tree_item_t;
typedef struct scapegoat_tree_node {
	int type;int depth;int count;int item_count;int index;struct scapegoat_tree_node *parent;scapegoat_tree_item_t *item;struct scapegoat_tree_node *childArray[2];
} scapegoat_tree_node_t;
typedef struct {scapegoat_tree_node_t *root;double alpha;} scapegoat_tree_t;
typedef struct {scapegoat_tree_t *tree;int vec_index;vector_t all_item_vec;scapegoat_tree_item_t *item;} scapegoat_tree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int scapegoat_tree_item_init(scapegoat_tree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));return 1;}
scapegoat_tree_item_t * scapegoat_tree_item_alloc()
{
  size_t size;scapegoat_tree_item_t *item;size = sizeof(scapegoat_tree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  scapegoat_tree_item_init(item);return item;
}
int scapegoat_tree_item_other_free(scapegoat_tree_item_t *item){vector_free(&(item->dataVec));scapegoat_tree_item_init(item);return 1;}
void scapegoat_tree_item_free(scapegoat_tree_item_t *item){if(item != NULL){scapegoat_tree_item_other_free(item);free(item);}}
int scapegoat_tree_node_init(scapegoat_tree_node_t *node)
{
	node->type = 0;node->depth = 0;node->count = 0;node->item_count = 0;node->index = 0;node->parent = NULL;
	node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
scapegoat_tree_node_t * scapegoat_tree_node_alloc()
{
	size_t size;scapegoat_tree_node_t *node;size = sizeof(scapegoat_tree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	scapegoat_tree_node_init(node);return node;
}
int scapegoat_tree_node_other_free(scapegoat_tree_node_t *node)
{
	if(node->item != NULL){scapegoat_tree_item_free(node->item);node->item = NULL;}scapegoat_tree_node_init(node);return 1;
}
void scapegoat_tree_node_free(scapegoat_tree_node_t *node)
{
	if(node != NULL){scapegoat_tree_node_other_free(node);free(node);}
}
void scapegoat_tree_node_destroy(scapegoat_tree_node_t **node)
{
	scapegoat_tree_node_t **scapegoat_tree_node;scapegoat_tree_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	if(one_node->childArray[0] != NULL){scapegoat_tree_node = &(one_node->childArray[0]);scapegoat_tree_node_destroy(scapegoat_tree_node);one_node->childArray[0] = NULL;}
	if(one_node->childArray[1] != NULL){scapegoat_tree_node = &(one_node->childArray[1]);scapegoat_tree_node_destroy(scapegoat_tree_node);one_node->childArray[1] = NULL;}
	scapegoat_tree_node_free((*node));*node = NULL;
}
void scapegoat_tree_node_get_all_item(scapegoat_tree_node_t *node, vector_t *all_item_vec)
{
	if(node == NULL){return ;}
	if(node->childArray[0] != NULL){scapegoat_tree_node_get_all_item(node->childArray[0], all_item_vec);}
	if(node->item != NULL){vector_add(all_item_vec, node->item);}
	if(node->childArray[1] != NULL){scapegoat_tree_node_get_all_item(node->childArray[1], all_item_vec);}
}
int scapegoat_tree_preorder_get_all_item(scapegoat_tree_t *tree, vector_t *all_item_vec)
{
	scapegoat_tree_node_t *last_node;scapegoat_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else{if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int scapegoat_tree_inorder_get_next_item(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, scapegoat_tree_node_t **result_node)
{
	scapegoat_tree_node_t *last_node;scapegoat_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}			
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int scapegoat_tree_inorder_get_all_item(scapegoat_tree_t *tree, vector_t *all_item_vec)
{
	scapegoat_tree_node_t *last_node;scapegoat_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int scapegoat_tree_postorder_get_all_item(scapegoat_tree_t *tree, vector_t *all_item_vec)
{
	scapegoat_tree_node_t *last_node;scapegoat_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{		
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
		else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else
				{
					if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
scapegoat_tree_t * scapegoat_tree_alloc()
{
	size_t size;scapegoat_tree_t *tree;size = sizeof(scapegoat_tree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;tree->alpha = 0.75;return tree;
}
void scapegoat_tree_destroy(scapegoat_tree_t *tree)
{
	scapegoat_tree_node_t **scapegoat_tree_node;if(tree == NULL){return ;}if(tree->root == NULL){free(tree);return ;}
	scapegoat_tree_node = &(tree->root);scapegoat_tree_node_destroy(scapegoat_tree_node);tree->root = NULL;free(tree);
}
int scapegoat_tree_node_rotate_left_child(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, scapegoat_tree_node_t *left_child)
{
	int index;scapegoat_tree_node_t *parent;scapegoat_tree_node_t *right_child;scapegoat_tree_node_t *left_left_child;scapegoat_tree_node_t *left_right_child;
	int right_depth;int left_left_depth;int left_right_depth;int right_count;int left_left_count;int left_right_count;
	int right_item_count;int left_left_item_count;int left_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(left_child == NULL){return -1;}if(node->childArray[0] != left_child){return -1;}
	if(node->item == NULL){return -1;}if(left_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	right_child = node->childArray[1];left_left_child = left_child->childArray[0];left_right_child = left_child->childArray[1];
	if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
	else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
	if(left_left_child == NULL){left_left_depth = -1;left_left_count = 0;left_left_item_count = 0;}
	else{left_left_depth = left_left_child->depth;left_left_count = left_left_child->count;left_left_item_count = left_left_child->item_count;}
	if(left_right_child == NULL){left_right_depth = -1;left_right_count = 0;left_right_item_count = 0;}
	else{left_right_depth = left_right_child->depth;left_right_count = left_right_child->count;left_right_item_count = left_right_child->item_count;}
	if(parent == NULL){tree->root = left_child;left_child->index = 0;left_child->parent = NULL;}
	else{parent->childArray[index] = left_child;left_child->index = index;left_child->parent = parent;}
	left_child->childArray[1] = node;node->index = 1;node->parent = left_child;
	node->childArray[0] = left_right_child;if(left_right_child != NULL){left_right_child->index = 0;left_right_child->parent = node;}
	node->type = (right_item_count-left_right_item_count);node->depth = max((left_right_depth+1), (right_depth+1));
	node->count = node->item->dataVec.count;node->count += left_right_count;node->count += right_count;
	node->item_count = 1;node->item_count += left_right_item_count;node->item_count += right_item_count;
	left_child->type = (node->item_count-left_left_item_count);left_child->depth = max((left_left_depth+1), (node->depth+1));
	left_child->count = left_child->item->dataVec.count;left_child->count += left_left_count;left_child->count += node->count;
	left_child->item_count = 1;left_child->item_count += left_left_item_count;left_child->item_count += node->item_count;
	return 1;
}
int scapegoat_tree_node_rotate_right_child(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, scapegoat_tree_node_t *right_child)
{
	int index;scapegoat_tree_node_t *parent;scapegoat_tree_node_t *left_child;scapegoat_tree_node_t *right_left_child;scapegoat_tree_node_t *right_right_child;
	int left_depth;int right_left_depth;int right_right_depth;int left_count;int right_left_count;int right_right_count;
	int left_item_count;int right_left_item_count;int right_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(right_child == NULL){return -1;}if(node->childArray[1] != right_child){return -1;}
	if(node->item == NULL){return -1;}if(right_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	left_child = node->childArray[0];right_left_child = right_child->childArray[0];right_right_child = right_child->childArray[1];
	if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
	else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
	if(right_left_child == NULL){right_left_depth = -1;right_left_count = 0;right_left_item_count = 0;}
	else{right_left_depth = right_left_child->depth;right_left_count = right_left_child->count;right_left_item_count = right_left_child->item_count;}
	if(right_right_child == NULL){right_right_depth = -1;right_right_count = 0;right_right_item_count = 0;}
	else{right_right_depth = right_right_child->depth;right_right_count = right_right_child->count;right_right_item_count = right_right_child->item_count;}
	if(parent == NULL){tree->root = right_child;right_child->index = 0;right_child->parent = NULL;}
	else{parent->childArray[index] = right_child;right_child->index = index;right_child->parent = parent;}
	right_child->childArray[0] = node;node->index = 0;node->parent = right_child;
	node->childArray[1] = right_left_child;if(right_left_child != NULL){right_left_child->index = 1;right_left_child->parent = node;}
	node->type = (right_left_item_count-left_item_count);node->depth = max((left_depth+1), (right_left_depth+1));
	node->count = node->item->dataVec.count;node->count += left_count;node->count += right_left_count;
	node->item_count = 1;node->item_count += left_item_count;node->item_count += right_left_item_count;
	right_child->type = (right_right_item_count-node->item_count);right_child->depth = max((node->depth+1), (right_right_depth+1));
	right_child->count = right_child->item->dataVec.count;right_child->count += node->count;right_child->count += right_right_count;
	right_child->item_count = 1;right_child->item_count += node->item_count;right_child->item_count += right_right_item_count;
	return 1;	
}
int scapegoat_tree_node_rotate_one(scapegoat_tree_t *tree, scapegoat_tree_node_t *node)
{
	int index;scapegoat_tree_node_t *parent;scapegoat_tree_node_t *one_node;scapegoat_tree_node_t *one_left_child;scapegoat_tree_node_t *one_right_child;
	scapegoat_tree_node_t *left_child;scapegoat_tree_node_t *right_child;scapegoat_tree_node_t *left_left_child;scapegoat_tree_node_t *left_right_child;
	scapegoat_tree_node_t *right_left_child;scapegoat_tree_node_t *right_right_child;int left_item_count;int right_item_count;int left_left_item_count;
	int left_right_item_count;int right_left_item_count;int right_right_item_count;int one_left_depth;int one_right_depth;int one_left_count;
	int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(node->type == 0){return 0;}index = node->index;parent = node->parent;
	if(node->type < 0)
	{
		if(node->childArray[0] == NULL){return -1;}left_child = node->childArray[0];if(left_child->item == NULL){return -1;}
		if(left_child->type > 0)
		{
			if(left_child->childArray[1] == NULL){return -1;}left_right_child = left_child->childArray[1];if(left_right_child->item == NULL){return -1;}
			if(node->childArray[1] == NULL){right_item_count = 0;}else{right_item_count = node->childArray[1]->item_count;}
			left_right_item_count = left_right_child->item_count;
			if(right_item_count >= left_right_item_count){return 0;}
			scapegoat_tree_node_rotate_right_child(tree, left_child, left_right_child);
			one_left_child = node->childArray[0];one_right_child = node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			node->type = (one_right_item_count-one_left_item_count);node->depth = max((one_left_depth+1), (one_right_depth+1));
			node->count = node->item->dataVec.count;node->count += one_left_count;node->count += one_right_count;
			node->item_count = 1;node->item_count += one_left_item_count;node->item_count += one_right_item_count;
			scapegoat_tree_node_rotate_left_child(tree, node, one_left_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];scapegoat_tree_node_rotate_one(tree, one_left_child);
			one_right_child = one_node->childArray[1];scapegoat_tree_node_rotate_one(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_item_count-one_left_item_count);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			scapegoat_tree_node_rotate_one(tree, one_node);return 1;
		}
		else
		{
			left_left_child = left_child->childArray[0];
			if(node->childArray[1] == NULL){right_item_count = 0;}else{right_item_count = node->childArray[1]->item_count;}
			if(left_left_child == NULL){left_left_item_count = 0;}else{left_left_item_count = left_left_child->item_count;}
			if(right_item_count >= left_left_item_count){return 0;}
			scapegoat_tree_node_rotate_left_child(tree, node, left_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];scapegoat_tree_node_rotate_one(tree, one_left_child);
			one_right_child = one_node->childArray[1];scapegoat_tree_node_rotate_one(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_item_count-one_left_item_count);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			scapegoat_tree_node_rotate_one(tree, one_node);return 1;
		}
	}
	else if(node->type > 0)
	{
		if(node->childArray[1] == NULL){return -1;}right_child = node->childArray[1];if(right_child->item == NULL){return -1;}
		if(right_child->type < 0)
		{
			if(right_child->childArray[0] == NULL){return -1;}right_left_child = right_child->childArray[0];if(right_left_child->item == NULL){return -1;}
			if(node->childArray[0] == NULL){left_item_count = 0;}else{left_item_count = node->childArray[0]->item_count;}
			right_left_item_count = right_left_child->item_count;
			if(left_item_count >= right_left_item_count){return 0;}
			scapegoat_tree_node_rotate_left_child(tree, right_child, right_left_child);
			one_left_child = node->childArray[0];one_right_child = node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			node->type = (one_right_item_count-one_left_item_count);node->depth = max((one_left_depth+1), (one_right_depth+1));
			node->count = node->item->dataVec.count;node->count += one_left_count;node->count += one_right_count;
			node->item_count = 1;node->item_count += one_left_item_count;node->item_count += one_right_item_count;
			scapegoat_tree_node_rotate_right_child(tree, node, one_right_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];scapegoat_tree_node_rotate_one(tree, one_left_child);
			one_right_child = one_node->childArray[1];scapegoat_tree_node_rotate_one(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_item_count-one_left_item_count);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			scapegoat_tree_node_rotate_one(tree, one_node);return 1;
		}
		else
		{
			right_right_child = right_child->childArray[1];
			if(node->childArray[0] == NULL){left_item_count = 0;}else{left_item_count = node->childArray[0]->item_count;}
			if(right_right_child == NULL){right_right_item_count = 0;}else{right_right_item_count = right_right_child->item_count;}
			if(left_item_count >= right_right_item_count){return 0;}			
			scapegoat_tree_node_rotate_right_child(tree, node, right_child);
			if(parent == NULL){one_node = tree->root;}else{one_node = parent->childArray[index];}
			one_left_child = one_node->childArray[0];scapegoat_tree_node_rotate_one(tree, one_left_child);
			one_right_child = one_node->childArray[1];scapegoat_tree_node_rotate_one(tree, one_right_child);
			one_left_child = one_node->childArray[0];one_right_child = one_node->childArray[1];
			if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
			else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
			if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
			else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
			one_node->type = (one_right_item_count-one_left_item_count);one_node->depth = max((one_left_depth+1), (one_right_depth+1));
			one_node->count = one_node->item->dataVec.count;one_node->count += one_left_count;one_node->count += one_right_count;
			one_node->item_count = 1;one_node->item_count += one_left_item_count;one_node->item_count += one_right_item_count;
			scapegoat_tree_node_rotate_one(tree, one_node);return 1;
		}
	}
	return 0;
}
int scapegoat_tree_node_rotate_two(scapegoat_tree_t *tree, scapegoat_tree_node_t *node)
{
	scapegoat_tree_node_t *left_child;scapegoat_tree_node_t *right_child;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(node->type == 0){return 0;}
	if(node->type < 0)
	{
		if(node->childArray[0] == NULL){return -1;}left_child = node->childArray[0];if(left_child->item == NULL){return -1;}
		if(left_child->item_count < (node->item_count * tree->alpha)){return 0;}scapegoat_tree_node_rotate_one(tree, node);return 1;
	}
	else if(node->type > 0)
	{
		if(node->childArray[1] == NULL){return -1;}right_child = node->childArray[1];if(right_child->item == NULL){return -1;}
		if(right_child->item_count < (node->item_count * tree->alpha)){return 0;}scapegoat_tree_node_rotate_one(tree, node);return 1;
	}	
	return 0;
}
int scapegoat_tree_node_splay(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, scapegoat_tree_node_t *final_parent)
{
	int check_index;scapegoat_tree_node_t *check_parent;scapegoat_tree_node_t *check_node;scapegoat_tree_node_t *one_left_child;scapegoat_tree_node_t *one_right_child;
	int one_left_depth;int one_right_depth;int one_left_count;int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(node->parent == NULL){return 0;}if(node->parent == final_parent){return 0;}check_node = node;
	while(check_node != NULL && check_node->parent != NULL && check_node->parent != final_parent)
	{
		check_index = check_node->index;check_parent = check_node->parent;
		one_left_child = check_parent->childArray[0];one_right_child = check_parent->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_parent->type = (one_right_item_count-one_left_item_count);check_parent->depth = max((one_left_depth+1), (one_right_depth+1));
		check_parent->count = check_parent->item->dataVec.count;check_parent->count += one_left_count;check_parent->count += one_right_count;
		check_parent->item_count = 1;check_parent->item_count += one_left_item_count;check_parent->item_count += one_right_item_count;
		if(check_index == 0){scapegoat_tree_node_rotate_left_child(tree, check_parent, check_node);}else{scapegoat_tree_node_rotate_right_child(tree, check_parent, check_node);}
	}
	if(check_node->parent == NULL){return 1;}else{check_node = check_node->parent;}
	while(check_node != NULL)
	{
		check_parent = check_node->parent;
		one_left_child = check_node->childArray[0];one_right_child = check_node->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_node->type = (one_right_item_count-one_left_item_count);check_node->depth = max((one_left_depth+1), (one_right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += one_left_count;check_node->count += one_right_count;
		check_node->item_count = 1;check_node->item_count += one_left_item_count;check_node->item_count += one_right_item_count;
		check_node = check_parent;
	}
	return 1;
}
int scapegoat_tree_find_rank(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, int rank, scapegoat_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count)
{
	scapegoat_tree_node_t *left_child;int left_count;int left_item_count;scapegoat_tree_node_t *check_node;int check_count;int check_item_count;
	int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(rank < 1){return -1;}if(rank > tree->root->count){return -1;}*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;
	check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}if((rank-rank_count) > check_node->count){return -1;}left_child = check_node->childArray[0];
		if(left_child == NULL){left_count = 0;left_item_count = 0;}else{left_count = left_child->count;left_item_count = left_child->item_count;}
		check_count = (left_count+(check_node->item->dataVec.count));check_item_count = (left_item_count+1);
		if((rank-rank_count) > check_count)
		{
			rank_count += check_count;rank_item_count += check_item_count;
			if(check_node->childArray[1] == NULL){return 2;}else{check_node = check_node->childArray[1];}
		}
		else if((rank-rank_count) <= left_count)
		{
			if(check_node->childArray[0] == NULL){return 2;}else{check_node = check_node->childArray[0];}			
		}
		else
		{
			rank_count += check_count;rank_item_count += check_item_count;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}		
	}
	return 0;
}
int scapegoat_tree_find_base(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, byte_t *key, word_t key_len, scapegoat_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count, int *result_index)
{
	int one;scapegoat_tree_item_t *item;scapegoat_tree_node_t *check_node;int rank_count;int rank_item_count;scapegoat_tree_node_t *one_child;
	int one_count;int one_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;*result_index = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			if(check_node->childArray[1] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 1;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 0;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}
	}
	return 0;
}
int scapegoat_tree_find_max(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, scapegoat_tree_node_t **result_node)
{
	scapegoat_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[1] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[1];}
	}
	return 0;
}
int scapegoat_tree_find_min(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, scapegoat_tree_node_t **result_node)
{
	scapegoat_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[0] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[0];}
	}
	return 0;
}
int scapegoat_tree_find_first_upper_equal(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, byte_t *key, word_t key_len, scapegoat_tree_node_t **result_node)
{
	int one;scapegoat_tree_item_t *item;scapegoat_tree_node_t *check_node;scapegoat_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int scapegoat_tree_find_last_lower_equal(scapegoat_tree_t *tree, scapegoat_tree_node_t *node, byte_t *key, word_t key_len, scapegoat_tree_node_t **result_node)
{
	int one;scapegoat_tree_item_t *item;scapegoat_tree_node_t *check_node;scapegoat_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int scapegoat_tree_get_rank(scapegoat_tree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = scapegoat_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int scapegoat_tree_check_exist(scapegoat_tree_t *tree, byte_t *key, word_t key_len)
{
	scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = scapegoat_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}return 1;
}
int scapegoat_tree_get(scapegoat_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	scapegoat_tree_item_t *item;scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = scapegoat_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(item->dataVec), result_data_vec);}return 1;
}
int scapegoat_tree_splay(scapegoat_tree_t *tree, byte_t *key, word_t key_len)
{
	scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = scapegoat_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	scapegoat_tree_node_splay(tree, result_node, NULL);return 1;
}
int scapegoat_tree_insert(scapegoat_tree_t *tree, byte_t *key, word_t key_len, void *value)
{
	scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;scapegoat_tree_item_t *one_item;
	scapegoat_tree_node_t *one_node;scapegoat_tree_node_t *check_node;scapegoat_tree_node_t *check_parent;scapegoat_tree_node_t *left_child;scapegoat_tree_node_t *right_child;
	int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = scapegoat_tree_item_alloc();if(one_item == NULL){return 0;}
		one_node = scapegoat_tree_node_alloc();if(one_node == NULL){scapegoat_tree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
		one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;one_node->index = 0;one_node->parent = NULL;
		one_node->item = one_item;tree->root = one_node;return 1;
	}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = scapegoat_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->item;vector_add(&(one_item->dataVec), value);check_node = result_node;
		while(check_node != NULL){check_node->count++;check_node = check_node->parent;}return 1;		
	}
	one_item = scapegoat_tree_item_alloc();if(one_item == NULL){return 0;}
	one_node = scapegoat_tree_node_alloc();if(one_node == NULL){scapegoat_tree_item_free(one_item);return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);
	one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;
	one_node->index = result_index;one_node->parent = result_node;one_node->item = one_item;
	result_node->childArray[result_index] = one_node;check_node = result_node;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_item_count-left_item_count);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		scapegoat_tree_node_rotate_two(tree, check_node);
		check_node = check_parent;
	}
	return 1;
}
int scapegoat_tree_remove(scapegoat_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	scapegoat_tree_node_t *one_node;scapegoat_tree_item_t *one_item;int one_count;scapegoat_tree_node_t *one_child;int one_index;scapegoat_tree_node_t *one_parent;
	scapegoat_tree_node_t *replace_node;scapegoat_tree_item_t *replace_item;scapegoat_tree_node_t *check_node;scapegoat_tree_node_t *check_parent;
	scapegoat_tree_node_t *left_child;scapegoat_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = scapegoat_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	if(result_node->childArray[0] != NULL && result_node->childArray[1] != NULL)
	{
		one_node = result_node->childArray[0];replace_node = NULL;temp_result = scapegoat_tree_find_max(tree, one_node, &replace_node);
		if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(replace_node == NULL){return 0;}replace_item = replace_node->item;
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		one_count = ((replace_item->dataVec.count)-(one_item->dataVec.count));scapegoat_tree_item_free(one_item);
		result_node->item = replace_item;replace_node->item = NULL;check_node = result_node;
		while(check_node != NULL){check_node->count += one_count;check_node = check_node->parent;}result_node = replace_node;
	}
	else
	{
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		scapegoat_tree_item_free(one_item);result_node->item = NULL;
	}
	one_index = result_node->index;one_parent = result_node->parent;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] == NULL)
	{
		one_child = result_node->childArray[0];result_node->childArray[0] = NULL;scapegoat_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else if(result_node->childArray[0] == NULL && result_node->childArray[1] != NULL)
	{
		one_child = result_node->childArray[1];result_node->childArray[1] = NULL;scapegoat_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else
	{
		one_child = NULL;result_node->childArray[0] = NULL;result_node->childArray[1] = NULL;scapegoat_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;}else{one_parent->childArray[one_index] = one_child;}
	}
	if(one_parent == NULL){return 1;}check_node = one_parent;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_item_count-left_item_count);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		scapegoat_tree_node_rotate_two(tree, check_node);
		check_node = check_parent;
	}
	return 1;
}
int scapegoat_tree_inorder_get_all_item_other(scapegoat_tree_t *tree, vector_t *all_item_vec)
{
	scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;scapegoat_tree_node_t *check_node;
	scapegoat_tree_node_t *next_node;int temp_result;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = scapegoat_tree_find_rank(tree, tree->root, 1, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}next_node = NULL;
		temp_result = scapegoat_tree_inorder_get_next_item(tree, check_node, &next_node);if(next_node == NULL){return 1;}check_node = next_node;
	}
	return 1;
}
int scapegoat_tree_rank_min_max_remove(scapegoat_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;scapegoat_tree_node_t *one_node;vector_t one_node_vec;scapegoat_tree_node_t *min_node;scapegoat_tree_node_t *max_node;
	scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;scapegoat_tree_node_t *check_node;
	scapegoat_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = scapegoat_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = scapegoat_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	scapegoat_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
    }
    else
    {
    	one_count = (max_rank-min_rank+1);
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank));check_node = min_node;
    	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = scapegoat_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = scapegoat_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  	scapegoat_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (upper_min_rank-min_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));check_node = min_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	scapegoat_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  	scapegoat_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (max_rank-lower_max_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	vector_delete_min_max(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank));check_node = max_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
	vector_free(&one_node_vec);return 1;
}
int scapegoat_tree_rank_min_max_get(scapegoat_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;scapegoat_tree_node_t *one_node;vector_t one_node_vec;scapegoat_tree_node_t *min_node;scapegoat_tree_node_t *max_node;
	scapegoat_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;scapegoat_tree_node_t *check_node;
	scapegoat_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = scapegoat_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = scapegoat_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = scapegoat_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = scapegoat_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_node_vec);return 1;
}
int scapegoat_tree_min_max_remove(scapegoat_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;scapegoat_tree_node_t *one_node;vector_t one_node_vec;scapegoat_tree_node_t *min_node;scapegoat_tree_node_t *max_node;
	scapegoat_tree_node_t *result_node;scapegoat_tree_node_t *check_node;scapegoat_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = scapegoat_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = scapegoat_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    scapegoat_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = scapegoat_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = scapegoat_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  scapegoat_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	scapegoat_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  scapegoat_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
	vector_free(&one_node_vec);return 1;	
}
int scapegoat_tree_min_max_get(scapegoat_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;scapegoat_tree_node_t *one_node;vector_t one_node_vec;scapegoat_tree_node_t *min_node;scapegoat_tree_node_t *max_node;
	scapegoat_tree_node_t *result_node;scapegoat_tree_node_t *check_node;scapegoat_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = scapegoat_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = scapegoat_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = scapegoat_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = scapegoat_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
	vector_free(&one_node_vec);return 1;	
}
int scapegoat_tree_iterator_init(scapegoat_tree_t *tree, scapegoat_tree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return 0;}scapegoat_tree_node_get_all_item(tree->root, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
scapegoat_tree_iterator_t * scapegoat_tree_iterator_alloc(scapegoat_tree_t *tree)
{
	size_t size;scapegoat_tree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(scapegoat_tree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(scapegoat_tree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void scapegoat_tree_iterator_free(scapegoat_tree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int scapegoat_tree_iterator_next(scapegoat_tree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;		
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}	
}
void scapegoat_tree_item_dump(FILE *fd, scapegoat_tree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void scapegoat_tree_dump(FILE *fd, scapegoat_tree_t *tree)
{
	scapegoat_tree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = scapegoat_tree_iterator_alloc(tree);if(iterator == NULL){return ;}
	scapegoat_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(scapegoat_tree_iterator_next(iterator) == 1){scapegoat_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	scapegoat_tree_iterator_free(iterator);
}
void scapegoat_tree_dot_node_dump(FILE *fd, scapegoat_tree_node_t *node, int *nDump)
{
	int i;scapegoat_tree_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n%d:%d\\n",oneDump, node->type, node->depth, node->index, node->count, node->item_count);
	*nDump = (oneDump+1);
	if(node->item != NULL){fprintf(fd, "%s:%d\\n",((char *)(node->item->key)),node->item->dataVec.count);}
	fprintf(fd, "\"];\n");
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			scapegoat_tree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void scapegoat_tree_dot_dump(scapegoat_tree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("scapegoat_tree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph scapegoat_tree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");scapegoat_tree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;scapegoat_tree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = scapegoat_tree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    scapegoat_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	scapegoat_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    scapegoat_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	scapegoat_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	scapegoat_tree_splay(tree, (byte_t *)(arrKeyStr[27]), strlen(arrKeyStr[27]));
	for(i = 5; i < 8; ++i)
	{
	    scapegoat_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i]);
	}
	scapegoat_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	scapegoat_tree_splay(tree, (byte_t *)(arrKeyStr[27]), strlen(arrKeyStr[27]));
	for(i = 5; i < 8; ++i)
	{
	    scapegoat_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	scapegoat_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	scapegoat_tree_dot_dump(tree);
	scapegoat_tree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

cartesian_tree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

typedef uint8_t byte_t;
typedef size_t  word_t;

typedef struct {int count;int max;void **mem;} vector_t;
typedef struct {byte_t *key;word_t key_len;vector_t dataVec;uint64_t heap_val;} cartesian_tree_item_t;
typedef struct cartesian_tree_node {
	int type;int depth;int count;int item_count;int index;struct cartesian_tree_node *parent;cartesian_tree_item_t *item;struct cartesian_tree_node *childArray[2];
} cartesian_tree_node_t;
typedef struct {cartesian_tree_node_t *root;} cartesian_tree_t;
typedef struct {cartesian_tree_t *tree;int vec_index;vector_t all_item_vec;cartesian_tree_item_t *item;} cartesian_tree_iterator_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);vec->mem = NULL;}vector_init(vec);}
int vector_get(vector_t *vec, int index, void **item){if(index < 0 || index >= vec->count){return 0;}*item = vec->mem[index];return 1;}
int vector_set(vector_t *vec, int index, void *item){if(index < 0 || index >= vec->count){return 0;}vec->mem[index] = item;return 1;}
void vector_swap(vector_t *vec, int indexA, int indexB)
{
	void *itemA;void *itemB;vector_get(vec, indexA, &itemA);vector_get(vec, indexB, &itemB);vector_set(vec, indexA, itemB);vector_set(vec, indexB, itemA);
}
int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	temp = NULL;temp = realloc(vec->mem, (max*sizeof(void *)));if(temp == NULL){return 0;}
	vec->mem = temp;vec->max = max;return 1;
}
int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, (vec->count+1)) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
int vector_insert(vector_t *vec, int index, void *item)
{
	int i;if(index < 0 || index > vec->count){return 0;}
	if(vector_reserve(vec, (vec->count+1)) == 1)
	{
		if(index == vec->count){vec->mem[vec->count] = item;vec->count++;return 1;}
		else
		{
			for(i = vec->count;i > index;i--){vec->mem[i] = vec->mem[i-1];}vec->mem[index] = item;vec->count++;return 1;
		}
	}
	else{return 0;}	
}
int vector_delete(vector_t *vec, int index, void **item)
{
	int i;if(index < 0 || index >= vec->count){return 0;}if(item != NULL){*item = vec->mem[index];}
	if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
	vec->mem[vec->count-1] = NULL;vec->count--;return 1;
}
int vector_delete_min_max(vector_t *vec, int min_index, int max_index)
{
	int i;int j;int count;if(min_index < 0 || min_index >= vec->count){return 0;}if(max_index < 0 || max_index >= vec->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);
	if(max_index < (vec->count-1))
	{
		i = (max_index+1);j = min_index;while(i < vec->count){vec->mem[j] = vec->mem[i];i++;j++;}for(i = j;i < vec->count;i++){vec->mem[i] = NULL;}
	}
	else{for(i = min_index;i < vec->count;i++){vec->mem[i] = NULL;}}
	vec->count -= count;return 1;
}
int vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;return 1;
}
int vector_copy_vec_two(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return 0;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}
	b->count = a->count;return 1;	
}
int vector_copy_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = count;return 1;
}
int vector_copy_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);if(vector_reserve(b, count) == 0){return 0;}
	i = min_index;j = 0;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = count;return 1;	
}
int vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_two(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return 0;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
int vector_add_vec_min_max(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;return 1;
}
int vector_add_vec_min_max_two(vector_t *a, int min_index, int max_index, vector_t *b)
{
	int i;int j;int count;int one;if(min_index < 0 || min_index >= a->count){return 0;}if(max_index < 0 || max_index >= a->count){return 0;}
	if(min_index > max_index){return 0;}count = (max_index-min_index+1);one = (count+(b->count));if(vector_reserve(b, one) == 0){return 0;}
	i = min_index;j = b->count;while(i <= max_index){b->mem[j] = a->mem[i];i++;j++;}
	b->count = one;return 1;
}
void vector_set_vec(vector_t *a, vector_t *b){b->count = a->count;b->max = a->max;b->mem = a->mem;}
int compareItem_key(byte_t *item_key, word_t item_key_len, byte_t *key, word_t key_len)
{
	int result;
	if(item_key_len < key_len){result = memcmp(item_key, key, item_key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return -1;}}
	else if(item_key_len > key_len){result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 1;}}
	else{result = memcmp(item_key, key, key_len);if(result < 0){return -1;}else if(result > 0){return 1;}else{return 0;}}
}
int compareItem_heap(uint64_t item_heap_val, uint64_t heap_val)
{
	if(item_heap_val < heap_val){return -1;}else if(item_heap_val > heap_val){return 1;}else{return 0;}
}
int cartesian_tree_item_init(cartesian_tree_item_t *item){item->key = NULL;item->key_len = 0;vector_init(&(item->dataVec));item->heap_val = 0;return 1;}
cartesian_tree_item_t * cartesian_tree_item_alloc()
{
  size_t size;cartesian_tree_item_t *item;size = sizeof(cartesian_tree_item_t);item = NULL;item = malloc(size);if(item == NULL){return NULL;}
  cartesian_tree_item_init(item);return item;
}
int cartesian_tree_item_other_free(cartesian_tree_item_t *item){vector_free(&(item->dataVec));cartesian_tree_item_init(item);return 1;}
void cartesian_tree_item_free(cartesian_tree_item_t *item){if(item != NULL){cartesian_tree_item_other_free(item);free(item);}}
int cartesian_tree_node_init(cartesian_tree_node_t *node)
{
	node->type = 0;node->depth = 0;node->count = 0;node->item_count = 0;node->index = 0;node->parent = NULL;
	node->item = NULL;node->childArray[0] = NULL;node->childArray[1] = NULL;return 1;
}
cartesian_tree_node_t * cartesian_tree_node_alloc()
{
	size_t size;cartesian_tree_node_t *node;size = sizeof(cartesian_tree_node_t);node = NULL;node = malloc(size);if(node == NULL){return NULL;}
	cartesian_tree_node_init(node);return node;
}
int cartesian_tree_node_other_free(cartesian_tree_node_t *node)
{
	if(node->item != NULL){cartesian_tree_item_free(node->item);node->item = NULL;}cartesian_tree_node_init(node);return 1;
}
void cartesian_tree_node_free(cartesian_tree_node_t *node)
{
	if(node != NULL){cartesian_tree_node_other_free(node);free(node);}
}
void cartesian_tree_node_destroy(cartesian_tree_node_t **node)
{
	cartesian_tree_node_t **cartesian_tree_node;cartesian_tree_node_t *one_node;if(node == NULL || *node == NULL){return ;}one_node = (*node);
	if(one_node->childArray[0] != NULL){cartesian_tree_node = &(one_node->childArray[0]);cartesian_tree_node_destroy(cartesian_tree_node);one_node->childArray[0] = NULL;}
	if(one_node->childArray[1] != NULL){cartesian_tree_node = &(one_node->childArray[1]);cartesian_tree_node_destroy(cartesian_tree_node);one_node->childArray[1] = NULL;}
	cartesian_tree_node_free((*node));*node = NULL;
}
void cartesian_tree_node_get_all_item(cartesian_tree_node_t *node, vector_t *all_item_vec)
{
	if(node == NULL){return ;}
	if(node->childArray[0] != NULL){cartesian_tree_node_get_all_item(node->childArray[0], all_item_vec);}
	if(node->item != NULL){vector_add(all_item_vec, node->item);}
	if(node->childArray[1] != NULL){cartesian_tree_node_get_all_item(node->childArray[1], all_item_vec);}
}
int cartesian_tree_preorder_get_all_item(cartesian_tree_t *tree, vector_t *all_item_vec)
{
	cartesian_tree_node_t *last_node;cartesian_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;
	if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else{if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int cartesian_tree_inorder_get_next_item(cartesian_tree_t *tree, cartesian_tree_node_t *node, cartesian_tree_node_t **result_node)
{
	cartesian_tree_node_t *last_node;cartesian_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
	else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}			
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){*result_node = check_node;return 1;}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int cartesian_tree_inorder_get_all_item(cartesian_tree_t *tree, vector_t *all_item_vec)
{
	cartesian_tree_node_t *last_node;cartesian_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}else{return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}}
			}
			else
			{
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
int cartesian_tree_postorder_get_all_item(cartesian_tree_t *tree, vector_t *all_item_vec)
{
	cartesian_tree_node_t *last_node;cartesian_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}check_node = tree->root;	
	if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
	else
	{
		if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
		else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}return 1;}
	}
	while(last_node != NULL && check_node != NULL)
	{
		if(last_node == check_node->parent)
		{
			if(check_node->childArray[0] != NULL){last_node = check_node;check_node = check_node->childArray[0];}
			else
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else{if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}last_node = check_node;check_node = check_node->parent;}
			}
		}
		else
		{
			if(last_node == check_node->childArray[0])
			{
				if(check_node->childArray[1] != NULL){last_node = check_node;check_node = check_node->childArray[1];}
				else
				{
					if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
					if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
				}
			}
			else
			{
				if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}
				if(check_node->parent == NULL){return 1;}else{last_node = check_node;check_node = check_node->parent;}
			}
		}
	}
	return 1;
}
cartesian_tree_t * cartesian_tree_alloc()
{
	size_t size;cartesian_tree_t *tree;size = sizeof(cartesian_tree_t);tree = NULL;tree = malloc(size);if(tree == NULL){return NULL;}
	tree->root = NULL;return tree;
}
void cartesian_tree_destroy(cartesian_tree_t *tree)
{
	cartesian_tree_node_t **cartesian_tree_node;if(tree == NULL){return ;}if(tree->root == NULL){free(tree);return ;}
	cartesian_tree_node = &(tree->root);cartesian_tree_node_destroy(cartesian_tree_node);tree->root = NULL;free(tree);
}
int cartesian_tree_node_rotate_left_child(cartesian_tree_t *tree, cartesian_tree_node_t *node, cartesian_tree_node_t *left_child)
{
	int index;cartesian_tree_node_t *parent;cartesian_tree_node_t *right_child;cartesian_tree_node_t *left_left_child;cartesian_tree_node_t *left_right_child;
	int right_depth;int left_left_depth;int left_right_depth;int right_count;int left_left_count;int left_right_count;
	int right_item_count;int left_left_item_count;int left_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(left_child == NULL){return -1;}if(node->childArray[0] != left_child){return -1;}
	if(node->item == NULL){return -1;}if(left_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	right_child = node->childArray[1];left_left_child = left_child->childArray[0];left_right_child = left_child->childArray[1];
	if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
	else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
	if(left_left_child == NULL){left_left_depth = -1;left_left_count = 0;left_left_item_count = 0;}
	else{left_left_depth = left_left_child->depth;left_left_count = left_left_child->count;left_left_item_count = left_left_child->item_count;}
	if(left_right_child == NULL){left_right_depth = -1;left_right_count = 0;left_right_item_count = 0;}
	else{left_right_depth = left_right_child->depth;left_right_count = left_right_child->count;left_right_item_count = left_right_child->item_count;}
	if(parent == NULL){tree->root = left_child;left_child->index = 0;left_child->parent = NULL;}
	else{parent->childArray[index] = left_child;left_child->index = index;left_child->parent = parent;}
	left_child->childArray[1] = node;node->index = 1;node->parent = left_child;
	node->childArray[0] = left_right_child;if(left_right_child != NULL){left_right_child->index = 0;left_right_child->parent = node;}
	node->type = (right_depth-left_right_depth);node->depth = max((left_right_depth+1), (right_depth+1));
	node->count = node->item->dataVec.count;node->count += left_right_count;node->count += right_count;
	node->item_count = 1;node->item_count += left_right_item_count;node->item_count += right_item_count;
	left_child->type = (node->depth-left_left_depth);left_child->depth = max((left_left_depth+1), (node->depth+1));
	left_child->count = left_child->item->dataVec.count;left_child->count += left_left_count;left_child->count += node->count;
	left_child->item_count = 1;left_child->item_count += left_left_item_count;left_child->item_count += node->item_count;
	return 1;
}
int cartesian_tree_node_rotate_right_child(cartesian_tree_t *tree, cartesian_tree_node_t *node, cartesian_tree_node_t *right_child)
{
	int index;cartesian_tree_node_t *parent;cartesian_tree_node_t *left_child;cartesian_tree_node_t *right_left_child;cartesian_tree_node_t *right_right_child;
	int left_depth;int right_left_depth;int right_right_depth;int left_count;int right_left_count;int right_right_count;
	int left_item_count;int right_left_item_count;int right_right_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(right_child == NULL){return -1;}if(node->childArray[1] != right_child){return -1;}
	if(node->item == NULL){return -1;}if(right_child->item == NULL){return -1;}index = node->index;parent = node->parent;
	left_child = node->childArray[0];right_left_child = right_child->childArray[0];right_right_child = right_child->childArray[1];
	if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
	else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
	if(right_left_child == NULL){right_left_depth = -1;right_left_count = 0;right_left_item_count = 0;}
	else{right_left_depth = right_left_child->depth;right_left_count = right_left_child->count;right_left_item_count = right_left_child->item_count;}
	if(right_right_child == NULL){right_right_depth = -1;right_right_count = 0;right_right_item_count = 0;}
	else{right_right_depth = right_right_child->depth;right_right_count = right_right_child->count;right_right_item_count = right_right_child->item_count;}
	if(parent == NULL){tree->root = right_child;right_child->index = 0;right_child->parent = NULL;}
	else{parent->childArray[index] = right_child;right_child->index = index;right_child->parent = parent;}
	right_child->childArray[0] = node;node->index = 0;node->parent = right_child;
	node->childArray[1] = right_left_child;if(right_left_child != NULL){right_left_child->index = 1;right_left_child->parent = node;}
	node->type = (right_left_depth-left_depth);node->depth = max((left_depth+1), (right_left_depth+1));
	node->count = node->item->dataVec.count;node->count += left_count;node->count += right_left_count;
	node->item_count = 1;node->item_count += left_item_count;node->item_count += right_left_item_count;
	right_child->type = (right_right_depth-node->depth);right_child->depth = max((node->depth+1), (right_right_depth+1));
	right_child->count = right_child->item->dataVec.count;right_child->count += node->count;right_child->count += right_right_count;
	right_child->item_count = 1;right_child->item_count += node->item_count;right_child->item_count += right_right_item_count;
	return 1;	
}
int cartesian_tree_node_rotate_up(cartesian_tree_t *tree, cartesian_tree_node_t *node)
{
	int check_index;cartesian_tree_node_t *check_parent;cartesian_tree_node_t *check_node;cartesian_tree_node_t *one_left_child;cartesian_tree_node_t *one_right_child;
	int one_left_depth;int one_right_depth;int one_left_count;int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(node->parent == NULL){return 0;}if(compareItem_heap(node->parent->item->heap_val, node->item->heap_val) >= 0){return 0;}check_node = node;
	while(check_node != NULL && check_node->parent != NULL && compareItem_heap(check_node->parent->item->heap_val, check_node->item->heap_val) < 0)
	{
		check_index = check_node->index;check_parent = check_node->parent;
		one_left_child = check_parent->childArray[0];one_right_child = check_parent->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_parent->type = (one_right_depth-one_left_depth);check_parent->depth = max((one_left_depth+1), (one_right_depth+1));
		check_parent->count = check_parent->item->dataVec.count;check_parent->count += one_left_count;check_parent->count += one_right_count;
		check_parent->item_count = 1;check_parent->item_count += one_left_item_count;check_parent->item_count += one_right_item_count;
		if(check_index == 0){cartesian_tree_node_rotate_left_child(tree, check_parent, check_node);}else{cartesian_tree_node_rotate_right_child(tree, check_parent, check_node);}
	}
	if(check_node->parent == NULL){return 1;}else{check_node = check_node->parent;}
	while(check_node != NULL)
	{
		check_parent = check_node->parent;
		one_left_child = check_node->childArray[0];one_right_child = check_node->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_node->type = (one_right_depth-one_left_depth);check_node->depth = max((one_left_depth+1), (one_right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += one_left_count;check_node->count += one_right_count;
		check_node->item_count = 1;check_node->item_count += one_left_item_count;check_node->item_count += one_right_item_count;
		check_node = check_parent;
	}
	return 1;
}
int cartesian_tree_node_rotate_down(cartesian_tree_t *tree, cartesian_tree_node_t *node)
{
	cartesian_tree_node_t *check_parent;cartesian_tree_node_t *check_node;cartesian_tree_node_t *left_child;cartesian_tree_node_t *right_child;cartesian_tree_node_t *one_left_child;
	cartesian_tree_node_t *one_right_child;int one_left_depth;int one_right_depth;int one_left_count;int one_right_count;int one_left_item_count;int one_right_item_count;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}check_node = node;
	while(check_node != NULL)
	{
		left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child != NULL && right_child != NULL)
		{
			if(compareItem_heap(left_child->item->heap_val, right_child->item->heap_val) >= 0)
			{
				if(compareItem_heap(check_node->item->heap_val, left_child->item->heap_val) >= 0){break;}
				else{cartesian_tree_node_rotate_left_child(tree, check_node, left_child);}
			}
			else
			{
				if(compareItem_heap(check_node->item->heap_val, right_child->item->heap_val) >= 0){break;}
				else{cartesian_tree_node_rotate_right_child(tree, check_node, right_child);}
			}
		}
		else if(left_child != NULL && right_child == NULL)
		{
			if(compareItem_heap(check_node->item->heap_val, left_child->item->heap_val) >= 0){break;}
			else{cartesian_tree_node_rotate_left_child(tree, check_node, left_child);}
		}
		else if(left_child == NULL && right_child != NULL)
		{
			if(compareItem_heap(check_node->item->heap_val, right_child->item->heap_val) >= 0){break;}
			else{cartesian_tree_node_rotate_right_child(tree, check_node, right_child);}
		}
		else{break;}
	}
	while(check_node != NULL)
	{
		check_parent = check_node->parent;
		one_left_child = check_node->childArray[0];one_right_child = check_node->childArray[1];
		if(one_left_child == NULL){one_left_depth = -1;one_left_count = 0;one_left_item_count = 0;}
		else{one_left_depth = one_left_child->depth;one_left_count = one_left_child->count;one_left_item_count = one_left_child->item_count;}
		if(one_right_child == NULL){one_right_depth = -1;one_right_count = 0;one_right_item_count = 0;}
		else{one_right_depth = one_right_child->depth;one_right_count = one_right_child->count;one_right_item_count = one_right_child->item_count;}
		check_node->type = (one_right_depth-one_left_depth);check_node->depth = max((one_left_depth+1), (one_right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += one_left_count;check_node->count += one_right_count;
		check_node->item_count = 1;check_node->item_count += one_left_item_count;check_node->item_count += one_right_item_count;
		check_node = check_parent;
	}
	return 1;	
}
int cartesian_tree_find_rank(cartesian_tree_t *tree, cartesian_tree_node_t *node, int rank, cartesian_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count)
{
	cartesian_tree_node_t *left_child;int left_count;int left_item_count;cartesian_tree_node_t *check_node;int check_count;int check_item_count;
	int rank_count;int rank_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}if(node->item == NULL){return -1;}
	if(rank < 1){return -1;}if(rank > tree->root->count){return -1;}*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;
	check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}if((rank-rank_count) > check_node->count){return -1;}left_child = check_node->childArray[0];
		if(left_child == NULL){left_count = 0;left_item_count = 0;}else{left_count = left_child->count;left_item_count = left_child->item_count;}
		check_count = (left_count+(check_node->item->dataVec.count));check_item_count = (left_item_count+1);
		if((rank-rank_count) > check_count)
		{
			rank_count += check_count;rank_item_count += check_item_count;
			if(check_node->childArray[1] == NULL){return 2;}else{check_node = check_node->childArray[1];}
		}
		else if((rank-rank_count) <= left_count)
		{
			if(check_node->childArray[0] == NULL){return 2;}else{check_node = check_node->childArray[0];}			
		}
		else
		{
			rank_count += check_count;rank_item_count += check_item_count;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}		
	}
	return 0;
}
int cartesian_tree_find_base(cartesian_tree_t *tree, cartesian_tree_node_t *node, byte_t *key, word_t key_len, cartesian_tree_node_t **result_node, int *result_rank_count, int *result_rank_item_count, int *result_index)
{
	int one;cartesian_tree_item_t *item;cartesian_tree_node_t *check_node;int rank_count;int rank_item_count;cartesian_tree_node_t *one_child;
	int one_count;int one_item_count;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;*result_rank_count = 0;*result_rank_item_count = 0;*result_index = 0;check_node = node;rank_count = 0;rank_item_count = 0;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem_key(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			if(check_node->childArray[1] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 1;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;*result_index = 0;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			one_child = check_node->childArray[0];if(one_child == NULL){one_count = 0;one_item_count = 0;}else{one_count = one_child->count;one_item_count = one_child->item_count;}
			rank_count += one_count;rank_item_count += one_item_count;rank_count += item->dataVec.count;rank_item_count += 1;
			*result_node = check_node;*result_rank_count = rank_count;*result_rank_item_count = rank_item_count;return 1;
		}
	}
	return 0;
}
int cartesian_tree_find_max(cartesian_tree_t *tree, cartesian_tree_node_t *node, cartesian_tree_node_t **result_node)
{
	cartesian_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[1] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[1];}
	}
	return 0;
}
int cartesian_tree_find_min(cartesian_tree_t *tree, cartesian_tree_node_t *node, cartesian_tree_node_t **result_node)
{
	cartesian_tree_node_t *check_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(node == NULL){return -1;}
	if(node->item == NULL){return -1;}*result_node = NULL;check_node = node;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}
		if(check_node->childArray[0] == NULL){*result_node = check_node;return 1;}else{check_node = check_node->childArray[0];}
	}
	return 0;
}
int cartesian_tree_find_first_upper_equal(cartesian_tree_t *tree, cartesian_tree_node_t *node, byte_t *key, word_t key_len, cartesian_tree_node_t **result_node)
{
	int one;cartesian_tree_item_t *item;cartesian_tree_node_t *check_node;cartesian_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem_key(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int cartesian_tree_find_last_lower_equal(cartesian_tree_t *tree, cartesian_tree_node_t *node, byte_t *key, word_t key_len, cartesian_tree_node_t **result_node)
{
	int one;cartesian_tree_item_t *item;cartesian_tree_node_t *check_node;cartesian_tree_node_t *one_node;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(node == NULL){return -1;}if(node->item == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	*result_node = NULL;check_node = node;one_node = NULL;
	while(check_node != NULL)
	{
		if(check_node->item == NULL){return -1;}item = check_node->item;one = compareItem_key(item->key, item->key_len, key, key_len);
		if(one < 0)
		{
			if(check_node->childArray[1] == NULL)
			{
				one_node = check_node;*result_node = one_node;return 2;
			}
			else{one_node = check_node;check_node = check_node->childArray[1];}
		}
		else if(one > 0)
		{
			if(check_node->childArray[0] == NULL)
			{
				*result_node = one_node;return 2;
			}
			else{check_node = check_node->childArray[0];}
		}
		else
		{
			*result_node = check_node;return 1;
		}
	}
	return 0;
}
int cartesian_tree_get_rank(cartesian_tree_t *tree, byte_t *key, word_t key_len, int *result_rank)
{
	cartesian_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = cartesian_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}*result_rank = result_rank_count;return 1;
}
int cartesian_tree_check_exist(cartesian_tree_t *tree, byte_t *key, word_t key_len)
{
	cartesian_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = cartesian_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}return 1;
}
int cartesian_tree_get(cartesian_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	cartesian_tree_item_t *item;cartesian_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = cartesian_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(item->dataVec), result_data_vec);}return 1;
}
int cartesian_tree_insert(cartesian_tree_t *tree, byte_t *key, word_t key_len, void *value, uint64_t heap_val)
{
	cartesian_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;cartesian_tree_item_t *one_item;
	cartesian_tree_node_t *one_node;uint64_t one_heap_val;cartesian_tree_node_t *check_node;cartesian_tree_node_t *check_parent;cartesian_tree_node_t *up_node;
	cartesian_tree_node_t *left_child;cartesian_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(tree == NULL){return -1;}if(key == NULL){return -1;}if(key_len <= 0){return -1;}if(value == NULL){return -1;}
	if(tree->root == NULL)
	{
		one_item = cartesian_tree_item_alloc();if(one_item == NULL){return 0;}
		one_node = cartesian_tree_node_alloc();if(one_node == NULL){cartesian_tree_item_free(one_item);return 0;}
		one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);one_item->heap_val = heap_val;
		one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;
		one_node->index = 0;one_node->parent = NULL;one_node->item = one_item;tree->root = one_node;return 1;
	}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = cartesian_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(result_node == NULL){return 0;}
	if(temp_result == 1)
	{
		one_item = result_node->item;one_heap_val = one_item->heap_val;vector_add(&(one_item->dataVec), value);one_item->heap_val = heap_val;
		check_node = result_node;while(check_node != NULL){check_node->count++;check_node = check_node->parent;}
		if(heap_val > one_heap_val){cartesian_tree_node_rotate_up(tree, result_node);return 1;}
		else if(heap_val < one_heap_val){cartesian_tree_node_rotate_down(tree, result_node);return 1;}
		else{return 1;}
	}
	one_item = cartesian_tree_item_alloc();if(one_item == NULL){return 0;}
	one_node = cartesian_tree_node_alloc();if(one_node == NULL){cartesian_tree_item_free(one_item);return 0;}
	one_item->key = key;one_item->key_len = key_len;vector_add(&(one_item->dataVec), value);one_item->heap_val = heap_val;
	one_node->type = 0;one_node->depth = 0;one_node->count = 1;one_node->item_count = 1;
	one_node->index = result_index;one_node->parent = result_node;one_node->item = one_item;up_node = one_node;
	result_node->childArray[result_index] = one_node;check_node = result_node;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_depth-left_depth);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		check_node = check_parent;
	}
	cartesian_tree_node_rotate_up(tree, up_node);
	return 1;
}
int cartesian_tree_remove(cartesian_tree_t *tree, byte_t *key, word_t key_len, vector_t *result_data_vec)
{
	cartesian_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;int result_index;int temp_result;
	cartesian_tree_node_t *one_node;cartesian_tree_item_t *one_item;int one_count;cartesian_tree_node_t *one_child;int one_index;cartesian_tree_node_t *one_parent;
	cartesian_tree_node_t *replace_node;cartesian_tree_item_t *replace_item;cartesian_tree_node_t *check_node;cartesian_tree_node_t *check_parent;
	cartesian_tree_node_t *up_node;cartesian_tree_node_t *down_node;
	cartesian_tree_node_t *left_child;cartesian_tree_node_t *right_child;int left_depth;int right_depth;int left_count;int right_count;int left_item_count;int right_item_count;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}if(key == NULL){return -1;}
	if(key_len <= 0){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;result_index = 0;
	temp_result = cartesian_tree_find_base(tree, tree->root, key, key_len, &result_node, &result_rank_count, &result_rank_item_count, &result_index);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}up_node = NULL;down_node = NULL;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] != NULL)
	{
		one_node = result_node->childArray[0];replace_node = NULL;temp_result = cartesian_tree_find_max(tree, one_node, &replace_node);
		if(temp_result == -1){return -1;}if(temp_result == 0){return 0;}if(replace_node == NULL){return 0;}replace_item = replace_node->item;
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		if(replace_item->heap_val < one_item->heap_val){down_node = result_node;}
		else if(replace_item->heap_val > one_item->heap_val){up_node = result_node;}
		one_count = ((replace_item->dataVec.count)-(one_item->dataVec.count));cartesian_tree_item_free(one_item);
		result_node->item = replace_item;replace_node->item = NULL;check_node = result_node;
		while(check_node != NULL){check_node->count += one_count;check_node = check_node->parent;}result_node = replace_node;
	}
	else
	{
		one_item = result_node->item;if(result_data_vec != NULL){vector_copy_vec(&(one_item->dataVec), result_data_vec);}
		cartesian_tree_item_free(one_item);result_node->item = NULL;
	}
	one_index = result_node->index;one_parent = result_node->parent;
	if(result_node->childArray[0] != NULL && result_node->childArray[1] == NULL)
	{
		one_child = result_node->childArray[0];result_node->childArray[0] = NULL;cartesian_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else if(result_node->childArray[0] == NULL && result_node->childArray[1] != NULL)
	{
		one_child = result_node->childArray[1];result_node->childArray[1] = NULL;cartesian_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;one_child->index = 0;one_child->parent = NULL;}
		else{one_parent->childArray[one_index] = one_child;one_child->index = one_index;one_child->parent = one_parent;}
	}
	else
	{
		one_child = NULL;result_node->childArray[0] = NULL;result_node->childArray[1] = NULL;cartesian_tree_node_free(result_node);
		if(one_parent == NULL){tree->root = one_child;}else{one_parent->childArray[one_index] = one_child;}
	}
	if(one_parent == NULL){return 1;}check_node = one_parent;
	while(check_node != NULL)
	{
		check_parent = check_node->parent;left_child = check_node->childArray[0];right_child = check_node->childArray[1];
		if(left_child == NULL){left_depth = -1;left_count = 0;left_item_count = 0;}
		else{left_depth = left_child->depth;left_count = left_child->count;left_item_count = left_child->item_count;}
		if(right_child == NULL){right_depth = -1;right_count = 0;right_item_count = 0;}
		else{right_depth = right_child->depth;right_count = right_child->count;right_item_count = right_child->item_count;}
		check_node->type = (right_depth-left_depth);check_node->depth = max((left_depth+1), (right_depth+1));
		check_node->count = check_node->item->dataVec.count;check_node->count += left_count;check_node->count += right_count;
		check_node->item_count = 1;check_node->item_count += left_item_count;check_node->item_count += right_item_count;
		check_node = check_parent;
	}
	if(down_node != NULL){cartesian_tree_node_rotate_down(tree, down_node);}
	else if(up_node != NULL){cartesian_tree_node_rotate_up(tree, up_node);}
	return 1;
}
int cartesian_tree_inorder_get_all_item_other(cartesian_tree_t *tree, vector_t *all_item_vec)
{
	cartesian_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;cartesian_tree_node_t *check_node;
	cartesian_tree_node_t *next_node;int temp_result;if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = cartesian_tree_find_rank(tree, tree->root, 1, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}check_node = result_node;
	while(check_node != NULL)
	{
		if(check_node->item != NULL){vector_add(all_item_vec, check_node->item);}next_node = NULL;
		temp_result = cartesian_tree_inorder_get_next_item(tree, check_node, &next_node);if(next_node == NULL){return 1;}check_node = next_node;
	}
	return 1;
}
int cartesian_tree_rank_min_max_remove(cartesian_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;cartesian_tree_node_t *one_node;vector_t one_node_vec;cartesian_tree_node_t *min_node;cartesian_tree_node_t *max_node;
	cartesian_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;cartesian_tree_node_t *check_node;
	cartesian_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = cartesian_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = cartesian_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	cartesian_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
    }
    else
    {
    	one_count = (max_rank-min_rank+1);
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank));check_node = min_node;
    	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = cartesian_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = cartesian_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  	cartesian_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (upper_min_rank-min_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  	vector_delete_min_max(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank));check_node = min_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	cartesian_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  	cartesian_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
  }
  else
  {
  	one_count = (max_rank-lower_max_rank+1);
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  	vector_delete_min_max(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank));check_node = max_node;
  	while(check_node != NULL){check_node->count -= one_count;check_node = check_node->parent;}
  }
	vector_free(&one_node_vec);return 1;
}
int cartesian_tree_rank_min_max_get(cartesian_tree_t *tree, int min_rank, int max_rank, vector_t *result_data_vec)
{
	int i;cartesian_tree_node_t *one_node;vector_t one_node_vec;cartesian_tree_node_t *min_node;cartesian_tree_node_t *max_node;
	cartesian_tree_node_t *result_node;int result_rank_count;int result_rank_item_count;cartesian_tree_node_t *check_node;
	cartesian_tree_node_t *next_node;int temp_result;int one_count;int lower_min_rank;int upper_min_rank;int lower_max_rank;int upper_max_rank;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_rank < 1){return -1;}if(min_rank > tree->root->count){return -1;}if(max_rank < 1){return -1;}
	if(max_rank > tree->root->count){return -1;}if(min_rank > max_rank){return -1;}
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = cartesian_tree_find_rank(tree, tree->root, min_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	min_node = result_node;one_count = min_node->item->dataVec.count;upper_min_rank = result_rank_count;lower_min_rank = (upper_min_rank-(one_count-1));
	result_node = NULL;result_rank_count = 0;result_rank_item_count = 0;
	temp_result = cartesian_tree_find_rank(tree, tree->root, max_rank, &result_node, &result_rank_count, &result_rank_item_count);
	if(temp_result == -1){return -1;}if(temp_result != 1){return 0;}if(result_node == NULL){return 0;}
	max_node = result_node;one_count = max_node->item->dataVec.count;upper_max_rank = result_rank_count;lower_max_rank = (upper_max_rank-(one_count-1));
	if(min_node == max_node)
	{
    if(min_rank == lower_min_rank && max_rank == upper_min_rank)
    {
    	if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    	return 1;
    }
    else
    {
    	if(result_data_vec != NULL){vector_copy_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (max_rank-lower_min_rank), result_data_vec);}
    	return 1;
    }
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = cartesian_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = cartesian_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(min_rank == lower_min_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(min_node->item->dataVec), (min_rank-lower_min_rank), (upper_min_rank-lower_min_rank), result_data_vec);}
  }
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(max_rank == upper_max_rank)
  {
  	if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  }
  else
  {
  	if(result_data_vec != NULL){vector_add_vec_min_max_two(&(max_node->item->dataVec), 0, (max_rank-lower_max_rank), result_data_vec);}
  }
	vector_free(&one_node_vec);return 1;
}
int cartesian_tree_min_max_remove(cartesian_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;cartesian_tree_node_t *one_node;vector_t one_node_vec;cartesian_tree_node_t *min_node;cartesian_tree_node_t *max_node;
	cartesian_tree_node_t *result_node;cartesian_tree_node_t *check_node;cartesian_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem_key(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = cartesian_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = cartesian_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    cartesian_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = cartesian_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = cartesian_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  cartesian_tree_remove(tree, min_node->item->key, min_node->item->key_len, NULL);
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  	cartesian_tree_remove(tree, one_node->item->key, one_node->item->key_len, NULL);
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
  cartesian_tree_remove(tree, max_node->item->key, max_node->item->key_len, NULL);
	vector_free(&one_node_vec);return 1;	
}
int cartesian_tree_min_max_get(cartesian_tree_t *tree, byte_t *min_key, word_t min_key_len, byte_t *max_key, word_t max_key_len, vector_t *result_data_vec)
{
	int i;cartesian_tree_node_t *one_node;vector_t one_node_vec;cartesian_tree_node_t *min_node;cartesian_tree_node_t *max_node;
	cartesian_tree_node_t *result_node;cartesian_tree_node_t *check_node;cartesian_tree_node_t *next_node;int temp_result;
	if(result_data_vec != NULL){vector_free(result_data_vec);}if(tree == NULL){return -1;}if(tree->root == NULL){return -1;}
	if(tree->root->item == NULL){return -1;}if(min_key == NULL){return -1;}if(min_key_len <= 0){return -1;}if(max_key == NULL){return -1;}
	if(max_key_len <= 0){return -1;}if(compareItem_key(min_key, min_key_len, max_key, max_key_len) > 0){return -1;}
	result_node = NULL;temp_result = cartesian_tree_find_first_upper_equal(tree, tree->root, min_key, min_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}min_node = result_node;
	result_node = NULL;temp_result = cartesian_tree_find_last_lower_equal(tree, tree->root, max_key, max_key_len, &result_node);
	if(temp_result == -1){return -1;}if(result_node == NULL){return 0;}max_node = result_node;
	if(min_node == max_node)
	{
    if(result_data_vec != NULL){vector_copy_vec_two(&(min_node->item->dataVec), result_data_vec);}
    return 1;
	}
	vector_init(&one_node_vec);next_node = NULL;temp_result = cartesian_tree_inorder_get_next_item(tree, min_node, &next_node);
	if(next_node == NULL){return 0;}check_node = next_node;
	while(check_node != NULL && check_node != max_node)
	{
		vector_add(&one_node_vec, check_node);next_node = NULL;temp_result = cartesian_tree_inorder_get_next_item(tree, check_node, &next_node);
		if(next_node == NULL){vector_free(&one_node_vec);return 0;}check_node = next_node;
	}
  if(result_data_vec != NULL){vector_add_vec_two(&(min_node->item->dataVec), result_data_vec);}
  for (i = 0;i < one_node_vec.count;i++)
  {
  	one_node = one_node_vec.mem[i];
  	if(result_data_vec != NULL){vector_add_vec_two(&(one_node->item->dataVec), result_data_vec);}
  }
  if(result_data_vec != NULL){vector_add_vec_two(&(max_node->item->dataVec), result_data_vec);}
	vector_free(&one_node_vec);return 1;	
}
int cartesian_tree_iterator_init(cartesian_tree_t *tree, cartesian_tree_iterator_t *iterator)
{
	vector_t oneVec;vector_init(&oneVec);if(tree == NULL){return 0;}if(tree->root == NULL){return 0;}if(iterator == NULL){return 0;}
	if(vector_reserve(&oneVec, tree->root->item_count) == 0){return 0;}cartesian_tree_node_get_all_item(tree->root, &oneVec);
	if(oneVec.count <= 0){vector_free(&oneVec);return 0;}iterator->tree = tree;iterator->vec_index = 0;vector_set_vec(&oneVec, &(iterator->all_item_vec));
	iterator->item = iterator->all_item_vec.mem[0];vector_init(&oneVec);return 1;
}
cartesian_tree_iterator_t * cartesian_tree_iterator_alloc(cartesian_tree_t *tree)
{
	size_t size;cartesian_tree_iterator_t *iterator;if(tree == NULL){return NULL;}if(tree->root == NULL){return NULL;}
	size = sizeof(cartesian_tree_iterator_t);iterator = NULL;iterator = malloc(size);if(iterator == NULL){return NULL;}
	if(cartesian_tree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}return iterator;
}
void cartesian_tree_iterator_free(cartesian_tree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->all_item_vec));free(iterator);}
}
int cartesian_tree_iterator_next(cartesian_tree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->all_item_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->item = iterator->all_item_vec.mem[vec_index];return 1;
	}
	return 0;
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}	
}
void cartesian_tree_item_dump(FILE *fd, cartesian_tree_item_t *item){writeData(fd, item->key, &(item->dataVec));}
void cartesian_tree_dump(FILE *fd, cartesian_tree_t *tree)
{
	cartesian_tree_iterator_t *iterator;if(tree == NULL){return ;}if(tree->root == NULL){return ;}
	iterator = cartesian_tree_iterator_alloc(tree);if(iterator == NULL){return ;}
	cartesian_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");
	while(cartesian_tree_iterator_next(iterator) == 1){cartesian_tree_item_dump(fd, iterator->item);fprintf(fd, "\n");}
	cartesian_tree_iterator_free(iterator);
}
void cartesian_tree_dot_node_dump(FILE *fd, cartesian_tree_node_t *node, int *nDump)
{
	int i;cartesian_tree_node_t *one_node;int oneDump;int twoDump;if(node == NULL){return ;}
	oneDump = (*nDump);fprintf(fd, "%d [label=\"%d:%d:%d\\n%d:%d\\n%I64x\\n",oneDump, node->type, node->depth, node->index, node->count, node->item_count, node->item->heap_val);
	*nDump = (oneDump+1);
	if(node->item != NULL){fprintf(fd, "%s:%d\\n",((char *)(node->item->key)),node->item->dataVec.count);}
	fprintf(fd, "\"];\n");
	for(i = 0;i <= 1;i++)
	{
		one_node = node->childArray[i];
		if(one_node != NULL)
		{
			twoDump = (*nDump);
			fprintf(fd, "%d -> %d [label=\"child[%d]\", color=\"blue\"];\n", oneDump, twoDump, i);
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", twoDump, oneDump);
			cartesian_tree_dot_node_dump(fd, one_node, nDump);
		}
	}
}
//dot -Tpng -o tree.png tree.dot
void cartesian_tree_dot_dump(cartesian_tree_t *tree)
{
	FILE *one_fd;int nDump;if(tree == NULL){return ;}if(tree->root == NULL){return ;}one_fd =fopen("cartesian_tree.dot", "w");nDump = 0;
	fprintf(one_fd, "digraph cartesian_tree {\n");fprintf(one_fd, "node [shape=box, fontname=\"Arial\"];\n");cartesian_tree_dot_node_dump(one_fd, tree->root, &nDump);
	fprintf(one_fd, "}\n");fflush(one_fd);fclose(one_fd);
}
FILE *fd;
int n;
char arrKeyStr[128][128];
char arrValStr[128][128];

void build()
{
	int i;cartesian_tree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 32;
	memcpy(arrKeyStr[0],"1111",4) ;memcpy(arrValStr[0],"11",2);
	memcpy(arrKeyStr[1],"2222",4) ;memcpy(arrValStr[1],"22",2);
	memcpy(arrKeyStr[2],"3333",4) ;memcpy(arrValStr[2],"33",2);
	memcpy(arrKeyStr[3],"4444",4) ;memcpy(arrValStr[3],"44",2);
	memcpy(arrKeyStr[4],"5555",4) ;memcpy(arrValStr[4],"55",2);
	memcpy(arrKeyStr[5],"6666",4) ;memcpy(arrValStr[5],"66",2);
	memcpy(arrKeyStr[6],"7777",4) ;memcpy(arrValStr[6],"77",2);
	memcpy(arrKeyStr[7],"8888",4) ;memcpy(arrValStr[7],"88",2);
	memcpy(arrKeyStr[8],"9999",4) ;memcpy(arrValStr[8],"99",2);
	memcpy(arrKeyStr[9],"aaaa",4) ;memcpy(arrValStr[9],"aa",2);
	memcpy(arrKeyStr[10],"bbbb",4);memcpy(arrValStr[10],"bb",2);
	memcpy(arrKeyStr[11],"cccc",4);memcpy(arrValStr[11],"cc",2);
	memcpy(arrKeyStr[12],"dddd",4);memcpy(arrValStr[12],"dd",2);
	memcpy(arrKeyStr[13],"eeee",4);memcpy(arrValStr[13],"ee",2);
	memcpy(arrKeyStr[14],"ffff",4);memcpy(arrValStr[14],"ff",2);
	memcpy(arrKeyStr[15],"gggg",4);memcpy(arrValStr[15],"gg",2);
	memcpy(arrKeyStr[16],"hhhh",4) ;memcpy(arrValStr[16],"hh",2);
	memcpy(arrKeyStr[17],"iiii",4) ;memcpy(arrValStr[17],"ii",2);
	memcpy(arrKeyStr[18],"jjjj",4) ;memcpy(arrValStr[18],"jj",2);
	memcpy(arrKeyStr[19],"kkkk",4) ;memcpy(arrValStr[19],"kk",2);
	memcpy(arrKeyStr[20],"llll",4) ;memcpy(arrValStr[20],"ll",2);
	memcpy(arrKeyStr[21],"mmmm",4) ;memcpy(arrValStr[21],"mm",2);
	memcpy(arrKeyStr[22],"nnnn",4) ;memcpy(arrValStr[22],"nn",2);
	memcpy(arrKeyStr[23],"oooo",4) ;memcpy(arrValStr[23],"oo",2);
	memcpy(arrKeyStr[24],"pppp",4) ;memcpy(arrValStr[24],"pp",2);
	memcpy(arrKeyStr[25],"qqqq",4) ;memcpy(arrValStr[25],"qq",2);
	memcpy(arrKeyStr[26],"rrrr",4);memcpy(arrValStr[26],"rr",2);
	memcpy(arrKeyStr[27],"ssss",4);memcpy(arrValStr[27],"ss",2);
	memcpy(arrKeyStr[28],"tttt",4);memcpy(arrValStr[28],"tt",2);
	memcpy(arrKeyStr[29],"uuuu",4);memcpy(arrValStr[29],"uu",2);
	memcpy(arrKeyStr[30],"vvvv",4);memcpy(arrValStr[30],"vv",2);
	memcpy(arrKeyStr[31],"wwww",4);memcpy(arrValStr[31],"ww",2);
	tree = cartesian_tree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    cartesian_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i], ((((uint32_t)rand()) << 15) | ((uint32_t)rand())));
	}
	cartesian_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    cartesian_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	cartesian_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    cartesian_tree_insert(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), arrValStr[i], ((((uint32_t)rand()) << 15) | ((uint32_t)rand())));
	}
	cartesian_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    cartesian_tree_remove(tree, (byte_t *)(arrKeyStr[i]), strlen(arrKeyStr[i]), NULL);
	}
	cartesian_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	cartesian_tree_dot_dump(tree);
	cartesian_tree_destroy(tree);
}

int main()
{
	build();
	return 0;
}


trie_tree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

FILE *fd;
int n;
char arrKeyStr[64][128];
char arrValStr[64][128];

typedef struct {int count;int max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
void vector_delete(vector_t *vec, int index, void **item)
{
	int i;
	if(index >= 0 && index < vec->count)
	{
		if(item != NULL){*item = vec->mem[index];}if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
		vec->mem[vec->count-1] = NULL;vec->count--;
	}
}
void vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return ;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;
}
void vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return ;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;
}

typedef struct trie_tree_node {
	uint8_t key_byte;int key_count;int val_count;struct trie_tree_node *parent;int depth;vector_t arrayVec;void *key;uint32_t key_len;vector_t dataVec;
} trie_tree_node_t;
typedef struct {int count;int trie_node_count;int remove_trie_node_count;vector_t rootVec;} trie_tree_t;

int trie_tree_vector_get_index(vector_t *vec, uint8_t key_byte)
{
	trie_tree_node_t *node;int i;int index;index = -1;
	for(i = 0;i < vec->count;i++){node = vec->mem[i];if(node != NULL && node->key_byte == key_byte){index = i;break;}}
	return index;
}
trie_tree_node_t * trie_tree_node_alloc()
{
  trie_tree_node_t *node;node = NULL;node = (trie_tree_node_t *)malloc(sizeof(trie_tree_node_t));if(node == NULL){return NULL;}
  if (node != NULL)
  {
  	node->key_byte = 0;node->key_count = 0;node->val_count = 0;node->parent = NULL;node->depth = 0;node->key = NULL;node->key_len = 0;
  	vector_init(&(node->arrayVec));vector_init(&(node->dataVec));
  }
  return node;
}
void trie_tree_node_free(trie_tree_node_t *node){if(node != NULL){vector_free(&(node->arrayVec));vector_free(&(node->dataVec));free(node);}}
void trie_tree_node_destroy(trie_tree_node_t **node)
{
  trie_tree_node_t **trie_node;int i;if(node == NULL || *node == NULL){return ;}
  for(i = 0;i < (*node)->arrayVec.count;i++)
  {
  	if((*node)->arrayVec.mem[i] != NULL)
  	{
  		trie_node = (trie_tree_node_t **)(&((*node)->arrayVec.mem[i]));trie_tree_node_destroy(trie_node);(*node)->arrayVec.mem[i] = NULL;
  	}
  }
  trie_tree_node_free((*node));*node = NULL;
}
void trie_tree_vector_delete_node(trie_tree_t *tree, trie_tree_node_t *node)
{
  trie_tree_node_t **trie_node;trie_tree_node_t *parent;int index;if(tree == NULL){return ;}if(node == NULL){return ;}
  if(node->key_count > 0 || node->val_count > 0){return ;}parent = node->parent;index = -1;
  if(parent == NULL)
  {
  	index = trie_tree_vector_get_index(&(tree->rootVec), node->key_byte);if(index == -1){return ;}
  	trie_node = (trie_tree_node_t **)(&(tree->rootVec.mem[index]));trie_tree_node_destroy(trie_node);tree->rootVec.mem[index] = NULL;
  	vector_delete(&(tree->rootVec), index, NULL);
  }
  else
  {
  	index = trie_tree_vector_get_index(&(parent->arrayVec), node->key_byte);if(index == -1){return ;}
  	trie_node = (trie_tree_node_t **)(&(parent->arrayVec.mem[index]));trie_tree_node_destroy(trie_node);parent->arrayVec.mem[index] = NULL;
  	vector_delete(&(parent->arrayVec), index, NULL);  	
  }
}
trie_tree_t * trie_tree_alloc()
{
  trie_tree_t *tree;tree = NULL;tree = (trie_tree_t *)malloc(sizeof(trie_tree_t));if(tree == NULL){return NULL;}
  if (tree != NULL){tree->count = 0;tree->trie_node_count = 0;tree->remove_trie_node_count = 0;vector_init(&(tree->rootVec));}
  return tree;
}
void trie_tree_destroy(trie_tree_t *tree)
{
  trie_tree_node_t **trie_node;int i;if(tree == NULL){return ;}
  for(i = 0;i < tree->rootVec.count;i++)
  {
  	if(tree->rootVec.mem[i] != NULL)
  	{
  		trie_node = (trie_tree_node_t **)(&(tree->rootVec.mem[i]));trie_tree_node_destroy(trie_node);tree->rootVec.mem[i] = NULL;
  	}
  }
  vector_free(&(tree->rootVec));free(tree);
}
int trie_tree_find_base(trie_tree_t *tree, void *key, size_t key_len, trie_tree_node_t **result_trie_node)
{
	int depth;int index;trie_tree_node_t *trie_node;uint8_t *key_byte_array;*result_trie_node = NULL;
	if(tree == NULL){return 0;}if(key == NULL){return 0;}if(key_len <= 0){return 0;}key_byte_array = (uint8_t *)(key);
	index = trie_tree_vector_get_index(&(tree->rootVec), key_byte_array[0]);if(index == -1){return 0;}if(tree->rootVec.mem[index] == NULL){return 0;}
	trie_node = (tree->rootVec.mem[index]);if(key_len == 1){*result_trie_node = trie_node;return 1;}depth = 1;	
	while(depth < key_len && trie_node != NULL)
	{
		index = trie_tree_vector_get_index(&(trie_node->arrayVec), key_byte_array[depth]);if(index == -1){*result_trie_node = trie_node;return 0;}
		if(trie_node->arrayVec.mem[index] == NULL){*result_trie_node = trie_node;return 0;}trie_node = (trie_node->arrayVec.mem[index]);depth++;
	}
	if(depth == key_len && trie_node != NULL){*result_trie_node = trie_node;return 1;}else{*result_trie_node = trie_node;return 0;}
}
int trie_tree_check_base(trie_tree_t *tree, void *key, size_t key_len, trie_tree_node_t **result_trie_node)
{
	int depth;int index;trie_tree_node_t *trie_node;uint8_t *key_byte_array;*result_trie_node = NULL;
	if(tree == NULL){return 0;}if(key == NULL){return 0;}if(key_len <= 0){return 0;}key_byte_array = (uint8_t *)(key);
	index = trie_tree_vector_get_index(&(tree->rootVec), key_byte_array[0]);if(index == -1){return 0;}trie_node = (tree->rootVec.mem[index]);
	if(trie_node == NULL){return 0;}if(trie_node->key_count <= 0){return 0;}if(key_len == 1){*result_trie_node = trie_node;return 1;}depth = 1;
	while(depth < key_len && trie_node != NULL && trie_node->key_count > 0)
	{
		index = trie_tree_vector_get_index(&(trie_node->arrayVec), key_byte_array[depth]);if(index == -1){return 0;}
		trie_node = (trie_node->arrayVec.mem[index]);if(trie_node == NULL){return 0;}if(trie_node->key_count <= 0){return 0;}depth++;
	}
	if(depth == key_len && trie_node != NULL && trie_node->key_count > 0){*result_trie_node = trie_node;return 1;}else{return 0;}
}
int trie_tree_check_exist(trie_tree_t *tree, void *key, size_t key_len, trie_tree_node_t **result_trie_node)
{
	trie_tree_node_t *trie_node;*result_trie_node = NULL;trie_node = NULL;
	if(trie_tree_check_base(tree, key, key_len, &trie_node) == 1)
	{
		if(trie_node != NULL && trie_node->key_count > 0 && trie_node->dataVec.count > 0){*result_trie_node = trie_node;return 1;}
	}
	return 0;
}
void trie_tree_vector_get_all_prefix(trie_tree_node_t *node, vector_t *vec)
{
	int i;trie_tree_node_t *trie_node;if(node == NULL){return ;}if(node->key_count <= 0){return ;}if(node->dataVec.count > 0){vector_add(vec, node);}
	for(i = 0;i < node->arrayVec.count;i++)
	{
		trie_node = node->arrayVec.mem[i];if(trie_node != NULL && trie_node->key_count > 0){trie_tree_vector_get_all_prefix(trie_node, vec);}
	}
}
void trie_tree_vector_get_all_remove(trie_tree_node_t *node, vector_t *vec)
{
	int i;trie_tree_node_t *trie_node;if(node == NULL){return ;}
	if(node != NULL && node->key_count <= 0 && node->val_count <= 0){vector_add(vec, node);return ;}
	for(i = 0;i < node->arrayVec.count;i++)
	{
		trie_node = node->arrayVec.mem[i];
		if(trie_node != NULL && trie_node->key_count <= 0 && trie_node->val_count <= 0){vector_add(vec, trie_node);}
		else if(trie_node != NULL && trie_node->key_count > 0 && trie_node->val_count > 0){trie_tree_vector_get_all_remove(trie_node, vec);}
	}
}
int trie_tree_check_prefix(trie_tree_t *tree, void *key, size_t key_len, trie_tree_node_t **result_trie_node, vector_t *vec)
{
	trie_tree_node_t *trie_node;*result_trie_node = NULL;trie_node = NULL;if(vec != NULL){vector_free(vec);}
	if(trie_tree_check_base(tree, key, key_len, &trie_node) == 1)
	{
		if(trie_node != NULL && trie_node->key_count > 0)
		{
			if(vec != NULL){*result_trie_node = trie_node;trie_tree_vector_get_all_prefix(trie_node, vec);return 1;}
			else{*result_trie_node = trie_node;return 1;}			
		}
	}
	return 0;	
}
int trie_tree_delete_all_remove(trie_tree_t *tree)
{
	int i;trie_tree_node_t *trie_node;trie_tree_node_t *remove_trie_node;vector_t remove_trie_node_vec;
	if(tree == NULL){return 0;}if(tree->trie_node_count < 1024){return 0;}if(tree->remove_trie_node_count < ((tree->trie_node_count*4)/5)){return 0;}
	vector_init(&remove_trie_node_vec);vector_reserve(&remove_trie_node_vec, tree->trie_node_count);
	for(i = 0;i < tree->rootVec.count;i++)
	{
  	if(tree->rootVec.mem[i] != NULL){trie_node = (tree->rootVec.mem[i]);trie_tree_vector_get_all_remove(trie_node, &remove_trie_node_vec);}		
	}
	if(remove_trie_node_vec.count <= 0){vector_free(&remove_trie_node_vec);return 0;}
	for(i = 0;i < remove_trie_node_vec.count;i++)
	{
		remove_trie_node = (remove_trie_node_vec.mem[i]);if(remove_trie_node != NULL){trie_tree_vector_delete_node(tree, remove_trie_node);}
	}
	tree->trie_node_count -= tree->remove_trie_node_count;tree->remove_trie_node_count = 0;vector_free(&remove_trie_node_vec);return 1;
}
int trie_tree_get(trie_tree_t *tree, void *key, size_t key_len, trie_tree_node_t **result_trie_node, vector_t *vec)
{
	trie_tree_node_t *trie_node;trie_node = NULL;if(result_trie_node != NULL){*result_trie_node = NULL;}if(vec != NULL){vector_free(vec);}
	if(tree == NULL){return 0;}if(key == NULL){return 0;}if(key_len <= 0){return 0;}
  if(trie_tree_check_exist(tree, key, key_len, &trie_node) == 1)
  {
  	if(trie_node != NULL)
  	{
  		if(vec != NULL){vector_copy_vec(&(trie_node->dataVec), vec);}if(result_trie_node != NULL){*result_trie_node = trie_node;}return 1;
  	}
  }
  return 0;
}
int trie_tree_get_prefix(trie_tree_t *tree, void *key, size_t key_len, trie_tree_node_t **result_trie_node, vector_t *vec)
{
	int i;trie_tree_node_t *trie_node;vector_t trie_node_vec;trie_node = NULL;vector_init(&trie_node_vec);
	if(result_trie_node != NULL){*result_trie_node = NULL;}if(vec != NULL){vector_free(vec);}
	if(tree == NULL){return 0;}if(key == NULL){return 0;}if(key_len <= 0){return 0;}
  if(trie_tree_check_prefix(tree, key, key_len, &trie_node, &trie_node_vec) == 1)
  {
  	if(trie_node != NULL && trie_node_vec.count > 0)
  	{
  		if(result_trie_node != NULL){*result_trie_node = trie_node;}
  		for(i = 0;i < trie_node_vec.count;i++)
  		{
  			trie_node = (trie_node_vec.mem[i]);if(trie_node != NULL){if(vec != NULL){vector_add_vec(&(trie_node->dataVec), vec);}}
  		}
  		vector_free(&trie_node_vec);return 1;
  	}
  }
  vector_free(&trie_node_vec);return 0;
}
int trie_tree_insert(trie_tree_t *tree, void *key, size_t key_len, void *value)
{
	uint8_t *key_byte_array;int i;int j;vector_t one_trie_node_vec;int depth;trie_tree_node_t *parent_trie_node;trie_tree_node_t *one_trie_node;
	trie_tree_node_t *trie_node;trie_node = NULL;if(tree == NULL){return 0;}if(key == NULL){return 0;}if(key_len <= 0){return 0;}if(value == NULL){return 0;}
  if(trie_tree_find_base(tree, key, key_len, &trie_node) == 1)
  {
  	if(trie_node->dataVec.count > 0)
  	{
  		vector_add(&(trie_node->dataVec), value);while(trie_node != NULL){trie_node->val_count++;trie_node = (trie_node->parent);}
  	}
  	else
  	{
  		trie_node->key = key;trie_node->key_len = key_len;vector_add(&(trie_node->dataVec), value);
  		while(trie_node != NULL)
  		{
  			if(trie_node->key_count <= 0 && trie_node->val_count <= 0){tree->remove_trie_node_count--;}
  			trie_node->key_count++;trie_node->val_count++;trie_node = (trie_node->parent);
  		}
  	}
  	tree->count++;return 1;
  }
  if(trie_node == NULL)
  {
  	depth = 0;vector_init(&one_trie_node_vec);vector_reserve(&one_trie_node_vec, key_len);
  	while(depth < key_len)
  	{
  		one_trie_node = trie_tree_node_alloc();if(one_trie_node == NULL){break;}vector_add(&one_trie_node_vec, one_trie_node);depth++;
  	}
  	if(depth < key_len)
  	{
  		for(i = 0;i < one_trie_node_vec.count;i++)
  		{
  			one_trie_node = one_trie_node_vec.mem[i];if(one_trie_node != NULL){trie_tree_node_free(one_trie_node);}
  		}
  		vector_free(&one_trie_node_vec);return 0;
  	}
  	key_byte_array = (uint8_t *)(key);j = 0;depth = 0;parent_trie_node = NULL;
  	while(depth < key_len)
  	{
  		one_trie_node = one_trie_node_vec.mem[j];
  		if(one_trie_node != NULL)
  		{
  			one_trie_node->key_byte = key_byte_array[depth];one_trie_node->key_count = 1;one_trie_node->val_count = 1;
  			if(depth == 0){one_trie_node->parent = NULL;one_trie_node->depth = 0;}else{one_trie_node->parent = parent_trie_node;one_trie_node->depth = depth;}
  			if(depth < (key_len-1)){one_trie_node->key = NULL;one_trie_node->key_len = 0;}
  			else{one_trie_node->key = key;one_trie_node->key_len = key_len;vector_add(&(one_trie_node->dataVec), value);}
  			if(depth == 0){vector_add(&(tree->rootVec), one_trie_node);}else{vector_add(&(parent_trie_node->arrayVec), one_trie_node);}
  			parent_trie_node = one_trie_node;
  		}
  		j++;depth++;
  	}
  	tree->count++;tree->trie_node_count += one_trie_node_vec.count;vector_free(&one_trie_node_vec);return 1;
  }
  else
  {
  	depth = (trie_node->depth+1);vector_init(&one_trie_node_vec);vector_reserve(&one_trie_node_vec, key_len);
  	while(depth < key_len)
  	{
  		one_trie_node = trie_tree_node_alloc();if(one_trie_node == NULL){break;}vector_add(&one_trie_node_vec, one_trie_node);depth++;
  	}
  	if(depth < key_len)
  	{
  		for(i = 0;i < one_trie_node_vec.count;i++)
  		{
  			one_trie_node = one_trie_node_vec.mem[i];if(one_trie_node != NULL){trie_tree_node_free(one_trie_node);}
  		}
  		vector_free(&one_trie_node_vec);return 0;
  	}  	
  	key_byte_array = (uint8_t *)(key);j = 0;depth = (trie_node->depth+1);parent_trie_node = trie_node;
  	while(depth < key_len)
  	{
  		one_trie_node = one_trie_node_vec.mem[j];
  		if(one_trie_node != NULL)
  		{
  			one_trie_node->key_byte = key_byte_array[depth];one_trie_node->key_count = 1;one_trie_node->val_count = 1;
  			one_trie_node->parent = parent_trie_node;one_trie_node->depth = depth;
  			if(depth < (key_len-1)){one_trie_node->key = NULL;one_trie_node->key_len = 0;}
  			else{one_trie_node->key = key;one_trie_node->key_len = key_len;vector_add(&(one_trie_node->dataVec), value);}
  			vector_add(&(parent_trie_node->arrayVec), one_trie_node);
  			parent_trie_node = one_trie_node;
  		}
  		j++;depth++;
  	}
  	one_trie_node = trie_node;
  	while(one_trie_node != NULL)
  	{
  		if(one_trie_node->key_count <= 0 && one_trie_node->val_count <= 0){tree->remove_trie_node_count--;}
  		one_trie_node->key_count++;one_trie_node->val_count++;one_trie_node = (one_trie_node->parent);
  	}  	
  	tree->count++;tree->trie_node_count += one_trie_node_vec.count;vector_free(&one_trie_node_vec);return 1;
  }
  return 1;
}
int trie_tree_remove(trie_tree_t *tree, void *key, size_t key_len, vector_t *vec)
{
  trie_tree_node_t *one_trie_node;trie_tree_node_t *trie_node;trie_node = NULL;if(vec != NULL){vector_free(vec);}
  if(tree == NULL){return 0;}if(key == NULL){return 0;}if(key_len <= 0){return 0;}  
  if(trie_tree_check_exist(tree, key, key_len, &trie_node) == 1)
  {
  	if(trie_node != NULL && trie_node->key_count > 0 && trie_node->dataVec.count > 0)
  	{
  		if(vec != NULL){vector_copy_vec(&(trie_node->dataVec), vec);}
  		one_trie_node = trie_node;
  		while(one_trie_node != NULL)
  		{
  			one_trie_node->key_count--;one_trie_node->val_count -= (trie_node->dataVec.count);
  			if(one_trie_node->key_count <= 0 && one_trie_node->val_count <= 0){tree->remove_trie_node_count++;}
  			one_trie_node = (one_trie_node->parent);
  		}
  		tree->count -= (trie_node->dataVec.count);trie_node->key = NULL;trie_node->key_len = 0;vector_free(&(trie_node->dataVec));
  		trie_tree_delete_all_remove(tree);return 1;
  	}  	
  }
  return 0;
}
int trie_tree_remove_prefix(trie_tree_t *tree, void *key, size_t key_len, vector_t *vec)
{
  int i;vector_t one_trie_node_vec;trie_tree_node_t *one_trie_node;trie_tree_node_t *trie_node;trie_node = NULL;if(vec != NULL){vector_free(vec);}
  if(tree == NULL){return 0;}if(key == NULL){return 0;}if(key_len <= 0){return 0;}vector_init(&one_trie_node_vec);  
  if(trie_tree_check_prefix(tree, key, key_len, &trie_node, &one_trie_node_vec) == 1)
  {
  	if(trie_node != NULL && trie_node->key_count > 0 && one_trie_node_vec.count > 0)
  	{
  		for(i = 0;i < one_trie_node_vec.count;i++)
  		{
  			one_trie_node = one_trie_node_vec.mem[i];
  			if(one_trie_node != NULL && one_trie_node->dataVec.count > 0){if(vec != NULL){vector_add_vec(&(one_trie_node->dataVec), vec);}}
  		}
  		for(i = 0;i < one_trie_node_vec.count;i++)
  		{
  			one_trie_node = one_trie_node_vec.mem[i];
  			if(one_trie_node != NULL && one_trie_node->dataVec.count > 0){trie_tree_remove(tree, one_trie_node->key, one_trie_node->key_len, NULL);}  			
  		}  		
  		vector_free(&one_trie_node_vec);return 1;  		
  	}
  }
  vector_free(&one_trie_node_vec);return 0;
}
typedef struct {trie_tree_t *tree;int vec_index;vector_t trie_node_vec;trie_tree_node_t *trie_node;} trie_tree_iterator_t;

int trie_tree_iterator_init(trie_tree_t *tree, trie_tree_iterator_t *iterator)
{
  int i;trie_tree_node_t *trie_node;if(tree == NULL){return 0;}if(iterator == NULL){return 0;}vector_init(&(iterator->trie_node_vec));
	for(i = 0;i < tree->rootVec.count;i++)
	{
  	if(tree->rootVec.mem[i] != NULL){trie_node = (tree->rootVec.mem[i]);trie_tree_vector_get_all_prefix(trie_node, &(iterator->trie_node_vec));}		
	}
	if(iterator->trie_node_vec.count <= 0){vector_free(&(iterator->trie_node_vec));return 0;}
	iterator->tree = tree;iterator->vec_index = 0;iterator->trie_node = iterator->trie_node_vec.mem[0];return 1;
}
trie_tree_iterator_t * trie_tree_iterator_alloc(trie_tree_t *tree)
{
	trie_tree_iterator_t *iterator;if(tree == NULL){return NULL;}iterator = NULL;iterator = malloc(sizeof(trie_tree_iterator_t));
	if(iterator != NULL){if(trie_tree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}else{return iterator;}}
	return iterator;
}
void trie_tree_iterator_free(trie_tree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->trie_node_vec));free(iterator);}
}
int trie_tree_iterator_next(trie_tree_iterator_t *iterator)
{
	int vec_index;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->trie_node_vec.count-1))
	{
		vec_index++;iterator->vec_index = vec_index;iterator->trie_node = iterator->trie_node_vec.mem[vec_index];return 1;
	}
	return 0;
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}
	fprintf(fd, "\n");
}
void trie_tree_node_dump(FILE *fd, trie_tree_node_t *node){writeData(fd, node->key, &(node->dataVec));}
void trie_tree_dump(FILE *fd, trie_tree_t *tree)
{
	trie_tree_iterator_t *iterator;if(tree == NULL){return ;}iterator = trie_tree_iterator_alloc(tree);if(iterator == NULL){return ;}
	trie_tree_node_dump(fd, iterator->trie_node);while(trie_tree_iterator_next(iterator) == 1){trie_tree_node_dump(fd, iterator->trie_node);}
	trie_tree_iterator_free(iterator);
}

void build()
{
	int i;trie_tree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 16;
	strcpy(arrKeyStr[0],"1100") ;strcpy(arrValStr[0],"0");
	strcpy(arrKeyStr[1],"1200") ;strcpy(arrValStr[1],"1");
	strcpy(arrKeyStr[2],"1300") ;strcpy(arrValStr[2],"2");
	strcpy(arrKeyStr[3],"1400") ;strcpy(arrValStr[3],"3");
	strcpy(arrKeyStr[4],"1500") ;strcpy(arrValStr[4],"4");
	strcpy(arrKeyStr[5],"1600") ;strcpy(arrValStr[5],"5");
	strcpy(arrKeyStr[6],"1100") ;strcpy(arrValStr[6],"6");
	strcpy(arrKeyStr[7],"1200") ;strcpy(arrValStr[7],"7");
	strcpy(arrKeyStr[8],"1300") ;strcpy(arrValStr[8],"8");
	strcpy(arrKeyStr[9],"1400") ;strcpy(arrValStr[9],"9");
	strcpy(arrKeyStr[10],"1500");strcpy(arrValStr[10],"10");
	strcpy(arrKeyStr[11],"1600");strcpy(arrValStr[11],"11");
	strcpy(arrKeyStr[12],"1100");strcpy(arrValStr[12],"12");
	strcpy(arrKeyStr[13],"1200");strcpy(arrValStr[13],"13");
	strcpy(arrKeyStr[14],"1700");strcpy(arrValStr[14],"14");
	strcpy(arrKeyStr[15],"1800");strcpy(arrValStr[15],"15");
	tree = trie_tree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    trie_tree_insert(tree, arrKeyStr[i], strlen(arrKeyStr[i]), arrValStr[i]);
	}
	trie_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    trie_tree_remove(tree, arrKeyStr[i], strlen(arrKeyStr[i]), NULL);
	}
	trie_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	trie_tree_destroy(tree);
}

int main()
{
	build();
	return 0;
}

radix_tree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <ctype.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

#define min(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one < inner_two ? inner_one : inner_two;})
#define max(x, y) ({typeof(x) inner_one = (x);typeof(y) inner_two = (y);(void)(&inner_one == &inner_two);inner_one > inner_two ? inner_one : inner_two;})

FILE *fd;
int n;
char arrKeyStr[64][128];
char arrValStr[64][128];

typedef struct {int count;int max;void **mem;} vector_t;

void vector_init(vector_t *vec){vec->count = 0;vec->max = 0;vec->mem = NULL;}
void vector_free(vector_t *vec){if(vec->mem != NULL){free(vec->mem);}vector_init(vec);}
void vector_get(vector_t *vec, int index, void **item){if(index >= 0 && index < vec->count){*item = vec->mem[index];}}

int vector_reserve(vector_t *vec, int size)
{
	int max;void *temp;max = 0;
	if(size <= vec->max){return 1;}
	else if(vec->max == 0 && size > 0){max = 4;if(size > 4){do{max *= 2;}while(size > max);}}
	else if(vec->max > 0 && size > vec->max){max = vec->max;do{max *= 2;}while(size > max);}
	if(max > 0)
	{
		temp = NULL;temp = realloc(vec->mem, max * sizeof(void *));
		if(temp != NULL){vec->mem = temp;vec->max = max;return 1;}else{return 0;}
	}
	else {return 1;}
}

int vector_add(vector_t *vec, void *item)
{
	if(vector_reserve(vec, vec->count + 1) == 1){vec->mem[vec->count] = item;vec->count++;return 1;}else{return 0;}
}
void vector_delete(vector_t *vec, int index, void **item)
{
	int i;
	if(index >= 0 && index < vec->count)
	{
		if(item != NULL){*item = vec->mem[index];}if(index < vec->count-1){for(i = index; i < vec->count-1; i++){vec->mem[i] = vec->mem[i+1];}}
		vec->mem[vec->count-1] = NULL;vec->count--;
	}
}
void vector_copy_vec(vector_t *a, vector_t *b)
{
	int i;if(vector_reserve(b, a->count) == 0){return ;}
	for(i = 0; i < a->count; i++){b->mem[i] = a->mem[i];}for(i = a->count; i < b->max; i++){b->mem[i] = NULL;}
	b->count = a->count;
}
void vector_add_vec(vector_t *a, vector_t *b)
{
	int i;int j;int one;one = (a->count+b->count);if(vector_reserve(b, one) == 0){return ;}
	i = 0;j = b->count;while(i < a->count){b->mem[j] = a->mem[i];i++;j++;}for(i = one; i < b->max; i++){b->mem[i] = NULL;}
	b->count = one;
}

typedef struct list_link {struct list_link *prev;struct list_link *next;} list_link_t;
typedef struct {void *key;uint32_t key_len;vector_t dataVec;list_link_t link;} list_node_t;
typedef struct {int count;list_link_t head;} list_t;

void list_link_init(list_link_t *link){link->prev = link;link->next = link;}
void list_link_add(list_link_t *link, list_link_t *prev, list_link_t *next){link->next = next;link->prev = prev;next->prev = link;prev->next = link;}
void list_link_del(list_link_t *link, list_link_t *prev, list_link_t *next){prev->next = next;next->prev = prev;list_link_init(link);}
void list_node_init(list_node_t *node){node->key = NULL;node->key_len = 0;vector_init(&(node->dataVec));list_link_init(&(node->link));}
list_node_t * list_node_alloc(){list_node_t *node;node = NULL;node = malloc(sizeof(list_node_t));if(node != NULL){list_node_init(node);}return node;}
void list_node_free(list_node_t *node){if(node != NULL){vector_free(&(node->dataVec));free(node);}}
void list_init(list_t *list){list->count = 0;list_link_init(&(list->head));}

void list_lpush(list_t *list, list_node_t *node)
{
  if(list->count > 0){list_link_add(&(node->link),&(list->head),list->head.next);}else{list_link_add(&(node->link),&(list->head),&(list->head));}
  list->count++;
}
void list_rpush(list_t *list, list_node_t *node)
{
  if(list->count > 0){list_link_add(&(node->link),list->head.prev,&(list->head));}else{list_link_add(&(node->link),&(list->head),&(list->head));}
  list->count++;
}
list_node_t * list_lpop(list_t *list)
{
	list_node_t *node;list_link_t *link;if(list->count <= 0){return NULL;}link = list->head.next;
  node = ((list_node_t *)((unsigned char *)(link) - (int)(&(((list_node_t *)0)->link))));
  if(list->count > 1){list_link_del(link, &(list->head), link->next);}else{list_link_del(link, &(list->head), &(list->head));}
  list->count--;return node;
}
list_node_t * list_rpop(list_t *list) 
{
	list_node_t *node;list_link_t *link;if (list->count <= 0) {return NULL;}link = list->head.prev;
  node = ((list_node_t *)((unsigned char *)(link) - (int)(&(((list_node_t *)0)->link))));
  if (list->count > 1){list_link_del(link, link->prev, &(list->head));}else{list_link_del(link, &(list->head), &(list->head));}
  list->count--;return node;
}
void list_pop(list_t *list, list_node_t *node)
{
	list_link_t *link;link = &(node->link);list_link_del(link, link->prev, link->next);list->count--;
}

void list_free(list_t *list)
{
	list_node_t *node;if(list->count <= 0){return ;}node = list_lpop(list);while(node != NULL){list_node_free(node);node = list_lpop(list);}
}

void hashToByte(uint8_t *byte, uint64_t *hash)
{
  int index;int i;int s;uint64_t w;s = (sizeof(uint64_t)*8);w = *hash;
  for(i = 8; i <= s; i += 8){index = ((i/8)-1);byte[index] = ((w >> (s-i)) & 0xFF);}
}

void byteToHash(uint8_t *byte, uint64_t *hash)
{
  int index;int i;int s;uint64_t n;uint64_t w;s = (sizeof(uint64_t)*8);w = 0;
  for(i = 8; i <= s; i += 8){index = ((i/8)-1);n = (uint64_t)(byte[index]);w |= (n << (s-i));}*hash = w;
}

int base16_encode(uint8_t *input, int input_length, uint8_t *output)
{
	int i;int j;if(input_length <= 0){return -1;}j = 0;
	for(i = 0; i < input_length; i++){output[j] = ((input[i] >> 4) & 0x0F);j++;output[j] = (input[i] & 0x0F);j++;}return j;
}

#define ROTATE_RIGHT(x, n) (((x) >> (n)) | ((x) << (64-(n))))
#define read_u64(x) ((uint64_t)(*((uint64_t *)(x))))
#define read_u32(x) ((uint64_t)(*((uint32_t *)(x))))
#define read_u16(x) ((uint64_t)(*((uint16_t *)(x))))
#define read_u8(x)  ((uint64_t)(*((uint8_t *)(x))))

void metrohash64_1(uint8_t *key, uint64_t length, uint32_t seed, uint8_t *out)
{
	static uint64_t k0 = 0x00000000C83A91E1ULL;static uint64_t k1 = 0x000000008648DBDBULL;
	static uint64_t k2 = 0x000000007BDEC03BULL;static uint64_t k3 = 0x000000002F5870A5ULL;
	uint64_t v[4];uint64_t v0;uint64_t v1;uint64_t hash;uint8_t *ptr;uint8_t *end;ptr = key;end = (ptr+length);hash = (((((uint64_t)seed)+k2)*k0)+length);
	if(length >= 32)
	{
		v[0] = hash;v[1] = hash;v[2] = hash;v[3] = hash;
		do
		{
			v[0] += (read_u64(ptr)*k0);ptr += 8;v[0] = (ROTATE_RIGHT(v[0],29)+v[2]);
			v[1] += (read_u64(ptr)*k1);ptr += 8;v[1] = (ROTATE_RIGHT(v[1],29)+v[3]);
			v[2] += (read_u64(ptr)*k2);ptr += 8;v[2] = (ROTATE_RIGHT(v[2],29)+v[0]);
			v[3] += (read_u64(ptr)*k3);ptr += 8;v[3] = (ROTATE_RIGHT(v[3],29)+v[1]);
		}
		while(ptr <= (end - 32));
		v[2] ^= (ROTATE_RIGHT((((v[0]+v[3])*k0)+v[1]), 33)*k1);v[3] ^= (ROTATE_RIGHT((((v[1]+v[2])*k1)+v[0]), 33)*k0);
		v[0] ^= (ROTATE_RIGHT((((v[0]+v[2])*k0)+v[3]), 33)*k1);v[1] ^= (ROTATE_RIGHT((((v[1]+v[3])*k1)+v[2]), 33)*k0);
		hash += (v[0]^v[1]);
	}
	if((end-ptr) >= 16)
	{
		v0 = (hash+(read_u64(ptr)*k0));ptr += 8;v0 = (ROTATE_RIGHT(v0,33)*k1);v1 = (hash+(read_u64(ptr)*k1));ptr += 8;v1 = (ROTATE_RIGHT(v1,33)*k2);
		v0 ^= (ROTATE_RIGHT((v0*k0), 35)+v1);v1 ^= (ROTATE_RIGHT((v1*k3), 35)+v0);hash += v1;
	}
	if((end-ptr) >= 8)
	{
		hash += (read_u64(ptr)*k3);ptr += 8;hash ^= (ROTATE_RIGHT(hash, 33)*k1);
	}
	if((end-ptr) >= 4)
	{
		hash += (read_u32(ptr)*k3);ptr += 4;hash ^= (ROTATE_RIGHT(hash, 15)*k1);
	}
	if((end-ptr) >= 2)
	{
		hash += (read_u16(ptr)*k3);ptr += 2;hash ^= (ROTATE_RIGHT(hash, 13)*k1);
	}
	if((end - ptr) >= 1)
	{
		hash += (read_u8(ptr)*k3);hash ^= (ROTATE_RIGHT(hash, 25)*k1);
	}
	hash ^= ROTATE_RIGHT(hash, 33);hash *= k0;hash ^= ROTATE_RIGHT(hash, 33);
	memcpy(out, &hash, 8);
}

typedef struct radix_tree_node {
	uint8_t hash_key_byte;int hash_key_count;int hash_val_count;int index;struct radix_tree_node *parent;int depth;struct radix_tree_node *array[16];list_t list;
} radix_tree_node_t;
typedef struct {int count;int radix_node_count;int remove_radix_node_count;int list_node_count;radix_tree_node_t *rootArray[16];} radix_tree_t;

int radix_tree_array_get_index(radix_tree_node_t **array, uint8_t hash_key_byte)
{
	radix_tree_node_t *node;int index;if(hash_key_byte < 0 || hash_key_byte >= 16){return -1;}node = array[hash_key_byte];index = -1;
	if(node != NULL && node->hash_key_byte == hash_key_byte){index = hash_key_byte;}return index;
}
radix_tree_node_t * radix_tree_node_alloc()
{
  int i;radix_tree_node_t *node;node = NULL;node = (radix_tree_node_t *)malloc(sizeof(radix_tree_node_t));if(node == NULL){return NULL;}
  if (node != NULL)
  {
  	node->hash_key_byte = 0;node->hash_key_count = 0;node->hash_val_count = 0;node->index = 0;node->parent = NULL;node->depth = 0;
  	for(i = 0;i < 16;i++){node->array[i] = NULL;}list_init(&(node->list));
  }
  return node;
}
void radix_tree_node_free(radix_tree_node_t *node){if(node != NULL){list_free(&(node->list));free(node);}}
void radix_tree_node_destroy(radix_tree_node_t **node)
{
  radix_tree_node_t **radix_node;int i;if(node == NULL || *node == NULL){return ;}
  for(i = 0;i < 16;i++)
  {
  	if((*node)->array[i] != NULL)
  	{
  		radix_node = (&((*node)->array[i]));radix_tree_node_destroy(radix_node);(*node)->array[i] = NULL;
  	}
  }
  radix_tree_node_free((*node));*node = NULL;
}
void radix_tree_array_delete_node(radix_tree_t *tree, radix_tree_node_t *node)
{
  radix_tree_node_t **radix_node;radix_tree_node_t *parent;int index;if(tree == NULL){return ;}if(node == NULL){return ;}
  if(node->hash_key_count > 0 || node->hash_val_count > 0){return ;}parent = node->parent;index = -1;
  if(parent == NULL)
  {
  	index = radix_tree_array_get_index(tree->rootArray, node->hash_key_byte);if(index == -1){return ;}
  	radix_node = (&(tree->rootArray[index]));radix_tree_node_destroy(radix_node);tree->rootArray[index] = NULL;
  }
  else
  {
  	index = radix_tree_array_get_index(parent->array, node->hash_key_byte);if(index == -1){return ;}
  	radix_node = (&(parent->array[index]));radix_tree_node_destroy(radix_node);parent->array[index] = NULL;
  }
}
radix_tree_t * radix_tree_alloc()
{
  int i;radix_tree_t *tree;tree = NULL;tree = (radix_tree_t *)malloc(sizeof(radix_tree_t));if(tree == NULL){return NULL;}
  if (tree != NULL)
  {
  	tree->count = 0;tree->radix_node_count = 0;tree->remove_radix_node_count = 0;tree->list_node_count = 0;
  	for(i = 0;i < 16;i++){tree->rootArray[i] = NULL;}
  }
  return tree;
}
void radix_tree_destroy(radix_tree_t *tree)
{
  radix_tree_node_t **radix_node;int i;if(tree == NULL){return ;}
  for(i = 0;i < 16;i++)
  {
  	if(tree->rootArray[i] != NULL)
  	{
  		radix_node = (&(tree->rootArray[i]));radix_tree_node_destroy(radix_node);tree->rootArray[i] = NULL;
  	}
  }
  free(tree);
}
int radix_tree_find_base(radix_tree_t *tree, void *key, size_t key_len, radix_tree_node_t **result_radix_node, list_node_t **result_list_node)
{
	uint64_t hash;uint8_t hash_byte_array[8];uint8_t hash_key_byte_array[16];int depth;int index;radix_tree_node_t *radix_node;
	list_node_t *list_node;list_link_t *pos;list_link_t *next;list_link_t *end;*result_radix_node = NULL;*result_list_node = NULL;
	if(tree == NULL){return 0;}if(key == NULL){return 0;}if(key_len <= 0){return 0;}metrohash64_1(((uint8_t *)key), key_len, 0, ((uint8_t *)(&hash)));
	hashToByte(hash_byte_array, &hash);base16_encode(hash_byte_array, 8, hash_key_byte_array);
	index = radix_tree_array_get_index(tree->rootArray, hash_key_byte_array[0]);if(index == -1){return 0;}
	if(tree->rootArray[index] == NULL){return 0;}radix_node = (tree->rootArray[index]);depth = 1;	
	while(depth < 16 && radix_node != NULL)
	{
		index = radix_tree_array_get_index(radix_node->array, hash_key_byte_array[depth]);if(index == -1){*result_radix_node = radix_node;return 0;}
		if(radix_node->array[index] == NULL){*result_radix_node = radix_node;return 0;}radix_node = (radix_node->array[index]);depth++;
	}
	if(depth == 16 && radix_node != NULL)
	{
		if(radix_node->list.count > 0)
		{
			pos = radix_node->list.head.next;next = pos->next;end = &(radix_node->list.head);
			while(pos != end)
			{
				list_node = ((list_node_t *)((unsigned char *)(pos) - (int)(&(((list_node_t *)0)->link))));
				if(list_node->key_len == key_len)
				{
					if(memcmp(list_node->key, key, key_len) == 0){*result_radix_node = radix_node;*result_list_node = list_node;return 1;}
				}
				pos = next;next = pos->next;
			}
		}
		*result_radix_node = radix_node;return 1;
	}
	else{*result_radix_node = radix_node;return 0;}
}
int radix_tree_check_base(radix_tree_t *tree, void *key, size_t key_len, radix_tree_node_t **result_radix_node, list_node_t **result_list_node)
{
	uint64_t hash;uint8_t hash_byte_array[8];uint8_t hash_key_byte_array[16];int depth;int index;radix_tree_node_t *radix_node;
	list_node_t *list_node;list_link_t *pos;list_link_t *next;list_link_t *end;*result_radix_node = NULL;*result_list_node = NULL;
	if(tree == NULL){return 0;}if(key == NULL){return 0;}if(key_len <= 0){return 0;}metrohash64_1(((uint8_t *)key), key_len, 0, ((uint8_t *)(&hash)));
	hashToByte(hash_byte_array, &hash);base16_encode(hash_byte_array, 8, hash_key_byte_array);
	index = radix_tree_array_get_index(tree->rootArray, hash_key_byte_array[0]);if(index == -1){return 0;}
	if(tree->rootArray[index] == NULL){return 0;}radix_node = (tree->rootArray[index]);if(radix_node->hash_key_count <= 0){return 0;}depth = 1;	
	while(depth < 16 && radix_node != NULL && radix_node->hash_key_count > 0)
	{
		index = radix_tree_array_get_index(radix_node->array, hash_key_byte_array[depth]);if(index == -1){return 0;}
		if(radix_node->array[index] == NULL){return 0;}radix_node = (radix_node->array[index]);if(radix_node->hash_key_count <= 0){return 0;}depth++;
	}
	if(depth == 16 && radix_node != NULL && radix_node->hash_key_count > 0)
	{
		if(radix_node->list.count > 0)
		{
			pos = radix_node->list.head.next;next = pos->next;end = &(radix_node->list.head);
			while(pos != end)
			{
				list_node = ((list_node_t *)((unsigned char *)(pos) - (int)(&(((list_node_t *)0)->link))));
				if(list_node->key_len == key_len)
				{
					if(memcmp(list_node->key, key, key_len) == 0){*result_radix_node = radix_node;*result_list_node = list_node;return 1;}
				}
				pos = next;next = pos->next;
			}
		}
		*result_radix_node = radix_node;return 1;
	}
	else{return 0;}
}
int radix_tree_check_exist(radix_tree_t *tree, void *key, size_t key_len, radix_tree_node_t **result_radix_node, list_node_t **result_list_node)
{
	radix_tree_node_t *radix_node;list_node_t *list_node;*result_radix_node = NULL;*result_list_node = NULL;radix_node = NULL;list_node = NULL;
	if(radix_tree_check_base(tree, key, key_len, &radix_node, &list_node) == 1)
	{
		if(radix_node != NULL && radix_node->hash_key_count > 0 && radix_node->list.count > 0 && list_node != NULL)
		{
			*result_radix_node = radix_node;*result_list_node = list_node;return 1;
		}
	}
	return 0;
}
void radix_tree_array_get_all_prefix(radix_tree_node_t *node, vector_t *vec)
{
	int i;radix_tree_node_t *radix_node;if(node == NULL){return ;}if(node->hash_key_count <= 0){return ;}if(node->list.count > 0){vector_add(vec, node);}
	for(i = 0;i < 16;i++)
	{
		radix_node = node->array[i];if(radix_node != NULL && radix_node->hash_key_count > 0){radix_tree_array_get_all_prefix(radix_node, vec);}
	}
}
void radix_tree_array_get_all_remove(radix_tree_node_t *node, vector_t *vec)
{
	int i;radix_tree_node_t *radix_node;if(node == NULL){return ;}
	if(node != NULL && node->hash_key_count <= 0 && node->hash_val_count <= 0){vector_add(vec, node);return ;}
	for(i = 0;i < 16;i++)
	{
		radix_node = node->array[i];
		if(radix_node != NULL && radix_node->hash_key_count <= 0 && radix_node->hash_val_count <= 0){vector_add(vec, radix_node);}
		else if(radix_node != NULL && radix_node->hash_key_count > 0 && radix_node->hash_val_count > 0){radix_tree_array_get_all_remove(radix_node, vec);}
	}
}
int radix_tree_delete_all_remove(radix_tree_t *tree)
{
	int i;radix_tree_node_t *radix_node;radix_tree_node_t *remove_radix_node;vector_t remove_radix_node_vec;
	if(tree == NULL){return 0;}if(tree->radix_node_count < 1024){return 0;}if(tree->remove_radix_node_count < ((tree->radix_node_count*4)/5)){return 0;}
	vector_init(&remove_radix_node_vec);vector_reserve(&remove_radix_node_vec, tree->radix_node_count);
	for(i = 0;i < 16;i++)
	{
  	if(tree->rootArray[i] != NULL){radix_node = (tree->rootArray[i]);radix_tree_array_get_all_remove(radix_node, &remove_radix_node_vec);}		
	}
	if(remove_radix_node_vec.count <= 0){vector_free(&remove_radix_node_vec);return 0;}
	for(i = 0;i < remove_radix_node_vec.count;i++)
	{
		remove_radix_node = (remove_radix_node_vec.mem[i]);if(remove_radix_node != NULL){radix_tree_array_delete_node(tree, remove_radix_node);}
	}
	tree->radix_node_count -= tree->remove_radix_node_count;tree->remove_radix_node_count = 0;vector_free(&remove_radix_node_vec);return 1;
}
int radix_tree_get(radix_tree_t *tree, void *key, size_t key_len, radix_tree_node_t **result_radix_node, list_node_t **result_list_node, vector_t *vec)
{
	radix_tree_node_t *radix_node;list_node_t *list_node;radix_node = NULL;list_node = NULL;
	if(result_radix_node != NULL){*result_radix_node = NULL;}if(result_list_node != NULL){*result_list_node = NULL;}if(vec != NULL){vector_free(vec);}
	if(tree == NULL){return 0;}if(key == NULL){return 0;}if(key_len <= 0){return 0;}
  if(radix_tree_check_exist(tree, key, key_len, &radix_node, &list_node) == 1)
  {
  	if(radix_node != NULL && list_node != NULL)
  	{
  		if(vec != NULL){vector_copy_vec(&(list_node->dataVec), vec);}
  		if(result_radix_node != NULL){*result_radix_node = radix_node;}if(result_list_node != NULL){*result_list_node = list_node;}return 1;
  	}
  }
  return 0;
}
int radix_tree_insert(radix_tree_t *tree, void *key, size_t key_len, void *value)
{
	uint64_t hash;uint8_t hash_byte_array[8];uint8_t hash_key_byte_array[16];int i;int j;vector_t one_radix_node_vec;int depth;
	radix_tree_node_t *parent_radix_node;radix_tree_node_t *one_radix_node;radix_tree_node_t *radix_node;list_node_t *list_node;
	radix_node = NULL;list_node = NULL;if(tree == NULL){return 0;}if(key == NULL){return 0;}if(key_len <= 0){return 0;}if(value == NULL){return 0;}	
  if(radix_tree_find_base(tree, key, key_len, &radix_node, &list_node) == 1)
  {
  	if(radix_node->list.count > 0)
  	{
  		if(list_node != NULL)
  		{
  			vector_add(&(list_node->dataVec), value);while(radix_node != NULL){radix_node->hash_val_count++;radix_node = (radix_node->parent);}
  			tree->count++;return 1;
  		}
  		else
  		{
  			list_node = list_node_alloc();if(list_node == NULL){return 0;}list_node->key = key;list_node->key_len = key_len;
  			vector_add(&(list_node->dataVec), value);list_lpush(&(radix_node->list), list_node);
  			while(radix_node != NULL){radix_node->hash_val_count++;radix_node = (radix_node->parent);}
  			tree->count++;tree->list_node_count++;return 1;
  		}
  	}
  	else
  	{
  		list_node = list_node_alloc();if(list_node == NULL){return 0;}list_node->key = key;list_node->key_len = key_len;
  		vector_add(&(list_node->dataVec), value);list_lpush(&(radix_node->list), list_node);
  		while(radix_node != NULL)
  		{
  			if(radix_node->hash_key_count <= 0 && radix_node->hash_val_count <= 0){tree->remove_radix_node_count--;}
  			radix_node->hash_key_count++;radix_node->hash_val_count++;radix_node = (radix_node->parent);
  		}
  		tree->count++;tree->list_node_count++;return 1;
  	}
  }
  metrohash64_1(((uint8_t *)key), key_len, 0, ((uint8_t *)(&hash)));hashToByte(hash_byte_array, &hash);base16_encode(hash_byte_array, 8, hash_key_byte_array);
  list_node = list_node_alloc();if(list_node == NULL){return 0;}
  if(radix_node == NULL)
  {
  	depth = 0;vector_init(&one_radix_node_vec);vector_reserve(&one_radix_node_vec, 16);
  	while(depth < 16)
  	{
  		one_radix_node = radix_tree_node_alloc();if(one_radix_node == NULL){break;}vector_add(&one_radix_node_vec, one_radix_node);depth++;
  	}
  	if(depth < 16)
  	{
  		for(i = 0;i < one_radix_node_vec.count;i++)
  		{
  			one_radix_node = one_radix_node_vec.mem[i];if(one_radix_node != NULL){radix_tree_node_free(one_radix_node);}
  		}
  		list_node_free(list_node);vector_free(&one_radix_node_vec);return 0;
  	}
  	list_node->key = key;list_node->key_len = key_len;vector_add(&(list_node->dataVec), value);j = 0;depth = 0;parent_radix_node = NULL;
  	while(depth < 16)
  	{
  		one_radix_node = one_radix_node_vec.mem[j];
  		if(one_radix_node != NULL)
  		{
  			one_radix_node->hash_key_byte = hash_key_byte_array[depth];one_radix_node->hash_key_count = 1;one_radix_node->hash_val_count = 1;
  			if(depth == 0)
  			{
  				one_radix_node->index = 0;one_radix_node->parent = NULL;one_radix_node->depth = 0;
  				tree->rootArray[(one_radix_node->hash_key_byte)] = one_radix_node;
  			}
  			else
  			{
  				one_radix_node->index = one_radix_node->hash_key_byte;one_radix_node->parent = parent_radix_node;one_radix_node->depth = depth;
  				parent_radix_node->array[(one_radix_node->index)] = one_radix_node;
  			}
  			if(depth == 15){list_lpush(&(one_radix_node->list), list_node);}  			
  			parent_radix_node = one_radix_node;
  		}
  		j++;depth++;
  	}
  	tree->count++;tree->list_node_count++;tree->radix_node_count += one_radix_node_vec.count;vector_free(&one_radix_node_vec);return 1;
  }
  else
  {
  	depth = (radix_node->depth+1);vector_init(&one_radix_node_vec);vector_reserve(&one_radix_node_vec, 16);
  	while(depth < 16)
  	{
  		one_radix_node = radix_tree_node_alloc();if(one_radix_node == NULL){break;}vector_add(&one_radix_node_vec, one_radix_node);depth++;
  	}
  	if(depth < 16)
  	{
  		for(i = 0;i < one_radix_node_vec.count;i++)
  		{
  			one_radix_node = one_radix_node_vec.mem[i];if(one_radix_node != NULL){radix_tree_node_free(one_radix_node);}
  		}
  		list_node_free(list_node);vector_free(&one_radix_node_vec);return 0;
  	}
  	list_node->key = key;list_node->key_len = key_len;vector_add(&(list_node->dataVec), value);j = 0;
  	depth = (radix_node->depth+1);parent_radix_node = radix_node;
  	while(depth < 16)
  	{
  		one_radix_node = one_radix_node_vec.mem[j];
  		if(one_radix_node != NULL)
  		{
  			one_radix_node->hash_key_byte = hash_key_byte_array[depth];one_radix_node->hash_key_count = 1;one_radix_node->hash_val_count = 1;
  			one_radix_node->index = one_radix_node->hash_key_byte;one_radix_node->parent = parent_radix_node;one_radix_node->depth = depth;
  			parent_radix_node->array[(one_radix_node->index)] = one_radix_node;if(depth == 15){list_lpush(&(one_radix_node->list), list_node);}
  			parent_radix_node = one_radix_node;
  		}
  		j++;depth++;
  	}
  	one_radix_node = radix_node;
  	while(one_radix_node != NULL)
  	{
  		if(one_radix_node->hash_key_count <= 0 && one_radix_node->hash_val_count <= 0){tree->remove_radix_node_count--;}
  		one_radix_node->hash_key_count++;one_radix_node->hash_val_count++;one_radix_node = (one_radix_node->parent);
  	}
  	tree->count++;tree->list_node_count++;tree->radix_node_count += one_radix_node_vec.count;vector_free(&one_radix_node_vec);return 1;
  }
  return 1;
}
int radix_tree_remove(radix_tree_t *tree, void *key, size_t key_len, vector_t *vec)
{
  radix_tree_node_t *one_radix_node;radix_tree_node_t *radix_node;list_node_t *list_node;radix_node = NULL;list_node = NULL;
  if(vec != NULL){vector_free(vec);}if(tree == NULL){return 0;}if(key == NULL){return 0;}if(key_len <= 0){return 0;}
  if(radix_tree_check_exist(tree, key, key_len, &radix_node, &list_node) == 1)
  {
  	if(radix_node != NULL && radix_node->hash_key_count > 0 && radix_node->list.count > 0 && list_node != NULL)
  	{
  		list_pop(&(radix_node->list), list_node);if(vec != NULL){vector_copy_vec(&(list_node->dataVec), vec);}
  		if(radix_node->list.count <= 0)
  		{
  			one_radix_node = radix_node;
  			while(one_radix_node != NULL)
  			{
  				one_radix_node->hash_key_count--;one_radix_node->hash_val_count -= (list_node->dataVec.count);
  				if(one_radix_node->hash_key_count <= 0 && one_radix_node->hash_val_count <= 0){tree->remove_radix_node_count++;}
  				one_radix_node = (one_radix_node->parent);
  			}
  		}
  		else
  		{
  			one_radix_node = radix_node;
  			while(one_radix_node != NULL){one_radix_node->hash_val_count -= (list_node->dataVec.count);one_radix_node = (one_radix_node->parent);}
  		}
  		tree->count -= (list_node->dataVec.count);tree->list_node_count--;list_node_free(list_node);radix_tree_delete_all_remove(tree);return 1;
  	}  	
  }
  return 0;
}

typedef struct {
	radix_tree_t *tree;int vec_index;vector_t radix_node_vec;radix_tree_node_t *radix_node;list_node_t *list_node;list_link_t *pos;list_link_t *next;list_link_t *end;
} radix_tree_iterator_t;


int radix_tree_iterator_init(radix_tree_t *tree, radix_tree_iterator_t *iterator)
{
  int i;radix_tree_node_t *radix_node;if(tree == NULL){return 0;}if(iterator == NULL){return 0;}vector_init(&(iterator->radix_node_vec));
	for(i = 0;i < 16;i++)
	{
  	if(tree->rootArray[i] != NULL){radix_node = (tree->rootArray[i]);radix_tree_array_get_all_prefix(radix_node, &(iterator->radix_node_vec));}		
	}
	if(iterator->radix_node_vec.count <= 0){vector_free(&(iterator->radix_node_vec));return 0;}	
	iterator->tree = tree;iterator->vec_index = 0;iterator->radix_node = iterator->radix_node_vec.mem[0];
	iterator->pos = (iterator->radix_node->list.head.next);iterator->next = iterator->pos->next;iterator->end = &(iterator->radix_node->list.head);	
	iterator->list_node = ((list_node_t *)((unsigned char *)(iterator->pos) - (int)(&(((list_node_t *)0)->link))));return 1;
}
radix_tree_iterator_t * radix_tree_iterator_alloc(radix_tree_t *tree)
{
	radix_tree_iterator_t *iterator;if(tree == NULL){return NULL;}iterator = NULL;iterator = malloc(sizeof(radix_tree_iterator_t));
	if(iterator != NULL){if(radix_tree_iterator_init(tree, iterator) == 0){free(iterator);iterator = NULL;return iterator;}else{return iterator;}}
	return iterator;
}
void radix_tree_iterator_free(radix_tree_iterator_t *iterator)
{
	if(iterator != NULL){vector_free(&(iterator->radix_node_vec));free(iterator);}
}
int radix_tree_iterator_next(radix_tree_iterator_t *iterator)
{
	int vec_index;list_node_t *list_node;list_link_t *pos;list_link_t *next;if(iterator == NULL){return 0;}vec_index = iterator->vec_index;
	if(vec_index < (iterator->radix_node_vec.count-1))
	{
		if(iterator->next != iterator->end)
		{
			pos = iterator->next;next = pos->next;list_node = ((list_node_t *)((unsigned char *)(pos) - (int)(&(((list_node_t *)0)->link))));
			iterator->list_node = list_node;iterator->pos = pos;iterator->next = next;return 1;			
		}
		else
		{
			vec_index++;iterator->vec_index = vec_index;iterator->radix_node = iterator->radix_node_vec.mem[vec_index];
			iterator->pos = (iterator->radix_node->list.head.next);iterator->next = iterator->pos->next;iterator->end = &(iterator->radix_node->list.head);
			iterator->list_node = ((list_node_t *)((unsigned char *)(iterator->pos) - (int)(&(((list_node_t *)0)->link))));return 1;			
		}
	}
	else
	{
		if(iterator->next != iterator->end)
		{
			pos = iterator->next;next = pos->next;list_node = ((list_node_t *)((unsigned char *)(pos) - (int)(&(((list_node_t *)0)->link))));
			iterator->list_node = list_node;iterator->pos = pos;iterator->next = next;return 1;			
		}
		else
		{
			return 0;
		}
	}
	return 0;
}
void writeData(FILE *fd, void *key, vector_t *vec)
{
	int i;void *item;fprintf(fd, "%s <--> ", ((char *)key));
	for(i = 0; i < vec->count; ++i)
	{
		vector_get(vec, i, &item);if(i < (vec->count-1)){fprintf(fd, "%s : ", ((char *)item));}else{fprintf(fd, "%s", ((char *)item));}
	}
	fprintf(fd, "\n");
}
void list_node_dump(FILE *fd, list_node_t *node){writeData(fd, node->key, &(node->dataVec));}
void radix_tree_dump(FILE *fd, radix_tree_t *tree)
{
	radix_tree_iterator_t *iterator;if(tree == NULL){return ;}iterator = radix_tree_iterator_alloc(tree);if(iterator == NULL){return ;}
	list_node_dump(fd, iterator->list_node);while(radix_tree_iterator_next(iterator) == 1){list_node_dump(fd, iterator->list_node);}
	radix_tree_iterator_free(iterator);
}

void build()
{
	int i;radix_tree_t *tree;memset(arrKeyStr,0,sizeof(arrKeyStr));memset(arrValStr,0,sizeof(arrValStr));n = 16;
	strcpy(arrKeyStr[0],"1100") ;strcpy(arrValStr[0],"0");
	strcpy(arrKeyStr[1],"1200") ;strcpy(arrValStr[1],"1");
	strcpy(arrKeyStr[2],"1300") ;strcpy(arrValStr[2],"2");
	strcpy(arrKeyStr[3],"1400") ;strcpy(arrValStr[3],"3");
	strcpy(arrKeyStr[4],"1500") ;strcpy(arrValStr[4],"4");
	strcpy(arrKeyStr[5],"1600") ;strcpy(arrValStr[5],"5");
	strcpy(arrKeyStr[6],"1100") ;strcpy(arrValStr[6],"6");
	strcpy(arrKeyStr[7],"1200") ;strcpy(arrValStr[7],"7");
	strcpy(arrKeyStr[8],"1300") ;strcpy(arrValStr[8],"8");
	strcpy(arrKeyStr[9],"1400") ;strcpy(arrValStr[9],"9");
	strcpy(arrKeyStr[10],"1500");strcpy(arrValStr[10],"10");
	strcpy(arrKeyStr[11],"1600");strcpy(arrValStr[11],"11");
	strcpy(arrKeyStr[12],"1100");strcpy(arrValStr[12],"12");
	strcpy(arrKeyStr[13],"1200");strcpy(arrValStr[13],"13");
	strcpy(arrKeyStr[14],"1700");strcpy(arrValStr[14],"14");
	strcpy(arrKeyStr[15],"1800");strcpy(arrValStr[15],"15");
	tree = radix_tree_alloc();if(tree == NULL){return ;}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    radix_tree_insert(tree, arrKeyStr[i], strlen(arrKeyStr[i]), arrValStr[i]);
	}
	radix_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	for(i = 5; i < 8; ++i)
	{
	    radix_tree_remove(tree, arrKeyStr[i], strlen(arrKeyStr[i]), NULL);
	}
	radix_tree_dump(fd, tree);
	fprintf(fd, "\n");fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	radix_tree_destroy(tree);
}

int main()
{
	build();
	return 0;
}


fenwick_tree.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifndef NULL
#define NULL ((void*) 0)
#endif

int arrData[10000];
int arrDataTwo[10000];
int n;
FILE *fd;

int clz(unsigned int x)
{
	int n;n = 0;if(x == 0){return 32;}if(x >= 0x80000000U) {return 0;}
  if (x <= 0x0000FFFFU) {n = n + 16; x = x << 16;}
  if (x <= 0x00FFFFFFU) {n = n + 8; x = x << 8;}
  if (x <= 0x0FFFFFFFU) {n = n + 4; x = x << 4;}
  if (x <= 0x3FFFFFFFU) {n = n + 2; x = x << 2;}
  if (x <= 0x7FFFFFFFU) {n = n + 1;}
  return n;
}

#define lowbit(x) ((x)&(-x))
#define highbit(x) (1<<(31-clz(x)))

void add(int index, int value){while(index>=1 && index<=n){arrDataTwo[index] += value;index += lowbit(index);}}
void sum(int index, int *value){*value = 0;while(index>=1 && index<=n){*value += arrDataTwo[index];index -= lowbit(index);}}
void get(int index, int *value){int one;sum(index,value);sum(index-1,&one);*value -= one;}
int searchSum(int value)
{
	int index;int one;int two;index = 0;one = highbit(n);
	while(one >= 1)
	{
		two = (index + one);
		if(two <= n)
		{
			if(arrDataTwo[two] == value){return two;}
			else if(arrDataTwo[two] < value){value -= arrDataTwo[two];index = two;}
		}
		one >>= 1;
	}
	return 0;
}
//dot -Tpng -o tree.png tree.dot
void fenwick_tree_dump(int nameCount)
{
	int index;int parentIndex;int value;char oneFileName[64];
	memset(oneFileName,0,sizeof(oneFileName));
	sprintf(oneFileName,"%d%s",nameCount,"tree.dot");
	fd =fopen(oneFileName, "w");
	fprintf(fd, "digraph fenwick_tree {\n");
	fprintf(fd, "node [shape=circle, fontname=\"Arial\"];\n");
	index = 1;
	while(index>=1 && index<=n)
	{
		get(index, &value);
		fprintf(fd, "%d [label=\"%d:%d:%d\"];\n",index,index,value, arrDataTwo[index]);
		parentIndex = (index+lowbit(index));
		if(parentIndex>=1 && parentIndex<=n)
		{
			fprintf(fd, "%d -> %d [label=\"parent\", color=\"red\"];\n", index, parentIndex);
		}
		index++;
	}
	fprintf(fd, "}\n");
	fflush(fd);
	fclose(fd);
	return ;
}

void build()
{
	int i;int value;
	memset(arrData,0,sizeof(arrData));
	memset(arrDataTwo,0,sizeof(arrDataTwo));
	n = 32;
	for(i = 0; i < n; ++i)
	{
		arrData[i] = (4*i+1);
		add(i+1, arrData[i]);
	}
	fd=fopen("out.txt", "wb");
	for(i = 0; i < n; ++i)
	{
	    fprintf(fd, "%d ",arrData[i]);
	}
	fprintf(fd, "\n");
	for(i = 0; i < n; ++i)
	{
	    sum(i+1, &value);
	    fprintf(fd, "%d ",value);
	}
	fprintf(fd, "\n");
	for(i = 0; i < n; ++i)
	{
	    get(i+1, &value);
	    fprintf(fd, "%d ",value);
	}
	fprintf(fd, "\n");
	for(i = 0; i < n; ++i)
	{
	    sum(i+1, &value);
	    fprintf(fd, "%d ",searchSum(value));
	}
	fprintf(fd, "\n");
	fflush(fd);
	fclose(fd);
	fenwick_tree_dump(n);
}

int main()
{
	build();
	return 0;
}

