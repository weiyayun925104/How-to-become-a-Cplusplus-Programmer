汇编语言 第三版 王爽 1-9856行
一个CPU有N根地址线，则可以说这个CPU的地址总线的宽度为N。
这样的CPU最多可以寻找2的N次方个内存单元。
数据总线的宽度决定了CPU和外界的数据传送速度。
8根数据总线一次可传送一个8位二进制数据（即一个字节）。
16根数据总线一次可传送两个字节。
CPU对外部器件的控制是通过控制总线来进行的。
其中有一根称为“读信号输出”的控制线负责由CPU向外传送读信号，
有一根称为“写信号输出”的控制线则负责传送写信号。
（4）在存储器中指令和数据没有任何区别，都是二进制信息。
（5）存储单元从零开始顺序编号。
（6）一个存储单元可以存储8个bit，即8位二进制数。
捡测点1.1
（1）1个CPU的寻址能力为8KB，那么它的地址总线的宽度为13。
（2）1KB的存储器有1024个存储单元。存储单元的编号从0到1023。
（3）1KB的存储器可以存储个8192bit，1024个Byte。
（4）1GB、1MB、1KB分别是1073741824 1048756 1024Byte。
（5）8080、8088、80286、80386的地址总线宽度分别为16根、20根、24根、32根，则它们的寻址能力分别为：64（KB）、1（MB）、16（MB）、4（GB）。
（6）8080、8088、8086、80286、80386的数据总线宽度分别为8根、8根、16根、16根、32根。则它们一次可以传送的数据为：1（B）、1（B）、2（B）、2（B）、4（B）。
（7）从内存中读取1024字节的数据，8086至少要读512次，80386至少要读256次。
（8）在存储器中，数据和程序以二进制形式存放。

从读写属性上看分为两类：随机存储器（RAM）和只读存储器（ROM）。
随机存储器可读可写，但必须带电存储，关机后存储的内容丢失；
只读存储器只能读取不能写入，关机后其中的内容不丢失。
・随机存储器
用于存放供CPU使用的绝大部分程序和数据，主随机存储器一般由两个位置上的RAM组成，
装在主板上RAM和插在扩展插槽上的RAM。
・装有BIOS（Basic Input/Output System，基本输入/输出系统）的ROM 
BIOS是由主板和各类接口卡（如显卡、网卡等）厂商提供的软件系统，
可以通过它利用该硬件设备进行最基本的输入输出。在主板和某些接口卡上插有存储相应BIOS的ROM。
例如，主板上的ROM中存储着主板的BIOS（通常称为系统BIOS）；显卡上的ROM中存储着显卡的BIOS；如果网卡上装有ROM，那其中就可以存储网卡的BIOS。
・接口卡上的RAM某些接口卡需要对大批量输入、输出数据进行暂时存储，在其上装有RAM。
最典型的是显示卡上的RAM，一般称为显存。显示卡随时将显存中的数据向显示器上输出。
换句话说，我们将需要显示的内容写入显存，就会出现在显示器上。
上述的那些存储器，在物理上是独立的器件，但是在以下两点上相同。
・都和CPU的总线相连。
・CPU对它们进行读或写的时候都通过控制线发出内存读写命令。
这也就是说，CPU在操控它们的时候，把它们都当作内存来对待，
把它们总的看作一个由若干存储单元组成的逻辑存储器，
这个逻辑存储器就是我们所说的内存地址空间。在汇编这门课中，我们所面对的是内存地址空间。
简单地说，在CPU中：
・运算器进行信息处理；・寄存器进行信息存储；
・控制器控制各种器件进行工作；
・内部总线连接各种器件，在它们之间进行数据的传送。
8086CPU的所有寄存器都是16位的，可以存放两个字节。
AX、BX、CX、DX这4个寄存器通常用来存放一般性的数据，被称为通用寄存器。
AX、BX、CX、DX这4个寄存器都可分为两个可独立使用的8位寄存器来用：
・AX可分为AH和AL；・BX可分为BH和BL；・CX可分为CH和CL；・DX可分为DH和DL。
AX的低8位（0位~7位）构成了AL寄存器，高8位（8位~15位）构成了AH寄存器。
AH和AL寄存器是可以独立使用的8位寄存器。
8086CPU可以一次性处理以下两种尺寸的数据。
・字节：记为byte，一个字节由8个bit组成，可以存在8位寄存器中。
・字：记为word，一个字由两个字节组成，这两个字节分别称为这个字的高位字节和低位字节。
一个字可以存在一个16位寄存器中，这个字的高位字节和低位字节自然就存在这个寄存器的高8位寄存器和低8位寄存器中。
在进行数据传送或运算时，要注意指令的两个操作对象的位数应当是一致的
检测点2.1
（1）写出每条汇编指令执行后相关寄存器中的值。
mov ax,62627   Ax=F4A3H
mov ah，31H   AX=31A3H
mov al，23H    Ax=3123H
add ax，ax       Ax=6246H
mov bx，826CH BX=826cH
mov cx，ax     Cx=6246H
mov ax，bx    AX=826ch
add ax，bx     AX=04d8h
mov al，bh    Ax=0482h
mov ah，bl   Ax=6c82h
add ah，ah    Ax=d882h
add al，6       Ax=d888h
add al，al      Ax=d810h
mov ax，Cx    AX=6246h
（2）只能使用目前学过的汇编指令，最多使用4条指令，编程计算2的4次方。
mov ax,2
add ax,ax
add ax,ax
add ax,ax
地址加法器采用物理地址=段地址x16+偏移地址的方法用段地址和偏移地址合成物理地址。
段地址×16+偏移地址=物理地址的本质含义是：CPU在访问内存时，用一个基础地址（段地址×16）和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址。
更一般地说，8086CPU的这种寻址功能是“基础地址+偏移地址=物理地址”寻址模式的一种具体实现方案。
8086CPU中，段地址×16可看作是基础地址。
将若干地址连续的内存单元看作一个段，用段地址×16定位段的起始地址（基础地址），
用偏移地址定位段中的内存单元。有两点需要注意：段地址×16必然是16的倍数，所以一个段的起始地址也一定是16的倍数；
偏移地址为16位，16位地址的寻址能力为64KB，所以一个段的长度最大为64KB。
捡测点2.2
（1）给定段地址为0001H，仅通过变化偏移地址寻址，CPU的寻址范围为00010h到1000fh。
（2）有一数据存放在内存20000H单元中，现给定段地址为SA，若想用偏移地址寻到此单元。则SA应满足的条件是：最小为10001h，最大为20000h。
提示，反过来思考一下，当段地址给定为多少，CPU无论怎么变化偏移地址都无法寻到20000H单元？
小于10001h 大于20000h
段地址在8086CPU的段寄存器中存放。8086CPU有4个段寄存器：CS、DS、SS、ES。
当8086CPU要访问内存时由这4个段寄存器提供内存单元的段地址。
CS为代码段寄存器，IP为指令指针寄存器
8086CPU的工作过程可以简要描述如下。
（1）从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器；
（2）IP=IP+所读取指令的长度，从而指向下一条指令；
（3）执行指令。转到步骤（1），重复这个过程。
在8086CPU加电启动或复位后（即CPU刚开始工作时）CS和IP被设置为CS=FFFFH，IP=0000H，即在8086PC机刚启动时，
CPU从内存FFFF0H单元中读取指令执行，FFFF0H单元中的指令是8086PC机开机后执行的第一条指令。
8086CPU大部分寄存器的值，都可以用mov指令来改变，mov指令被称为传送指令。
若想同时修改CS、IP的内容，可用形如jmp段地址：偏移地址的指令完成，如jmp2AE3：3，
执行后：CS=2AE3H，IP=0003H，CPU将从2AE33H处读取指令。
jmp3：0B16，执行后：CS=0003H，IP=0B16H，CPU将从00B46H处读取指令。
若想仅修改IP的内容，可用形如“jmp某一合法寄存器”的指令完成，如第2章寄存器
jmp ax，指令执行前：ax=1000H，CS=2000H，IP=0003H
指令执行后：ax=1000H，CS=2000H，IP=1000H 
jmp bx，指令执行前：bx=0B16H，CS=2000H，IP=0003H
指令执行后：bx=0B16H，CS=2000H，IP=0B16H
“jmp某一合法寄存器”指令的功能为：用寄存器中的值修改IP。
jmp ax，在含义上好似：mov IP，ax。
如何使得代码段中的指令被执行呢？将一段内存当作代码段，仅仅是我们在编程时的一种安排，
CPU并不会由于这种安排，就自动地将我们定义的代码段中的指令当作指令来执行。
CPU只认被CS:IP指向的内存单元中的内容为指令。所以，要让CPU执行我们放在代码段中的指令，
必须要将CS:IP指向所定义的代码段中的第一条指令的首地址。
对于上面的例子，我们将一段代码存放在123B0H~123B9H内存单元中，将其定义为代码段，
如果要让这段代码得到执行，可设CS=123BH、IP=0000H。
（1）段地址在8086CPU的段寄存器中存放。当8086CPU要访问内存时，由段寄存器提供内存单元的段地址。
8086CPU有4个段寄存器，其中CS用来存放指令的段地址。
（2）CS存放指令的段地址，IP存放指令的偏移地址。
8086机中，任意时刻，CPU将CS:IP指向的内容当作指令执行。
（3）8086CPU的工作过程：
①从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器；
②IP指向下一条指令；
③执行指令。（转到步骤①，重复这个过程。）
（4）8086CPU提供转移指令修改CS、IP的内容。
检测点2.3
下面的3条指令执行后，CPU几次修改IP？都是在什么时候？最后IP中的值是多少？
mov ax，bx
sub ax，ax 
jmp ax
CPU读取mov ax,ax的时候，第一次修改IP
     读取sub ax,ax的时候，第二次修改IP
     读取jmp ax的时候，第三次修改IP
     当执行jmp ax的时候，IP变为0，这是第4次修改
     最后IP变为0
本次实验中需要用到的命令
查看、修改CPU中寄存器的内容：R命令
查看内存中的内容：D命令
修改内存中的内容：E命令（可以写入数据、指令，在内存中，它们实际上没有区别）将内存中的内容解释为机器指令和对应的汇编指令：U命令执行CS:IP指向的内存单元处的指令：T命令
以汇编指令的形式向内存中写入指令：A命令
在预备知识中，详细讲解了Debug的基本功能和用法。在汇编语言的学习中，Debug是一个经常用到的工具，在学习预备知识中，应该一边看书一边在机器上操作。
前面提到，我们的原则是：以后用到的，以后再说。所以在这里只讲了一些在本次实验中需要用到的命令的相关的使用方法。以后根据需要，我们会讲解其他的用法。
CPU中，用16位寄存器来存储一个字。高8位存放高位字节，低8位存放低位字节。
在内存中存储时，由于内存单元是字节单元（一个单元存放一个字节），
则一个字要用两个地址连续的内存单元来存放，这个字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。
比如我们从0地址开始存放20000，这种情况如图3.1所示。
我们提出字单元的概念：字单元，即存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成。
高地址内存单元中存放字型数据的高位字节，低地址内存单元中存放字型数据的低位字节。
任何两个地址连续的内存单元，N号单元和N+1号单元，
可以将它们看成两个内存单元，也可看成一个地址为N的字单元中的高位字节单元和低位字节单元。
8086CPU中有一个DS寄存器，通常用来存放要访问数据的段地址。
使用mov指令，可完成两种传送：①将数据直接送入寄存器；②将一个寄存器中的内容送入另一个寄存器。
也可以使用mov指令将一个内存单元中的内容送入一个寄存器中。
从哪一个内存单元送到哪一个寄存器中呢？在指令中必须指明。
寄存器用寄存器名来指明，内存单元则需用内存单元的地址来指明。
此时mov指令的格式应该是：mov寄存器名，内存单元地址。
指令执行时，8086CPU自动取ds中的数据为内存单元的段地址。
8086CPU不支持将数据直接送入段寄存器的操作，ds是一个段寄存器，
所以mov ds，1000H这条指令是非法的。只好用一个寄存器来进行中转，
即先将1000H送入一个一般的寄存器，如bx，再将bx中的内容送入ds。
从内存单元到寄存器的格式是：“mov寄存器名，内存单元地址”，
从寄存器到内存单元则是：“mov内存单元地址，寄存器名”。
只要在mov指令中给出16位的寄存器就可以进行16位数据的传送了。
mov寄存器，数据比如：mov ax，8
mov寄存器，寄存器比如：mov ax，bx 
mov寄存器，内存单元比如：mov ax，[0]
mov内存单元，寄存器比如：mov [0]，ax 
mov段寄存器，寄存器比如：mov ds，ax
mov寄存器，段寄存器
mov内存单元，段寄存器
mov段寄存器，内存单元
add 寄存器，数据比如：add ax，8
add寄存器，寄存器比如：add ax，bx 
add 寄存器，内存单元比如：add ax，[0]
add 内存单元，寄存器比如：add[0]，ax 
sub寄存器，数据比如：sub ax，9
sub寄存器，寄存器比如：sub ax，bx 
sub寄存器，内存单元比如：subax，[0]
sub内存单元，寄存器比如：sub[0]，ax
它们可以对段寄存器进行操作吗？比如“add ds，ax”。不可以
如何访问数据段中的数据呢？
可以在具体操作的时候，用ds存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元。
（1）字在内存中存储时，要用两个地址连续的内存单元来存放，
字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。
（2）用mov指令访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中。
（3）[address]表示一个偏移地址为address的内存单元。
（4）在内存和寄存器之间传送字型数据时，高地址单元和高8位寄存器、低地址单元和低8位寄存器相对应。
捡测点3.1
（1）在Debug中，用“d0：01f”查看内存，结果如下。
0000：0000 7080 F030 EF60 30E2-0080801266202260
0000：0010 6226 E6D6 CC2E 3C3B-ABBA000026066688
下面的程序执行前，AX=0，BX=0，写出每条汇编指令执行完后相关寄存器中的值。
mov ax，1
mov ds，ax 
mov ax，[0000]Ax=2662
mov bx，[0001]BX=e626
mov ax，bx       AX=e626
mov ax，[0000]  Ax=2662
mov bx，[0002]BX=d6e6
add ax，bxAX=fd48
add ax，[0004]AX=2c14
mov ax，0Ax=0000
mov al，[0002]Ax=00e6
mov bx，0BX=0000
mov bl，[000C]BX=0026
add al，blAx=000c
提示，注意ds的设置。
（2）内存中的情况如图3.6所示。
各寄存器的初始值：CS=2000H，IP=0，DS=1000H，AX=0，BX=0；
①写出CPU执行的指令序列（用汇编指令写出）。
②写出CPU执行每条指令后，CS、IP和相关寄存器中的数值。
③再次体会：数据和程序有区别吗？如何确定内存中的信息哪些是数据，哪些是程序？
CS = 2000h,IP = 0,DS = 1000h
mov ax,6622h  AX = 6622h
jmp 0ff0:0100h CS = 0ff0 IP = 0100h
mov ax,2000h  AX = 2000h
mov ds,ax       DS = 2000h
mov ax,[0008] AX = C389h
mov ax,[0002] AX = EA66h
指令                     CS  IP  DS  AX  BX 
mov ax，6622H 2000H 0003H 1000H 6622H 0000H
jmp 0ff0:0100    0ff0H 0100H 1000H 6622H 0000H
mov ax，2000H 0ff0H 0103H 1000H 2000H 0000H 
mov ds，ax        0ff0H 0105H 2000H 2000H 0000H 
mov ax，[0008] 0ff0H 0108H 2000H C389H 0000H 
mov ax，[0002] 0ff0H 010BH 2000H EA66H 0000H
程序和数据没有区别，当内存单元被CS:IP指定时其存储的就被当做程序执行。
当内存单元被DS:[address]指定时其存储的就被当做数据。
在这里，我们对栈的研究仅限于这个角度：栈是一种具有特殊的访问方式的存储空间。
它的特殊性就在于，最后进入这个空间的数据，最先出去。
栈有两个基本的操作：入栈和出栈。入栈就是将一个新的元素放到栈顶，出栈就是从栈顶取出一个元素。栈顶的元素总是最后入栈，需要出栈时，又最先被从栈中取出。
栈的这种操作规则被称为：LIFO（Last In First Out，后进先出）。
8086CPU提供入栈和出栈指令，最基本的两个是PUSH（入栈）和POP（出栈）。
比如，push ax表示将寄存器ax中的数据送入栈中，pop ax表示从栈顶取出数据送入ax。
8086CPU的入栈和出栈操作都是以字为单位进行的。
注意，字型数据用两个单元存放，高地址单元存放高8位，低地址单元存放低8位。
8086CPU中，有两个寄存器，段寄存器SS和寄存器SP，
栈顶的段地址存放在SS中，偏移地址存放在SP中。
任意时刻，SS:SP指向栈顶元素。push指令和pop指令执行时，CPU从SS和SP中得到栈顶的地址。
pushax的执行，由以下两步完成。
（1）SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；
（2）将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。
8086CPU中，入栈时，栈顶从高地址向低地址方向增长。
任意时刻，SS:SP指向栈顶元素，当栈为空的时候，栈中没有元素，也就不存在栈顶元素，
所以SS:SP只能指向栈的最底部单元下面的单元，该单元的偏移地址为栈最底部的字单元的偏移地址+2，
popax的执行过程和push ax刚好相反，由以下两步完成。
（1）将SS:SP指向的内存单元处的数据送入ax中；
（2）SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。
pop操作前的栈顶元素，1000CH处的2266H依然存在，但是，它已不在栈中。
当再次执行push等入栈指令后，SS:SP移至1000CH，并在里面写入新的数据，它将被覆盖。
上面描述了执行push、pop指令时，发生的栈顶超界问题。可以看到，当栈满的时候再使用push 指令入栈，或栈空的时候再使用pop指令出栈，都将发生栈顶超界问题。
8086CPU不保证我们对栈的操作不会超界。
这也就是说，8086CPU只知道栈顶在何处（由SS:SP指示），而不知道我们安排的栈空间有多大。
这点就好像CPU只知道当前要执行的指令在何处（由CS:IP指示），而不知道要执行的指令有多少。
从这两点上我们可以看出8086CPU的工作机理，它只考虑当前的情况：当前的栈顶在何处、当前要执行的指令是哪一条。
push和pop指令是可以在寄存器和内存之间传送数据的。
push和pop指令的格式可以是如下形式：
push 寄存器；将一个寄存器中的数据入栈
pop寄存器；出栈，用一个寄存器接收出栈的数据
push 段寄存器；将一个段寄存器中的数据入栈
pop段寄存器；出栈，用一个段寄存器接收出栈的数据
push和pop也可以在内存单元和内存单元之间传送数据
push内存单元；将一个内存字单元处的字入栈（注意：栈操作都是以字为单位）
pop内存单元；出栈，用一个内存字单元接收出栈的数据
push、pop实质上就是一种内存传送指令，可以在寄存器和内存之间传送数据，
与mov指令不同的是，push和pop指令访问的内存单元的地址不是在指令中给出的，
而是由SS:SP指出的。同时，push和pop指令还要改变SP中的内容。
push和pop指令同mov指令不同，CPU执行mov指令只需一步操作，就是传送，
而执行push、pop指令却需要两步操作。
执行push时，CPU的两步操作是：先改变SP，后向SS:SP处传送。
执行pop时，CPU的两步操作是：先读取SS:SP处的数据，后改变SP。
（1）8086CPU提供了栈操作机制，方案如下。
在SS、SP中存放栈顶的段地址和偏移地址；
提供入栈和出栈指令，它们根据SS:SP指示的地址，按照栈的方式访问内存单元。
（2）push 指令的执行步骤：①SP-SP-2；②向SS:SP指向的字单元中送入数据。
（3）pop指令的执行步骤：①从SS:SP指向的字单元中读取数据；②SP=SP+2。
（4）任意时刻，SS:SP指向栈顶元素。
（5）8086CPU只记录栈顶，栈空间的大小我们要自己管理。
（6）用栈来暂存以后需要恢复的寄存器的内容时，寄存器出栈的顺序要和入栈的顺序相反。
（7）push、pop实质上是一种内存传送指令，注意它们的灵活应用。
将一段内存当作栈段，仅仅是我们在编程时的一种安排，CPU并不会由于这种安排，
就在执行push、pop等栈操作指令时自动地将我们定义的栈段当作栈空间来访问。
如何使得如push、pop等栈操作指令访问我们定义的栈段呢？
前面我们已经讨论过，就是要将SS:SP指向我们定义的栈段。
push、pop等指令在执行的时候只修改SP，所以栈顶的变化范围是0~FFFFH，
从栈空时候的SP=0，一直压栈，直到栈满时SP=0；
如果再次压栈，栈顶将环绕，覆盖了原来栈中的内容。
所以一个栈段的容量最大为64KB。
我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元。
这完全是我们自己的安排。
我们可以用一个段存放数据，将它定义为“数据段”；
我们可以用一个段存放代码，将它定义为“代码段”；
我们可以用一个段当作栈，将它定义为“栈段”。
我们可以这样安排，但若要让CPU按照我们的安排来访问这些段，就要：
对于数据段，将它的段地址放在DS中，用mov、add、sub等访问内存单元的指令时，
CPU就将我们定义的数据段中的内容当作数据来访问；
对于代码段，将它的段地址放在CS中，将段中第一条指令的偏移地址放在IP中，
这样CPU就将执行我们定义的代码段中的指令；
对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地址放在SP中，
这样CPU在需要进行栈操作的时候，比如执行push、pop指令等，
就将我们定义的栈段当作栈空间来用。
检测点3.2
（1）补全下面的程序，使其可以将10000H~1000FH中的8个字，逆序复制到20000H~2000FH中。
逆序复制的含义如图3.17所示（图中内存里的数据均为假设）。
mov ax,1000H 
mov ds,ax 
mov ax,2000h
mov ss,ax
mov sp,0010h
push [0]
push[2]
push [4]
push [6]
push [8]
push [A]
push [C]
push [E]
（2）补全下面的程序，使其可以将10000H~1000FH中的8个字，逆序复制到20000H~2000FH中。
mov ax，2000H 
mov ds，ax 
mov ax,1000h
mov ss,ax
mov sp,0000h
pop[E]
pop[C]
pop[A]
pop[8]
pop[6]
pop[4]
pop[2]
pop[0]
D命令也提供了一种符合CPU机理的格式：“d段寄存器：偏移地址”，
以段寄存器中的数据为段地址SA，列出从SA：偏移地址开始的内存区间中的数据。
在E、A、U这些可以带有内存单元地址的命令中，也可以同D命令一样，
用段寄存器表示内存单元的段地址。
Debug的T命令在执行修改寄存器SS的指令时，下一条指令也紧接着被执行。中断机制
2.实验任务
（1）使用Debug，将下面的程序段写入内存，逐条执行，根据指令执行后的实际运行情况填空。
mov ax，ffff 
mov ds，ax 
mov ax，2200
mov ss，ax 
mov sp，0100
mov ax，[0]；ax=5bea
add ax，[2]；ax=5cca
mov bx，[4]；bx=30f0
add bx，[6]；bx=6024
push ax；sp= 00fe；修改的内存单元的地址是2200:00fe内容为5cca
push bx；sp=00fc；修改的内存单元的地址是2200:00fc内容为6024
pop ax；sp=00fe；ax=6024
pop bx；sp=0100；bx=5cca
push[4]；sp=00fe；修改的内存单元的地址2200:00fe是内容为30f0
push[6]；sp=00fc；修改的内存单元的地址是2200:00fc内容为2f34
一个汇编语言程序从写出到最终执行的简要过程
第一步：编写汇编源程序。
使用文本编辑器，用汇编语言编写汇编源程序。
这一步工作的结果是产生了一个存储源程序的文本文件。
第二步：对源程序进行编译连接。
使用汇编语言编译程序对源程序文件中的源程序进行编译，产生目标文件；
再用连接程序对目标文件进行连接，生成可在操作系统中直接运行的可执行文件。
可执行文件包含两部分内容。
・程序（从源程序中的汇编指令翻译过来的机器码）和数据（源程序中定义的数据）
・相关的描述信息（比如，程序有多大、要占用多少内存空间等）
这一步工作的结果：产生了一个可在操作系统中运行的可执行文件。
第三步：执行可执行文件中的程序。
在操作系统中，执行可执行文件中的程序。
操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，
并进行相关的初始化（比如设置CS:IP指向第一条要执行的指令），然后由CPU执行程序。
在汇编语言源程序中，包含两种指令，一种是汇编指令，一种是伪指令。
汇编指令是有对应的机器码的指令，可以被编译为机器指令，最终为CPU所执行。
而伪指令没有对应的机器指令，最终不被CPU所执行。那么谁来执行伪指令呢？
伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。
segment和ends是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时，
必须要用到的一对伪指令。segment和ends的功能是定义一个段，
segment 说明一个段开始，ends说明一个段结束。一个段必须有一个名称来标识，
使用格式为：
段名segment
段名ends
一个汇编程序是由多个段组成的，这些段被用来存放代码、数据或当作栈空间来使用。
一个源程序中所有将被计算机所处理的信息：指令、数据、栈，被划分到了不同的段中。
end是一个汇编程序的结束标记，编译器在编译汇编程序的过程中，
如果碰到了伪指令end，就结束对源程序的编译。
所以，在我们写程序的时候，如果程序写完了，要在结尾处加上伪指令end。
否则，编译器在编译程序时，无法知道程序在何处结束。
ends是和segment成对使用的，标记一个段的结束，
ends的含义可理解为“end segment”。end的作用是标记整个程序的结束。
assume这条伪指令的含义为“假设”。
它假设某一段寄存器和程序中的某一个用segment...ends定义的段相关联。
通过assume说明这种关联，在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系。
用assume将有特定用途的段和相关的段寄存器关联起来即可。
用汇编语言写的源程序，包括伪指令和汇编指令，我们编程的最终目的是让计算机完成一定的任务。
源程序中的汇编指令组成了最终由计算机执行的程序，而源程序中的伪指令是由编译器来处理的，
它们并不实现我们编程的最终目的。这里所说的程序就是指源程序中最终由计算机执行、处理的指令或数据。
汇编源程序中，除了汇编指令和伪指令外，还有一些标号，比如“codesg”。
一个标号指代了一个地址。比如codesg在segment的前面，作为一个段的名称，
这个段的名称最终将被编译、连接程序处理为一个段的段地址。
能让编译器进行编译的源程序，这样的源程序应该具备起码的结构。
源程序是由一些段构成的。我们可以在这些段中存放代码、数据、或将某个段当作栈空间。
一个程序P2在可执行文件中，则必须有一个正在运行的程序P1，
将P2从可执行文件中加载入内存后，将CPU的控制权交给P2，P2才能得以运行。
P2开始运行后，P1暂停运行。而当P2运行完毕后，
应该将CPU的控制权交还给使它得以运行的程序P1，此后，P1继续运行。
一个程序结束后，将CPU的控制权交还给使它得以运行的程序，
我们称这个过程为：程序返回。那么，如何返回呢？应该在程序的末尾添加返回的程序段。
目的|相关指令|指令性质|指令执行者
通知编译器一个段结束|段名ends|伪指令|编译时，由编译器执行
通知编译器程序结束|end|伪指令|编译时，由编译器执行
程序返回|mov ax，4c00H int21H|汇编指令|执行时，由CPU执行
一般说来，程序在编译时被编译器发现的错误是语法错误，
在源程序编译后，在运行时发生的错误是逻辑错误。
语法错误容易发现，也容易解决。而逻辑错误通常不容易被发现。
好了，我们简单地讲连接的作用，连接的作用有以下几个。
（1）当源程序很大时，可以将它分为多个源程序文件来编译，
每个源程序编译成为目标文件后，再用连接程序将它们连接到一起，生成一个可执行文件；
（2）・程序中调用了某个库文件中的子程序，
需要将这个库文件和该程序生成的目标文件连接到一起，生成一个可执行文件；
（3）一个源程序编译后，得到了存有机器码的目标文件，
目标文件中的有些内容还不能直接用来生成可执行文件，
连接程序将这些内容处理为最终的可执行信息。所以，在只有一个源程序文件，
而又不需要调用某个库中的子程序的情况下，也必须用连接程序对目标文件进行处理，生成可执行文件。
注意，对于连接的过程，可执行文件是我们要得到的最终结果。
为了观察程序的运行过程，可以使用Debug。
Debug可以将程序加载入内存，设置CS:IP指向程序的入口，
但Debug并不放弃对CPU的控制，这样，
我们就可以使用Debug的相关命令来单步执行程序，查看每一条指令的执行结果。
Debug将程序从可执行文件加载入内存后，cx中存放的是程序的长度。
（1）程序加载后，ds中存放着程序所在内存区的段地址，
这个内存区的偏移地址为0，则程序所在的内存区的地址为ds：0；
（2）这个内存区的前256个字节中存放的是PSP，DOS用来和程序进行通信。
从256字节处向后的空间存放的是程序。
所以，从ds中可以得到PSP的段地址SA，PSP的偏移地址为0，则物理地址为SA×16+0。
因为PSP占256（100H）字节，所以程序的物理地址是：
SA×16+0+256=SA×16+16×16+0=（SA+16）×16+0
可用段地址和偏移地址表示为：SA+10H：0。
注意，要使用P命令执行int21。
需要注意的是，在DOS中运行程序时，是command将程序加载入内存，
所以程序运行结束后返回到command中，
而在这里是Debug将程序加载入内存，所以程序运行结束后要返回到Debug中。
使用Q命令退出Debug，将返回到command中，因为Debug是由command加载运行的。
在DOS中用“debug 1.exe”运行Debug对1.exe进行跟踪时，程序加载的顺序是：
command加载Debug，Debug加载1.exe。
返回的顺序是：从1.exe中的程序返回到Debug，从Debug返回到command。

assume cs:codesg
codesg segment
mov ax,0123h
mov bx,0456h
add ax,bx
add ax,ax
mov ax,4c00h
int 21h
codesg ends
end

assume cs:abc 
abc segment 
mov ax,2 
add ax,ax 
add ax,ax 
mov ax,4c00H 
int 21H 
abc ends 
end 

assume cs:codesg
codesg segment
mov ax,2000h
mov ss,ax
mov sp,0
add sp,10
pop ax
pop bx
push ax
push bx
pop ax
pop bx
mov ax,4c00h
int 21h
codesg ends
end
要完整地描述一个内存单元，需要两种信息：①内存单元的地址；②内存单元的长度（类型）。
用[0]表示一个内存单元时，0表示单元的偏移地址，段地址默认在ds中，
单元的长度（类型）可以由具体指令中的其他操作对象（比如说寄存器）指出。
[bx]同样也表示一个内存单元，它的偏移地址在bx中，比如下面的指令：
mov ax，[bx]
将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单元），存放一个字，
偏移地址在bx中，段地址在ds中。
mov al，[bx]
将一个内存单元的内容送入al，这个内存单元的长度为1字节（字节单元），存放一个字节，
偏移地址在bx中，段地址在ds中。
为了描述上的简洁，在以后的课程中，
我们将使用一个描述性的符号“（）”来表示一个寄存器或一个内存单元中的内容。比如：
（ax）表示ax中的内容、（al）表示al中的内容；
（20000H）表示内存20000H单元的内容（()中的内存单元的地址为物理地址）；
（（ds）*16+（bx））表示：
ds中的内容为ADR1，bx中的内容为ADR2，内存ADR1×16+ADR2单元的内容。
也可以理解为：ds中的ADR1作为段地址，bx中的ADR2作为偏移地址，
内存ADR1：ADR2单元的内容。
注意，“（）”中的元素可以有3种类型：①寄存器名；②段寄存器名；
③内存单元的物理地址（一个20位数据）。
我们看一下（X）的应用，比如，
（1）ax中的内容为0010H，可以这样来描述：（ax）=0010H；
（2）2000：1000处的内容为0010H，可以这样来描述：（21000H）=0010H；
（3）对于mov ax，[2]的功能，可以这样来描述：（ax）=（（ds）*16+2）；
（4）对于mov[2]，ax的功能，可以这样来描述：(（ds）*16+2）=（ax）；
（5）对于add ax，2的功能，可以这样来描述：（ax）=（ax）+2；
（6）对于add ax，bx的功能，可以这样来描述：（ax）=（ax）+（bx）；
（7）对于push ax的功能，可以这样来描述：
（sp）=（sp）-2
（（ss）*16+（sp））=（ax）
（8）对于pop ax的功能，可以这样来描述：
（ax）=（（ss）*16+（sp））
（sp）=（sp）+2
（X）所表示的数据有两种类型：①字节；②字。是哪种类型由寄存器名或具体的运算决定，比如：
（al）、（bl）、（cl）等得到的数据为字节型；（ds）、（ax）、（bx）等得到的数据为字型。
（al）=（20000H），则（20000H）得到的数据为字节型；
（ax）=（20000H），则（20000H）得到的数据为字型。
我们用idata表示常量。比如：
mov ax，[idata]就代表mov ax，[1]、mov ax，[2]、mov ax，[3]等。
mov bx，idata 就代表mov bx，1、mov bx，2、mov bx，3等。
mov ds，idata就代表mov ds，1、mov ds，2等，它们都是非法指令。
mov ax，[bx]功能：bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，
将SA:EA处的数据送入ax中。即：（ax）=（（ds）*16+（bx））。
mov[bx]，ax功能：bx中存放的数据作为一个偏移地址EA，段地址SA默认在ds中，
将ax中的数据送入内存SA:EA处。即：（（ds）*16+（bx））=（ax）。
inc bx的含义是bx中的内容加1
mov ax,2000H 
mov ds,ax 
mov bx,1000H 
mov ax,[bx]
inc bx
inc bx 
mov [bx],ax 
inc bx
inc bx 
mov [bx],ax 
inc bx 
mov [bx],al 
inc bx 
mov [bx],al
loop指令的格式是：loop标号，CPU执行loop指令的时候，要进行两步操作，
①（cx）=（cx）-1；②判断cx中的值，不为零则转至标号处执行程序，如果为零则向下执行。
通常我们用loop指令来实现循环功能，cx中存放循环次数。
（1）标号
在汇编语言中，标号代表一个地址，程序5.1中有一个标号s。
它实际上标识了一个地址，这个地址处有一条指令：add ax，ax。
（2）loops CPU执行loop s的时候，要进行两步操作：
①（cx）=（cx）-1；
②判断cx中的值，不为0则转至标号s所标识的地址处执行（这里的指令是add ax，ax），
如果为零则执行下一条指令（下一条指令是mov ax，4c00h）。
（3）以下3条指令
mov cx，11
s:add ax，ax
1oop s
执行loop s时，首先要将（cx）减1，然后若（cx）不为0，
则向前转至s处执行add ax，ax。所以，可以利用cx来控制add ax，ax的执行次数。
从上面的过程中，我们可以总结出用cx和loop指令相配合实现循环功能的3个要点：
（1）在cx中存放循环次数；
（2）loop指令中的标号所标识地址要在前面；
（3）要循环执行的程序段，要写在标号和loop指令的中间。
用cx和loop指令相配合实现循环功能的程序框架如下。
mov cx，循环次数
s：
循环执行的程序段
1oop s

assume cs:code
code segment
mov ax,0ffffh
mov ds,ax
mov bx,6
mov al,[bx]
mov ah,0
mov dx,0
mov cx,3
s:add dx,ax
loop s
mov ax,4c00h
int 21h
code ends
end

注意程序中的第一条指令mov ax，0ffffh。
我们知道，大于9FFFh的十六进制数据A000H、A001H...C000H、C001H...FFFEH、FFFFH等，
在书写的时候都是以字母开头的。
而在汇编源程序中，数据不能以字母开头，所以要在前面加0。
比如，9138h在汇编源程序中可以直接写为“9138h”，而A000h在汇编源程序中要写为“0A000h”。
我们用Debug对这个程序的循环程序段进行跟踪，
现在有这样一个问题：前面的7条指令，即标号s前的指令，已经确定在逻辑上完全正确，
我们不想再一步步地跟踪了，只想跟踪循环的过程。
所以希望可以一次执行完标号s前的指令。
可以用一个新的Debug命令g来达到目的。
g 0012
g 0016
这里的问题是，我们希望将循环一次执行完。可以使用p命令来达到目的。
再次遇到loop指令时，使用p命令来执行，
Debug就会自动重复执行循环中的指令，直到（cx）=0为止。
我们在Debug中写过类似的指令：
mov ax，[0]
表示将ds：0处的数据送入ax中。
但是在汇编源程序中，指令“mov ax，[0]”被编译器当作指令“movax，0”处理。

0BFF:0100 mov ax,2000
0BFF:0103 mov ds,ax 
0BFF:0105 mov al,[0]
0BFF:0108 mov bl,[1] 
0BFF:010C mov cl,[2]
0BFF:0110 mov dl,[3]

MOV AX,2000
MOV DS,AX
MOV AL,[0000]
MOV BL,[0001]
MOV CL,[0002]
MOV DL,[0003]

assume cs:code
code segment
mov ax,2000h
mov ds,ax
mov al,[0]
mov b1,[1]
mov c1,[2]
mov d1,[3]
mov ax,4c00h
int 21h
code ends
end

MOV AX，2000
MoV DS，AX
MOV AL，00
MOV BL，01
MOV CL，02
MOV DL，03
MOV AX，4C00
INT 21
Debug和编译器masm对形如“mov ax，[0]”这类指令在解释上的不同。
我们在Debug中和源程序中写入同样形式的指令：
“mov al，[0]”、“mov bl，[1]”、“mov cl，[2]”、“mov dl，[3]”，
但Debug和编译器对这些指令中的“[idata]”却有不同的解释。
Debug将它解释为“[idata]”是一个内存单元，
“idata”是内存单元的偏移地址；而编译器将“[idata]”解释为“idata”。
那么我们如何在源程序中实现
将内存2000：0、2000：1、20002、2000：3单元中的数据送入al，bl，cl，dl中呢？
目前的方法是，可将偏移地址送入bx寄存器中，用[bx]的方式来访问内存单元。
这样做是可以，可是比较麻烦，我们要用bx来间接地给出内存单元的偏移地址。
我们还是希望能够像在Debug中那样，在“[]”中直接给出内存单元的偏移地址。
这样做，在汇编源程序中也是可以的，
只不过，要在“[]”的前面显式地给出段地址所在的段寄存器。
比如我们可以这样访问2000：0单元：
mov ax，2000h
mov ds，ax
mov al，ds:[0]
比较一下汇编源程序中以下指令的含义。
“mov al，[0]”，含义：（al）=0，将常量0送入al中（与mov al，0含义相同）；
“mov al，ds:[0]”，含义：（al）=（（ds）*16+0），将内存单元中的数据送入al中；
“mov al，[bx]”，含义：（al）=（（ds）*16+（bx）），将内存单元中的数据送入al中；
“mov al，ds:[bx]”，含义：与“mov al，[bx]”相同。
从上面的比较中可以看出：
（1）在汇编源程序中，如果用指令访问一个内存单元，
则在指令中必须用“[...]”来表示内存单元，如果在“[]”里用一个常量idata直接给出内存单元的偏移地址，
就要在“[]”的前面显式地给出段地址所在的段寄存器。比如mov al，ds:[0]
如果没有在“[]”的前面显式地给出段地址所在的段寄存器，比如mov al，[0]
那么，编译器masm将把指令中的“[idata]”解释为“idata”。
（2）如果在“[]”里用寄存器，比如bx，间接给出内存单元的偏移地址，则段地址默认在ds中。
当然，也可以显式地给出段地址所在的段寄存器。
计算ffff:0-ffff:b单元中的数据的和，结果存储在dx中。
assume cs:code
code segment
mov ax,0ffffh
mov ds,ax
mov dx,0
mov al,ds:[0]
mov ah,0
add dx,ax
mov al,ds:[1]
mov ah,0
add dx,ax
mov al,ds:[2]
mov ah,0
add dx,ax
mov al,ds:[3]
mov ah,0
add dx,ax
mov al,ds:[4]
mov ah,0
add dx,ax
mov al,ds:[5]
mov ah,0
add dx,ax
mov al,ds:[6]
mov ah,0
add dx,ax
mov al,ds:[7]
mov ah,0
add dx,ax
mov al,ds:[8]
mov ah,0
add dx,ax
mov al,ds:[9]
mov ah,0
add dx,ax
mov al,ds:[0ah]
mov ah,0
add dx,ax
mov al,ds:[0bh]
mov ah,0
add dx,ax
mov ax,4c00h
int 21h
code ends
end

完整的算法描述如下。
初始化：
（ds）=ffffh 
  X=0
（dx）=0
循环12次：
（a1）=（（ds）*16+X）
（ah）=0
（dx）=（dx）+（ax）
  X=X+1
可见，表示内存单元偏移地址的X应该是一个变量，
因为在循环的过程中，偏移地址必须能够递增。
这样，在指令中，我们就不能用常量来表示偏移地址。
我们可以将偏移地址放到bx中，用[bx]的方式访问内存单元。
在循环开始前设（bx）=0，每次循环，将bx中的内容加1即可。
更详细的算法描述如下。
初始化：
（ds）=ffffh
（bx）=0
（dx）=0
（cx）=12
循环12次：
s:（al）=（（ds）*16+（bx））
（ah）=0
（dx）=（dx）+（ax）
（bx）=（bx）+1
loop s

assume cs:code
code segment
mov ax,0ffffh
mov ds,ax
mov bx,0
mov dx,0
mov cx,12
s:mov al,[bx]
mov ah,0
add dx,ax
inc bx
loop s
mov ax,4c00h
int 21h
code ends
end

在实际编程中，经常会遇到，用同一种方法处理地址连续的内存单元中的数据的问题。
我们需要用循环来解决这类问题，
同时我们必须能够在每次循环的时候按照同一种方法来改变要访问的内存单元的地址。
这时，就不能用常量来给出内存单元的地址（比如，[0]、[1]、[2]中，0、1、2是常量），
而应用变量。“mov al，[bx]”中的bx就可以看作一个代表内存单元地址的变量，
我们可以不写新的指令，仅通过改变bx中的数值，改变指令访问的内存单元。
指令“mov ax，，[bx]”中，内存单元的偏移地址由bx给出，而段地址默认在ds中。
我们可以在访问内存单元的指令中显式地给出内存单元的段地址所在的段寄存器。比如：
（1）mov ax，ds:[bx]
将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单元），存放一个字，
偏移地址在bx中，段地址在ds中。
（2）mov ax，cs:[bx]
将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单元），存放一个字，
偏移地址在bx中，段地址在cs中。
（3）mov ax，ss:[bx]
将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单元），存放一个字，
偏移地址在bx中，段地址在ss中。
（4）mov ax，es:[bx]
将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单元），存放一个字，
偏移地址在bx中，段地址在es中。
（5）mov ax，ss:[0]
将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单元），存放一个字，
偏移地址为0，段地址在ss中。
（6）mov ax，cs:[0]
将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单元），存放一个字，
偏移地址为0，段地址在cs中。
这些出现在访问内存单元的指令中，用于显式地指明内存单元的段地址的
ds: cs: ss: es: 在汇编语言中称为段前缀。
在不能确定一段内存空间中是否存放着重要的数据或代码的时候，不能随意向其中写入内容。
在一般的PC机中，DOS方式下，DOS和其他合法的程序一般都不会使用
0:200-0:2ff（00200h~002ffh）的256个字节的空间。
所以，我们使用这段空间是安全的。
不过为了谨慎起见，在进入DOS后，我们可以先用Debug查看一下，
如果0：200~0：2ff单元的内容都是0的话，则证明DOS和其他合法的程序没有使用这里。
好了，我们总结一下：
（1）我们需要直接向一段内存中写入内容；
（2）这段内存空间不应存放系统或其他程序的数据或代码，否则写入操作很可能引发错误；
（3）DOS方式下，一般情况，0：200-0：2ff空间中没有系统或其他程序的数据或代码；
（4）以后，我们需要直接向一段内存中写入内容时，就使用0：200-0：2ff这段空间。
我们考虑一个问题，将内存ffff:0-ffff:b单元中的数据复制到0：200-0：20b单元中。
分析一下。
（1）0：200-0：20b单元等同于0020：0-0020：b单元，它们描述的是同一段内存空间。
（2）复制的过程应用循环实现，简要描述如下。
初始化：
X=0循环12次：
将ffff:X单元中的数据送入0020：X（需要用一个寄存器中转）X=X+1
（3）在循环中，源始单元ffff:X和目标单元0020：X的偏移地址X是变量。我们用bx来存放。
（4）将0：200~0：20b用0020：0-0020：b描述，
就是为了使目标单元的偏移地址和源始单元的偏移地址从同一数值0开始。
assume cs:code
code segment
mov bx,0
mov cx,12
s:mov ax,0ffffh
mov ds,ax
mov dl,[bx]
mov ax,0020h
mov ds,ax
mov [bx],dl
inc bx
1oop s
mov ax,4c00h
int 21h
code ends
end

assume cs:code
code segment
mov ax,0ffffh
mov ds,ax
mov ax,0020h
mov es,ax
mov bx,0
mov cx,12
s:mov dl,ds:[bx]
mov es:[bx],dl
inc bx
1oop s
mov ax,4c00h
int 21h
code ends
end
使用es存放目标空间0020：0~0020b的段地址，用ds存放源始空间ffff:0-ffff:b的段地址。
在访问内存单元的指令“mov es:[bx]，al”中，显式地用段前缀
“es:”给出单元的段地址，这样就不必在循环中重复设置ds。

（1）编程，向内存0：200-0：23F依次传送数据0-63（3FH）。
地址 0200:0-3F 数据 0-3F
assume cs:code
code segment
mov ax,0200h
mov ds,ax
mov ax,0
mov bx,0
mov cx,40h
s:mov [bx],al
inc ax
inc bx 
loop s
mov ax,4c00h
int 21h
code ends
end
（2）编程，向内存0：200~0：23F依次传送数据0~63（3FH），程序中只能使用9条指令，9条指令中包括“mov ax，4c00h”和“int 21h”。
地址 0200:0-3F 数据 0-3F
assume cs:code
code segment
mov ax,0200h
mov ds,ax
mov bx,0
mov cx,40h
s:mov [bx],bl
inc bx 
loop s
mov ax,4c00h
int 21h
code ends
end

（3）下面的程序的功能是将“mov ax，4c00h”之前的指令复制到内存0：200处，补全程序。上机调试，跟踪运行结果。
地址 0020:0
assume cs:code
code segment
mov ax, cs
mov ds,ax
mov ax,0020h
mov es,ax
mov bx,0
mov cx, 0017h
s:mov al,[bx]
mov es:[bx],al 
inc bx
loop s
mov ax,4c00h
int 21h
code ends
end
前面的程序中，只有一个代码段。现在有一个问题是，如果程序需要用其他空间来存放数据，使用哪里呢？
第5章中，我们讲到要使用一段安全的空间。可哪里安全呢？
第5章中，我们说0：200~0：2FF是相对安全的，可这段空间的容量只有256个字节，
如果我们需要的空间超过256个字节该怎么办呢？
在操作系统的环境中，合法地通过操作系统取得的空间都是安全的，
因为操作系统不会让一个程序所用的空间和其他程序以及系统自己的空间相冲突。
在操作系统允许的情况下，程序可以取得任意容量的空间。
程序取得所需空间的方法有两种，一是在加载程序的时候为程序分配，再就是程序在执行的过程中向系统申请。
加载程序的时候为程序分配空间，我们在前面已经有所体验，比如我们的程序在加载的时候，取得了代码段中的代码的存储空间。
我们若要一个程序在被加载的时候取得所需的空间，则必须要在源程序中做出说明。
我们通过在源程序中定义段来进行内存空间的获取。
上面是从内存空间获取的角度上，谈定义段的问题。
我们再从程序规划的角度来谈一下定义段的问题。大多数有用的程序，都要处理数据，使用栈空间，当然也都必须有指令，
为了程序设计上的清晰和方便，我们一般也都定义不同的段来存放它们。

从规范的角度来讲，我们是不能自己随便决定哪段空间可以使用的，应该让系统来为我们分配。
我们可以在程序中，定义我们希望处理的数据，这些数据就会被编译、连接程序作为程序的一部分写到可执行文件中。
当可执行文件中的程序被加载入内存时，这些数据也同时被加载入内存中。
与此同时，我们要处理的数据也就自然而然地获得了存储空间。
assume cs:code
code segment
dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
mov bx,0
mov ax,0
mov cx,8
s:add ax,cs:[bx]
add bx,2
loop s
mov ax,4c00h
int 21h
code ends
end
解释一下，程序第一行中的“dw”的含义是定义字型数据。dw即“define word”。
在这里，使用dw定义了8个字型数据（数据之间以逗号分隔），它们所占的内存空间的大小为16个字节。
程序中的指令就要对这8个数据进行累加，可这8个数据在哪里呢？
由于它们在代码段中，程序在运行的时候CS中存放代码段的段地址，所以可以从CS中得到它们的段地址。
它们的偏移地址是多少呢？因为用dw定义的数据处于代码段的最开始，所以偏移地址为0，
这8个数据就在代码段的偏移0、2、4、6、8、A、C、E处。
程序运行时，它们的地址就是CS：0、CS：2、CS：4、CS：6、CS：8、CS:A、CS:C、CS:E。
如何让这个程序在编译、连接后可以在系统中直接运行呢？我们可以在源程序中指明程序的入口所在，具体做法如下。
assume cs:code
code segment
dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
start:mov bx,0
mov ax,0
mov cx,8
s:add ax,cs:[bx]
add bx,2
loop s
mov ax,4c00h
int 21h
code ends
end start
在程序的第一条指令的前面加上了一个标号start，而这个标号在伪指令end的后面出现。
这里，我们要再次探讨end的作用。end除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方。
在程序6.2中我们用end指令指明了程序的入口在标号start处，也就是说，“mov bx，0”是程序的第一条指令。
在单任务系统中，可执行文件中的程序执行过程如下。
（1）由其他的程序（Debug、command或其他程序）将可执行文件中的程序加载入内存；
（2）设置CS:IP指向程序的第一条要执行的指令（即程序的入口），从而使程序得以运行；
（3）程序运行结束后，返回到加载者。
现在的问题是，根据什么设置CPU的CS:IP指向程序的第一条要执行的指令？
也就是说，如何知道哪一条指令是程序的第一条要执行的指令？
这一点，是由可执行文件中的描述信息指明的。我们知道可执行文件由描述信息和程序组成，
程序来自于源程序中的汇编指令和定义的数据；
描述信息则主要是编译、连接程序对源程序中相关伪指令进行处理所得到的信息。
我们在程序6.2中，用伪指令end描述了程序的结束和程序的入口。
在编译、连接后，由“end start”指明的程序入口，被转化为一个入口地址，存储在可执行文件的描述信息中。
在程序6.2生成的可执行文件中，这个入口地址的偏移地址部分为：10H。
当程序被加载入内存之后，加载者从程序的可执行文件的描述信息中读到程序的入口地址，设置CS:IP。
这样CPU就从我们希望的地址处开始执行。
归根结底，我们若要CPU从何处开始执行程序，只要在源程序中用“end标号”指明就可以了。
有了这种方法，就可以这样来安排程序的框架：
assume cs:code
code segment
数据
start：
代码
code ends
end start
完成下面的程序，利用栈，将程序中定义的数据逆序存放。
assume cs:codesg
codesg segment
dw 0123h，0456h，0789h，0abch，0defh，0fedh，0cbah，0987h
？
codesg ends
end
程序的思路大致如下。
程序运行时，定义的数据存放在cs：0-cs:F单元中，共8个字单元。依次将这8个字单元中的数据入栈，
然后再依次出栈到这8个字单元中，从而实现数据的逆序存放。
问题是，我们首先要有一段可当作栈的内存空间。如前所述，这段空间应该由系统来分配。
可以在程序中通过定义数据来取得一段空间，然后将这段空间当作栈空间来用。程序如下。
assume cs:codesg
codesg segment
dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
start:mov ax,cs
mov ss,ax
mov sp,30h
mov bx,0
mov cx,8
s:push cs:[bx]
add bx,2
loop s
mov bx,0
mov cx,8
s0:pop cs:[bx]
add bx,2
loop s0
mov ax,4c00h
int 21h
codesg ends
end start
在代码段中定义了16个字型数据，它们的数值都是0。这16个字型数据的值是多少，对程序来说没有意义。
我们用dw定义16个数据，即在程序中写入了16个字型数据，而程序在加载后，将用32个字节的内存空间来存放它们。
这段内存空间是我们所需要的，程序将它用作栈空间。
可见，我们定义这些数据的最终目的是，通过它们取得一定容量的内存空间。
所以我们在描述dw的作用时，可以说用它定义数据，也可以说用它开辟内存空间。
检测点6.1
（1）下面的程序实现依次用内存0：0-0：15单元中的内容改写程序中的数据，完成程序：
assume cs:codesg
codesg segment
dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
start:mov ax,0
mov ds,ax
mov bx,0
mov cx,8
s:mov ax,[bx]
mov cs:[bx],ax
add bx,2
loop s
mov ax,4c00h
int 21h
codesg ends
end start
（2）下面的程序实现依次用内存0：0-0：15单元中的内容改写程序中的数据，数据的传送用栈来进行。
栈空间设置在程序内。完成程序：
assume cs:codesg
codesg segment
dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
dw 0,0,0,0,0,0,0,0,0,0
start:mov ax,cs
mov ss,ax
mov sp,24h
mov ax,0
mov ds,ax
mov bx,0
mov cx,8
s:push [bx]
pop cs:[bx]
add bx,2
loop s
mov ax,4c00h
int 21h
codesg ends
end start
在前面的内容中，我们在程序中用到了数据和栈，将数据、栈和代码都放到了一个段里面。
我们在编程的时候要注意何处是数据，何处是栈，何处是代码。这样做显然有两个问题：
（1）把它们放到一个段中使程序显得混乱；
（2）前面程序中处理的数据很少，用到的栈空间也小，加上没有多长的代码，
放到一个段里面没有问题。但如果数据、栈和代码需要的空间超过64KB，就不能放在一个段中
（一个段的容量不能大于64KB，是我们在学习中所用的8086模式的限制，并不是所有的处理器都这样）。
所以，应该考虑用多个段来存放数据、代码和栈。
怎样做呢？我们用和定义代码段一样的方法来定义多个段，
然后在这些段里面定义需要的数据，或通过定义数据来取得栈空间。
具体做法如下面的程序所示，这个程序实现了和程序6.3一样的功能，
不同之处在于它将数据、栈和代码放到了不同的段中。
assume cs:code,ds:data,ss:stack
data segment 
dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
data ends
stack segment
dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
stack ends
code segment
start:mov ax,stack
mov ss,ax
mov sp,20h
mov ax,data
mov ds,ax
mov bx,0
mov cx,8
s:push [bx]
add bx,2
loop s
mov bx,0
mov cx,8
s0:pop [bx]
add bx,2
loop s0
mov ax,4c00h
int 21h
code ends
end start
（1）定义多个段的方法
这点，我们从程序中可明显地看出，
定义一个段的方法和前面所讲的定义代码段的方法没有区别，只是对于不同的段，
要有不同的段名。
（2）对段地址的引用
现在，程序中有多个段了，如何访问段中的数据呢？
当然要通过地址，而地址是分为两部分的，即段地址和偏移地址。
如何指明要访问的数据的段地址呢？在程序中，段名就相当于一个标号，它代表了段地址。
所以指令“mov ax，data”的含义就是将名称为“data”的段的段地址送入ax。
一个段中的数据的段地址可由段名代表，偏移地址就要看它在段中的位置了。
程序中“data”段中的数据“0abch”的地址就是：data：6。
要将它送入bx中，就要用如下的代码：
mov ax，data
mov ds，ax
mov bx，ds:[6]
我们不能用下面的指令：
mov ds，data
mov bx，ds:[6]
其中指令“mov ds，data”是错误的，因为8086CPU不允许将一个数值直接送入段寄存器中。
程序中对段名的引用，如指令“mov ds，data”中的“data”，
将被编译器处理为一个表示段地址的数值。
（3）“代码段”、“数据段”、“栈段”完全是我们的安排
现在，我们以一个具体的程序来再次讨论一下所谓的“代码段”、“数据段”、“栈段”。
在汇编源程序中，可以定义许多的段，比如在程序6.4中，定义了3个段，
“code”、“data”和“stack”。我们可以分别安排它们存放代码、数据和栈。
那么我们如何让CPU按照我们的这种安排来执行这个程序呢？
下面来看看源程序中对这3个段所做的处理。
①我们在源程序中为这3个段起了具有含义的名称，
用来放数据的段我们将其命名为“data”，用来放代码的段我们将其命名为“code”，
用作栈空间的段命名为“stack”。
这样命名了之后，CPU是否就去执行“code”段中的内容，
处理“data”段中的数据，将“stack”当做栈了呢？
当然不是，我们这样命名，仅仅是为了使程序便于阅读。这些名称同“start”、
“s”、“s0”等标号一样，仅在源程序中存在，CPU并不知道它们。
②我们在源程序中用伪指令“assume cs:code，ds:data，ss:stack”
将cs、ds和ss分别和code、data、stack段相连。
这样做了之后，CPU是否就会将cs指向code，ds指向data，ss指向stack，
从而按照我们的意图来处理这些段呢？
当然也不是，要知道assume是伪指令，是由编译器执行的，
也是仅在源程序中存在的信息，CPU并不知道它们。
我们不必深究assume的作用，
只要知道需要用它将你定义的具有一定用途的段和相关的寄存器联系起来就可以了。
③若要CPU按照我们的安排行事，就要用机器指令控制它，
源程序中的汇编指令是CPU要执行的内容。CPU如何知道去执行它们？
我们在源程序的最后用“end start”说明了程序的入口，
这个入口将被写入可执行文件的描述信息，可执行文件中的程序被加载入内存后，
CPU的CS:IP被设置指向这个入口，从而开始执行程序中的第一条指令。标号
“start”在“code”段中，这样CPU就将code段中的内容当作指令来执行了。
我们在code段中，使用指令：
mov ax，stack
mov ss，ax
mov sp，20h设置ss指向stack，设置ss:sp指向stack：20，
CPU执行这些指令后，将把stack 段当做栈空间来用。
CPU若要访问data段中的数据，则可用ds指向data段，
用其他的寄存器（如bx）来存放data段中数据的偏移地址。
总之，CPU到底如何处理我们定义的段中的内容，是当作指令执行，当作数据访问，
还是当作栈空间，完全是靠程序中具体的汇编指令，
和汇编指令对CS:IP、SS:SP、DS等寄存器的设置来决定的。
（1）将下面的程序编译、连接，用Debug加载、跟踪，然后回答问题。
assume cs:code,ds:data,ss:stack
data segment
dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
data ends
stack segment
dw 0,0,0,0,0,0,0,0
stack ends
code segment
start:mov ax,stack
mov ss,ax
mov sp,16
mov ax,data
mov ds,ax
push ds:[0]
push ds:[2]
pop ds:[2]
pop ds:[0]
mov ax,4c00h
int 21h
code ends
end start
①CPU执行程序，程序返回前，data段中的数据为多少？data段中的数据不变。
②CPU执行程序，程序返回前，cs=2093、ss=2092、ds=2091。
③设程序加载后，code段的段地址为x，则data段的段地址为x-2，stack段的段地址为x-1。
（2）将下面的程序编译、连接，用Debug加载、跟踪，然后回答问题。
assume cs:code,ds:data,ss:stack
data segment
dw 0123h,0456h
data ends
stack segment
dw 0,0
stack ends
code segment
start:mov ax,stack
mov ss,ax
mov sp,16
mov ax,data
mov ds,ax
push ds:[0]
push ds:[2]
pop ds:[2]
pop ds:[0]
mov ax,4c00h
int 21h
code ends
end start
①CPU执行程序，程序返回前，data段中的数据为多少？data段中的数据不变。
②CPU执行程序，程序返回前，cs=2093、ss=2092、ds=2091。
③设程序加载后，code段的段地址为x，则data段的段地址为x-2，stack段的段地址为x-1。
④对于如下定义的段：
name segment
...
name ends
如果段中的数据占N个字节，则程序加载后，该段实际占有的空间为
N>=1
((N-1)/16 + 1)*16 其中除法为整除。
N            N-1
[1-16]->[0-15]
（3）将下面的程序编译、连接，用Debug加载、跟踪，然后回答问题。
assume cs:code,ds:data,ss:stack
code segment
start:mov ax,stack
mov ss,ax
mov sp,16
mov ax,data
mov ds,ax
push ds:[0]
push ds:[2]
pop ds:[2]
pop ds:[0]
mov ax,4c00h
int 21h
code ends
data segment
dw 0123h,0456h
data ends
stack segment
dw 0,0
stack ends
end start
①CPU执行程序，程序返回前，data段中的数据为多少？data段中的数据不变。
②CPU执行程序，程序返回前，cs=2091、ss=2095、ds=2094。
③设程序加载后，code段的段地址为X，则data段的段地址为x+3，stack段的段地址为x+4。
（4）如果将（1）、（2）、（3）题中的最后一条伪指令“end start”改为“end”
（也就是说，不指明程序的入口），则哪个程序仍然可以正确执行？请说明原因。
只有（3）题中的程序可以正确运行，在不指明程序入口的情况下，
程序默认按照顺序从头开始执行，而3个程序中只有程序3的code段位于最开始的部分，
所以只有（3）题中的程序可以正确运行。
（5）程序如下，编写code段中的代码，将a段和b段中的数据依次相加，将结果存到c段中。
assume cs:code
a segment
db 1,2,3,4,5,6,7,8
a ends
b segment
db 1,2,3,4,5,6,7,8
b ends
c segment
db 0,0,0,0,0,0,0,0
c ends
code segment
start:mov ax,c
mov ds,ax
mov ax,b
mov es,ax
mov ax,a
mov ss,ax
mov bx,0
mov cx,8
s:mov al,ss:[bx]
mov [bx],al
mov al,es:[bx]
add [bx],al
inc bx
loop s
mov ax,4c00h
int 21h
code ends
end start
（6）程序如下，编写code段中的代码，用push指令将a段中的前8个字型数据，
逆序存储到b段中。
assume cs:code
a segment
dw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0dh,0eh,0fh,0ffh
a ends
b segment
dw 0,0,0,0,0,0,0,0
b ends
code segment
start:mov ax,a
mov ds,ax
mov ax,b
mov ss,ax
mov sp,10h
mov bx,0
mov cx,8
s:push [bx]
add bx,2
loop s
mov ax,4c00h
int 21h
code ends
end start
（1）and指令：逻辑与指令，按位进行与运算。
例如指令：
mov al，01100011B
and  al，00111011B
执行后：
         al=00100011B
通过该指令可将操作对象的相应位设为0，其他位不变。
例如：
将al的第6位设为0的指令是：and al，10111111B
将al的第7位设为0的指令是：and al，01111111B
将al的第0位设为0的指令是：and al，11111110B
（2）or指令：逻辑或指令，按位进行或运算。
例如指令：
mov al，01100011B
or     al，00111011B
执行后：
         al=01111011B
通过该指令可将操作对象的相应位设为1，其他位不变。
例如：
将al的第6位设为1的指令是：or al，01000000B
将al的第7位设为1的指令是：or al，10000000B
将al的第0位设为1的指令是：or al，00000001B
一个文本编辑过程中，就包含着按照ASCII编码规则进行的编码和解码。
在文本编辑过程中，我们按一下键盘的a键，就会在屏幕上看到“a”。
这是怎样一个过程呢？我们按下键盘的a键，这个按键的信息被送入计算机，
计算机用ASCII码的规则对其进行编码，将其转化为61H存储在内存的指定空间中；
文本编辑软件从内存中取出61H，将其送到显卡上的显存中；
工作在文本模式下的显卡，用ASCⅡ码的规则解释显存中的内容，61H被当作字符“a”，
显卡驱动显示器，将字符“a”的图像画在屏幕上。
我们可以看到，显卡在处理文本信息的时候，是按照ASCIⅡ码的规则进行的。
这也就是说，如果我们要想在显示器上看到“a”，就要给显卡提供“a”的ASCII码，61H。
如何提供？当然是写入显存中。
我们可以在汇编程序中，用….的方式指明数据是以字符的形式给出的，
编译器将把它们转化为相对应的ASCII码。如下面的程序。
assume cs:code,ds:data
data segment 
db 'unIX'
db 'foRK'
data ends
code segment
start:mov al,'a'
mov bl,'b'
mov ax,4c00h
int 21h
code ends
end start
上面的源程序中：
db 'unIX'相当于 db 75H，6EH，49H，58H，
“u”、“n”、“I”、“X”的ASCII码分别为75H、6EH、49H、58H；
db 'foRK'相当于db 66H，6FH，52H，4BH，
“f”、“o”、“R”、“K”的ASCII码分别为66H、6FH、52H、4BH；
mov al，'a'相当于mov al，61H，“a”的ASCII码为61H；
mov bl，'b'相当于mov al，62H，“b”的ASCII码为62H。
下面考虑这样一个问题，在codesg中填写代码，
将datasg中的第一个字符串转化为大写，第二个字符串转化为小写。
assume cs:codesg,ds:datasg
datasg segment 
db 'BaSiC'
db 'iNfOrMaTiOn'
datasg ends
codesg segment
start:
codesg ends
end start
首先分析一下，我们知道同一个字母的大写字符和小写字符对应的ASCIⅡ码是不同的，
比如“A”的ASCIⅡ码是41H，“a”的ASCⅡ码是61H。
要改变一个字母的大小写，实际上就是要改变它所对应的ASCⅡ码。
我们可以将所有的字母的大写字符和小写字符所对应的ASCIⅡ码列出来，
进行一下对比，从中找到规律。
通过对比，我们可以看出来，小写字母的ASCII码值比大写字母的ASCII码值大20H。
这样，我们可以想到，如果将“a”的ASCII码值减去20H，就可以得到“A”；
如果将“A”的ASCII码值加上20H就可以得到“a”。
按照这样的方法，可以将datasg段中的第一个字符串“BaSiC”中的小写字母变成大写，
第二个字符串“iNfOrMaTiOn”中的大写字母变成小写。
要注意的是，对于字符串“BaSiC”，应只对其中的小写字母所对应的ASCIⅡ码进行减20H的处理，
将其转为大写，而对其中的大写字母不进行改变；
对于字符串“iNfOrMaTiOn”，我们应只对其中的大写字母所对应的ASCIⅡ码进行加20H的处理，
将其转为小写，而对于其中的小写字母不进行改变。
这里面就存在着一个前提，程序必须要能够判断一个字母是大写还是小写。
以“BaSiC”讨论，程序的流程将是这样的：
assume cs:codesg,ds:datasg
datasg segment 
db 'BaSiC'
db 'iNfOrMaTiOn'
datasg ends
codesg segment
start:mov ax,datasg
mov ds,ax
mov bx,0
mov cx,5
s:mov al,[bx]
如果（al）>61H，则为小写字母的ASCII码，则：sub al,20H
mov [bx],al
inc bx
1oop s
codesg ends
end start
判断将用到一些我们目前还没有学习到的指令。
现在面临的问题是，用已学的指令来解决这个问题，则不能对字母的大小写进行任何判断。
但是，现实的问题却要求程序必须要能区别对待大写字母和小写字母。那么怎么办呢？
如果一个问题的解决方案，使我们陷入一种矛盾之中。
那么，很可能是我们考虑问题的出发点有了问题，或是说，我们起初运用的规律并不合适。
我们应该重新观察，寻找新的规律。可以看出，就ASCIⅡ码的二进制形式来看，
除第5位（位数从0开始计算）外，大写字母和小写字母的其他各位都一样。
大写字母ASCII码的第5位为0，小写字母的第5位为1。
这样，我们就有了新的方法，一个字母，不管它原来是大写还是小写，
将它的第5位置0，它就必将变为大写字母；
将它的第5位置1，它就必将变为小写字母。
在这个方法中，我们不需要在处理前判断字母的大小写。比如：
对于“BaSiC”中的“B”，按要求，它已经是大写字母了，不应进行改变，
将它的第5位设为0，它还是大写字母，因为它的第5位本来就是0。
用什么方法将一个数据中的某一位置0还是置1？当然是用我们刚刚学过的or和and指令。
完整的程序如下。
assume cs:codesg,ds:datasg
datasg segment 
db 'BaSiC'
db 'iNfOrMaTiOn'
datasg ends
codesg segment
start:mov ax,datasg
mov ds,ax
mov bx,0
mov cx,5
s:mov al,[bx]
and al,11011111B
mov [bx],al
inc bx
loop s
mov bx,5
mov cx,11
s0:mov al,[bx]
or al,00100000B
mov[bx],al
inc bx
loop s0
mov ax,4c00h
int 21h
codesg ends
end start
在前面，我们用[bx]的方式来指明一个内存单元，
还可以用一种更为灵活的方式来指明内存单元：[bx+idata]表示一个内存单元，
它的偏移地址为（bx）+idata（bx中的数值加上idata）。
我们看一下指令mov ax，[bx+200]的含义：
将一个内存单元的内容送入ax，这个内存单元的长度为2个字节（字单元），
存放一个字，偏移地址为bx中的数值加上200，段地址在ds中。
数学化的描述为：（ax）=（（ds）*16+（bx）+200）
该指令也可以写成如下格式（常用）：
mov ax，[200+bx]
mov ax,200[ bx]
mov ax,[ bx].200
有了[bx+idata]这种表示内存单元的方式，
我们就可以用更高级的结构来看待所要处理的数据。我们通过下面的问题来理解这一点。
在codesg中填写代码，将datasg中定义的第一个字符串转化为大写，第二个字符串转化为小写。
按照我们原来的方法，用[bx]的方式定位字符串中的字符。
assume cs:codesg,ds:datasg
datasg segment
db 'BaSiC'
db 'MinIX'
datasg ends
codesg segment
start:mov ax,datasg
mov ds,ax
mov bx,0
mov cx,5
s:mov al,[bx]
and al,11011111b
mov [bx],al
inc bx
loop s
mov bx,5
mov cx,5
s0:mov al,[bx]
or al,00100000b
mov [bx],al
inc bx
loop s0
mov ax,4c00h
int 21h
codesg ends
end start
现在，我们有了[bx+idata]的方式，就可以用更简化的方法来完成上面的程序。
观察datasg段中的两个字符串，一个的起始地址为0，另一个的起始地址为5。
我们可以将这两个字符串看作两个数组，一个从0地址开始存放，另一个从5开始存放。
那么我们可以用[0+bx]和[5+bx]的方式在同一个循环中定位这两个字符串中的字符。
在这里，0和5给定了两个字符串的起始偏移地址，
bx中给出了从起始偏移地址开始的相对地址。
这两个字符串在内存中的起始地址是不一样的，
但是，它们中的每一个字符，从起始地址开始的相对地址的变化是相同的。
改进的程序如下。
assume cs:codesg,ds:datasg
datasg segment
db 'BaSiC'
db 'MinIX'
datasg ends
codesg segment
start:mov ax,datasg
mov ds,ax
mov bx,0
mov cx,5
s:mov al,[bx]
and al,11011111b
mov [bx],al
mov al,[5+bx]
or al,00100000b
mov [5+bx],al
inc bx
loop s
mov ax,4c00h
int 21h
codesg ends
end start
程序也可以写成下面的样子：
assume cs:codesg,ds:datasg
datasg segment
db 'BaSiC'
db 'MinIX'
datasg ends
codesg segment
start:mov ax,datasg
mov ds,ax
mov bx,0
mov cx,5
s:mov al,0[bx]
and al,11011111b
mov 0[bx],al
mov al,5[bx]
or al,00100000b
mov 5[bx],al
inc bx
loop s
mov ax,4c00h
int 21h
codesg ends
end start
如果用高级语言，比如C语言来描述上面的程序，大致是这样的：
char a[5] = "BaSiC";
char b[5] = "MinIX";
main()
{
int i;
i = 0;
do
{
    a[i] = a[i] & 0xDF;
    b[i] = b[i] l 0x20;
    i++;
}
while(i < 5);
}
如果你熟悉C语言的话，可以比较一下这个C程序和上面的汇编程序的相似之处。
尤其注意它们定位字符串中字符的方式。
C语言：a[i]，b[i]
汇编语言：0[bx]，5[bx]
通过比较，我们可以发现，[bx+idata]的方式为高级语言实现数组提供了便利机制。
si和di是8086CPU中和bx功能相近的寄存器，si和di不能够分成两个8位寄存器来使用。
下面的3组指令实现了相同的功能。
（1）mov bx，0
         mov ax，[bx]
（2）mov si，0
         mov ax，[si]
（3）mov di，0
         mov ax，[di]
下面的3组指令也实现了相同的功能。
（1）mov bx，0
         mov ax，[bx+123]
（2）mov si，0
         mov ax，[si+123]
（3）mov di，0
         mov ax,[di+l23]
用si和di 实现将字符串’welcome to masm！”复制到它后面的数据区中。
我们编写的程序大都是进行数据的处理，而数据在内存中存放，
所以我们在处理数据之前首先要搞清楚数据存储在什么地方，也就是说数据的内存地址。
现在我们要对datasg段中的数据进行复制，先来看一下要复制的数据在什么地方，
datasg：0，这是要进行复制的数据的地址。那么复制到哪里去呢？它后面的数据区。
“welcome to masm！”从偏移地址0开始存放，长度为16个字节，
所以，它后面的数据区的偏移地址为16，就是字符串“.....…”存放的空间。
清楚了地址之后，我们就可以进行处理了。
我们用ds:si指向要复制的源始字符串，用ds:di指向复制的目的空间，
然后用一个循环来完成复制。
assume cs: codesg,ds: datasg
datasg segment
db 'welcome to masm!'
db '................'
datasg ends
codesg segment
start:mov ax,datasg
mov ds,ax
mov si,0
mov di,16
mov cx,8
s:mov ax,[si]
mov [di],ax
add si,2
add di,2
loop s
mov ax,4c00h
int 21h
codesg ends
end start
注意，在程序中，用16位寄存器进行内存单元之间的数据传送，
一次复制2个字节，一共循环8次。
我们可以利用[bx（si或di）+idata]的方式，来使程序变得简洁。程序如下。
assume cs: codesg,ds: datasg
datasg segment
db 'welcome to masm!'
db '................'
datasg ends
codesg segment
start:mov ax,datasg
mov ds,ax
mov si,0
mov cx,8
s:mov ax,0[si]
mov 16[si],ax
add si,2
loop s
mov ax,4c00h
int 21h
codesg ends
end start
在前面，我们用[bx（si或di）]和[bx（si或di）+idata]的方式来指明一个内存单元，
我们还可以用更为灵活的方式：[bx+si]和[bx+di]。
[bx+si]和[bx+di]的含义相似，我们以[bx+si]为例进行讲解。
[bx+si]表示一个内存单元，它的偏移地址为（bx）+（si）（即bx中的数值加上si中的数值）。
指令mov ax，[bx+si]的含义如下：
将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单元），存放一个字，
偏移地址为bx中的数值加上si中的数值，段地址在ds中。
数学化的描述为：（ax）=（（ds）*16+（bx）+（si））
该指令也可以写成如下格式（常用）：
mov ax，[bx][si]
[bx+si+idata]和[bx+di+idata]的含义相似，我们以[bx+si+idata]为例进行讲解。
[bx+si+idata]表示一个内存单元，它的偏移地址为（bx）+（si）+idata
（即bx中的数值加上si中的数值再加上idata）。
指令mov ax，[bx+si+idata]的含义如下：
将一个内存单元的内容送入ax，这个内存单元的长度为2字节（字单元），存放一个字，
偏移地址为bx中的数值加上si中的数值再加上idata，段地址在ds中。
数学化的描述为：（ax）=（（ds）*16+（bx）+（si）+idata）
该指令也可以写成如下格式（常用）：
mov ax,[ bx+200+si] 
mov ax,[200+bx+si] 
mov ax,200[ bx][ si]
mov ax,[ bx].200[ si] 
mov ax,[ bx][ si].200
如果我们比较一下前面用到的几种定位内存地址的方法（可称为寻址方式），就可以发现：
（1）[idata]用一个常量来表示地址，可用于直接定位一个内存单元；
（2）[bx]用一个变量来表示内存地址，可用于间接定位一个内存单元；
（3）[bx+idata]用一个变量和常量表示地址，
可在一个起始地址的基础上用变量间接定位一个内存单元；
（4）[bx+si]用两个变量表示地址；
（5）[bx+si+idata]用两个变量和一个常量表示地址。
可以看到，从[idata]一直到[bx+si+idata]，
我们可以用更加灵活的方式来定位一个内存单元的地址。
这使我们可以从更加结构化的角度来看待所要处理的数据。
下面我们通过一个问题的系列来体会CPU提供多种寻址方式的用意，并学习一些相关的编程技巧。
编程，将datasg段中每个单词的头一个字母改为大写字母。
assume cs: codesg,ds: datasg
datasg segment
db '1. file         ' 
db '2. edit         '
db '3. search       '
db '4. view         '
db '5. options      '
db '6. help         '
datasg ends
codesg segment
start:mov ax,datasg
mov ds,ax
mov bx,0
mov cx,6
s:mov al,[bx+3]
and al,11011111b
mov [bx+3],al
add bx,16
loop s
mov ax,4c00h
int 21h
codesg ends
end start
编程，将 datasg 段中每个单词改为大写字母。
assume cs:codesg,ds:datasg
datasg segment
db 'ibm             '
db 'dec             '
db 'dos             '
db 'vax             '
datasg ends
codesg segment
start: mov ax,datasg
mov ds,ax
mov bx,0
mov cx,4
s0:mov dx,cx
mov si,0
mov cx,3
s:mov al,[bx+si]
and al,11011111b
mov [bx+si],al
inc si
loop s
add bx,16
mov cx,dx
loop s0
mov ax,4c00h
int 21h
codesg ends
end start
我们在这里讨论的问题是，程序中经常需要进行数据的暂存，怎样做将更为合理。
这些数据可能是寄存器中的，也可能是内存中的。
我们可以用寄存器暂存它们，但是这不是一个一般化的解决方案，
因为寄存器的数量有限，每个程序中可使用的寄存器都不一样。
我们希望寻找一个通用的方案，来解决这种在编程中经常会出现的问题。
显然，我们不能选择寄存器，那么可以使用的就是内存了。
可以考虑将需要暂存的数据放到内存单元中，需要使用的时候，再从内存单元中恢复。
这样我们就需要开辟一段内存空间。再次改进的程序如下。
assume cs:codesg,ds:datasg
datasg segment
db 'ibm             '
db 'dec             '
db 'dos             '
db 'vax             '
dw 0
datasg ends
codesg segment
start: mov ax,datasg
mov ds,ax
mov bx,0
mov cx,4
s0:mov ds:[40H],cx
mov si,0
mov cx,3
s:mov al,[bx+si]
and al,11011111b
mov [bx+si],al
inc si
loop s
add bx,16
mov cx,ds:[40H]
loop s0
mov ax,4c00h
int 21h
codesg ends
end start
我们使用内存来暂存数据，这一点是确定了的，但是值得推敲的是，
我们用怎样的结构来保存这些数据，而使得我们的程序更加清晰。
一般来说，在需要暂存数据的时候，我们都应该使用栈。
回忆一下，栈空间在内存中，采用相关的指令，如push、pop等，
可对其进行特殊的操作。下面，再次改进我们的程序。
assume cs:codesg,ds:datasg,ss:stacksg
datasg segment
db 'ibm             '
db 'dec             '
db 'dos             '
db 'vax             '
datasg ends
stacksg segment
dw 0,0,0,0,0,0,0,0
stacksg ends
codesg segment
start: mov ax,stacksg
mov ss,ax
mov sp,16
mov ax,datasg
mov ds,ax
mov bx,0
mov cx,4
s0:push cx
mov si,0
mov cx,3
s:mov al,[bx+si]
and al,11011111b
mov [bx+si],al
inc si
loop s
add bx,16
pop cx
loop s0
mov ax,4c00h
int 21h
codesg ends
end start
编程，将datasg段中每个单词的前4个字母改为大写字母。
assume cs: codesg,ss: stacksg,ds: datasg
stacksg segment
dw 0,0,0,0,0,0,0,0
stacksg ends
datasg segment
db '1. display      '
db '2. brows        '
db '3. replace      '
db '4. modify       '
datasg ends
codesg segment
start: mov ax,stacksg
mov ss,ax
mov sp,16
mov ax,datasg
mov ds,ax
mov bx,0
mov cx,4
s0: push cx
mov si,3
mov cx,4
s: mov al,[bx+si]
and al,11011111b
mov [bx+si],al
inc si
loop s
add bx,16
pop cx
loop s0
mov ax,4c00h
int 21h
codesg ends
end start
有两个基本的问题
（1）处理的数据在什么地方？
（2）要处理的数据有多长？
这两个问题，在机器指令中必须给以明确或隐含的说明，否则计算机就无法工作。
我们定义的描述性符号：reg和sreg。
为了描述上的简洁，在以后的课程中，
我们将使用两个描述性的符号reg来表示一个寄存器，用sreg表示一个段寄存器。
reg的集合包括：ax、bx、cx、dx、ah、al、bh、bl、ch、cl、dh、dl、sp、bp、si、di；
sreg的集合包括：ds、ss、cs、es。
bx、si、di和bp
（1）在8086CPU中，只有这4个寄存器可以用在“[..…]”中来进行内存单元的寻址。
比如下面的指令都是正确的：
mov ax，[bx]
mov ax，[bx+si]
mov ax，[bx+di]
mov ax，[bp]
mov ax，[bp+si]
mov ax，[bp+di]
而下面的指令是错误的：
mov ax，[cx]
mov ax，[ax]
mov ax，[dx]
mov ax，[ds]
（2）在[…]中，这4个寄存器可以单个出现，或只能以4种组合出现：
bx和si、bx和di、bp和si、bp和di。比如下面的指令是正确的：
mov ax,[bx]
mov ax,[si]
mov ax,[di]
mov ax,[bp]
mov ax,[bx+si]
mov ax,[bx+di]
mov ax,[bp+si]
mov ax,[bp+di]
mov ax,[bx+si+idata]
mov ax,[bx+di+idata]
mov ax,[bp+si+idata]
mov ax,[bp+di+idata]
下面的指令是错误的：
mov ax，[bx+bp]
mov ax，[si+di]
（3）只要在[.…]中使用寄存器bp，而指令中没有显性地给出段地址，段地址就默认在ss中。比如下面的指令。
mov ax，[bp]含义：（ax）=（（ss）*16+（bp））
mov ax，[bp+idata]含义：（ax）=（（ss）*16+（bp）+idata）
mov ax，[bp+si]含义：（ax）=（（ss）*16+（bp）+（si））
mov ax，[bp+si+idata]含义：（ax）=（（ss）*16+（bp）+（si）+idata）
绝大部分机器指令都是进行数据处理的指令，处理大致可分为3类：读取、写入、运算。
在机器指令这一层来讲，并不关心数据的值是多少，
而关心指令执行前一刻，它将要处理的数据所在的位置。
指令在执行前，所要处理的数据可以在3个地方：
CPU内部、内存、端口（端口将在后面的课程中进行讨论）。
在汇编语言中如何表达数据的位置？汇编语言中用3个概念来表达数据的位置。
（1）立即数（idata）对于直接包含在机器指令中的数据（执行前在CPU的指令缓冲器中），
在汇编语言中称为：立即数（idata），在汇编指令中直接给出。
例：mov ax，1
add bx，2000h
or bx，00010000b
mov al，'a'
（2）寄存器
指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名。
例：mov ax，bx
mov ds，ax
push bx
mov ds:[0]，bx
push ds
mov ss，ax
mov sp，ax
（3）段地址（SA）和偏移地址（EA）指令要处理的数据在内存中，
在汇编指令中可用[X]的格式给出EA，SA在某个段寄存器中。
存放段地址的寄存器可以是默认的，比如：
mov ax，[0]
mov ax，[di]
mov ax，[bx+8]
mov ax，[bx+si]
mov ax，[bx+si+8]
等指令，段地址默认在ds中；
mov ax，[bp]
mov ax，[bp+8]
mov ax，[bp+si]
mov ax，[bp+si+8]
等指令，段地址默认在ss中。
存放段地址的寄存器也可以是显性给出的，比如以下的指令。
mov ax，ds:[bp]含义：（ax）=（（ds）*16+（bp））
mov ax，es:[bx]含义：（ax）=（（es）*16+（bx））
mov ax，ss:[bx+si]含义：（ax）=（（ss）*16+（bx）+（si））
mov ax，cs:[bx+si+8]含义：（ax）=（（cs）*16+（bx）+（si）+8）
当数据存放在内存中的时候，我们可以用多种方式来给定这个内存单元的偏移地址，
这种定位内存单元的方法一般被称为寻址方式。
8086CPU有多种寻址方式，我们在前面的课程中都已经用到了，
这里进行一下总结。
寻址方式小结
寻址方式|含义|名称
[idata]  EA=idata;SA=(ds) 直接寻址
[bx]      EA=(bx);SA=(ds)   寄存器间接寻址
[si]       EA=(si);SA=(ds)    寄存器间接寻址
[di]      EA=(di);SA=(ds)    寄存器间接寻址
[bp]     EA=(bp);SA=(ss)   寄存器间接寻址
[bx+idata] EA=(bx)+idata;SA=(ds)  寄存器相对寻址
[si+idata]  EA=(si)+idata;SA=(ds)  寄存器相对寻址
[di+idata] EA=(di)+idata;SA=(ds)  寄存器相对寻址
[bp+idata] EA=(bp)+idata;SA=(ss)  寄存器相对寻址
[bx+si]  EA=(bx)+(si);SA=(ds)   基址变址寻址
[bx+di] EA=(bx)+(di);SA=(ds)   基址变址寻址
[bp+si] EA=(bp)+(si);SA=(ss)   基址变址寻址
Ibp+di] EA=(bp)+(di);SA=(ss)  基址变址寻址
[bx+si+idata] EA=(bx)+(si)+idata; SA=(ds)  相对基址变址寻址
[bx+di+idata] EA=(bx)+(di)+idata; SA=(ds)  相对基址变址寻址
[bp+si+idata] EA=(bp)+(si)+idata; SA=(ss)  相对基址变址寻址
[bp+di+idata] EA=(bp)+(di)+idata; SA=(ss)  相对基址变址寻址
8086CPU的指令，可以处理两种尺寸的数据，byte和word。
所以在机器指令中要指明，指令进行的是字操作还是字节操作。
对于这个问题，汇编语言中用以下方法处理。
（1）通过寄存器名指明要处理的数据的尺寸。
例如，下面的指令中，寄存器指明了指令进行的是字操作。
mov ax，1
mov bx，ds:[0]
mov ds，ax
mov ds:[0]，ax
inc ax
add ax，1000
下面的指令中，寄存器指明了指令进行的是字节操作。
mov al，1
mov al，bl
mov al，ds:[0]
mov ds:[0]，al
inc al
add al，100
（2）在没有寄存器名存在的情况下，用操作符Xptr指明内存单元的长度，
X在汇编指令中可以为word或byte。
例如，下面的指令中，用word ptr指明了指令访问的内存单元是一个字单元。
mov word ptr ds:[0]，1
inc word ptr [bx]
inc word ptr ds:[0]
add word ptr [bx]，2
下面的指令中，用byte ptr指明了指令访问的内存单元是一个字节单元。
mov byte ptr ds:[0]，1
inc byte ptr [bx]
inc byte ptr ds:[0]
add byte ptr [bx]，2
在没有寄存器参与的内存单元访问指令中，
用word ptr或byte ptr显性地指明所要访问的内存单元的长度是很必要的。
否则，CPU无法得知所要访问的单元是字单元，还是字节单元。
假设我们用Debug查看内存的结果如下：
2000：1000 FF FF FF FF FF FF..……
那么指令：
mov ax，2000H
mov ds，ax
mov byte ptr [1000]，1将使内存中的内容变为：
2000：1000 01 FF FF FF FF FF..……
而指令：
mov ax，2000H
mov ds，ax
mov word ptr [1000H]，1将使内存中的内容变为：
2000：1000 01 00 FF FF FEFE.…
这是因为mov byte ptr [1000H]，1访问的是地址为ds：1000H的字节单元，
修改的是ds：1000H单元的内容；
而mov word ptr[1000H]，1访问的是地址为ds：1000H的字单元，
修改的是ds：1000H和ds：1001H两个单元的内容。
（3）其他方法
有些指令默认了访问的是字单元还是字节单元，
比如，push[1000H]就不用指明访问的是字单元还是字节单元，
因为push指令只进行字操作。
关于DEC公司的一条记录（1982年）如下。
公司名称：DEC
总裁姓名：Ken Olsen
排名：137
收入：40（40亿美元）
著名产品：PDP（小型机）
这些数据在内存中以图8.1所示的方式存放。
可以看到，这些数据被存放在seg段中从偏移地址60H起始的位置，
从seg：60起始以ASCII字符的形式存储了3个字节的公司名称；
从seg：60+3起始以ASCIⅡ字符的形式存储了9个字节的总裁姓名；
从seg：60+0C起始存放了一个字型数据，总裁在富翁榜上的排名；
从seg：60+0E起始存放了一个字型数据，公司的收入；
从seg：60+10起始以ASCII字符的形式存储了3个字节的产品名称。
以上是该公司1982年的情况，到了1988年DEC公司的信息有了如下变化。
（1）Ken Olsen在富翁榜上的排名已升至38位；
（2）DEC的收入增加了70亿美元；
（3）该公司的著名产品已变为VAX系列计算机。
我们提出的任务是，编程修改内存中的过时数据。
首先，我们应该分析一下要修改的数据。
要修改内容是：
（1）（DEC公司记录）的（排名字段）（2）（DEC公司记录）的（收入字段）
（3）（DEC公司记录）的（产品字段）的（第一个字符）、（第二个字符）、（第三个字符）
从要修改的内容，我们就可以逐步地确定修改的方法。
根据上面的分析，程序如下。
mov ax,seg
mov ds,ax
mov bx,60h
mov word ptr [bx+0ch],38
add word ptr [bx+0eh],70
mov si,0
mov byte ptr [bx+10h+si],'V'
inc si 
mov byte ptr [bx+10h+si],'A'
inc si 
mov byte ptr [bx+10h+si],'X'
如果你熟悉C语言的话，我们可以用C语言来描述这个程序，大致应该是这样的：
struct company
{
    char cn[3];
    char hn[9];
    int pm;
    int sr;
    char cp[3];
};
struct company dec={"DEC","Ken Olsen",137,40,"PDP"};
main()
{
    int i;
    dec. pm = 38;
    dec. sr = dec. sr + 70;
    i = 0;
    dec. cp[i] = 'V';
    i++;
    dec. cp[i] = 'A';
    i++;
    dec. cp[i] = 'X';
    return 0;
}
我们再按照C语言的风格，用汇编语言写一下这个程序，注意和C语言相关语句的比对：
mov ax,seg
mov ds,ax
mov bx,60h
mov word ptr [bx].0ch,38
add word ptr [bx].0eh,70
mov si,0
mov byte ptr [bx].10h[si],'V'
inc si
mov byte ptr [ bx].10h[si],'A'
inc si
mov byte ptr [ bx].10h[si],'X'
我们可以看到，8086CPU提供的如[bx+si+idata]的寻址方式为结构化数据的处理提供了方便。
使得我们可以在编程的时候，从结构化的角度去看待所要处理的数据。
从上面可以看到，一个结构化的数据包含了多个数据项，而数据项的类型又不相同，
有的是字型数据，有的是字节型数据，有的是数组（字符串）。
一般来说，我们可以用[bx+idata+si]的方式来访问结构体中的数据。
用bx定位整个结构体，用idata定位结构体中的某一个数据项，用si定位数组项中的每个元素。
为此，汇编语言提供了更为贴切的书写方式，如：
[bx].idata、[bx].idata[si]。
在C语言程序中我们看到，如：dec.cp[i]，
dec是一个变量名，指明了结构体变量的地址，
cp是一个名称，指明了数据项cp的地址，
而i用来定位cp中的每一个字符。
汇编语言中的做法是：bx.10h[si]。看一下，是不是很相似？
div是除法指令，使用div做除法的时候应注意以下问题。
（1）除数：有8位和16位两种，在一个reg或内存单元中。
（2）被除数：默认放在AX或DX和AX中，
如果除数为8位，被除数则为16位，默认在AX中存放；
如果除数为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。
（3）结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数；
如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。
格式如下：
div reg
div 内存单元
现在，我们可以用多种方法来表示一个内存单元了，比如下面的例子：
div byte ptr ds:[0]
含义：（al）=（ax）/（（ds）*16+0）的商
（ah）=（ax）/（（ds）*16+0）的余数
div word ptr es:[0]
含义：（ax）=[（dx）*10000H+（ax）]/（（es）*16+0）的商
（dx）=[（dx）*10000H+（ax）]/（（es）*16+0）的余数
div byte ptr [bx+si+8]
含义：（al）=（ax）/（（ds）*16+（bx）+（si）+8）的商
（ah）=（ax）/（（ds）*16+（bx）+（si）+8）的余数
div word ptr [bx+si+8]
含义：（ax）=[（dx）*10000H+（ax）]/（（ds）*16+（bx）+（si）+8）的商
（dx）=[（dx）*10000H+（ax）]/（（ds）*16+（bx）+（si）+8）的余数
编程，利用除法指令计算100001/100。
首先分析一下，被除数100001大于65535，
不能用ax寄存器存放，所以只能用dx和ax两个寄存器联合存放100001，
也就是说要进行16位的除法。除数100小于255，可以在一个8位寄存器中存放，
但是，因为被除数是32位的，除数应为16位，所以要用一个16位寄存器来存放除数100。
因为要分别为dx和ax赋100001的高16位值和低16位值，
所以应先将100001表示为16进制形式：186A1H。程序如下：
mov dx,0001H
mov ax,86A1H
mov bx,64H
div bx
程序执行后，（ax）=03E8H（即1000），（dx）=1（余数为1）。
读者可自行在Debug中实践。
编程，利用除法指令计算1001/100。
首先分析一下，被除数1001可用ax寄存器存放，除数100可用8位寄存器存放，
也就是说，要进行8位的除法。程序如下。
mov ax，03E9H
mov bl，64H
div bl程序执行后，（al）=0AH（即10），（ah）=1（余数为1）。
读者可自行在Debug中实践。
前面我们用db和dw定义字节型数据和字型数据。
dd是用来定义 dword（double word，双字）型数据的。比如：
data segment
db 1
dw 1
dd 1
data ends
在data段中定义了3个数据：
第一个数据为01H，在data：0处，占1个字节；
第二个数据为0001H，在data：1处，占1个字；
第三个数据为00000001H，在data：3处，占2个字。
用div计算data段中第一个数据除以第二个数据后的结果，商存在第三个数据的存储单元中。
data segment
dd 100001
dw 100
dw 0
data ends思考后看分析。
分析：
data段中的第一个数据是被除数，为dword（双字）型，32位，
所以在做除法之前，用dx和ax存储。
应将data：0字单元中的低16位存储在ax中，data：2字单元中的高16位存储在dx中。
程序如下。
mov ax,data
mov ds,ax
mov ax,ds:[0]
mov dx,ds:[2]
div word ptr ds:[4]
mov ds:[6],ax
dup是一个操作符，在汇编语言中同db、dw、dd等一样，也是由编译器识别处理的符号。
它是和db、dw、dd等数据定义伪指令配合使用的，用来进行数据的重复。比如：
db 3 dup（0）
定义了3个字节，它们的值都是0，相当于db 0,0,0。
db 3 dup（0,1,2）
定义了9个字节，它们是0、1、2、0、1、2、0、1、2，
相当于db 0,1,2,0,1,2,0,1,2。
db 3 dup（'abc','ABC'）
定义了18个字节，它们是'abcABCabcABCabcABC'，
相当于db 'abcABCabcABCabcABC'。
可见，dup的使用格式如下。
db 重复的次数 dup（重复的字节型数据）
dw 重复的次数 dup（重复的字型数据）
dd 重复的次数 dup（重复的双字型数据）
dup是一个十分有用的操作符，比如要定义一个容量为200个字节的栈段，
如果不用dup，则必须：
stack segment
dw 0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0
dw 0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0
dw 0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0
dw 0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0
dw 0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0，0
当然，你可以用dd，使程序变得简短一些，
但是如果要求定义一个容量为1000字节或10000字节的呢？
如果没有dup，定义部分的程序就变得太长了，有了dup就可以轻松解决。如下：
stack seqment
db 200 dup（0）
stack ends
Power idea公司从1975年成立一直到1995年的基本情况如下。
年份    收入（千美元）雇员（人）人均收入（千美元）
1975  16                      3                ？
1976  22                      7                ？
1977  382                    9                ？
1978  1356                 13               ？
1979  2390                 28               ？
1980  8000                 38               ？
...
1995  5937000           17800         ？
下面的程序中，已经定义好了这些数据：
assume cs:codesg
data segment
db '1975','1976',′1977','1978','1979','1980','1981','1982','1983'
db '1984','1985','1986','1987','1988','1989','1990','1991','1992'
db '1993','1994','1995'
dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514
dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000
dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226
dw 11542,14430,15257,17800
data ends
table segment
db 21 dup（'year summ ne ?? '）
table ends
编程，将data段中的数据按如下格式写入到table段中，
并计算21年中的人均收入（取整），结果也按照下面的格式保存在table段中。
提示，可将data段中的数据看成是多个数组，而将table中的数据看成是一个结构型数据的数组，
每个结构型数据中包含多个数据项。
可用bx定位每个结构型数据，用idata定位数据项，用si定位数组项中的每个元素，
对于table中的数据的访问可采用[bx].idata和[bx].idata[si]的寻址方式。
注意，这个程序是到目前为止最复杂的程序，它几乎用到了我们以前学过的所有知识和编程技巧。
所以，这个程序是对我们从前学习的最好的实践总结。请认真完成。
assume cs:codesg
data segment
db '1975','1976','1977','1978','1979','1980','1981','1982','1983'
db '1984','1985','1986','1987','1988','1989','1990','1991','1992'
db '1993','1994','1995'
dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514
dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000
dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226
dw 11542,14430,15257,17800
data ends
table segment
db 21 dup ('year summ ne ?? ')
table ends
codesg segment
start: mov ax,data
mov ds,ax
mov ax,table
mov es,ax
mov si,0
mov di,0
mov bx,0
mov cx,21
s: mov ax,[di]
mov es:[si],ax
mov ax,[di+2]
mov es:[si+2],ax
mov ax,[bx+168]
mov es:[si+10],ax
mov ax,[di+84]
mov es:[si+5],ax
mov dx,[di+86]
mov es:[si+7],dx
div word ptr es:[si+10]
mov es:[si+13],ax
add si,16
add di,4
add bx,2
loop s
mov ax,4c00h
int 21h
codesg ends
end start
可以修改IP，或同时修改CS和IP的指令统称为转移指令。
概括地讲，转移指令就是可以控制CPU执行内存中某处代码的指令。
8086CPU的转移行为有以下几类。
・只修改IP时，称为段内转移，比如：jmp ax。
・同时修改CS和IP时，称为段间转移，比如：jmp 1000：0。
由于转移指令对IP的修改范围不同，段内转移又分为：短转移和近转移。
・短转移IP的修改范围为-128~127。
・近转移IP的修改范围为-32768-32767。
8086CPU的转移指令分为以下几类。
・无条件转移指令（如：jmp）
・条件转移指令
・循环指令（如：loop）
・过程
・中断
这些转移指令转移的前提条件可能不同，但转移的基本原理是相同的。
我们在这一章主要通过深入学习无条件转移指令jmp来理解CPU执行转移指令的基本原理。
操作符offset在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。
比如下面的程序：
assume cs:codesg
codesg segment
start:mov ax,offset start
s:mov ax,offset s
mov ax,4c00h
int 21h
codesg ends
end start
在上面的程序中，offset操作符取得了标号start和s的偏移地址0和3，所以指令：
mov ax，offset start相当于指令mov ax，0，因为start是代码段中的标号，
它所标记的指令是代码段中的第一条指令，偏移地址为0；
mov ax，offsets相当于指令mov ax，3，因为s是代码段中的标号，
它所标记的指令是代码段中的第二条指令，第一条指令长度为3个字节，则s的偏移地址为3。
有如下程序段，添写两条指令，使该程序在运行中将s处的一条指令复制到s0处。
assume cs:codesg
codesg segment
s:mov ax,bx
mov si,offset s
mov di,offset s0
mov ax,cs:[si]
mov cs:[di],ax
s0:nop
nop
mov ax,4c00h
int 21h
codesg ends
end s
jmp为无条件转移指令，可以只修改IP，也可以同时修改CS和IP。
jmp指令要给出两种信息：
（1）转移的目的地址
（2）转移的距离（段间转移、段内短转移，段内近转移）
不同的给出目的地址的方法，和不同的转移位置，对应有不同格式的jmp指令。
下面的几节内容中，我们以给出目的地址的不同方法为主线，
讲解jmp指令的主要应用格式和CPU执行转移指令的基本原理。
jmp short 标号（转到标号处执行指令）
这种格式的jmp指令实现的是段内短转移，它对IP的修改范围为-128~127，
也就是说，它向前转移时可以最多越过128个字节，向后转移可以最多越过127个字节。
jmp指令中的“short”符号，说明指令进行的是短转移。
jmp指令中的“标号”是代码段中的标号，指明了指令要转移的目的地，
转移指令结束后，CS:IP应该指向标号处的指令。
assume cs:codesg
codesg segment
start:mov ax,0
jmp short s 
add ax,1
s:inc ax
mov ax,4c00h
int 21h
codesg ends
end start
上面的程序执行后，ax中的值为1，因为执行jmp short s后，越过了add ax，1，
IP指向了标号s处的inc ax。也就是说，程序只进行了一次ax加1操作。
汇编指令jmp short s对应的机器指令应该是什么样的呢？
我们先看一下别的汇编指令和其相对应的机器指令。
汇编指令机器指令
mov ax,0123h B8 2301
mov ax,ds:[0123h] A1 2301
push ds:[0123h] FF 36 2301
可以看到，在一般的汇编指令中，汇编指令中的idata（立即数），
不论它是表示一个数据还是内存单元的偏移地址，都会在对应的机器指令中出现，
因为CPU执行的是机器指令，它必须要处理这些数据或地址。
对照汇编源程序，我们可以看到，Debug将jmp short s中的s表示为inc ax指令的偏移地址8，
并将jmp short s表示为jmp 0008，表示转移到cs：0008处。
这一切似乎合理，可是当我们查看jmp short s或是jmp 0008所对应的机器码，却发现了一些问题。
jmp 0008（Debug中的表示）或jmp short s（汇编语言中的表示）所对应的机器码为
EB 03，注意，这个机器码中竟不包含转移的目的地址，这意味着，CPU在执行EB03的时，
并不知道转移的目的地址。那么，CPU根据什么进行转移呢？它知道转移到哪里呢？
令人奇怪的是，汇编指令jmp short s中，明明是带有转移的目的地址（由标号s表示）的，
可翻译成机器指令后，怎么目的地址就没了呢？没有了目的地址，CPU如何知道转移到哪里呢？
assume cs:codesg
codesg segment
start:mov ax,0
mov bx,0
jmp short s 
add ax,1
s:inc ax
mov ax,4c00h
int 21h
codesg ends
end start
比较一下程序9.1和9.2用Debug查看的结果，
注意，两个程序中的jmp指令都要使IP指向inc ax指令，
但是程序1的inc ax指令的偏移地址为8，而程序2的inc ax指令的偏移地址为000BH。
我们再来看两个程序中的jmp指令所对应的机器码，都是EB03。
这说明CPU在执行jmp指令的时候并不需要转移的目的地址。
两个程序中的jmp指令的转移目的地址并不一样，一个是cs：0008，另一个是cs：000B，
如果机器指令中包含了转移的目的地址的话，那么它们对应的机器码应该是不同的。
可是它们对应的机器码都是EB03，这说明在机器指令中并不包含转移的目的地址。
如果机器指令中不包含目的地址的话，那么也就是说，
CPU不需要这个目的地址就可以实现对IP的修改。
CPU不是神仙，它只能处理你提供给它的东西，jmp指令的机器码中不包含转移的目的地址，
那么，CPU如何知道将IP改为多少呢？所以，在jmp指令的机器码中，一定包含了某种信息，
使得CPU可以将它当做修改IP的依据。这种信息是什么呢？我们一步步地分析。
我们先简单回忆一下CPU执行指令的过程（如果你需要更多的回忆，可以复习一下2.10节的内容）。
（1）从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲器；
（2）（IP）=（IP）+所读取指令的长度，从而指向下一条指令；
（3）执行指令。转到1，重复这个过程。
按照这个步骤，我们参照图9.2看一下，程序9.2中jmp short s指令的读取和执行过程：
（1）（CS）=0BBDH，（IP）=0006H，CS:IP指向EB03（jmp short s的机器码）；
（2）读取指令码EB03进入指令缓冲器；
（3）（IP）=（IP）+所读取指令的长度=（IP）+2=0008H，CS:IP指向add ax，1；
（4）CPU执行指令缓冲器中的指令EB03；
（5）指令EB03执行后，（IP）=000BH，CS:IP指向inc ax。
从上面的过程中我们看到，CPU将指令EB03读入后，IP指向了下一条指令，
即CS：0008处的add ax，1，接着执行EB03。
如果EB03没有对IP进行修改的话，那么，接下来CPU将执行add ax，1，
可是，CPU执行的EB03却是一条修改IP的转移指令，
执行后（IP）=000BH，CS:IP指向inc ax，CS：0008处的add ax，1没有被执行。
CPU在执行EB03的时候是根据什么修改的IP，使其指向目标指令呢？
就是根据指令码中的03。注意，要转移的目的地址是CS：000B，
而CPU执行EB03时，当前的（IP）=0008H，
如果将当前的IP值加3，使（IP）=000BH，CS:IP就可指向目标指令。
在转移指令EB03中并没有告诉CPU要转移的目的地址，
却告诉了CPU要转移的位移，即将当前的IP向后移动3个字节。
因为程序1、2中的jmp指令转移的位移相同，都是向后3个字节，所以它们的机器码都是EB03。
原来如此，在“jmp short 标号”指令所对应的机器码中，
并不包含转移的目的地址，而包含的是转移的位移。
这个位移，是编译器根据汇编指令中的“标号”计算出来的，具体的计算方法如图9.3所示。
实际上，“jmp short 标号”的功能为：（IP）=（IP）+8位位移。
（1）8位位移=标号处的地址-jmp指令后的第一个字节的地址；
（2）short 指明此处的位移为8位位移；
（3）8位位移的范围为-128~127，用补码表示（如果你对补码还不了解，请阅读附注2）；
（4）8位位移由编译程序在编译时算出。
还有一种和“jmp short 标号”功能相近的指令格式，jmp near ptr 标号，它实现的是段内近转移。
“jmp near ptr 标号”的功能为：（IP）=（IP）+16位位移。
（1）16位位移=标号处的地址-jmp指令后的第一个字节的地址；
（2）near ptr指明此处的位移为16位位移，进行的是段内近转移；
（3）16位位移的范围为-32768~32767，用补码表示；
（4）16位位移由编译程序在编译时算出。
前面讲的jmp指令，其对应的机器指令中并没有转移的目的地址，而是相对于当前IP的转移位移。
“jmp far ptr 标号”实现的是段间转移，又称为远转移。功能如下：
（CS）=标号所在段的段地址；（IP）=标号在段中的偏移地址。
far ptr指明了指令用标号的段地址和偏移地址修改CS和IP。
assume cs:codesg
codesg segment
start:mov ax,0
mov bx,0
jmp far ptr s
db 256 dup (0)
s:add ax,1
inc ax
mov ax,4c00h
int 21h
codesg ends
end start
我们要注意一下jmp far ptr s所对应的机器码：EA 0B01 BD0B，
其中包含转移的目的地址。“0B01 BD0B”是目的地址在指令中的存储顺序，
高地址的“BD0B”是转移的段地址：0BBDH，低地址的“0B01”是偏移地址：010BH。
1.向前转移
s:
...
jmp s（jmp short s、jmp near ptr s、jmp far ptr s）
编译器中有一个地址计数器（AC），编译器在编译程序过程中，每读到一个字节AC就加1。
当编译器遇到一些伪操作的时候，也会根据具体情况使AC增加，如db、dw等。
在向前转移时，编译器可以在读到标号s后记下AC的值as，在读到jmp..…s后记下AC的值aj。
编译器可以用as-aj算出位移量disp。
此时，编译器作如下处理。
（1）如果disp属于[-128，127]，则：
对于jmp s、jmp short s将产生jmp short s所对应的机器码
jmp short s所对应的机器码格式为：EB disp（占两个字节）
jmp near ptr s
对于jmp near ptr s将产生jmp near ptr s所对应的机器码，
jmp near ptr s所对应的机器码格式为：E9 disp（占3个字节）；
jmp far ptr s
对于jmp far ptr s将产生相应的编码，
jmp far ptr s所对应的机器码格式为：EA 偏移地址段地址（占5个字节）。
（2）如果disp属于[-32768，32767]，则：
对于jmp short s将产生编译错误；
对于jmp s、jmp near ptr s将产生jmp near ptr s所对应的机器码，
jmp near ptr s所对应的机器码格式为：E9 disp（占3个字节）；
对于jmp far ptr s将产生相应的编码，
jmp far ptr s所对应的机器码格式为：EA 偏移地址段地址（占5个字节）。
2.向后转移
jmp s（jmp short s、jmp near ptr s、jmp far ptr s）
...
s
在这种情况下，编译器先读到jmp...s指令。
由于它还没有读到标号s，所以编译器此时还不能确定标号s处的AC值。
也就是说，编译器不能确定位移量disp的大小。
此时，记下jmp...s指令的位置和AC的值aj，当向后读到标号s时，记下AC的值as，
并计算出转移的位移量：disp=as-aj。
此时，编译器作如下处理。
（1）当disp属于[-128，127]时，则：
对于jmp s、jmp short s将产生jmp short s所对应的机器码
jmp short s所对应的机器码格式为：EB disp（占两个字节）
jmp near ptr s
对于jmp near ptr s将产生jmp near ptr s所对应的机器码，
jmp near ptr s所对应的机器码格式为：E9 disp（占3个字节）；
jmp far ptr s
对于jmp far ptr s将产生相应的编码，
jmp far ptr s所对应的机器码格式为：EA 偏移地址段地址（占5个字节）。
（2）当disp属于[-32768，32767]时，则：
对于jmp short s将产生编译错误；
对于jmp s、jmp near ptr s将产生jmp near ptr s所对应的机器码，
jmp near ptr s所对应的机器码格式为：E9 disp（占3个字节）；
对于jmp far ptr s将产生相应的编码，
jmp far ptr s所对应的机器码格式为：EA 偏移地址段地址（占5个字节）。
转移地址在寄存器中的jmp指令
jmp 16位reg 功能：（IP）=（16位reg）
转移地址在内存中的jmp指令有两种格式：
（1）jmp word ptr 内存单元地址（段内转移）
功能：从内存单元地址处开始存放着一个字，是转移的目的偏移地址。
内存单元地址可用寻址方式的任一格式给出。
比如，下面的指令：
mov ax,0123H
mov ds:[0],ax
jmp word ptr ds:[0]
执行后，（IP）=0123H。
又比如，下面的指令：
mov ax,0123H
mov [bx],ax
jmp word ptr [bx]
执行后，（IP）=0123H
（2）jmp dword ptr 内存单元地址（段间转移）
功能：从内存单元地址处开始存放着两个字，
高地址处的字是转移的目的段地址，低地址处是转移的目的偏移地址。
（CS）=（内存单元地址+2）
（IP）=（内存单元地址）
内存单元地址可用寻址方式的任一格式给出。
比如，下面的指令：
mov ax,0123H
mov ds:[0],ax
mov word ptr ds:[2],0
jmp dword ptr ds:[0]
执行后，（CS）=0，（IP）=0123H，CS:IP指向0000：0123
又比如，下面的指令：
mov ax,0123H
mov[bx],ax
mov word ptr [bx+2],0
jmp dword ptr [bx]
执行后，（CS）=0，（IP）=0123H，CS:IP指向0000：0123
检测点9.1
（1）程序如下。
assume cs:code
data segment
db 8 dup (0)
data ends
code segment
start:mov ax,data
mov ds,ax
mov bx,0
jmp word ptr [bx+1]
mov ax,4c00h
int 21h
code ends
end start
若要使程序中的jmp指令执行后，CS:IP指向程序的第一条指令，在data段中应该定义哪些数据？
db 8 dup (0)
（2）程序如下。
assume cs:code
data segment
dd 12345678H
data ends
code segment
start:mov ax,data
mov ds,ax
mov bx,0
mov [bx],offset start
mov [bx+2],cs
jmp dword ptr ds:[0]
mov ax,4c00h
int 21h
code ends
end start
补全程序，使jmp指令执行后，CS:IP指向程序的第一条指令。
（3）用Debug查看内存，结果如下：
2000：1000 BE 00 06 00 00 00..
则此时，CPU执行指令：
mov ax,2000H
mov es,ax
jmp dword ptr es:[1000H]
后，（CS）=0006H，（IP）= 00BEH
jcxz指令为有条件转移指令，所有的有条件转移指令都是短转移，
在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为：-128~127。
指令格式：jcxz 标号（如果（cx）=0，转移到标号处执行。）
操作：当（cx）=0时，（IP）=（IP）+8位位移；
8位位移=标号处的地址一jcxz指令后的第一个字节的地址；
8位位移的范围为-128~127，用补码表示；
8位位移由编译程序在编译时算出。
当（cx）不等于0时，什么也不做（程序向下执行）。
我们从jcxz的功能中可以看出，“jcxz标号”的功能相当于：
if（（cx）==0）jmp short 标号；
（这种用C语言和汇编语言进行的综合描述，或许能使你对有条件转移指令理解得更加清楚。）
捡测点9.2
补全编程，利用jcxz指令，实现在内存2000H段中查找第一个值为0的字节，
找到后，将它的偏移地址存储在dx中。
assume cs:code
code segment
start:mov ax,2000H
mov ds,ax
mov bx,0
s: mov cl,[bx]
mov ch,0
jcxz ok
inc bx
jmp short s
ok:mov dx,bx
mov ax,4c00h
int 21h
code ends
end start
loop指令为循环指令，所有的循环指令都是短转移，
在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都为：-128~127。
指令格式：loop 标号（（cx）=（cx）-1，如果（cx）不等于0，转移到标号处执行。）
操作：
（1）（cx）=（cx）-1；
（2）如果（cx）不等于0，（IP）=（IP）+8位位移。
8位位移=标号处的地址-loop指令后的第一个字节的地址；
8位位移的范围为-128~127，用补码表示；
8位位移由编译程序在编译时算出。
如果（cx）=0，什么也不做（程序向下执行）。
我们从loop的功能中可以看出，“loop 标号”的功能相当于：
（cx）--；if（（cx）不等于0）jmp short 标号；
检测点9.3
补全编程，利用loop指令，实现在内存2000H段中查找第一个值为0的字节，
找到后，将它的偏移地址存储在dx中。
dec指令的功能和inc相反，dec bx进行的操作为：（bx）=（bx）-1
assume cs:code
code segment
start:mov ax,2000H
mov ds,ax
mov bx,0
s: mov cl,[bx]
mov ch,0
inc cx
inc bx
loop s
ok:dec bx
mov dx,bx
mov ax,4c00h
int 21h
code ends
end start
前面我们讲到：
jmp short 标号
jmp near ptr 标号
jcxz 标号
loop 标号
等几种汇编指令，它们对IP的修改是根据转移目的地址和转移起始地址之间的位移来进行的。
在它们对应的机器码中不包含转移的目的地址，而包含的是到目的地址的位移。
这种设计，方便了程序段在内存中的浮动装配。
例如：
汇编指令         机器代码
mov cx，6      B90600
mov ax，10h  B81000
s:add ax,ax     01C0
loop s            E2FC
这段程序装在内存中的不同位置都可正确执行，
因为loop s在执行时只涉及s的位移（-4，前移4个字节，补码表示为FCH），而不是s的地址。
如果loop s的机器码中包含的是s的地址，则就对程序段在内存中的偏移地址有了严格的限制，
因为机器码中包含的是s的地址，如果s处的指令不在目的地址处，程序的执行就会出错。
而loop s的机器码中包含的是转移的位移，就不存在这个问题了，
因为，无论s处的指令的实际地址是多少，loop指令的转移位移是不变的。
注意，根据位移进行转移的指令，它们的转移范围受到转移位移的限制，
如果在源程序中出现了转移范围超界的问题，在编译的时候，编译器将报错。
assume cs:code
code segment
start:jmp short s
db 128 dup(0)
s:mov ax,0ffffh
mov ax,4c00h
int 21h
code ends
end start
 jmp short s的转移范围是-128~127，IP最多向后移动127个字节。
注意，我们在第2章中讲到的形如“jmp 2000：0100”的转移指令，
是在Debug中使用的汇编指令，汇编编译器并不认识。如果在源程序中使用，编译时也会报错。
分析下面的程序，在运行前思考：这个程序可以正确返回吗？
运行后再思考：为什么是这种结果？通过这个程序加深对相关内容的理解。
assume cs:codesg
codesg segment
mov ax,4c00h
int 21h
start:mov ax,0
s:nop
nop
mov di,offset s
mov si,offset s2
mov ax,cs:[si]
mov cs:[di],ax
s0:jmp short s
s1:mov ax,0
int 21h
mov ax,0
s2:jmp short s1
nop
codesg ends
end start
指令jmp short s1占2字节，指令mov di, offset s将s的偏移地址传送到DI，
mov si, offset s2将s2的偏移地址传送到SI，然后再通过ax做中转将s2处的指令复制到s处，
最后再跳转至s处执行复制过来的指令。
jmp short s1是相对跳转，其直接修改IP寄存器，
从s2到s1共有10个字节的偏移(jmp short s1指令后的第一个字节的地址)，
实际上 jmp short s1等价于(ip)=(ip)-10，
所以执行复制过来的指令后，IP将指向0，程序按照顺序执行mov ax, 4c00h和int 21h，正确返回。
编程：在屏幕中间分别显示绿色、绿底红色、白底蓝色的字符串‘welcome to masm！'。
编程所需的知识通过阅读、分析下面的材料获得。
80×25彩色字符模式显示缓冲区（以下简称为显示缓冲区）的结构：
内存地址空间中，B8000H~BFFFFH共32KB的空间，为80×25彩色字符模式的显示缓冲区。
向这个地址空间写入数据，写入的内容将立即出现在显示器上。
在80×25彩色字符模式下，显示器可以显示25行，每行80个字符，
每个字符可以有256种属性（背景色、前景色、闪烁、高亮等组合信息）。
这样，一个字符在显示缓冲区中就要占两个字节，分别存放字符的ASCII码和属性。
80×25模式下，一屏的内容在显示缓冲区中共占4000个字节。
显示缓冲区分为8页，每页4KB（约等于4000B），显示器可以显示任意一页的内容。
一般情况下，显示第0页的内容。
也就是说通常情况下，B8000H~B8F9FH中的4000个字节的内容将出现在显示器上。
在一页显示缓冲区中：
偏移000~09F对应显示器上的第1行（80个字符占160个字节）；
一个字符在显示缓冲区中就要占两个字节，分别存放字符的ASCII码和属性
偏移0A0~13F对应显示器上的第2行；
偏移140~1DF对应显示器上的第3行；
偏移1E0~27F对应显示器上的第4行；
偏移280~31F对应显示器上的第5行；
偏移320~3BF对应显示器上的第6行；
偏移3C0~45F对应显示器上的第7行；
偏移460~4FF对应显示器上的第8行；
偏移500~59F对应显示器上的第9行；
偏移5A0~63F对应显示器上的第10行；
偏移640~6DF对应显示器上的第11行；
偏移6E0~77F对应显示器上的第12行；
偏移780~81F对应显示器上的第13行；
偏移820~8BF对应显示器上的第14行；
偏移8C0~95F对应显示器上的第15行；
偏移960~9FF对应显示器上的第16行；
偏移A00~A9F对应显示器上的第17行；
偏移AA0~B3F对应显示器上的第18行；
偏移B40~BDF对应显示器上的第19行；
偏移BE0~C7F对应显示器上的第20行；
偏移C80~D1F对应显示器上的第21行；
偏移D20~DBF对应显示器上的第22行；
偏移DC0~E5F对应显示器上的第23行；
偏移E60~EFF对应显示器上的第24行；
依此类推，可知，偏移F00~F9F对应显示器上的第25行。
在一行中，一个字符占两个字节的存储空间（一个字），
低位字节存储字符的ASCII码，高位字节存储字符的属性。一行共有80个字符，占160个字节。
即在一行中：
00~01单元对应显示器上的第1列；
02~03单元对应显示器上的第2列；
04~05单元对应显示器上的第3列；
依此类推，可知，9E~9F单元对应显示器上的第80列。
例：在显示器的0行0列显示黑低绿色的字符串'ABCDEF'
（A'的ASCII码值为41H，02H表示黑底绿色）显示缓冲区里的内容为：
                  00 01 02 03 04 05 06 07 08 09 0A 0B...0E 0F 
B800:0000 41 02 42 02 43 02 44 02 45 02 46  02......
B800:00A0 ................
可以看出，在显示缓冲区中，偶地址存放字符，奇地址存放字符的颜色属性。
一个在屏幕上显示的字符，具有前景（字符色）和背景（底色）两种颜色，
字符还可以以高亮度和闪烁的方式显示。前景色、背景色、闪烁、高亮等信息被记录在属性字节中。
属性字节的格式：
      7    654 3 210
含义BL RGB I  RGB
    闪烁 背景 高亮 前景
R：红色G：绿色B：蓝色
可以按位设置属性字节，从而配出各种不同的前景色和背景色。
比如：
红底绿字，属性字节为：01000010B；
红底闪烁绿字，属性字节为：11000010B；
红底高亮绿字，属性字节为：01001010B；
黑底白字，属性字节为：00000111B；
白底蓝字，属性字节为：01110001B。
例：在显示器的0行0列显示红底高亮闪烁绿色的字符串'ABCDEF'
（红底高亮闪烁绿色，属性字节为：11001010B，CAH）
显示缓冲区里的内容为：
                  00 01 02 03 04 05 06 07 08 09 0A 0B...0E 0F 
B800:0000 41 CA 42 CA 43 CA 44 CA 45 CA 46  CA......
B800:00A0 ................
注意，闪烁的效果必须在全屏DOS方式下才能看到。
assume cs:code
data segment
db 'welcome to masm!'
data ends
code segment
start:mov ax,data
mov ds,ax
mov ax,0B800H
mov es,ax
mov si,0
mov di,0
mov cx,16
s:mov al,[si]
mov ah,10000010B
mov es:[di+1664],ax
mov ah,10100100B
mov es:[di+1824],ax
mov ah,11110001B
mov es:[di+1984],ax
inc si
add di,2
loop s
mov ax,4c00h
int 21h
code ends
end start
call和ret指令都是转移指令，它们都修改IP，或同时修改CS和IP。
它们经常被共同用来实现子程序的设计。这一章，我们讲解call和ret指令的原理。
ret指令用栈中的数据，修改IP的内容，从而实现近转移；
retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移。
CPU执行ret指令时，进行下面两步操作：
（1）（IP）=（（ss）*16+（sp））
（2）（sp）=（sp）+2
CPU执行retf指令时，进行下面4步操作：
（1）（IP）=（（ss）*16+（sp））
（2）（sp）=（sp）+2
（3）（CS）=（（ss）*16+（sp））
（4）（sp）=（sp）+2
可以看出，如果我们用汇编语法来解释ret和retf指令，则：
CPU执行ret指令时，相当于进行：
pop IP
CPU执行retf指令时，相当于进行：
pop IP
pop CS
例：
下面的程序中，ret指令执行后，（IP）=0，CS:IP指向代码段的第一条指令。
assume cs:code
stack segment
db 16 dup (0)
stack ends
code segment
mov ax,4c00h
int 21h
start:mov ax,stack
mov ss,ax
mov sp,16
mov ax,0
push ax
mov bx,0
ret
code ends
end start
下面的程序中，retf指令执行后，CS:IP指向代码段的第一条指令。
assume cs:code
stack segment
db 16 dup(0)
stack ends
code segment
mov ax,4c00h
int 21h
start:mov ax,stack
mov ss,ax
mov sp,16
mov ax,0
push cs
push ax
mov bx,0
retf
code ends
end start
检测点10.1
补全程序，实现从内存1000：0000处开始执行指令。
assume cs:code
stack segment
db 16 dup (0)
stack ends
code segment
start:mov ax,stack
mov ss,ax
mov sp,16
mov ax,1000h
push ax
mov ax,0000h
push ax
retf
code ends
end start
CPU执行call指令时，进行两步操作：
（1）将当前的IP或CS和IP压入栈中；
（2）转移。
call 指令不能实现短转移，除此之外，call 指令实现转移的方法和imp指令的原理相同，
下面的几个小节中，我们以给出转移目的地址的不同方法为主线，讲解call 指令的主要应用格式。
call 标号（将当前的IP压栈后，转到标号处执行指令）
CPU执行此种格式的call指令时，进行如下的操作：
（1）（sp）=（sp）-2
（（ss）*16+（sp））=（IP）
（2）（IP）=（IP）+16位位移。
16位位移=标号处的地址-call指令后的第一个字节的地址；
16位位移的范围为-32768~32767，用补码表示；
16位位移由编译程序在编译时算出。
从上面的描述中，可以看出，如果我们用汇编语法来解释此种格式的call指令，则：
CPU执行“call 标号”时，相当于进行：
push IP
jmp near ptr 标号
检测点10.2
下面的程序执行后，ax中的数值为多少？
内存地址 机器码   汇编指令
1000：0 b80000  mov ax，0
1000：3 e80100  call s
1000：6 40          inc ax
1000：7 58        s:pop ax
CPU读取指令 call s 之后，ip指向下条指令地址 ip = 6。
执行call s指令时 ip = 6，ax中的数值为6
stack segment
db 16 dup (0)
stack ends
code segment
start:mov ax,stack
mov ss,ax
mov sp,16
mov ax,0
call s
inc ax
s:pop ax
mov ax,4c00h
int 21h
code ends
end start
前面讲的call指令，其对应的机器指令中并没有转移的目的地址，而是相对于当前IP的转移位移。
“call far ptr 标号”实现的是段间转移。
CPU执行此种格式的call指令时，进行如下的操作。
（1）（sp）=（sp）-2
（（ss）*16+（sp））=（CS）
（sp）=（sp）-2
（（ss）*16+（sp））=（IP）
（2）（CS）=标号所在段的段地址
（IP）=标号在段中的偏移地址
从上面的描述中可以看出，如果我们用汇编语法来解释此种格式的call指令，则：
CPU执行“call far ptr标号”时，相当于进行：
push CS
push IP
jmp far ptr 标号
检测点10.3
下面的程序执行后，ax中的数值为多少？
内存地址 机器码            汇编指令
1000：0 b80000          mov ax，0
1000：3 9A09000010  call far ptr s
1000：8 40                   inc ax
1000：9 58                s:pop ax   ax = 8
                                     add ax,ax ax = 10h
                                     pop bx    bx = 1000h
                                     add ax,bx ax = 1010h
CPU读取指令 call far ptr s 之后，ip指向下条指令地址 ip = 8 cs = 1000h。
执行call far ptr s指令时  ip = 8 cs = 1000h
指令格式：call 16位reg
功能：
（sp）=（sp）-2
（（ss）*16+（sp））=（IP）
（IP）=（16位reg）
用汇编语法来解释此种格式的call指令，CPU执行“call 16位reg”时，相当于进行：
push IP
jmp 16位reg
检测点10.4
下面的程序执行后，ax中的数值为多少？
内存地址 机器码     汇编指令
1000：0 b8 0600  mov ax,6
1000：3 ff d0        call ax
1000：5 40           inc ax
1000：6                mov bp,sp ss:[sp]=5
                             add ax,[bp] ss:[bp]=5 ax = 000bh
CPU读取指令 call ax 之后，ip指向下条指令地址 ip =5 。
执行call ax指令时  ip = 5
转移地址在内存中的call指令有两种格式。
（1）call word ptr 内存单元地址
用汇编语法来解释此种格式的call指令，则：
CPU执行“call word ptr 内存单元地址”时，相当于进行：
push IP
jmp word ptr 内存单元地址
比如，下面的指令：
mov sp,10h
mov ax,0123h
mov ds:[0],ax
call word ptr ds:[0]
执行后，（IP）=0123H，（sp）=0EH。
（2）call dword ptr 内存单元地址
用汇编语法来解释此种格式的call指令，则：
CPU执行“call dword ptr 内存单元地址”时，相当于进行：
push CS
push IP
jmp dword ptr 内存单元地址
比如，下面的指令：
mov sp,10h
mov ax,0123h
mov ds:[0],ax
mov word ptr ds:[2],0
call dword ptr ds:[0]
执行后，（CS）=0，（IP）=0123H，（sp）=0CH。
检测点10.5
（1）下面的程序执行后，ax中的数值为多少？
（注意：用call指令的原理来分析，不要在Debug中单步跟踪来验证你的结论。
对于此程序，在Debug中单步跟踪的结果，不能代表CPU的实际执行结果。）
assume cs:code
stack segment
dw 8 dup (0)
stack ends
code segment
start:mov ax,stack
mov ss,ax
mov sp,16
mov ds,ax
mov ax,0
call word ptr ds:[0EH]
inc ax ax = 1
inc ax ax = 2
inc ax ax = 3
mov ax,4c00h
int 21h
code ends
end start
CPU读取指令 call word ptr ds:[0EH] 之后，ip指向下条指令inc ax的地址  。
当执行call word ptr ds:[0EH]时，执行两步操作，
第一步将原IP值入栈，第二步将ds:[0EH]处的值赋值给IP。实际上这两步操作的是同一个内存单元。
执行指令之后，ip指向下条指令inc ax的地址 
（2）下面的程序执行后，ax和bx中的数值为多少？
assume cs:code
data segment
dw 8 dup (0)
data ends
code segment
start:mov ax,data
mov ss,ax
mov sp,16
mov word ptr ss:[0],offset s
mov ss:[2],cs
call dword ptr ss:[0]
nop
s:mov ax,offset s
sub ax,ss:[0cH] ax = 0001h
mov bx,cs
sub bx,ss:[0eH] bx = 0000h
mov ax,4c00h
int 21h
code ends
end start
CPU读取指令 call dword ptr ss:[0] 之后，ip指向下条指令nop的地址  。
当执行call dword ptr ss:[0]时，执行两步操作，
第一步将原CS IP值入栈，第二步将ss:[0]处的值赋值给CS IP。
前面，我们已经分别学习了ret和call指令的原理。
现在来看一下，如何将它们配合使用来实现子程序的机制。
问题10.1
下面程序返回前，bx中的值是多少？
assume cs:code
code segment
start:mov ax,1
mov cx,3
call s
mov bx,ax
mov ax,4c00h
int 21h
s:add ax,ax
loop s
ret
code ends
end start
我们来看一下CPU执行这个程序的主要过程。
（1）CPU将call s指令的机器码读入，IP指向了call s后的指令mov bx,ax，
然后CPU执行call s指令，将当前的IP值（指令mov bx,ax的偏移地址）压栈，
并将IP的值改变为标号s处的偏移地址；
（2）CPU从标号s处开始执行指令，loop循环完毕后，（ax）=8；
（3）CPU将ret指令的机器码读入，IP指向了ret指令后的内存单元，然后CPU执行ret指令，
从栈中弹出一个值（即call s先前压入的mov bx,ax指令的偏移地址）送入IP中。
则CS:IP指向指令mov bx,ax；
（4）CPU从mov bx,ax开始执行指令，直至完成。
程序返回前，（bx）=8。
可以看出，从标号s到ret的程序段的作用是计算2的N次方，计算前，N的值由cx提供。
我们再来看下面的程序：
assume cs:code
stack segment
db 8 dup (0)
db 8 dup (0)
stack end
code segment
start:mov ax,stack
mov ss,ax
mov sp,16
mov ax,1000
call s
mov ax,4c00h
int 21h
s:add ax,ax
ret
code ends
end start
从上面的讨论中我们发现，可以写一个具有一定功能的程序段，我们称其为子程序，
在需要的时候，用call指令转去执行。可是执行完子程序后，如何让CPU接着call 指令向下执行？
call指令转去执行子程序之前，call 指令后面的指令的地址将存储在栈中，
所以可在子程序的后面使用ret指令，用栈中的数据设置IP的值，
从而转到call指令后面的代码处继续执行。
这样，我们可以利用call和ret来实现子程序的机制。子程序的框架如下。
标号：
       指令
       ret
具有子程序的源程序的框架如下。
assume cs:code
code segment
main:
...
call sub1
...
mov ax,4c00h
int 21h
sub1:
...
call sub2
...
ret
sub2:
...
ret
code ends
end main
现在，可以从子程序的角度，回过头来再看一下本节中的两个程序。
因下面要用到，这里介绍一下mul指令，mul是乘法指令，
使用mul做乘法的时候，注意以下两点。
（1）两个相乘的数：
两个相乘的数，要么都是8位，要么都是16位。
如果是8位，一个默认放在AL中，另一个放在8位reg或内存字节单元中；
如果是16位，一个默认在AX中，另一个放在16位reg或内存字单元中。
（2）结果：
如果是8位乘法，结果默认放在AX中；
如果是16位乘法，结果高位默认在DX中存放，低位在AX中放。
格式如下：
mul reg
mul 内存单元
内存单元可以用不同的寻址方式给出，比如：
mul byte ptr ds:[0]
含义：（ax）=（al）*（（ds）*16+0）；
mul word ptr [bx+si+8]
含义：（ax）=（ax）*（（ds）*16+（bx）+（si）+8）结果的低16位。
（dx）=（ax）*（（ds）*16+（bx）+（si）+8）结果的高16位。
例：
（1）计算100*10。
100和10小于255，可以做8位乘法，程序如下。
mov al,100
mov bl,10
mul bl
结果：（ax）=1000（03E8H）
（2）计算100*10000
100小于255，可10000大于255，所以必须做16位乘法，程序如下。
mov ax,100
mov bx,10000
mul bx
结果：（ax）=4240H，（dx）=000FH（F4240H=1000000）
从上面我们看到，call与ret指令共同支持了汇编语言编程中的模块化设计。
在实际编程中，程序的模块化是必不可少的。因为现实的问题比较复杂，
对现实问题进行分析时，把它转化成为相互联系、不同层次的子问题，是必须的解决方法。
而call与ret指令对这种分析方法提供了程序实现上的支持。
利用call和ret指令，我们可以用简捷的方法，
实现多个相互联系、功能独立的子程序来解决一个复杂的问题。
下面的内容中，我们来看一下子程序设计中的相关问题和解决方法。
子程序一般都要根据提供的参数处理一定的事务，处理后，将结果（返回值）提供给调用者。
其实，我们讨论参数和返回值传递的问题，
实际上就是在探讨，应该如何存储子程序需要的参数和产生的返回值。
比如，设计一个子程序，可以根据提供的N，来计算N的3次方。
这里面就有两个问题：
（1）将参数N存储在什么地方？
（2）计算得到的数值，存储在什么地方？
很显然，可以用寄存器来存储，可以将参数放到bx中；
因为子程序中要计算N*N*N，可以使用多个mul指令，为了方便，可将结果放到dx和ax中。
子程序如下。
cube:mov ax,bx
mul bx
mul bx
ret
注意，我们在编程的时候要注意形成良好的风格，对于程序应有详细的注释。
子程序的注释信息应该包含对子程序的功能、参数和结果的说明。
因为今天写的子程序，以后可能还会用到；自己写的子程序，也很可能要给别人使用，
所以一定要有全面的说明。
用寄存器来存储参数和结果是最常使用的方法。
对于存放参数的寄存器和存放结果的寄存器，
调用者和子程序的读写操作恰恰相反：
调用者将参数送入参数寄存器，从结果寄存器中取到返回值；
子程序从参数寄存器中取到参数，将返回值送入结果寄存器。
编程，计算data段中第一组数据的3次方，结果保存在后面一组 dword单元中。
我们可以用到已经写好的子程序，程序如下：
assume cs:code
data segment
dw 1,2,3,4,5,6,7,8
dd 0,0,0,0,0,0,0,0
data ends
code segment
start:mov ax,data
mov ds,ax
mov si,0
mov di,16
mov cx,8
s: mov bx,[si]
call cube
mov [di],ax
mov [di].2,dx
add si,2
add di,4
loop s
mov ax,4c00h
int 21h
cube:mov ax,bx
mul bx
mul bx
ret
code ends
end start
前面的例程中，子程序cube只有一个参数，放在bx中。
如果有两个参数，那么可以用两个寄存器来放，
可是如果需要传递的数据有3个、4个或更多直至N个，该怎样存放呢？
寄存器的数量终究有限，我们不可能简单地用寄存器来存放多个需要传递的数据。
对于返回值，也有同样的问题。
在这种时候，我们将批量数据放到内存中，
然后将它们所在内存空间的首地址放在寄存器中，传递给需要的子程序。
对于具有批量数据的返回结果，也可用同样的方法。
下面看一个例子，设计一个子程序，
功能：将一个全是字母的字符串转化为大写。
这个子程序需要知道两件事，字符串的内容和字符串的长度。
因为字符串中的字母可能很多，所以不便将整个字符串中的所有字母都直接传递给子程序。
但是，可以将字符串在内存中的首地址放在寄存器中传递给子程序。
因为子程序中要用到循环，我们可以用loop指令，而循环的次数恰恰就是字符串的长度。
出于方便的考虑，可以将字符串的长度放到cx中。
capital:and byte ptr [si],11011111b
inc si
loop capital
ret
编程，将data段中的字符串转化为大写。
assume cs:code
data segment
db 'conversation'
data ends
code segment
start:mov ax,data
mov ds,ax
mov si,0
mov cx,12
call capital
mov ax,4c00h
int 21h
capital:and byte ptr [si],11011111b
inc si
loop capital
ret
code ends
end start
注意，除了用寄存器传递参数外，还有一种通用的方法是用栈来传递参数。
这种技术和高级语言编译器的工作原理密切相关。
我们下面结合C语言的函数调用，看一下用栈传递参数的思想。
用栈传递参数的原理十分简单，
就是由调用者将需要传递给子程序的参数压入栈中，子程序从栈中取得参数。
我们看下面的例子。
栈中的顺序 低地址->高地址
bp->ip->a->b
difcube:push bp
mov bp,sp
mov ax,[bp+4]
sub ax,[bp+6]
mov bp,ax
mul bp
mul bp
pop bp
ret 4
指令ret n的含义用汇编语法描述为：
pop ip
add sp,n
因为用栈传递参数，所以调用者在调用程序的时候要向栈中压入参数，
子程序在返回的时候可以用ret n指令将栈顶指针修改为调用前的值。
调用上面的子程序之前，需要压入两个参数，所以用ret 4返回。
我们看一下如何调用上面的程序，设a=3、b=1，下面的程序段计算（a-b）的3次方：
栈中的顺序 低地址->高地址
bp->ip->a->b
mov ax,1
push ax
mov ax,3
push ax
call difcube
下面，我们通过一个C语言程序编译后的汇编语言程序，看一下栈在参数传递中的应用。
要注意的是，在C语言中，局部变量也在栈中存储。
C程序
void add(int, int, int);
main()
{
    int a = 1;
    int b = 2;
    int c = 0;
    add(a, b, c);
    c++;
}
void add(int a, int b, int c)
{
    c = a + b;
}
编译后的汇编程序
栈中的顺序 低地址->高地址
bp->ip->a->b->c->局部a->局部b->局部c
mov bp,sp
sub sp,6
mov word ptr [bp-6],0001
mov word ptr [bp-4],0002
mov word ptr [bp-2],0000
push [bp-2]
push [bp-4]
push [bp-6]
call ADDR
add sp,6
inc word ptr [bp-2]
ADDR:push bp
mov bp,sp
mov ax,[bp+4]
add ax,[bp+6]
mov [bp+8],ax
mov sp,bp
pop bp
ret
设计一个子程序，
功能：将一个全是字母，以0结尾的字符串，转化为大写。
程序要处理的字符串以0作为结尾符，这个字符串可以如下定义：
db 'conversation',0
应用这个子程序，字符串的内容后面一定要有一个0，标记字符串的结束。
子程序可以依次读取每个字符进行检测，如果不是0，就进行大写的转化；如果是0，就结束处理。
由于可通过检测0而知道是否已经处理完整个字符串，
所以子程序可以不需要字符串的长度作为参数。
可以用jcxz来检测0。
capital:mov cl,[si]
mov ch,0
jcxz ok
and byte ptr [si],11011111b
inc si
jmp short capital
ok:ret
来看一下这个子程序的应用。
（1）将data段中字符串转化为大写。
assume cs:code
data segment
db 'conversation',0
data ends
代码段中的相关程序段如下。
mov ax,data
mov ds,ax
mov si,0
call capital
完整的程序如下：
assume cs:code
data segment
db 'conversation',0
data ends
code segment
start:mov ax,data
mov ds,ax
mov si,0
call capital
mov ax,4c00h
int 21h
capital:mov cl,[si]
mov ch,0
jcxz ok
and byte ptr [si],11011111b
inc si
jmp short capital
ok:ret
code ends
end start
（2）将data段中的字符串全部转化为大写。
assume cs:code
data segment
db 'word',0
db 'unix',0
db 'wind',0
db 'good',0
data ends
可以看到，所有字符串的长度都是5（算上结尾符0），
使用循环，重复调用子程序capital，完成对4个字符串的处理。
完整的程序如下。
code segment
start:mov ax,data
mov ds,ax
mov bx,0
mov cx,4
s:mov si,bx
call capital
add bx,5
loop s
mov ax,4c00h
int 21h
capital:mov cl,[si]
mov ch,0
jcxz ok
and byte ptr [si],11011111b
inc si
jmp short capital
ok:ret
code ends
end start
问题10.2这个程序在思想上完全正确，但在细节上却有些错误，把错误找出来。
思考后看分析。
分析：
问题在于cx的使用，主程序要使用cx记录循环次数，可是子程序中也使用了cx，
在执行子程序的时候，cx中保存的循环计数值被改变，使得主程序的循环出错。
从上面的问题中，实际上引出了一个一般化的问题：
子程序中使用的寄存器，很可能在主程序中也要使用，造成了寄存器使用上的冲突。
那么如何来避免这种冲突呢？粗略地看，可以有以下两个方案。
（1）在编写调用子程序的程序时，注意看看子程序中有没有用到会产生冲突的寄存
器，如果有，调用者使用别的寄存器；
（2）在编写子程序的时候，不要使用会产生冲突的寄存器。
我们来分析一下上面两个方案的可行性：
（1）这将给调用子程序的程序的编写造成很大的麻烦，
因为必须要小心检查所调用的子程序中是否有将产生冲突的寄存器。
比如说，在上面的例子中，
我们在编写主程序的循环的时候就得检查子程序中是否用到了bx和cx，
因为如果子程序中用到了这两个寄存器就会出现问题。
如果采用这种方案来解决冲突的话，
那么在主程序的循环中，就不能使用cx寄存器，因为子程序中已经用到。
（2）这个方案是不可能实现的，因为编写子程序的时候无法知道将来的调用情况。
可见，我们上面所设想的两个方案都不可行。我们希望：
（1）编写调用子程序的程序的时候不必关心子程序到底使用了哪些寄存器；
（2）编写子程序的时候不必关心调用者使用了哪些寄存器；
（3）不会发生寄存器冲突。
解决这个问题的简捷方法是，
在子程序的开始将子程序中所有用到的寄存器中的内容都保存起来，在子程序返回前再恢复。
可以用栈来保存寄存器中的内容。
以后，我们编写子程序的标准框架如下：
子程序开始：子程序中使用的寄存器入栈
子程序内容
子程序中使用的寄存器出栈
返回（ret、retf）
我们改进一下子程序capital的设计：
capital:push cx
push si
change:mov cl,[si]
mov ch,0
jcxz ok
and byte ptr [si],11011111b
inc si
jmp short change
ok:pop si
pop cx
ret
要注意寄存器入栈和出栈的顺序。
完整的程序如下：
assume cs:code
data segment
db 'word',0
db 'unix',0
db 'wind',0
db 'good',0
data ends
stack segment
dw 8 dup (0)
stack ends
code segment
start:mov ax,data
mov ds,ax
mov ax,stack
mov ss,ax
mov sp,16
mov bx,0
mov cx,4
s:mov si,bx
call capital
add bx,5
loop s
mov ax,4c00h
int 21h
capital:push cx
push si
change:mov cl,[si]
mov ch,0
jcxz ok
and byte ptr [si],11011111b
inc si
jmp short change
ok:pop si
pop cx
ret
code ends
end start
在这次实验中，我们将要编写3个子程序，
通过它们来认识几个常见的问题和掌握解决这些问题的方法。
同前面的所有实验一样，这个实验是必须独立完成的，
在后面的课程中，将要用到这个实验中编写的3个子程序。
1.显示字符串
问题
显示字符串是现实工作中经常要用到的功能，应该编写一个通用的子程序来实现这个功能。
我们应该提供灵活的调用接口，使调用者可以决定显示的位置（行、列）、内容和颜色。
子程序描述
名称：show_str
功能：在指定的位置，用指定的颜色，显示一个用0结束的字符串。
参数：（dh）=行号（取值范围0-24），（dl）=列号（取值范围0-79），
          （cl）=颜色，ds:si指向字符串的首地址
返回：无
应用举例：在屏幕的8行3列，用绿色显示data段中的字符串。
assume cs:code
data segment
db 'Welcome to masm!',0
data ends
code segment
start:mov dh,8
mov dl,3
mov cl,2
mov ax,data
mov ds,ax
mov si,0
call show_str
mov ax,4c00h
int 21h
show_str:
...
code ends
end start
完整的程序如下
assume cs:code
data segment
db 'Welcome to masm!',0
data ends
stack segment
dw 16 dup (0)
stack ends
code segment
start:mov dh,8
mov dl,3
mov cl,2
mov ax,data
mov ds,ax
mov ax,stack
mov ss,ax
mov sp,32
mov si,0
call show_str
mov ax,4c00h
int 21h
show_str:push dx
push cx
push bx
push ax
push si
push di
push es
mov ax,0B800H
mov es,ax
mov bx,0
mov di,0
mov al,160
mul dh
add bx,ax
mov al,2
mul dl
add bx,ax
mov al,cl
s:mov cl,ds:[si]
mov ch,0
jcxz ok
mov ch,al
mov es:[bx+di],cx
inc si
add di,2
jmp s
ok:pop es
pop di
pop si
pop ax
pop bx
pop cx
pop dx
ret
code ends
end start
提示
（1）子程序的入口参数是屏幕上的行号和列号，注意在子程序内部要将它们转化为显存中的地址，
首先要分析一下屏幕上的行列位置和显存地址的对应关系；
（2）注意保存子程序中用到的相关寄存器；
（3）这个子程序的内部处理和显存的结构密切相关，但是向外提供了与显存结构无关的接口。
通过调用这个子程序，进行字符串的显示时可以不必了解显存的结构，为编程提供了方便。
在实验中，注意体会这种设计思想。
2.解决除法溢出的问题
问题
前面讲过，div指令可以做除法。当进行8位除法的时候，用al存储结果的商，ah存储结果的余数；
进行16位除法的时候，用ax存储结果的商，dx存储结果的余数。
可是，现在有一个问题，如果结果的商大于al或ax所能存储的最大值，那么将如何？
比如，下面的程序段：
mov bh，1
mov ax，1000
div bh进行的是8位除法，结果的商为1000，而1000在al中放不下。
又比如，下面的程序段：
mov ax，1000H
mov dx，1
mov bx，1
div bx进行的是16位除法，结果的商为11000H，而11000H在ax中存放不下。
我们在用div指令做除法的时候，很可能发生上面的情况：
结果的商过大，超出了寄存器所能存储的范围。
当CPU执行div等除法指令的时候，如果发生这样的情况，
将引发CPU的一个内部错误，这个错误被称为：除法溢出。
我们可以通过特殊的程序来处理这个错误，但在这里我们不讨论这个错误的处理，
这是后面的课程中要涉及的内容。
下面我们仅仅来看一下除法溢出发生时的一些现象，如图10.1所示。
图中展示了在Windows 2000中使用Debug执行相关程序段的结果，
div指令引发了CPU的除法溢出，系统对其进行了相关的处理。
好了，我们已经清楚了问题的所在：用div指令做除法的时候可能产生除法溢出。
由于有这样的问题，在进行除法运算的时候要注意除数和被除数的值，
比如1000000/10就不能用div指令来计算。那么怎么办呢？我们用下面的子程序divdw解决。
子程序描述
名称：divdw
功能：进行不会产生溢出的除法运算，被除数为dword型，除数为word型，结果为dword型。
参数：（ax）=dword型数据的低16位
（dx）=dword型数据的高16位
（cx）=除数
返回：（dx）=结果的高16位，（ax）=结果的低16位
（cx）=余数
应用举例：计算1000000/10（F4240H/0AH）
mov ax,4240H
mov dx,000FH
mov cx,0AH
call divdw
结果：（dx）=0001H，（ax）=86A0H，（cx）=0
提示
给出一个公式：
X：被除数，范围：[0，FFFFFFFF]
N：除数，范围：[0，FFFF]
H:X高16位，范围：[0，FFFF]
L:X低16位，范围：[0，FFFF]
int（）：描述性运算符，取商，比如，int（38/10）=3
rem（）：描述性运算符，取余数，比如，rem（38/10）=8
公式：X/N=int（H/N）*65536+[rem（H/N）*65536+L]/N
X/n=int（H/n）*65536+[rem（H/n）*65536+L]/n 
H=int（x/65536）；L=rem（x/65536）
这个公式将可能产生溢出的除法运算：X/N，转变为多个不会产生溢出的除法运算。
公式中，等号右边的所有除法运算都可以用div指令来做，肯定不会导致除法溢出。
（关于这个公式的推导，有兴趣的读者请参看附注5。）
完整的程序如下
assume cs:code
stack segment
dw 16 dup (0)
stack ends
code segment
start:mov ax,stack
mov ss,ax
mov sp,32
mov ax,4240H
mov dx,000FH
mov cx,0AH
call divdw
mov ax,4c00h
int 21h
divdw:push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
code ends
end start
3.数值显示
问题
编程，将data段中的数据以十进制的形式显示出来。
data segment
dw 123,12666,1,8,3,38
data ends
这些数据在内存中都是二进制信息，标记了数值的大小。
要把它们显示到屏幕上，成为我们能够读懂的信息，需要进行信息的转化。
比如，数值12666，在机器中存储为二进制信息：0011000101111010B（317AH），
计算机可以理解它。而要在显示器上读到可以理解的数值12666，
我们看到的应该是一串字符：“12666”。
由于显卡遵循的是ASCII编码，为了让我们能在显示器上看到这串字符，
它在机器中应以ASCIⅡ码的形式存储为：
31H、32H、36H、36H、36H（字符“0”~“9”对应的ASCII码为30H-39H）。
通过上面的分析可以看到，在概念世界中，有一个抽象的数据12666，它表示了一个数值的大小。
在现实世界中它可以有多种表示形式，可以在电子机器中以高低电平（二进制）的形式存储，
也可以在纸上、黑板上、屏幕上以人类的语言“12666”来书写。
现在，我们面临的问题就是，要将同一抽象的数据，从一种表示形式转化为另一种表示形式。
可见，要将数据用十进制形式显示到屏幕上，要进行两步工作：
（1）将用二进制信息存储的数据转变为十进制形式的字符串；
（2）显示十进制形式的字符串。
第二步我们在本次实验的第一个子程序中已经实现，在这里只要调用一下 show_str即可。
我们来讨论第一步，因为将二进制信息转变为十进制形式的字符串也是经常要用到的功能，
我们应该为它编写一个通用的子程序。
子程序描述
名称：dtoc
功能：将word型数据转变为表示十进制数的字符串，字符串以0为结尾符。
参数：（ax）=word型数据
ds:si指向字符串的首地址
返回：无
应用举例：编程，将数据12666以十进制的形式在屏幕的8行3列，用绿色显示出来。
在显示时我们调用本次实验中的第一个子程序show_str。
assume cs:code
data segment
db 10 dup (0)
data ends
code segment
start:mov ax,12666
mov bx,data
mov ds,bx
mov si,0
call dtoc
mov dh,8
mov dl,3
mov cl,2
call show_str
code ends
end start
提示
下面我们对这个问题进行一下简单地分析。
（1）要得到字符串“12666”，就是要得到一列表示该字符串的ASCII码：31H、
32H、36H、36H、36H。
十进制数码字符对应的ASCII码=十进制数码值+30H。
要得到表示十进制数的字符串，先求十进制数每位的值。
例：对于12666，先求得每位的值：1、2、6、6、6。
再将这些数分别加上30H，便得到了表示12666的ASCII码串：31H、32H、36H、36H、36H。
（2）那么，怎样得到每位的值呢？采用下面的方法：
可见，用10除12666，共除5次，记下每次的余数，就得到了每位的值。
（3）综合以上分析，可得出处理过程如下。
用12666除以10，循环5次，记下每次的余数；
将每次的余数分别加30H，便得到了表示十进制数的ASCII码串。
如下：
（4）对（3）的质疑。
在已知数据是12666的情况下，知道进行5次循环。
可在实际问题中，数据的值是多少程序员并不知道，也就是说，程序员不能事先确定循环次数。
那么，如何确定数据各位的值已经全部求出了呢？
我们可以看出，只要是除到商为0，各位的值就已经全部求出。
可以使用jcxz指令来实现相关的功能。
完整的程序如下
assume cs:code
data segment
db 16 dup (0)
data ends
stack segment
dw 32 dup (0)
stack ends
code segment
start:mov ax,data
mov ds,ax
mov ax,stack
mov ss,ax
mov sp,64
mov ax,12666
mov si,0
call dtoc
mov dh,8
mov dl,3
mov cl,2
call show_str
mov ax,4c00h
int 21h
dtoc:push dx
push cx
push bx
push ax
push si
push di
mov di,0
mov dx,0
mov bx,10
divide:mov cx,ax
jcxz finish
div bx
inc di
push dx
mov dx,0
jmp divide
finish:mov cx,di
string:pop bx
add bx,30h
mov ds:[si],bl
inc si
loop string
pop di
pop si
pop ax
pop bx
pop cx
pop dx
ret
show_str:push dx
push cx
push bx
push ax
push si
push di
push es
mov ax,0B800H
mov es,ax
mov bx,0
mov di,0
mov al,160
mul dh
add bx,ax
mov al,2
mul dl
add bx,ax
mov al,cl
s:mov cl,ds:[si]
mov ch,0
jcxz ok
mov ch,al
mov es:[bx+di],cx
inc si
add di,2
jmp s
ok:pop es
pop di
pop si
pop ax
pop bx
pop cx
pop dx
ret
code ends
end start
课程设计1
在整个课程中，我们一共有两个课程设计，编写两个比较综合的程序，这是第一个。
任务：将实验7中的Power idea公司的数据按照图10.2所示的格式在屏幕上显示出来。
在这个程序中，要用到我们前面学到的几乎所有的知识，
注意选择适当的寻址方式和相关子程序的设计和应用。
另外，要注意，因为程序要显示的数据有些已经大于65535，
应该编写一个新的数据到字符串转化的子程序，完成dword型数据到字符串的转化，说明如下。
名称：dtoc
功能：将dword型数转变为表示十进制数的字符串，字符串以0为结尾符。
参数：（ax）=dword型数据的低16位
          （dx）=dword型数据的高16位
           ds:si指向字符串的首地址
返回：无
在这个子程序中要注意除法溢出的问题，可以用我们在实验10中设计的子程序divdw来解决。
修改后的程序如下
assume cs:code
data segment
db 16 dup (0)
data ends
stack segment
dw 32 dup (0)
stack ends
code segment
start:mov ax,data
mov ds,ax
mov ax,stack
mov ss,ax
mov sp,64
mov ax,4240H
mov dx,000FH
mov si,0
call dtoc
mov dh,8
mov dl,3
mov cl,2
call show_str
mov ax,4c00h
int 21h
dtoc:push dx
push cx
push bx
push ax
push si
push di
mov di,0
divide:mov cx,dx
jcxz finish_s
divide_s:mov cx,0AH
call divdw
inc di
push cx
jmp divide
finish_s:mov cx,ax
jcxz finish
jmp divide_s
finish:mov cx,di
string:pop bx
add bx,30h
mov ds:[si],bl
inc si
loop string
pop di
pop si
pop ax
pop bx
pop cx
pop dx
ret
show_str:push dx
push cx
push bx
push ax
push si
push di
push es
mov ax,0B800H
mov es,ax
mov bx,0
mov di,0
mov al,160
mul dh
add bx,ax
mov al,2
mul dl
add bx,ax
mov al,cl
show_str_s:mov cl,ds:[si]
mov ch,0
jcxz ok
mov ch,al
mov es:[bx+di],cx
inc si
add di,2
jmp show_str_s
ok:pop es
pop di
pop si
pop ax
pop bx
pop cx
pop dx
ret
divdw:push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
code ends
end start
完整的程序如下
assume cs:code
data segment
db '1975','1976','1977','1978','1979','1980','1981','1982','1983'
db '1984','1985','1986','1987','1988','1989','1990','1991','1992'
db '1993','1994','1995'
dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514
dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000
dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226
dw 11542,14430,15257,17800
db 16 dup (0)
data ends
stack segment
dw 128 dup (0)
stack ends
code segment
start:mov ax,data
mov ds,ax
mov ax,stack
mov ss,ax
mov sp,256
call show_info
mov ax,4c00h
int 21h
show_info:
mov si,210
mov di,0
mov bx,0
mov cx,21
show_info_s: push cx
mov ax,ds:[di]
mov ds:[si],ax
mov ax,ds:[di+2]
mov ds:[si+2],ax
mov ds:[si+4],0
mov ax,23
sub ax,cx
push ax
push ax
push ax
mov dh,al
mov dl,12
mov cl,7
call show_str
mov ax,ds:[di+84]
mov dx,ds:[di+86]
call dtoc
pop ax
mov dh,al
mov dl,24
mov cl,7
call show_str
mov ax,ds:[bx+168]
mov dx,0
call dtoc
pop ax
mov dh,al
mov dl,36
mov cl,7
call show_str
mov ax,ds:[di+84]
mov dx,ds:[di+86]
mov cx,ds:[bx+168]
call divdw
call dtoc
pop ax
mov dh,al
mov dl,48
mov cl,7
call show_str
add di,4
add bx,2
pop cx
loop show_info_s
ret
show_str:push dx
push cx
push bx
push ax
push si
push di
push es
mov ax,0B800H
mov es,ax
mov bx,0
mov di,0
mov al,160
mul dh
add bx,ax
mov al,2
mul dl
add bx,ax
mov al,cl
show_str_s:mov cl,ds:[si]
mov ch,0
jcxz ok
mov ch,al
mov es:[bx+di],cx
inc si
add di,2
jmp show_str_s
ok:pop es
pop di
pop si
pop ax
pop bx
pop cx
pop dx
ret
dtoc:push dx
push cx
push bx
push ax
push si
push di
mov di,0
divide:mov cx,dx
jcxz finish_s
divide_s:mov cx,0AH
call divdw
inc di
push cx
jmp divide
finish_s:mov cx,ax
jcxz finish
jmp divide_s
finish:mov cx,di
string:pop bx
add bx,30h
mov ds:[si],bl
inc si
loop string
mov ds:[si],0
pop di
pop si
pop ax
pop bx
pop cx
pop dx
ret
divdw:push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
code ends
end start
CPU内部的寄存器中，有一种特殊的寄存器（对于不同的处理机，个数和结构都可能不同）
具有以下3种作用。
（1）用来存储相关指令的某些执行结果；
（2）用来为CPU执行相关指令提供行为依据；
（3）用来控制CPU的相关工作方式。
这种特殊的寄存器在8086CPU中，被称为标志寄存器。
8086CPU的标志寄存器有16位，其中存储的信息通常被称为程序状态字（PSW）。
我们已经使用过8086CPU的ax、bx、cx、dx、si、di、bp、sp、IP、cs、ss、ds、es
等13个寄存器了，本章中的标志寄存器（以下简称为flag）是我们要学习的最后一个寄存器。
flag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。
而flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。
8086CPU的flag寄存器的结构如图11.1所示。
15 14 13 12 11 10  9  8   7   6   5   4  3  2  1  0
                    OF DF IF TF SF ZF       AF   PF     CF
flag的1、3、5、12、13、14、15位在8086CPU中没有使用，不具有任何含义。
而0、2、4、6、7、8、9、10、11位都具有特殊的含义。
在这一章中，我们学习标志寄存器中的CF、PF、ZF、SF、OF、DF标志位，
以及一些与其相关的典型指令。
flag的第6位是ZF，零标志位。
它记录相关指令执行后，其结果是否为0。如果结果为0，那么zf=1；如果结果不为0，那么zf=0。
比如，指令：
mov ax,1
sub ax,1
执行后，结果为0，则zf=1。
mov ax,2
sub ax,1
执行后，结果不为0，则zf=0。
对于zf的值，我们可以这样来看，zf标记相关指令的计算结果是否为0，
如果为0，则zf要记录下“是0”这样的肯定信息。
在计算机中1表示逻辑真，表示肯定，所以当结果为0的时候zf=1，表示“结果是0”。
如果结果不为0，则zf要记录下“不是0”这样的否定信息。
在计算机中0表示逻辑假，表示否定，所以当结果不为0的时候zf=0，表示“结果不是0”。
比如，指令：
mov ax,1
and ax,0
执行后，结果为0，则zf=1，表示“结果是0”。
mov ax,1
or ax,0
执行后，结果不为0，则zf=0，表示“结果非0”。
注意，在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，
比如，add、sub、mul、div、inc、or、and等，它们大都是运算指令（进行逻辑或算术运算）；
有的指令的执行对标志寄存器没有影响，比如，mov、push、pop等，它们大都是传送指令。
在使用一条指令的时候，要注意这条指令的全部功能，
其中包括，执行结果对标志寄存器的哪些标志位造成影响。
flag的第2位是PF，奇偶标志位。它记录相关指令执行后，
其结果的所有bit位中1的个数是否为偶数。如果1的个数为偶数，pf=1，如果为奇数，那么pf=0。
比如，指令：
mov al,1
add al,10
执行后，结果为00001011B，其中有3（奇数）个1，则pf=0；
mov al,1
or al,2
执行后，结果为00000011B，其中有2（偶数）个1，则pf=1；
sub al,al
执行后，结果为00000000B，其中有0（偶数）个1，则pf=1。
flag的第7位是SF，符号标志位。它记录相关指令执行后，其结果是否为负。
如果结果为负，sf=1；如果非负，sf=0。
计算机中通常用补码来表示有符号数据。
计算机中的一个数据可以看作是有符号数，也可以看成是无符号数。比如：
00000001B，可以看作为无符号数1，或有符号数+1；
10000001B，可以看作为无符号数129，也可以看作有符号数-127。
这也就是说，对于同一个二进制数据，
计算机可以将它当作无符号数据来运算，也可以当作有符号数据来运算。
比如：
mov al,10000001B
add al,1
结果：（al）=10000010B。
可以将add指令进行的运算当作无符号数的运算，
那么add指令相当于计算129+1，结果为130（10000010B）；
也可以将add指令进行的运算当作有符号数的运算，
那么add指令相当于计算-127+1，结果为-126（10000010B）。
不管我们如何看待，CPU在执行add等指令的时候，就已经包含了两种含义，
也将得到用同一种信息来记录的两种结果。关键在于我们的程序需要哪一种结果。
SF标志，就是CPU对有符号数运算结果的一种记录，它记录数据的正负。
在我们将数据当作有符号数来运算的时候，可以通过它来得知结果的正负。
如果我们将数据当作无符号数来运算，SF的值则没有意义，虽然相关的指令影响了它的值。
这也就是说，CPU在执行add等指令时，是必然要影响到SF标志位的值的。
至于我们需不需要这种影响，那就看我们如何看待指令所进行的运算了。
比如：
mov al,10000001B
add al,1
执行后，结果为10000010B，sf=1，
表示：如果指令进行的是有符号数运算，那么结果为负；
mov al,10000001B
add al,01111111B
执行后，结果为0，sf=0，
表示：如果指令进行的是有符号数运算，那么结果为非负。
某些指令将影响标志寄存器中的多个标记位，
这些被影响的标记位比较全面地记录了指令的执行结果，为相关的处理提供了所需的依据。
比如指令sub al,al执行后，ZF、PF、SF等标志位都要受到影响，它们分别为：1、1、0。
检测点11.1
写出下面每条指令执行后，ZF、PF、SF等标志位的值。
NV UP PL NZ PO NC
sub al,al    ZF=1 PF=1 SF=0
mov al,1   ZF=1 PF=1 SF=0
push ax    ZF=1 PF=1 SF=0
pop bx     ZF=1 PF=1 SF=0
add al,bl  ZF=0 PF=0 SF=0
add al,10 ZF=0 PF=1 SF=0
mul al     ZF=0 PF=1 SF=1
flag的第0位是CF，进位标志位。一般情况下，在进行无符号数运算的时候，
它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。
对于位数为N的无符号数来说，其对应的二进制信息的最高位，
即第N-1位，就是它的最高有效位，而假想存在的第N位，就是相对于最高有效位的更高位。
我们知道，当两个数据相加的时候，有可能产生从最高有效位向更高位的进位。
比如，两个8位数据：98H+98H，将产生进位。
由于这个进位值在8位数中无法保存，我们在前面的课程中，就只是简单地说这个进位值丢失了。
其实CPU在运算的时候，并不丢弃这个进位值，而是记录在一个特殊的寄存器的某一位上。
8086CPU就用flag的CF位来记录这个进位值。
比如，下面的指令：
mov al,98H
add al,al
执行后：（al）=30H，CF=1，CF记录了从最高有效位向更高位的进位值
add al,al
执行后：（al）=60H，CF=0，CF记录了从最高有效位问更高位的进位值
而当两个数据做减法的时候，有可能向更高位借位。
比如，两个8位数据：97H-98H，将产生借位，借位后，相当于计算197H-98H。而flag的CF位也可以用来记录这个借位值。
比如，下面的指令：
mov al,97H
sub al,98H
执行后：（al）=FFH，CF=1，CF记录了向更高位的借位值
sub al,al
执行后：（al）=0，CF=0，CF记录了向更高位的借位值
我们先来谈谈溢出的问题。在进行有符号数运算的时候，
如结果超过了机器所能表示的范围称为溢出。
那么，什么是机器所能表示的范围呢？
比如说，指令运算的结果用8位寄存器或内存单元来存放，
比如，add al,3，那么对于8位的有符号数据，机器所能表示的范围就是-128~127。
同理，对于16位有符号数据，机器所能表示的范围是-32768-32767。
如果运算结果超出了机器所能表达的范围，将产生溢出。
注意，这里所讲的溢出，只是对有符号数运算而言。
下面我们看两个溢出的例子。
mov al,98
add al,99
执行后将产生溢出。因为add al,99进行的有符号数运算是：
（al）=（al）+99=98+99=197。
而结果197超出了机器所能表示的8位有符号数的范围：-128~127。
mov al,0F0H
F0H，为有符号数-16的补码
add al,088H
88H，为有符号数-120的补码
执行后，将产生溢出。因为add al,088H进行的有符号数运算是：
（al）=（al）+（-120）=（-16）+（-120）=-136
而结果-136超出了机器所能表示的8位有符号数的范围：-128~127。
如果在进行有符号数运算时发生溢出，那么运算的结果将不正确。就上面的两个例子来说：
mov al,98
add al,99
add指令运算的结果是（al）=0C5H，
因为进行的是有符号数运算，所以al中存储的是有符号数，而C5H是有符号数-59的补码。
如果我们用add指令进行的是有符号数运算，则98+99=-59这样的结果让人无法接受。
造成这种情况的原因，就是实际的结果197，作为一个有符号数，在8位寄存器al中存放不下。
同样，对于：
mov al,0F0H
F0H，为有符号数-16的补码
add al,088H
88H，为有符号数-120的补码
add 指令运算的结果是（al）=78H，因为进行的是有符号数运算，所以al中存储的是有符号数，
而78H表示有符号数120。如果我们用add指令进行的是有符号数运算，
则-16-120=120这样的结果显然不正确。
造成这种情况的原因，就是实际的结果-136，作为一个有符号数，在8位寄存器al中存放不下。
由于在进行有符号数运算时，可能发生溢出而造成结果的错误。
则CPU需要对指令执行后是否产生溢出进行记录。
flag的第11位是OF，溢出标志位。一般情况下，OF记录了有符号数运算的结果是否发生了溢出。
如果发生溢出，OF=1；如果没有，OF=0。
一定要注意CF和OF的区别：
CF是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位。比如：
mov al,98
add al,99
add 指令执行后：CF=0，OF=1。
前面我们讲过，CPU在执行add等指令的时候，就包含了两种含义：无符号数运算和有符号数运算。
对于无符号数运算，CPU用CF位来记录是否产生了进位；
对于有符号数运算，CPU用OF位来记录是否产生了溢出，
当然，还要用SF位来记录结果的符号。
对于无符号数运算，98+99没有进位，CF=0；对于有符号数运算，98+99发生溢出，OF=1。
mov al,0F0H
add al,88H
add 指令执行后：CF=1，OF=1。
对于无符号数运算，0F0H+88H有进位，CF=1；
对于有符号数运算，0F0H+88H发生溢出，OF=1。
mov al,0F0H
add al,78H
add 指令执行后：CF=1，OF=0。
对于无符号运算，0F0H+78H有进位，CF=1；
对于有符号数运算，0F0H+78H不发生溢出，OF=0。
我们可以看出，CF和OF所表示的进位和溢出，是分别对无符号数和有符号数运算而言的，
它们之间没有任何关系。
检测点11.2
写出下面每条指令执行后，ZF、PF、SF、CF、OF等标志位的值。
NV UP PL NZ PO NC
                           CF   OF   SF   ZF   PF
sub al,al              0     0     0     1     1
mov al,10H         0     0     0     1     1
add al,90H          0     0     1     0    1
mov al,80H         0     0     1     0    1
add al,80H          1     1     0     1    1
mov al,0FCH       1     1     0     1    1
add al,05H          1     0     0     0    0
mov al,7DH         1    0     0     0    0
add al,0BH          0    1     1     0     1
adc是带进位加法指令，它利用了CF位上记录的进位值。
指令格式：adc 操作对象1，操作对象2
功能：操作对象1=操作对象1+操作对象2+CF
比如指令adc ax,bx实现的功能是：（ax）=（ax）+（bx）+CF
例：
mov ax,2
mov bx,1
sub bx,ax
adc ax,1
执行后，（ax）=4。adc 执行时，相当于计算：（ax）+1+CF=2+1+1=4。
mov ax,1
add ax,ax
adc ax,3
执行后，（ax）=5。adc 执行时，相当于计算：（ax）+3+CF=2+3+0=5。
mov al,98H
add al,al
adc al,3
执行后，（al）=34H。adc 执行时，相当于计算：（al）+3+CF=30H+3+1=34H。
可以看出，adc指令比add指令多加了一个CF位的值。
为什么要加上CF的值呢？CPU为什么要提供这样一条指令呢？先来看一下CF的值的含义。
在执行adc指令的时候加上的CF的值的含义，是由adc指令前面的指令决定的，
也就是说，关键在于所加上的CF值是被什么指令设置的。
显然，如果CF的值是被sub指令设置的，那么它的含义就是借位值；
如果是被add指令设置的，那么它的含义就是进位值。
我们来看一下两个数据：0198H和0183H如何相加的：
   0198
+0183
   031B
可以看出，加法可以分两步来进行：①低位相加；②高位相加再加上低位相加产生的进位值。
下面的指令和add ax，bx具有相同的结果：
add al,bl
adc ah,bh
看来CPU提供adc指令的目的，就是来进行加法的第二步运算的。
adc 指令和add指令相配合就可以对更大的数据进行加法运算。我们来看一个例子：
编程，计算1EF000H+201000H，结果放在ax（高16位）和bx（低16位）中。
因为两个数据的位数都大于16，用add指令无法进行计算。
我们将计算分两步进行，先将低16位相加，然后将高16位和进位值相加。程序如下。
mov ax,001EH
mov bx,0F000H
add bx,1000H
adc ax,0020H
adc指令执行后，也可能产生进位值，所以也会对CF位进行设置。
由于有这样的功能，我们就可以对任意大的数据进行加法运算。看一个例子：
编程，计算1EF0001000H+2010001EF0H，
结果放在ax（最高16位），bx（次高16位），cx（低16位）中。
计算分3步进行：
（1）先将低16位相加，完成后，CF中记录本次相加的进位值；
（2）再将次高16位和CF（来自低16位的进位值）相加，完成后，CF中记录本次相加的进位值；
（3）最后高16位和CF（来自次高16位的进位值）相加，完成后，CF中记录本次相加的进位值。
程序如下。
mov ax,001EH
mov bx,0F000H
mov cx,1000H
add cx,1EF0H
adc bx,1000H
adc ax,0020H
下面编写一个子程序，对两个128位数据进行相加。
名称：add128
功能：两个128位数据进行相加。
参数：ds:si指向存储第一个数的内存空间，因数据为128位，所以需要8个字单元，
由低地址单元到高地址单元依次存放128位数据由低到高的各个字。
运算结果存储在第一个数的存储空间中。
ds:di指向存储第二个数的内存空间。
程序如下。
add128:push ax
push cx
push si
push di
sub ax,ax
mov cx,8
s:mov ax,ds:[si]
adc ax,ds:[di]
mov ds:[si],ax
inc si
inc si
inc di
inc di
loop s
pop di
pop si
pop cx
pop ax
ret
inc和loop指令不影响CF位，思考一下，上面的程序中，能不能将4个inc指令，用
add si,2
add di,2来取代？不能 add指令影响CF位
sbb是带借位减法指令，它利用了CF位上记录的借位值。
指令格式：sbb 操作对象1，操作对象2
功能：操作对象1=操作对象1-操作对象2-CF
比如指令 sbb ax,bx实现的功能是：（ax）=（ax）-（bx）-CF
sbb指令执行后，将对CF进行设置。利用sbb指令可以对任意大的数据进行减法运算。
比如，计算003E1000H-00202000H，结果放在ax，bx中，程序如下：
mov bx,1000H
mov ax,003EH
sub bx,2000H
sbb ax,0020H
sbb和adc是基于同样的思想设计的两条指令，在应用思路上和adc类似。
在这里，我们就不再进行过多的讨论。
通过学习这两条指令，我们可以进一步领会一下标志寄存器CF位的作用和意义。
cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。
cmp指令执行后，将对标志寄存器产生影响。
其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果。
cmp指令格式：cmp 操作对象1，操作对象2
功能：计算操作对象1-操作对象2但并不保存结果，仅仅根据计算结果对标志寄存器进行设置。
比如，指令cmp ax,ax，做（ax）-（ax）的运算，结果为0，但并不在ax中保存，
仅影响flag的相关各位。指令执行后：zf=1，pf=1，sf=0，cf=0，of=0。
下面的指令：
mov ax,8
mov bx,3
cmp ax,bx
执行后：（ax）=8，zf=0，pf=1，sf=0，cf=0，of=0。
其实，我们通过cmp指令执行后，相关标志位的值就可以看出比较的结果。
cmp ax,bx
如果（ax）=（bx）则（ax）-（bx）=0，所以：zf=1；
如果（ax）不等于（bx）则（ax）-（bx）不等于0，所以：zf=0；
如果（ax）<（bx）则（ax）-（bx）将产生借位，所以：cf=1；
如果（ax）≥（bx）则（ax）-（bx）不必借位，所以：cf=0；
如果（ax）>（bx）则（ax）-（bx）既不必借位，结果又不为0，所以：cf=0并且zf=0；
如果（ax）≤（bx）则（ax）-（bx）既可能借位，结果可能为0，所以：cf=1或zf=1。
现在我们可以看出比较指令的设计思路，即：通过做减法运算，影响标志寄存器，
标志寄存器的相关位记录了比较的结果。反过来看上面的例子。
指令cmp ax,bx的逻辑含义是比较ax和bx中的值，如果执行后：
zf=1，说明（ax）=（bx）
zf=0，说明（ax）不等于（bx）
cf=1，说明（ax）<（bx）
cf=0，说明（ax）≥（bx）
cf=0并且zf=0，说明（ax）>（bx）
cf=1或zf=1，说明（ax）≤（bx）
同add、sub指令一样，CPU在执行cmp指令的时候，
也包含两种含义：进行无符号数运算和进行有符号数运算。
所以利用cmp指令可以对无符号数进行比较，也可以对有符号数进行比较。
上面所讲的是用cmp进行无符号数比较时，相关标志位对比较结果的记录。
下面我们再来看一下如果用cmp来进行有符号数比较时，CPU用哪些标志位对比较结果进行记录。
我们以cmp ah,bh为例进行说明。
cmp ah,bh
如果（ah）=（bh）则（ah）-（bh）=0，所以：zf=1；
如果（ah）不等于（bh）则（ah）-（bh）不等于0，所以：zf=0；
所以，根据cmp指令执行后zf的值，就可以知道两个数据是否相等。
我们继续看，如果（ah）<（bh）则可能发生什么情况呢？
对于有符号数运算，在（ah）<（bh）情况下，（ah）-（bh）显然可能引起sf=1，即结果为负。
比如：
（ah）=1，（bh）=2；则（ah）-（bh）=0FFH，0FFH为-1的补码，因为结果为负，所以sf=1。
（ah）=0FEH，（bh）=0FFH；则（ah）-（bh）=-2-（-1）=0FFH，因为结果为负，所以sf=1。
通过上面的例子，我们是不是可以得到这样的结论：
cmp 操作对象1，操作对象2指令执行后，sf=1，就说明操作对象1<操作对象2？
当然不是。
我们再看两个例子。
（ah）=22H，（bh）=0A0H；则（ah）-（bh）=34-（-96）=82H，82H是-126的补码
所以sf=1
这里虽然sf=1，但是并不能说明（ah）<（bh）因为显然34>-96。
两个有符号数A和B相减，得到的是负数，那么可以肯定A<B，这个思路没有错误，
关键在于我们根据什么来断定得到的是一个负数。
CPU将cmp指令得到的结果记录在flag的相关标志位中。
我们可以根据指令执行后，相关标志位的值来判断比较的结果。
单纯地考查sf的值不可能知道结果的正负。因为sf记录的只是可以在计算机中存放的相应位数的结果的正负。
比如add ah,al执行后，sf记录的是ah中的8位二进制信息所表示的数据的正负。
cmp ah,bh执行后，sf记录的是（ah）-（bh）所得到的8位结果数据的正负，
虽然这个结果没有在我们能够使用的寄存器或内存单元中保存，
但是在指令执行的过程中，它暂存在CPU内部的暂存器中。
所得到的相应结果的正负，并不能说明，运算所应该得到的结果的正负。
这是因为在运算的过程中可能发生溢出。
如果有这样的情况发生，那么，sf的值就不能说明任何问题。比如：
mov ah,22H
mov bh,0A0H
sub ah,bh
结果sf=1，运算实际得到的结果是（ah）=82H，
但是在逻辑上，运算所应该得到的结果是：34-（-96）=130。
就是因为130这个结果作为一个有符号数超出了-128~127这个范围，
在ah中不能表示，而ah中的结果被CPU当作有符号数解释为-126。
而sf被用来记录这个实际结果的正负，所以sf=1。
但sf=1不能说明在逻辑上，运算所得的正确结果的正负。
又比如：
mov ah,08AH
mov bh,070h
cmp ah,bh
结果sf=0，运算（ah）-（bh）实际得到的结果是1AH，
但是在逻辑上，运算所应该得到的结果是：（-118）-112=-230。
sf记录实际结果的正负，所以sf=0。但sf=0不能说明在逻辑上，运算所得的正确结果。
但是逻辑上的结果的正负，才是cmp指令所求的真正结果，
因为我们就是要靠它得到两个操作对象的比较信息。
所以cmp指令所作的比较结果，不是仅仅靠sf就能记录的，因为它只能记录实际结果的正负。
我们考虑一下，两种结果之间的关系，实际结果的正负，和逻辑上真正结果的正负，
它们之间有多大的距离呢？从上面的分析中，我们知道，
实际结果的正负，之所以不能说明逻辑上真正结果的正负，关键的原因在于发生了溢出。
如果没有溢出发生的话，那么，实际结果的正负和逻辑上真正结果的正负就一致了。
所以，我们应该在考查sf（得知实际结果的正负）的同时考查of（得知有没有溢出），
就可以得知逻辑上真正结果的正负，同时就可以知道比较的结果。
下面，我们以cmp ah,bh为例，总结一下CPU执行cmp指令后，
sf和of的值是如何来说明比较的结果的。
（1）如果sf=1，而of=0
of=0，说明没有溢出，逻辑上真正结果的正负=实际结果的正负；
因sf=1，实际结果为负，所以逻辑上真正的结果为负，所以（ah）<（bh）。
（2）如果sf=1，而of=1：
of=1，说明有溢出，逻辑上真正结果的正负不等于实际结果的正负；因sf=1，实际结果为负。
实际结果为负，而又有溢出，这说明是由于溢出导致了实际结果为负，
简单分析一下，就可以看出，如果因为溢出导致了实际结果为负，
那么逻辑上真正的结果必然为正。
这样，sf=1，of=1，说明了（ah）>（bh）。
（3）如果sf=0，而of=1
of=1，说明有溢出，逻辑上真正结果的正负不等于实际结果的正负；因sf=0，实际结果非负。
而of=1说明有溢出，则结果非0，所以，实际结果为正。
实际结果为正，而又有溢出，这说明是由于溢出导致了实际结果非负，
简单分析一下，就可以看出，如果因为溢出导致了实际结果为正，
那么逻辑上真正的结果必然为负。
这样，sf=0，of=1，说明了（ah）<（bh）。
（4）如果sf=0，而of=0
of=0，说明没有溢出，逻辑上真正结果的正负=实际结果的正负；
因sf=0，实际结果非负，所以逻辑上真正的结果非负，所以（ah）≥（bh）。
上面，我们深入讨论了cmp指令在进行有符号数和无符号数比较时，
对flag相关标志位的影响，和CPU如何通过相关的标志位来表示比较的结果。
在学习中，要注意领会8086CPU这种工作机制的设计思想。
实际上，这种设计思想对于各种处理机来说是普遍的。
下面的内容中我们将学习一些根据cmp指令的比较结果（即cmp指令执行后，相关标志位的值）
进行工作的指令。
“转移”指的是它能够修改IP，而“条件”指的是它可以根据某种条件，决定是否修改IP。
比如，jcxz就是一个条件转移指令，它可以检测cx中的数值，如果（cx）=0，就修改IP，
否则什么也不做。所有条件转移指令的转移位移都是[-128，127]。
除了jcxz之外，CPU还提供了其他条件转移指令，
大多数条件转移指令都检测标志寄存器的相关标志位，根据检测的结果来决定是否修改IP。
它们检测的是哪些标志位呢？就是被cmp指令影响的那些，表示比较结果的标志位。
这些条件转移指令通常都和cmp相配合使用，就好像call和ret指令通常相配合使用一样。
因为cmp指令可以同时进行两种比较，无符号数比较和有符号数比较，
所以根据cmp指令的比较结果进行转移的指令也分为两种，
即根据无符号数的比较结果进行转移的条件转移指令（它们检测zf、cf的值）
和根据有符号数的比较结果进行转移的条件转移指令（它们检测sf、of和zf的值）。
下面是常用的根据无符号数的比较结果进行转移的条件转移指令。
指令   含义               检测的相关标志位
je       等于则转移     zf=1
jne     不等于则转移  zf=0
jb       低于则转移     cf=1
jnb     不低于则转移  cf=0
ja       高于则转移     cf=0且zf=0
jna    不高于则转移   cf=1或zf=1
这些指令比较常用，它们都很好记忆，它们的第一个字母都是j，表示jump；
后面的字母表示意义如下。
e：表示equal
ne：表示not equal
b：表示below
nb：表示 not below
a：表示above
na：表示not above
注意观察一下它们所检测的标志位，
都是cmp指令进行无符号数比较的时候，记录比较结果的标志位。
比如je，检测zf位，当zf=1的时候进行转移，
如果在je前面使用了cmp指令，那么je对zf的检测，
实际上就是间接地检测cmp的比较结果是否为两数相等。下面看一个例子。
编程实现如下功能：
如果（ah）=（bh）则（ah）=（ah）+（ah），否则（ah）=（ah）+（bh）。
cmp ah,bh
je s
add ah,bh
jmp short ok
s:add ah,ah
ok:
...
上面的程序执行时，如果（ah）=（bh），则cmp ah,bh使zf=1，
而je检测zf是否为1，如果为1，将转移到标号s处执行指令add ah,ah。
这也可以说，cmp比较ah、bh后所得到的相等的结果使得je指令进行转移。
从而很好地体现了je指令的逻辑含义，相等则转移。
虽然je的逻辑含义是“相等则转移”，但它进行的操作是zf=1时则转移。
“相等则转移”这种逻辑含义，是通过和cmp指令配合使用来体现的，
因为是cmp指令为“zf=1”赋予了“两数相等”的含义。
至于究竟在je之前使不使用cmp指令，在于我们的安排。
je检测的是zf位置，不管je前面是什么指令，
只要CPU执行je指令时，zf=1，那么就会发生转移，比如：
mov ax,0
add ax,0
je s
inc ax
s:inc ax
执行后，（ax）=1。add ax,0使得zf=1，所以je指令将进行转移。
可在这个时候发生的转移的确不带有“相等则转移”的含义。
因为此处的je指令检测到的zf=1，不是由cmp等比较指令设置的，
而是由add指令设置的，并不具有“两数相等”的含义。
但无论“zf=1”的含义如何，是什么指令设置的，只要是zf=1，就可以使得je指令发生转移。
CPU提供了cmp指令，也提供了je等条件转移指令，
如果将它们配合使用，可以实现根据比较结果进行转移的功能。
但这只是“如果”，只是一种合理的建议，和事实上常用的方法。
但究竟是否配合使用它们，完全是你自己的事情。这就好像call和ret指令的关系一样。
对于jne、jb、jnb、ja、jna等指令和cmp指令配合使用的思想和je相同，可以自己分析一下。
虽然我们分别讨论了cmp指令和与其比较结果相关的有条件转移指令，
但是它们经常在一起配合使用。所以我们在联合应用它们的时候，
不必再考虑cmp指令对相关标志位的影响和je等指令对相关标志位的检测。
因为相关的标志位，只是为cmp和je等指令传递比较结果。
我们可以直接考虑cmp和je等指令配合使用时，表现出来的逻辑含义。
它们在联合使用的时候表现出来的功能有些像高级语言中的IF语句。
我们来看下面的一组程序。
data段中的8个字节如下：
data segment
db 8,11,8,1,8,5,63,38
data ends
（1）编程，统计data段中数值为8的字节的个数，用ax保存统计结果。
编程思路：初始设置（ax）=0，然后用循环依次比较每个字节的值，
找到一个和8相等的数就将ax的值加1。程序如下。
mov ax,data
mov ds,ax
mov bx,0
mov ax,0
mov cx,8
s:cmp byte ptr ds:[bx],8
jne next
inc ax
next:inc bx
loop s
程序执行后：（ax）=3
assume cs:code
data segment
db 8,11,8,1,8,5,63,38
data ends
code segment
start: mov ax,data
mov ds,ax
mov bx,0
mov ax,0
mov cx,8
s:cmp byte ptr ds:[bx],8
jne next
inc ax
next:inc bx
loop s
mov ax,4c00h
int 21h
code ends
end start
这个程序也可以写成这样：
mov ax,data
mov ds,ax
mov bx,0
mov ax,0
mov cx,8
s:cmp byte ptr ds:[bx],8
je ok
jmp short next
ok:inc ax
next:inc bx
loop s
完整的程序如下
assume cs:code
data segment
db 8,11,8,1,8,5,63,38
data ends
code segment
start: mov ax,data
mov ds,ax
mov bx,0
mov ax,0
mov cx,8
s:cmp byte ptr ds:[bx],8
je ok
jmp short next
ok:inc ax
next:inc bx
loop s
mov ax,4c00h
int 21h
code ends
end start
比起第一个程序，它直接地遵循了“等于8则计数值加1”的原则，
用je指令检测等于8的情况，但是没有第一个程序精简。
第一个程序用jne检测不等于8的情况，从而间接地检测等于8的情况。
要注意在使用cmp和条件转移指令时的这种编程思想。
（2）编程，统计data段中数值大于8的字节的个数，用ax保存统计结果。
编程思路：初始设置（ax）=0，然后用循环依次比较每个字节的值，
找到一个大于8的就将ax的值加1。程序如下。
mov ax,data
mov ds,ax
mov ax,0
mov bx,0
mov cx,8
s:cmp byte ptr ds:[bx],8
jna next
inc ax
next:inc bx
loop s
程序执行后：（ax）=3
assume cs:code
data segment
db 8,11,8,1,8,5,63,38
data ends
code segment
start: mov ax,data
mov ds,ax
mov ax,0
mov bx,0
mov cx,8
s:cmp byte ptr ds:[bx],8
jna next
inc ax
next:inc bx
loop s
mov ax,4c00h
int 21h
code ends
end start
（3）编程，统计data段中数值小于8的字节的个数，用ax保存统计结果。
编程思路：初始设置（ax）=0，然后用循环依次比较每个字节的值，
找到一个小于8的就将ax的值加1。程序如下。
mov ax,data
mov ds,ax
mov ax,0
mov bx,0
mov cx,8
s:cmp byte ptr ds:[bx],8
jnb next
inc ax
next:inc bx
loop s
程序执行后：（ax）=2
assume cs:code
data segment
db 8,11,8,1,8,5,63,38
data ends
code segment
start: mov ax,data
mov ds,ax
mov ax,0
mov bx,0
mov cx,8
s:cmp byte ptr ds:[bx],8
jnb next
inc ax
next:inc bx
loop s
mov ax,4c00h
int 21h
code ends
end start
上面讲解了根据无符号数的比较结果进行转移的条件转移指令。
根据有符号数的比较结果进行转移的条件转移指令的工作原理和无符号的相同，
只是检测了不同的标志位。
我们在这里主要探讨的是cmp、标志寄存器的相关位、条件转移指令三者配合应用的原理，
这个原理具有普遍性，而不是逐条讲解条件转移指令。
对这些指令感兴趣的读者可以查看相关的指令手册。
检测点11.3
（1）补全下面的程序，统计F000:0处32个字节中，大小在[32，128]的数据的个数。
mov ax,0f000h
mov ds,ax
mov bx,0
mov dx,0
mov cx,32
s:mov al,[bx]
cmp al,32
jb s0
cmp al,128
ja s0
inc dx
s0:inc bx
loop s
（2）补全下面的程序，统计F000:0处32个字节中，大小在（32，128）的数据的个数。
mov ax,0f000h
mov ds,ax
mov bx,0
mov dx,0
mov cx,32
s:mov al,[bx]
cmp al,32
jna s0
cmp al,128
jnb s0
inc dx
s0:inc bx
loop s
flag的第10位是DF，方向标志位。在串处理指令中，控制每次操作后si、di的增减。
df=0每次操作后 si、di 递增；.
df=1每次操作后si、di 递减。
我们来看下面的一个串传送指令。
格式：movsb
功能：执行movsb指令相当于进行下面几步操作。
（1）（（es）*16+（di））=（（ds）*16+（si））
（2）如果df=0则：（si）=（si）+1（di）=（di）+1
        如果df=1则：（si）=（si）-1（di）=（di）-1
用汇编语法描述movsb的功能如下。
mov es:[di],byte ptr ds:[si]
8086并不支持这样的指令，这里只是个描述
如果df=0：inc si inc di
如果df=1：dec si dec di
可以看出，movsb的功能是将ds:si指向的内存单元中的字节送入es:di中，
然后根据标志寄存器df位的值，将si和di递增或递减。
当然，也可以传送一个字，指令如下。
格式：movsw
movsw的功能是将ds:si 指向的内存字单元中的字送入es:di 中，
然后根据标志寄存器df位的值，将si和di递增2或递减2。
用汇编语法描述movsw的功能如下。
mov es:[di],word ptr ds:[si]
8086并不支持这样的指令，这里只是个描述
如果df=0：add si,2 add di,2
如果df=1：sub si,2 sub di,2
movsb和movsw进行的是串传送操作中的一个步骤，
一般来说，movsb 和movsw都和rep配合使用，
格式如下：rep movsb
用汇编语法来描述rep movsb的功能就是：
s：movsb
loop s
可见，rep的作用是根据cx的值，重复执行后面的串传送指令。
由于每执行一次movsb指令si 和di都会递增或递减指向后一个单元或前一个单元，
则rep movsb就可以循环实现（cx）个字符的传送。
同理，也可以使用这样的指令：rep movsw。
相当于：
s:movsw
loop s
由于flag的df位决定着串传送指令执行后，si和di改变的方向，
所以CPU应该提供相应的指令来对df位进行设置，从而使程序员能够决定传送的方向。
8086CPU提供下面两条指令对df位进行设置。
cld指令：将标志寄存器的df位置0
std指令：将标志寄存器的df位置1
我们来看下面的两个程序。
（1）编程，用串传送指令，将data段中的第一个字符串复制到它后面的空间中。
data segment
db 'Welcome to masm!'
db 16 dup (0)
data ends
我们分析一下，使用串传送指令进行数据的传送，需要给它提供一些必要的信息，它们是：
①传送的原始位置：ds:si；
②传送的目的位置：es:di；
③传送的长度：cx；
④传送的方向：df。
在这个问题中，这些信息如下。
①传送的原始位置：data:0；
②传送的目的位置：data:0010；
③传送的长度：16；
④传送的方向：因为正向传送（每次串传送指令执行后，si和di递增）比较方便，所以设置df=0。
好了，明确了这些信息之后，我们来编写程序：
mov ax,data
mov ds,ax
mov si,0
mov es,ax
mov di,16
mov cx,16
cld
rep movsb
完整的程序如下
assume cs:code
data segment
db 'Welcome to masm!'
db 16 dup (0)
data ends
code segment
start: mov ax,data
mov ds,ax
mov si,0
mov es,ax
mov di,16
mov cx,16
cld
rep movsb
mov ax,4c00h
int 21h
code ends
end start
（2）编程，用串传送指令，将F000H段中的最后16个字符复制到data段中。
data segment
db 16 dup (0)
data ends
我们还是先来看一下应该为串传送指令提供什么样的信息。
要传送的字符串位于F000H段的最后16个单元中，那么它的最后一个字符的位置：
F000：FFFF，是显而易见的。可以将ds:si指向F000H段的最后一个单元，
将es:di指向data段中的最后一个单元，然后逆向（即从高地址向低地址）传送16个字节即可。
①传送的原始位置：F000:FFFF；
②传送的目的位置：data:000F；
③传送的长度：16；
④传送的方向：因为逆向传送（每次串传送指令执行后，si和di递减）比较方便，所以设置df=1。
程序如下。
mov ax,0f000h
mov ds,ax
mov si,0ffffh
mov ax,data
mov es,ax
mov di,15
mov cx,16
std
rep movsb
完整的程序如下
assume cs:code
data segment
db 16 dup (0)
data ends
code segment
start: mov ax,0f000h
mov ds,ax
mov si,0ffffh
mov ax,data
mov es,ax
mov di,15
mov cx,16
std
rep movsb
mov ax,4c00h
int 21h
code ends
end start
pushf的功能是将标志寄存器的值压栈，而popf是从栈中弹出数据，送入标志寄存器中。
pushf和popf，为直接访问标志寄存器提供了一种方法。
15 14 13 12 11 10  9  8   7   6   5   4  3  2  1  0
                    OF DF IF TF SF ZF       AF   PF     CF
检测点11.4
下面的程序执行后：（ax）=？0045h
mov ax,0
push ax
popf
mov ax,0fff0h
add ax,0010h
pushf
pop ax
and al,11000101B   al = 0100 0101
and ah,00001000B ah = 0000 0000
zf=1 pf=1 cf=1
完整的程序如下
assume cs:code
stack segment
dw 16 dup (0)
stack ends
code segment
start: mov ax,stack
mov ss,ax
mov sp,32
mov ax,0
push ax
popf
mov ax,0fff0h
add ax,0010h
pushf
pop ax
and al,11000101B
and ah,00001000B
mov ax,4c00h
int 21h
code ends
end start
在Debug中，标志寄存器是按照有意义的各个标志位单独表示的。
15 14 13 12 11 10  9  8   7   6   5   4  3  2  1  0
                    OF DF IF TF SF ZF       AF   PF     CF
在Debug中，我们可以看到下面的信息。
AX=0000 BX=0000 CX=0000 DX=0000 SP=FFEE BP=0000 SI=0000 DI=0000
DS=**** ES=**** SS=**** CS=**** IP=0100 NV UP EI PL NZ NA PO NC
                                                                     OF  DF    SF  ZF       PF   CF
下面列出Debug对我们已知的标志位的表示。
标志   值为1的标记 值为0的标记
of      OV               NV
sf      NG               PL
zf      ZR                NZ
pf     PE                 PO
cf     CY                 NC
df    DN                 UP
编写一个子程序，将包含任意字符，以0结尾的字符串中的小写字母转变成大写字母，描述如下。
名称：letterc
功能：将以0结尾的字符串中的小写字母转变成大写字母
参数：ds:si指向字符串首地址
应用举例：
assume cs:codesg
datasg segment
db "Beginner's All-purpose Symbolic Instruction Code.",0
datasg ends
codesg segment
begin:mov ax,datasg
mov ds,ax
mov si,0
call letterc
mov ax,4c00h
int 21h
letterc:
...
codesg ends
end begin
注意需要进行转化的是字符串中的小写字母a～z，而不是其他字符。
完整的程序如下
assume cs:code
data segment
db "Beginner's All-purpose Symbolic Instruction Code.",0
data ends
stack segment
dw 128 dup (0)
stack ends
code segment
start:mov ax,data
mov ds,ax
mov ax,stack
mov ss,ax
mov sp,256
mov si,0
call letterc
mov ax,4c00h
int 21h
letterc:push ax
push si
letterc_s:mov al,ds:[si]
cmp al,0
je ok
cmp al,97
jb next
cmp al,122
ja next
and byte ptr ds:[si],11011111b
next:inc si
jmp letterc_s
ok:pop si
pop ax
ret
code ends
end start
任何一个通用的CPU，比如8086，都具备一种能力，可以在执行完当前正在执行的指令之后，
检测到从CPU外部发送过来的或内部产生的一种特殊信息，
并且可以立即对所接收到的信息进行处理。这种特殊的信息，我们可以称其为：中断信息。
中断的意思是指，CPU不再接着（刚执行完的指令）向下执行，
而是转去处理这个特殊信息。注意，我们这里所说的中断信息，
是为了便于理解而采用的一种逻辑上的说法。
它是对几个具有先后顺序的硬件操作所产生的事件的统一描述。
“中断信息”是要求CPU马上进行某种处理，并向所要进行的该种处理提供了必备的参数的通知信息。
因为本书的内容不是微机原理与接口或组成原理，
我们只能用一些便于理解的说法来描述一些比较复杂的机器工作原理，
从而使学习者忽略一些和我们的学习重心无关的内容。
但笔者又需要对这些问题有一个严谨的交代，所以，有了这些补充说明的文字。
如果你不理解这些文字所讲的东西，就不必去理解了。
中断信息可以来自CPU的内部和外部，这一章中，我们主要讨论来自于CPU内部的中断信息。
当CPU的内部有什么事情发生的时候，将产生需要马上处理的中断信息呢？
对于8086CPU，当CPU内部有下面的情况发生的时候，将产生相应的中断信息。
（1）除法错误，比如，执行div指令产生的除法溢出；
（2）单步执行；
（3）执行into指令；
（4）执行int指令。
我们现在不要去管这4种情况的具体含义，
只要知道CPU内部有4种情况可以产生需要及时处理的中断信息即可。
虽然我们现在并不很清楚，这4种情况到底是什么，
但是有一点是很清楚的，即，它们是不同的信息。
既然是不同的信息，就需要进行不同的处理。
要进行不同的处理，CPU首先要知道，所接收到的中断信息的来源。
所以中断信息中必须包含识别来源的编码。
8086CPU用称为中断类型码的数据来标识中断信息的来源。
中断类型码为一个字节型数据，可以表示256种中断信息的来源。
以后，我们将产生中断信息的事件，即中断信息的来源，简称为中断源，
上述的4种中断源，在8086CPU中的中断类型码如下。
（1）除法错误：0
（2）单步执行：1
（3）执行into指令：4
（4）执行int指令，该指令的格式为int n，
指令中的n为字节型立即数，是提供给CPU的中断类型码。
CPU收到中断信息后，需要对中断信息进行处理。
而如何对中断信息进行处理，可以由我们编程决定。
我们编写的，用来处理中断信息的程序被称为中断处理程序。
一般来说，需要对不同的中断信息编写不同的处理程序。
CPU在收到中断信息后，应该转去执行该中断信息的处理程序。
我们知道，若要8086CPU执行某处的程序，
就要将CS:IP指向它的入口（即程序第一条指令的地址）。
可见首要的问题是，CPU在收到中断信息后，如何根据中断信息确定其处理程序的入口。
CPU的设计者必须在中断信息和其处理程序的入口地址之间建立某种联系，
使得CPU根据中断信息可以找到要执行的处理程序。
我们知道，中断信息中包含有标识中断源的类型码。
根据CPU的设计，中断类型码的作用就是用来定位中断处理程序。
比如CPU根据中断类型码4，就可以找到4号中断的处理程序。
可随之而来的问题是，若要定位中断处理程序，需要知道它的段地址和偏移地址，
而如何根据8位的中断类型码得到中断处理程序的段地址和偏移地址呢？
CPU用8位的中断类型码通过中断向量表找到相应的中断处理程序的入口地址。
那么什么是中断向量表呢？中断向量表就是中断向量的列表。
那么什么又是中断向量呢？所谓中断向量，就是中断处理程序的入口地址。
展开来讲，中断向量表，就是中断处理程序入口地址的列表。
中断向量表在内存中保存，其中存放着256个中断源所对应的中断处理程序的入口，如图12.1所示。
0号中断源对应的
中断处理程序的入口地址
1号中断源对应的
中断处理程序的入口地址
2号中断源对应的
中断处理程序的入口地址
3号中斯源对应的
中断处理程序的入口地址
图12.1中断向量表
可以看到，CPU只要知道了中断类型码，就可以将中断类型码作为中断向量表的表项号，
定位相应的表项，从而得到中断处理程序的入口地址。
可见，CPU用中断类型码，通过查找中断向量表，就可以得到中断处理程序的入口地址。
在这个方案中，一个首要的问题是，CPU如何找到中断向量表？
现在，找到中断向量表成了通过中断类型码找到中断处理程序入口地址的先决条件。
中断向量表在内存中存放，对于8086PC机，中断向量表指定放在内存地址0处。
从内存0000：0000到0000：03FF的1024个单元中存放着中断向量表。能不能放在别处呢？
不能，如果使用8086CPU，中断向量表就必须放在0000：0000~0000：03FF单元中，
这是规定，因为8086CPU就从这个地方读取中断向量表。
那么在中断向量表中，一个表项占多大的空间呢？
一个表项存放一个中断向量，也就是一个中断处理程序的入口地址，
对于8086CPU，这个入口地址包括段地址和偏移地址，所以一个表项占两个字，
高地址字存放段地址，低地址字存放偏移地址。
检测点12.1
（1）用Debug查看内存，情况如下：
0000：0000 68 10 A7 00 8B 01 70 00-16 00 9D 03 8B 01 70 00
则3号中断源对应的中断处理程序的入口地址为：0070:018B。
（2）存储N号中断源对应的中断处理程序入口的偏移地址的内存单元的地址为：4N。
存储N号中断源对应的中断处理程序入口的段地址的内存单元的地址为：4N+2。
从上面的讲解中，我们知道，可以用中断类型码，在中断向量表中找到中断处理程序的入口。
找到这个入口地址的最终目的是用它设置CS和IP，使CPU执行中断处理程序。
用中断类型码找到中断向量，并用它设置CS和IP，这个工作是由CPU的硬件自动完成的。
CPU硬件完成这个工作的过程被称为中断过程。
CPU收到中断信息后，要对中断信息进行处理，首先将引发中断过程。
硬件在完成中断过程后，CS:IP将指向中断处理程序的入口，CPU开始执行中断处理程序。
有一个问题需要考虑，CPU在执行完中断处理程序后，应该返回原来的执行点继续执行下面的指令。
所以在中断过程中，在设置CS:：IP之前，还要将原来的CS和IP的值保存起来。
在使用call 指令调用子程序时有同样的问题，子程序执行后还要返回到原来的执行点继续执行，
所以，call指令先保存当前CS和IP的值，然后再设置CS和IP。
下面是8086CPU在收到中断信息后，所引发的中断过程。
（1）（从中断信息中）取得中断类型码；
（2）标志寄存器的值入栈（因为在中断过程中要改变标志寄存器的值，所以先将其保存在栈中）；
（3）设置标志寄存器的第8位TF和第9位IF的值为0（这一步的目的后面将介绍）；
（4）CS的内容入栈；
（5）IP的内容入栈；
（6）从内存地址为中断类型码*4和中断类型码*4+2的两个字单元中
读取中断处理程序的入口地址设置IP和CS。
CPU在收到中断信息之后，如果处理该中断信息，
就完成一个由硬件自动执行的中断过程（程序员无法改变这个过程中所要做的工作）。
中断过程的主要任务就是用中断类型码在中断向量表中找到中断处理程序的入口地址，设置CS和IP。
因为中断处理程序执行完成后，CPU还要回过头来继续执行被中断的程序，
所以要在设置CS、IP之前，先将它们的值保存起来。可以看到CPU将它们保存在栈中。
我们注意到，在中断过程中还要做的一个工作就是设置标志寄存器的TF、IF位，
对于这样做的目的，我们将在后面的内容和下一章中进行讨论。
因为在执行完中断处理程序后，需要恢复在进入中断处理程序之前的CPU现场
（某一时刻，CPU中各个寄存器的值）。所以应该在修改标记寄存器之前，将它的值入栈保存。
我们更简洁地描述中断过程，如下：
（1）取得中断类型码N；
（2）pushf
（3）TF=0，IF=0
（4）push CS
（5）push IP
（6）（IP）=（N*4），（CS）=（N*4+2）
在最后一步完成后，CPU开始执行由程序员编写的中断处理程序。
由于CPU随时都可能检测到中断信息，也就是说，CPU随时都可能执行中断处理程序，
所以中断处理程序必须一直存储在内存某段空间之中。
而中断处理程序的入口地址，即中断向量，必须存储在对应的中断向量表表项中。
中断处理程序的编写方法和子程序的比较相似，下面是常规的步骤：
（1）保存用到的寄存器；
（2）处理中断；
（3）恢复用到的寄存器；
（4）用iret指令返回。
iret 指令的功能用汇编语法描述为：
pop IP
pop CS
popf
iret通常和硬件自动完成的中断过程配合使用。
可以看到，在中断过程中，寄存器入栈的顺序是标志寄存器、CS、IP，
而iret的出栈顺序是IP、CS、标志寄存器，刚好和其相对应，
实现了用执行中断处理程序前的CPU现场恢复标志寄存器和CS、IP的工作。
iret指令执行后，CPU回到执行中断处理程序前的执行点继续执行程序。
下面的内容中，我们通过对0号中断，即除法错误中断的处理，来体会一下前面所讲的内容。
当CPU执行div等除法指令的时候，如果发生了除法溢出错误，将产生中断类型码为0的中断信息，
CPU将检测到这个信息，然后引发中断过程，转去执行0号中断所对应的中断处理程序。
我们看一下下面程序的执行结果，如图12.2所示（不同的操作系统下显示可能不同）。
mov ax,1000h
mov bh,1
div bh
可以看到，当CPU执行div bh时，发生了除法溢出错误，产生0号中断信息，从而引发中断过程，
CPU执行0号中断处理程序。我们从图中可以看出系统中的0号中断处理程序的功能：
显示提示信息“Divide overflow”后，返回到操作系统中。
现在我们考虑改变一下0号中断处理程序的功能，即重新编写一个0号中断处理程序，
它的功能是在屏幕中间显示“overflow!”，然后返回到操作系统，如图12.3所示。
当CPU执行div bh后，发生了除法溢出错误，产生0号中断信息，引发中断过程，
CPU执行我们编写的0号中断处理程序。在屏幕中间显示提示信息“overflow！”后，
返回到操作系统中。
编程：当发生除法溢出时，在屏幕中间显示“overflow!”，返回DOS。
我们首先进行分析：
（1）当发生除法溢出的时候，产生0号中断信息，从而引发中断过程。
此时，CPU将进行以下工作。
①取得中断类型码0；
②标志寄存器入栈，TF、IF设置为0；
③CS、IP入栈；
④（IP）=（0*4），（CS）=（0*4+2）。
（2）可见，当中断0发生时，CPU将转去执行中断处理程序。
只要按如下步骤编写中断处理程序，当中断0发生时，即可显示“overflow！”。
①相关处理；
②向显示缓冲区送字符串“overflow!”；
③返回DOS。
我们将这段程序称为：do0。
（3）现在的问题是：do0应存放在内存中。因为除法溢出随时可能发生，
CPU随时都可能将CS:IP指向do0的入口，执行程序。
那么do0应该放在哪里呢？？
由于我们是在操作系统之上使用计算机，所有的硬件资源都在操作系统的管理之下，
所以我们要想得到一块内存区存放do0，应该向操作系统申请。
但在这里出于两个原因我们不想这样做：
①过多地讨论申请内存将偏离问题的主线；
②我们学习汇编的一个重要目的就是要获得对计算机底层的编程体验。
所以，在可能的情况下，我们不去理会操作系统，而直接面向硬件资源。
问题变得简单而直接，我们只需找到一块别的程序不会用到的内存区，将do0传送到其中即可。
前面讲到，内存0000：0000-0000：03FF，
大小为1KB的空间是系统存放中断处理程序入口地址的中断向量表。
8086支持256个中断，但是，实际上，系统中要处理的中断事件远没有达到256个。
所以在中断向量表中，有许多单元是空的。
中断向量表是PC系统中最重要的内存区，只用来存放中断处理程序的入口地址，
DOS系统和其他应用程序都不会随便使用这段空间。
可以利用中断向量表中的空闲单元来存放我们的程序。
一般情况下，从0000：0200至0000：02FF的256个字节的空间所对应的中断向量表项都是空的，
操作系统和其他应用程序都不占用。我们在前面的课程中使用过这段空间（参见5.7节）。
根据以前的编程经验，我们可以估计出，do0的长度不可能超过256个字节。
结论：我们可以将do0传送到内存0000：0200处。
（4）将中断处理程序do0放到0000：0200后，若要使得除法溢出发生的时候，
CPU转去执行do0，则必须将do0的入口地址，即0000：0200登记在中断向量表的对应表项中。
因为除法溢出对应的中断类型码为0，它的中断处理程序的入口地址应该从0*4地址单元开始存放，
段地址存放在0*4+2字单元中，偏移地址存放在0*4字单元中。
也就是说要将do0的段地址0存放在0000：0002字单元中，
将偏移地址200H存放在0000：0000字单元中。
总结上面的分析，我们要做以下几件事情。
（1）编写可以显示“overflow!”的中断处理程序：do0；
（2）将do0送入内存0000：0200处；
（3）将do0的入口地址0000：0200存储在中断向量表0号表项中。
程序的框架如下。
程序12.1
assume cs:code
code segment
start:do0 安装程序
设置中断向量表
mov ax,4c00h
int 21h
do0:显示字符串"overflow!"
mov ax,4c00h
int 21h
code ends
end start
可以看到，上面的程序分为两部分：
（1）安装do0，设置中断向量的程序；
（2）do0。
程序12.1执行时，do0的代码是不执行的，它只是作为do0安装程序所要传送的数据。
程序12.1执行时，首先执行do0安装程序，将do0的代码复制到内存0：200处，
然后设置中断向量表，将do0的入口地址，即偏移地址200H和段地址0，保存在0号表项中。
这两部分工作完成后，程序就返回了。程序的目的就是在内存0：200处安装do0的代码，
将0号中断处理程序的入口地址设置为0：200。
do0的代码虽然在程序中，却不在程序执行的时候执行。
它是在除法溢出发生的时候才得以执行的中断处理程序。
do0部分代码的最后两条指令是依照我们的编程要求，用来返回DOS的。
现在，我们在反过来从CPU的角度看一下，什么是中断处理程序？
我们来看一下do0是如何变成0号中断的中断处理程序的。
（1）程序12.1在执行时，被加载到内存中，此时do0的代码在程序12.1所在的内存空间中，
它只是存放在程序12.1的代码段中的一段要被传送到其他单元中的数据，
我们不能说它是0号中断的中断处理程序；
（2）程序12.1中安装do0的代码执行完后，do0的代码被从程序12.1的代码段中复制到0：200处。
此时，我们也不能说它是0号中断的中断处理程序，它只不过是存放在0：200处的一些数据；
（3）程序12.1中设置中断向量表的代码执行完后，在0号表项中填入了do0的入口地址0：200，
此时0：200处的信息，即do0的代码，就变成了0号中断的中断处理程序。
因为当除法溢出（即0号中断）发生时，CPU将执行0：200处的代码。
回忆一下：
我们如何让一个内存单元成为栈顶？将它的地址放入SS、SP中；
我们如何让一个内存单元中的信息被CPU当作指令来执行？将它的地址放入CS、IP中；
那么，我们如何让一段程序成为N号中断的中断处理程序？
将它的入口地址放入中断向量表的N号表项中。
下面的内容中，我们讨论每一部分程序的具体编写方法。
可以使用movsb指令，将do0的代码送入0：200处。程序如下。
assume cs:code
code segment
start:设置es:di指向目的地址
设置ds:si指向源地址
设置cx为传输长度
设置传输方向为正
rep movsb
设置中断向量表
mov ax,4c00h
int 21h
do0:显示字符串"overflow!"
mov ax,4c00h
int 21h
code ends
end start
我们来看一下，用rep movsb指令的时候要确定的信息。
（1）传送的原始位置，段地址：code，偏移地址：offset do0；
（2）传送的目的位置：0：200；
（3）传送的长度：do0部分代码的长度；
（4）传送的方向：正向。
更明确的程序如下。
assume cs:code
code segment
start:mov ax,cs
mov ds,ax
mov si,offset do0
mov ax,0
mov es,ax
mov di,200h
mov cx,do0部分代码的长度
cld
rep movsb
设置中断向量表
mov ax,4c00h
int 21h
do0:显示字符串"overflow!"
mov ax,4c00h
int 21h
code ends
end start
问题是，我们如何知道do0代码的长度？
最简单的方法是，计算一下do0中所有指令码的字节数。
但是这样做太麻烦了，因为只要do0的内容发生了改变，我们都要重新计算它的长度。
可以利用编译器来计算do0的长度，具体做法如下。
assume cs:code
code segment
start:mov ax,cs
mov ds,ax
mov si,offset do0
mov ax,0
mov es,ax
mov di,200h
mov cx,offset do0end-offset do0
cld
rep movsb
设置中断向量表
mov ax,4c00h
int 21h
do0:显示字符串"overflow!"
mov ax,4c00h
int 21h
do0end:nop
code ends
end start
“-”是编译器识别的运算符号，编译器可以用它来进行两个常数的减法。
比如，指令：mov ax,8-4，被编译器处理为指令：mov ax,4。
汇编编译器可以处理表达式。
比如，指令：mov ax,(5+3)*5/10，被编译器处理为指令：mov ax,4。
好了，知道了“-”的含义，对于用offset do0end-offset do0，得到do0代码的长度的原理，
这里就不再多说了，相信到了现在，读者已可以自己进行分析了。
下面我们编写do0程序。
do0程序的主要任务是显示字符串，程序如下。
do0:设置ds:si指向字符串
mov ax,0b800h
mov es,ax
mov di,12*160+36*2
mov cx,9
s:mov al,ds:[si]
mov es:[di],al
inc si
add di,2
loop s
mov ax,4c00h
int 21h
do0end:nop
程序写好了，可要显示的字符串放在那里呢？我们看下面的程序。
程序12.2
assume cs:code
data segment
db "overflow!"
data ends
code segment
start:mov ax,cs
mov ds,ax.
mov si,offset do0
mov ax,0
mov es,ax
mov di,200h
mov cx,offset dooend-offset do0
cld
rep movsb
设置中断向量表
mov ax,4c00h
int 21h
do0:mov ax,data
mov ds,ax
mov ax,0b800h
mov es,ax
mov di,12*160+36*2
mov cx,9
s:mov al,[si]
mov es:[di],al
inc si
add di,2
loop s
mov ax,4c00h
int 21h
do0end:nop
code ends
end start
上面的程序，看似合理，可实际上却大错特错。注意，“overflow！”在程序12.2的data段中。
程序12.2执行完成后返回，它所占用的内存空间被系统释放，
而在其中存放的“overflow！”也将很可能被别的信息覆盖。
而do0程序被放到了0：200处，随时都会因发生了除法溢出而被CPU执行，
很难保证do0程序从原来程序12.2所处的空间中取得的是要显示的字符串“overflow！”。
因为do0程序随时可能被执行，而它要用到字符串“overflow！”，
所以该字符串也应该存放在一段不会被覆盖的空间中。
正确的程序如下。
程序12.3
assume cs:code
code segment
start:mov ax,cs
mov ds,ax
mov si,offset do0
mov ax,0
mov es,ax
mov di,200h
mov cx,offset do0end-offset do0
cld
rep movsb
设置中断向量表
mov ax,4c00h
int 21h
do0:jmp short do0start
db "overflow!"
do0start:mov ax,cs
mov ds,ax
mov si,202h
mov ax,0b800h
mov es,ax
mov di,12*160+36*2
mov cx,9
s:mov al,[si]
mov es:[di],al
inc si
add di,2
loop s
mov ax,4c00h
int 21h
do0end:nop
code ends
end start
在程序12.3中，将“overflow!”放到do0程序中，程序12.3执行时，
将标号do0到标号do0end之间的内容送到0000：0200处。
注意，因为在do0程序开始处的“overflow!”不是可以执行的代码，所以在
“overflow!”之前加上一条jmp指令，转移到正式的do0程序。
当除法溢出发生时，CPU执行0：200处的jmp指令，跳过后面的字符串，转到正式的do0程序执行。
do0程序执行过程中必须要找到“overflow!”，那么它在哪里呢？首先来看段地址，
“overflow!”和do0的代码处于同一个段中，而除法溢出发生时，CS中必然存放do0的段地址，
也就是“overflow!”的段地址；再来看偏移地址，0：200处的指令为jmp short do0start，
这条指令占两个字节，所以“overflow!”的偏移地址为202h。
下面，将do0的入口地址0：200，写入中断向量表的0号表项中，
使do0成为0号中断的中断处理程序。
0号表项的地址为0：0，其中0：0字单元存放偏移地址，0：2字单元存放段地址。程序如下。
mov ax,0
mov es,ax
mov word ptr es:[0*4],200h
mov word ptr es:[0*4+2],0
完整的程序如下
assume cs:code
code segment
start:mov ax,cs
mov ds,ax
mov si,offset do0
mov ax,0
mov es,ax
mov di,200h
mov cx,offset do0end-offset do0
cld
rep movsb
mov word ptr es:[0],200h
mov word ptr es:[2],0
mov ax,1000h
mov bh,1
div bh
mov ax,4c00h
int 21h
do0:jmp short do0start
db "overflow!",0
do0start:mov ax,cs
mov ds,ax
mov si,202h
mov ax,0b800h
mov es,ax
mov di,1992
mov ah,7
do0_s:mov al,ds:[si]
cmp al,0
je do0_ok
mov es:[di],ax
inc si
add di,2
jmp short do0_s
do0_ok:mov ax,4c00h
int 21h
do0end:nop
code ends
end start
基本上，CPU在执行完一条指令之后，
如果检测到标志寄存器的TF位为1，则产生单步中断，引发中断过程。
单步中断的中断类型码为1，则它所引发的中断过程如下。
（1）取得中断类型码1；
（2）标志寄存器入栈，TF、IF设置为0；
（3）CS、IP入栈；
（4）（IP）=（1*4），（CS）=（1*4+2）。
如上所述，如果TF=1，则执行一条指令后，CPU就要转去执行1号中断处理程序。
CPU为什么要提供这样的功能呢？
我们在使用Debug的t命令的时候，有没有想过这样的问题，
Debug如何能让CPU在执行一条指令后，就显示各个寄存器的状态？
我们知道，CPU在执行程序的时候是从CS:IP指向的某个地址开始，自动向下读取指令执行。
也就是说，如果CPU不提供其他功能的话，就按这种方式工作，
只要CPU一加电，它就从预设的地址开始一直执行下去，
不可能有任何程序能控制它在执行完一条指令后停止，去做别的事情。
可是，我们在Debug中看到的情况却是，Debug可以控制CPU执行被加载程序中的一条指令，
然后让它停下来，显示寄存器的状态。
Debug 有特殊的能力吗？我们只能说Debug利用了CPU提供的一种功能。
只有CPU提供了在执行一条指令后就转去做其他事情的功能，
Debug或是其他的程序才能利用CPU提供的这种功能做出我们使用T命令时的效果。
好了，我们来简要地考虑一下Debug是如何利用CPU所提供的单步中断的功能的。
首先，Debug提供了单步中断的中断处理程序，功能为显示所有寄存器中的内容后等待输入命令。
然后，在使用t命令执行指令时，Debug将TF设置为1，使得CPU工作于单步
中断方式下，则在CPU执行完这条指令后就引发单步中断，执行单步中断的中断处理程序，
所有寄存器中的内容被显示在屏幕上，并且等待输入命令。
那么，接下来的问题是，当TF=1时，CPU在执行完一条指令后将引发单步中断，
转去执行中断处理程序。注意，中断处理程序也是由一条条指令组成的，
如果在执行中断处理程序之前，TF=1，则CPU在执行完中断处理程序的第一条指令后，
又要产生单步中断，则又要转去执行单步中断的中断处理程序，
在执行完中断处理程序的第一条指令后，又要产生单步中断，
则又要转去执行单步中断的中断处理程序……
看来，上面的过程将陷入一个永远不能结束的循环，
CPU永远执行单步中断处理程序的第一条指令。
CPU当然不能让这种情况发生，解决的办法就是，在进入中断处理程序之前，设置TF=0。
从而避免CPU在执行中断处理程序的时候发生单步中断。
这就是为什么在中断过程中有TF=0这个步骤，我们再来看一下中断过程。
（1）取得中断类型码N；
（2）标志寄存器入栈，TF=0、IF=0；
（3）CS、IP入栈；
（4）（IP）=（N*4），（CS）=（N*4+2）。
最后，CPU提供单步中断功能的原因就是，为单步跟踪程序的执行过程，提供了实现机制。
一般情况下，CPU在执行完当前指令后，如果检测到中断信息，就响应中断，引发中断过程。
可是，在有些情况下，CPU在执行完当前指令后，即便是发生中断，也不会响应。
对于这些情况，我们不一一列举，只是用一种情况来进行说明。
在执行完向ss寄存器传送数据的指令后，即便是发生中断，CPU也不会响应。
这样做的主要原因是，ss:sp联合指向栈顶，而对它们的设置应该连续完成。
如果在执行完设置ss的指令后，CPU响应中断，引发中断过程，
要在栈中压入标志寄存器、CS和IP的值。而ss改变，sp并未改变，ss:sp指向的不是正确的栈顶，
将引起错误。所以CPU在执行完设置ss的指令后，不响应中断。
这给连续设置ss和sp指向正确的栈顶提供了一个时机。
即，我们应该利用这个特性，将设置ss和sp的指令连续存放，
使得设置sp的指令紧接着设置ss的指令执行，而在此之间，CPU不会引发中断过程。
比如，我们要将栈顶设为1000：0，应该：
mov ax,1000h
mov ss,ax
mov sp,0
而不应该：
mov ax,1000h
mov ss,ax
mov ax,0
mov sp,0
好了，现在我们回过来看一下，实验2中的“（3）下一条指令执行了吗？”。现在你知道原因了吗？
Debug利用单步中断来实现T命令的功能，也就是说，
用T命令执行一条指令后，CPU响应单步中断，执行Debug设置好的处理程序，
才能在屏幕上显示寄存器的状态，并等待命令的输入。
而在mov ss,ax指令执行后，CPU根本就不响应任何中断，其中也包括单步中断，
所以Debug设置好的用来显示寄存器状态和等待输入命令的中断处理程序根本没有得到执行，
所以我们看不到预期的结果。CPU接着向下执行后面的指令mov sp,10h，
然后响应单步中断，我们才看到正常的结果。
编写0号中断的处理程序，使得在除法溢出发生时，
在屏幕中间显示字符串“divide error!”，然后返回到DOS。
要求：仔细跟踪调试，在理解整个过程之前，不要进行后面课程的学习。
完整的程序如下
assume cs:code
code segment
start:mov ax,cs
mov ds,ax
mov si,offset do0
mov ax,0
mov es,ax
mov di,200h
mov cx,offset do0end-offset do0
cld
rep movsb
mov word ptr es:[0],200h
mov word ptr es:[2],0
mov ax,1000h
mov bh,1
div bh
mov ax,4c00h
int 21h
do0:jmp short do0start
db "divide error!",0
do0start:mov ax,cs
mov ds,ax
mov si,202h
mov ax,0b800h
mov es,ax
mov di,1992
mov ah,7
do0_s:mov al,ds:[si]
cmp al,0
je do0_ok
mov es:[di],ax
inc si
add di,2
jmp short do0_s
do0_ok:mov ax,4c00h
int 21h
do0end:nop
code ends
end start
中断信息可以来自CPU的内部和外部，当CPU的内部有需要处理的事情发生的时候，
将产生需要马上处理的中断信息，引发中断过程。
在第12章中，我们讲解了中断过程和两种内中断的处理。
这一章中，我们讲解另一种重要的内中断，由int指令引发的中断。
int指令的格式为：int n，n为中断类型码，它的功能是引发中断过程。
CPU执行int n指令，相当于引发一个n号中断的中断过程，执行过程如下。
（1）取中断类型码n；
（2）标志寄存器入栈，IF=0，TF=0；
（3）CS、IP入栈；
（4）（IP）=（n*4），（CS）=（n*4+2）。
从此处转去执行n号中断的中断处理程序。
可以在程序中使用int指令调用任何一个中断的中断处理程序。例如，下面的程序：
assume cs:code
code segment
start:mov ax,0b800h
mov es,a
mov byte ptr es:[12*160+40*2],'!'
int 0
code ends
end start
完整的程序如下
assume cs:code
code segment
start:mov ax,0b800h
mov es,ax
mov byte ptr es:[2000],'!'
int 0
code ends
end start
这个程序在Windows2000中的DOS方式下执行时，将在屏幕中间显示一个“！”，
然后显示“Divide overflow”后返回到系统中。“！”是我们编程显示的，
而“Divide overflow”是哪里来的呢？我们的程序中又没有做除法，不可能产生除法溢出。
程序是没有做除法，但是在结尾使用了int 0指令。
CPU执行int 0指令时，将引发中断过程，执行0号中断处理程序，
而系统设置的0号中断处理程序的功能是显示“Divide overflow”，然后返回到系统。
可见，int指令的最终功能和call指令相似，都是调用一段程序。
一般情况下，系统将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用。
我们在编程的时候，可以用int 指令调用这些子程序。
当然，也可以自己编写一些中断处理程序供别人使用。
以后，我们可以将中断处理程序简称为中断例程。
前面，我们已经编写过中断0的中断例程了，
现在我们讨论可以供应用程序调用的中断例程的编写方法。
下面通过两个问题来讨论。
问题一：编写、安装中断7ch的中断例程。
功能：求一word型数据的平方。
参数：（ax）=要计算的数据。
返回值：dx、ax中存放结果的高16位和低16位。
应用举例：求2*3456的平方。
assume cs:code
code segment
start:mov ax,3456
int 7ch
add ax,ax
adc dx,dx
mov ax,4c00h
int 21h
code ends
end start
分析一下，我们要做以下3部分工作。
（1）编写实现求平方功能的程序；
（2）安装程序，将其安装在0：200处；
（3）设置中断向量表，将程序的入口地址保存在7ch表项中，使其成为中断7ch的中断例程。
安装程序如下。
assume cs:code
code segment
start:mov ax,cs
mov ds,ax
mov si,offset sqr
mov ax,0
mov es,ax
mov di,200h
mov cx,offset sqrend-offset sqr
cld
rep movsb
mov ax,0
mov es,ax
mov word ptr es:[7ch*4],200h
mov word ptr es:[7ch*4+2],0
mov ax,4c00h
int 21h
sqr:mul ax
iret
sqrend:nop
code ends
end start
完整的程序如下
assume cs:code
code segment
start:mov ax,cs
mov ds,ax
mov si,offset sqr
mov ax,0
mov es,ax
mov di,200h
mov cx,offset sqrend-offset sqr
cld
rep movsb
mov word ptr es:[496],200h
mov word ptr es:[498],0
mov ax,3456
int 7ch
add ax,ax
adc dx,dx
mov ax,4c00h
int 21h
sqr:mul ax
iret
sqrend:nop
code ends
end start
注意，在中断例程sqr的最后，要使用iret指令。用汇编语法描述，iret指令的功能为：
pop IP
pop CS
popf
CPU执行int 7ch指令进入中断例程之前，标志寄存器、当前的CS和IP被压入栈中，
在执行完中断例程后，应该用iret指令恢复int 7ch执行前的标志寄存器和CS、IP的值，
从而接着执行应用程序。
int指令和iret指令的配合使用与call 指令和ret指令的配合使用具有相似的思路。
问题二：编写、安装中断7ch的中断例程。
功能：将一个全是字母，以0结尾的字符串，转化为大写。
参数：ds:si指向字符串的首地址。
应用举例：将data段中的字符串转化为大写。
assume cs:code
data segment
db 'conversation',0
data ends
code segment
start:mov ax,data
mov ds,ax
mov si,0
int 7ch
mov ax,4c00h
int 21h
code ends
end start
安装程序如下。
assume cs:code
code segment
start:mov ax,cs
mov ds,ax
mov si,offset capital
mov ax,0
mov es,ax
mov di,200h
mov cx,offset capitalend-offset capital
cld
rep movsb
mov ax,0
mov es,ax
mov word ptr es:[7ch*4],200h
mov word ptr es:[7ch*4+2],0
mov ax,4c00h
int 21h
capital:push cx
push si
change:mov cl,ds:[si]
mov ch,0
jcxz ok
and byte ptr ds:[si],11011111b
inc si
jmp short change
ok:pop si
pop cx
iret
capitalend:nop
code ends
end start
完整的程序如下
assume cs:code
data segment
db 'conversation',0
data ends
code segment
start:mov ax,cs
mov ds,ax
mov si,offset capital
mov ax,0
mov es,ax
mov di,200h
mov cx,offset capitalend-offset capital
cld
rep movsb
mov word ptr es:[496],200h
mov word ptr es:[498],0
mov ax,data
mov ds,ax
mov si,0
int 7ch
mov ax,4c00h
int 21h
capital:push cx
push si
change:mov cl,ds:[si]
mov ch,0
jcxz ok
and byte ptr ds:[si],11011111b
inc si
jmp short change
ok:pop si
pop cx
iret
capitalend:nop
code ends
end start
在中断例程capital中用到了寄存器si和cx，编写中断例程和编写子程序的时候具有
同样的问题，就是要避免寄存器的冲突。应该注意例程中用到的寄存器的值的保存和恢复。
问题：用7ch中断例程完成loop指令的功能。
loop s的执行需要两个信息，循环次数和到s的位移，所以，7ch中断例程要完成loop指令的功能，
也需要这两个信息作为参数。我们用cx存放循环次数，用bx存放位移。
应用举例：在屏幕中间显示80个'!'。
assume cs:code
code segment
start:mov ax,0b800h
mov es,ax
mov di,160*12
mov bx,offset s-offset se
mov cx,80
s:mov byte ptr es:[di],'!'
add di,2
int 7ch
se:nop
mov ax,4c00h
int 21h
code ends
end start
在上面的程序中，用int 7ch调用7ch中断例程进行转移，用bx传递转移的位移。
分析：为了模拟loop指令，7ch中断例程应具备下面的功能。
（1）dec cx；
（2）如果（cx）不等于0，转到标号s处执行，否则向下执行。
下面我们分析7ch中断例程如何实现到目的地址的转移。
（1）转到标号s显然应设（CS）=标号s的段地址，（IP）=标号s的偏移地址。
（2）那么，中断例程如何得到标号s的段地址和偏移地址呢？
int 7ch引发中断过程后，进入7ch中断例程，
在中断过程中，当前的标志寄存器、CS和IP都要压栈，
此时压入的CS和IP中的内容，分别是调用程序的段地址（可以认为是标号s的段地址）
和int 7ch后一条指令的偏移地址（即标号se的偏移地址）。
可见，在中断例程中，可以从栈里取得标号s的段地址和标号se的偏移地址，
而用标号se的偏移地址加上bx中存放的转移位移就可以得到标号s的偏移地址。
（3）现在知道，可以从栈中直接和间接地得到标号s的段地址和偏移地址，
那么如何用它们设置CS:IP呢？
可以利用iret指令，我们将栈中的se的偏移地址加上bx中的转移位移，
则栈中的se的偏移地址就变为了s的偏移地址。
我们再使用iret指令，用栈中的内容设置CS、IP，从而实现转移到标号s处。
7ch中断例程如下。
lp:push bp
mov bp,sp
dec cx
jcxz lpret
add ss:[bp+2],bx
lpret:pop bp
iret
完整的程序如下
assume cs:code
code segment
start:mov ax,cs
mov ds,ax
mov si,offset lp
mov ax,0
mov es,ax
mov di,200h
mov cx,offset lpend-offset lp
cld
rep movsb
mov word ptr es:[496],200h
mov word ptr es:[498],0
mov ax,0b800h
mov es,ax
mov di,1920
mov bx,offset s-offset se
mov cx,80
s:mov byte ptr es:[di],'!'
mov byte ptr es:[di+1],7
add di,2
int 7ch
se:nop
mov ax,4c00h
int 21h
lp:push bp
mov bp,sp
dec cx
jcxz lpret
add ss:[bp+2],bx
lpret:pop bp
iret
lpend:nop
code ends
end start
因为要访问栈，使用了bp，在程序开始处将bp入栈保存，结束时出栈恢复。
当要修改栈中se的偏移地址的时候，栈中的情况为：栈顶处是bp原来的数值，
下面是se的偏移地址，再下面是s的段地址，再下面是标志寄存器的值。
而此时，bp中为栈顶的偏移地址，所以（（ss）*16+（bp）+2）处为se的偏移地址，
将它加上bx中的转移位移就变为s的偏移地址。
最后用iret出栈返回，CS:IP即从标号s处开始执行指令。
如果（cx）=0，则不需要修改栈中se的偏移地址，直接返回即可。
CPU从标号se处向下执行指令。
检测点13.1
（1）在上面的内容中，我们用7ch中断例程实现loop的功能，
则上面的7ch中断例程所能进行的最大转移位移是多少？
[-32768,32767]
（2）用7ch中断例程完成jmp near ptr s指令的功能，用bx向中断例程传送转移位移。
应用举例：在屏幕的第12行，显示data段中以0结尾的字符串。
assume cs:code
data segment
db 'conversation',0
data ends
code segment
start:mov ax,data
mov ds,ax
mov si,0
mov ax,0b800h
mov es,ax
mov di,12*160
s:cmp byte ptr ds:[si],0
je ok
mov al,ds:[si]
mov es:[di],al
inc si
add di,2
mov bx,offset s-offset ok
int 7ch
ok:mov ax,4c00h
int 21h
code ends
end start
完整的程序如下
assume cs:code
data segment
db 'conversation',0
data ends
code segment
start:mov ax,cs
mov ds,ax
mov si,offset jmpnp
mov ax,0
mov es,ax
mov di,200h
mov cx,offset jmpnpend-offset jmpnp
cld
rep movsb
mov word ptr es:[496],200h
mov word ptr es:[498],0
mov ax,data
mov ds,ax
mov si,0
mov ax,0b800h
mov es,ax
mov di,1920
s:cmp byte ptr ds:[si],0
je ok
mov al,ds:[si]
mov es:[di],al
mov byte ptr es:[di+1],7
inc si
add di,2
mov bx,offset s-offset ok
int 7ch
ok:mov ax,4c00h
int 21h
jmpnp:push bp
mov bp,sp
add ss:[bp+2],bx
pop bp
iret
jmpnpend:nop
code ends
end start
在系统板的ROM中存放着一套程序，称为BIOS（基本输入输出系统），
BIOS中主要包含以下几部分内容。
（1）硬件系统的检测和初始化程序；
（2）外部中断（第15章中进行讲解）和内部中断的中断例程；
（3）用于对硬件设备进行I/O操作的中断例程；
（4）其他和硬件系统相关的中断例程。
操作系统DOS也提供了中断例程，从操作系统的角度来看，
DOS的中断例程就是操作系统向程序员提供的编程资源。
BIOS和DOS在所提供的中断例程中包含了许多子程序，
这些子程序实现了程序员在编程的时候经常需要用到的功能。
程序员在编程的时候，可以用int 指令直接调用BIOS和DOS提供的中断例程，来完成某些工作。
和硬件设备相关的DOS中断例程中，一般都调用了BIOS的中断例程。
前面的课程中，我们都是自己编写中断例程，将它们放到安装程序中，
然后运行安装程序，将它们安装到指定的内存区中。此后，别的应用程序才可以调用。
而BIOS和DOS提供的中断例程是如何安装到内存中的呢？我们下面讲解它们的安装过程。
（1）开机后，CPU一加电，初始化（CS）=OFFFFH，（IP）=0，
自动从FFFF：0单元开始执行程序。FFFF：0处有一条转跳指令，
CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序。
（2）初始化程序将建立BIOS所支持的中断向量，
即将BIOS提供的中断例程的入口地址登记在中断向量表中。
注意，对于BIOS所提供的中断例程，只需将入口地址登记在中断向量表中即可，
因为它们是固化到ROM中的程序，一直在内存中存在。
（3）硬件系统检测和初始化完成后，调用int 19h进行操作系统的引导。
从此将计算机交由操作系统控制。
（4）DOS启动后，除完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量。
检测点13.2
判断下面说法的正误：
（1）我们可以编程改变FFFF：0处的指令，使得CPU不去执行BIOS中的硬件系统检测和初始化程序。
错误，FFFF：0位于只读的ROM中，不能修改
（2）int 19h中断例程，可以由DOS提供。
错误，硬件系统检测和初始化完成后，调用int 19h进行操作系统的引导，
之后计算机才由DOS操作系统控制。
下面我们举几个例子，来看一下BIOS中断例程的应用。
int 10h中断例程是BIOS提供的中断例程，其中包含了多个和屏幕输出相关的子程序。
一般来说，一个供程序员调用的中断例程中往往包括多个子程序，
中断例程内部用传递进来的参数来决定执行哪一个子程序。
BIOS和DOS提供的中断例程，都用ah来传递内部子程序的编号。
下面看一下int 10h中断例程的设置光标位置功能。
mov ah,2
mov bh,0
mov dh,5
mov dl,12
int 10h
（ah）=2表示调用第10h号中断例程的2号子程序，功能为设置光标位置，
可以提供光标所在的行号（80*25字符模式下：0~24）、列号（80*25字符模式下：0~79），
和页号作为参数。
（bh）=0，（dh）=5，（dl）=12，设置光标到第0页，第5行，第12列。
bh中页号的含义：内存地址空间中，B8000H~BFFFFH共32kB的空间，
为80*25彩色字符模式的显示缓冲区。一屏的内容在显示缓冲区中共占4000个字节。
显示缓冲区分为8页，每页4KB（约等于4000B），显示器可以显示任意一页的内容。
一般情况下，显示第0页的内容。也就是说，
通常情况下，B8000H-B8F9FH中的4000个字节的内容将出现在显示器上。
再看一下int 10h中断例程的在光标位置显示字符功能。
mov ah,9；在光标位置显示字符
mov al,'a'；字符
mov bl,7；颜色属性
mov bh,0；第0页
mov cx,3；字符重复个数
int 10h
（ah）=9表示调用第10h号中断例程的9号子程序，功能为在光标位置显示字符，
可以提供要显示的字符、颜色属性、页号、字符重复个数作为参数。
bl中的颜色属性的格式如下。
        7 654  3     210
含义BL RGB I      RGB
   闪烁 背景 高亮 前景
可以看出，和显存中的属性字节的格式相同。
编程：在屏幕的5行12列显示3个红底高亮闪烁绿色的'a'。
assume cs:code
code segment
mov ah,2
mov bh,0
mov dh,5
mov dl,12
int 10h
mov ah,9
mov al,'a'
mov bl,11001010b
mov bh,0
mov cx,3
int 10h
mov ax,4c00h
int 21h
code ends
end
完整的程序如下
assume cs:code
code segment
start:mov ah,2
mov bh,0
mov dh,5
mov dl,12
int 10h
mov ah,9
mov al,'a'
mov bl,11001010b
mov bh,0
mov cx,3
int 10h
mov ax,4c00h
int 21h
code ends
end start
注意，闪烁的效果必须在全屏DOS方式下才能看到。
int 21h中断例程是DOS提供的中断例程，其中包含了DOS提供给程序员在编程时调用的子程序。
我们前面一直使用的是int 21h中断例程的4ch号功能，即程序返回功能，如下：
mov ah,4ch；程序返回
mov al,0；返回值
int 21h
（ah）=4ch 表示调用第21h号中断例程的4ch号子程序，功能为程序返回，
可以提供返回值作为参数。
我们前面使用这个功能的时候经常写做：
mov ax,4c00h
int 21h
我们看一下int 21h中断例程在光标位置显示字符串的功能：
ds:dx指向字符串；要显示的字符串需用“$”作为结束符
mov ah,9；功能号9，表示在光标位置显示字符串
int 21h
（ah）=9表示调用第21h号中断例程的9号子程序，功能为在光标位置显示字符串，
可以提供要显示字符串的地址作为参数。
编程：在屏幕的5行12列显示字符串“Welcome to masm！”。
assume cs:code
data segment
db 'Welcome to masm','$'
data ends
code segment
start:mov ah,2
mov bh,0
mov dh,5
mov dl,12
int 10h
mov ax,data
mov ds,ax
mov dx,0
mov ah,9
int 21h
mov ax,4c00h
int 21h
code ends
end start
上述程序在屏幕的5行12列显示字符串“Welcome to masm”，直到遇见“$”
（“$”本身并不显示，只起到边界的作用）。
如果字符串比较长，遇到行尾，程序会自动转到下一行开头处继续显示；
如果到了最后一行，还能自动上卷一行。
DOS为程序员提供了许多可以调用的子程序，都包含在int 21h中断例程中。
我们这里只对原理进行了讲解，对于DOS提供的所有可调用子程序的情况，
读者可以参考相关的书籍。
（1）编写并安装int 7ch中断例程，功能为显示一个用0结束的字符串，中断例程安装在0：200处。
参数：（dh）=行号，（dl）=列号，（cl）=颜色，ds:si指向字符串首地址。
以上中断例程安装成功后，对下面的程序进行单步跟踪，
尤其注意观察 int、iret指令执行前后CS、IP和栈中的状态。
assume cs:code
data segment
db "welcome to masm!",0
data ends
code segment
start:mov dh,10
mov dl,10
mov cl,2
mov ax,data
mov ds,ax
mov si,0
int 7ch
mov ax,4c00h
int 21h
code ends
end start
完整的程序如下
assume cs:code
data segment
db "welcome to masm!",0
data ends
code segment
start:mov ax,cs
mov ds,ax
mov si,offset show_str
mov ax,0
mov es,ax
mov di,200h
mov cx,offset show_strend-offset show_str
cld
rep movsb
mov word ptr es:[496],200h
mov word ptr es:[498],0
mov dh,10
mov dl,10
mov cl,2
mov ax,data
mov ds,ax
mov si,0
int 7ch
mov ax,4c00h
int 21h
show_str:push dx
push cx
push bx
push ax
push si
push di
push es
mov ax,0B800H
mov es,ax
mov bx,0
mov di,0
mov al,160
mul dh
add bx,ax
mov al,2
mul dl
add bx,ax
mov al,cl
show_str_s:mov cl,ds:[si]
mov ch,0
jcxz show_str_ok
mov ch,al
mov es:[bx+di],cx
inc si
add di,2
jmp show_str_s
show_str_ok:pop es
pop di
pop si
pop ax
pop bx
pop cx
pop dx
iret
show_strend:nop
code ends
end start
（2）编写并安装int 7ch中断例程，功能为完成loop指令的功能。
参数：（cx）=循环次数，（bx）=位移。
以上中断例程安装成功后，对下面的程序进行单步跟踪，
尤其注意观察 int、iret指令执行前后CS、IP和栈中的状态。
在屏幕中间显示80个“！”。
assume cs:code
code segment
start:mov ax,0b800h
mov es,ax
mov di,160*12
mov bx,offset s-offset se
mov cx,80
s:mov byte ptr es:[di],'!'
add di,2
int 7ch
se:nop
mov ax,4c00h
int 21h
code ends
end start
完整的程序如下
assume cs:code
code segment
start:mov ax,cs
mov ds,ax
mov si,offset lp
mov ax,0
mov es,ax
mov di,200h
mov cx,offset lpend-offset lp
cld
rep movsb
mov word ptr es:[496],200h
mov word ptr es:[498],0
mov ax,0b800h
mov es,ax
mov di,1920
mov bx,offset s-offset se
mov cx,80
s:mov byte ptr es:[di],'!'
mov byte ptr es:[di+1],7
add di,2
int 7ch
se:nop
mov ax,4c00h
int 21h
lp:push bp
mov bp,sp
dec cx
jcxz lpret
add ss:[bp+2],bx
lpret:pop bp
iret
lpend:nop
code ends
end start
（3）下面的程序，分别在屏幕的第2、4、6、8行显示4句英文诗，补全程序。
assume cs:code
code segment
s1: db 'Good,better,best,','$'
s2: db 'Never let it rest,','$'
s3: db 'Till good is better,','$'
s4: db 'And better,best.','$'
s: dw offset s1,offset s2,offset s3,offset s4
row: db 2,4,6,8
start:mov ax,cs
mov ds,ax
mov bx,offset s
mov si,offset row
mov cx,4
ok:mov bh,0
mov dh,ds:[si]
mov dl,0
mov ah,2
int 10h
mov dx,ds:[bx]
mov ah,9
int 21h
add bx,2
inc si
loop ok
mov ax,4c00h
int 21h
code ends
end start
完整的程序如下
assume cs:code
code segment
s1: db 'Good,better,best,','$'
s2: db 'Never let it rest,','$'
s3: db 'Till good is better,','$'
s4: db 'And better,best.','$'
s: dw offset s1,offset s2,offset s3,offset s4
row: db 2,4,6,8
start:mov ax,cs
mov ds,ax
mov bx,offset s
mov si,offset row
mov cx,4
ok:mov bh,0
mov dh,ds:[si]
mov dl,0
mov ah,2
int 10h
mov dx,ds:[bx]
mov ah,9
int 21h
add bx,2
inc si
loop ok
mov ax,4c00h
int 21h
code ends
end start
完成后编译运行，体会其中的编程思想。
我们前面讲过，各种存储器都和CPU的地址线、数据线、控制线相连。
CPU在操控它们的时候，把它们都当作内存来对待，
把它们总地看做一个由若干存储单元组成的逻辑存储器，
这个逻辑存储器我们称其为内存地址空间（可参见1.15节）。
在PC机系统中，和CPU通过总线相连的芯片除各种存储器外，还有以下3种芯片。
（1）各种接口卡（比如，网卡、显卡）上的接口芯片，它们控制接口卡进行工作；
（2）主板上的接口芯片，CPU通过它们对部分外设进行访问；
（3）其他芯片，用来存储相关的系统信息，或进行相关的输入输出处理。
在这些芯片中，都有一组可以由CPU读写的寄存器。
这些寄存器，它们在物理上可能处于不同的芯片中，但是它们在以下两点上相同。
（1）都和CPU的总线相连，当然这种连接是通过它们所在的芯片进行的；
（2）CPU对它们进行读或写的时候都通过控制线向它们所在的芯片发出端口读写命令。
可见，从CPU的角度，将这些寄存器都当作端口，对它们进行统一编址，
从而建立了一个统一的端口地址空间。每一个端口在地址空间中都有一个地址。
CPU可以直接读写以下3个地方的数据。
（1）CPU内部的寄存器；
（2）内存单元；
（3）端口。
这一章，我们讨论端口的读写。
在访问端口的时候，CPU通过端口地址来定位端口。
因为端口所在的芯片和CPU通过总线相连，
所以，端口地址和内存地址一样，通过地址总线来传送。
在PC系统中，CPU最多可以定位64KB个不同的端口。则端口地址的范围为0~65535。
对端口的读写不能用mov、push、pop等内存读写指令。
端口的读写指令只有两条：in和out，分别用于从端口读取数据和往端口写入数据。
我们看一下CPU执行内存访问指令和端口访问指令时候，总线上的信息：
（1）访问内存：
mov ax,ds:[8]
假设执行前（ds）=0
执行时与总线相关的操作如下所示。
①CPU通过地址线将地址信息8发出；
②CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据；
③存储器将8号单元中的数据通过数据线送入CPU。
（2）访问端口：
in al,60h
从60h号端口读入一个字节执行时与总线相关的操作如下。
①CPU通过地址线将地址信息60h发出；
②CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据；
③端口所在的芯片将60h端口中的数据通过数据线送入CPU。
注意，在in和out指令中，只能使用ax或al来存放从端口中读入的数据或要发送到端口中的数据。
访问8位端口时用al，访问16位端口时用ax。
对0~255以内的端口进行读写时：
in al,20h
从20h端口读入一个字节
out 20h,al
往20h端口写入一个字节
对256~65535的端口进行读写时，端口号放在dx中：
mov dx,3f8h
将端口号3f8h送入dx
in al,dx
从3f8h端口读入一个字节
out dx,al
向3f8h端口写入一个字节
下面的内容中，我们通过对CMOS RAM的读写来体会一下对端口的访问。
PC机中，有一个CMOS RAM芯片，一般简称为CMOS。此芯片的特征如下。
（1）包含一个实时钟和一个有128个存储单元的RAM存储器（早期的计算机为64个字节）。
（2）该芯片靠电池供电。所以，关机后其内部的实时钟仍可正常工作，RAM中的信息不丢失。
（3）128个字节的RAM中，内部实时钟占用0~0dh单元来保存时间信息，
其余大部分单元用于保存系统配置信息，供系统启动时BIOS程序读取。
BIOS也提供了相关的程序，使我们可以在开机的时候配置CMOS RAM中的系统信息。
（4）该芯片内部有两个端口，端口地址为70h和71h。
CPU通过这两个端口来读写CMOS RAM。
（5）70h为地址端口，存放要访问的CMOS RAM单元的地址；
71h为数据端口，存放从选定的CMOS RAM单元中读取的数据，或要写入到其中的数据。
可见，CPU对CMOS RAM的读写分两步进行，比如，读CMOS RAM的2号单元：
①将2送入端口70h；
②从端口71h读出2号单元的内容。
检测点14.1
（1）编程，读取CMOS RAM的2号单元的内容。
mov al,2
out 70h,al
in al,71h
（2）编程，向CMOS RAM的2号单元写入0。
mov al,2
out 70h,al
mov al,0
out 71h,al
shl和shr是逻辑移位指令，后面的课程中我们要用到移位指令，这里进行一下讲解。
shl是逻辑左移指令，它的功能为：
（1）将一个寄存器或内存单元中的数据向左移位；
（2）将最后移出的一位写入CF中；
（3）最低位用0补充。
指令：
mov al,01001000b
shl al,1
将al中的数据左移一位
执行后（al）=10010000b，CF=0。
我们来看一下shl al,1的操作过程。
（1）左移
原数据：  01001000
左移后：01001000
（2）将最后移出的一位写入CF中
原数据：01001000
左移后：1001000   CF=0
（3）最低位用0补充
原数据：01001000
左移后：10010000
如果接着上面，继续执行一条shl al,1，
则执行后：（al）=00100000b，CF=1。
shl指令的操作过程如下。
（1）左移
原数据： 10010000
左移后：10010000
（2）将最后移出的一位写入CF中
原数据：10010000
左移后：0010000   CF=1
（3）最低位用0补充
原数据：10010000
左移后：00100000
如果移动位数大于1时，必须将移动位数放在cl中。
比如，指令：
mov al,01010001b
mov cl,3
shl al,cl
执行后（al）=10001000b，因为最后移出的一位是0，所以CF=0。
可以看出，将X逻辑左移一位，相当于执行X=X*2。
比如：
mov al,00000001b
执行后（al）=00000001b=1
shl al,1
执行后（al）=00000010b=2
shl al,1
执行后（al）=00000100b=4
shl al,1
执行后（al）=00001000b=8
mov cl,3
shl al,cl
执行后（al）=01000000b=64
shr是逻辑右移指令，它和shl所进行的操作刚好相反。
（1）将一个寄存器或内存单元中的数据向右移位；
（2）将最后移出的一位写入CF中；
（3）最高位用0补充。
指令：
mov al,10000001b
shr al,1
将al中的数据右移一位执行后（al）=01000000b，CF=1。
如果接着上面，继续执行一条shr al,1，则执行后：（al）=00100000b，CF=0。
如果移动位数大于1时，必须将移动位数放在cl中。
比如，指令：
mov al,01010001b
mov cl,3
shr al,cl
执行后（al）=00001010b，因为最后移出的一位是0，所以CF=0。
可以看出将X逻辑右移一位，相当于执行X=X/2。
检测点14.2
编程，用加法和移位指令计算（ax）=（ax）*10。提示，（ax）*10=（ax）*2+（ax）*8。
mov bx,ax
shl ax,1
mov cl,3
shl bx,cl
add ax,bx
在CMOS RAM中，存放着当前的时间：年、月、日、时、分、秒。
地址 说明
0        秒
1        秒报警
2        分
3        分报警
4        时
5        时报警
6        星期
7        日
8        月
9        年
这6个信息的长度都为1个字节，存放单元为：
秒：0分：2时：4日：7月：8年：9这些数据以BCD码的方式存放。
BCD码是以4位二进制数表示十进制数码的编码方法，如下所示。
十进制数码：    0      1        2       3       4       5       6       7       8       9
对应的BCD码：0000 0001 0010 0011 0100 0101 0110 0111 1000 1001
比如，数值26，用BCD码表示为：0010 0110。
可见，一个字节可表示两个BCD码。
则CMOS RAM存储时间信息的单元中，存储了用两个BCD码表示的两位十进制数，
高4位的BCD码表示十位，低4位的BCD码表示个位。比如，00010100b表示14。
编程，在屏幕中间显示当前的月份。
分析，这个程序主要做以下两部分工作。
（1）从CMOS RAM的8号单元读出当前月份的BCD码。
要读取CMOS RAM的信息，首先要向地址端口70h写入要访问的单元的地址：
mov al,8
out 70h,al
然后从数据端口71h中取得指定单元中的数据：
in al,71h
（2）将用BCD码表示的月份以十进制的形式显示到屏幕上。
我们可以看出，BCD码值=十进制数码值，则BCD码值+30h=十进制数对应的ASCII码。
从CMOS RAM的8号单元读出的一个字节中，包含了用两个BCD码表示的两位十进制数，
高4位的BCD码表示十位，低4位的BCD码表示个位。比如，00010100b表示14。
我们需要进行以下两步工作。
①将从CMOSRAM的8号单元中读出的一个字节，分为两个表示BCD码值的数据。
mov ah,al
al中为从CMOS RAM的8号单元中读出的数据
mov cl,4
shr ah,cl
ah中为月份的十位数码值
and al,00001111b
al中为月份的个位数码值
②显示（ah）+30h和（al）+30h对应的ASCII码字符。
完整的程序如下。
assume cs:code
code segment
start:mov al,8
out 70h,al
in al,71h
mov ah,al
mov cl,4
shr ah,cl
and al,00001111b
add ah,30h
add al,30h
mov bx,0b800h
mov es,bx
mov byte ptr es:[2000],ah
mov byte ptr es:[2001],7
mov byte ptr es:[2002],al
mov byte ptr es:[2003],7
mov ax,4c00h
int 21h
code ends
end start
完整的程序如下
assume cs:code
code segment
start:mov al,8
out 70h,al
in al,71h
mov ah,al
mov cl,4
shr ah,cl
and al,00001111b
add ah,30h
add al,30h
mov bx,0b800h
mov es,bx
mov byte ptr es:[2000],ah
mov byte ptr es:[2001],7
mov byte ptr es:[2002],al
mov byte ptr es:[2003],7
mov ax,4c00h
int 21h
code ends
end start
ah*10+al的测试程序如下
assume cs:code
code segment
start:mov al,8
out 70h,al
in al,71h
mov ah,al
mov cl,4
shr ah,cl
and al,00001111b
call multen
add ah,30h
add al,30h
mov bx,0b800h
mov es,bx
mov byte ptr es:[2000],ah
mov byte ptr es:[2001],7
mov byte ptr es:[2002],al
mov byte ptr es:[2003],7
mov ax,4c00h
int 21h
multen:push ax
push bx
push cx
mov bh,ah
shl ah,1
mov cl,3
shl bh,cl
add ah,bh
add ah,al
mov al,ah
mov ah,0
pop cx
pop bx
pop ax
ret
code ends
end start
编程，以“年/月/日 时：分：秒”的格式，显示当前的日期、时间。
注意：CMOS RAM中存储着系统的配置信息，除了保存时间信息的单元外，
不要向其他的单元中写入内容，否则将引起一些系统错误。
完整的程序如下
assume cs:code
data segment
db 9,8,7,4,2,0
data ends
code segment
start:mov bx,0b800h
mov es,bx
mov di,1992
mov bx,data
mov ds,bx
mov si,0
mov cx,6
mov byte ptr es:[di+4],'/'
mov byte ptr es:[di+5],7
mov byte ptr es:[di+10],'/'
mov byte ptr es:[di+11],7
mov byte ptr es:[di+16],' '
mov byte ptr es:[di+17],7
mov byte ptr es:[di+22],':'
mov byte ptr es:[di+23],7
mov byte ptr es:[di+28],':'
mov byte ptr es:[di+29],7
s:mov al,ds:[si]
out 70h,al
in al,71h
call show_bcd
add di,2
inc si
loop s
mov ax,4c00h
int 21h
show_bcd:push cx
mov ah,al
mov cl,4
shr ah,cl
and al,00001111b
add ah,30h
add al,30h
mov byte ptr es:[di],ah
mov byte ptr es:[di+1],7
mov byte ptr es:[di+2],al
mov byte ptr es:[di+3],7
add di,4
pop cx
ret
code ends
end start
以前我们讨论的都是CPU对指令的执行。我们知道，CPU在计算机系统中，
除了能够执行指令，进行运算以外，还应该能够对外部设备进行控制，接收它们的输入，
向它们进行输出。也就是说，CPU除了有运算能力外，
还要有I/O（Input/Output，输入/输出）能力。
比如，我们按下键盘上的一个键，CPU最终要能够处理这个键。
在使用文本编辑器时，按下a键后，我们可以看到屏幕上出现“a”，
是CPU将从键盘上输入的键所对应的字符送到显示器上的。
要及时处理外设的输入，显然需要解决两个问题：
①外设的输入随时可能发生，CPU如何得知？
②CPU从何处得到外设的输入？
这一章中，我们以键盘输入为例，讨论这两个问题。
第14章我们讲过，PC系统的接口卡和主板上，装有各种接口芯片。
这些外设接口芯片的内部有若干寄存器，CPU将这些寄存器当作端口来访问。
外设的输入不直接送入内存和CPU，而是送入相关的接口芯片的端口中；
CPU向外设的输出也不是直接送入外设，而是先送入端口中，再由相关的芯片送到外设。
CPU还可以向外设输出控制命令，而这些控制命令也是先送到相关芯片的端口中，
然后再由相关的芯片根据命令对外设实施控制。
可见，CPU通过端口和外部设备进行联系。
现在，我们知道了外设的输入被存放在端口中，可是外设的输入随时都有可能到达，
CPU如何及时地知道，并进行处理呢？
更一般地讲，就是外设随时都可能发生需要CPU及时处理的事件，CPU如何及时得知并进行处理？
CPU提供中断机制来满足这种需要。前面讲过，当CPU的内部有需要处理的事情发生的时候，
将产生中断信息，引发中断过程。这种中断信息来自CPU的内部。
还有一种中断信息，来自于CPU外部，当CPU外部有需要处理的事情发生的时候，
比如说，外设的输入到达，相关芯片将向CPU发出相应的中断信息。
CPU在执行完当前指令后，可以检测到发送过来的中断信息，引发中断过程，处理外设的输入。
在PC系统中，外中断源一共有以下两类。
1.可屏蔽中断
可屏蔽中断是CPU可以不响应的外中断。CPU是否响应可屏蔽中断，要看标志寄存器的IF位的设置。
当CPU检测到可屏蔽中断信息时，如果IF=1，则CPU在执行完当前指令后响应中断，
引发中断过程；如果IF=0，则不响应可屏蔽中断。
我们回忆一下内中断所引发的中断过程：
（1）取中断类型码n；
（2）标志寄存器入栈，IF=0，TF=0；
（3）CS、IP入栈；
（4）（IP）=（n*4），（CS）=（n*4+2）
由此转去执行中断处理程序。
可屏蔽中断所引发的中断过程，除在第1步的实现上有所不同外，基本上和内中断的中断过程相同。
因为可屏蔽中断信息来自于CPU外部，中断类型码是通过数据总线送入CPU的；
而内中断的中断类型码是在CPU内部产生的。
现在，我们可以解释中断过程中将IF置为0的原因了。
将IF置0的原因就是，在进入中断处理程序后，禁止其他的可屏蔽中断。
当然，如果在中断处理程序中需要处理可屏蔽中断，可以用指令将IF置1。
8086CPU提供的设置IF的指令如下：
sti，设置IF=1
cli，设置IF=0。
2.不可屏蔽中断
不可屏蔽中断是CPU必须响应的外中断。
当CPU检测到不可屏蔽中断信息时，则在执行完当前指令后，立即响应，引发中断过程。
对于8086CPU，不可屏蔽中断的中断类型码固定为2，所以中断过程中，不需要取中断类型码。
则不可屏蔽中断的中断过程为：
（1）标志寄存器入栈，IF=0，TF=0；
（2）CS、IP入栈；
（3）（IP）=（8），（CS）=（0AH）。
几乎所有由外设引发的外中断，都是可屏蔽中断。
当外设有需要处理的事件（比如说键盘输入）发生时，相关芯片向CPU发出可屏蔽中断信息。
不可屏蔽中断是在系统中有必须处理的紧急情况发生时用来通知CPU的中断信息。
在我们的课程中，主要讨论可屏蔽中断。
下面我们看一下键盘输入的处理过程，并以此来体会一下PC机处理外设输入的基本方法。
1.键盘输入
键盘上的每一个键相当于一个开关，键盘中有一个芯片对键盘上的每一个键的开关状态进行扫描。
按下一个键时，开关接通，该芯片就产生一个扫描码，扫描码说明了按下的键在键盘上的位置。
扫描码被送入主板上的相关接口芯片的寄存器中，该寄存器的端口地址为60h。
松开按下的键时，也产生一个扫描码，扫描码说明了松开的键在键盘上的位置。
松开按键时产生的扫描码也被送入60h端口中。
一般将按下一个键时产生的扫描码称为通码，松开一个键产生的扫描码称为断码。
扫描码长度为一个字节，通码的第7位为0，断码的第7位为1，即：
断码=通码+80h
比如，g键的通码为22h，断码为a2h。
表15.1是键盘上部分键的扫描码，只列出通码。断码=通码+80h。
2.引发9号中断
键盘的输入到达60h端口时，相关的芯片就会向CPU发出中断类型码为9的可屏蔽中断信息。
CPU检测到该中断信息后，如果IF=1，则响应中断，引发中断过程，转去执行int 9中断例程。
3.执行int 9中断例程
BIOS提供了int 9中断例程，用来进行基本的键盘输入处理，主要的工作如下：
（1）读出60h端口中的扫描码；
（2）如果是字符键的扫描码，将该扫描码和它所对应的字符码（即ASCII码）
送入内存中的BIOS键盘缓冲区；如果是控制键（比如Ctrl）和切换键（比如CapsLock）的扫描码，
则将其转变为状态字节（用二进制位记录控制键和切换键状态的字节）
写入内存中存储状态字节的单元；
（3）对键盘系统进行相关的控制，比如说，向相关芯片发出应答信息。
BIOS键盘缓冲区是系统启动后，BIOS用于存放int 9中断例程所接收的键盘输入的内存区。
该内存区可以存储15个键盘输入，因为int 9中断例程除了接收扫描码外，
还要产生和扫描码对应的字符码，所以在BIOS键盘缓冲区中，
一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码。
0040：17单元存储键盘状态字节，该字节记录了控制键和切换键的状态。
键盘状态字节各位记录的信息如下。
0：右shift状态，置1表示按下右shift键；
1：左shift状态，置1表示按下左shift键；
2：Ctrl状态，置1表示按下Ctrl键；
3：Alt状态，置1表示按下Alt键；
4：ScrollLock状态，置1表示Scroll指示灯亮；
5：NumLock状态，置1表示小键盘输入的是数字；
6：CapsLock状态，置1表示输入大写字母；
7：Insert状态，置1表示处于删除态。
从上面的内容中，可以看出键盘输入的处理过程：
①键盘产生扫描码；
②扫描码送入60h端口；
③引发9号中断；
④CPU执行int 9中断例程处理键盘输入。
上面的过程中，第1、2、3步都是由硬件系统完成的。我们能够改变的只有int 9中断处理程序。
我们可以重新编写int9中断例程，按照自己的意图来处理键盘的输入。
但是，在课程中，我们不准备完整地编写一个键盘中断的处理程序，
因为要涉及一些硬件细节，而这些内容脱离了我们的内容主线。
但是，我们却还要编写新的键盘中断处理程序，来进行一些特殊的工作，
那么这些硬件细节如何处理呢？
这点比较简单，因为BIOS提供的int 9中断例程已经对这些硬件细节进行了处理。
我们只要在自己编写的中断例程中调用BIOS的int 9中断例程就可以了。
编程：在屏幕中间依次显示“a”~“z”，并可以让人看清。
在显示的过程中，按下Esc键后，改变显示的颜色。
我们先来看一下如何依次显示“a”~“z”。
assume cs:code
code segment
start:mov ax,0b800h
mov es,ax
mov ah,'a'
s:mov es:[160*12+40*2],ah
inc ah
cmp ah,'z'
jna s
mov ax,4c00h
int 21h
code ends
end start
在上面的程序的执行过程中，我们无法看清屏幕上的显示。
因为一个字母刚显示到屏幕上，CPU执行几条指令后，就又变成了另一个字母，
字母之间切换得太快，无法看清。
应该在每显示一个字母后，延时一段时间，让人看清后，再显示下一个字母。
那么如何延时呢？我们让CPU执行一段时间的空循环。
因为现在CPU的速度都非常快，所以循环的次数一定要大，
用两个16位寄存器来存放32位的循环次数。如下：
mov dx,10h
mov ax,0
s:sub ax,1
sbb dx,0
cmp ax,0
jne s
cmp dx,0
jne s
上面的程序，循环100000h次。我们可以将循环延时的程序段写为一个子程序。
现在，我们的程序如下：
assume cs:code
stack segment
db 128 dup (0)
stack ends
code segment
start:mov ax,stack
mov ss,ax
mov sp,128
mov ax,0b800h
mov es,ax
mov ah,'a'
s:mov es:[160*12+40*2],ah
call delay
inc ah
cmp ah,'z'
jna s
mov ax,4c00h
int 21h
delay:push ax
push dx
mov dx,1000h
mov ax,0
s1:sub ax,1
sbb dx,0
cmp ax,0
jne s1
cmp dx,0
jne s1
pop dx
pop ax
ret
code ends
end start
完整的程序如下
assume cs:code
stack segment
db 128 dup (0)
stack ends
code segment
start:mov ax,stack
mov ss,ax
mov sp,128
mov ax,0b800h
mov es,ax
mov ah,'a'
s:mov es:[2000],ah
call delay
inc ah
cmp ah,'z'
jna s
mov ax,4c00h
int 21h
delay:push ax
push dx
mov dx,1000h
mov ax,0
delay_s:sub ax,1
sbb dx,0
cmp ax,0
jne delay_s
cmp dx,0
jne delay_s
pop dx
pop ax
ret
code ends
end start
显示“a”~“z”，并可以让人看清，这个任务已经实现。
那么如何实现，按下Esc键后，改变显示的颜色呢？
键盘输入到达60h端口后，就会引发9号中断，CPU则转去执行int 9中断例程。
我们可以编写int 9中断例程，功能如下。
（1）从60h端口读出键盘的输入；
（2）调用BIOS的int 9中断例程，处理其他硬件细节；
（3）判断是否为Esc的扫描码，如果是，改变显示的颜色后返回；如果不是则直接返回。
下面对这些功能的实现一一进行分析。
1.从端口60h读出键盘的输入
in al,60h
2.调用BIOS的int 9中断例程
有一点要注意的是，我们写的中断处理程序要成为新的int 9中断例程，
主程序必须要将中断向量表中的int 9中断例程的入口地址改为我们写的中断处理程序的入口地址。
则在新的中断处理程序中调用原来的int 9中断例程时，
中断向量表中的int 9中断例程的入口地址却不是原来的int 9中断例程的地址。
所以不能使用int 指令直接调用。
要能在我们写的新中断例程中调用原来的中断例程，
就必须在将中断向量表中的中断例程的入口地址改为新地址之前，将原来的入口地址保存起来。
这样，在需要调用的时候，我们才能找到原来的中断例程的入口。
对于我们现在的问题，假设将原来int 9中断例程的偏移地址和段地址保存在ds:[0]和ds:[2]单元中。
那么我们在需要调用原来的int 9中断例程时候，就可以在ds:[0]、ds[2]单元中找到它的入口地址。
那么，有了入口地址后，如何进行调用呢？
当然不能使用指令int 9来调用。我们可以用别的指令来对int指令进行一些模拟，
从而实现对中断例程的调用。
我们来看，int指令在执行的时候，CPU进行下面的工作。
（1）取中断类型码n；
（2）标志寄存器入栈；
（3）IF=0，TF=0；
（4）CS、IP入栈；
（5）（IP）=（n*4），（CS）=（n*4+2）。
取中断类型码是为了定位中断例程的入口地址，在我们的问题中，中断例程的入口地址已经知道。
所以，我们用别的指令模拟int 指令时候，不需要做第（1）步。
在假设要调用的中断例程的入口地址在ds：0和ds：2单元中的前提下，
我们将int过程用下面几步模拟。
（1）标志寄存器入栈；
（2）IF=0，TF=0；
（3）CS、IP入栈；
（4）（IP）=（（ds）*16+0），（CS）=（（ds）*16+2）。
可以注意到第（3）、（4）步和call dword ptr ds:[0]的功能一样，
call dword ptr ds:[0]的功能也是：
（1）CS、IP入栈；
（2）（IP）=（（ds）*16+0），（CS）=（（ds）*16+2）。
如果还有疑问，复习10.6节的内容。
所以int过程的模拟过程变为：
（1）标志寄存器入栈；
（2）IF=0，TF=0：
（3）call dword ptr ds:[0]。
对于（1），可用pushf实现；对于（2），可用下面的指令实现：
IF和TF为标志寄存器的第9位和第8位
pushf
pop ax
and ah,11111100b
push ax
popf
则模拟int指令的调用功能，调用入口地址在ds：0、ds：2中的中断例程的程序为：
pushf
pushf
pop ax
and ah,11111100b
push ax
popf
call dword ptr ds:[0]
3.如果是Esc的扫描码，改变显示的颜色后返回
如何改变显示的颜色？
显示的位置是屏幕的中间，即第12行40列，显存中的偏移地址为：160*12+40*2。
所以字符的ASCII码要送入段地址b800h，偏移地址160*12+40*2处。而段地址b800h，
偏移地址160*12+40*2+1处是字符的属性，只要改变此处的数据就可以改变在段地址b800h，
偏移地址160*12+40*2处显示的字符的颜色了。
该程序的最后一个问题是，要在程序返回前，
将中断向量表中的int 9中断例程的入口地址恢复为原来的地址。
否则程序返回后，别的程序将无法使用键盘。
经过分析，完整的程序如下。
assume cs:code
stack segment
db 128 dup (0)
stack ends
data segment
dw 0,0
data ends
code segment
start:mov ax,stack
mov ss,ax
mov sp,128
mov ax,data
mov ds,ax
mov ax,0
mov es,ax
push es:[9*4]
pop ds:[0]
push es:[9*4+2]
pop ds:[2]
mov word ptr es:[9*4],offset int9
mov es:[9*4+2],cs
mov ax,0b800h
mov es,ax
mov ah,'a'
s:mov es:[160*12+40*2],ah
call delay
inc ah
cmp ah,'z'
jna s
mov ax,0
mov es,ax
push ds:[0]
pop es:[9*4]
push ds:[2]
pop es:[9*4+2]
mov ax,4c00h
int 21h
delay:push ax
push dx
mov dx,1000h
mov ax,0
s1:sub ax,1
sbb dx,0
cmp ax,0
jne s1
cmp dx,0
jne s1
pop dx
pop ax
ret
int9:push ax
push bx
push es
in al,60h
pushf
pushf
pop bx
and bh,11111100b
push bx
popf
call dword ptr ds:[0]
cmp al,1
jne int9ret
mov ax,0b800h
mov es,ax
inc byte ptr es:[160*12+40*2+1]
int9ret:pop es
pop bx
pop ax
iret
code ends
end start
在dosbox中测试通过的完整程序如下
assume cs:code
stack segment
db 128 dup (0)
stack ends
data segment
dw 0,0
data ends
code segment
start:mov ax,stack
mov ss,ax
mov sp,128
mov ax,data
mov ds,ax
mov ax,0
mov es,ax
push es:[36]
pop ds:[0]
push es:[38]
pop ds:[2]
mov word ptr es:[36],offset int9
mov es:[38],cs
mov ax,0b800h
mov es,ax
mov ah,'a'
mov byte ptr es:[2001],1
s:mov es:[2000],ah
call delay
inc ah
cmp ah,'z'
jna s
mov ax,0
mov es,ax
push ds:[0]
pop es:[36]
push ds:[2]
pop es:[38]
mov ax,4c00h
int 21h
delay:push ax
push dx
mov dx,10h
mov ax,0
delay_s:sub ax,1
sbb dx,0
cmp ax,0
jne delay_s
cmp dx,0
jne delay_s
pop dx
pop ax
ret
int9:push ax
push bx
push es
in al,60h
pushf
pushf
pop bx
and bh,11111100b
push bx
popf
call dword ptr ds:[0]
cmp al,1
jne int9ret
mov ax,0b800h
mov es,ax
inc byte ptr es:[2001]
int9ret:pop es
pop bx
pop ax
iret
code ends
end start
注意，本章中所有关于键盘的程序，因要直接访问真实的硬件，则必须在DOS实模式下运行。
在Windows2000的DOS方式下运行，会出现一些和硬件工作原理不符合的现象。
检测点15.1
（1）仔细分析一下上面的int9中断例程，看看是否可以精简一下？
其实在我们的int9中断例程中，模拟int指令调用原int9中断例程的程序段是可以精简的，
因为在进入中断例程后，IF和TF都已经置0，没有必要再进行设置了。对于程序段：
pushf
pushf
pop ax
and ah,11111100b
push ax
popf
call dword ptr ds:[0]
可以精简为：
pushf
call dword ptr ds:[0]
两条指令。
（2）仔细分析上面程序中的主程序，看看有什么潜在的问题？
在主程序中，如果在执行设置int9中断例程的段地址和偏移地址的指令之间发生了键盘中断，
则CPU将转去一个错误的地址执行，将发生错误。
找出这样的程序段，改写它们，排除潜在的问题。
提示，注意sti和cli指令的用法。
完整的程序如下
assume cs:code
stack segment
db 128 dup (0)
stack ends
data segment
dw 0,0
data ends
code segment
start:mov ax,stack
mov ss,ax
mov sp,128
mov ax,data
mov ds,ax
mov ax,0
mov es,ax
push es:[36]
pop ds:[0]
push es:[38]
pop ds:[2]
cli
mov word ptr es:[36],offset int9
mov es:[38],cs
sti
mov ax,0b800h
mov es,ax
mov ah,'a'
mov byte ptr es:[2001],1
s:mov es:[2000],ah
call delay
inc ah
cmp ah,'z'
jna s
mov ax,0
mov es,ax
cli
push ds:[0]
pop es:[36]
push ds:[2]
pop es:[38]
sti
mov ax,4c00h
int 21h
delay:push ax
push dx
mov dx,10h
mov ax,0
delay_s:sub ax,1
sbb dx,0
cmp ax,0
jne delay_s
cmp dx,0
jne delay_s
pop dx
pop ax
ret
int9:push ax
push bx
push es
in al,60h
pushf
call dword ptr ds:[0]
cmp al,1
jne int9ret
mov ax,0b800h
mov es,ax
inc byte ptr es:[2001]
int9ret:pop es
pop bx
pop ax
iret
code ends
end start
下面，我们安装一个新的int 9中断例程，使得原int 9中断例程的功能得到扩展。
任务：安装一个新的int 9中断例程。
功能：在DOS下，按F1键后改变当前屏幕的显示颜色，其他的键照常处理。
我们进行一下分析。
（1）改变屏幕的显示颜色
改变从B8000H开始的4000个字节中的所有奇地址单元中的内容，
当前屏幕的显示颜色即发生改变。程序如下：
mov ax,0b800h
mov es,ax
mov bx,1
mov cx,2000
s:inc byte ptr es:[bx]
add bx,2
loop s
（2）其他键照常处理
可以调用原int 9中断处理程序，来处理其他的键盘输入。
（3）原int 9中断例程入口地址的保存
因为在编写的新int9中断例程中要调用原int9中断例程，所以，要保存原int9中断例程的入口地址。
保存在哪里？显然不能保存在安装程序中，因为安装程序返回后地址将丢失。
我们将地址保存在0：200单元处。
（4）新int9中断例程的安装
这个问题在前面已经详细讨论过。我们可将新的int9中断例程安装在0：204处。
完整的程序如下。
assume cs:code
stack segment
db 128 dup (0)
stack ends
code segment
start:mov ax,stack
mov ss,ax
mov sp,128
push cs
pop ds
mov ax,0
mov es,ax
mov si,offset int9
mov di,204h
mov cx,offset int9end-offset int9
cld
rep movsb
push es:[9*4]
pop es:[200h]
push es:[9*4+2]
pop es:[202h]
cli
mov word ptr es:[9*4],204h
mov word ptr es:[9*4+2],0
sti
mov ax,4c00h
int 21h
int9:push ax
push bx
push cx
push es
in al,60h
pushf
call dword ptr cs:[200h]
cmp al,3bh
jne int9ret
mov ax,0b800h
mov es,ax
mov bx,1
mov cx,2000
s:inc byte ptr es:[bx]
add bx,2
loop s
int9ret:pop es
pop cx
pop bx
pop ax
iret
int 9end:nop
code ends
end start
完整的程序如下
assume cs:code
stack segment
db 128 dup (0)
stack ends
code segment
start:mov ax,stack
mov ss,ax
mov sp,128
push cs
pop ds
mov ax,0
mov es,ax
mov si,offset int9
mov di,204h
mov cx,offset int9end-offset int9
cld
rep movsb
push es:[36]
pop es:[200h]
push es:[38]
pop es:[202h]
cli
mov word ptr es:[36],204h
mov word ptr es:[38],0
sti
mov ax,4c00h
int 21h
int9:push ax
push bx
push cx
push es
in al,60h
pushf
call dword ptr cs:[200h]
cmp al,3bh
jne int9ret
mov ax,0b800h
mov es,ax
mov bx,1
mov cx,2000
int9_s:inc byte ptr es:[bx]
add bx,2
loop int9_s
int9ret:pop es
pop cx
pop bx
pop ax
iret
int9end:nop
code ends
end start
这一章中，我们通过对键盘输入的处理，讲解了CPU对外设输入的通常处理方法。
即：
（1）外设的输入送入端口；
（2）向CPU发出外中断（可屏蔽中断）信息；
（3）CPU检测到可屏蔽中断信息，如果IF=1，CPU在执行完当前指令后响应中断，
执行相应的中断例程；
（4）可在中断例程中实现对外设输入的处理。
端口和中断机制，是CPU进行I/O的基础。
安装一个新的int 9中断例程，功能：在DOS下，按下“A”键后，除非不再松开，
如果松开，就显示满屏幕的“A”，其他的键照常处理。
提示，按下一个键时产生的扫描码称为通码，松开一个键产生的扫描码称为断码。
断码=通码+80h。
完整的程序如下
assume cs:code
stack segment
db 128 dup (0)
stack ends
code segment
start:mov ax,stack
mov ss,ax
mov sp,128
push cs
pop ds
mov ax,0
mov es,ax
mov si,offset int9
mov di,204h
mov cx,offset int9end-offset int9
cld
rep movsb
push es:[36]
pop es:[200h]
push es:[38]
pop es:[202h]
cli
mov word ptr es:[36],204h
mov word ptr es:[38],0
sti
mov ax,4c00h
int 21h
int9:push ax
push bx
push cx
push es
in al,60h
pushf
call dword ptr cs:[200h]
cmp al,9eh
jne int9ret
mov ax,0b800h
mov es,ax
mov bx,0
mov cx,2000
int9_s:mov byte ptr es:[bx],'A'
add bx,2
loop int9_s
int9ret:pop es
pop cx
pop bx
pop ax
iret
int9end:nop
code ends
end start
指令系统总结
我们对8086CPU的指令系统进行一下总结。读者若要详细了解8086指令系统中的各个指令的用法，
可以查看有关的指令手册。
8086CPU提供以下几大类指令。
1.数据传送指令
比如，mov、push、pop、pushf、popf、xchg 等都是数据传送指令，
这些指令实现寄存器和内存、寄存器和寄存器之间的单个数据传送。
2.算术运算指令
比如，add、sub、adc、sbb、inc、dec、cmp、imul、idiv、aaa 等都是算术运算指令，
这些指令实现寄存器和内存中的数据的算数运算。
它们的执行结果影响标志寄存器的sf、zf、of、cf、pf、af位。
3.逻辑指令
比如，and、or、not、xor、test、shl、shr、sal、sar、rol、ror、rcl、rcr 等都是逻辑指令。
除了not 指令外，它们的执行结果都影响标志寄存器的相关标志位。
4.转移指令
可以修改IP，或同时修改CS和IP的指令统称为转移指令。转移指令分为以下几类。
（1）无条件转移指令，比如，jmp；
（2）条件转移指令，比如，jcxz、je、jb、ja、jnb、jna等；
（3）循环指令，比如，loop；
（4）过程，比如，call、ret、retf；
（5）中断，比如，int、iret。
5.处理机控制指令
这些指令对标志寄存器或其他处理机状态进行设置，
比如，cld、std、cli、sti、nop、clc、cmc、stc、hlt、wait、esc、lock等都是处理机控制指令。
6.串处理指令
这些指令对内存中的批量数据进行处理，比如，movsb、movsw、cmps、scas、lods、stos等。
若要使用这些指令方便地进行批量数据的处理，则需要和rep、repe、repne等前缀指令配合使用。
这一章，我们讨论如何有效合理地组织数据，以及相关的编程技术。
前面的课程中，我们一直在代码段中使用标号来标记指令、数据、段的起始地址。
比如，下面的程序将code段中的a标号处的8个数据累加，结果存储到b标号处的字中。
assume cs:code
code segment
a:db 1,2,3,4,5,6,7,8
b:dw 0
start:mov si,offset a
mov bx,offset b
mov cx,8
s:mov al,cs:[si]
mov ah,0
add cs:[bx],ax
inc si
loop s
mov ax,4c00h
int 21h
code ends
end start
完整的程序如下
assume cs:code
code segment
a:db 1,2,3,4,5,6,7,8
b:dw 0
start:mov si,offset a
mov bx,offset b
mov cx,8
s:mov al,cs:[si]
mov ah,0
add cs:[bx],ax
inc si
loop s
mov ax,4c00h
int 21h
code ends
end start
程序中，code、a、b、start、s都是标号。这些标号仅仅表示了内存单元的地址。
但是，我们还可以使用一种标号，这种标号不但表示内存单元的地址，还表示了内存单元的长度，
即表示在此标号处的单元，是一个字节单元，还是字单元，还是双字单元。
上面的程序还可以写成这样：
assume cs:code
code seqment
a db 1,2,3,4,5,6,7,8
b dw 0
start:mov si,0
mov cx,8
s:mov al,a[si]
mov ah,0
add b,ax
inc si
loop s
mov ax,4c00h
int 21h
code ends
end start
完整的程序如下
assume cs:code
code segment
a db 1,2,3,4,5,6,7,8
b dw 0
start:mov si,0
mov cx,8
s:mov al,a[si]
mov ah,0
add b,ax
inc si
loop s
mov ax,4c00h
int 21h
code ends
end start
在code段中使用的标号a、b后面没有“：”，它们是同时描述内存地址和单元长度的标号。
标号a，描述了地址code：0，和从这个地址开始，以后的内存单元都是字节单元；
而标号b描述了地址code：8，和从这个地址开始，以后的内存单元都是字单元。
因为这种标号包含了对单元长度的描述，所以在指令中，它可以代表一个段中的内存单元。
比如，对于程序中的“b dw 0”：
指令：mov ax,b相当于：mov ax,cs:[8]
指令：mov b,2相当于：mov word ptr cs:[8],2
指令：inc b相当于：inc word ptr cs:[8]
在这些指令中，标号b代表了一个内存单元，地址为code：8，长度为两个字节。
下面的指令会引起编译错误：
mov al,b因为b代表的内存单元是字单元，而al是8位寄存器。
如果我们将程序中的指令“add b,ax”，写为“add b,al”，将出现同样的编译错误。
对于程序中的“a db 1,2,3,4,5,6,7,8”：
指令：mov al,a[si]
相当于：mov al,cs:0[si]
指令：mov al,a[3]
相当于：mov al,cs:0[3]
指令：mov al,a[bx+si+3]
相当于：mov al,cs:0[bx+si+3]
可见，使用这种包含单元长度的标号，可以使我们以简洁的形式访问内存中的数据。
以后，我们将这种标号称为数据标号，它标记了存储数据的单元的地址和长度。
它不同于仅仅表示地址的地址标号。
检测点16.1
下面的程序将code段中a处的8个数据累加，结果存储到b处的双字中，补全程序。
assume cs:code
code segment
a dw 1,2,3,4,5,6,7,8
b dd 0
start:mov si,0
mov cx,8
s:mov ax,a[si]
add word ptr b[0],ax
adc word ptr b[2],0
add si,2
loop s
mov ax,4c00h
int 21h
code ends
end start
完整的程序如下
assume cs:code
code segment
a dw 1,2,3,4,5,6,7,8
b dd 0
start:mov si,0
mov cx,8
s:mov ax,a[si]
add word ptr b[0],ax
adc word ptr b[2],0
add si,2
loop s
mov ax,4c00h
int 21h
code ends
end start
一般来说，我们不在代码段中定义数据，而是将数据定义到其他段中。
在其他段中，我们也可以使用数据标号来描述存储数据的单元的地址和长度。
注意，在后面加有“：”的地址标号，只能在代码段中使用，不能在其他段中使用。
下面的程序将data段中a标号处的8个数据累加，结果存储到b标号处的字中。
assume cs:code,ds:data
data segment
a db 1,2,3,4,5,6,7,8
b dw 0
data ends
code segment
start:mov ax,data
mov ds,ax
mov si,0
mov cx,8
s:mov al,a[si]
mov ah,0
add b,ax
inc si
loop s
mov ax,4c00h
int 21h
code ends
end start
完整的程序如下
assume cs:code,ds:data
data segment
a db 1,2,3,4,5,6,7,8
b dw 0
data ends
code segment
start:mov ax,data
mov ds,ax
mov si,0
mov cx,8
s:mov al,a[si]
mov ah,0
add b,ax
inc si
loop s
mov ax,4c00h
int 21h
code ends
end start
注意，如果想在代码段中直接用数据标号访问数据，
则需要用伪指令 assume将标号所在的段和一个段寄存器联系起来。
否则编译器在编译的时候，无法确定标号的段地址在哪一个寄存器中。
当然，这种联系是编译器需要的，但绝对不是说，我们因为编译器的工作需要，
用assume指令将段寄存器和某个段相联系，段寄存器中就会真的存放该段的地址。
我们在程序中还要使用指令对段寄存器进行设置。
比如，在上面的程序中，我们要在代码段code中用data段中的数据标号a、b访问数据，
则必须用assume将一个寄存器和data段相联。在程序中，我们用ds寄存器和data段相联，
则编译器对相关指令的编译如下。
指令：mov al,a[si]
编译为：mov al,[si+0]
指令：add b,ax
编译为：add [8],ax
因为这些实际编译出的指令，都默认所访问单元的段地址在ds中，
而实际要访问的段为data，所以若要访问正确，在这些指令执行前，ds中必须为data段的段地址。
则我们在程序中使用指令：
mov ax,data
mov ds,ax
设置ds指向data段。
可以将标号当作数据来定义，此时，编译器将标号所表示的地址当作数据的值。
比如：
data segment
a db 1,2,3,4,5,6,7,8
b dw 0
c dw a,b
data ends
测试通过的完整程序如下
assume cs:code,ds:data
data segment
a db 1,2,3,4,5,6,7,8
b dw 0
e dw a,b
data ends
code segment
start:mov ax,data
mov ds,ax
mov si,0
mov cx,8
s:mov al,a[si]
mov ah,0
add b,ax
inc si
loop s
mov ax,4c00h
int 21h
code ends
end start
数据标号c处存储的两个字型数据为标号a、b的偏移地址。相当于：
data segment
a db 1,2,3,4,5,6,7,8
b dw 0
c dw offset a,offset b
data ends
再比如：
data segment
a db 1,2,3,4,5,6,7,8
b dw 0
c dd a,b
data ends
数据标号c处存储的两个双字型数据为标号a的偏移地址和段地址、标号b的偏移地址和段地址。
相当于：
data segment
a db 1,2,3,4,5,6,7,8
b dw 0
c dw offset a,seg a,offset b,seg b
data ends
seg操作符，功能为取得某一标号的段地址。
检测点16.2
下面的程序将data段中a处的8个数据累加，结果存储到b处的字中，补全程序。
assume cs:code,es:data
data segment
a db 1,2,3,4,5,6,7,8
b dw 0
data ends
code segment
start:mov ax,data
mov es,ax
mov si,0
mov cx,8
s:mov al,a[si]
mov ah,0
add b,ax
inc si
loop s
mov ax,4c00h
int 21h
code ends
end start
完整的程序如下
assume cs:code,es:data
data segment
a db 1,2,3,4,5,6,7,8
b dw 0
data ends
code segment
start:mov ax,data
mov es,ax
mov si,0
mov cx,8
s:mov al,a[si]
mov ah,0
add b,ax
inc si
loop s
mov ax,4c00h
int 21h
code ends
end start
现在，我们讨论用查表的方法编写相关程序的技巧。
编写子程序，以十六进制的形式在屏幕中间显示给定的字节型数据。
分析：一个字节需要用两个十六进制数码来表示，所以，子程序需要在屏幕上显示两个ASCII字符。
我们当然要用“0”、“1”、“2”、“3”、“4”、“5”、“6”、“7”、“8”、“9”、“A”、“B”、“C”、“D”、“E”、“F”
这16个字符来显示十六进制数码。
我们可以将一个字节的高4位和低4位分开，分别用它们的值得到对应的数码字符。
比如2Bh，可以得到高4位的值为2，低4位的值为11，
那么如何用这两个数值得到对应的数码字符“2”和“B”呢？
最简单的办法就是一个一个地比较，如下：
如果数值为0，则显示“0”；
如果数值为1，则显示“1”；
...
如果数值为11，则显示“B”；
...
我们可以看出，这样做，程序中要使用多条比较、转移指令。程序将比较长，混乱。
显然，我们希望能够在数值0-15和字符“0”~“F”之间找到一种映射关系。
这样用0~15间的任何数值，都可以通过这种映射关系直接得到“0”~“F”中对应的字符。
数值0-9和字符“0”~“9”之间的映射关系是很明显的，即：
数值+30h=对应字符的ASCIⅡ值
0+30h=“0”的ASCII值
1+30h=“1”的ASCII值
2+30h=“2”的ASCII值
但是，10~15和“A”~“F”之间的映射关系是：
数值+37h=对应字符的ASCII值
10+37h=“A”的ASCII值
11+37h=“B”的ASCII值
12+37h=“C”的ASCII值
可见，我们可以利用数值和字符之间的这种原本存在的映射关系，
通过高4位和低4位值得到对应的字符码。
但是由于映射关系的不同，我们在程序中必须进行一些比较，
对于大于9的数值，我们要用不同的计算方法。
这样做，虽然使程序得到了简化。但是，如果我们希望用更简捷的算法，
就要考虑用同一种映射关系从数值得到字符码。
所以，我们就不能利用0~9和“0”~“9”之间与10~15和“A”~“F”之间原有的映射关系。
因为数值0-15和字符“0”~“F”之间没有一致的映射关系存在，
所以，我们应该在它们之间建立新的映射关系。
具体的做法是，建立一张表，表中依次存储字符“0”~“F”，
我们可以通过数值0~15直接查找到对应的字符。
子程序如下。用al传送要显示的数据
showbyte:jmp short show
table db '0123456789ABCDEF'
show:push bx
push es
mov ah,al
shr ah,1
shr ah,1
shr ah,1
shr ah,1
and al,00001111b
mov bl,ah
mov bh,0
mov ah,table[bx]
mov bx,0b800h
mov es,bx
mov es:[160*12+40*2],ah
mov bl,al
mov bh,0
mov al,table[bx]
mov es:[160*12+40*2+2],al
pop es
pop bx
ret
完整的程序如下
assume cs:code
code segment
start:mov al,6ah
call showbyte
mov ax,4c00h
int 21h
showbyte:jmp short show
table db '0123456789ABCDEF'
show:push bx
push es
mov ah,al
shr ah,1
shr ah,1
shr ah,1
shr ah,1
and al,00001111b
mov bl,ah
mov bh,0
mov ah,table[bx]
mov bx,0b800h
mov es,bx
mov es:[2000],ah
mov bl,al
mov bh,0
mov al,table[bx]
mov es:[2002],al
pop es
pop bx
ret
code ends
end start
可以看出，在子程序中，我们在数值0~15和字符“0”~“F”之间建立的映射关系为：
以数值N为table表中的偏移，可以找到对应的字符。
利用表，在两个数据集合之间建立一种映射关系，
使我们可以用查表的方法根据给出的数据得到其在另一集合中的对应数据。
这样做的目的一般来说有以下3个。
（1）为了算法的清晰和简洁；
（2）为了加快运算速度；
（3）为了使程序易于扩充。
在上面的子程序中，我们更多的是为了算法的清晰和简洁，而采用了查表的方法。
下面我们来看一下，为了加快运算速度而采用查表的方法的情况。
编写一个子程序，计算sin（x），x的集合{0°，30°，60°，90°，120°，150°，180°}，
并在屏幕中间显示计算结果。比如sin（30）的结果显示为“0.5”。
我们可以利用麦克劳林公式来计算sin（x）。x为角度，麦克劳林公式中需要代入弧度，则：
sin（x）=sin（y）约等于y- (y的三次方)/3! + (y的5次方)/5!
y=x/180*3.1415926
可以看出，计算sin（x）需要进行多次乘法和除法。
乘除是非常费时的运算，它们的执行时间大约是加法、比较等指令的5倍。
如何才能够不做乘除而计算sin（x）呢？我们看一下需要计算的sin（x）的结果：
sin（0）=0
sin（30）=0.5
sin（60）=0.866
sin（90）=1
sin（120）=0.866
sin（150）=0.5
sin（180）=0
我们可以看出，其实用不着计算，可以占用一些内存空间来换取运算的速度。
将所要计算的sin（x）的结果都存储到一张表中；然后用角度值来查表，找到对应的sin（x）的值。
用ax向子程序传递角度，程序如下：
showsin:jmp short show
table dw ag0,ag30,ag60,ag90,ag120,ag150,ag180
ag0 db '0',0
ag30 db '0.5',0
ag60 db '0.866',0
ag90 db '1',0
ag120 db '0.866',0
ag150 db '0.5',0
ag180 db '0',0
show:push bx
push es
push si
mov bx,0b800h
mov es,bx
mov ah,0
mov bl,30
div bl
mov bl,al
mov bh,0
add bx,bx
mov bx,table[bx]
mov si,160*12+40*2
shows:mov ah,cs:[bx]
cmp ah,0
je showret
mov es:[si],ah
inc bx
add si,2
jmp short shows
showret:pop si
pop es
pop bx
ret
完整的程序如下
assume cs:code
code segment
start:mov ax,30
call showsin
mov ax,4c00h
int 21h
showsin:jmp short show
table dw ag0,ag30,ag60,ag90,ag120,ag150,ag180
ag0 db '0',0
ag30 db '0.5',0
ag60 db '0.866',0
ag90 db '1',0
ag120 db '0.866',0
ag150 db '0.5',0
ag180 db '0',0
show:push bx
push es
push si
mov bx,0b800h
mov es,bx
mov ah,0
cmp al,180
ja showret
mov bl,30
div bl
mov bl,al
mov bh,0
add bx,bx
mov bx,table[bx]
mov si,2000
shows:mov ah,cs:[bx]
cmp ah,0
je showret
mov es:[si],ah
inc bx
add si,2
jmp short shows
showret:pop si
pop es
pop bx
ret
code ends
end start
在上面的子程序中，我们在角度值X和表示sin（x）的字符串集合table之间建立的映射关系为：
以角度值/30为table表中的偏移，可以找到对应的字符串的首地址。
编程的时候要注意程序的容错性，即对于错误的输入要有处理能力。
在上面的子程序中，我们还应该再加上对提供的角度值是否超范围的检测。
如果提供的角度值不在合法的集合中，程序将定位不到正确的字符串，出现错误。
对于角度值的检测，请读者自行完成。
上面的两个子程序中，我们将通过给出的数据进行计算或比较而得到结果的问题，
转化为用给出的数据作为查表的依据，通过查表得到结果的问题。
具体的查表方法，是用查表的依据数据，直接计算出所要查找的元素在表中的位置。
像这种可以通过依据数据，直接计算出所要找的元素的位置的表，我们称其为直接定址表。
我们可以在直接定址表中存储子程序的地址，从而方便地实现不同子程序的调用。
我们看下面的问题。
实现一个子程序setscreen，为显示输出提供如下功能。
（1）清屏；
（2）设置前景色；
（3）设置背景色；
（4）向上滚动一行。
入口参数说明如下。
（1）用ah寄存器传递功能号：
0表示清屏，1表示设置前景色，2表示设置背景色，3表示向上滚动一行；
（2）对于1、2号功能，用al传送颜色值，（al）的集合{0，1，2，3，4，5，6，7}。
下面我们讨论一下各种功能如何实现。
（1）清屏：将显存中当前屏幕中的字符设为空格符；
（2）设置前景色：设置显存中当前屏幕中处于奇地址的属性字节的第0、1、2位；
（3）设置背景色：设置显存中当前屏幕中处于奇地址的属性字节的第4、5、6位；
（4）向上滚动一行：依次将第n+1行的内容复制到第n行处；最后一行为空。
我们将这4个功能分别写为4个子程序，请读者根据编程思想，自行读懂下面的程序。
sub1:push bx
push cx
push es
mov bx,0b800h
mov es,bx
mov bx,0
mov cx,2000
sub1s:mov byte ptr es:[bx],' '
add bx,2
loop sub1s
pop es
pop cx
pop bx
ret
sub2:push bx
push cx
push es
mov bx,0b800h
mov es,bx
mov bx,1
mov cx,2000
sub2s:and byte ptr es:[bx],11111000b
or es:[bx],al
add bx,2
loop sub2s
pop es
pop cx
pop bx
ret
sub3:push bx
push cx
push es
mov cl,4
shl al,cl
mov bx,0b800h
mov es,bx
mov bx,1
mov cx,2000
sub3s:and byte ptr es:[bx],10001111b
or es:[bx],al
add bx,2
loop sub3s
pop es
pop cx
pop bx
ret
sub4:push cx
push si
push di
push es
push ds
mov si,0b800h
mov es,si
mov ds,si
mov si,160
mov di,0
cld
mov cx,24
sub4s:push cx
mov cx,160
rep movsb
pop cx
loop sub4s
mov cx,80
mov si,0
sub4s1:mov byte ptr[160*24+si],' '
add si,2
loop sub4s1
pop ds
pop es
pop di
pop si
pop cx
ret
我们可以将这些功能子程序的入口地址存储在一个表中，它们在表中的位置和功能号相对应。
对应关系为：功能号*2=对应的功能子程序在地址表中的偏移。程序如下：
setscreen:jmp short set
table dw sub1,sub2,sub3,sub4
set:push bx
cmp ah,3
ja sret
mov bl,ah
mov bh,0
add bx,bx
call word ptr table[bx]
sret:pop bx
ret
完整的程序如下
assume cs:code
code segment
start:mov ax,0000h
call setscreen
mov ax,4c00h
int 21h
setscreen:jmp short set
table dw sub1,sub2,sub3,sub4
set:push bx
cmp ah,3
ja setret
mov bl,ah
mov bh,0
add bx,bx
call word ptr table[bx]
setret:pop bx
ret
sub1:push bx
push cx
push es
mov bx,0b800h
mov es,bx
mov bx,0
mov cx,2000
sub1s:mov byte ptr es:[bx],' '
add bx,2
loop sub1s
pop es
pop cx
pop bx
ret
sub2:push bx
push cx
push es
mov bx,0b800h
mov es,bx
mov bx,1
mov cx,2000
sub2s:and byte ptr es:[bx],11111000b
or es:[bx],al
add bx,2
loop sub2s
pop es
pop cx
pop bx
ret
sub3:push bx
push cx
push es
mov cl,4
shl al,cl
mov bx,0b800h
mov es,bx
mov bx,1
mov cx,2000
sub3s:and byte ptr es:[bx],10001111b
or es:[bx],al
add bx,2
loop sub3s
pop es
pop cx
pop bx
ret
sub4:push cx
push si
push di
push es
push ds
mov si,0b800h
mov es,si
mov ds,si
mov si,160
mov di,0
cld
mov cx,24
sub4s:push cx
mov cx,160
rep movsb
pop cx
loop sub4s
mov cx,80
mov si,0
sub4s1:mov byte ptr [3840+si],' '
add si,2
loop sub4s1
pop ds
pop es
pop di
pop si
pop cx
ret
code ends
end start
当然，我们也可以将子程序setscreen如下实现。
setscreen:cmp ah,0
je do1
cmp ah,1
je do2
cmp ah,2
je do3
cmp ah,3
je do4
jmp short sret
do1:call sub1
jmp short sret
do2:call sub2
jmp short sret
do3:call sub3
jmp short sret
do4:call sub4
sret:ret
显然，用通过比较功能号进行转移的方法，程序结构比较混乱，不利于功能的扩充。
比如说，在setscreen中再加入一个功能，则需要修改程序的逻辑，加入新的比较、转移指令。
用根据功能号查找地址表的方法，程序的结构清晰，便于扩充。
如果加入一个新的功能子程序，那么只需要在地址表中加入它的入口地址就可以了。
安装一个新的int7ch中断例程，为显示输出提供如下功能子程序。
（1）清屏；
（2）设置前景色；
（3）设置背景色；
（4）向上滚动一行。
入口参数说明如下。
（1）用ah寄存器传递功能号：0表示清屏，1表示设置前景色，2表示设置背景色，
3表示向上滚动一行；
（2）对于1、2号功能，用al传送颜色值，（al）的集合{0，1，2，3，4，5，6，7}。
完整的程序如下
assume cs:code
code segment
start:mov ax,cs
mov ds,ax
mov si,offset setscreen
mov ax,0
mov es,ax
mov di,200h
mov cx,offset setscreenend-offset setscreen
cld
rep movsb
mov word ptr es:[496],200h
mov word ptr es:[498],0
mov ax,0000h
int 7ch
mov ax,4c00h
int 21h
setscreen:jmp short set
table dw offset sub1 - offset setscreen + 200h,offset sub2 - offset setscreen + 200h,offset sub3 - offset setscreen + 200h,offset sub4 - offset setscreen + 200h
set:push bx
cmp ah,3
ja setret
mov bl,ah
mov bh,0
add bx,bx
call word ptr cs:(table - setscreen + 200h)[bx]
setret:pop bx
iret
sub1:push bx
push cx
push es
mov bx,0b800h
mov es,bx
mov bx,0
mov cx,2000
sub1s:mov byte ptr es:[bx],' '
add bx,2
loop sub1s
pop es
pop cx
pop bx
ret
sub2:push bx
push cx
push es
mov bx,0b800h
mov es,bx
mov bx,1
mov cx,2000
sub2s:and byte ptr es:[bx],11111000b
or es:[bx],al
add bx,2
loop sub2s
pop es
pop cx
pop bx
ret
sub3:push bx
push cx
push es
mov cl,4
shl al,cl
mov bx,0b800h
mov es,bx
mov bx,1
mov cx,2000
sub3s:and byte ptr es:[bx],10001111b
or es:[bx],al
add bx,2
loop sub3s
pop es
pop cx
pop bx
ret
sub4:push cx
push si
push di
push es
push ds
mov si,0b800h
mov es,si
mov ds,si
mov si,160
mov di,0
cld
mov cx,24
sub4s:push cx
mov cx,160
rep movsb
pop cx
loop sub4s
mov cx,80
mov si,0
sub4s1:mov byte ptr [3840+si],' '
add si,2
loop sub4s1
pop ds
pop es
pop di
pop si
pop cx
ret
setscreenend:nop
code ends
end start
大多数有用的程序都需要处理用户的输入，键盘输入是最基本的输入。
程序和数据通常需要长期存储，磁盘是最常用的存储设备。
BIOS为这两种外设的I/O提供了最基本的中断例程，
在本章中，我们对它们的应用和相关的问题进行讨论。
我们已经讲过，键盘输入将引发9号中断，BIOS提供了int 9中断例程。
CPU在9号中断发生后，执行int 9中断例程，从60h端口读出扫描码，
并将其转化为相应的ASCII码或状态信息，存储在内存的指定空间（键盘缓冲区或状态字节）中。
一般的键盘输入，在CPU执行完int 9中断例程后，都放到了键盘缓冲区中。
键盘缓冲区中有16个字单元，可以存储15个按键的扫描码和对应的ASCII码。
下面我们按照键盘缓冲区的逻辑结构，来看一下键盘输入的扫描码和对应的ASCII码是如何
写入键盘缓冲区的。
注意：在我们的课程中，仅在逻辑结构的基础上，讨论BIOS键盘缓冲区的读写问题。
其实键盘缓冲区是用环形队列结构管理的内存区，但我们不对队列和环形队列的实现进行讨论，
因为那是另一门专业课《数据结构》的内容。
下面，我们通过下面几个键：
1E  30 2E 20  12   2A  1E
A、B、C、D、E、Shift_A、A的输入过程，简要地看一下int 9中断例程对键盘输入的处理方法。
41 42 43 44 45 41
61 62 63 64 65 61 
a b c d e
0040：17单元存储键盘状态字节，该字节记录了控制键和切换键的状态。
键盘状态字节各位记录的信息如下。
0：右shift状态，置1表示按下右shift键；
1：左shift状态，置1表示按下左shift键；
2：Ctrl状态，置1表示按下Ctrl键；
3：Alt状态，置1表示按下Alt键；
4：ScrollLock状态，置1表示Scroll指示灯亮；
5：NumLock状态，置1表示小键盘输入的是数字；
6：CapsLock状态，置1表示输入大写字母；
7：Insert状态，置1表示处于删除态。
（1）初始状态下，没有键盘输入，键盘缓冲区空，此时没有任何元素。
（2）按下A键，引发键盘中断；CPU执行int 9中断例程，从60h端口读出A键的通码；
然后检测状态字节，看看是否有Shift、Ctrl等切换键按下；
发现没有切换键按下，则将A键的扫描码1eh和对应的ASCII码，即字母“a”的ASCII码61h，
写入键盘缓冲区。缓冲区的字单元中，高位字节存储扫描码，低位字节存储ASCⅡ码。
此时缓冲区中的内容如下。
1E61
（3）按下B键，引发键盘中断；CPU执行int 9中断例程，从60h端口读出B键的通码；
然后检测状态字节，看看是否有切换键按下；发现没有切换键按下，
将B键的扫描码30h和对应的ASCII码，即字母“b”的ASCII码62h，写入键盘缓冲区。
此时缓冲区中的内容如下。
1E61 3062
（4）按下C、D、E键后，缓冲区中的内容如下。
1E61 3062 2E63 2064 1265
（5）按下左Shift键，引发键盘中断；int 9中断例程接收左Shift键的通码，
设置0040：17处的状态字节的第1位为1，表示左Shift键按下。
（6）按下A键，引发键盘中断；CPU执行int 9中断例程，从60h端口读出A键的通码；
检测状态字节，看看是否有切换键按下；发现左Shift键被按下，
则将A键的扫描码1Eh和Shift_A对应的ASCII码，即字母“A”的ASCII码41h，写入键盘缓冲区。
此时缓冲区中的内容如下。
1E61 3062 2E63 2064 1265 1E41
（7）松开左Shift键，引发键盘中断；int 9中断例程接收左Shift键的断码，
设置0040：17处的状态字节的第1位为0，表示左Shift键松开。
（8）按下A键，引发键盘中断；CPU执行int 9中断例程，从60h端口读出A键的通码；
然后检测状态字节，看看是否有切换键按下；发现没有切换键按下，
则将A键的扫描码1Eh和A对应的ASCII码，即字母“a”的ASCII码61h，写入键盘缓冲区。
此时缓冲区中的内容如下。
1E61 3062 2E63 2064 1265 1E41 1E61
BIOS提供了int 16h中断例程供程序员调用。int 16h中断例程中包含的一个最重要的功能是
从键盘缓冲区中读取一个键盘输入，该功能的编号为0。
下面的指令从键盘缓冲区中读取一个键盘输入，并且将其从缓冲区中删除：
mov ah,0
int 16h
结果：（ah）=扫描码，（al）=ASCII码。
下面我们接着上一节中的键盘输入过程，看一下int 16h如何读取键盘缓冲区。
（1）执行
mov ah,0
int 16h
后，缓冲区中的内容如下。
3062 2E63 2064 1265 1E41 1E61
ah中的内容为1Eh，al中的内容为61h。
（2）执行
mov ah,0
int 16h
后，缓冲区中的内容如下。
2E63 2064 1265 1E41 1E61
ah中的内容为30h，al中的内容为62h。
（3）执行
mov ah,0
int 16h
后，缓冲区中的内容如下。
2064 1265 1E41 1E61
ah中的内容为2Eh，al中的内容为63h。
（4）执行4次
mov ah,0
int 16h
后，缓冲区空。
ah中的内容为1Eh，al中的内容为61h。
（5）执行
mov ah,0
int 16h
int 16h中断例程检测键盘缓冲区，发现缓冲区空，则循环等待，直到缓冲区中有数据。
（6）按下A键后，缓冲区中的内容如下。
1E61
（7）循环等待的int 16h中断例程检测到键盘缓冲区中有数据，将其读出，缓冲区又为空。
ah中的内容为1Eh，al中的内容为61h。
从上面我们可以看出，int16h中断例程的0号功能，进行如下的工作。
（1）检测键盘缓冲区中是否有数据；
（2）没有则继续做第1步；
（3）读取缓冲区第一个字单元中的键盘输入；
（4）将读取的扫描码送入ah，ASCII码送入al；
（5）将已读取的键盘输入从缓冲区中删除。
可见，BIOS的int 9中断例程和int 16h中断例程是一对相互配合的程序，
int 9中断例程向键盘缓冲区中写入，int 16h中断例程从缓冲区中读出。
它们写入和读出的时机不同，int 9中断例程是在有键按下的时候向键盘缓冲区中写入数据；
而int 16h中断例程是在应用程序对其进行调用的时候，将数据从键盘缓冲区中读出。
我们在编写一般的处理键盘输入的程序的时候，可以调用int 16h从键盘缓冲区中读取键盘的输入。
编程，接收用户的键盘输入，
输入“r”，将屏幕上的字符设置为红色；
输入“g”，将屏幕上的字符设置为绿色；
输入“b”，将屏幕上的字符设置为蓝色。
程序如下，画线处的程序比较技巧，请读者自行分析。
assume cs:code
code segment
start:mov ah,0
int 16h
mov ah,1
cmp al,'r'
je red
cmp al,'g'
je green
cmp al,'b'
je blue
jmp short sret
red:shl ah,1
green:shl ah,1
blue:mov bx,0b800h
mov es,bx
mov bx,1
mov cx,2000
s:and byte ptr es:[bx],11111000b
or es:[bx],ah
add bx,2
loop s
sret:mov ax,4c00h
int 21h
code ends
end start
完整的程序如下
assume cs:code
code segment
start:mov ah,0
int 16h
mov ah,1
cmp al,'r'
je red
cmp al,'g'
je green
cmp al,'b'
je blue
jmp short sret
red:shl ah,1
green:shl ah,1
blue:mov bx,0b800h
mov es,bx
mov bx,1
mov cx,2000
s:and byte ptr es:[bx],11111000b
or es:[bx],ah
add bx,2
loop s
sret:mov ax,4c00h
int 21h
code ends
end start
检测点17.1
“在int 16h中断例程中，一定有设置IF=1的指令。”这种说法对吗？
正确，int 16h中断例程在键盘缓冲区中没有数据时，会等待直到键盘缓冲区中有数据为止，
因此，int 16h中需要处理int 9h中断，所以一定有设置IF=1的指令。
用户通过键盘输入的通常不仅仅是单个字符而是字符串。
下面我们讨论字符串输入中的问题和简单的解决方法。
最基本的字符串输入程序，需要具备下面的功能。
（1）在输入的同时需要显示这个字符串；
（2）一般在输入回车符后，字符串输入结束；
（3）能够删除已经输入的字符。
对于这3个功能，我们可以想象在DOS中，输入命令行时的情况。
编写一个接收字符串输入的子程序，实现上面3个基本功能。
因为在输入的过程中需要显示，子程序的参数如下：
（dh）、（dl）=字符串在屏幕上显示的行、列位置；
ds:si指向字符串的存储空间，字符串以0为结尾符。
下面我们进行分析。
（1）字符的输入和删除。
每个新输入的字符都存储在前一个输入的字符之后，而删除是从最后面的字符进行的，
我们看下面的过程。
空字符串：
输入“a”：a
输入“b”：ab
输入“c”：abc
输入“d”：abcd
删除一个字符：abc
删除一个字符：ab
删除一个字符：a
删除一个字符：
可以看出在字符串输入的过程中，字符的输入和输出是按照栈的访问规则进行的，即后进先出。
这样，我们就可以用栈的方式来管理字符串的存储空间，也就是说，
字符串的存储空间实际上是一个字符栈。字符栈中的所有字符，从栈底到栈顶，组成一个字符串。
（2）在输入回车符后，字符串输入结束。
输入回车符后，可以在字符串中加入0，表示字符串结束。
（3）在输入的同时需要显示这个字符串。
每次有新的字符输入和删除一个字符的时候，都应该重新显示字符串，
即从字符栈的栈底到栈顶，显示所有的字符。
（4）程序的处理过程。
现在我们可以简单地确定程序的处理过程如下。
①调用int 16h读取键盘输入；
②如果是字符，进入字符栈，显示字符栈中的所有字符；继续执行①；
③如果是退格键，从字符栈中弹出一个字符，显示字符栈中的所有字符；继续执行①；
④如果是Enter键，向字符栈中压入0，返回。
从程序的处理过程中可以看出，字符栈的入栈、出栈和显示栈中的内容，是需要在多处使用的功能，
我们应该将它们写为子程序。
子程序：字符栈的入栈、出栈和显示。
参数说明：（ah）=功能号，0表示入栈，1表示出栈，2表示显示；
ds:si指向字符栈空间；
对于0号功能：（al）=入栈字符；
对于1号功能：（al）=返回的字符；
对于2号功能：（dh）、（dl）=字符串在屏幕上显示的行、列位置。
charstack:jmp short charstart
table dw charpush,charpop,charshow
top dw 0
charstart:push bx
push dx
push di
push es
cmp ah,2
ja sret
mov bl,ah
mov bh,0
add bx,bx
jmp word ptr table[bx]
charpush:mov bx,top
mov [si][bx],al
inc top
jmp sret
charpop:cmp top,0
je sret
dec top
mov bx,top
mov al,[si][bx]
jmp sret
charshow:mov bx,0b800h
mov es,bx
mov al,160
mov ah,0
mul dh
mov di,ax
add dl,dl
mov dh,0
add di,dx
mov bx,0
charshows:cmp bx,top
jne noempty
mov byte ptr es:[di],' '
jmp sret
noempty:mov al,[si][bx]
mov es:[di],al
mov byte ptr es:[di+2],' '
inc bx
add di,2
jmp charshows
sret:pop es
pop di
pop dx
pop bx
ret
上面的子程序中，字符栈的访问规则如下所示。
（1）栈空
（2）“a”入栈
（3）“b”入栈
另外一个要注意的问题是，显示栈中字符的时候，要注意清除屏幕上上一次显示的内容。
我们现在写出完整的接收字符串输入的子程序，如下所示。
getstr:push ax
getstrs:mov ah,0
int 16h
cmp al,20h
jb nochar
mov ah,0
call charstack
mov ah,2
call charstack
jmp getstrs
nochar:cmp ah,0eh
je backspace
cmp ah,1ch
je enter
jmp getstrs
backspace:mov ah,1
call charstack
mov ah,2
call charstack
jmp getstrs
enter:mov al,0
mov ah,0
call charstack
mov ah,2
call charstack
pop ax
ret
完整的程序如下
assume cs:code
data segment
db 128 dup (0)
data ends
stack segment
dw 128 dup (0)
stack ends
code segment
start:mov ax,data
mov ds,ax
mov ax,stack
mov ss,ax
mov sp,256
mov si,0
call getstr
mov ax,4c00h
int 21h
getstr:push ax
push dx
mov dh,12
mov dl,36
getstrs:mov ah,0
int 16h
cmp al,20h
jb nochar
mov ah,0
call charstack
mov ah,2
call charstack
jmp getstrs
nochar:cmp ah,0eh
je backspace
cmp ah,1ch
je enter
jmp getstrs
backspace:mov ah,1
call charstack
mov ah,2
call charstack
jmp getstrs
enter:mov al,0
mov ah,0
call charstack
mov ah,2
call charstack
pop dx
pop ax
ret
charstack:jmp short charstart
table dw charpush,charpop,charshow
top dw 0
charstart:push bx
push dx
push di
push es
cmp ah,2
ja sret
mov bl,ah
mov bh,0
add bx,bx
jmp word ptr table[bx]
charpush:mov bx,top
mov ds:[si][bx],al
inc top
jmp sret
charpop:cmp top,0
je sret
dec top
mov bx,top
mov al,ds:[si][bx]
jmp sret
charshow:mov bx,0b800h
mov es,bx
mov al,160
mul dh
mov di,ax
mov al,2
mul dl
add di,ax
mov bx,0
charshows:cmp bx,top
jne noempty
mov byte ptr es:[di],' '
jmp sret
noempty:mov al,ds:[si][bx]
mov es:[di],al
mov byte ptr es:[di+2],' '
inc bx
add di,2
jmp charshows
sret:pop es
pop di
pop dx
pop bx
ret
code ends
end start
我们主要以3.5英寸软盘为例，进行讲解。
3.5英寸软盘分为上下两面，每面有80个磁道，每个磁道又分为18个扇区，
每个扇区的大小为512个字节。
则：2面*80磁道*18扇区*512字节=1440KB约等于1.44MB
磁盘的实际访问由磁盘控制器进行，我们可以通过控制磁盘控制器来访问磁盘。
只能以扇区为单位对磁盘进行读写。在读写扇区的时候，要给出面号、磁道号和扇区号。
面号和磁道号从0开始，而扇区号从1开始。
如果我们通过直接控制磁盘控制器来访问磁盘，则需要涉及许多硬件细节。
BIOS提供了对扇区进行读写的中断例程，这些中断例程完成了许多复杂的和硬件相关的工作。
我们可以通过调用BIOS中断例程来访问磁盘。
BIOS 提供的访问磁盘的中断例程为int 13h。
功能02H  
功能描述：读扇区 
入口参数：AH＝02H 
AL＝扇区数 
CH＝软盘 磁道号
CL＝软盘 扇区号
DH＝软盘 磁头号 面号
DL＝软盘 驱动器号
00H~7FH：软盘；80H~0FFH：硬盘 
软驱从0开始，0：软驱 A，1：软驱 B；
硬盘从80h开始，80h：硬盘C，81h：硬盘D
ES:BX＝缓冲区的地址 
出口参数：CF＝0 操作成功，AH＝00H，AL＝传输的扇区数，否则，AH＝状态代码 出错代码 
功能03H  
功能描述：写扇区 
入口参数：AH＝03H 
AL＝扇区数 
CH＝软盘 磁道号
CL＝软盘 扇区号
DH＝软盘 磁头号 面号
DL＝软盘 驱动器号
00H~7FH：软盘；80H~0FFH：硬盘 
软驱从0开始，0：软驱 A，1：软驱 B；
硬盘从80h开始，80h：硬盘C，81h：硬盘D
ES:BX＝缓冲区的地址 
出口参数：CF＝0 操作成功，AH＝00H，AL＝传输的扇区数，否则，AH＝状态代码 出错代码 
读取0面0道1扇区的内容到0：200的程序如下所示。
mov ax,0
mov es,ax
mov bx,200h
mov al,1
mov ch,0
mov cl,1
mov dl,0
mov dh,0
mov ah,2
int 13h
入口参数：
（ah）=int 13h的功能号（2表示读扇区）
（al）=读取的扇区数
（ch）= 磁道号
（cI）=扇区号
（dh）=磁头号（对于软盘即面号，因为一个面用一个磁头来读写）
（dI）=驱动器号
软驱从0开始，0：软驱 A，1：软驱 B；
硬盘从80h开始，80h：硬盘C，81h：硬盘D
es:bx指向接收从扇区读入数据的内存区
返回参数：操作成功：（ah）=0，（al）=读入的扇区数
操作失败：（ah）=出错代码
将0：200中的内容写入0面0道1扇区。
mov ax,0
mov es,ax
mov bx,200h
mov al,1
mov ch,0
mov cl,1
mov dl,0
mov dh,0
mov ah,3
int 13h
入口参数：
（ah）= int 13h的功能号（3表示写扇区）
（al）=写入的扇区数
（ch）=磁道号
（cl）=扇区号
（dh）=磁头号（面）
（dl）=驱动器号
软驱从0开始，0：软驱 A，1：软驱 B；
硬盘从80h开始，80h：硬盘C，81h：硬盘D
es:bx指向将写入磁盘的数据
返回参数：
操作成功：（ah）=0，（al）=写入的扇区数
操作失败：（ah）=出错代码
注意，下面我们要使用int 13h中断例程对软盘进行读写。
直接向磁盘扇区写入数据是很危险的，很可能覆盖掉重要的数据。
如果向软盘的0面0道1扇区中写入了数据，要使软盘在现有的操作系统下可以使用，
必须要重新格式化。在编写相关的程序之前，必须要找一张空闲的软盘。
在使用int 13h中断例程时一定要注意驱动器号是否正确，千万不要随便对硬盘中的扇区进行写入。
编程：将当前屏幕的内容保存在磁盘上。
分析：1屏的内容占4000个字节，需要8个扇区，用0面0道的1-8扇区存储显存中的内容。
程序如下。
assume cs:code
code segment
start:mov ax,0b800h
mov es,ax
mov bx,0
mov al,8
mov ch,0
mov cl,1
mov dl,0
mov dh,0
mov ah,3
int 13h
mov ax,4c00h
int 21h
code ends
end start
完整的程序如下
测试通过的写软盘
assume cs:code
code segment
start:mov ax,0b800h
mov es,ax
mov bx,0
mov al,8
mov ch,0
mov cl,1
mov dl,0
mov dh,0
mov ah,3
int 13h
mov ax,4c00h
int 21h
code ends
end start
测试通过的读软盘
assume cs:code
code segment
start:mov ax,0b800h
mov es,ax
mov bx,0
mov al,8
mov ch,0
mov cl,1
mov dl,0
mov dh,0
mov ah,2
int 13h
mov ax,4c00h
int 21h
code ends
end start
我们可以看出，用面号、磁道号、扇区号来访问磁盘不太方便。
可以考虑对位于不同的磁道、面上的所有扇区进行统一编号。
编号从0开始，一直到2879，我们称这个编号为逻辑扇区编号。
编号的方法如下所示。
物理扇区号        逻辑扇区号
0面0道1扇区 0
0面0道2扇区 1
0面0道3扇区 2
0面0道4扇区 3
...
0面0道18扇区 17
0面1道1扇区 18
0面1道2扇区 19
0面1道3扇区 20
0面1道4扇区 21
...
0面1道18扇区 35
0面2道1扇区 36
0面2道2扇区 37
0面2道3扇区 38
0面2道4扇区 39
...
0面79道18扇区 1439
1面0道1扇区 1440
1面0道2扇区 1441
1面0道3扇区 1442
1面0道4扇区 1443
可以看出，逻辑扇区号和物理扇区号的关系如下：
逻辑扇区号=（面号*80+磁道号）*18+扇区号-1
那么如何根据逻辑扇区号算出物理编号呢？可以用下面的算法。
int()：描述性运算符，取商
rem()：描述性运算符，取余数
逻辑扇区号=（面号*80+磁道号）*18+扇区号-1
面号=int（逻辑扇区号/1440）
磁道号=int（rem（逻辑扇区号/1440）/18）
扇区号= rem（rem（逻辑扇区号/1440）/18）+ 1
安装一个新的int 7ch中断例程，实现通过逻辑扇区号对软盘进行读写。
参数说明：
（1）用ah寄存器传递功能号：0表示读，1表示写；
（2）用dx寄存器传递要读写的扇区的逻辑扇区号；
（3）用es:bx指向存储读出数据或写入数据的内存区。
提示，用逻辑扇区号计算出面号、磁道号、扇区号后，调用int 13h中断例程进行实际的读写。
完整的程序如下
assume cs:code
code segment
start:mov ax,cs
mov ds,ax
mov si,offset floppyio
mov ax,0
mov es,ax
mov di,200h
mov cx,offset floppyioend-offset floppyio
cld
rep movsb
mov word ptr es:[496],200h
mov word ptr es:[498],0
mov ax,0b800h
mov es,ax
mov bx,0
mov ax,0000h
mov dx,0
int 7ch
mov ax,4c00h
int 21h
floppyio:push ax
push cx
push dx
add ah,2
mov al,1
push ax
mov ax,dx
mov dx,0
mov cx,1440
div cx
push ax
mov ax,dx
mov dl,18
div dl
inc ah
mov ch,al
mov cl,ah
pop ax
mov dh,al
mov dl,0
pop ax
int 13h
pop dx
pop cx
pop ax
iret
floppyioend:nop
code ends
end start
阅读下面的材料：开机后，CPU自动进入到FFFF：0单元处执行，此处有一条跳转指令。
CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序。
初始化程序将建立BIOS所支持的中断向量，
即将BIOS提供的中断例程的入口地址登记在中断向量表中。
硬件系统检测和初始化完成后，调用int 19h进行操作系统的引导。
如果设为从软盘启动操作系统，则int 19h将主要完成以下工作。
（1）控制0号软驱，读取软盘0道0面1扇区的内容到0：7c00；
（2）将CS:IP指向0：7c00。
软盘的0道0面1扇区中装有操作系统引导程序。int 19h将其装到0：7c00处后，
设置CPU从0：7c00开始执行此处的引导程序，操作系统被激活，控制计算机。
如果在0号软驱中没有软盘，或发生软盘IO错误，则int 19h将主要完成以下工作。
（1）读取硬盘C的0道0面1扇区的内容到0：7c00；
（2）将CS:IP指向0：7c00。
这次课程设计的任务是编写一个可以自行启动计算机，不需要在现有操作系统环境中运行的程序。
该程序的功能如下。
（1）列出功能选项，让用户通过键盘进行选择，界面如下。
1）reset pc 重新启动计算机
2）start system 引导现有的操作系统
3）clock 进入时钟程序
4）set clock 设置时间
（2）用户输入"1”后重新启动计算机（提示：考虑ffff：0单元）。
（3）用户输入“2"后引导现有的操作系统（提示：考虑硬盘C的0道0面1扇区）。
（4）用户输入"3”后，执行动态显示当前日期、时间的程序。
显示格式如下：年/月/日 时：分：秒
进入此项功能后，一直动态显示当前的时间，在屏幕上将出现时间按秒变化的效果
（提示：循环读取CMOS）
当按下F1键后，改变显示颜色；按下Esc键后，返回到主选单（提示：利用键盘中断）。
（5）用户输入“4”后可更改当前的日期、时间，更改后返回到主选单（提示：输入字符串）。
下面给出几点建议：
（1）在DOS下编写安装程序，在安装程序中包含任务程序；
（2）运行安装程序，将任务程序写到软盘上；
（3）若要任务程序可以在开机后自行执行，要将它写到软盘的0道0面1扇区上。
如果程序长度大于512个字节，则需要用多个扇区存放，
这种情况下，处于软盘0道0面1扇区中的程序就必须负责将其他扇区中的内容读入内存。
这个程序较为复杂，它用到了我们所学到的所有技术，需要进行仔细地分析和耐心地调试。
这个程序对于我们的整个学习过程是具有总结性的，希望读者能够尽力完成。
测试通过的完整程序如下
assume cs:code
code segment
start:mov ax,cs
mov es,ax
mov bx,offset boot_main
mov ah,3
mov al,3
mov ch,0
mov cl,1
mov dh,0
mov dl,0
int 13h
mov ax,4c00h
int 21h
boot_main:jmp main_menu
menu_1 db '1) Reset PC',0
menu_2 db '2) Start System',0
menu_3 db '3) Show Clock',0
menu_4 db '4) Set Clock',0
menu_5 db 'Please Enter Your Choice[1-4]:',0
menu_table dw offset menu_1 - offset boot_main + 7c00h,offset menu_2 - offset boot_main + 7c00h,offset menu_3 - offset boot_main + 7c00h,offset menu_4 - offset boot_main + 7c00h,offset menu_5 - offset boot_main + 7c00h
char_table dw offset charpush - offset boot_main + 7c00h,offset charpop - offset boot_main + 7c00h,offset charshow - offset boot_main + 7c00h
char_array db 32 dup (0)
char_top dw 0
char_error db 'Input Error!',0
char_datetime db 'yy/mm/dd hh:mm:ss',0
cmos_datetime db 9,8,7,4,2,0
tip_clock db 'Press F1 to change the color and Press ESC to return',0
tip_setclock db 'Press Input DateTime[YYMMDDhhmmss]:',0
datetime_array db 8 dup (0)
main_menu:mov ax,cs
mov es,ax
mov bx,7e00h
mov ah,2
mov al,2
mov ch,0
mov cl,2
mov dh,0
mov dl,0
int 13h
call show_main_menu
mov ax,4c00h
int 21h
show_main_menu:push dx
push cx
push bx
push si
push ds
main_menu_start:call clear_screen
mov bx,cs
mov ds,bx
mov bx,0
mov cx,5
mov dh,8
mov dl,12
show_main_menu_s:push cx
mov si,cs:(offset menu_table - offset boot_main + 7c00h)[bx]
mov cl,7
call show_str
inc dh
add bx,2
pop cx
loop show_main_menu_s
main_input_start:mov dh,12
mov dl,42
call getstr
mov ax,0
call check_main_menu
cmp ax,0
je main_input_start
cmp ax,1
je choice_1
cmp ax,2
je choice_2
cmp ax,3
je choice_3
cmp ax,4
je choice_4
jmp main_menu_start
choice_1:call reset_pc
jmp main_menu_ret
choice_2:call start_system
jmp main_menu_ret
choice_3:call show_clock
jmp main_menu_start
choice_4:call set_clock
jmp main_menu_start
main_menu_ret:pop ds
pop si
pop bx
pop cx
pop dx
ret
show_str:push dx
push cx
push bx
push ax
push si
push di
push es
mov ax,0B800H
mov es,ax
mov bx,0
mov di,0
mov al,160
mul dh
add bx,ax
mov al,2
mul dl
add bx,ax
mov al,cl
show_str_s:mov cl,ds:[si]
mov ch,0
jcxz show_str_ok
mov ch,al
mov es:[bx+di],cx
inc si
add di,2
jmp show_str_s
show_str_ok:pop es
pop di
pop si
pop ax
pop bx
pop cx
pop dx
ret
clear_screen:push bx
push cx
push es
mov bx,0b800h
mov es,bx
mov bx,0
mov cx,2000
clear_screen_s:mov byte ptr es:[bx],' '
mov byte ptr es:[bx+1],7
add bx,2
loop clear_screen_s
pop es
pop cx
pop bx
ret
clear_keyboard_buffer:push ax
clear_keyboard_buffer_s:mov ah,1
int 16h
jz clear_keyboard_buffer_ok
mov ah,0
int 16h
jmp clear_keyboard_buffer_s
clear_keyboard_buffer_ok:pop ax
ret
getstr:push ax
push bx
push cx
push dx
push si
push ds
call clear_line
call clear_keyboard_buffer
mov bx,cs
mov ds,bx
mov si,offset char_array - offset boot_main + 7c00h
mov word ptr cs:(offset char_top - offset boot_main + 7c00h)[0],0
mov ah,2
mov bh,0
int 10h
getstrs:mov ah,0
int 16h
cmp al,20h
jb nochar
mov ah,0
call charstack
mov ah,2
call charstack
push dx
mov ax,word ptr cs:(offset char_top - offset boot_main + 7c00h)[0]
add dl,al
mov ah,2
mov bh,0
int 10h
pop dx
jmp getstrs
nochar:cmp ah,0eh
je backspace
cmp ah,1ch
je enter
jmp getstrs
backspace:mov ah,1
call charstack
mov ah,2
call charstack
push dx
mov ax,word ptr cs:(offset char_top - offset boot_main + 7c00h)[0]
add dl,al
mov ah,2
mov bh,0
int 10h
pop dx
jmp getstrs
enter:mov al,0
mov ah,0
call charstack
mov ah,2
call charstack
pop ds
pop si
pop dx
pop cx
pop bx
pop ax
ret
charstack:push bx
push dx
push di
push es
charstart:cmp ah,2
ja charstackret
mov bl,ah
mov bh,0
add bx,bx
jmp word ptr cs:(offset char_table - offset boot_main + 7c00h)[bx]
charpush:mov bx,word ptr cs:(offset char_top - offset boot_main + 7c00h)[0]
mov ds:[si][bx],al
inc word ptr cs:(offset char_top - offset boot_main + 7c00h)[0]
jmp charstackret
charpop:cmp word ptr cs:(offset char_top - offset boot_main + 7c00h)[0],0
je charstackret
dec word ptr cs:(offset char_top - offset boot_main + 7c00h)[0]
mov bx,word ptr cs:(offset char_top - offset boot_main + 7c00h)[0]
mov al,ds:[si][bx]
jmp charstackret
charshow:mov bx,0b800h
mov es,bx
mov al,160
mul dh
mov di,ax
mov al,2
mul dl
add di,ax
mov bx,0
charshows:cmp bx,word ptr cs:(offset char_top - offset boot_main + 7c00h)[0]
jne noempty
mov byte ptr es:[di],' '
jmp charstackret
noempty:mov al,ds:[si][bx]
mov es:[di],al
mov byte ptr es:[di+2],' '
inc bx
add di,2
jmp charshows
charstackret:pop es
pop di
pop dx
pop bx
ret
clear_line:push dx
push cx
push bx
push ax
push es
mov bx,0b800h
mov es,bx
mov al,160
mul dh
mov bx,ax
mov al,2
mul dl
add bx,ax
mov cx,80
mov al,dl
mov ah,0
sub cx,ax
clear_line_s:mov byte ptr es:[bx],' '
mov byte ptr es:[bx+1],7
add bx,2
loop clear_line_s
pop es
pop ax
pop bx
pop cx
pop dx
ret
delay:push ax
push dx
mov ax,0
delay_s:sub ax,1
sbb dx,0
cmp ax,0
jne delay_s
cmp dx,0
jne delay_s
pop dx
pop ax
ret
check_main_menu:push dx
push cx
push bx
push si
push ds
cmp word ptr cs:(offset char_top - offset boot_main + 7c00h)[0],2
jne check_error
mov bx,cs
mov ds,bx
mov si,offset char_array - offset boot_main + 7c00h
mov al,ds:[si][0]
cmp al,31h
jb check_error
cmp al,34h
ja check_error
sub al,30h
jmp check_main_menu_ret
check_error:mov al,0
call clear_line
mov si,offset char_error - offset boot_main + 7c00h
mov cl,7
call show_str
push dx
mov dx,5000h
call delay
pop dx
check_main_menu_ret:
pop ds
pop si
pop bx
pop cx
pop dx
ret
change_color:push bx
push cx
push es
mov bx,0b800h
mov es,bx
mov bx,1
mov cx,2000
change_color_s:inc byte ptr es:[bx]
or byte ptr es:[bx],00001000b
and byte ptr es:[bx],00001111b
add bx,2
loop change_color_s
pop es
pop cx
pop bx
ret
show_datetime:push dx
push cx
push bx
push ax
push si
push di
push ds
push es
mov bx,cs
mov ds,bx
mov es,bx
mov si,offset cmos_datetime - offset boot_main + 7c00h
mov di,offset char_datetime - offset boot_main + 7c00h
mov cx,6
show_datetime_s:push cx
mov al,ds:[si]
out 70h,al
in al,71h
mov ah,al
mov cl,4
shr ah,cl
and al,00001111b
add ah,30h
add al,30h
mov byte ptr es:[di],ah
mov byte ptr es:[di+1],al
add di,3
inc si
pop cx
loop show_datetime_s
mov si,offset char_datetime - offset boot_main + 7c00h
mov bx,0b800h
mov es,bx
mov bx,1
mov cl,es:[bx]
call show_str
pop es
pop ds
pop di
pop si
pop ax
pop bx
pop cx
pop dx
ret
show_clock:push dx
push cx
push bx
push ax
push si
push ds
call clear_screen
call clear_keyboard_buffer
mov bx,cs
mov ds,bx
mov si,offset tip_clock - offset boot_main + 7c00h
mov dh,8
mov dl,12
mov cl,7
call show_str
mov dh,11
mov dl,12
show_clock_start:call show_datetime
push dx
mov dx,2000h
call delay
pop dx
mov ah,1
int 16h
jz show_clock_start
cmp ah,3BH
je change_clock_color
cmp al,1BH
je show_clock_finish
call clear_keyboard_buffer
jmp show_clock_start
change_clock_color:call change_color
call clear_keyboard_buffer
jmp show_clock_start
show_clock_finish:call clear_keyboard_buffer
show_clock_ret:pop ds
pop si
pop ax
pop bx
pop cx
pop dx
ret
check_clock_datetime:push dx
push cx
push bx
push si
push ds
cmp word ptr cs:(offset char_top - offset boot_main + 7c00h)[0],13
jne check_clock_error
mov bx,cs
mov ds,bx
mov si,offset char_array - offset boot_main + 7c00h
mov cx,12
mov bx,0
check_clock_s:mov al,ds:[si][bx]
cmp al,30h
jb check_clock_error
cmp al,39h
ja check_clock_error
inc bx
loop check_clock_s
mov al,1
jmp check_clock_ret
check_clock_error:mov al,0
call clear_line
mov si,offset char_error - offset boot_main + 7c00h
mov cl,7
call show_str
push dx
mov dx,5000h
call delay
pop dx
check_clock_ret:
pop ds
pop si
pop bx
pop cx
pop dx
ret
get_clock_datetime:push dx
push cx
push bx
push ax
push si
push di
push ds
push es
mov bx,cs
mov ds,bx
mov es,bx
mov si,offset char_array - offset boot_main + 7c00h
mov di,offset datetime_array - offset boot_main + 7c00h
mov cx,6
get_clock_datetime_s:push cx
mov ah,ds:[si]
mov al,ds:[si+1]
sub ah,30h
sub al,30h
mov cl,4
shl ah,cl
and al,00001111b
or ah,al
mov es:[di],ah
add si,2
inc di
pop cx
loop get_clock_datetime_s
pop es
pop ds
pop di
pop si
pop ax
pop bx
pop cx
pop dx
ret
set_clock_datetime:push dx
push cx
push bx
push ax
push si
push di
push ds
push es
mov bx,cs
mov ds,bx
mov es,bx
mov si,offset cmos_datetime - offset boot_main + 7c00h
mov di,offset datetime_array - offset boot_main + 7c00h
mov cx,6
set_clock_datetime_s:mov al,ds:[si]
out 70h,al
mov al,es:[di]
out 71h,al
inc si
inc di
loop set_clock_datetime_s
pop es
pop ds
pop di
pop si
pop ax
pop bx
pop cx
pop dx
ret
set_clock:push dx
push cx
push bx
push ax
push si
push ds
call clear_screen
call clear_keyboard_buffer
mov bx,cs
mov ds,bx
mov si,offset tip_setclock - offset boot_main + 7c00h
mov dh,8
mov dl,8
mov cl,7
call show_str
clock_input_start:mov dh,8
mov dl,43
call getstr
mov ax,0
call check_clock_datetime
cmp ax,0
je clock_input_start
call get_clock_datetime
call set_clock_datetime
pop ds
pop si
pop ax
pop bx
pop cx
pop dx
ret
reset_pc:push bx
mov bx,0FFFFh
push bx
mov bx,0
push bx
retf
pop bx
ret
floppyio:push ax
push cx
push dx
add ah,2
push ax
mov ax,dx
mov dx,0
mov cx,1440
div cx
push ax
mov ax,dx
mov dl,18
div dl
inc ah
mov ch,al
mov cl,ah
pop ax
mov dh,al
mov dl,0
pop ax
int 13h
pop dx
pop cx
pop ax
ret
start_system:push dx
push cx
push bx
push ax
push si
push di
push ds
push es
mov bx,cs
mov ds,bx
mov es,bx
mov si,offset copy_start - offset boot_main + 7c00h
mov di,8200h
mov cx,offset copy_end-offset copy_start
cld
rep movsb
mov bx,8200h
push bx
ret
copy_start:mov ax,0
mov es,ax
mov bx,7c00h
mov ah,2
mov al,1
mov ch,0
mov cl,1
mov dh,0
mov dl,80h
int 13h
mov bx,0
push bx
mov bx,7c00h
push bx
retf
copy_end:nop
pop es
pop ds
pop di
pop si
pop ax
pop bx
pop cx
pop dx
ret
code ends
end start
对于已经按本书的要求完成了前面所有学习内容的学习者，
如果有兴趣用汇编语言对一些相关问题进行一下深入的研究，可以学习本部分内容。
在这部分内容中，本书将启示我们如何进行独立研究和深度思考。同时使我们：
（1）认识到汇编语言对于深入理解其他领域知识的重要性。
（2）对前面所学习的汇编语言知识进行融会。
（3）对用研究的方法进行学习进行体验。
下面看一下我们要研究的问题。
（1）人们用C语言编程时都要用到变量。
比如，程序：打印从'a'到'h'的8个字符。
main()
{
    int n, ch;
    ch = 'a’;
    for(n = 0; n < 8; n++)
    {
        printf("%c\n",ch+n);
    }
}
（2）C语言规定，用户写的C语言程序都要从main函数开始运行，因此main函数又称为主函数。
（3）printf函数可以接收的参数数量不定，我们对此司空见惯，比如：
main()
{
    printf("hello world!");
    printf("%d + %d =%d", 1, 2, 1 + 2);
}
注意，上面提到了几个关键词：都要用、规定、司空见惯，在看下面的内容的时候再仔细阅读上面的文字，找到这几个关键词。
思考下面几个问题：
（1）人们用C语言编程时都要用变量，我们就非用不可吗？
（2）C语言规定用户写的程序从main函数开始，我们就非要用main函数吗？
（3）printf函数可以接收不定数量的参数司空见惯，我们就不怀疑了吗？
我们把问题再精简一下，使其变得更本质：
（1）都在用，我们就非得用吗？
2）规定了，我们就只知道遵守吗？
3）司空见惯，我们就不怀疑了吗？
在许多领域内，我们被这些所谓都在用的，规定了的，司空见惯的，蒙蔽了多久呢？
如果我们被这些蒙蔽，那么，真正蒙蔽我们的是这些，还是我们自己？
现在我们提出要研究的3个问题：
（1）用C语言编程可以不用变量吗？
（2）用C语言编程可以不用main函数吗？
（3）我们能写一个printf函数吗？
注意：
（1）我们使用TC 2.0编译器来进行研究，因为这是国内大多数学习者都会使用的c语言编译器。
（2）我们的研究所用的基础知识大都是在前面汇编语言的课程中学习过的。只有极少数知识是我们前面的课程中没有讲解的，
但有前面汇编语言的基础，这些知识学习者都可以通过自己学习和研究掌握。
（3）这部分内容主要是启发学习者进行独立研究和深度思考，一定要注意这一点，相应地调整自己的学习思想。
我们要对C语言进行深入的研究，就必须从准备一个清晰的C语言开发环境开始。
我们看一下TC 2.0的安装目录，有很多的文件和子目录，子目录下面还有很多程序和文件。这些程序和文件是我们现在都需要的吗？
这些程序和文件会对我们研究的问题造成影响吗？问题是：这么多程序和文件混合在一起，
如果其中有些程序和文件对我们研究的问题有影响，那么，我们容易判断出影响来自哪些程序和文件吗？
为了研究的过程清晰明了，我们的原则是：
（1）我们只运行解决当前问题所要用的，我们已知的程序；
（2）所有我们已知的程序在解决我们的问题的运行过程中，需要用到的程序和文件，也都是我们已知的。
这样，我们就可以清晰地知道，哪些程序和文件是用于解决哪些问题的。
这个原则决定了，我们在研究实践中，需要一步步地把我们已知的程序和文件与其他的程序和文件分离开来。
按照上面的原则，请完成以下试验。
（1）在d盘建立一个目录（在Windows中称为文件夹）tc2.0，在DOS环境中，方法如下：d:\md tc2.0
然后将tc2.0的所有文件都拷贝在d:\tc2.0目录下。
（2）在c盘建立一个目录minic。在DOS环境中，方法如下：c:\md minic
这个目录用来存放我们已知的解决问题要用的程序和文件。
注意，一般的产品软件系统，都可以通过设置搜索路径的方式让系统提供的程序可以在相关文件不在相同目录的情况下，
也可以找到相关的文件。这个做法可能会导致类似以下的情况：
我们在把一个程序拷贝到一个空的目录后，这个目录下只有这一个程序，然后我们运行它，它可以正确运行，
我们就认为这个程序在运行过程中不需要别的文件。但是很可能它在运行过程中使用了别的文件，
它不是在当前目录下，而是通过系统设置的搜索路径找到的相关文件。
如上情况的出现会影响我们对一个程序运行过程中使用哪些文件的掌握，而对一些问题产生错误的判断。
我们可以用两种方法解决这个问题
①不让设置的默认路径指向真的包含相关文件的目录；
②把我们所要研究的系统的所有文件都拷贝到一个不可能是系统设置的搜索路径的目录中。
我们上面用的是第二种方法，将tc2.0的所有文件，都拷贝到d:\tc2.0目录下，
因为这个目录基本上不可能被tc2.0设置成为相关文件的搜索路径。这样我们从这个目录拷贝到其他目录（比如c:\minic）的程序，
在运行过程中如果需要使用tc2.0中的相关文件，就会出现文件找不到的错误，我们根据提示信息，就可以知道找不到的是哪个文件，
也就可能分析出这个文件是干什么用的。
（3）把我们（国内大多数学习者）都已知的tc.exe（集成开发环境）拷贝到c:\minic下：c:\minic\copy d:\tc2.0\tc.exe
（4）运行tc.exe：c:\minic\tc
用tc环境中的菜单项"Options"中的"Directories"选项，对tc的工作路径进行设置，将所有路径都清空，即都设置为当前路径。
然后用"Save options"选项保存设置。
（5）在tc.exe环境中编辑程序simple.c，保存到c:\minic下。
程序simple.c：
main()
{
    printf("hello world!\n");
}
（6）用tc环境中菜单项"Compile"中的"Compile to OBJ"，对程序simple.c进行编译。
看看显示出的提示信息，编译成功了吗？用菜单项"File"中"Quit"（或按Alt-X）退出tc环境，在c:\minic下查找simple.obj.
（7）用如下的方法运行tc.exe:c:\minic\tc simple因为simple.obj文件已经生成，
所以我们用tc环境中菜单项"Compile"中的"Link EXE file"，将simple.obj连接为simple.exe
进行连接后，Message窗口显示出提示信息："Unable to open input file 'C0S.OBJ"
看看显示出的提示信息，连接成功了吗？在c:\minic下查找simple.exe，能找到吗？
（8）可以看出，tc进行连接要使用相关文件，但是找不到，所以出错。
为解决这个问题，需要从d:\tc2.0目录和子目录下查找到相关文件，将其拷贝到c:\minic下。
当然，也可以用tc环境中的Options菜单项下的相关功能设置相关文件（如obj文件）所在的目录的方法，
解决找不到.obj文件和.lib文件的问题，但是，为了让学习者能够对此时需要哪些文件，以及这些文件在什么目录下，
如何找到这些文件等问题有清晰的感性认识，这里我们不用这样的方法。
如果在TC 2.0安装目录下和各个子目录下都找不到所需的.obj文件和.lib文件，则需要重新安装一套完整的TC 2.0.
想办法把所有tc.exe对程序simple.obj进行连接生成.exe文件必须用到的相关文件都找到，拷贝到c:\minic。
注意，找的是必须用到的。
9）用c:\minic\tc.exe对simple.c进行编译，连接，生成simple.exe.
TC进行连接需要如下的文件：
C0S.OBJ
CS.LIB
EMU.LIB
GRAPHICS.LIB
MATHS.LIB
我们用什么，不用什么，都要看我们要解决什么问题。搞清楚问题，就知道了我们的需要，然后我们就不会拘泥于一种方法，
因为可能有很多方法都可以解决我们要解决的问题。
我们为什么必须用变量？因为我们在编程时必须存储数据。
那么如果可以用别的方法存储数据，我们就可以不必因此目的而使用变量。
用什么方法来存储数据呢？在学习汇编语言时，我们如何存储数据？我们把数据存储在寄存器和内存空间中。
那么，在C语言中如何使用寄存器和内存空间呢？
在本次研究试验中，我们研究一下使用寄存器的问题。
在汇编语言中，要使用寄存器，必须要给出寄存器名，在C语言中也是如此。
tc2.0提供的编译器支持如下寄存器名：
"_AX"，"_BX"，"_CX"，"_DX"，"_SI"，"_DI"，"_SP"
“_BP"，"_CS"，"_DS"，"_SS"，"_ES"，"_AL"，"_AH"
“_BL"，"_BH"，"_CL"，"_CH"，"_DL"，"_DH"
从这些寄存器名称，可以看出它们对应的是哪个寄存器。
用c:\minic目录下的tc.exe完成以下试验。
（1）编一个程序ur1.c。
main()
{
    _AX = 1;
    _BX = 1;
    _CX = 2;
    _AX = _BX + _CX;
    _AH = _BL + _CL;
    _AL = _BH + _CH;
}
把这个程序保存在c:\minic下，然后，编译，连接，生成ur1.exe.
（2）用Debug加载ur1.exe，用u命令查看ur1.c编译后的机器码和汇编代码。
思考：main函数的代码在什么段中？用Debug怎样找到ur1.exe中main函数的代码？
main函数的代码在CS段中，需要知道main函数的偏移地址才能找到main函数的代码。
printf("%x\n", main);
（3）用下面的方法打印出ur1.exe被加载运行时，main函数在代码段中的偏移地址：
main()
{
    printf("%x\n", main);
}
"%x”指的是按照十六进制格式打印。
思考：为什么这个程序能够打印出main函数在代码段中的偏移地址？
这里的printf打印了main函数的入口地址，也即main函数在代码段中的偏移地址。
main是一个标号
（4）用Debug加载ur1.exe，根据上面打印出的main函数的偏移地址，用u命令察看main函数的汇编代码。
仔细找到ur1.c中每条C语句对应的汇编代码。
main（）
注意：在这里，对于main函数汇编代码开始处的"push bp mov bp,sp"和结尾处的"pop bp"，
这里只理解到：这是C编译器安排的为函数中可能使用到bp寄存器而设置的，就可以了。
（5）通过main函数后面有ret指令，我们可以设想：C语言将函数实现为汇编语言中的子程序。
研究下面程序的汇编代码，验证我们的设想。经过验证，C语言确实将函数实现为汇编语言中的子程序。
程序ur2.c：
void f(void);
main()
{
    _AX = 1;
    _BX = 1;
    _CX = 2;
    f();
}
void f(void)
{
    _AX = _BX + _CX;
}
寄存器只有十几个，但是内存空间可以很大。那么在c语言里如何使用内存空间呢？
其实，寄存器也好，内存空间也好，都是存储空间，对于存储空间来说，要使用它们
一般都需要给出两个信息：①指明是存储空间所在、是哪个的信息；②指明存储空间有多大的类型信息。
对于寄存器来说，就需要给出寄存器的名称，寄存器的名称中也包含了它们的类型信息。
对于内存空间来说，就需要给出地址（准确的说，是内存空间首地址）和空间存储数据的类型。
我们知道，在C语言里，用指针型数据来表示内存空间的地址和空间存储数据的类型。
比如要向偏移地址为2000h、存储一个字节的内存空间写入一个字符a，我们用如下的方法：
*(char*)0x2000='a'；第一个"*”表示要访问的是一个内存空间；
"0x2000"是一个数值（0x表示十六进制），"(char*)"里面的"*”指明了这个数值表示一个内存空间的地址，
"char”指明了这个地址是存储char型数据的内存空间的地址。
当然也可以用给出段地址和偏移地址的方法访问内存空间，比如我们要向地址为2000：0、存储一个字节的内存空间写入字符'a'，
如下：
*(char far*)0x20000000='a'；
“far”指明内存空间的地址是段地址和偏移地址，“0x20000000”中的“0x2000”给出了段地址，“0000”给出了偏移地址。
不过这样直接用地址访问内存空间的方式是不安全的，因为，如果这些空间并不是分配给我们的程序使用的空间，
这样做就可能改变了别的程序的代码或数据，引起错误。
我们可以按照上面的例子，举一反三，对以前学过的C语言相关知识进行深入的理解。
用c:\minic目录下的tc.exe，完成下面的试验。
（1）编一个程序um1.c：
main()
{
    *(char *)0x2000 = 'a';
    *(int *)0x2000 = 0xf;
    *(char far *)0x20001000 = 'a';
    _AX = 0x2000;
    *(char *)_AX = 'b';
    _BX = 0x1000;
    *(char *)(_BX + _BX) = 'a';
    *(char far *)(0x20001000 + _BX) = *(char *)_AX;
}
把um1.c保存在c\minic下，编译，连接生成um1.exe。
然后用Debug加载um1.exe，对main函数的汇编代码进行分析，
找到每条C语句对应的汇编代码；对main函数进行单步跟踪，察看相关内存单元的内容。
（2）编一个程序，用一条C语句实现在屏幕的中间显示一个绿色的字符“a”。
main()
{
    *(int far *)0xb80007d0 = 0x0261;
}
（3）分析下面程序中所有函数的汇编代码，思考相关的问题。
int a1, a2, a3;
void f(void);
main()
{
    int b1, b2, b3;
    a1 = 0xa1;
    a2 = 0xa2;
    a3 = 0xa3;
    b1 = 0xb1;
    b2 = 0xb2;
    b3 = 0xb3;
}
void f(void)
{
    int c1, c2, c3;
    a1 = 0x0fa1;
    a2 = 0x0fa2;
    a3 = 0x0fa3;
    c1 = 0xc1;
    c2 = 0xc2;
    c3 = 0xc3;
}
问题：C语言将全局变量存放在哪里？将局部变量存放在哪里？每个函数开头的“push bp mov bp sp”有何含义？
C语言将全局变量存放在数据段中，将局部变量存放在栈段中。
局部变量放在了栈段中，使用sp的话，假如程序中有入栈出栈的操作，栈顶指针变了，就找不到局部变量了。
使用BP这个寄存器，在程序的开始把Sp的值赋给BP，然后，改变SP的值，把局部变量的位置留出来。
这时，我们可以方便的用BP找到局部变量。函数返回时，BP的值又赋值给SP，函数内的局部变量就消失了。
这也就是为什么C语言中局部变量的值只在函数内有效的原因。
（4）分析下面程序的汇编代码，思考相关的问题。
int f(void);
int a, b, ab;
main()
{
    int c;
    c = f();
}
int f(void)
{
    ab = a + b;
    return ab;
}
问题：C语言将函数的返回值存放在哪里？
C语言将返回值存放在通用寄存器AX中
（5）下面的程序向安全的内存空间写入从“a”到“h”的8个字符，理解程序的含义，深入理解相关的知识。
（注意：请自己学习、研究malloc函数的用法）
#define Buffer ((char *)*(int far *)0x02000000)
main()
{
    Buffer = (char *)malloc(20);
    Buffer[10] = 0;
    while(Buffer[10] != 8)
    {
        Buffer[Buffer[10]] = 'a' + Buffer[10];
        Buffer[10]++;
    }
    free(Buffer);
}
AX中存放由malloc申请内存返回的首地址。
段地址0200:偏移地址0000的内存空间存放由malloc申请内存返回的首地址。
程序通过malloc分配大小为20字节的空间给并将其地址存入Buffer所指向的空间即0200:0000中。
随后，通过一个while循环将这20个字节的空间的0-7个字节分别赋予对应的字符，并且用第10个字节计数。
在本研究试验中，我们看看如何不用main函数，编写可以正确运行的程序。我们用一个简单的程序来进行研究。
程序f.c：
f()
{
    *(char far *)(0xb8000000 + 160 * 10 + 80) = 'a';
    *(char far *)(0xb8000000 + 160 * 10 + 81) = 2;
}
下面，我们研究如何用tc.exe对f.c进行编译，连接，生成可正确运行的f.exe。
我们用c:\minic下的tc.exe完成以下试验。
（1）把程序f.c保存在c:\minic下，对其进行编译，连接。思考相关的问题。
问题：
①编译和连接哪个环节会出问题？
②显示出的错误信息是什么？
③这个错误信息可能与哪个文件相关？
回答
①连接环节出现了错误
②在C0S模块中未定义的标号_main
③和C0S.OBJ这个文件有关
（2）用学习汇编语言时使用的link.exe对tc.exe生成的f.obj文件进行连接，生成f.exe。用Debug加载f.exe，察看整个程序的汇编代码。思考相关的问题。
问题：
①f.exe的程序代码总共有多少字节？001Dh
②f.exe的程序能正确返回吗？不能正确的返回
③f函数的偏移地址是多少？偏移地址为0
（3）写一个程序m.c。
main()
{
    *(char far *)(0xb8000000 + 160 * 10 + 80) = 'a';
    *(char far *)(0xb8000000 + 160 * 10 + 81) = 2;
}
用tc.exe对m.c进行编译，连接，生成m.exe，用Debug察看m.exe整个程序的汇编代码。思考相关的问题。
问题：
①m.exe的程序代码总共有多少字节？0EC9h
②m.exe能正确返回吗？能正确返回
③m.exe程序中的main函数和f.exe中的f函数的汇编代码有何不同？没有不同
（4）用Debug对m.exe 进行跟踪：①找到对main函数进行调用的指令的地址；②找到整个程序返回的指令。
注意：使用g命令和p命令。
cs:011a调用main函数cs:01fa
cs:0156返回dos系统ah赋值为4c,调用int 21h
（5）思考如下几个问题：
①对main函数调用的指令和程序返回的指令是哪里来的？
②没有main函数时，出现的错误信息里有和“c0s”相关的信息；
而前面在搭建开发环境时，没有c0s.obj文件tc.exe就无法对程序进行连接。
是不是tc.exe把c0s.obj和用户程序的.obj文件一起进行连接生成.exe文件？
③对用户程序的main函数进行调用的指令和程序返回的指令是否就来自c0s.obj文件？
④我们如何看到c0s.obj文件中的程序代码呢？
⑤c0s.obj文件里有我们设想的代码吗？
回答
①对main函数调用的指令和程序返回的指令是来自于其他的文件而非编译后的文件。
②是的
③是的
④用LINK.EXE对其进行连接即可
⑤有
（6）用link.exe对c:\minic目录下的c0s.obj进行连接，生成c0s.exe。
用Debug分别察看c0s.exe和m.exe的汇编代码。注意：从头开始察看，两个文件中的程序代码有何相同之处？
两个程序的代码基本相同，且都是在011A调用了CALL指令，在0156调用了INT 21中断
（7）用Debug找到m.exe中调用main函数的call指令的偏移地址，从这个偏移地址开始向后察看10条指令；
然后用Debug加载c0s.exe，从相同的偏移地址开始向后察看10条指令。对两处的指令进行对比。
M.EXE和C0S.EXE在偏移地址011A之后的10条指令除了跳转指令的跳转地址有所不同外几乎完全相同。
（8）从上我们可以看出，tc.exe把c0s.obj和用户.obj文件一同进行连接，生成.exe文件。
按照这个方法生成的.exe文件中的程序的运行过程如下。
①c0s.obj里的程序先运行，进行相关的初始化，比如，申请资源、设置DS、SS等寄存器；
②c0s.obj里的程序调用main函数，从此用户程序开始运行；
③用户程序从main函数返回到c0s.obj的程序中；
④c0s.obj的程序接着运行，进行相关的资源释放，环境恢复等工作；
⑤c0s.obj的程序调用DOS的int 21h例程的4ch号功能，程序返回。
看来，C程序必须从main函数开始，是C语言的规定，这个规定不是在编译时保证的（tc.exe对f.c的编译是可以通过的），
也不是连接的时候保证的（虽然，tc.exe文件对f.obj文件不能连接成fexe，但link.exe却可以），而是用如下的机制保证的。
首先，C开发系统提供了用户写的应用程序正确运行所必须的初始化和程序返回等相关程序，
这些程序存放在相关的.obj文件（比如，c0s.obj）中。
其次，需要将这些文件和用户.obj文件一起进行连接，才能生成可正确运行的.exe文件。
第三，连接在用户.obj文件前面的由C语言开发系统提供的.obj文件里的程序要对main 函数进行调用。
基于这种机制，我们只要改写c0s.obj，让它调用其他函数，编程时就可以不写main函数了。
下面，我们用汇编语言编一个程序c0s.asm，然后把它编译为c0s.obj，替代c:\minic目录下的c0s.obj。
程序c0s.asm：
assume cs:code
data segment
db 128 dup (0)
data ends
code segment
start:mov ax,data
mov ds,ax
mov ss,ax
mov sp,128
call s
mov ax,4c00h
int 21h
s:
code ends
end start
用masm.exe对c0s.asm进行编译，生成c0s.obj，把这个c0s.obj复制到c:\minic目录下覆盖由tc2.0提供的c0s.obj。
（9）在c:\minic目录下，用tc.exe将f.c重新进行编译，连接，生成f.exe。这次能通过连接吗？
fexe可以正确运行吗？用Debug察看f.exe的汇编代码。
能通过连接，可以正确运行
（10）在新的c0s.obj的基础上，写一个新的f.c，向安全的内存空间写入从“a”到“h”的8个字符。分析、理解f.c。
程序f.c：
#define Buffer ((char *)*(int far *)0x02000000)
f()
{
    Buffer = 0;
    Buffer[10] = 0;
    while(Buffer[10] != 8)
    {
        Buffer[Buffer[10]] = 'a' + Buffer[10];
        Buffer[10]++;
    }
}
注意，完成上面的相关试验后，把c:\minic目录下的c0s.obj文件恢复为tc2.0提供的c0s.obj文件。
用c:\minic下的tc.exe完成下面的试验。
（1）写一个程序a.c：
void showchar(char a, int b);
main()
{
    showchar('a', 2);
}
void showchar(char a, int b)
{
    *(char far *)(0xb8000000 + 160 * 10 + 80) = a;
    *(char far *)(0xb8000000 + 160 * 10 + 81) = b;
}
用tc.exe对a.c进行编译，连接，生成a.exe。用Debug加载a.exe，对函数的汇编代码进行分析。
解答这两个问题：main函数是如何给showchar传递参数的？showchar是如何接收参数的？
main函数通过push操作将对应的参数压栈来给showchar传递参数，并且在函数返回后通过pop操作将参数退栈。
showchar通过SS:BP寻址在栈中取得对应的参数。
（2）写一个程序b.c：
void showchar(int, int, ...);
main()
{
    showchar(8, 2, 'a', 'b’,'c','d','e','f','g','h');
}
void showchar(int n, int color, ...)
{
    int a;
    for(a = 0; a != n; a++)
    {
        *(char far *)(0xb8000000 + 160 * 10 + 80 + a + a) = *(int *)(_BP + 8 + a + a);
        *(char far *)(0xb8000000 + 160 * 10 + 81 + a + a) = color;
    }
}
分析程序b.c，深入理解相关的知识。
思考：showchar函数是如何知道要显示多少个字符的？printf函数是如何知道有多少个参数的？
待显示字符的个数为showchar函数的第一个参数，showchar函数以此得知要显示的字符的个数。
 通过对printf的一个参数所指向的字符串的分析，printf函数以此得知参数的个数。
（3）实现一个简单的printf函数，只需要支持“%c、%d”即可。
测试通过的完整程序如下
void myprintf(char *, ...);
main()
{
    myprintf("%c %c %d %d %d %c abc %%d", 'a', 'b', 'c', 'e', -12345, 48, 0);
}
void myprintf(char *str, ...)
{
    int i;
    int arg_pos;
    int dis_pos;
    i = 0;
    arg_pos = 0;
    dis_pos = 1600;
    while(str[i] != 0)
    {
        if(str[i] == '%')
        {
            if(str[i + 1] == 'd')
            {
                int length;
                int flag;
                int num;
                int j;
                int k;
                length = 0;
                flag = 0;
                num = *((int *)(_BP + 6 + arg_pos));
                if(num == 0)
                {
                    *(char far *)(0xb8000000 + dis_pos) = '0';
                    arg_pos += 2;
                    dis_pos += 2;
                    i += 2;
                }
                else
                {
                    if(num < 0)
                    {
                        flag = 1;
                        num *= -1;
                    }
                    j = num;
                    while(j != 0)
                    {
                        j = j / 10;
                        length++;
                    }
                    j = num;
                    k = dis_pos;
                    k += ((length + flag - 1) * 2);
                    while(j != 0)
                    {
                        *(char far *)(0xb8000000 + k) = (j % 10 + 48);
                        k -= 2;
                        j = j / 10;
                    }
                    if(flag == 1)
                    {
                        *(char far *)(0xb8000000 + k) = '-';
                        k -= 2;
                    }
                    arg_pos += 2;
                    dis_pos += ((length + flag) * 2);
                    i += 2;
                }
            }
            else if(str[i + 1] == 'c')
            {
                *(char far *)(0xb8000000 + dis_pos) = *((char *)(_BP + 6 + arg_pos));
                arg_pos += 2;
                dis_pos += 2;
                i += 2;
            }
            else
            {
                *(char far *)(0xb8000000 + dis_pos) = str[i];
                dis_pos += 2;
                i++;
            }
        }
        else
        {
            *(char far *)(0xb8000000 + dis_pos) = str[i];
            dis_pos += 2;
            i++;
        }
    }
}
Intel80386微处理器，它可以在以下3个模式下工作。
（1）实模式：工作方式相当于一个8086。
（2）保护模式：提供支持多任务环境的工作方式，建立保护机制（这与VAX等小型机类似）。
（3）虚拟8086模式：可从保护模式切换至其中的一种8086工作方式。
这种方式的提供使用户可以方便地在保护模式下运行一个或多个原8086程序。
以后的各代微处理器都提供了上述3种工作模式。
任何一台使用Intel系列CPU的PC机只要一开机，CPU就工作在实模式下。
如果你的机器装的是DOS，那么在DOS加载后CPU仍以实模式工作。
如果你的机器装的是Windows，那么Windows加载后，
将由Windows将CPU切换到保护模式下工作，
因为Windows是多任务系统，它必须在保护模式下运行。
如果你在Windows中运行一个DOS下的程序，
那么Windows将CPU切换到虚拟8086模式下运行该程序。
或者是这样，你点击开始菜单在程序项中进入MS-DOS方式，
这时，Windows也将CPU切换到虚拟8086模式下运行。

80x86汇编语言程序设计教程 杨季文 9885-74726行
目前，国内最广泛使用的PC系列机（包括兼容机），都以Intel的80×86系列微处理器或者兼容的微处理器为CPU。
在Intel的80x86家族中，16位的8086/8088是基础，实现了以分段方式管理存储器；
32位的80386是高档微处理器的里程碑，实现了支持多任务的保护工作方式；
基于MMX技术的Pentium是新一代的微处理器，实现了对多媒体处理的支持。
本书以8086/8088为基础，以80386为重点，面向Pentium等新一代微处理器，
讲解汇编语言程序设计的一般概念、基本技术和常用技巧，介绍宏和模块化程序设计的技术方法，
讲解保护方式编程的相关概念、编程技术及实现细节。
本书分三个部分，共12章。
第一部分是基础部分。
第1章介绍汇编语言的特点和其他基本概念。
第2、第3章以8086/8088为背景，
简要介绍8086/8088寻址方式、指令系统和汇编语言的常用伪指令语句后，讲解如何利用汇编语言实现程序的基本结构。
第4章详细讲解了子程序的设计和如何调用DOS提供的子程序。
第5章以PC及其兼容机为硬件平台，介绍输入/输出和中断等概念，讲解如何利用汇编语言编写BIOS程序和调用BIOS程序。
第6章以DOS为软件平台，讲解如何利用汇编语言编写小型应用程序。
第7章以MASM和TASM为汇编器，介绍宏和条件汇编等汇编语言的高级技术。
第8章介绍模块化程序设计技术以及与高级语言的混合编程。
第二部分是提高部分。
第9章介绍实方式下的80386及其编程。
第10章讲解保护方式下的80386及其编程，该章内容十分丰富。
第11章介绍80486和Pentium程序设计基础。
第三部分是上机实验指导，安排为第12章，应在上机实验前先阅读了解该章内容。
本书的第一部分适合初学者，可作为学习汇编语言程序设计的教材。
本书的第二部分适合已基本掌握8086/8088汇编语言的程序员，可作为学习保护方式编程技术的教材或参考书，
也可作为其他人员了解高档微处理器和保护方式编程技术细节的参考书，
还可作为程序员透彻地了解Windows程序设计技术的参考书。

第1章绪论
本章先介绍汇编语言的一些基本概念，然后介绍数据的表示和类型，最后简单介绍了Intel的x86家族历代微处理。
1.1汇编语言概述
尽管在使用汇编语言进行程序设计之前，完全理解汇编语言的特点有困难，
但了解汇编语言的特点对学习汇编语言程序设计是有益的。
本节先说明汇编语言的内容，再介绍汇编语言的特点和使用汇编语言的场合。
1.1.1汇编语言
1.机器语言
CPU能直接识别并遵照执行的指令称为机器指令。机器指令在形式上表现为二进制编码。
机器指令一般由操作码和操作数两部分构成，操作码在前，操作数在后。
操作码指出要进行的操作或运算，如加、减、传送等。操作数指出参与操作或运算的对象，也指出操作或运算结果存放的位置，
如CPU的寄存器、存储单元和数据等。
机器指令与CPU有着密切的关系。通常，CPU的种类不同，对应的机器指令也就不同。
不同型号CPU的指令集往往有较大的差异。但同一个系列CPU的指令集常常具有良好的向上兼容性，
也即下一代CPU的指令集是上一代CPU指令集的超集。例如，Intel 80386指令集包含了8086指令集。
机器语言是用二进制编码的机器指令的集合及一组使用机器指令的规则。
它是CPU能直接识别的唯一语言。只有用机器语言描述的程序，CPU才能直接执行。
用机器语言描述的程序称为目的程序或目标程序。
为了阅读和书写方便，常用十六进制形式或八进制形式表示二进制编码。
例如，我们用Intel 8086指令写一个两数相加的程序片段。
具体要求是把偏移2200H存储单元中的数与偏移2201H存储单元中的数相加，将它们的和送入偏移2202H存储单元。
完成这一工作的程序片段包含三条机器指令，用十六进制形式表示如下：
A0 00 20
02 06 01 20
A2 02 20
几乎没有人能直接看出该程序片段的功能，原因是程序员难以掌握机器语言。
因此，程序员难以用机器语言写程序，更难写出健壮的程序；用机器语言编制出的程序也不易为人们理解、记忆和交流。
所以，只是在早期或不得已时才用机器语言写程序，现在几乎没有人用机器语言写程序了。
机器语言有如下缺点：机器语言不能用人们熟悉的形式来描述计算机要执行的任务；
用机器语言编写程序十分繁难，极易出错；一旦有错，也很难发现，也即调试困难。
2.汇编语言
为了克服机器语言的上述缺点，人们采用便于记忆、并能描述指令功能的符号来表示指令的操作码。
这些符号被称为指令助记符。助记符一般是说明指令功能的英语词汇或者词汇的缩写。
同时也用符号表示操作数，如CPU的寄存器、存储单元地址等。
用指令助记符、地址符号等符号表示的指令称为汇编格式指令。
汇编语言是汇编格式指令、伪指令的集合及其表示、使用这些指令的一组规则。
伪指令的概念留待以后介绍。用汇编语言书写的程序称为汇编语言程序，或称为汇编语言源程序，或简称为源程序。
利用汇编语言，上述两数相加的程序片段可表示如下：
MOV AL,VAR1
ADD AL,VAR2
MOV VAR3,AL
显然，汇编格式指令比二进制编码的机器指令要容易掌握得多，
用汇编语言编写的程序要比用机器语言编写的程序容易理解、调试和维护
3.汇编程序
由于CPU能直接识别的唯一语言是机器语言，
所以用汇编语言编写的源程序必须被翻译成用机器语言表示的目标程序后才能由CPU执行。
把汇编语言源程序翻译成目标程序的过程称为汇编。完成汇编任务的程序叫做汇编程序。汇编过程如图1.1所示。
1.1.2汇编语言的特点
由于汇编语言使用指令助记符和符号地址，所以它要比机器语言容易掌握得多。与高级语言相比较，汇编语言有如下特点。
1.汇编语言与机器关系密切
因为汇编格式指令是机器指令的符号表示，所以汇编格式指令与机器有着密切的关系，
因此汇编语言也与机器有着密切的关系，确切地说汇编语言与机器所带的CPU有着十分密切的关系。
对于各种不同类型的CPU，要使用各种不同的汇编语言。于是，对于各种不同类型的CPU，也就有各种不同的汇编程序。
由于汇编语言与机器关系十分密切，所以汇编语言源程序与高级语言源程序相比，它的通用性和可移植性要差得多。
但通过汇编语言可最直接和最有效地控制机器，这常常是大多数高级语言难以做到的。
2.汇编语言程序效率高
用汇编语言编写的源程序在汇编后所得的目标程序效率高。
这种目标程序的高效率反映在时间和空间两个方面：其一是运行速度快；其二是目标程序短。
在采用相同算法的前提下，任何高级语言程序在这两方面的效率都不如汇编语言程序，许多情况下更是远远不及。
汇编语言程序能获得“时空”高效率的主要原因是：构成汇编语言主体的汇编格式指令是机器指令的符号表示，
每一条汇编格式指令都是所对应的某条机器指令的“化身”；
另一个重要原因是汇编语言程序能直接并充分利用机器硬件系统的许多特性。高级语言程序在上述两点上要逊色得多。
3.编写汇编语言源程序繁琐
编写汇编语言源程序要比编写高级语言源程序繁琐得多。
汇编语言是面向机器的语言，高级语言是面向过程或面向目标、对象的语言。
如下两点突出表现了汇编语言的这一特性：
作为机器指令符号化的每一条汇编格式指令所能完成的操作极为有限。
例如，Z80指令集中没有乘法指令，8086指令集中没有能够同时完成两次算术运算的指令。
程序员在利用汇编语言编写程序时，必须考虑包括寄存器、存储单元和寻址方式在内的几乎所有细节问题。
例如：指令执行对标志的影响，堆栈设置的位置等。在使用高级语言编写程序时，程序员不会遇到这些琐碎却重要的问题。
4.汇编语言程序调试困难
调试汇编语言程序往往要比调试高级语言程序困难。
汇编格式指令的功能有限和程序员要注意太多的细节问题是造成这种困难的两个客观原因；
汇编语言提供给了程序员最大的“舞台”，而程序员往往为了追求“时空”上的高效率而不顾程序的结构，
这是造成调试困难的主观原因。
1.1.3恰当地使用汇编语言
1.汇编语言的优缺点
为了恰当地使用汇编语言，我们先明确一下它的优缺点。
汇编语言的主要优点是利用它可能编写出在“时空”两个方面最有效率的程序。另外，通过它可最直接和最有效地操纵机器硬件系统。
汇编语言的主要缺点是它面向机器，与机器关系密切，它要求程序员比较熟悉机器硬件系统，要考虑许多细节问题，
最终导致程序员编写程序繁琐；调试程序困难；维护、交流和移植程序更困难。
正是由于汇编语言与机器关系密切，才使汇编语言具有其他高级语言所不具备的上述优点和缺点。
为了利用汇编语言的优点，必须付出相应的代价。但汇编语言的每一个优点常常闪耀出诱人的光芒，使人们勇敢地面对它的缺点。
2.使用汇编语言的场合
根据汇编语言的优缺点，我们要恰当地使用汇编语言，即尽可能地“扬长避短”。
是否利用汇编语言编写程序，要看具体的应用场合，要充分考虑到软件的开发时间和软件的质量等诸多方面的因素。
我们认为下列应用场合，可考虑使用汇编语言编写程序。
（1）对软件的执行时间或存储容量有较高要求的场合。
例如：系统程序的关键核心，智能化仪器仪表的控制系统，实时控制系统等。
（2）需要提高大型软件性能的场合。通常把大型软件中执行频率高的子程序（过程）用汇编语言编写，
然后把它们与其他程序一起连接。
（3）软件与硬件关系密切，软件要有直接和有效控制硬件的场合。如设备驱动程序等。
（4）没有合适的高级语言的场合。
3.适度地追求“时空”效率
在用汇编语言编写程序时，追求“时空”效率要适度。
在编写汇编语言程序时，我们要尽量利用最恰当的指令，以便节约一个字节或节省几个机器周期。
但时至今日，计算机硬件系统的整体性能已极大地提高，
所以，除非不得已，不要为节约少量字节或机器周期而影响程序的结构性、健壮性和可读性等。
要在确保汇编语言程序上述性能良好的前提下追求“时空”性能。
1.2数据的表示和类型
熟悉数据在计算机内的表示形式是掌握汇编语言程序设计的关键之一。本节简单介绍数据的表示形式和类型。
计算机中存储信息的最小单位称为位，在绝大多数系统中它只能表示两种状态。这两种状态可分别代表0和1。
计算机系统内部采用二进制表示数值数据，也采用二进制编码表示非数值数据和指令，其主要原因就在于此。
1.2.1数值数据的表示
所谓数值数据就是数。这里仅介绍定点整数的有关内容。
1.数的二进制表示
尽管日常生活中大多采用十进制计数，但在计算机内，数却大多采用二进制表示。
某个二进制数所表示的数值用十进制数来衡量时，可利用如下按权相加的方法计算得到：
在书写时，为了与十进制数相区别，通常在二进制数后加一个字母B。
2.有符号数的补码表示
为了方便地表示负数和容易地实现减法操作，有符号数采用补码形式表示。
所以，有符号数二进制表示的最高位是符号位，0表示正数，1表示负数。
正数数值的补码形式用二进制表示。为得到一个负数数值的补码形式，方法可以是先得出该负数所对应正数的二进制形式，
然后使正数的每一个二进制位变反，最后再将变反的结果加1。
3.符号扩展
常常需要把一个n位二进制数扩展成m位二进制数（m>n）。当要扩展的数是无符号数时，只要在最高位前扩展（m-n）个0。
如果要扩展的数是有符号数，并且采用补码形式表示，那么，就要进行符号位的扩展。
例如，21的8位二进制和16位的二进制补码如下：
                00010101          8位
0000000000010101         16位
例如，-3的8位二进制补码和16位二进制补码如不：
                11111101      8位
1111111111111101     16位
4.数值数据的表示范围
n位二进制数能够表示的无符号整数的范围是：
采用补码形式表示有符号数。那么n位二进制数能够表示的有符号整数的范围是：
所以，如果n是8，那么能够表示的无符号整数的范围是0~255，能够表示的有符号整数的范围是-128~+127；
如果n是16，那么能够表示的无符号整数的范围是0~65535，能够表示的有符号整数的范围是-32768~+32767。
5.BCD码
虽然二进制数实现容易，并且二进制运算规律简单，但不符合人们的使用习惯，书写阅读都不方便。
所以在计算机输入输出时通常还是采用十进制来表示数，这就需要实现十进制与二进制间的转换。
为了转换方便，常采用二进制编码的十进制，简称为BCD码（Binary Coded Decimal）。
BCD码就是用4位二进制数编码表示1位十进制数。
表示的方法可有多种，常用的是8421BCD码，它的表示规则如表1.1所示。从表1.1可见，8421BCD码最自然和最简单。
例如，十进制数1996用8421BCD码表示成0001 1001 1001 0110，每组4位二进制数之间是二进制的，但组与组之间是十进制的。
和十进制数1996等值的二进制数是111 1100 1100。
6.十六进制表示
由于二进制数的基数太小，所以书写和阅读都不够方便。而十六进制数的基数16等于2的4次幂，
于是二进制数与十六进制数之间能方便地转换，也即4位二进制数对应1位十六进制数，或者1位十六进制数对应4位二进制数。
因此，人们常常把二进制数改写成十六进制数，在汇编语言程序设计过程中尤其如此。
在书写时，为了区别于十进制数和二进制数，通常在十六进制数后加一个字母H。
1.2.2非数值数据的表示
计算机除了处理数值数据外，还要处理大量的非数值数据，如文字信息和图表信息等，为此必须对非数值数据进行编码，
这样不仅计算机能够方便地处理和存储它们，而且还可以赋予它们数值数据的某些属性。
1.ASCII码
美国信息交换标准码（American Standard Code for Information Interchange），
简称为ASCII码，是目前国际上比较通用的字符二进制编码，微型计算机中也普遍采用它作为字符的编码。
它是7位二进制编码，表1.2列出了ASCII码。
表1.2ASClI码表
从表1.2可看到，它对94个常用的一般符号进行了编码，其中包括26个英文字母的大小写符号、10个数字符号和32个其他符号。
空格也作为一个符号，其编码是20H，它界于一般符号和32个控制符之间。所有这些一般符号和可控制符统称为字符。
从表1.2还可看到，数字符号的编码、大写字母符号的编码和小写字母符号的编码分别是连续的，
所以只要记住数字符号的编码从30H开始、大写字母符号的编码从41H开始和小写字母的编码从61H开始，
那么就可推出其他数字符号和字母符号的编码。
由于ASCII码只使用了7位二进制进行编码，故最多表示128个字符。这往往不能满足使用要求。
为此在IBM PC系列及其兼容机上，使用扩展的ASCII码。扩展的ASCII码使用8位二进制进行编码，故可表示256个字符。
另外，在该扩展的ASCII码中，控制符所对应的编码同时也表示其他图形符号。请参见附录。
2.变形国标码
有了ASCII码，计算机就能处理数字、字母等字符，但还不能处理汉字符。
为了使计算机能够处理汉字信息，就必须对汉字进行编码。
我国在1981年5月对六千多个常用汉字制定了交换码的国家标准，即GB2312-80《信息交换用汉字编码字符集――基本集》。
该标准规定了汉字信息交换用的基本汉字符和一般图形字符，它们共计7445个，其中汉字分成两级共计6763个。
该标准同时也给定了它们的二进制编码，即国标码。国标码是16位编码，高8位表示汉字符的区号，低8位表示汉字符的位号。
实际上，为了给汉字符编码，该标准把代码表分成94个区，每个区有94个位。区号和位号都从21H开始。
一级汉字安排在30H区至57H区，二级汉字安排在58H区至77H区。
例如，“啊”字的国标码是3021H。国标码为汉字的输入提供了一种标准输入方式。
目前在计算机中文平台中普遍采用的汉字编码是变形国标码。变形国标码是16位二进制编码，顾名思义它是国标码的变形。
用得最多的变形方法是把国标码的第15位和第7位均置成1，由于国标码中第15位和第7位都是0，
所以这种变形方法实际上就是在国标码上加8080H。
尽管16位的变形国标码与两个扩展的ASCII码的组合有冲突，但它在相关系统模块的支持下，有效地实现了汉字在计算机内的表示。
1.2.3基本数据类型
计算机存取的以二进制位表示的信息位数一般是8的倍数，它们有专门的名称。
1.字节
一个字节由8个二进制位组成。字节的最低位一般称为第0位，最高位称为第7位，如图1.2所示。
通常，硬件存储器的每一存储单元就由8个连续的位组成，也即可用于存储一个字节的信息。
如用一个字节来表示一个无符号数，那么表示范围是0~255；如表示有符号数，则表示范围是一128~+127。
一个字节足以表示一个ASCII字符，也可以表示一个扩展的ASCII字符。
另外，一个字节可分成2个4位的位组，称为半字节。
2.字
2个字节（即16个二进制位）组成一个字，如图1.3所示。字的最低位称为第0位，最高位称为第15位。
字的低8位称为低字节，高8位称为高字节。
由于一个字由16个二进制位组成，所以用一个字来表示无符号数，则表示范围是0~65535；
如表示有符号数，则表示范围是-32768~+32767间的有符号数。
一个字还可表示一个变形国标码。
注意，有时候字是涉及处理器一次能够处理的信息量的一个术语，字长是衡量处理器品质的一个重要指标。
3.双字
就和听起来一样，双字由2个字组成，也即包含32个二进制位。低16位称为低字，高16位称为高字。双字能表示的数的范围更大。
4.四字
四字就是由四个字组成，包含64个二进制位。如果双字还不能表达所需要的数值精度，那么四字也许就能解决问题了。
5.十字节
十字节就和它的名称一样，由10个字节组成，含80个二进制位。可用于存储非常大的数或表示较多的信息。
6.字符串
字符串是指由字符构成的一个线性数组。通常每个字符用一个字节表示，但有时每个字符也可用一个字或一个双字来表示。
1.3Intel系列CPU简介
汇编语言与CPU关系密切。本节从汇编语言程序设计的角度对Intel的80×86系列CPU作一简单介绍。
1.3.1 8位微处理器
1971年Intel开发出了第一代微处理器4004，它是一个4位的微处理器，自身含有计算和逻辑功能。
它由2250个MOS晶体管构成，每秒内能够执行约6万次操作。含有一个累加器，16个用作暂存数据的寄存器。
可寻址640字节的内存。指令集含有45条指令。
4004作为一般处理器来讲，功能还不够强，只能作为计算器的核心来使用。但它是一种新思想的第一代产物。
1972年Intel公司推出了第一块8位微处理器8008。它由约3300个MOS晶体管构成。
由于无论是指令执行的数据还是译码数据，以及操作数都能按8位处理，所以它比4004要快，每秒内执行的操作可超过8万次。
它含有7个8位寄存器，可寻址16K的内存。具有48条指令组成的指令集，但与4004的指令集不兼容。
1974年Intel公司又推出了为多种应用而设计的8位微处理器8080，它是Intel的第二代微处理器，也是第一个通用的微处理器。
它的功能相当强，足以作为微计算机的核心。它由6000多个晶体管构成，每秒能执行约60万次操作。寻址能力达到64K。
8080的指令集包含了8008的指令集，从而获得与8008指令集的兼容性，此外还增加了20多条指令。
8080为Intel公司成为当今CPU的霸主打下了坚实的基础。
1976年Intel公司公布了8080的变种8080A，此后还公布了作为8080A增强型的8085。
1.3.2 16位微处理器
1978年Intel公司率先推出了第三代微处理器即16位微处理器8086。
有两个关键的结构概念使微处理器设计定型且从8086开始施行，这两个概念是存储器分段和指令译码表。
Intel的x86家族也由此开始。
1.Intel 8086
8086内部分成如图1.4所示的两部分：总线接口部件BIU（Bus Interface Unit）和执行部件EU（Execution Unit）。
总线接口部件BIU包括一组段寄存器、一个指令指示器、指令队列（长6个字节）、地址产生器和总线控制器等。
BIU根据执行部件EU的请求，完成CPU与存储器或I/O设备之间的数据传送。
在EU执行指令的过程中，BIU根据需要从存储器中预先取出一些指令，保存到指令队列中。
如果EU执行一条转移指令，使程序发生转移，那么存放在指令队列中的预先取得的指令就不再有用，
BIU会根据EU的指示从新的地址重新开始取指令。
执行部件EU包括一个算术逻辑单元（ALU）、一组通用寄存器和标志寄存器等，它们均是16位的。
EU负责指令的执行，并进行算术逻辑运算等。EU从BIU中的指令队列中取得指令。
当指令要求将数据存放到存储器或输出到外部设备，或者要从存储器或外部设备读取数据时，EU就向BIU发出请求，
BIU根据EU发来的请求完成这些操作。
由于EU和BIU分开，8086的取指令过程和执行指令的过程在很大程度上是重叠的，即两个部件是并行工作的。
图1.5是执行顺序示意图。8086的这种结构，大大减少了等待取指令所需的时间，提高了CPU的效率。
与先前的8080和8085相比，8086的这种结构一方面可以提高整体的执行速度，
另一方面又降低了对与之相配的存储器的存取速度的要求。
8086的功能足够强。它具有20条地址线，故寻址范围可达到1M。
它具有16条数据线，能在一个总线周期内存取在偶地址开始的字操作数。
它能执行整套8080/8085指令，并且还增加了包括乘除法指令在内的许多条新指令。
由于处理速度的提高、运算能力的增强和内部部件的并行工作这三个方面的原因，使得它的处理能力大大地超过了8位微处理器。
2.Intel 8088
在8086推出之时，8位机已使用了一段时间，许多价格合理的外部接口或设备都是8位结构，为了方便地与8位外部接口或设备相连，
1979年Intel公司又推出了8088。8088是8086的8位版，它具有与8086相同的内部结构，包括EU和BIU两部件、16位的寄存器等。
所不同的是8088对外只有8根数据线，总是按字节存取内存单元。8088也称为准16位微处理器。
IBM PC和PC/XT及其同档次的兼容机都采用8088作为CPU。
从汇编语言程序设计的角度看，8088与8086几乎没有什么区别。
除了非常特别的程序外，适用于其中一个CPU的程序，可以不加修改地在另一个CPU上执行。
3.Intel 80186
1981年Intel公司推出了80186。除了8086所具有的特性外，80186还集成若干通用系统所需的部件，
包括一个片选逻辑部件，两个独立的高速直接存储器访问通道，三个可编程时钟，一个可编程中断控制器和一个时钟发生器等，
这些部件使得80186功能更强。
80186指令集包括了从早期的8080开始的所有指令，并且还增加了十余条新的指令，以改造现存的编码或产生最佳的80186编码。
从汇编语言程序设计的角度看，80186只是比8086多了几条指令。
4.Intel 80286
在1982年2月Intel公司还推出了一种超级16位微处理器即80286。
它比8086/8088和80186在速度和性能上都有较大的提高。它具有24根地址线，可寻址的最大物理空间达16M，
它具有大批量数据处理、存储保护和多道程序处理能力，支持迫切需要的虚拟存储系统，
因此它已可成为多任务、多用户系统的核心。
80286有四个独立的处理部件，分别是执行部件EU、总线部件BU、指令部件IU和地址部件AU。
这四个部件能同时并行工作，与8086相比，80286效率更高。
80286可按两种模式运行：一种是实方式，另一种是保护方式。初始状态是实方式。
在实方式下，80286的操作与80186极为相似，它提供的指令集包含了80186的指令集，此外还提供了几条特殊指令，
它们是为实现从实方式转到保护方式服务的。总之，从汇编语言程序设计的角度看，除了多识别几条指令外，
实模式下的80286相当于一个快速的8086。只有在保护模式下80286才能发挥其全部功能。
实现寻址16M字节的物理地址空间，而在实方式下仍只能寻址最低端的1M字节空间。
利用存储保护实现操作系统和任务的分离，在实方式下没有此能力。
支持每个任务多达1024M字节的虚拟存储空间，同样在实方式下没有此能力。
在保护模式下，80286还提供多条仅供操作系统使用的特权指令。
IBM PC/AT采用80286作为CPU。
1.3.3 32位微处理器
第四代微处理器是32位微处理器。Intel80x86家族的32位微处理器始于80386。
1.Intel80386
1985年10月Intel公司推出了32位微处理器80386。它不仅是微处理器发展进程中的里程碑，
而且现在看来也是80x86家族中担负过“发扬光大”之重任的成员。
80386兼容先前的8086/8088、80186和80286。
80386全面支持32位数据类型和32位操作。通用寄存器等从先前的16位扩展到32位。
数据传送和算术逻辑运算等各种操作从先前的8或者16位扩展到8、16或者32位。
80386拥有32根数据线，存储器存取操作也从先前的1个或者2个连续字节（16位）扩展到1个、2个或者4个连续字节（32位）。
80386还增加了若干条包括位操作在内的新指令。这些新指令可使得某些任务更容易实现。
80386支持实方式和保护方式两种运行模式。在实方式下，80386相当于一个可进行32位处理的快速的8086。
只有在保护方式下，80386才能真正发挥其全部强大的功能。
80386支持32位物理地址，在保护方式下，可寻址的物理地址空间高达4G。与8086和80286等相比，这个数字是巨大的。
在此基础上，80386有效地支持虚拟存储器和多任务。与80286相比，80386在支持虚拟存储器时，还提供了可选的分页机制，
这是很重要的改进。
80386在保护方式下会支持称为虚拟8086方式的运行模式。虚拟8086方式可更有效地执行8086/8088代码。
所有这些功能，为我们进入32位时代做好了准备。实现这些功能的80386基本上由六个可并行处理的部件构成，如图1.6所示。
这些部件的并行处理对提高80386的效率是有益的。总线接口部件（Bus Interface Unit）为80386和它的环境之间提供接口。
它接收来自执行部件或代码预取部件的存取传递请求，并按优先级选择这些请求。同时，它产生或完成当前总线周期的信号，
这些信号包括访问存储器和I/O的地址、数据和控制输出。代码预取部件（Code Prefetch Unit）执行预取代码功能。
当BIU不占用总线周期来执行一条指令时，它指示BIU顺着指令字节流顺序提取代码。
这些被预取的指令存放在16字节的预取代码队列中，等待指令译码部件的处理。
指令译码部件（Instruction Decode Unit）从预取代码队列中取出指令并将它们转换成微代码。
被译码的指令按FIFO方式存放在三个代码的指令队列中，等待执行部件的处理。
执行部件（Execution Unit）执行指令队列中的指令，并与完成该指令要求的所有其他部件实现通信。
它含有八个用于地址计算和数据操作的32位通用寄存器，还含有一个64位桶式移位器，用于加速移位、循环、乘法和除法操作。
分段部件（Segment Unit）和分页部件（Paging Unit）构成存储器管理部件MMU。
分段部件把逻辑地址（虚拟地址）转换成线性地址，并有效地实现多种存储器保护措施。
分页部件把线性地址转换成物理地址，并更有效地支持虚拟存储器的实现。
分页是可选的，当不启用分页部件时，线性地址就直接作为物理地址。
2.Intel80486
1989年4月Intel公司推出了80486，它是80x86家族中继80386之后又一种功能更强大的32位微处理器。
它兼容先前的8086/8088、80186、80286和80386。
简单地说，80486是在微处理器80386的基础上集成数值协处理器80387和超高速缓存而构成的。
图1.7是80486的结构示意图。图中的微处理器部分相当于80386，但它采用“流水线”的方式执行指令，从而总体效益更好。
所谓“流水线”方式，是指把指令处理分隔成若干个阶段，每个阶段都有独立的部件来处理，当一条指令的某个处理阶段完成后，
它就进入到下一处理阶段，而独立的处理部件就可立即处理下一条指令。超高速缓存的容量为8K字节，
利用它可在片上存储常用的数据和指令，以减少对外部总线的访问。数值协处理器是专为快速地进行浮点运算而设计的，
称为浮点部件。集成在片内的浮点部件可更加有效地协助80486进行浮点数值运算。
1.3.4Pentium和Pentium Pro
Intel把其第五代微处理器命名为Pentium（奔腾），把其第六代微处理器命名为Pentium Pro（高能奔腾）。
1.Pentium
1993年3月Intel公司推出了接替80486的新一代微处理器Pentium。它的性能比80486又有较大幅度的提高，
但它兼容先前的8086/8088、80186、80286、80386和80486。
Pentium支持的数据总线位数达到64位；支持的物理地址位数是32位；内部寄存器仍是32位。
Pentium采用超标量体系结构，拥有两条“流水线”，称为“U”流水线和“V”流水线。“U”流水线和“V”流水线都能执行整数指令，
“U”流水线还能执行浮点指令。这样可实现在每个时钟周期内最多可执行两条指令。Pentium还开始支持动态分支预测。
Pentium内置的浮点部件是在80486浮点部件的基础上完全重新设计，运算性能大大提高。
Pentium有两个独立的超高速缓存，即一个指令超高速缓存和一个数据超高速缓存，容量分别是8K字节。
所以，即使Pentium以与80486相同的频率工作，整数运算性能仍可提高一倍，浮点性能可提高5倍。
2.Pentium Pro
1995年11月Intel公司推出了更新一代微处理器Pentium Pro。它似乎是为进一步加快32位代码的运行而设计的，
但它兼容先前的8086/8088、80186、80286、80386、80486和Pentium。
Pentium Pro支持的数据总线位数是64位；支持的物理地址位数达到36位；内部寄存器是32位。
除了像Pentium那样具有两个独立的容量为8K字节的L1级缓存分别作为指令超高速缓存和数据超高速缓存外，
Pentium Pro还集成了一个256K或512K字节的L2级高速缓存。L2高速缓存能以处理器的全速运行。
Intel在Pentium Pro上实现了一种卓绝的设计：既是超标量的又是超流水线的，既能支持乱序执行又能支持寄存器重命名，
既开发了分支预测又开发了推测执行。所有这些统称为“动态执行”。Pentium Pro的超流水线技术扩展了原先的基本流水线概念，
进一步划细了基本流水线的各处理阶段。超标量指有多条流水线，Pentium Pro具有三发超标量模式，
在每个时钟周期内最多可执行三条指令。乱序执行是指不必按程序中指定的顺序执行对应每一条指令的内部RISC型操作，
这有利于提高流水线的效率。寄存器重命名是指把对体系结构寄存器的引用转换成对物理寄存器的引用，
有助于减轻指令间的伪相关。分支预测是指对一个分支是否真正改变程序流而进行的猜测；
推测执行是指允许提前执行那些由于分支原因导致不一定总被执行的指令，这些都有利于提高流水线的效率。
上述“动态执行”使得Pentium Pro在大多数情况下处理指令比Pentium的效率更高。
尽管Pentium Pro的“动态执行”十分复杂，但对汇编语言程序员而言，Pentium Pro与Pentium几乎无区别，
相反它使得软件优化对于提高其性能显得并不太重要。
3.发展趋势
表1.3列出了Intel的80x86家族前几代微处理器的性能，从中可见微处理器技术发展迅猛，
每种新型号的速度都比前一种旧型号更快，因此能更好地满足最终用户各种各样的要求。
1997年初推出的基于MMX技术的Pentium处理器使微处理器性能又上了一个台阶。
MMX是指多媒体扩展（MultiMedia eXtension），它是自80386出现以来Intel的80x86家族体系结构的最大的改进和增强。
MMX技术具有一套基本的、通用目的的整数指令，可以比较容易地满足各种多媒体应用程序及多媒体通信程序的需要。
重点的技术包括单指令多数据技术（SIMD）、57条新指令、8个64位宽的MMX寄存器和4种新的数据类型。
基于MMX技术的处理器具有足够的能力完成高速通信或带有多媒体任务的应用程序。
MMX技术使程序员可设计更多、更丰富、更令人惊奇的应用程序。
1.4习题
题1.8到目前为止，Intel的80×86家族有哪些成员？这些成员有何特征？

题1.1 与机器语言相比，汇编语言有何特点？与高级语言相比，汇编语言有何特点？
答：与机器语言相比，汇编语言的的特点有：
    1、易于记忆
    2、容易理解
    3、方便调试
    4、便于维护
    与高级语言相比，汇编语言的特点有：
    1、与机器指令关系密切
    2、程序效率高
    3、编写源程序繁琐
    4、程序调试困难
题1.2 汇编语言有何优缺点？
答：汇编语言的优点有：
    1、与机器语言相比易于记忆，容易理解，方便调试和维护；
    2、与高级语言相比，与机器指令关系密切，可直接和有效地操纵硬件，程序效率高；
    汇编语言的缺点：
    1、与高级语言相比，汇编语言编写源程序繁琐；
    2、调试困难；维护、交流和移植程序更困难
题1.3 汇编程序的作用是什么？汇编程序与编译程序有何不同？
答：汇编程序的作用是将汇编语言源程序翻译成目标程序；
    汇编程序是将汇编语言源程序翻译成目标程序；而编译程序是将高级语言编写的源程序翻译成目标程序
题1.4 哪些场合需要使用汇编语言？
答：需要使用汇编语言的场合有：
    1、对软件的执行时间或存储容量有较高要求的场合；
    2、需要提高大型软件性能的场合；
    3、软件与硬件关系密切，软件要有直接和有效控制硬件的场合；
    4、没有合适的高级语言的场合；
题1.5 在计算机系统中，如何表示西文字符和汉字符？
答：在计算机系统中，西文字符主要由ASCII码表示；而汉字符主要采用变形国标码表示；
题1.6 什么是BCD码？
答：BCD码是二进制编码的十进制，BCD码用4个二进制数表示0－9十个数字
题1.7 说明字节、字和双字之间的关系。
答：字节（byte）由8个二进制，即8bit组成；字（word）由16个二进制，即16bit组成；双字（Dual word）为32bit；
    1 Dual word=2 word= 4 byte
题1.8 到目前为止，Intel的80X86家族有哪些成员？这些成员有何特征？
答：Intel 8086
Intel 80286
Intel 80386
Intel 80486
Intel Pentium
Intel Pentium Pro
Intel Pentium MMX
Intel Pentium II
Intel Pentium III
Intel Pentium Ⅳ
Intel Pentium D
第2章8086/8088寻址方式和指令系统
从汇编语言程序设计的角度看，8086/8088、80186和实方式下的80286没有多大差异，而且Intel的80x86指令系统向上兼容。
本章介绍8086/8088寻址方式和指令系统。
2.1 8086/8088寄存器组
程序员可使用的8086/8088寄存器有通用寄存器、段寄存器和标志寄存器。这些寄存器有某些特定的用途，最常用的是通用寄存器。
2.1.1 8086/8088CPU寄存器组
8086/8088包括四个16位数据寄存器，两个16位指针寄存器，两个16位变址寄存器，一个16位指令指针，四个16位段寄存器，
一个16位标志寄存器。这14个16位寄存器分成四组，它们的名称和分组情况如图2.1所示。
四个16位数据寄存器
AH AL  AX
BH BL  BX
CH CL  CX
DH DL DX
两个16位指针寄存器
SP 堆栈指针
BP 基址指针
两个16位变址寄存器
Sl 源地址
DI 目的地址
一个16位指令指针
IP 指令指针
一个16位标志寄存器
FLAG 标志寄存器
四个16位段寄存器
CS 代码段
DS 数据段
SS 堆栈段
ES 附加段
1.通用寄存器
数据寄存器、指针寄存器和变址寄存器统称为通用寄存器。这样称呼的理由是，这些寄存器除了各自规定的专门用途外，
它们均可用于传送和暂存数据，可以保存算术逻辑运算中的操作数和运算结果。
各通用寄存器的专门用途列于表2.1中。汇编语言程序员对这些用途必须充分注意，以便正确和合理地使用这些通用寄存器。
表2.1通用寄存器的专门用途
AX 字乘法，字除法，字I/O
AL 字节乘法，字节除法，字节I/O，十进制算术运算
AH 字节乘法，字节除法
BX 存储器指针
CX 串操作或循环控制中的计数器
CL 移位计数器
DX 字乘法，字除法，间接I/O
Sl  存储器指针（串操作中的源指针）
DI 存储器指针（串操作中的目的指针）
BP 存储器指针（存取堆栈的指针）
SP 堆栈指针
（1）数据寄存器
数据寄存器主要用来保存操作数或运算结果等信息，它们的存在节省了为存取操作数所需占用总线和访问存储器的时间。
四个16位的数据寄存器可分解成八个独立的8位寄存器，这八个8位的寄存器有各自的名称，均可独立存取。
如图2.1所示，AX寄存器分解为AH寄存器和AL寄存器；BX寄存器分解为BH寄存器和BL寄存器；
CX寄存器分解为CH寄存器和CL寄存器；DX寄存器分解为DH寄存器和DL寄存器。名称中的字母H表示高，字母L表示低。
AH寄存器就是AX寄存器的高8位，AL寄存器就是AX寄存器的低8位。AH寄存器和AL寄存器的合并就是AX寄存器。
其他寄存器类推。
程序员在设计8086/8088程序时，要充分利用数据寄存器的上述双重性，恰当地进行合分，以便有效地处理字和字节信息。
AX和AL寄存器又称为累加器（Accumulator）。一般通过累加器进行的操作所花的时间可能最少，
此外累加器还有许多专门的用途，所以累加器使用得最普遍。
BX寄存器称为基（Base）地址寄存器。它是四个数据寄存器中唯一可作为存储器指针使用的寄存器。
CX寄存器称为计数（Count）寄存器。在字符串操作和循环操作时，用它来控制重复循环操作次数。
在移位操作时，CL寄存器用于保存移位的位数。
DX寄存器称为数据（Data）寄存器。在进行32位的乘除法操作时，用它存放被除数的高16位或余数。它也用于存放I/O端口地址。
（2）变址和指针寄存器
变址和指针寄存器主要用于存放某个存储单元地址的偏移，或某组存储单元开始地址的偏移，即作为存储器（短）指针使用。
作为通用寄存器，它们也可以保存16位算术逻辑运算中的操作数和运算结果，有时运算结果就是需要的存储单元地址的偏移。
注意，16位的变址寄存器和指针寄存器不能分解成8位寄存器使用。
利用变址寄存器和指针寄存器不仅能够有效地缩短机器指令的长度，而且能够实现多种存储器操作数的寻址，
从而方便地实现对多种类型数据的操作。
SI和DI寄存器称为变址寄存器。在字符串操作中，规定由SI给出源指针，由DI给出目的指针，
所以SI也称为源变址（Source Index）寄存器，DI也称为目的变址（Destination Index）寄存器。
当然，SI和DI也可作为一般存储器指针使用。
BP和SP寄存器称为指针寄存器。BP主要用于给出堆栈中数据区基址的偏移，从而方便地实现直接存取堆栈中的数据，
所以BP也称为基指针（Base Pointer）寄存器。正常情况下，SP只作为堆栈指针（Stack Pointer）使用，
即保存堆栈栈顶地址的偏移。堆栈是一片存储区域，我们以后再介绍堆栈操作和堆栈的作用。
2.段寄存器
8086/8088CPU依赖其内部的四个段寄存器实现寻址1M字节物理地址空间。8086/8088把1M字节地址空间分成若干逻辑段，
当前使用段的段值存放在段寄存器中。由段值和段内偏移形成20位地址，在2.2节介绍形成20位地址的具体方法。
8086/8088CPU的四个段寄存器均是16位的，分别称为代码段（Code Segment）寄存器CS，
数据段（Data Segment）寄存器DS，堆栈段（Stack Segment）寄存器SS，附加段（Extra Segment）寄存器ES。
由于8086/8088有这四个段寄存器，所以有四个当前使用段可直接存取，这四个当前段分别称为代码段、数据段、堆栈段和附加段。
在2.2节介绍如何使用这四个段寄存器和访问这四个段。
3.指令指针
8086/8088CPU中的指令指针IP（Instruction Pointer）也是16位的，
它类似于8080/8085中的程序计数器PC（Program Counter）。指令指针IP给出接着要执行的指令在代码段中的偏移。
实际上接着要执行的指令已被预取到指令预取队列，除非发生转移。在理解IP的功能时，可不考虑指令预取队列。
2.1.2标志寄存器
8086/8088CPU中有一个16位的标志寄存器，包含了9个标志，主要用于反映处理器的状态和运算结果的某些特征。
各标志在标志寄存器中的位置如下所示。
15 14 13 12 11 10  9  8   7   6   5   4  3  2  1  0
                    OF DF IF TF SF ZF       AF   PF     CF
有些指令的执行会影响部分标志，而有些指令的执行不会影响标志；反过来，有些指令的执行受某些标志的影响，
有些指令的执行不受标志的影响。所以，程序员要充分注意指令与标志的关系。
9个标志可分成两组，第一组6个标志主要受加减运算和逻辑运算结果的影响，称为运算结果标志，
第二组标志不受运算结果的影响，称为状态控制标志。
1.运算结果标志
（1）进位标志CF（Carry Flag）
进位标志CF主要用于反映运算是否产生进位或借位。
如果运算结果的最高位（字操作时的第15位或字节操作时的第7位）产生一个进位或借位，则CF被置1，否则CF被清0。
在进行多字节数的加减运算时，要使用到该标志；在比较无符号数的大小时，要使用到该标志。
移位指令也把操作数的最高位或最低位移入CF。移位指令和CF的配合，可实现操作数之间的位传送。
CF也常作为子程序的出口参数之一。
8086/8088提供专门的改变CF值的指令。
（2）零标志ZF（Zero Flag）
零标志ZF用于反映运算结果是否为0。如果运算结果为0，则ZF被置1，否则ZF被清0。
在判断运算结果是否为0时，要使用到该标志。
（3）符号标志SF（Sign Flag）
符号标志SF用于反映运算结果的符号位。SF与运算结果的最高位相同，如果运算结果的最高位为1，则SF被置1，否则SF被清0。
由于在8086/8088系统中，有符号数采用补码的形式表示，所以SF反映了运算结果的符号。
如果运算结果为正，则SF被清0，否则SF被置1。
（4）溢出标志OF（Overflow Flag）
溢出标志OF用于反映有符号数加减运算是否引起溢出。如运算结果超出了8位或16位有符号数的表示范围，
即在字节运算时大于127或小于-128，在字运算时大于32767或小于-32768，称为溢出。如果溢出，则OF被置1，否则OF被清0。
要特别注意，溢出标志与进位标志是两个不同性质的标志，不能混淆。
（5）奇偶标志PF（Parity Flag）
奇偶标志PF用于反映运算结果中“1”的个数。如果“1”的个数为偶数，则PF被置1，否则PF被清0。
利用PF可进行奇偶校验检查，或产生奇偶效验位。在串行通信中，为了提高传送的可靠性，常采用奇偶校验。
（6）辅助进位标志AF（Auxiliary Carry Flag）
在字节操作时，如发生低半字节向高半字节进位或借位；在字操作时，如发生低字节向高字节进位或借位，
则辅助进位标志AF被置1，否则AF被清0。十进制算术运算调整指令自动根据该标志产生相应的调整动作。
2.状态控制标志
状态控制标志控制处理器的操作，要通过专门的指令才能使状态控制标志发生变化。
（1）方向标志DF（Direction Flag）
方向标志决定着串操作指令执行时有关指针寄存器调整方向。
当DF为1时，串操作指令按减方式改变有关的存储器指针值；当DF为0时，串操作指令按加方式改变有关的存储器指针值。
8086/8088提供的专门用于设置方向标志DF的指令是STD，专门用于清DF的指令是CLD。
（2）中断允许标志IF（Interrupt-enable Flag）
中断允许标志决定着CPU是否响应外部可屏蔽中断请求。
当IF为1时，CPU能够响应外部的可屏蔽中断请求；当IF为0时，则不响应外部的可屏蔽中断请求。
但此标志的状态对于外部的非屏蔽中断请求，或内部产生的中断不起作用。
8086/8088提供的专门用于设置中断允许标志IF的指令是STI，专门用于清IF的指令是CLI。
（3）追踪标志TF（Trap Flag）
当追踪标志TF被置1后，CPU进入单步方式。所谓单步方式是指在一条指令执行后，产生一个单步中断。
这主要用于程序的调试。8086/8088没有专门设置和清除TF标志的指令，要通过其他方法设置或清除TF。
2.2存储器分段和地址的形成
从8086开始采用分段的方法管理存储器。只有充分理解存储器分段的概念和存储器逻辑地址和物理地址的关系，
才能熟练地使用8086/8088汇编语言。
2.2.1存储单元的地址和内容
在以8086或8088为CPU的系统中（如IBM PC兼容机），以字节为单位线性地组织存储器。为了标识和存取每一个存储单元，
给每一个存储单元规定一个编号，也就是存储单元地址。存储单元地址用二进制数表示，从0开始，顺序地每次加1。
存储单元的地址是无符号数，n位二进制数总共能够表示2的n次方个存储单元的地址。为了书写方便，
存储单元地址常采用十六进制数表示。一个存储单元中存放的信息称为该存储单元的内容。
图2.2示意了存储器中部分存储单元存放信息的情况。从图2.2可看到，地址为56780H的字节存储单元中的内容是34H，
而地址为56781H的字节存储单元中的内容是12H。一个字存放到存储器要占用连续的两个字节单元。
系统规定，当把一个字存放到存储器时，其低字节存放在地址较低的字节单元中，其高字节存放在地址较高的字节单元中。
这样二个连续的字节单元就构成了一个字单元，字单元的地址采用它的低地址表示。
例如，图2.2中地址为56780H的字单元的内容是1234H，而地址为834ABH的字单元的内容是6780H。
上述存储原则称为“高高低低”原则。在以字节方式存取字时需要特别注意该原则，当以字方式存取字时，处理器自动采用该原则。
四个连续的字节单元就构成了一个双字单元，双字单元的地址就是最低字节单元的地址。
一个双字存放到存储器时也按照“高高低低”原则存储，也即高字在高地址字中，低字在低地址字中，
也就是最高字节在最高地址字节单元中，最低字节在最低地址字节单元中。
如图2.2所示，地址为56780H的双字单元中存放的内容是29561234H。
2.2.2存储器的分段
8086/8088CPU有20根地址线，可直接寻址的物理地址空间为1M字节（=2的20次方）。
系统存储器由以字节为单位的存储单元组成，存储单元的物理地址长20位，范围是00000H至FFFFFH。
尽管8086/8088内部的ALU每次最多进行16位运算，
存放存储单元地址偏移的指针寄存器（如P、SP以及BP、SI、DI和BX）都是16位，
但8086/8088通过对存储器分段和使用段寄存器的方法有效地实现了寻址1M字节物理空间。
根据需要把1M字节地址空间划分成若干逻辑段。每个逻辑段必须满足如下两个条件：第一，逻辑段的开始地址必须是16的倍数；
第二，逻辑段的最大长度为64K。按照这两个条件，1M字节地址空间最多可划分成64K个逻辑段，最少也要划分成16个逻辑段。
第一个条件与段寄存器长16位有关；第二个条件与指针寄存器长16位相关。
逻辑段与逻辑段可以相连，也可以不相连，还可以部分重叠。图2.3给出了若干逻辑段的划分情况。
在图2.3中，段B与段C部分重叠，段E与段D相连。
这种存储器分段的方法不仅有利于实现寻址1M字节空间，而且也十分有利于对1M字节存储空间的管理。
对实现程序的重定位和浮动，对实现代码数据的隔离，对充分利用存储空间，这种方法都有益。
2.2.3物理地址的形成
由于段的起始地址必须是16的倍数，所以段起始地址有如下形式：
bbbbbbbbbbbbbbbb0000用16进制可表示成XXXX0。这种20位的段起始地址，可压缩表示成16位的XXXX形式。
我们把20位段起始地址的高16位XXXX称为段值。显然，段起始地址等于段值乘16（即左移4位）。
要访问的某一个存储单元总是属于某个段。我们把存储单元的地址与所在段的起始地址的差称为段内偏移，简称为偏移。
在一个段内，通过偏移可指定要访问的存储单元，或者说要访问的存储单元可由偏移来指定。
在整个1M地址空间中，存储单元的物理地址等于段起始地址加上偏移。
于是，存储单元的逻辑地址由段值和偏移两部分组成，用如下形式表示：
段值：偏移
根据逻辑地址可方便地得到存储单元的物理地址，计算公式如下：
物理地址=段值×16+偏移
通过移位和算术加可容易地实现上述公式，图2.4是物理地址产生的示意图。
例如，用16进制表示的逻辑地址1234：3456H所对应的存储单元的物理地址为15796H。
由于段可以重叠，所以一个物理地址可用多个逻辑地址表示。
图2.5是这样的一个例子，其中存储单元的物理地址是12345H，标出的两个重叠段的段值分别是1002H和1233H，
在对应段内的偏移分别是2325H和0015H。
采用段值和偏移构成逻辑地址后，段值由段寄存器给出，
偏移可由指令指针IP、堆栈指针SP和其他可作为存储器指针使用的寄存器（SI、DI、BX和BP）给出，偏移还可直接用16位数给出。
指令中不使用物理地址，而是使用逻辑地址，由总线接口单元BIU按需要根据段值和偏移自动形成20位物理地址。
2.2.4段寄存器的引用
由于8086/8088CPU有四个段寄存器，可保存四个段值，所以可同时使用四个段，
但这四个段有所分工。每当需要产生一个20位的物理地址时，BIU会自动引用一个段寄存器，且左移4位再与一个16位的偏移相加。
图2.6给出了一个同时使用四个段的例子。
在取指令的时候，自动引用代码段寄存器CS，再加上由IP所给出的16位偏移，得到要取指令的物理地址。
当涉及到一个堆栈操作时，则自动引用堆栈段寄存器SS，再加上由SP所给出的16位偏移，得到堆栈操作所需的物理地址。
当偏移涉及BP寄存器时，缺省引用的段寄存器也为堆栈段寄存器SS。
在存取一个普通存储器操作数时，则自动选择数据段寄存器DS或附加段寄存器ES，
再加上16位偏移，得到存储器操作数的物理地址。此时的16位偏移，可以是包含在指令中的直接地址，
也可以是某一个16位存储器指针寄存器的值，也可以是指令中的偏移再加上存储器指针寄存器中的值，
这取决于指令的寻址方式。除了串操作时目的段选择附加段寄存器ES外，缺省选择数据段寄存器DS。
在不改变段寄存器值的情况下，寻址的最大范围是64K字节。
若某个程序使用的总的存储长度（包括代码、堆栈和数据区）不超过64K字节，则整个程序可以合用一个64K字节的段。
若有一个程序，它的代码长度、堆栈长度和数据区长度均不超过64K字节，
则可在程序开始时分别给DS和SS等段寄存器赋值，在程序的其他地方就可不再考虑这些段寄存器所含的段值，
程序就能正常地运行。假如某个程序的数据区长度超过64K字节，那么就要在两个或多个数据段中存取数据。
如果出现这种情况，只要在从存取一个数据段改变到存取另一个数据段时，改变数据段寄存器内的段值就可以了。
由于BIU能根据需要自动选择段寄存器，所以通常情况下在指令中不指明所需要的段寄存器。
取指令和堆栈操作所引用的段寄存器分别规定为CS和SS，是不可变的；
串操作中目的段的段寄存器规定为ES也是不可变的。
但是，在存取一般存储器操作数时，段寄存器可以不一定是DS；当偏移涉及BP寄存器时，段寄存器也不是非要为SS。
8086/8088允许使用段超越前缀，改变上述两种情况下所使用的段寄存器，也即用段超越前缀直接明确指定引用的段寄存器。
表2.2列出了段寄存器的引用规定，其中“可选用的段寄存器”栏就列出了可作为段超越前缀改变的段寄存器，
另外，有效地址EA（Effective Address）就是指段内偏移。
2.3 8086/8088的寻址方式
表示指令中操作数所在的方法称为寻址方式。
8086/8088有七种基本的寻址方式：立即寻址，寄存器寻址，直接寻址，寄存器间接寻址，寄存器相对寻址，基址加变址寻址，
相对基址加变址寻址。
直接寻址、寄存器间接寻址、寄存器相对寻址、基址加变址寻址和相对基址加变址寻址，这五种寻址方式属于存储器寻址，
用于说明操作数所在存储单元的地址。由于总线接口单元BIU能根据需要自动引用段寄存器得到段值，
所以这五种方式也就是确定存放操作数的存储单元有效地址EA的方法。有效地址EA是一个16位的无符号数，
在利用这五种方法计算有效地址时，所得的结果认为是一个无符号数。
除了这些基本的寻址方式外，还有固定寻址和I/O端口寻址等。
2.3.1立即寻址方式
操作数就包含在指令中，它作为指令的一部分，跟在操作码后存放在代码段。这种操作数称为立即数。
立即数可以是8位，也可以是16位。如果立即数是16位，那么按“高高低低”原则存放，
即高位字节在高地址存储单元，低位字节在低地址存储单元。
指令“MOV AX,1234H”的存储和执行情况如图2.7所示。
这种寻址方式主要用于给寄存器或存储单元赋初值的场合。
2.3.2寄存器寻址方式
操作数在CPU内部的寄存器中，指令中指定寄存器号。
对于16位操作数，寄存器可以是AX、BX、CX、DX，SI、DI、SP和BP等；
对于8位操作数，寄存器可以是AL、AH、BL、BH、CL、CH、DL和DH。
例如，指令“MOV SI,AX”和指令“MOV AL,DH”中的源操作数和目的操作数均是寄存器寻址。
再如，图2.7所示指令中，目的操作数采用寄存器寻址。
由于操作数在寄存器中，不需要通过访问存储器来取得操作数，所以采用这种寻址方式的指令执行速度较快。
2.3.3直接寻址方式
操作数在存储器中，指令直接包含有操作数的有效地址。操作数一般存放在数据段，
所以操作数的地址由DS加上指令中直接给出的16位偏移得到。如果采用段超越前缀，则操作数也可含在数据段外的其他段中。
设数据段寄存器DS的内容是5000H，地址为51234H字存储单元中的内容是6789H，
那么在执行指令“MOV AX,[1234H]”后寄存器AX的内容是6789H。
图2.8是此指令的存储和执行情况。为方便，本章常用（reg）表示寄存器reg的内容。
于是该例的假设用（DS）=5000H表示，执行结果用（AX）=6789H表示。
下面指令中目标操作数采用直接寻址，并且使用了段超越前缀：
MOV ES:[5678H],BL
引用的段寄存器是ES
这种寻址方式常用于处理单个存储器变量的情况。它可实现在64K字节的段内寻找操作数。
直接寻址的操作数通常是程序使用的变量。
注意立即寻址和直接寻址书写表示方法上的不同，直接寻址的地址要放在方括号中。
在源程序中，往往用变量名表示。
2.3.4寄存器间接寻址方式
操作数在存储器中，操作数有效地址在SI、DI、BX、BP这四个寄存器之一中。
在一般情况（即不使用段超越前缀明确指定段寄存器）下，如果有效地址在SI、DI和BX中，则以DS段寄存器之内容为段值；
如果有效地址在BP中，则以SS段寄存器之内容为段值。
例如，MOV AX,[SI]
假设，（DS）=5000H，（SI）=1234H那么，存取的物理存储单元地址是51234H。
再设该字存储单元的内容是6789H，那么在执行该指令后，（AX）=6789H。图2.9反映该指令的存储和执行情况。
下面指令中源操作数采用寄存器间接寻址，并且使用了段超越前缀：
MOV DL,CS:[BX]
引用的段寄存器是CS
下面指令中目的操作数采用寄存器间接寻址，由于使用BP作为指针寄存器，所以缺省的段寄存器是SS：
MOV [BP],CX
引用的段寄存器是SS
这种寻址方式可以用于表格处理，在处理完表中的一项后，只要修改指针寄存器的内容就可以方便地处理表中的另一项。
请注意在书写表示寄存器间接寻址时，寄存器名一定要放在方括号中。
下面两条指令的目的操作数的寻址方式完全不同：
MOV [SI],AX
目的操作数寄存器间接寻址
MOV SI,AX
目的操作数寄存器寻址
2.3.5寄存器相对寻址方式
操作数在存储器中，
操作数的有效地址是一个基址寄存器（BX、BP）或变址寄存器的（SI、DI）内容加上指令中给定的8位或16位位移量之和。即：
在一般情况（即不使用段超越前缀明确指定段寄存器）下，如果SI、DI或BX之内容作为有效地址的一部分，
那么引用的段寄存器是DS；如果BP之内容作为有效地址的一部分，那么引用的段寄存器是SS。
在指令中给定的8位或16位位移量采用补码形式表示。在计算有效地址时，如位移量是8位，则被带符号扩展成16位。
当所得的有效地址超过FFFFH，则取其64K的模。
例如，MOV AX,[DI+1223H]
假设，（DS）=5000H，（DI）=3678H那么，存取的物理存储单元地址是5489BH。
再设该字存储单元的内容是55AAH，那么在执行该指令后，（AX）=55AAH。图2.10反映该指令的存储和执行情况。
下面指令中，源操作数采用寄存器相对寻址，引用的段寄存器是SS：
MOV BX,[BP-4]
下面指令中，目的操作数采用寄存器相对寻址，引用的段寄存器是ES：
MOV ES:[BX+5],AL
这种寻址方式同样可用于表格处理，表格的首地址可设置为指令中的位移量，
利用修改基址或变址寄存器的内容来存取表格中的项值。
所以，这种方式很有利于实现高级语言中对结构或记录等数据类型所实施的操作。
请注意书写时基址或变址寄存器名一定要放在方括号中，而位移可不写在方括号中。
下面两条指令源操作数的寻址方式是相同的，表示的形式等价：
MOV AX,[SI+3]
MOV AX,3[SI]
2.3.6基址加变址寻址方式
操作数在存储器中，操作数的有效地址由基址寄存器之一的内容与变址寄存器之一的内容相加得到。即：
在一般情况（即不使用段超越前缀明确指定段寄存器）下，如果BP之内容作为有效地址的一部分，则以SS之内容为段值，
否则以DS之内容为段值。
当所得的有效地址超过FFFFH时，就取其64K的模。
例如，MOV AX,[BX+DI]
假设，（DS）=5000H，（BX）=1223H，（DI）=54H那么，存取的物理存储单元地址是51277H。
再设该字存储单元的内容是168H，那么在执行该指令后，（AX）=168H。图2.11反映该指令的执行情况。
下面指令中，源操作数采用基址加变址寻址，通过增加段超越前缀来引用段寄存器ES：
MOV AX,ES:[BX+SI]
下面指令中，目的操作数采用基址加变址寻址，引用的段寄存器是DS：
MOV DS:[BP+SI],AL
这种寻址方式适用于数组或表格处理。用基址寄存器存放数组首地址，而用变址寄存器来定位数组中的各元素，或反之。
由于两个寄存器都可改变，所以能更加灵活地访问数组或表格中的元素。
下面的二种表示方法是等价的：
MOV AX,[BX+DI]
MOV AX,[DI][BX]
2.3.7相对基址加变址寻址方式
操作数在存储器中，操作数的有效地址由基址寄存器之一的内容与变址寄存器之一的内容及指令中给定的8位或16位位移量
相加得到。也即：
在一般情况（即不使用段超越前缀指令明确指定段寄存器）下，如果BP之内容作为有效地址的一部分，
则以SS段寄存器之内容为段值，否则以DS段寄存器之内容为段值。
在指令中给定的8位或16位位移量采用补码形式表示。在计算有效地址时，如果位移量是8位，那么被带符号扩展成16位。
当所得的有效地址超过FFFFH时，就取其64K的模。
例如，MOV AX,[BX+DI-2]
假设，（DS）=5000H，（BX）=1223H，（DI）=54H那么，存取的物理存储单元地址是51275H。
再设该字存储单元的内容是7654H，那么在执行该指令后，（AX）=7654H。图2.12反映该指令的存储和执行情况，
位移用补码表示。
尽管相对基址加变址这种寻址方式最复杂，但也是最灵活。
相对基址加变址这种寻址方式的表示方法多种多样，下面四种表示方法均是等价的：
MOV AX,[BX+DI+1234H]
MOV AX,1234H[BX+DI]
MOV AX,1234H[BX][DI]
MOV AX,1234H[DI][BX]
2.4 8086/8088指令系统
本节详细介绍8086/8088指令集中的大部分常用指令，剩下的部分指令分散在有关章节中介绍。
2.4.1指令集说明
1.分组
与早先的8位微处理器相比，8086/8088的指令系统丰富，而且指令的功能也强。
大多数指令既能处理字数据，又能处理字节数据；算术运算和逻辑运算不局限于累加器，存储器操作数也可直接参加算术逻辑运算。
8086/8088的指令系统可分为如下六个功能组：
（1）数据传送；
（2）算术运算；
（3）逻辑运算；
（4）串操作；
（5）程序控制；
（6）处理器控制。
2.指令表示格式
为了方便地介绍指令系统中的指令，我们先介绍汇编语言中指令语句的一般格式。
在汇编语言中，指令语句可由四部分组成，一般格式如下：
[标号：]指令助记符[操作数1[，操作数2]][；注释]
指令是否带有操作数，完全取决于指令本身，有的指令无操作数，有的指令只有一个操作数，有的指令需要两个操作数。
标号的使用取决于程序的需要，是否写上注释由程序员决定。
请注意：标号只被汇编程序识别，它与指令本身无关；由分号引导的注释则纯粹是为了理解和阅读程序的需要，
汇编程序将其全部忽略，绝对不影响指令。
3.其他说明
对于每一条指令，程序员要注意以下几点：
（1）指令的功能；
（2）适用于指令的操作数寻址方式；
（3）指令对标志的影响；
（4）指令的长度和执行时间。
2.4.2数据传送指令
数据传送指令组又可分为：传送指令，交换指令，地址传送指令，堆栈操作指令，标志传送指令，查表指令，输入输出指令。
查表指令和输入输出指令在有关章节介绍。
除了SAHF和POPF指令外，这组指令对各标志没有影响。
1.传送指令
传送指令是使用得最频繁的指令，其格式如下：
MOV DST,SRC
此指令把一个字节或一个字从源操作数SRC送至目的操作数DST。
源操作数可以是累加器、寄存器、存储单元以及立即数，而目的操作数可以是累加器、寄存器和存储单元。传送不改变源操作数。
MOV指令可实现的传送方向如图2.13所示。具体地说，数据传送指令能实现下列传送功能：
（1）CPU内部寄存器之间的数据传送。例如：
MOV AH,AL
MOV DL,BH
MOV BP,SP
MOV AX,CS
MOV DS,BX
就寄存器之间传送而言，下列情况是例外：源和目的不能同时是段寄存器；代码段寄存器CS不能作为目的；
指令指针IP既不能作为源，也不能作为目的。注意，这种例外永远存在。
（2）立即数送至通用寄存器或存储单元（各种存储器寻址方式）。例如：
MOV AL,3
MOV Sl,-5
MOV VARB,-1
VARB是变量名，代表一个存储单元
MOV VARW,3456H
VARW是一个字变量
MOV [SI],6543H
注意，立即数不能直接传送到段寄存器，立即数永远不能作为目的操作数。
（3）寄存器与存储器间的数据传送。例如：
MOV AX,VARW
VARW是一个字变量，存储器操作为直接寻址
MOV BH,[DI]
存储器操作数为寄存器间接寻址
MOV DI,ES:[SI+3]
存储器操作数为相对变址寻址，使用段超越前缀
MOV BP,[BX+SI+3]
存储器操作数为相对基址加变址寻址
MOV VARB,DL
VARB是一个字节变量
MOV [BP],AX
使用SS段寄存器
MOV DS:[BP],DL
使用段超越前缀
MOV VARW,DS
VARW是一个字变量
MOV ES,VARW
对存储器操作数而言，可采用各种存储器寻址方式，这一点对其他指令也一直成立。
关于MOV指令，除了前面的例外，还要遵守下列规定：
①源操作数和目的操作数类型要一致。即同时为字节或字，不能一个是字节，另一个是字。
②除了串操作指令外，源操作数和目的操作数不能同时是存储器操作数。
这些例外和规定不仅适用于MOV指令，也同样适用于所有涉及到操作数的指令。
如果要在两个存储单元间传送数据，那么可利用通用寄存器过渡的方法进行，例如：
MOV AX,VARW1
把字变量VARW1的内容送到字变量VARW2
MOV VARW2,AX
这种利用通用寄存器过渡的方法，也适用于段寄存器间的数据传送。例如：
MOV AX,CS
把CS的内容送到DS
MOV DS,AX
2.交换指令
利用交换指令可方便地实现通用寄存器与通用寄存器或存储单元间的数据交换，交换指令的格式如下：
XCHG OPRD1,OPRD2
此指令把操作数OPRD1的内容与操作数OPRD2的内容交换。操作数同时是字节或字。例如：
XCHG AL,AH
XCHG Sl,BX
OPRD1和OPRD2可以是通用寄存器和存储单元。但不包括段寄存器，也不能同时是存储单元，还不能有立即数，
这符合已介绍过的例外和规定。可采用各种存储器寻址方式来指定存储单元。例如：
XCHG [SI+3],AL
XCHG [DI+BP+3],BX
3.地址传送指令
8086/8088有如下三条地址传送指令。
（1）指令LEA（Load Effective Address）
指令LEA称为传送有效地址指令，其格式如下：
LEA REG,OPRD
该指令把操作数OPRD的有效地址传送到操作数REG。
操作数OPRD必须是一个存储器操作数，操作数REG必须是一个16位的通用寄存器。例如：
LEA AX,BUFFER
BUFFER是变量名
LEA DX,[BX+3]
LEA SI,[BP+DI+4]
请注意，LEA指令与把存储单元中的数据传送到寄存器的MOV指令有本质上的区别。
假设变量BUFFER的偏移是1234H，该字变量的值为5678H，那么在执行完指令
“LEA AX,BUFFER”后，AX寄存器中的值为1234H，而不是5678H，在执行完指令
“MOV AX,BUFFER”后，AX寄存器中的值为5678H，而不是1234H。
（2）指令LDS（Load pointer into DS）
段值和段内偏移构成32位的地址指针。该指令传送32位地址指针，其格式如下：
LDS REG，OPRD
该指令把操作数OPRD中所含的一个32位地址指针的段值部分送到数据段寄存器DS，把偏移部分送到指令给出的通用寄存器REG。
操作数OPRD必须是一个32位的存储器操作数，操作数REG可以是一个16位的通用寄存器，
但实际使用的往往是变址寄存器或指针寄存器。例如：
LDS Dl,[BX]
LDS SI,FAR POINTER
FAR POINTER是一个双字变量假设双字变量FAR POINTER包含的32位地址指针的段值为5678H，偏移为1234H，
那么在执行指令“LDS SI,FAR POINTER”后，段寄存器DS的值为5678H，寄存器SI的值为1234H。
32位地址指针的偏移部分存储在双字变量的低地址字中，段值部分存储在高地址字中。图2.14是该指令的执行示意图。
（3）指令LES（Load pointer into ES）
LES指令也传送32位地址指针，其格式如下：
LES REG,OPRD
该指令把操作数OPRD中所含的32位地址指针的段值部分送到附加段寄存器ES，把偏移部分送到指令给出的通用寄存器REG。
其他说明同指令LDS。
2.4.3堆栈操作指令
在8086/8088系统中，堆栈是一段RAM区域。称为栈底的一端地址较大，称为栈顶的一端地址较小。
堆栈的段值在堆栈段寄存器SS中，堆栈指针寄存器SP始终指向栈顶。
只要重新设置SS和SP的初值（例如用MOV指令），就可以改变堆栈的位置。堆栈的深度由SP的初值决定。
堆栈操作始终遵守“后进先出”的原则，所有数据的存入和取出都在栈顶进行。在8086/8088系统中，进出堆栈的数据均以字为单位。
我们先列出堆栈的如下主要用途，每种用途的具体使用情况在以后的章节中陆续作介绍：
（1）现场和返回地址的保护；
（2）寄存器内容的保护；
（3）传递参数；
（4）存储局部变量。
堆栈操作指令分为两种：进栈指令PUSH和出栈指令POP。
1.进栈指令 PUSH进栈指令把16位数据压入堆栈，其格式如下：
PUSH SRC
该指令把源操作数SRC压入堆栈。它先把堆栈指针寄存器SP的值减2，然后把源操作数SRC送入由SP所指的栈顶。
图2.15（a）和（b）示意指令“PUSH AX”执行前后堆栈的变化情况，假设AX=8A9BH。
随着压入堆栈的数据增多，堆栈也逐步扩展。SP值随着压栈而减小，但每次操作完，SP总是指向栈顶。
当把一个16位数据压入堆栈时，总是遵守“高高低低”的存储原则。
源操作数SRC可以是通用寄存器和段寄存器，也可以是字存储单元。例如：
PUSH SI
PUSH DS
PUSH VARW
VARW是字变量
PUSH [SI]
2.出栈指令 POP出栈指令从堆栈弹出16位数据，其格式如下：
POP DST
该指令从栈顶弹出一个字数据到目的操作数DST。它先把堆栈指针寄存器SP所指的字数据送至目的操作数DST，然后SP值加2，
使其仍指向栈顶。图2.15（b）和（c）示意执行指令“POP AX”前后的堆栈变化情况。随着弹出堆栈的数据增多，堆栈也逐步收缩。
SP值随着弹出操作而增大，但每次操作完，SP总是指向栈顶。
目的操作数DST可以是通用寄存器和段寄存器（但CS例外），也可以是字存储单元。例如：
POP [SI]
POP VARW
VARW是字变量
POP ES
POP SI
下面的程序片段说明堆栈的一种用途，临时保存寄存器的内容：
PUSH DS
保护DS
PUSH CS
POP DS
使DS的内容与CS的内容相同
其他操作
POP DS
恢复DS
2.4.4标志操作指令
8086/8088指令集中，有一部分指令是专门对标志寄存器或标志位进行的，
包括四条标志寄存器传送指令和七条专门用于设置或清除某些标志位的指令。
1.标志传送指令
标志传送指令属于数据传送指令组。
（1）指令LAHF（Load AH with Flags）
指令LAHF采用固定寻址方式，指令格式如下：
LAHF
该条指令把标志寄存器的低8位（包括符号标志SF、零标志ZF、辅助进位标志AF、奇偶标志PF和进位标志CF）传送到寄存器AH的
指定位，即相应地传送至寄存器AH的位7、6、4、2和0，其他的位（位5、3和1）的内容无定义，如图2.16所示。
这条指令本身不影响这些标志和其他标志。
15 14 13 12 11 10  9  8   7   6   5   4  3  2  1  0
                    OF DF IF TF SF ZF       AF   PF     CF
（2）指令SAHF（Store AH into Flags）
指令SAHF采用固定寻址方式，其格式如下：
SAHF
该条指令与指令LAHF刚好相反，把寄存器AH的指定位送至标志寄存器低8位的SF、ZF、AF、PF和CF标志位。
因而这些标志的内容就要受到影响，并取决于AH中相应位的状态。
但这条指令不影响溢出标志OF、方向标志DF、中断允许标志IF和追踪标志TF，也即不影响标志寄存器的高位字节。例如：
MOV AH,0C1H
SAHF
CF=1，PF=0，AF=0，ZF=1，SF=1
（3）指令PUSHF
指令PUSHF的格式如下：
PUSHF
该条指令把标志寄存器的内容压入堆栈，即先把堆栈指针寄存器SP的值减2，然后把标志寄存器的内容送入由SP所指的栈顶。
这条指令不影响标志。
（4）指令POPF
指令POPF的格式如下：
POPF
该条指令把当前堆栈顶的一个字传送到标志寄存器，同时相应地修改堆栈指针，即把堆栈指针寄存器SP的值加2。
在执行该指令后，标志寄存器各位会发生相应变化。
这条指令和PUSHF指令一起可以保存和恢复标志寄存器的内容，即保存和恢复各标志的值。
另外，这两条指令也可以用来改变追踪标志TF。在8086/8088指令系统中，没有专门设置和清除TF标志的指令，
为了改变TF标志，可先用PUSHF指令将标志压入堆栈，然后设法改变栈顶字单元中的第8位（把整个标志寄存器看成是一个字），
再用POPF指令把该字弹回到标志寄存器，这样其余的标志不受影响，而只有TF标志按需要改变了。
2.标志位操作指令
标志位操作指令属于处理器控制指令组，它们仅对指令规定的标志产生指令规定的影响，对其他标志没有影响。
（1）清进位标志指令CLC（CLear Carry flag）
清进位标志指令的格式如下：
CLC
该条指令使进位标志为0。
（2）置进位标志指令STC（SeT Carry flag）
置进位标志指令的格式如下：
STC
该条指令使进位标志为1。
（3）进位标志取反指令CMC（CoMplement Carry flag）
进位标志取反指令的格式如下：
CMC
该条指令使进位标志取反。如CF为1，则使CF为0；如CF为0，则CF为1。
（4）清方向标志CLD（CLear Direction flag）
清方向标志指令的格式如下：
CLD
该条指令使方向标志DF为0。从而在执行串操作指令时，使地址按递增方式变化。
（5）置方向标志STD（SeT Direction flag）
置方向标志指令的格式如下：
STD
该条指令使方向标志DF为1。从而在执行串操作指令时，使地址按递减方式变化。
（6）清中断允许标志CLI（CLear Interrupt enable flag）
清中断允许标志指令的格式如下：
CLI
该条指令使中断允许标志IF为0，于是CPU就不响应来自外部装置的可屏蔽中断。但对不可屏蔽中断和内部中断都没有影响。
（7）置中断允许标志STI（SeT Interrupt enable flag）
置中断允许标志指令的格式如下：
STI
该条指令使中断允许标志IF为1，则CPU可以响应可屏蔽中断。
2.4.5加减运算指令
8086/8088提供加、减、乘和除四种基本算术运算操作。这些操作都可用于字节或字的运算，
也可以用于无符号数的运算或有符号数的运算。有符号数用补码表示。
加减运算指令不再分为无符号数运算指令和有符号数运算指令，而乘除运算指令还分为无符号数运算指令和有符号数运算指令。
另外，8086/8088还提供了各种十进制算术运算调整指令。
关于加减运算指令，有如下几点通用说明，请予以注意：
①加减运算指令对无符号数和有符号数的处理一视同仁。既作为无符号数而影响标志CF和AF，也作为有符号数影响标志OF和SF，
当然总会影响标志ZF。加减运算指令也要影响标志PF。有些指令稍有例外。
②可参与加减运算的操作数如图2.17所示。总是只有通用寄存器或存储单元可用于存放运算结果。
如果参与运算的操作数有两个，则最多只能有一个是存储器操作数。
③如果参与运算的操作数有两个，则它们的类型必须一致，即同时为字节，或同时为字。
④存储器操作数可采用2.3节中介绍的四种存储器操作数寻址方式。
1.加法指令
（1）普通加法指令ADD（ADDiton）
普通加法指令的格式如下：
ADD OPRD1，OPRD2
这条指令完成两个操作数相加，结果送至目的操作数OPRD1，即：
OPRD1=OPRD1+OPRD2 例如：
ADD AL,5
ADD AL,AH
ADD DI,DI
ADD BL,VARB
VARB是字节变量
ADD VARW,SI
VARW是字变量
ADD [BX+SI-3],AX
我们用下面的程序片段说明加法指令及其对标志的影响，同时说明8位数据寄存器与16位数据寄存器间的关系。
安排的注释用于说明对应指令执行完后受影响的寄存器和标志位的变化，为了便于说明，采用16进制的形式表示数据。
MOV AX,7896H
AX=7896H，即AH=78H，AL=96H
各标志位保持不变
ADD AL,AH
AL=0EH，AH=78H，即AX=780EH
CF=1，ZF=0，SF=0，OF=0，AF=0，PF=0
ADD AH,AL
AH=86H，AL=0EH，即AX=860EH
CF=0，ZF=0，SF=1，OF=1，AF=1，PF=0
ADD AL,0F2H
AL=00H，AH=86H，即AX=8600H
CF=1，ZF=1，SF=0，OF=0，AF=1，PF=1
ADD AX,1234H
AX=9834H，即AH=98，AL=34H
CF=0，ZF=0，SF=1，OF=0，AF=0，PF=0
在字节操作时，如发生低半字节向高半字节进位或借位；在字操作时，如发生低字节向高字节进位或借位，
则辅助进位标志AF被置1，否则AF被清0。
PF=1表示结果中的低八位1的个数为偶数
NV UP EI PL NZ NA PO NC
OF  DF    SF  ZF       PF   CF
下面列出Debug对我们已知的标志位的表示。
标志   值为1的标记 值为0的标记
of      OV               NV
sf      NG               PL
zf      ZR                NZ
pf     PE                 PO
cf     CY                 NC
df    DN                 UP
（2）带进位加指令ADC（ADd with Carry）
带进位加指令的格式如下：
ADC OPRD1，OPRD2
这条指令与ADD指令类似，完成两个操作数相加，但还要把进位标志CF的现行值加上去，把结果送至目的操作数OPRD1，即：
OPRD1=OPRD1+OPRD2+CF
例如：
ADC AL,[Sl]
ADC DX,AX
ADC DX,VARW
VARW是字变量
ADC指令主要用于多字节运算中。尽管在8086/8088中可以进行16位运算，但16位二进制数能表达的整数的范围还是很有限的，
为了扩大数的范围，仍然需要多字节运算。例如，有两个四字节的数相加，加法要分两次进行，先进行低两字节相加，
然后再做高两字节相加。在高两字节相加时，要把低两字节相加以后可能出现的进位考虑进去，用ADC指令实现这点很方便。
下面的程序片段实现两个四字节数相加，注意传送指令不影响标志：
MOV AX,FIRST1
FIRST1是存放第一个数低两字节的变量
ADD AX,SECOND1
SECOND1是存放第二个数低两字节的变量
MOV THIRD1,AX
保存低两字节相加的结果到THIRD1变量中
MOV AX,FIRST2
FIRST2是存放第一个数高两字节的变量
ADC AX,SECOND2
SECOND2是存放第二个数高两字节的变量
MOV THIRD2,AX
保存结果的高两字节到THIRD2变量中
（3）加1指令INC（INCrement）
加1指令的格式如下：
INC OPRD
这条指令完成对操作数OPRD加1，然后把结果送回OPRD，即：
OPRD=OPRD+1
例如：
INC AL
INC VARB
VARB是字节变量
操作数DST可以是通用寄存器，也可以是存储单元。这条指令执行的结果影响标志ZF、SF、OF、PF和AF，但它不影响CF。
该指令主要用于调整地址指针和计数器。
例，假设有100个16位无符号数存放在从1234：5678H开始的内存中，现需要求它们的和。
设把32位的和保存在DX（高位）和AX寄存器中。
下面的程序片段能实现上述功能：
……
MOV AX,1234H
MOV DS,AX
置数据段寄存器值
MOV SI,5678H
置指针初值
MOV AX,0
清32位累加和
MOV DX,AX
MOV CX,100
置数据个数计数器
NEXT:ADD AX,[SI]
求和
ADC DX,0
加上可能的进位
INC SI
调整指针
INC SI
DEC CX
计数器减1
JNZ NEXT
如果不为0，那么就继续累加下一个数据
.……
2.减法指令
（1）普通减法指令SUB（SUBtraction）
普通减法指令的格式如下：
SUB OPRD1，OPRD2
这条指令完成两个操作数相减，从OPRD1中减去OPRD2，结果送到目标操作数OPRD1中，即：
OPRD1=OPRD1-OPRD2
例如：
SUB AH,12
SUB BX,BP
SUB AL,[BX]
SUB BX,VARW
VARW是字变量
SUB [BP-2],AX
我们用下面的程序片段说明减法指令及其对标志的影响，同时再次说明8位数据寄存器与16位数据寄存器间的关系。
安排的注释用于说明对应指令执行完受影响的寄存器和标志位的变化，为了便于说明，还采用16进制的形式表示数据。
MOV BX,9048H
BX=9048H，即BH=90H，BL=48H
SUB BH,BL
BH=48H，BL=48H，即BX=4848H
CF=0，ZF=0，SF=0，OF=1，AF=1，PF=1
SUB BL,BH
BL=00H，BH=48H，即BX=4800H
CF=0，ZF=1，SF=0，OF=0，AF=0，PF=1
SUB BL,5
BL=FBH，BH=48H，即BX=48FBH
CF=1，ZF=0，SF=1，OF=0，AF=1，PF=0
SUB BX,8F34H
BX=B9C7H，即BH=B9H，BL=C7H
CF=1，ZF=0，SF=1，OF=1，AF=0，PF=0
（2）带进（借）位减指令SBB（SuBtract with Borrow）
带借位指令的格式如下：
SBBOPRD1，OPRD2
这条指令与SUB指令类似，在操作数OPRD1减去操作数OPRD2的同时还要减借位（进位）标志CF的现行值，即：
OPRD1=OPRD1-OPRD2-CF
例如：
SBB AL,DL
SBB DX,AX
该指令主要用于多字节数相减的场合。
（3）减1指令DEC（DECrement）
减1指令的格式如下：
DEC OPRD
这条指令把操作数OPRD减1，并把结果送回OPRD，即：
OPRD=OPRD-1
例如：
DEC BX
DEC VARB
VARB是字节变量
操作数OPRD可以是通用寄存器，也可以是存储单元。在相减时，把操作数作为一个无符号数对待。
这条指令执行的结果影响标志ZF、SF、OF、PF和AF，但它不影响CF。
该指令主要用于调整地址指针和计数器。
（4）取补指令NEG（NEGate）
取补指令的格式如下：
NEG OPRD
这条指令对操作数取补，就是用零减去操作数OPRD，再把结果送回OPRD，也即：
OPRD=0-OPRD例如：
NEG AL
NEG VARW[SI]
有效地址是变量VARW的位移加SI的值
如在字节操作时对-128取补，或在字操作时对-32768取补，则操作数没有变化，但OF被置位。
操作数可以是通用寄存器，也可以是存储单元。此指令的执行结果影响CF、ZF、SF、OF、AF和PF，
一般总使CF为1，除非操作数为0。
当操作数为0时，置CF位为0
当操作数不为0时，置CF位为1
（5）比较指令CMP（CoMPare）
比较指令的格式如下：
CMP OPRD1，OPRD2
这条指令完成操作数OPRD1减去操作数OPRD2，运算结果不送到OPRD1，但影响标志CF、ZF、SF、OF、AF和PF。例如：
CMP SI,DI
CMP CL,5
CMP DX,[BP-4]
比较指令主要用于比较两个数的关系，是否相等，谁大谁小。
在执行了比较指令后，可根据ZF是否置位，判断两者是否相等；
如果两者是无符号数，则可根据CF判断大小；
如果两者是有符号数，则要根据SF和OF判断大小。
例，设有两个64位数按“高高低低”原则存放同一个段的两个缓冲区DATA1和DATA2中，现需要计算DATA1-DATA2。
下面的程序片段计算DATA1-DATA2，结果存放在DATA1中，可能发生的借位保留在CF中：
……
MOV CX,4
64位分成4个字
SUB BX,BX
清指针，同时清CF
NEXT:MOV AX,DATA2[BX]
取减数
SBB DATA1[BX],AX
带借位减
INC BX
调整指针
INC BX
DEC CX
是否已处理完4个字？
JNZ NEXT
没完继续
……
2.4.6乘除运算指令
8086/8088除了提供加减运算指令外，还提供乘除运算指令。
乘除运算指令分为无符号数运算指令和有符号数运算指令，这点与加减运算指令不同。
乘除运算指令对标志位的影响有些特别，不像加减运算指令对标志位的影响那样自然。
1.乘法指令
在乘法指令中，一个操作数总是隐含在寄存器AL（8位数相乘）或者AX（16位数相乘）中，
另一个操作数可以采用除立即数方式以外的任一种寻址方式。
（1）无符号数乘法指令MUL（MULtiply）无符号指令的格式如下：
MUl OPRD
如果OPRD是字节操作数，则把AL中的无符号数与OPRD相乘，16位结果送到AX中；
如果OPRD是字操作数，则把AX中的无符号数与OPRD相乘，32位结果送到DX和AX对中，DX含高16位，AX含低16位。
所以由操作数OPRD决定是字节相乘，还是字相乘。例如：
MUL BL
MUL AX
MUL VARW
VARW是字变量
如果乘积结果的高半部分（字节相乘时为AH，在字相乘时为DX）不等于零，则标志CF=1，OF=1；否则CF=0，OF=0。
所以如果CF=1和OF=1表示在AH或DX中含有结果的有效数。该指令对其他标志位无定义。
（2）有符号数乘法指令IMUL（slgned MULtiply）
有符号数乘指令的格式如下：
IMUL OPRD
这条指令把被乘数和乘数均作为有符号数，此外与指令MUL完全类似。例如：
IMUL CL
IMUL DX
IMUL VARW
VARW是字变量
如果乘积结果的高半部分（字节相乘时为AH，在字相乘时为DX）不是低半部分的符号扩展，则标志CF=1，OF=1；
否则CF=0，OF=0。所以如果CF=1和OF=1表示在AH或DX中含有结果的有效数。该指令对其他标志位无定义。
2.除法指令
在除法指令中，被除数总是在隐含在寄存器AX（除数是8位）或者DX和AX（除数是16位）中，
另一个操作数可以采用除立即数方式外的任一种寻址方式。
（1）无符号数除法指令DIV（DIVision）
无符号数除法指令的格式如下：
DIV OPRD
如果OPRD是字节操作数，则把AX中的无符号数除以OPRD，8位的商送到AL中，8位的余数送到AH；
如果OPRD是字操作数，则把DX（高16位）和AX中的无符号数除以OPRD，16位的商送到AX，16位的余数送到DX中。
所以由操作数OPRD决定是字节除，还是字除。例如：
DIV BL
DIV SI
DIV VARW
VARW是字变量
注意：如果除数为0，或者在8位数除时商超过8位，或者在16位除时商超过16位，则认为是除法溢出，引起0号中断。
除法指令对标志位的影响无定义。
（2）有符号数除法指令IDIV（sIgned DIVision）
有符号数除法指令的格式如下：
IDIV OPRD
这条指令把被除数和除数均作为有符号数，此外与指令DIV完全类似。
例如：
IDIV CX
IDIV VARW
VARW是字变量
当除数为0，或者商太大（字节除时超过127，字除时超过32767），或者商太小（字节除时小于-127，字除时小于-32767）时，
则引起0号中断。
3.符号扩展指令
由于除法指令隐含使用字被除数或双字被除数，所以当被除数为字节，或者除数和被除数均为字时，需要在除操作前扩展被除数。
为此8086/8088专门提供了符号扩展指令。
（1）字节转换为字指令CBW（Convert Byte to Word）
字节转换为字指令的格式如下：
CBW
这条指令把寄存器AL中的符号扩展到寄存器AH。即若AL的最高有效位为0，则AH=0；若AL的最高有效位为1，则AH=0FFH。
例如：
MOV AX,3487H
AX=3487H，即AH=34H，AL=87H
CBW
AH=0FFH，AL=87H，即AX=0FF87H
这条指令能在两个字节相除以前，产生一个字长度的被除数。这条指令不影响各标志位。
（2）字转换为双字指令CWD（Convert Word to Double word）
字转换为双字指令的格式如下：
CWD
这条指令把寄存器AX中的符号扩展到寄存器DX。
即若（AX）的最高有效位为0，则DX=0；若AX的最高有效位为1，则DX=0FFFFH。
例如：
MOV AX,4567H
AX=4567H
CWD
AX=4567H，DX=0
这条指令能在两个字相除以前，产生一个双字长度的被除数。该指令不影响各标志位。
注意：在无符号数除之前，不宜用CBW或CWD指令扩展符号位，一般采用XOR指令清高8位或高16位。
例，计算如下表达式的值：
（X*Y+Z-1024）/75
假设其中的X、Y和Z均为16位带符号数，分别存放在名为XXX、YYY和ZZZ的变量单元中。
再假设计算结果的商保存在AX中，余数保存在DX中。
下面的程序片段能够满足要求：
……
MOV AX,XXX
IMUL YYY
计算X*Y
MOV CX,AX
MOV BX,DX
积保存到BX:CX中
MOV AX,ZZZ
CWD
把ZZZ扩展成32位
ADD AX,CX
再计算和
ADC DX,BX
SUB AX,1024
再计算差
SBB DX,0
MOV CX,75
IDIV CX
最后计算商和余数
……
2.4.7逻辑运算和移位指令
这组指令包括逻辑运算、移位和循环移位指令三部分。逻辑运算指令除指令NOT外，均有两个操作数。
移位和循环移位指令只有一个操作数。关于这组指令有如下几点通用说明，请予以注意：
①如果指令有两个操作数，那么这两个操作数也可如图2.17所示结合。但最多只能有一个为存储器操作数。
②只有通用寄存器或存储器操作数可作为目的操作数，用于存放运算结果。
③如果只有一个操作数，则该操作数既是源又是目的。
④操作数可以是字节，也可以是字。但如果有两个操作数，则它们的类型必须一致，即同时为字节，或同时为字。
⑤对于存储器操作数可采用2.3节中介绍的四种存储器操作数寻址方式。
1.逻辑运算指令
（1）否操作指令NOT
否操作指令的格式如下：
NOT OPRD
这条指令把操作数OPRD取反，然后送回OPRD。
例如：
NOT AX
NOT VARB
VARB是字节变量
操作数OPRD可以是通用寄存器，也可以是存储器操作数。此指令对标志没有影响。
（2）与操作指令AND
与操作指令的格式如下：
AND OPRD1，OPRD2
这条指令对两个操作数进行按位的逻辑“与”运算，结果送到目的操作数OPRD1。
例如：
AND DH,DH
AND AX,ES:[SI]
该指令执行以后，标志CF=0，标志OF=0，标志PF、ZF、SF反映运算结果，标志AF未定义。
某个操作数自己与自己相“与”，则值不变，但可使进位标志CF清0。
与操作指令主要用在使一个操作数中的若干位维持不变，而另外若干位清为0的场合。
把要维持不变的这些位与“1”相“与”，而把要清为0的这些位与“0”相“与”就能达到这样的目的。
例如：
MOV AL,34H
AL=34H
AND AL,0FH
AL=04H
（3）或操作指令OR
或操作指令的格式如下：
OR OPRD1，OPRD2
这条指令对两个操作数进行按位的逻辑“或”运算，结果送到目的操作数OPRD1。
例如：
OR AX,8080H
OR CL,AL
OR [BX-3],AX
OR指令执行以后，标志CF=0，标志OF=0，标志PF、ZF、SF反映运算结果，标志AF未定义。
某个操作数自己与自己相“或”，则值不变，但可使进位标志CF清0。
或操作指令主要用在使一个操作数中的若干位维持不变，而另外若干位置为1的场合。
把要维持不变的这些位与“0”相“或”，而把要置为1的这些位与“1”相“或”就能达到这样的目的。
例如：
MOV AL,41H
AL=01000001B，B表示二进制
OR AL,20H
AL=01100001B
（4）异或操作指令XOR
异或指令的格式如下：
XOR OPRD1，OPRD2
这条指令对两个操作数进行按位的逻辑“异或”运算，结果送到目的操作数OPRD1。
该指令执行以后，标志CF=0，标志OF=0，标志PF、ZF、SF反映运算结果，标志AF未定义。
某个操作数自己与自己相“异或”，则结果为0，并可使进位标志CF清0。例如：
XOR DX,DX
DX=0，CF=0
异或操作指令主要用在使一个操作数中的若干位维持不变，而另外若干位置取反的场合。
把要维持不变的这些位与“0”相“异或”，而把要取反的这些位与“1”相“异或”就能达到这样的目的。例如：
MOV AL,34H
AL=00110100B，符号B表示二进制
XOR AL,0FH；AL=00111011B
（5）测试指令TEST
测试指令的格式如下：
TEST OPRD1，OPRD2
这条指令和指令AND类似，也把两个操作数进行按位“与”，但结果不送到操作数OPRD1，仅仅影响标志。
该指令执行以后，标志ZF、PF和SF反映运算结果，标志CF和OF被清0。
该指令通常用于检测某些位是否为1，但又不希望改变原操作数值的场合。
例如，要检查AL中的位6或位2是否有一位为1，可使用如下的指令：
TEST AL，01000100B
符号B表示二进制如果位6和位2全为0，那么在执行上面的指令后，ZF被置1，否则ZF被清0。
2.一般移位指令
8086/8088有三条一般移位指令：算术左移/逻辑左移指令，算术右移指令，逻辑右移指令。这三条指令的一般格式如下：
SAL OPRD,m
算术左移指令（同逻辑左移指令）
SHL OPRD,m
逻辑左移指令
SAR OPRD,m
算术右移指令
SHR OPRD,m
逻辑右移指令
其中，m是移位位数，或为1或为CL，当要移多个位时，移位位数需存放在CL寄存器中。
操作数OPRD可以是通用寄存器，也可以是存储器操作数。
标志PF、SF和ZF反映移位后的结果。标志OF也受影响，但标志AF未定义。
（1）算术左移或逻辑左移指令SAL/SHL（Shift Arithmetic Left 或 SHift logic Left）
算术左移和逻辑左移进行相同的动作，尽管为了方便提供有两个助记符，但只有一条机器指令。具体格式如下：
SAl OPRD，m或者
SHL OPRD，m
算术左移SAL/逻辑左移SHL指令把操作数OPRD左移m位，每移动一位，右边用0补足一位，移出的最高位进入标志位CF。
如图2.18（a）所示。
下面的程序片段用于说明该指令的使用及其对标志位的影响，安排的注释给出了指令执行完后的操作数值和受影响的标志变化情况。
MOV AL,8CH
AL=8CH
SHL AL,1
AL=18H，CF=1，PF=1，ZF=0，SF=0，OF=1
MOV CL,6
CL=6
SHL AL,CL
AL=0，CF=0，PF=1，ZF=1，SF=0，OF=0
只要左移以后的结果未超出一个字节或一个字的表达范围，那么每左移一次，原操作数每一位的权增加了一倍，
也即相当于原数乘2。下面的程序片段实现把寄存器AL中的内容（设为无符号数）乘10，结果存放在AX中。
XOR AH,AH
（AH）=0
SHL AX,1
2X
MOV BX,AX
暂存2X
SHL AX,1
4X
SHL AX,1
8X
ADD AX,BX
8X+2X
（2）算术右移指令SAR（Shift Arithmetic Right）
算术右移指令的格式如下：
SAR OPRD，m
该指令使操作数右移m位，同时每移一位，左边的符号位保持不变，移出的最低位进入标志位CF。如图2.18（b）所示。
例如：
SAR AL,1
SAR BX,CL
对于有符号数和无符号数而言，算术右移一位相当于除以2。
（3）逻辑右移指令SHR（SHift logic Right）
逻辑右移指令的格式如下：
SHR OPRD，m
该指令使操作数右移m位，同时每移一位，左边用0补足，移出的最低位进入标志位CF。如图2.18（c）所示。例如：
SHR BL,1
SHR AX,CL
对于无符号数而言，逻辑右移一位相当于除以2。
在汇编语言程序设计中，经常需要对以位为单位的数据进行合并和分解处理。
一般通过移位指令和逻辑运算指令进行这种数据的合并和分解处理。
例，假设DATA1和DATA2各长4位，分别存放在AL寄存器的低4位和高4位中，
现要把它们分别存放到BL寄存器和BH寄存器的低4位中。
下面的程序片段能实现上述要求：
……
MOV BL,AL
AND BL,0FH
得DATA1
MOV BH,AL
得DATA2
MOV CL,4
SHR BH,CL
……
3.循环移位指令
8086/8088有四条循环移位指令：左循环移位指令ROL（ROtate Left），右循环移位指令ROR（ROtate Right），
带进位左循环移位指令RCL（Rotate Left throughCF），带进位右循环移位指令RCR（Rotate Right throughCF）。
这些指令可以一次只移一位，也可以一次移多位。如移多位，那么移位次数存放在CL寄存器中。
这些指令的格式如下：
ROL OPRD，m
ROR OPRD，m
RCL OPRD，m
RCR OPRD，m
其中，m是移位次数，或为1或为CL。操作数OPRD可以是通用寄存器，也可以是存储器操作数。
前两条循环指令没有把进位标志位CF包含在循环的环中；
后两条循环指令把进位标志CF包含在循环的环中，即作为整个循环的一部分。四条循环指令的操作如图2.19所示。
这些指令只影响标志CF和OF。
左循环移位指令ROL，它每移位一次，操作数左移，其最高位移入最低位，同时最高位也移入进位标志CF。
右循环移位指令ROR，它每移位一次，操作数右移，其最低位移入最高位，同时最低位也移入进位标志CF。
带进位左循环移位指令RCL，它每移位一次，操作数左移，其最高位移入进位标志CF，CF移入最低位。
带进位右循环移位指令RCR，它每移位一次，操作数右移，其最低位移入进位标志CF，CF移入最高位。
对于不带进位的循环移位指令而言，如果操作数是8位，那么在移位8次后，操作数就能复原；
如果操作数是16位，那么在移位16次后，操作数就能复原。
对于带进位的循环移位指令而言，如果操作数是8位，那么在移位9次后，操作就能复原；
如果操作是16位，那么在移位17次后，操作就能复原。例如：
MOV CL,9
RCR AL,CL
通过带进位循环移位指令和其他移位指令的结合，可以实现两个或多个操作数的重新结合。
例，下面的程序片段实现把AL的高4位与低4位交换：
ROL AL,1
ROL AL,1
ROL AL,1
ROL AL,1
例，下面的程序片段实现把AL的最低位送入BL的最低位，仍保持AL不变：
ROR BL,1
ROR AL,1
RCL BL,1
ROL AL,1
例，设DATA1存放在AL的低4位，DATA2存放在AH的低4位，DATA3存放在SI的低4位，DATA4存放在SI的高4位。
现要把这四个数据合并为16位，并存放到DX寄存器中。存放要求如下所示。
DH DATA1->DATA2
DL DATA3->DATA4
实现上述功能的程序片段如下：
把DATA1送到DH的高4位，即DX的高4位
MOV DH,AL
MOV CL,4
SHL DH,CL
把DATA2送到DH的低4位，即DX的位11至位8
AND AH,0FH
OR DH,AH
把DATA4送到DL的低4位，即DX的低4位，同时DATA3送到AL的高4位
MOV AX,SI
SHL AX,1
RCL DL,1
SHL AX,1
RCL DL,1
SHL AX,1
RCL DL,1
SHL AX,1
RCL DL,1
把DATA3送到DL的高4位，即DX的位7至位4
AND DL,0FH
OR DL,AL
DATA1存放在AL的低4位，DATA2存放在AH的低4位，DATA3存放在SI的低4位，DATA4存放在SI的高4位。
现要把这四个数据合并为16位，并存放到DX寄存器中。存放要求如下所示。
DH DATA1->DATA2
DL DATA3->DATA4
下面的程序片段，也能实现上述功能，请比较之：
把DATA1与DATA2合并，存放到DH
MOV CL,4
ROL AL,CL
AND AX,0FF0H
MOV DH,AH
OR DH,AL
把DATA3与DATA4合并，存放到DL
MOV AX,SI
ROR AX,CL
MOV DL,AH
……
2.4.8转移指令
8086/8088提供了大量用于控制程序流程的指令，按功能可分成如下四类：
（1）无条件转移指令和条件转移指令；
（2）循环指令；
（3）过程调用和过程返回指令；
（4）软中断指令和中断返回指令。
由于程序代码可分为多个段，所以根据转移时是否重置代码段寄存器CS的内容，它们又可分为段内转移和段间转移两大类。
段内转移是指仅重新设置指令指针IP的转移，由于没有重置CS，所以转移后继续执行的指令仍在同一个代码段中。
条件转移指令和循环指令只能实现段内转移。段间转移是指不仅重新设置IP，而且重新设置代码段寄存器CS的转移，
由于重置CS，所以转移后继续执行的指令在另一个段中。软中断指令和中断返回指令总是段间转移。
无条件转移指令和过程调用及返回指令既可以是段内转移，也可以是段间转移。
段内转移也称为近转移，而段间转移也称为远转移。
对无条件转移指令和过程调用指令而言，按确定转移目的地址的方式还可分为直接转移和间接转移两种。
下面介绍无条件转移指令、条件转移指令和循环指令。这些指令均不影响标志。
1.无条件转移指令
（1）无条件段内直接转移指令
无条件段内直接转移指令的使用格式如下：
JMP 标号
这条指令使控制无条件地转移到标号地址处。例如：
NEXT:MOV AX,CX
...
JMP NEXT
转NEXT处
.....
JMP OVER
转OVER处
……
OVER:MOV AX,1
无条件段内直接转移指令对应的机器指令格式如下，由操作码和地址差值构成。
指令操作码 地址差
其中的地址差是程序中该无条件转移指令的下一条指令的开始地址到转移目标地址（标号所指定指令的开始地址）的差值，
由汇编程序在汇编时计算得出。因此，在执行无条件段内转移指令时，实际的动作是把指令中的地址差加到指令指针IP上，
使IP之内容为目标地址，从而达到转移的目的。图2.20是无条件段内转移指令的存储和执行示意图。
请注意，指令中的地址差值由汇编程序计算得出。
段内无条件直接转移指令中的地址差可用一个字节表示，也可用一个字表示。
如果地址差只要用一个字节表示，就称为短转移；
如果地址差要用一个字表示，就称为近转移。
一个字节表示的地址差的范围是-128至+127，所以，如果以转移指令本身为基准，那么短转移的范围则在-126至+129之间。
一个字表示的地址差的范围是0至65535，当IP与地址差之和超过65535时，那么便在段内反饶（即取65536的模），
所以，近转移的范围是整个段。
如果当汇编程序汇编到该转移指令时能够正确地计算出地址差，那么汇编程序就根据地址差的大小，
决定使用一个字节表示地址差，还是使用一个字表示地址差。
例如，上例中的“JMP NEXT”指令。如果当汇编程序汇编到该指令时还不能计算出地址差，
那么汇编程序就按两字节地址差汇编此转移指令。例如，上例中的“JMP OVER”指令。
对于后一种情况，如果程序员在写程序时能估计出用一字节就可表示地址差，那么可在标号前加一个汇编程序操作符SHORT，
例如：JMP SHORT OVER
这样汇编程序就按一字节的地址差汇编此转移指令。当实际的地址差无法用一个字节表示时，
汇编程序会发出汇编出现错误的提示信息。
这种利用目标地址与当前转移指令本身地址之间的差值记录转移目标地址的转移方式也称为相对转移。
相对转移有利于程序的浮动。
（2）无条件段内间接转移指令
无条件段内间接转移指令的格式如下：
JMP OPRD
这条指令使控制无条件地转移到由操作数OPRD的内容给定的目标地址处。操作数OPRD可以是通用寄存器，也可以是字存储单元。例如：
JMP CX
CX寄存器的内容送IP
JMP WORD PTR [1234H]
字存储单元[1234H]的内容送IP
图2.21给出了上述指令的存储和执行示意图。其中假设当前数据段偏移1234H处字单元的内容是5678H。
（3）无条件段间直接转移指令
无条件段间直接转移指令的使用格式如下：
JMP FAR PTR 标号
这条指令使控制无条件地转移到标号所对应的地址处。标号前的符号“FAR PTR”向汇编程序说明这是段间转移。
只有当标号具有远属性，且标号处的指令已先被汇编的情况下，才可省去远属性的说明“FAR PTR”。
例如：
JMP FAR PTR EXIT
EXIT是定义在另一个代码段中的标号无条件段间直接转移指令的机器指令格式如下，由操作码及包括段值和偏移的地址构成。
指令操作码 目标地址偏移 目标地址段值
无条件段间直接转移指令的具体动作是把指令中包含的目标地址的段值和偏移分别置入CS和IP。
这种在指令中直接包含转移目标地址的转移方式称为绝对转移。
（4）无条件段间间接转移指令
无条件段间间接转移指令的格式如下：
JMP OPRD
这条指令使控制无条件地转移到由操作数OPRD的内容给定的目标地址处。操作数OPRD必须是双字存储单元。例如：
JMP DWORD PTR [1234H]
双字存储单元的低字内容送IP 双字存储单元的高字内容送CS
2.条件转移指令
8086/8088提供了大量的条件转移指令，它们根据某标志位或某些标志位的逻辑运算来判别条件是否成立。
如果条件成立，则转移，否则继续顺序执行。
所有条件转移都只是段内转移。
条件转移也采用相对转移方式。即通过在IP上加一个地址差的方法实现转移。
但条件转移指令中只用一个字节表示地差，所以，如果以条件转移指令本身作为基准，那么条件转移的范围在-126至+129之间。
如果条件转移的目标超出此范围，那么必须借助于无条件转移指令。
条件转移指令不影响标志。
条件转移指令的格式列于表2.3中，有些条件转移指令有两个助记符，还有些条件转移指令有三个助记符。
使用多个助记符的目的是便于记忆和使用。
表2.3条件转移指令
指令格式     转移条件     转移说明        其他说明
JZ 标号        ZF=1          等于0转移     单个标志
JE 标号        ZF=1          相等转移
JNZ 标号     ZF=0          不等于0转移  单个标志
JNE 标号     ZF=0          不相等转移
JS 标号       SF=1           为负转移
JNS 标号    SF=0           为正转移        单个标志
JO 标号      OF=1         溢出转移         单个标志
JNO 标号   OF=0         不溢出转移      单个标志
JP 标号      PF=1          偶转移             单个标志
JPE 标号    PF=1
JNP 标号   PF=0          奇转移             单个标志
JPO 标号   PF=0
JB 标号      CF=1         低于转移          单个标志
JNAE 标号 CF=1         不高于等于转移
JC 标号      CF=1         进位标志被置转移
JNB 标号    CF=0        不低于转移       单个标志
JAE 标号    CF=0         高于等于转移
JNC 标号   CF=0         进位标志被清转移
JBE  标号（CF或ZF）=1 低于等于转移 两个标志
JNA 标号（CF或ZF）=1 不高于转移
JNBE 标号（CF或ZF）=0 不低于等于转移 两个标志
JA 标号    （CF或ZF）=0  高于转移
JL 标号     （SF异或OF）=1 小于转移 两个标志
JNGE 标号（SF异或OF）=1 不大于等于转移
JNL标号   （SF异或OF）=0 不小于转移 两个标志
JGE 标号 （SF异或OF）=0  大于等于转移
JLE 标号（（SF异或OF）或ZF）=1  小于等于转移 三个标志
JNG标号（（SF异或OF）或ZF）=1 不大于转移
JNLE 标号（（SF异或OF）且ZF）=0 不小于等于转移 三个标志
JG标号    （（SF异或OF）且ZF）=0  大于转移
条件转移指令是用得最多的转移指令。通常，在条件转移指令前，总有用于条件判别的有关指令。
下面的程序片段测试AX的低四位是否全是0，如果均是0，那么使CX=0，否则使CX=-1。
MOV CX,-1
先使CX=-1
TEST AX,0FH
测试AX的低4位
JNZ NZERO
不全为0则转移
MOV CX,0
全为0时使CX=0
NZERO:
……
从表2.3中可见，无符号数之间大小比较后的条件转移指令和有符号数之间的大小比较后的条件转移指令有很大不同。
有符号数间的次序关系称为大于（G）、等于（E）和小于（L）；
无符号数间的次序关系称为高于（A）、等于（E）和低于（B）。
所以，在使用时要注意区分它们，不能混淆。
下面的程序片段实现两个无符号数（设在AX和BX中）的比较，把较大的数存放到AX中，把较小的数存放在BX中：
CMP AX,BX
JAE OK
无符号数比较大小转移
XCHG AX,BX
OK:
……
如果要比较的两个数是有符号数，则可用下面的程序片段：
CMP AX,BX
JGE OK
有符号数比较大小转移
XCHG AX,BX
OK:
……
从表2.3中可见，无符号数之间大小比较后的条件转移指令和有符号数之间的大小比较后的条件转移指令测试的标志完全不同。
不论无符号数还是有符号数，两数是否相等可由ZF标志反映。
当两个无符号数相减时，CF位的情况说明了是否有借位。
因此进位标志CF反映两个无符号数比较后的大小关系，所以用于无符号数比较后的条件转移指令（如JB和JAE等）检测标志CF，
以判别条件是否成立。但进位标志CF不能反映两个有符号数比较后的大小关系。
两个有符号数比较后的大小关系由符号标志SF和溢出标志OF一起来反映。
所以用于有符号数比较后的条件转移指令（如JL和JGE等）检测标志SF和OF，以判别条件是否成立。
设要比较的两个不相等的有符号数a和b分别存放在寄存器AX和BX中，执行指令“CMP AX,BX”后，
标志SF及OF的设置情况和两数的大小情况如下：
当没有溢出（OF=0）时，若SF=0，则a>b若SF=1，则a<b
当产生溢出（OF=1）时，若SF=0，则a<b若SF=1，则a>b
据此可推断出表2.3中用于有符号数比较后的条件转移指令所测试的条件。
3.循环指令
利用条件转移指令和无条件转移指令可以实现循环，但为了更加方便于循环的实现，
8086/8088还提供了四条用于实现循环的循环指令。
循环指令类似于条件转移指令，不仅属于段内转移，而且也采用相对转移的方式，即通过在IP上加一个地址差的方式实现转移。
循环指令中也只用一个字节表示地址差，所以，如果以循环指令本身作为基准，那么循环转移的范围在-126至+129之间。
循环指令不影响各标志。
（1）计数循环指令LOOP
计数循环指令的格式如下：
LOOP 标号
这条指令使寄存器CX的值减1，如果结果不等于0，则转移到标号，否则顺序执行LOOP指令后的指令。
该指令类似于如下的两条指令：
DEC CX
JNZ 标号
通常在利用LOOP指令构成循环时，先要设置好计数器CX的初值，即循环次数。
由于首先进行CX寄存器减1操作，再判结果是否为0，所以最多可循环65536次。
如下程序片段实现把从偏移1000H开始的512个字节的数据复制到从偏移3000H开始的缓冲区中（假设在当前数据段中进行移动）：
MOV Sl,1000H
置源指针
MOV Dl,3000H
置目标指针
MOV CX,512
置计数初值
NEXT:MOV AL,[SI]
INC SI
MOV [DI],AL
INC DI
LOOP NEXT
控制循环
.……
（2）等于/全零循环指令LOOPE/LOOPZ
等于/全零循环指令有两个助记符，格式如下：
LOOPE 标号
或者
LOOPZ 标号
这条指令使寄存器CX的值减1，如果结果不等于0，并且零标志ZF等于1，那么则转移到标号，否则顺序执行。
注意指令本身实施的寄存器CX减1操作不影响标志。如下的程序片段在字符串中查找第一个非’A'字符。
设字符串长度已保存在CX中，并且DS:DI指向字符串。如果找到，那么使BX指向该非’A'字符，如果找不到，那么使BX=0FFFFH。
......
MOV AL,'A'
DEC DI
NEXT:INC DI
CMP AL,[DI]
LOOPE NEXT
MOV BX,DI
JNE OK
MOV BX,-1
OK:
……
（3）不等于/非零循环指令LOOPNE/LOOPNZ
不等于/非零循环指令有两个助记符，格式如下：
LOOPNE 标号
LOOPNZ 标号
这条指令使寄存器CX的值减1，如果结果不等于0，并且零标志ZF等于0，那么则转移到标号，否则顺序执行。
注意指令本身实施的寄存器CX减1操作不影响标志。
（4）跳转指令JCXZ跳转指令也可以认为是条件转移指令。跳转指令的格式如下：
JCXZ 标号
该指令实现当寄存器CX的值等于0时转移到标号，否则顺序执行。
通常该指令用在循环开始前，以便在循环次数为0时，跳过循环体。
例如：.……
JCXZ OK
如果循环计数为0，就跳过循环
NEXT:
……
循环体
.……
LOOP NEXT
根据计数控制循环
OK:
……
2.5习题
题2.1 8086/8088通用寄存器的通用性表现在何处？8个通用寄存器各自有何专门用途？
哪些寄存器可作为存储器寻址方式的指针寄存器？
答：8086/8088通用寄存器的通用性表现在：
    这些寄存器除了各自规定的专门用途外，他们均可以用于传送和暂存数据，可以保存算术逻辑运算中的操作数和运算结果；
    8个通用寄存器的专门用途如下：
    AX 字乘法，字除法，字I/O
    BX 存储器指针
    CX 串操作或循环控制中的计数器
    DX 字乘法，字除法，间接I/O
    SI 存储器指针（串操作中的源指针）
    DI 存储器指针（串操作中的目的指针）
    BP 存储器指针（存取堆栈的指针）
    SP 堆栈指针
    其中BX，SI，DI，BP可作为存储器寻址方式的指针寄存器
题2.2  从程序员的角度看，8086/8088有多少个可访问的16位寄存器？有多少个可访问的8位寄存器？
答：   从程序员的角度看，8086/8088有14个可访问的16位寄存器；有8个可访问的8位寄存器；
四个16位数据寄存器
AH AL  AX
BH BL  BX
CH CL  CX
DH DL DX
两个16位指针寄存器
SP 堆栈指针
BP 基址指针
两个16位变址寄存器
Sl 源地址
DI 目的地址
一个16位指令指针
IP 指令指针
一个16位标志寄存器
FLAG 标志寄存器
四个16位段寄存器
CS 代码段
DS 数据段
SS 堆栈段
ES 附加段
题2.3  寄存器AX与寄存器AH和AL的关系如何？请写出如下程序片段中每条指令执行后寄存器AX的内容：
AH寄存器就是AX寄存器的高8位，AL寄存器就是AX寄存器的低8位。AH寄存器和AL寄存器的合并就是AX寄存器。
答：  MOV AX,1234H        AX=1234H
      MOV AL,98H          AX=1298H
      MOV AH,76H          AX=7698H
      ADD AL,81H          AX=7619H
      SUB AL,35H          AX=76E4H
      ADD AL,AH           AX=765AH
      ADC AH,AL           AX=D15AH
      ADD AX,0D2H         AX=D22CH
      SUB AX,0FFH         AX=D12DH
题2.4  8086/8088标志寄存器中定义了哪些标志？这些标志可分为哪两类？如何改变这些标志的状态？
定义了9个标志CF ZF SF OF PF AF DF IF TF
第一组6个标志主要受加减运算和逻辑运算结果的影响，称为运算结果标志，
第二组标志不受运算结果的影响，称为状态控制标志。
指令SAHF把寄存器AH的指定位送至标志寄存器低8位的SF、ZF、AF、PF和CF标志位。
指令POPF把当前堆栈顶的一个字传送到标志寄存器，在执行该指令后，标志寄存器各位会发生相应变化。
清进位标志指令CLC（CLear Carry flag）
置进位标志指令STC（SeT Carry flag）
进位标志取反指令CMC（CoMplement Carry flag）
清方向标志CLD（CLear Direction flag）
置方向标志STD（SeT Direction flag）
清中断允许标志CLI（CLear Interrupt enable flag）
置中断允许标志STI（SeT Interrupt enable flag）
某些指令执行过程中会改变部分标志的状态；
题2.5  请说说标志CF和标志OF的差异。
进位标志CF用于反映运算是否产生进位或借位。
如果运算结果的最高位（字操作时的第15位或字节操作时的第7位）产生一个进位或借位，则CF被置1，否则CF被清0。
溢出标志OF用于反映有符号数加减运算是否引起溢出。如运算结果超出了8位或16位有符号数的表示范围，
即在字节运算时大于127或小于-128，在字运算时大于32767或小于-32768，称为溢出。如果溢出，则OF被置1，否则OF被清0。
题2.6  8086/8088如何寻址1M字节的存储器物理地址空间？在划分段时必须满足的两个条件是什么？
最多可把1M字节空间划分成几个段？最少可把1M字节地址空间划分成几个段？
8086/8088通过对存储器分段和使用段寄存器的方法寻址1M字节物理空间。
把1M字节地址空间划分成若干逻辑段。每个逻辑段必须满足如下两个条件：第一，逻辑段的开始地址必须是16的倍数；
第二，逻辑段的最大长度为64K。
按照这两个条件，1M字节地址空间最多可划分成64K个逻辑段(段的长度为16)，最少也要划分成16个逻辑段(段的长度为64K)。
题2.7  在8086/8088上运行的程序某一时刻最多可访问几个段？程序最多可具有多少个段？程序至少几个段？
8086/8088CPU有四个段寄存器（代码段寄存器CS 堆栈段寄存器SS 数据段寄存器DS 附加段寄存器ES），保存四个段值，
所以最多可访问四个段，程序最多可具有4种类型的段，至少要有一个代码段；
题2.8  存储单元的逻辑地址如何表示？存储单元的20位物理地址如何构成？
存储单元的逻辑地址由段值和偏移两部分组成，用如下形式表示：段值：偏移
根据逻辑地址可方便地得到存储单元的物理地址，计算公式如下：物理地址=段值×16+偏移
题2.9  当段重叠时，一个存储单元的地址可表示成多个逻辑地址。请问物理地址12345H可表示多少个不同的逻辑地址？
偏移最大的逻辑地址是什么？偏移最小的逻辑地址是什么？
答：   12345H可表示1000H（4096）个不同的逻辑地址，偏移最大的逻辑地址是235:0FFF5H
       偏移最小的逻辑地址是1234:0005H
题2.10 为什么称CS为代码段寄存器？为什么称SS为堆栈寄存器？
在取指令的时候，自动引用段寄存器CS，再加上由IP所给出的16位偏移，得到要取指令的物理地址。
当涉及到一个堆栈操作时，则自动引用段寄存器SS，再加上由SP所给出的16位偏移，得到堆栈操作所需的物理地址。
题2.11 请举例说明何为段前缀超越。什么场合下要使用段前缀超越？
在存取一般存储器操作数时，段寄存器可以不一定是DS；当偏移涉及BP寄存器时，段寄存器也不是非要为SS。
使用段超越前缀直接明确指定引用的段寄存器，改变上述两种情况下所使用的段寄存器。例如：
引用的段寄存器是ES
MOV AX,ES:[BX+SI]
引用的段寄存器是DS
MOV DS:[BP+SI],AL
题2.12 8086/8088的基本寻址方式可分为哪三类？他们说明了什么？
立即寻址，寄存器寻址，存储器寻址
立即寻址 操作数包含在指令中，跟在操作码后。
寄存器寻址 操作数在CPU内部的寄存器中，指令中指定寄存器号。
存储器寻址 操作数在存储器中，指令中描述操作数的有效地址。
题2.13 存储器寻址方式分为哪几种？何为存储器的有效地址？
直接寻址、寄存器间接寻址、寄存器相对寻址、基址加变址寻址和相对基址加变址寻址，这五种寻址方式属于存储器寻址
操作数所在存储单元的地址，是一个16位的无符号数
题2.14 什么场合下缺省的段寄存器是SS？为什么这样安排？
当涉及到一个堆栈操作时，则缺省的段寄存器是SS，堆栈段寄存器SS加上由SP所给出的16位偏移，得到栈顶的物理地址。
题2.15 请说明如下指令中源操作数的寻址方式，并作相互比较:
答：MOV BX,[1234H]               直接寻址
       MOV BX,1234H                 立即寻址
       MOV DX,BX                      寄存器寻址
       MOV DX,[BX]                    寄存器间接寻址
       MOV DX,[BX+1234H]       寄存器相对寻址
       MOV DX,[BX+DI]              基址加变址寻址
       MOV DX,[BX+DI+1234H]         相对基址加变址寻址
题2.16 8086/8088提供了灵活多样的寻址方式，如何适当的选择寻址方式？
立即寻址方式 操作数包含在指令中 用于给寄存器或存储单元赋初值
寄存器寻址方式 操作数在寄存器中，指令执行速度较快
直接寻址方式 操作数在存储器中，指令直接包含有操作数的有效地址 
寄存器间接寻址方式 操作数在存储器中，操作数有效地址在SI、DI、BX、BP这四个寄存器之一中
寄存器相对寻址方式 操作数在存储器中，
操作数的有效地址是一个基址寄存器（BX、BP）或变址寄存器的（SI、DI）内容加上指令中给定的8位或16位位移量之和
基址加变址寻址方式 操作数在存储器中，操作数的有效地址由基址寄存器之一的内容与变址寄存器之一的内容相加得到
相对基址加变址寻址方式 操作数在存储器中，操作数的有效地址由基址寄存器之一的内容与变址寄存器之一的内容及
指令中给定的8位或16位位移量相加得到
结合程序中的需要进行灵活选择
题2.17 设想一下这些寻址方式如何支持高级语言的多种数据结构？
比较一下C语言和汇编语言定位字符串中字符的方式
C语言：a[i]，b[i]
汇编语言：0[bx]，5[bx]
通过比较，我们可以发现，[bx+idata]的方式为高级语言实现数组提供了便利机制。
比较一下几种定位内存地址的寻址方式，就可以发现：
（1）[idata]用一个常量来表示地址，可用于直接定位一个内存单元；
（2）[bx]用一个变量来表示内存地址，可用于间接定位一个内存单元；
（3）[bx+idata]用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元；
（4）[bx+si]用两个变量表示地址；
（5）[bx+si+idata]用两个变量和一个常量表示地址。
可以看到，从[idata]一直到[bx+si+idata]，我们可以用更加灵活的方式来定位一个内存单元的地址。
这使我们可以从更加结构化的角度来看待所要处理的数据。
题2.18 为什么目标操作数不能采用立即寻址方式？
立即寻址方式 操作数包含在指令中，作为指令的一部分，跟在操作码后，不能作为目标操作数。
题2.19 处理器的通用寄存器是否越多越好？通用寄存器不够用怎么办？
答：处理器的通用寄存器并非越多越好，因为处理器的通用寄存器数越多，处理器的内部结构越复杂，指令执行过程的开销越大。
       通用寄存器不够用，可以用内存中的存储单元代替，不过访问速度会变慢
题2.20 哪些存储器寻址方式可能导致有效地址超出64K的范围？8086/8088如何处理这种情况？
寄存器相对寻址 基址加变址寻址 相对基址加变址寻址
在计算有效地址时，如果位移量是8位，那么被带符号扩展成16位。当所得的有效地址超过FFFFH时，就取其64K的模。
题2.21 什么情况下根据段值和偏移确定的存储单元地址会超出1M？8086/8088如何处理这种情况？
物理地址=段值×16+偏移， 当经过计算得到的物理地址超过FFFFFH时，存储单元地址会超出1M。
8086/8088将取其1M的模
题2.22 8086/8088的指令集可分为哪6个子集？
8086/8088的指令系统可分为如下六个功能组：
（1）数据传送；
（2）算术运算；
（3）逻辑运算；
（4）串操作；
（5）程序控制；
（6）处理器控制。
题2.23 8086/8088的指令集合中，最长的指令有几个字节？最短的指令有几个字节？请举例说明？
8086/8088指令长度是可变的，指令机器码的长度为1~6个字节。
MOV AX,[BX+DI+1234H]
NOP
题2.24 8086/8088的算术逻辑运算指令最多一次处理多少二进制位？当欲处理的数据长度超出该范围怎么办？
答：8086/8088的算术逻辑运算指令最多一次处理16位；
如果处理的数据长度超出16位，则拆分成若干部分，依次运算，最后进行整合；
题2.25 如何实现使数据段与代码段相同？
把数据段的内容放到代码段中，并把CS段寄存器的值赋给DS段寄存器。
题2.26 通常情况下源操作数和目的操作数不能同时是存储器操作数。请给出把存储器操作数甲送到存储器操作数乙的两种方法。
答：  
       通过寄存器中转、通过栈中转 DS:[BX]=甲，DS:[SI]=乙
1、
       MOV AX, [BX]
       MOV [SI],AX
2、
       MOV AX,[BX]
       XCHG AX,[SI]
3、
       PUSH WORD PTR [BX]
       POP  WORD PTR [SI]
题2.27 请用一条指令实现把BX的内容加上123并把和送到寄存器AX。
答：   LEA AX, [BX+123H]
题2.28 堆栈有哪些用途？请举例说明。
（1）现场和返回地址的保护；call 子程序和ret、int 软中断和iret
（2）寄存器内容的保护；push和pop
（3）传递参数；push和pop
（4）存储局部变量
局部变量存放在堆栈中，在程序的开始把Sp的值赋给BP，然后，改变SP的值，把局部变量的位置留出来。
这时，我们可以方便的用BP找到局部变量。函数返回时，BP的值又赋值给SP，函数内的局部变量就消失了。
题2.29 在本章介绍的8086/8088指令中，哪些指令把寄存器SP作为指针使用？
PUSH POP PUSHF POPF
8086/8088指令集中，哪些指令把寄存器SP作为指针使用？
PUSH POP PUSHF POPF PUSHA POPA CALL RET RETF INT IRET    
题2.30 请说说标志CF的用途。请至少给出使标志CF清0的三种方法。
在进行多字节数的加减运算时，要使用到CF标志；在比较无符号数的大小时，要使用到CF标志。
移位指令也把操作数的最高位或最低位移入CF。移位指令和CF的配合，可实现操作数之间的位传送。
CF也常作为子程序的出口参数之一。
CF标志清0的方法 1、CLC 2、ADD AX,0 3、SUB AX,0 4、AND AX,0FFFFH 5、OR AX,0
题2.31请写出如下程序片段中每条算术运算指令执行后标志CF、ZF、SF、OF、PF和AF的状态：
MOV AL,89H
ADD AL,AL AL=12H
CF=1    ZF=0    SF=0    OF=1    PF=1    AF=1
ADD AL,9DH AL=AFH
CF=0    ZF=0    SF=1    OF=0    PF=1    AF=0
CMP AL,0BCH (AF-BC=F3)AL=AFH
CF=1    ZF=0    SF=1    OF=0    PF=1    AF=0
SUB AL,AL AL=0
CF=0    ZF=1    SF=0    OF=0    PF=1    AF=0
DEC AL
CF=0    ZF=0    SF=1    OF=0    PF=1    AF=1
INC AL
CF=0    ZF=1    SF=0    OF=0    PF=1    AF=1
题2.32什么是除法溢出？如何解决16位被除数8位除数可能产生的溢出？
无符号数除法指令DIV
如果除数为0，或者在8位数除时商超过8位，或者在16位除时商超过16位，则认为是除法溢出，引起0号中断。
有符号数除法指令IDIV
当除数为0，或者商太大，或者商太小时，则认为是除法溢出，引起0号中断。
将可能产生溢出的除法运算转变为多个不会产生溢出的除法运算。
给出一个公式：
X：被除数，范围：[0，FFFFFFFF]
N：除数，范围：[0，FFFF]
H:X高16位，范围：[0，FFFF]
L:X低16位，范围：[0，FFFF]
int（）：描述性运算符，取商，比如，int（38/10）=3
rem（）：描述性运算符，取余数，比如，rem（38/10）=8
公式：X/N=int（H/N）*65536+[rem（H/N）*65536+L]/N
X/n=int（H/n）*65536+[rem（H/n）*65536+L]/n 
H=int（x/65536）；L=rem（x/65536）
这个公式将可能产生溢出的除法运算：X/N，转变为多个不会产生溢出的除法运算。
公式中，等号右边的所有除法运算都可以用div指令来做，肯定不会导致除法溢出。
divdw:push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
子程序描述
名称：divdw
功能：进行不会产生溢出的除法运算，被除数为dword型，除数为word型，结果为dword型。
参数：（ax）=dword型数据的低16位
（dx）=dword型数据的高16位
（cx）=除数
返回：（dx）=结果的高16位，（ax）=结果的低16位
（cx）=余数
应用举例：计算1000000/10（F4240H/0AH）
mov ax,4240H
mov dx,000FH
mov cx,0AH
call divdw
题2.33请写出如下程序片段中每条逻辑运算指令执行后标志ZF、SF和PF的状态：
MOV AL,45H AL=45H
AND AL,0FH AL=05H
ZF=0 SF=0 PF=1
OR AL,0C3H AL=C7H
ZF=0 SF=1 PF=0
XOR AL,AL AL=0
ZF=1 SF=0 PF=1
题2.34“MOV AX,0”可使寄存器AX清0。另外再请写出三条可使寄存器AX清0的指令。
SUB AX,AX
AND AX,0
XOR AX,AX
题2.35请写出如下程序片段中每条移位指令执行后标志CF、ZF、SF和PF的状态：
MOV AL,84H AL=84H
SAR AL,1 AL=C2H
CF=0 ZF=0 SF=1 PF=0
SHR AL,1 AL=61H
CF=0 ZF=0 SF=0 PF=0
ROR AL,1 AL=B0H
CF=1 ZF=0 SF=1 PF=0
RCL AL,1 AL=61H
CF=1 ZF=0 SF=0 PF=0
SHL AL,1 AL=C2H
CF=0 ZF=0 SF=1 PF=0
ROL AL,1 AL=85H
CF=1 ZF=0 SF=1 PF=0
题2.36 8086/8088中，哪些指令把寄存器CX作为计数器使用？哪些指令把寄存器BX作为基指针寄存器使用？
LOOP LOOPE/LOOPZ LOOPNE/LOOPNZ JCXZ
数据传送 MOV XCHG LEA LDS LES PUSH POP
算术运算 ADD ADC INC SUB SBB DEC NEG CMP MUL IMUL DIV IDIV
逻辑运算 NOT AND OR XOR TEST SAR SAL SHR SHL ROR ROL RCR RCL
程序控制 JMP
题2.37请不用条件转移指令JG、JGE、JL和JLE等指令实现如下程序片段的功能：
CMP AL,BL
JGE OK
XCHG AL,BL
OK:
……
JGE 标号 （SF异或OF）=0  大于等于转移
JL 标号    （SF异或OF）=1 小于转移
15 14 13 12 11 10  9  8   7   6   5   4  3  2  1  0
                    OF DF IF TF SF ZF       AF   PF     CF
CX->(AL-BL) 0C
DX->BL AL

PUSH CX
PUSH DX
MOV CH,AL
MOV CL,0CH
SUB CH,BL
PUSHF
POP DX
ROR DX,CL
XOR CH,DH
AND CH,80H
MOV DX,CX
SHR DX,CL
MOV CL,DL
MOV DH BL
MOV DL AL
ROL DX,CL
MOV AL,DL
MOV BL,DH
POP DX
POP CX
题2.38段间转移和段内转移的本质区别是什么？8086/8088哪些指令可实现段间转移？
段间转移修改段寄存器CS的值，段内转移不修改段寄存器CS的值。
段间转移可以转移到另一个段中，段内转移还在同一个段中。
无条件转移指令  
JMP FAR PTR 标号 
JMP DWORD PTR 内存单元地址
过程调用和过程返回指令；
call far ptr 标号
call dword ptr 内存单元地址
retf
软中断指令和中断返回指令。
int 中断类型码
iret
题2.39 8086/8088的条件转移指令的转移范围有多大？如何实现超出范围的条件转移？
条件转移指令中只用一个字节表示地址差，一个字节表示的地址差的范围是-128至+127。
所以，如果以条件转移指令本身作为基准，那么条件转移的范围在-126至+129之间。
如果条件转移的目标超出此范围，那么必须借助于无条件转移指令。
题2.40相对转移和绝对转移的区别是什么？相对转移有何优点？
利用目标地址与当前转移指令本身地址之间的差值记录转移目标地址的转移方式称为相对转移。
在指令中直接包含转移目标地址的段值和偏移的转移方式称为绝对转移。
相对转移有利于程序的浮动。
题2.41请指出下列指令的错误所在：
（1）MOV CX,DL  源操作数和目的操作数类型不一致。一个是字节，另一个是字。
（2）XCHG [SI],3  XCHG指令的操作数不能有立即数
（3）POP CS        POP指令的目的操作数不能是CS
（4）MOV IP,AX  IP既不能作为源操作数，也不能作为目的操作数。
（5）SUB [SI],[DI] 源操作数和目的操作数不能同时是存储器操作数
（6）PUSH DH     源操作数不是16位
（7）OR BL,DX     源操作数和目的操作数类型不一致。一个是字节，另一个是字。
（8）AND AX,DS  段寄存器不能作为AND指令的操作数
（9）MUL 16        立即数不能作为MUL指令的操作数
（10）AND 7FFFH,AX  立即数不能作为目的操作数
（11）DIV 256             立即数不能作为DIV指令的操作数
（12）ROL CX,BL         BL不能作为ROL指令的存放移位次数的操作数
（13）MOV ES,1234H  立即数不能直接传送到段寄存器
（14）MOV CS,AX       代码段寄存器CS不能作为目的操作数
（15）SUB DL,CF         CF只是标志寄存器中的1Bit，不能作为操作数
（16）ADC AX,AL        源操作数和目的操作数类型不一致。一个是字节，另一个是字。
（17）MOV AL,300     300超过 0FFh,不能保存在8位的AL中
（18）JDXZ NEXT       没有JDXZ指令
题2.42请指出如下指令哪些是错误的，并说明原因：
（1）MOV [SP],AX      SP不能作为寻址的寄存器
（2）PUSH CS             对
（3）JMP BX+100H    对
（4）JMP CX              对
（5）ADD AL,[SI+DI]  SI、DI不能同时参与寻址
（6）SUB [BP+DI-1000],AL  对
（7）ADD BH,[BL-3]     BL不能作为寻址的寄存器
（8）ADD [BX],BX        对
（9）MOV AX,BX+DI   对
（10）LEA AX,[BX+DI] 对
（11）XCHG ES:[BP],AL 对
（12）XCHG [BP],ES 段寄存器不能作为XCHG指令的操作数
题2.43下列程序片段完成什么功能，可否有更简单的方法实现同样的功能：
XCHG AX,[SI]
XCHG AX,[DI]
XCHG AX,[SI]
[SI]、[DI]交换数据
PUSH [SI]
PUSH [DI]
POP [SI]
POP [DI]
题2.44请比较如下指令片段：
（1）LDS SI,[BX]        DS=[BX+2] SI=[BX]
（2）MOV SI,[BX]      DS=[BX+2] SI=[BX]
         MOV DS,[BX+2]
（3）MOV DS,[BX+2] DS=[BX+2] BX=[BX]
         MOV BX,[BX]
题2.45 TC或BC的编译模式与存储器分段管理有什么关系？
编译模式决定了编译程序如何在内存中放置程序代码、数据、堆栈，如何存取它们。
编译程序提供了6种编译模式，这6种模式是：
微模式（Tiny），小模式（Small），中模式（Medium），紧凑模式（Compact），大模式（Large）和巨模式（Huge）。
微模式(Tiny)
在微模式下程序中的数据及代码均放在同一段内，即它们不超过 64KB。
在微模式下代码段、堆栈段和数据段的段地址均相同，即CS=DS=SS=ES，指针都是near指针。
小模式(Small)
在小模式下，程序中的代码放在64KB的代码段内，数据放在64KB的数据段内。
在小模式下，栈段、附加数据段和数据段均指向同一地址，即DS=SS=ES，指针都是near指针。
中模式(Medium)
在中模式下，所有数据放在64KB的数据段内，数据段内使用near指针，代码量可以大于64KB（允许达到1MB），
因而可以在不同的代码段内。代码段使用far指针。来自不同源文件的代码模块放在不同的代码段内。
紧凑模式(Compact)
在紧凑模式下，数据量超过64KB时，可放在多个数据段中，数据段内的指针是far指针。
代码量不超过64KB，在一个段内，因而代码段内指针为near指针。静态数据不能超过64KB，堆用far指针来存取。
代码、静态数据、堆栈、堆各有自己的段。
大模式(Large)
大模式下，代码及数据均采用far指针，且都可达到1MB。代码分布在不同的代码段内，数据也分布在不同的数据段内。
静态数据不能超过64KB，堆用far指针来存取。代码、静态数据、堆栈、堆各有自己的段。
巨模式(Huge)
巨模式下，代码段及数据段均用far指针，代码分布在不同的代码段内，
数据也分布在不同的数据段内，它们来自不同的源程序，大堆栈只有一个。而且静态数据大小允许超过64KB。
代码、静态数据、堆栈、堆各有自己的段。
无论采用哪一种编译模式，C源程序编译生成的代码和数据量都不能超过64KB，
对于超过的源程序，可以视代码或数据多少将其分解成两个或多个程序分别编译。
大代码量程序要选用大代码编译模式（中模式、大模式和巨模式），
大数据量程序应选用大数据编译模式（紧凑模式、大模式和巨模式），这样编译生成的.obj 文件将会带给连接程序信息，
将代码和数据安排在不同段内。这样生成的.exe 文件在加载时将告诉 DOS 该程序应如何装入代码段和数据段，如何初始化寄存器。
这样，就可确定在不同编译模式下开辟数据区的大小，即大于64KB，或不超过64KB。
题2.46 TC或BC中使用的长指针的实质是什么？
寻址范围为2^16地址范围之内的指针叫做短指针，寻址范围超过前述范围的叫做长指针。
长指针由16位的地址和16位的偏移量组成，寻址长指针需要更改段寄存器的内容。 
第3章汇编语言及其程序设计初步
汇编语言不仅仅是由汇编格式指令构成的指令语句，它还包括丰富的伪指令语句及其他内容。
本章先简单介绍汇编语言，然后介绍如何进行顺序、分支和循环等程序设计。
3.1汇编语言的语句
汇编语言源程序由汇编语言语句组成。尽管与高级语言的语句相比，汇编语言语句比较简单，但它有两类完全不同的语句。
本节介绍语句格式及其主要组成部分―表达式的表示。
3.1.1语句的种类和格式
1.语句的种类
汇编语言有两种类型的语句，一种是指令语句，另一种是伪指令语句。这两种语句截然不同。
汇编程序在对源程序进行汇编时，把指令语句翻译成机器指令，也就是说，指令语句有着与其对应的机器指令。
伪指令语句没有与其对应的机器指令，只是指示汇编程序如何汇编源程序，包括符号的定义、变量的定义、段的定义等。
在宏汇编语言中，还有一种特殊的语句，称为宏指令语句。利用宏定义伪指令，可以把一个程序片段定义为一宏指令。
当宏指令作为语句出现时，该语句就称为宏指令语句。所以，在宏汇编语言中，除了指令语句和伪指令语句外，还有宏指令语句。
我们在第7章中再介绍宏指令语句。
2.语句的格式
指令语句和伪指令语句的格式是相似的，都由四部分组成。
指令语句的格式如下：
[标号：]指令助记符[操作数[，操作数]][；注释]
我们在2.4.1中已对指令语句的格式作过简要说明。
其中操作数可以是常数（数值表达式）操作数、寄存器操作数（寄存器名）或者存储器操作数（地址表达式）。
伪指令语句的格式如下：
[名字]伪指令定义符[参数，.…，参数][；注释]
伪指令定义符规定了伪指令的功能。
一般伪指令语句都有参数，用于说明伪指令的操作对象，参数的类型和个数随着伪指令的不同而不同。
有时参数是常数（数值表达式），有时参数是一般的符号，有时是具有特殊意义的符号。
伪指令语句中的名字有时是必需的，有时是可省的，这也与具体的伪指令有关。
在汇编语言源程序中，名字与标号很容易区分，名字后没有冒号，而标号后一定有冒号。
汇编程序忽略由分号开始至行尾的注释。为了阅读和理解程序的方便，程序员要恰当地使用注释，
通过注释来说明语句或程序的功能。有时整行都可作为注释，只要该行以分号引导。
通常一个语句写一行。语句的各组成部分间要有分隔符。标号后的冒号是现成的分隔符，注释引导符分号也是现成的分隔符。
此外，空格和制表符是最常用的分隔符，且多个空格或多个制表符的作用与一个空格或制表符的作用相同。
空格和制表符被作为分隔符（除非作为字符串中的字符）而被忽略，
所以常通过在语句行中加入空格和制表符的方法使上下语句行的各部分对齐，以方便阅读。
尽管对齐不是必需的，但肯定有助于阅读。参数之间常用逗号作分隔符，但有时也用空格或制表符作分隔符。
标号和名字一般最多由31个字母、数字及规定的特殊字符(?@_$)等组成，并且不能用数字开头。
一般情况下，汇编程序不区分标号和名字中的字母的大小写，除非要求汇编程序进行区分。
值得指出的是，标号和名字要尽量起得有意义，这会大大有助于程序的阅读和理解。
另外，标号和名字不能是汇编语言的保留字。汇编语言中的保留字主要是指令助记符、伪指令定义符和寄存器名，
还有一些其他的特殊保留字。顺便说一下，汇编程序也不区分保留字中字母的大小写。
3.1.2数值表达式
在汇编语言中，不仅有各种类型的运算符，还有许多操作符。通过运算符、操作符及括号把常数和符号连起来，就得到表达式。
表达式又分为数值表达式和地址表达式。上述指令语句中的操作数和伪指令语句中的参数在许多场合下只是数值表达式。
所谓数值表达式是指在汇编过程中能够由汇编程序计算出数值的表达式。
所以组成数值表达式的各部分必须在汇编时就能完全确定。
标号和变量可作为数值表达式中的符号，由符号说明伪指令语句或符号定义伪指令语句，说明或定义的符号，
也可成为数值表达式中的符号。下面先介绍常数和运算符。
1.常数
常数有多种类型和表示方式，常用的类型和表示方式如下：
（1）十进制常数
由若干个0到9的数字组成的序列，可以用字母D结尾。例如：1024，2048D。
通常情况下，常数用十进制表示，所以在表示十进制常数时一般不加后缀字母D。但汇编语言提供改变基数的伪指令.RADIX。
（2）十六进制常数
由若干个0至9的数字或字母A至F所组成的序列，必须以字母H结尾。
为了避免与普通符号（如标号、名字和保留字）相混淆，十六进制数必须以数字开头。
所以，凡是以字母A至F开头的十六进制数，必须在前面加一个0。在汇编语言中，十六进制数用得较普遍。例如：
OR AX,8080H
AND BL,0F0H
（3）二进制常数
由若干个0和1组成的序列，必须以字母B结尾。在汇编语言程序设计中，有时用二进制数较方便。例如：
TEST BL,00110100B
OR AL,11001010B
（4）八进制常数
由若干个0至7的数字组成的序列，必须以字母Q结尾。例如：127Q，377Q。
（5）字符串常数（串常数）
一个字符串常数是用引号括起来的一个或多个字符。串常数的值是包括在引号中的字符的ASCII代码值。
例如，'A'的值是41H，而'ab'的值是6162H。因此，串常数与整常数有时可以交替使用。例如：
CMP AL,'A'
MOV VARW,'ab'
CMP AX,"AB"
2.算术运算符
算术运算符包括正（+）、负（-）、加（+）、减（-）、乘（*）、除（/）和模（MOD），
这些算术运算符的意义与高级语言中同样运算符的意义相似。例如：
ADD AX,100*4+2
SUB CX,100H/2
MOV AL,-3
3.关系运算符
关系运算符包括相等（EQ）、不等（NE）、小于（LT）、大于（GT）、小于或等于（LE）、大于或等于（GE）。
运算结果总是一个数字值。若关系不成立，则结果为0，若关系成立，则结果为0FFFFH。例如：
MOV AX,1234H GT 1024H
MOV BX,1234H+5 LT 1024H
汇编后，目标程序中对应上述语句的指令如下：
MOV AX,0FFFFH
MOV BX,0
4.逻辑运算符
逻辑运算符包括按位操作的“与”（AND）、“或”（OR）、“异或”（XOR）和“非”（NOT），
另外，还有左移位（SHL）和右移位（SHR）。逻辑运算的结果是数值。例如：
MOV AX,1 SHL 3
ADD CX,1024 SHR 4
OR AL,3 AND 47H
AND BL,NOT (7 OR 54H)
汇编后，目标程序中对应上述语句的指令如下：
MOV AX,8
ADD CX,40H
OR AL,3
AND BL,0A8H
请注意逻辑运算符与指令助记符的区别，表达式中的逻辑运算是由汇编程序在汇编时完成的。
5.在数值表达式中使用的操作符
汇编语言中还有如下操作符可用在数值表达式中：HIGH、LOW、LENGTH、SIZE、OFFSET、SEG、TYPE、WIDTH和MASK等。
下面先介绍HIGH和LOW，其他的操作符在以后的章节中再作介绍。
（1）HIGH使用格式如下：
HIGH 数值表达式
结果是数值表达式值的高8位。
（2）LOW使用格式如下：
LOW 数值表达式
结果是数值表达式值的低8位。
例如：
MOV AX,HIGH（1234H+5）
MOV AX,HIGH 1234H+5
MOV AX,LOW 1234H-3
汇编后，目标程序中对应上述语句的指令如下：
MOV AX,12H
MOV AX,17H
HIGH优先级高于加（+）
MOV AX,31H
6.运算符和操作符的优先级
汇编语言中各种运算符和操作符的优先级按高到低排列如下：
（1）圆括号，尖括号，方括号，圆点符，LENGTH，SIZE，WIDTH，MASK。
其中，尖括号使用于记录中，圆点符使用于结构中。
（2）PTR，OFFSET，SEG，TYPE，THIS，冒号。
其中，冒号用于表示段超越前缀。
（3）*，/，MOD，SHL，SHR。
（4）HIGH，LOW。
（5）+，-。
（6）EQ，NE，LT，LE，GT，GE。
（7）NOT。
（8）AND。
（9）OR，XOR。
（10）SHORT。
3.1.3地址表达式
地址表达式所表示的是存储器操作数的地址。单个的标号、变量（对应直接寻址方式）和
有方括号括起的基址或变址寄存器（对应寄存器间接寻址）是地址表达式的特例。
在2.3节中介绍的寄存器相对寻址、基址加变址寻址和相对基址加变址寻址等寻址方式的各种表示均属于地址表达式。
在一个存储器地址上加或减一个数字量，结果仍为存储器地址。例如：
MOV AX,VARW+4
如VARW是变量，那么“VARW+4”表示以变量VARW的偏移加4为偏移的存储单元，而不是变量VARW的内容加4。
实际上，在汇编时无法确定变量VARW的值。
在表示变址寻址方式时，下面的表示方法是等价的（其中VARW是变量或是符号常量）：
[VARW+BX]
VARW[BX]
在表示基址加变址寻址方式时，下面的表示方法是等价的（其中VARW是变量或是符号常量）：
VARW[BX+DI]
[VARW+BX+DI]
VARW[BX][DI]
VARW[DI][BX]
3.2变量和标号
变量和标号分别代表存储单元。变量表示的存储单元中存放数值；标号表示的存储单元中存放指令代码。
标号的定义很简单。本节介绍如何定义变量，以及变量和标号的属性。
3.2.1数据定义语句
通过数据定义语句可为数据项分配存储单元，并根据需要设置其初值。还可用符号代表数据项，
此时符号就与分配的存储单元相联系。代表数据项的符号本身称为变量名，与之相对应的存储单元用于存放变量，
所以常常就把这样的存储单元称为变量。
1.数据定义语句
数据定义语句是最常用的伪指令语句。一般格式如下：
[变量名]数据定义符表达式[，表达式…，表达式]；注释
例如：
VARB DB 3
VARW DW -12345
DB 1
变量名是可选的，如果使用变量名，那么它就直接代表该语句所定义若干数据项中的第一个数据项。各表达式间用逗号分隔。
例如：
BUFF DB 100,3+4,5*6
（1）定义字节数据项
每一字节数据项只占用一个字节存储单元。定义字节数据项的数据定义符是DB。例如：
COUNT DB 100
DB 0DH,0AH,'$'
TABLE DB 0,1,4,9,16
上面的数据定义语句被汇编后所对应的存储区域分配情况如图3.1（a）所示，图中的数字值用16进制表示。
从图3.1（a）可见，由引号括起的字符对应其ASCII码值。下面是存取上述有关变量或数据项的指令举例：
DEC COUNT
MOV AL,TABLE
MOV TABLE+2,BL
TABLE+2是从TABLE开始的第3个字节
（2）定义字数据项
每一字数据项占用两个字节存储单元。定义字数据项的数据定义符是DW。例如：
FLAG DW 2FCDH,1024,-1
VECT DW 0
DW 2047
上面的数据定义语句被汇编后所对应的存储区域分配情况如图3.1（b）所示，图中的数字值用16进制表示。
-1用补码表示为0FFFFH。下面是存取上述有关变量或数据项的指令举例：
MOV BX,VECT
TEST FLAG,1234H
OR AX,FLAG+2
FLAG+2是从FLAG开始的第二个字变量
（3）定义双字数据项
每一双字数据项要占用四个字节存储单元。定义双字数据项的数据定义符是DD。例如：
VECTOR DD 4
FARPTR DD 12345678H,0
数据定义语句中的表达式一般是数值表达式，汇编程序在计算出数值后就作为对应数据项的初值。
所以，结果数值的大小必须适合对应变量或数据项的范围。
（4）定义没有初值的数据项
如果数据定义语句中的表达式单单是一个问号（?），那么表示不预置对应变量的初值，而仅仅是给变量分配存储单元。例如：
INBUFF DB 5,?,?,8,?
VARW DW ?
OLDV DD ?
（5）定义字符串
定义字节数据伪指令DB也可方便地用于定义字符串。字符串要用引号括起来，单引号和双引号皆可，只要配对。
DB伪指令把字符串中的各个字符的ASCII码值依次存放在相应的字节存储单元中。例如：
MESS1 DB 'HELLO！’上述语句与如下语句起相同的作用：
MESS1 DB 'H','E','L','L','O','!'
显然，用一对引号把字符串括起，要比把每一个字符用引号括起方便得多。再如：
MESS2 DB "How are you?",0DH,0AH,24H
图3.2给出了某个程序中的下列数据定义语句所定义的变量或数据项使用的存储单元和存放格式。
VARW DW 5678H
VARB DB 2,3,-2
VARD DD 0,12345678H
MESS DB 'OK!'
FLAG DW 'Ab'
从图3.2可见，字变量FLAG的初值’Ab’被解释为4162H，所以，其高8位41H存放在高地址字节中。请注意“高高低低”原则。
（6）定义其他类型数据项
利用数据定义语句还可定义8字节数据项和10字节数据项。
定义8字节数据项的数据定义符是DQ，定义10字节数据项的数据定义符是DT。例如：
DT 0
DQ ?
2.重复操作符DUP
有时需要定义数组，有时还需要定义数据缓冲区。为此，汇编语言提供了在数据定义语句中使用的重复操作符DUP。例如：
BUFFER DB 8 DUP (0)
上述伪指令语句就定义了由8个字节组成的缓冲区，每个字节的初值为0。
这样的缓冲区也可理解成由8项构成的数组，每项一个字节，初值为0。上述数据定义语句与如下的数据定义语句起到相同的作用：
BUFFER DB 0,0,0,0,0,0,0,0
重复操作符DUP的一般使用格式如下：
count DUP（表达式[，表达式，..]）上式作为特殊的表达式只能使用在数据定义语句中。
其中，count是重复次数，要重复的内容含在括号内，如有多个表达式，则表达式间用逗号分隔。
表达式中还可再使用重复操作符DUP，但有一定的嵌套层次限制。
例如：
BUFFER1 DB 5,0,5 DUP (?)
BUFFER2 DW 1024 DUP (0)
BUFFER3 DB 256 DUP ('ABCDE')
DATA DW 1,5 DUP (1,2,4 DUP (0))
3.2.2变量和标号
1.变量和标号的属性
变量表示存储单元，这种存储单元中存放数值；标号也表示存储单元，这种存储单元中存放机器指令代码。
所以，变量和标号均表示存储器操作数，都具有如下三种属性：
（1）段值，变量或标号对应存储单元所在段的段值。
（2）偏移，变量或标号对应存储单元的起始地址的段内偏移。
（3）类型，变量的类型主要是字节（BYTE）、字（WORD）和双字（DWORD）；
标号的类型主要是近（NEAR）和远（FAR），近表示段内标号，远表示段间标号。
在汇编语言程序设计中，变量和标号的这三个属性很重要，为此，汇编语言提供专门的析值操作符和类型操作符，
以便于对变量和标号的这三个属性进行有关操作处理。下面就简单介绍这些操作符。
2.析值操作符
析值操作符也称为数值回送操作符，原因是这些操作符把一些特征或存储器地址的一部分作为数值回送。
五个析值操作符的简单使用格式如下：
SEG 变量名或标号
OFFSET 变量名或标号
TYPE 变量名或标号
LENGTH 变量名
SIZE 变量名
这些操作符都使用在数值表达式中。为了说明这些操作符的作用，我们设在某个程序中有如下数据定义片段：
VARW DW 1234H,5678H
VARB DB 3,4
VARD DD 12345678H
BUFF DB 10 DUP (?)
MESS DB 'HELLO'
设变量VARW从偏移100H开始，对应的存储情况如图3.3所示。
（1）操作符SEG能返回变量所在段的段值，例如：
MOV AX,SEG VARW
把变量VARW所在段的段值送AX
MOV DS,AX
再送到数据段寄存器DS
（2）操作符OFFSET返回变量或者标号的偏移，例如：
MOV BX,OFFSET VARW
把VARW的偏移（100H）送BX
ADD Dl,OFFSET VARW+2
在汇编时计算出OFFSET VARW+2=102H
MOV SI,OFFSET VARB
把VARB的偏移（104H）送SI
请注意上一条指令与如下指令有质的不同：
LEA SI,VARB
利用操作符OFFSET只能取得用数据定义伪指令定义的变量的有效地址，而不能取得一般操作数的有效地址。
实际上，OFFSET只是汇编语言提供的操作符，它的返回值是在汇编时由汇编程序计算出来的。
（3）操作符TYPE返回变量或标号的类型，类型用数值表示，常见类型和对应的数值
规定如下：
字节（BYTE）变量              1
字（WORD）变量              2
双字（DWORD）变量        4
近（NEAR）标号               -1
远（FAR）标号                  -2
由上述表示关系可见，变量的类型值是对应类型的变量项所占用的字节数，而标号的类型值却没有实际的物理意义。
VARW DW 1234H,5678H
VARB DB 3,4
VARD DD 12345678H
BUFF DB 10 DUP (?)
MESS DB 'HELLO'
（4）操作符LENGTH返回利用DUP定义的数组中元素的个数，即重复操作符DUP前的count值。
如果变量定义语句中没有使用DUP，则总返回1。如果嵌套使用了DUP，则只返回最外层的重复数。例如：
MOV CX,LENGTH VARW
1送CX
MOV CX,LENGTH BUFF
10送CX
MOV CX,LENGTH MESS
1送CX
（5）操作符SIZE返回用DUP定义的数组占用的字节数，可按下式计算：
SIZE 变量=（LENGTH变量）*（TYPE变量）例如：
MOV CX,SIZE VARW
2送CX
MOV CX,SIZE BUFF
10送CX
MOV CX,SIZE MESS
1送CX
3.属性操作符
为了提高访问变量、标号和一般存储器操作数的灵活性，汇编语言还提供了属性操作符PTR和THIS，以达到按指定属性访问的目的。
（1）操作符PTR
我们先看一个例子。汇编程序在汇编指令“MOV [SI],1”时，将发出警告提示信息或出错提示信息，
其原因是汇编程序不能确定指针寄存器所指的存储器操作数的类型，即要访问的存储器操作数是字节类型还是字类型。
程序员要在源程序中明确指明，要访问的存储器操作数是字节类型还是字类型。这可利用PTR操作符来指明，例如：
MOV WORD PTR [SI],1
指明字类型
MOV BYTE PTR [SI],1
指明字节类型
PTR是最常用的合成操作符，用在地址表达式前，用于指定或临时改变变量和标号的类型。
一般格式如下：类型 PTR 地址表达式
其中，类型可以是BYTE、WORD、DWORD、NEAR和FAR。
它指示汇编程序无论地址表达式所表示的单元类型是什么，当前均以PTR前面的类型为准。
请注意，PTR操作符并不分配存储单元，而只是临时性地强制指定变量或标号的类型。
于是，利用PTR便可访问一个字变量的高字节和低字节，也可把两个字节变量当作一个字变量来访问。例如：
VARW DW 1234H
VARB DB 1
DB 3
VARD DD 12345678H
...
MOV AX,WORD PTR VARB
访问由VARB开始的一个字
MOV AL,BYTE PTR VARW
访问字变量VARW的低字节
MOV BYTE PTR VARW+1,AL
访问字变量VARW的高字节
MOV DX,WORD PTR VARD
访问双字变量VARD的低字
MOV WORD PTR VARD+2,ES
访问双字变量VARD的高字
MOV WORD PTR ES:[DI+2],0
再如：
JMP FAR PTR OK
OK是标号
JMP DWORD PTR OLDVECT
OLDVECT是变量
（2）操作符THIS
操作符THIS的一般格式如下：
THIS 类型
其中类型可以是BYTE、WORD、DWORD、NEAR和FAR等。它返回一个具有指定类型的存储器操作数，
但决不为该存储器操作数分配存储单元，所返回存储器操作数地址的段值和偏移就是下一个将分配的存储单元的段值和偏移。
与操作符PTR相比，有相似之处，即都能指定操作数类型。所不同的是，操作符THIS并不直接作用于其他的变量或标号，
而操作符PTR则不然。
操作符THIS一般使用在符号定义语句中，从而定义一个具有类型、段值和偏移三属性的表示存储器操作数的符号。例如：
MY_BYTE EQU THIS BYTE
EQU是符号定义语句的定义符
MY_WORD DW ?
如果在源程序中安排上述两条伪指令语句，那么符号MY_BYTE就表示一个字节变量，
它的段值和偏移与紧随其后的字变量MY_WORD相同。
所以，对字节变量MY_BYTE的访问实际上就是对字变量MY_WORD低字节的访问。
3.3常用伪指令语句和源程序组织
本节介绍常用的伪指令语句，并给出汇编语言源程序的组织形式。其他伪指令语句在以后各章节需要处给出。
3.3.1符号定义语句
通过符号定义语句，可把常数、表达式等用符号来表示。恰当地使用符号定义语句，不仅可大大方便程序的书写和阅读，
对程序的调试和修改也很有利。
1.等价语句EQU
等价语句的一般格式如下：
符号名 EQU 表达式
（1）用符号来代表常数或数值表达式。
在这种情况下，汇编程序计算出表达式的值，符号就代表计算结果。例如：
COUNT EQU 100
符号COUNT就代表常数100
BUFF_LEN EQU 4*COUNT
COUNT是已定义的符号常数
LTX EQU 1
RDX EQU LTX+50
INBUFFER DB COUNT,?,COUNT DUP (?)
（2）用符号表示一个字符串。
可用一简短的符号表示一复杂的字符串，以后当汇编程序遇到所定义的符号时，就用字符串代替之。例如：
HELLO EQU "How are you!"
（3）重新定义关键字或指令助记符。
也即给汇编语言的关键字或指令助记符起一个别的名称。例如：
MOVE EQU MOV
COUNT EQU CX
在安排了上述语句后，就可用MOVE代替指令助记符MOV，用COUNT代表寄存器CX。
当然指令助记符MOV和寄存器名CX还照可使用。例如：
MOVE AX,CX
也就是MOV AX,CX
MOV COUNT,100
也就是MOV CX,100
（4）定义存储器操作数符号。
所定义的存储器操作数符号具有类型、段值和偏移属性。例如：
VARW EQU THIS WORD
VARW的类型是字，段值和偏移与紧接的下一单元VARB相同。
VARB DB 2 DUP (0)
FLAG DW ?
FLAG1 EQU BYTE PTR FLAG
FLAG2 EQU BYTE PTR FLAG+1
在这之后，就可使用这些符号，例如：
MOV AX,VARW
MOV AL,FLAG1
相当于MOV AL,BYTE PTR FLAG
MOV FLAG2 AL
相当于MOV BYTE PTR FLAG+1,AL
需要注意：第一，等价语句不另外给符号分配存储单元；第二，等价语句定义的符号不能与其它符号相同，也不能被重新定义，
否则汇编程序会认为出现符号重新定义错误。
2.等号语句（=）
汇编语言还专门提供等号语句来定义符号常数，即用符号表示一个常数。
等号语句的一般格式如下：
符号名=数值表达式
例如：
XX=10
YY=20+300/4
数值表达式应该可以计算出数值，所以表达式中一般不能含有向前引用的符号名称。
用等号语句定义的符号可被重新定义。例如：
ABCD=1
ABCD=100
ABCD=2*ABCD+1
3.定义符号名语句
定义符号名语句的一般格式如下：
符号名 LABEL 类型
其中类型可以是BYTE、WORD、DWORD、NEAR和FAR等。
该语句的功能是定义有符号名指定的符号，使该符号的段属性和偏移属性与下一个紧接着的存储单元的段属性和偏移属性相同，
使该符号的类型为参数所规定的类型。例如：
BUFFER LABEL WORD
BUFF DB 100 DUP (0)
BUFFER的类型是WORD，段属性和偏移属性与BUFF相同。再如：
QUIT LABEL FAR
EXIT:MOV AH,4CH
这样指令“MOV AH,4CH”就有了两个标号QUIT和EXIT，但它们的类型不同。
3.3.2段定义语句
为了与存储器的分段结构相对应，汇编语言的源程序也由若干个段组成。段定义语句就是用来按段组织程序和利用存储器的。
1.段开始和结束语句
汇编语言源程序中的段以段开始语句开始，以段结束语句结束。
段定义的一般格式如下：
段名 SEGMENT [定位类型][组合类型]['类别']
段名 ENDS
段开始语句的定义符是SEGMENT，其中的定位类型、组合类型和类别都是可省的，暂不介绍它们的用法和用途（请见第8章）。
段结束语句的定义符是ENDS。段开始语句中的段名与段结束语句中的段名要相同，从而保持配对。
段名的命名方法与一般符号的命名方法相同。
一个简单的数据段如下所示：
DSEG SEGMENT
MESS DB 'HELLO',0DH,0AH,'$'
DSEG ENDS
一个简单的代码段如下所示：
CSEG SEGMENT
MOV AX,DSEG
把数据段DSEG的段值送AX
MOV DS,AX
再送DS寄存器
MOV DX,OFFSET MESS
MOV AH,9
INT 21H
DOS系统功能调用
MOV AH,4CH
INT 21H
DOS系统功能调用
CSEG ENDS
当段名作为符号被引用时，表示对应段的段值。指令“INT 21H”是软中断指令，在上述代码中起调用DOS系统功能的作用。
由于指令语句和数据定义语句都要占用存储单元，所以它们一定要安排在某个程序段内。
2.段使用设定语句
汇编程序根据段开始语句和段结束语句判断出源程序的段划分，为了有效地产生目标代码，
汇编程序还要了解各程序段与段寄存器间的对应关系。段寄存器与程序段的对应关系由段使用设定语句说明。
段使用设定语句的简单格式如下：
ASSUME 段寄存器名：段名[，段寄存器名：段名，...]
段寄存器名可以是CS、DS、SS和ES。段名就是段开始语句和段结束语句中规定的段名。
例如，下面的ASSUME语句告诉汇编程序，从现在开始CS寄存器对应CSEG段，DS寄存器对应DSEG段。
ASSUME CS:CSEG,DS:DSEG
ASSUME伪指令中的段名域也可以是一个特别的关键字NOTHING，它表示某个段寄存器不再与任何段有对应关系。
在一条ASSUME语句中可建立多个段寄存器与段的关系，只要用逗号分隔。
在源程序中可使用多条ASSUME语句，通常在代码段的一开始就使用ASSUME语句，确定段寄存器与段的对应关系，
以后可根据需要再使用ASSUME语句改变已建立的对应关系。
例如：
DSEG1 SEGMENT
定义一个数据段，段名为DSEG1
VARW DW 12
……
DSEG1 ENDS
DSEG2 SEGMENT
定义另一个数据段，段名为DSEG2
XXX DW 0
YYY DW 0
……
DSEG2 ENDS
CSEG SEGMENT
定义一个代码段
ASSUME CS:CSEG,DS:DSEG1,ES:DSEG2
MOV AX,DSEG1
MOV DS,AX
MOV AX,DSEG2
MOV ES,AX
……
MOV AX,VARW
MOV XXX,AX
……
ASSUME DS:DSEG2,ES:NOTHING
MOV AX,DSEG2
MOV DS,AX
MOV AX,XXX
MOV YYY,AX
……
CSEG ENDS
段使用设定语句是伪指令语句，它不能设置段寄存器的值，
所以在上述程序中还需要通过指令语句来给数据段寄存器和附加段寄存器赋值。
变量VARW在DSEG1段中定义，变量XXX在DSEG2段中定义，
而第一条ASSUME语句表示数据段寄存器DS对应DSEG1，附加段寄存器ES对应DSEG2，因此
汇编程序在汇编“MOV XXX,AX”时，将自动加上段超越前缀，即成为“MOV ES:XXX,AX”。
由于第二条ASSUME语句把DS与DSEG2对应，而变量XXX和YYY均在DSEG2段中，
所以汇编程序在汇编“MOV AX,XXX”和“MOV YYY,AX”时就不再加上段超越前缀。
假设没有第二条ASSUME语句，那么汇编程序也要为上述两条指令加上段超越前缀ES:。
如果在第二条ASSUME语句后，安排指令“MOV AX,VARW”，汇编程序将发出无法访问变量VARW的出错提示信息，
原因是第二条ASSUME语句解除了DS寄存器与DSEG1段的对应关系，DSEG1段不再与任何段寄存器对应。
再如果把第二条ASSUME语句改变为“ASSUME DS:DSEG2,ES:DSEG1”，结果会是什么?
我们可以在有关的指令中明确加上段超越前缀，从而改变ASSUME语句对有关指令的影响。例如：
MOV AX,ES:XXX
MOV DS:YYY,AX
3.ORG语句
汇编程序在对源程序汇编的过程中，使用地址计数器来保存当前正在汇编的指令或者变量的地址偏移。
通常地址计数器的值逐步递增，但程序员可利用ORG语句调整地址计数器的当前值。
ORG语句的一般格式如下：
ORG 数值表达式
汇编程序在汇编到该伪指令语句后，使地址计数器的值调整成数值表达式的结果值。
如数值表达式的值是n，那么ORG伪指令语句使下一个字节的地址成为n。例如：
TESTSEG SEGMENT
ORG 100H
BEGIN:MOV AX,1234H
……
ORG 500H
VAR DW 1234
……
TESTSEG ENDS
标号BEGIN的偏移等于100H，变量VAR的偏移等于500H。
另外，汇编语言用符号“$”表示地址计数器的值。允许程序员在指令和伪指令中直接用符号$引用地址计数器的当前值。
例如下面的语句表示跳过8个字节的存储区：
ORG $+8
当$用在指令中时，它表示本条指令第一字节的地址偏移。例如：下面的指令表示转移到距当前指令第一字节后6字节处：
JMP $+6
当$用在伪指令的参数中时，它表示的是地址计数器的当前值。例如：
ARRAY DW 1,2,$+4,3,4,$+4
设在汇编时ARRAY分配的地址偏移是100H，那么汇编后相应的存储情况如图3.4所示。
从图3.4中可见，由于$的值在不断变化，所以数组中两个数值表达式$+4得到的结果是不同的。
3.3.3汇编语言源程序的组织
1.一个完整的源程序
我们先看一个简单又完整的源程序。
；程序名：T3-1.ASM
；功能：显示信息“HELLO”
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
MESS DB 'HELLO',0DH,0AH,'$'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESS
MOV AH,9
INT 21H
MOV AH,4CH
INT 21H
CSEG ENDS
END START
源程序T3-1.ASM含有三个段，即堆栈段、数据段和代码段。数据段含有程序要使用到的数据，代码段一般含有程序的代码。
堆栈段作为堆栈使用，它由堆栈段定义语句说明，在第8章节中再对此作解释。
在经过汇编和连接处理后，可得到一个可执行程序。它运行时，在屏幕上显示字符串信息“HELLO”。
操作系统（DOS）在把它装入运行时，将给上述逻辑上的三个段，分配三个相应的物理段。
在DOS把控制权转到该程序时，将设置妥代码段寄存器CS和指令指针寄存器IP。
2.源程序的组织
汇编语言源程序的主体是若干个段，少到一个段，多至几十个段，一般格式如下：
NAME1 SEGMENT
……
NAME1 ENDS
NAME2 SEGMENT
……
NAME2 ENDS
……
NAMEn SEGMENT
……
NAMEn ENDS
END 标号
通常情况下，代码和数据分别在代码段和数据段中，但有时代码和数据可以合并在同一个段中。
一个完整的汇编语言源程序至少含有一个代码段，但一个汇编语言源程序模块却可以只有数据段。
目前，我们总把数据段安排在程序的前面，把代码段安排在程序的后面，但不是非要这样安排的。
此外，一个完整的程序还应该带有自己的堆栈段。但操作系统（DOS）在装载没有堆栈段的程序时，会指定一个堆栈段。
由于堆栈段的安排比较固定，而且我们在全教程中所举的例子程序均较小，总可利用DOS安排的堆栈，所以为了简单，
在以后所举各例子中均省去堆栈段。尽管连接程序在连接这种没有堆栈段的目标模块时，会发出一条警告信息，但可忽略它。
指令语句和数据定义伪指令语句应安排在段内。部分伪指令语句可安排在段外，例如，符号定义语句一般安排在源程序的开始处。
在源程序的最后还要有源程序结束语句。
3.源程序结束语句
源程序结束语句的一般格式如下：
END [标号]
该语句告诉汇编程序，源程序到此为止。汇编程序在遇到该语句后，就不再对其后的任何语句进行汇编，
所以，源程序结束语句往往是源程序的最后一条语句。
END语句可带有一个已在程序中定义过的标号，这表示程序要从标号所对应的指令开始执行，
也就是说，标号给定了程序的启动地址。
如果源程序是一个独立的程序，那么END语句应带有标号，从而指定程序的启动地址。
如果源程序仅是一个模块，且不是主模块，则END语句不应带有标号。我们在第8章中介绍模块和主模块的概念。
3.4顺序程序设计
CPU在执行顺序程序片段时，按照指令的先后次序执行指令，因此在顺序程序片段中，指令的先后次序是至关重要的。
在具体的顺序程序片段中，有些指令语句可以前后颠倒，有些则不行。
此外，还要注意顺序的优化，做到充分利用前面的处理结果，尽量避免重复操作。本节介绍顺序程序设计的基本方法。
3.4.1顺序程序举例
例1：设X和Y均为16位无符号数，写一个求表达式16X+Y值的程序。
由于表达式中的X和Y是16位数，表达式的结果可能要超出16位，所以定义两个字变量用于保存X和Y，
另外用一个32位的双字变量来保存结果。数据段可定义如下：
程序名：T3-2.ASM
功能：计算16X+Y 
DSEG SEGMENT
XXX DW 1234H
YYY DW 5678H
ZZZ DD ?
DSEG ENDS
CPU对寄存器操作数的运算操作要比对存储器操作数的运算操作快得多，所以应尽量利用寄存器进行运算操作。
用DX和AX寄存器保存中间结果，DX保存高16位，AX保存低16位。结合上述数据段，程序的代码段如下：
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV AX,XXX
XOR DX,DX
ADD AX,AX
ADC DX,DX
ADD AX,AX
ADC DX,DX
ADD AX,AX
ADC DX,DX
ADD AX,AX
ADC DX,DX
ADD AX,YYY
ADC DX,0
MOV WORD PTR ZZZ,AX
MOV WORD PTR ZZZ+2,DX
MOV AH,4CH
INT 21H
CSEG ENDS
END START
测试通过的完整程序如下
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
XXX DW 1234H
YYY DW 5678H
ZZZ DD ?
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV AX,XXX
XOR DX,DX
ADD AX,AX
ADC DX,DX
ADD AX,AX
ADC DX,DX
ADD AX,AX
ADC DX,DX
ADD AX,AX
ADC DX,DX
ADD AX,YYY
ADC DX,0
MOV WORD PTR ZZZ,AX
MOV WORD PTR ZZZ+2,DX
MOV AH,4CH
INT 21H
CSEG ENDS
END START
上面的代码分为六步，必须依次执行。第（2）步和第（5）步中的两条指令语句可以分别颠倒，其它各步中的指令语句均不能颠倒。
第（3）步是计算X*16，采用了四次自身相加的方法达到乘16的目的。
也可采用移位的方法达到乘16的目的，这样就不能简单地把16位扩展到32位，第（2）步和第（3）步可合并如下：
MOV AX,XXX
MOV DX,AX
MOV CL,4
SHL AX,CL
MOV CL,12
SHR DX,CL
还有一个更简单的方法计算X*16，那就是采用乘法指令。对应于第（2）步和第（3）步的代码可简化如下：
MOV AX,XXX
MOV DX,16
MUL DX
显然，代码长度越来越短，但这并不意味着执行速度越来越快，因为执行一条乘除法指令所花的时间较多。
当乘数是2的倍数时，往往可用移位指令实现乘运算：当乘数较小时，往往可采用相加的方法实现乘运算；
在对执行速度要求不大的情况下，可直接采用乘法指令实现乘运算。
例2：写一个把压缩存放的BCD码，转换为对应十进制数字ASCII码的程序。
所谓压缩存放是指一个字节中存放两个BCD码，即低4位存放一个BCD码，高4位存放一个BCD码。
如果仅仅是低4位存放一个BCD码，就称为非压缩存放。8421BCD码与对应十进制数字ASCII码的关系很简单，
在非压缩BCD码上加30H，就得对应十进制数字的ASCII码。源程序如下：
程序名：T3-3.ASM
功能：压缩BCD码转换成ASCII码
DSEG SEGMENT
BCD DB 86H
ASCII DB 2 DUP (0)
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV AL,BCD
AND AL,0FH
ADD AL,30H
MOV ASCII+1,AL
MOV AL,BCD
MOV CL,4
SHR AL,CL
ADD AL,30H
MOV ASCII,AL
MOV АН,4CH
INT 21H
CSEG ENDS
END START
测试通过的完整程序如下
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
BCD DB 86H
ASCII DB 2 DUP (0)
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV AL,BCD
AND AL,0FH
ADD AL,30H
MOV ASCII+1,AL
MOV AL,BCD
MOV CL,4
SHR AL,CL
ADD AL,30H
MOV ASCII,AL
MOV AH,4CH
INT 21H
CSEG ENDS
END START
上述代码段中的第（2）步和第（3）步可以颠倒，它们分别独立地把存放在低位和高位的BCD码转换为对应十进制数的ASCII码。
3.4.2 简单查表法代码转换
在汇编语言程序设计中，代码转换是经常的事。上面的把BCD码转换成ASCII码就是一例。
对于各种不同代码之间的转换，往往要采用各种不同的方法，以便获得最佳效率。
查表是实现代码转换的一种方法，下面介绍的简单查表方法是一种计算查表方法，适用于代码集合较小且转换关系复杂的场合
例3：写一个把16进制数字码转换为对应七段代码的程序。
利用如图3.5所示的七段显示数码管，能较好地显示16进制数字（0,...,9,A,b,C,d,E,F），七段数码管的每一段对应一个二进制位，
如果我们设0表示对应段亮，1表示对应段暗，那么数字码0对应以二 数码管示意图进制形式表示的代码1000000，
数字码1对应以二进形式表示的代码1111001，如此，数字码F对应以二进制形式表示的代码0001110，
这种用于表示七段数码管亮暗的代码就称为七段代码。
显然，16进制数字码与七段代码间的关系难以表示成一个简单的算术表达式，所以，利用表的方法实现代码转换较合适。
数字码0 七段代码1000000
数字码1 七段代码1111001
数字码2 七段代码0100100
数字码3 七段代码0110000

数字码4 七段代码0011001
数字码5 七段代码0010010
数字码6 七段代码0000010
数字码7 七段代码1111000

数字码8 七段代码0000000
数字码9 七段代码0010000
数字码A 七段代码0001000
数字码b 七段代码0000011

数字码C 七段代码1000110
数字码d 七段代码0100001
数字码E 七段代码0000110
数字码F 七段代码0001110
源程序如下：
程序名：T3-4.ASM
功能：16进制数字码到七段代码的转换
DSEG SEGMENT
TAB DB 1000000B,1111001B,0100100B,0110000B
DB 0011001B,0010010B,0000010B,1111000B
DB 0000000B,0010000B,0001000B,0000011B
DB 1000110B,0100001B,0000110B,0001110B
XCODE DB 8
YCODE DB ?
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV BL,XCODE
AND BL,0FH
XOR BH,BH
MOV AL,TAB[BX]
MOV YCODE,AL
MOV AH,4CH
INT 21H
CSEG ENDS
END START
测试通过的完整程序如下
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
TAB DB 1000000B,1111001B,0100100B,0110000B
DB 0011001B,0010010B,0000010B,1111000B
DB 0000000B,0010000B,0001000B,0000011B
DB 1000110B,0100001B,0000110B,0001110B
XCODE DB 8
YCODE DB ?
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV BL,XCODE
AND BL,0FH
XOR BH,BH
MOV AL,TAB[BX]
MOV YCODE,AL
MOV AH,4CH
INT 21H
CSEG ENDS
END START
利用查表的方法实现代码转换的关键是表的组织。上述程序中按16进制数字码的大小组织七段代码表，这就便于查找。
可以说，实际上没有进行真正的查找，只是根据16进制数字码，确定对应代码在表中的位置而已。这种代码转换方法简明快捷。
8086/8088CPU还专门提供一条查表指令XLAT（也称为换码指令），以方便实现上述这种类型的查表。
查表指令XLAT的格式如下：
XLAT
该指令把寄存器BX的内容作为表（每项一字节）的首地址，把寄存器AL的值作为下标，取出表项内容再送AL寄存器。
也就是把寄存器AL中的内容转换成表中对应项的值，此即所谓的换码。
使用此指令前，应先把表的首地址送BX寄存器。表最大为256项。
此指令属于数据传送指令组。
利用XLAT指令，上述程序T3-4.ASM的转换部分的代码可改写如下：
MOV BX,OFFSET TAB
MOV AL,XCODE
AND AL,0FH
XLAT
测试通过的完整程序如下
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
TAB DB 1000000B,1111001B,0100100B,0110000B
DB 0011001B,0010010B,0000010B,1111000B
DB 0000000B,0010000B,0001000B,0000011B
DB 1000110B,0100001B,0000110B,0001110B
XCODE DB 2
YCODE DB ?
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV BX,OFFSET TAB
MOV AL,XCODE
AND AL,0FH
XLAT
MOV YCODE,AL
MOV AH,4CH
INT 21H
CSEG ENDS
END START
3.4.3查表法求函数值
有许多数学函数的求值计算用汇编语言实现较为困难，除非利用数学协处理器。然而，上述这种表的组织形式和查表的方法，
能够适用于直接获得某些数学函数的值。
例4：设X是一个1~10之间的整数，写一个求函数Y=LG(X)值的程序。
把1~10这10个数的对数值组织成一张表，那么程序运行时的计算工作就大大简化，甚至可以说没有具体的计算。
由于1~10的以10为底的对数在0~1的范围之间，为了表示的方便和考虑一定的精度，所以把这些对数值放大10000倍，
这样每个对数值就用一个字表示。源程序如下：
程序名：T3-5.ASM
功能：求1到10的对数值
DSEG SEGMENT
VALUE DB 4
ANSWER DW ?
TAB DW 0,3010,4771,6021,6990,7782,8451,9031,9542,10000
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV AL,VLAUE
XOR AH,AH
DEC AX
ADD AX,AX
MOV BX,AX
MOV AX,TAB[BX]
MOV ANSWER,AX
MOV AH 4CH
INT 21H
CSEG ENDS
END START
测试通过的完整程序如下
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
VALUE DB 4
ANSWER DW ?
TAB DW 0,3010,4771,6021,6990,7782,8451,9031,9542,10000
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV AL,VALUE
XOR AH,AH
DEC AX
ADD AX,AX
MOV BX,AX
MOV AX,TAB[BX]
MOV ANSWER,AX
MOV AH,4CH
INT 21H
CSEG ENDS
END START
由于1的对数值是第一项，所以首先要自变量值X减1；又由于每个对数值用一个字表示，所以在计算表项在表内的地址时要乘2。
上述程序没有考虑超出范围的情况。
使用查表法求函数值有两个优点：（1）程序比较容易；（2）能够得到十进制或十六进制（或任何其他）格式的高精度函数值。
其缺点也许不那么明显：（1）函数值必须事先安排好因而有许多限制：（2）函数值的精度和准确性由程序员控制，
而不是由数学函数决定，当数据表的项较多时，难免有误差。
3.5分支程序设计
几乎所有的程序都不是从头顺序地执行到尾，而是在处理中经常存在着判断，并根据某种条件的判定结果而转向不同的处理。
这样程序就不再是简单地顺序执行，而是分成两个或多个分支。本节介绍分支程序设计的基本方法。
3.5.1分支程序举例
程序分支的两种基本结构如图3.6所示，这两种结构分别对应高级语言中的if语句和if-else语句。
在汇编语言中，一般利用条件测试指令和条件转移指令等实现简单的分支。
例1：设有三个单字节无符号数存放在BUFFER开始的缓冲区中，写一个能将它们按大到小重新排列的程序。
假设数据段就只有三个要排序的数据，定义如下：
程序名：T3-6.ASM
功能：实现三个无符号数的由大到小的排序
DATAS SEGMENT
BUFFER DB 87,234,123
DATAS ENDS
有多种方法可实现三个数的排序，我们采用交换法，先得到三个数中的最大数，然后再得到剩下两个数的最大数。
为了方便，先把要排序的三个数取到三个寄存器中。源程序代码段如下所示：
CODES SEGMENT
ASSUME CS:CODES,DS:DATAS
START:MOV AX,DATAS
MOV DS,AX
MOV SI,OFFSET BUFFER
MOV AL,[SI]
MOV BL,[SI+1]
MOV CL,[SI+2]
CMР AL,BL
JAE NEXT1
XCHG AL,BL
NEXT1:CMP AL,CL
JAE NEXT2
XCHG AL,CL
NEXT2:CMP BL,CL
JAЕ NEXT3
XCHG BL,CL
NEXT3:MOV [SI],AL
MOV [SI+1],BL
MOV [SI+2],CL
MOV AH,4CH
INT 21H
CODES ENDS
END START
测试通过的完整程序如下
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DATAS SEGMENT
BUFFER DB 87,234,123
DATAS ENDS
CODES SEGMENT
ASSUME CS:CODES,DS:DATAS
START:MOV AX,DATAS
MOV DS,AX
MOV SI,OFFSET BUFFER
MOV AL,[SI]
MOV BL,[SI+1]
MOV CL,[SI+2]
CMP AL,BL
JAE NEXT1
XCHG AL,BL
NEXT1:CMP AL,CL
JAE NEXT2
XCHG AL,CL
NEXT2:CMP BL,CL
JAE NEXT3
XCHG BL,CL
NEXT3:MOV [SI],AL
MOV [SI+1],BL
MOV [SI+2],CL
MOV AH,4CH
INT 21H
CODES ENDS
END START
在上述的排序片段中，含有三个分支，每个分支都是图3.6（a）的结构。
另外，上述程序先把三个要排序的数取到三个寄存器中。当然也可以不这样做，而是直接在内存中交换排序。
请把下面的程序片段与上述程序中的（2）、（3）和（4）步作一比较，孰优孰劣？
MOV SI,OFFSET BUFFER
MOV AL,[SI]
СМP AL,[SI+1]
JAE NEXT1
XCHG AL,[SI+1]
MOV [SI],AL
NEXT1:CMP AL,[SI+2]
JAE NEXT2
XCHG AL,[SI+2]
MOV [SI],AL
NEXT2:MOV AL,[SI+1]
CMP AL,[SI+2]
JAE NEXT3
XCHG AL,[SI+2]
MOV [SI+1],AL
NEXT3:
测试通过的完整程序如下
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DATAS SEGMENT
BUFFER DB 87,234,123
DATAS ENDS
CODES SEGMENT
ASSUME CS:CODES,DS:DATAS
START:MOV AX,DATAS
MOV DS,AX
MOV SI,OFFSET BUFFER
MOV AL,[SI]
CMP AL,[SI+1]
JAE NEXT1
XCHG AL,[SI+1]
MOV [SI],AL
NEXT1:CMP AL,[SI+2]
JAE NEXT2
XCHG AL,[SI+2]
MOV [SI],AL
NEXT2:MOV AL,[SI+1]
CMP AL,[SI+2]
JAE NEXT3
XCHG AL,[SI+2]
MOV [SI+1],AL
NEXT3:MOV AH,4CH
INT 21H
CODES ENDS
END START
例2：写一个实现把一位十六进制数转换为对应ASCII码的程序。
十六进制数码与对应ASCI1码的关系如下所示：
这种对应关系可表示为一个分段函数：Y=X+30H（0<=X<=9），Y=X+37H（0AH<=X<=0FH）
所以，程序要根据十六进制数码值是否超过9而进行分支。源程序如下
程序名：T3-7.ASM
功能：十六进制数到ASCII码的转换
DATA SEGMENT
XX DB 4
ASCII DB ?
DATA ENDS
CODE SEGMENT
ASSUME CS:CODE,DS:DATA
START:MOV AX,DATA
MOV DS,AX
MOV AL,XX
AND AL,0FH
СМР AL,9
JA LAB1
ADD AL,30H
JMP LAB2
LAB1:ADD AL,37H
LAB2:MOV ASCII AL
MOV AH,4CH
INT 21H
CODE ENDS
END START
测试通过的完整程序如下
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DATA SEGMENT
XX DB 4
ASCII DB ?
DATA ENDS
CODE SEGMENT
ASSUME CS:CODE,DS:DATA
START:MOV AX,DATA
MOV DS,AX
MOV AL,XX
AND AL,0FH
CMP AL,9
JA LAB1
ADD AL,30H
JMP LAB2
LAB1:ADD AL,37H
LAB2:MOV ASCII,AL
MOV AH,4CH
INT 21H
CODE ENDS
END START
上述程序中进行转换工作的指令（1）-（6）符合图3.6（b）的结构，指令（3）的无条件转移语句（指令）很重要，
如果没有这条指令，分支的结构就简化成为图3.6（a）。
由于上述程序分支的一边稍作变形后，可包含分支的另一边，所以进行代码转换工作可作如下优化，从而使处理既简单又高效。
ADD AL,30H
CMP AL,39H
JBE LAB2
ADD AL,07H
LAB2:
测试通过的完整程序如下
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DATA SEGMENT
XX DB 9
ASCII DB ?
DATA ENDS
CODE SEGMENT
ASSUME CS:CODE,DS:DATA
START:MOV AX,DATA
MOV DS,AX
MOV AL,XX
AND AL,0FH
ADD AL,30H
CMP AL,39H
JBE LAB2
ADD AL,07H
LAB2:MOV ASCII,AL
MOV AH,4CH
INT 21H
CODE ENDS
END START
一般情况下，如果分支结构同图3.6（b），且有一边很简单时，可考虑把它改变为图3.6（a）的结构。
具体的方法是，在判断之前先假设是简单的情况。
例3：写一个实现把一位十六进制数所对应的ASCII码转换为十六进制数的程序。
如果要转换的ASCII码没有对应的十六进制数码，则转换为特殊值负1。
考虑到A-F也能用小写字母表示，转换关系可用如下函数描述：
实现转换功能的源程序如下，其中对分支结构作了些优化处理
程序名：T3-8.ASM
功能：ASCII码转换为十六进制数
DATA SEGMENT
XX DB ?
ASCII DB 'a'
DATA ENDS
CODE SEGMENT
ASSUME CS:CODE,DS:DATA
START:MOV AX,DATA
MOV DS,AX
MOV AL,ASCII
CMP AL,'0'
JB LAB5
MOV AH,AL
SUB AH,'0'
CMP AL,'9'
JBE LAB6
CMP AL,'A'
JB LAB5
MOV AH,AL
SUB AH,'A'-10
CMP AL,'F'
JBE LAB6
CMP AL,'a'
JB LAB5
MOV AH,AL
SUB AH,'a'-10
CMP AL,'f'
JBE LAB6
LAB5:MOV AH,-1
LAB6:MOV XX,AH
MOV AH,4CH
INT 21H
CODE ENDS
END START
测试通过的完整程序如下
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DATA SEGMENT
XX DB ?
ASCII DB 'a'
DATA ENDS
CODE SEGMENT
ASSUME CS:CODE,DS:DATA
START:MOV AX,DATA
MOV DS,AX
MOV AL,ASCII
CMP AL,'0'
JB LAB5
MOV AH,AL
SUB AH,'0'
CMP AL,'9'
JBE LAB6
CMP AL,'A'
JB LAB5
MOV AH,AL
SUB AH,'A'-10
CMP AL,'F'
JBE LAB6
CMP AL,'a'
JB LAB5
MOV AH,AL
SUB AH,'a'-10
CMP AL,'f'
JBE LAB6
LAB5:MOV AH,-1
LAB6:MOV XX,AH
MOV AH,4CH
INT 21H
CODE ENDS
END START
由于大写字母的ASCII码值与对应小写字母的ASCII码值间相差20H，或者说大写字母ASCII码的位5为0，
而小写字母ASCII码的位5为1，所以指令“AND AL,0DFH“能把AL中的小写字母的ASCII码值转换为对应大写字母的ASCII码，
因此上述程序中进行代码转换的工作可进一步优化为：
CMP AL,'0'
JB LAB5
MOV AH,AL
SUB AH,'0'
CMP AL,'9'
JBE LAB6
AND AL,11011111B
CMP AL,'A'
JB LAB5
MOV AH,AL
SUB AH,'A'-10
CMP AL,'F'
JBE LAB6
LAB5:
测试通过的完整程序如下
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DATA SEGMENT
XX DB ?
ASCII DB 'a'
DATA ENDS
CODE SEGMENT
ASSUME CS:CODE,DS:DATA
START:MOV AX,DATA
MOV DS,AX
MOV AL,ASCII
CMP AL,'0'
JB LAB5
MOV AH,AL
SUB AH,'0'
CMP AL,'9'
JBE LAB6
AND AL,11011111B
CMP AL,'A'
JB LAB5
MOV AH,AL
SUB AH,'A'-10
CMP AL,'F'
JBE LAB6
LAB5:MOV AH,-1
LAB6:MOV XX,AH
MOV AH,4CH
INT 21H
CODE ENDS
END START
如果不考虑待转换的字符可能不是十六进制数码的情况，则程序要简单得多。
通过指令“OR AL,20H”把AL寄存器中的大写字母ASCII码值转换为对应的小写字母的ASCII码值，
如果AL中是数字符的ASCII码，也不会受影响。相应的代码如下：
OR AL,20H
SUB AL,'0'
CMP AL,9
JBE LAB4
SUB AL,'a'-'0'-10
LAB4:MOV XX,AL
3.5.2利用地址表实现多向分支
当要根据某个变量的值，进行多种不同处理时，就产生了多向分支。多向分支的结构如图3.7所示。
在高级语言中，常用switch语句等实现多向分支。在汇编语言中，如何实现多向分支呢？
任何复杂的多向分支总可分解成多个简单分支。图3.8给出了根据X的值是否为1~4，而进行5种不同处理的流程图片段。
用汇编语言实现这种多向分支的源程序结构如下所示：
CMP AH,1
JZ YES_1
JMP NOT_1
YES_1:
……
JMP OK
NOT_1: CMP AH,2
JZ YES_2
JMP NOT_2
YES_2:
……
JMP OK
NOT_2:CMP AH,3
JNZ NOT_3
YES_3:
……
JMP OK
NOT_3: CMP AH,4
JNZ NOT_4
YES_4:
……
JMP SHORT OK
NOT_4:
……
OK:
……
在上述说明多向分支程序结构的（*）语句处，无条件转移指令和条件转移指令配合实现分支（远距离条件转移）；
在（**）语句处，假设地址差能用一字节表示，故没有使用无条件转移指令；
在（***）处也假设地址差能用一字节表示，故使用了SHORT。在实际的程序中，要根据具体情况选择使用合适的指令。
这种程序结构显得繁琐，如果要用它实现5路以上的多向分支，则更加复杂。在汇编语言中，可使用地址表实现多向分支。
当多向分支在5路以上时，用地址表实现起来既方便又高效。
设程序MBRANCH每次只接收一个单键命令”A”至"H”，然后根据命令进行相应的处理。
如果接受到的输入不是规定的命令字母，则不处理。
为了利用入口地址表（也称散转表）实现多向分支，事先必须安排一张入口地址表。
如果各处理程序均在同一代码段内，则入口地址只要用偏移表示，所以入口地址表的每一项只用一个字。
MBRANCH的地址表可如下组织：
DSEG SEGMENT
……
COMTAB DW COMA,COMB,COMC,COMD
DW COME,COMF,COMG,COMH
……
DSEG ENDS
有了上述地址表后，多向分支的实现是方便的。采用地址表实现多向分支的MBRANCH源程序的有关代码如下所示：
……
MOV AH,1
INT 21H
AND AL,11011111B
CMP AL,'A'
JB OK
CMP AL,'H'
JA OK
SUB AL,'A'
XOR AH,AH
ADD AX,AX
MOV BX,AX
JMP WORD PTR COMTAB[BX]
MOV AH,4CH
INT 21H
COMA:
……
JMP OK
COMB:
……
JMP OK
COMC:
……
JMP OK
……
COMH:
……
JMP OK
上述代码中真正实现多向分支的部分是注释行带（**）的指令。
通过地址表实现多向分支的关键是，根据分支各路的条件确定对应处理程序的入口地址在地址表中的位置，
或者说对应处理程序的编号。在程序MBRANCH中，代表命令的字母是连续的，所以很容易由命令字母得出对应处理程序的编号。
如果命令字母不连续，则稍稍复杂些。
3.6循环程序设计
当要重复某些操作时，就应考虑使用循环。循环通常由四部分组成：
（1）初始化部分；
（2）循环体部分；
（3）调整部分；
（4）控制部分。
各部分之间的关系如图3.9所示。图3.9（a）是先执行后判断的结构，图3.9（b）是先判断后执行的结构。
有时这四部分可以简化，形成互相包含交叉的情况，不一定能明确分成四部分。
有多种方法可实现循环的控制，常用的有计数控制法和条件控制法等。本节介绍循环程序设计的基本方法。
3.6.1循坏程序举例
在第2章中介绍的若干数据求和等程序片段均采用了循环结构，下面再举几例，说明实现循环的基本方法。
例1：求内存中从地址0040：0000H开始的1024个字的字检验和。
所谓字检验和是指，结果只用字表示，忽略可能产生的进位。在数据传输时，为了保证数据传输的正确性，
一般要对传输的数据进行某种检查，常的简单检查方法是检查数据的按字节或字累计的和。
程序采用如图3.9（a）所示的循环结构，这个循环的四部分俱全。
在初始化部分设置存储器指针和循环计数器等；循环体部分只要实现累加求和，并不要考虑进位；
存储器指针的调整作为循环调整部分的内容；采用计数法控制循环。源程序如下：
程序名：T3-9.ASM
功能：说明根据计数法控制循环
DSEG SEGMENT
SUM DW ?
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG
START:MOV AX,40H
MOV DS,AX
MOV SI,0
MOV CX,1024
XOR AX,AX
AGAIN:ADD AX,[SI]
INC SI
INC SI
LOOP AGAIN
ASSUME DS:DSEG
MOV BX,DSEG
MOV DS,BX
MOV SUM,AX
MOV AH,4CH
INT 21H
CSEG ENDS
END START
测试通过的完整程序如下
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
SUM DW ?
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG
START:MOV AX,40H
MOV DS,AX
MOV SI,0
MOV CX,1024
XOR AX,AX
AGAIN:ADD AX,[SI]
INC SI
INC SI
LOOP AGAIN
ASSUME DS:DSEG
MOV BX,DSEG
MOV DS,BX
MOV SUM,AX
MOV AH,4CH
INT 21H
CSEG ENDS
END START
在初始化部分设置数据段寄存器DS之值为40H，这与先前的程序稍有不同，实际上，根据要求被处理的数据已明确在40H段。
在得到检验和之后，重新设置数据段寄存器DS之值为程序中定义的DSEG段的段值，以便保存检验和。
例2：不利用乘法指令实现乘法运算。
为了简单，设乘数和被乘数均是单字节无符号整数。举本例的目的是为了说明设计循环程序的基本方法，并非提倡不利用乘法指令。
另一方面确有不能使用乘法指令的场合，例如Z80的指令集中无乘法指令，那么只有用其他方法实现乘法运算了。
下面的程序采用累加的方法实现乘法，也就是把被乘数累加乘数次得到积。
由于设被乘数和乘数均是单字节无符号整数，所以积只用一个字表示。源程序如下：
程序名：T3-10.ASM
功能：（略）
DSEG SEGMENT
XXX DB 234
YYY DB 125
ZZZ DW ?
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV AL,XXX
XOR AH,AH
MOV CL,YYY
XOR CH,CH
XOR DX,DX
JCXZ OK
MULTI:ADD DX,AX
LOOP MULTI
OK:MOV ZZZ,DX
MOV AH,4CH
INT 21H
CSEG ENDS
END START
测试通过的完整程序如下
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
XXX DB 234
YYY DB 125
ZZZ DW ?
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV AL,XXX
XOR AH,AH
MOV CL,YYY
XOR CH,CH
XOR DX,DX
JCXZ OK
MULTI:ADD DX,AX
LOOP MULTI
OK:MOV ZZZ,DX
MOV AH,4CH
INT 21H
CSEG ENDS
END START
在上述程序的循环中，只有循环的三部分，而缺少循环调整部分。为了使循环体简单，所以把被乘数扩展成16位，
从而可直接采用16位的累加。如果只采用8位累加，则循环体可修改如下：
ADD DL,AL
ADC DH,0
采用累加的方法实现乘法运算虽然简单，但当乘数稍大时将花较多的时间。
一般可采用移位相加的方法实现乘法运算，移位相加的方法类似于手算。
图3.10是一种移位相加法实现乘法运算的流程图，其中被乘数左移，乘数右移。图3.10符合图3.9（a）所示的循环结构。
实现图3.10所示流程图的源程序片段如下所示：
MOV AL,XXX
XOR AH,AH
MOV BL,YYY
XOR DX,DX
MOV CX,8
MULTl:SHR BL,1
JNC NEXT
ADD DX,AX
NEXT:ADD AX,AX
LOOP MULTI
MOV ZZZ,DX
测试通过的完整程序如下
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
XXX DB 234
YYY DB 125
ZZZ DW ?
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV AL,XXX
XOR AH,AH
MOV BL,YYY
XOR DX,DX
CMP BL,0
JZ OK
MOV CX,8
MULTl:SHR BL,1
JNC NEXT
ADD DX,AX
NEXT:ADD AX,AX
LOOP MULTI
OK:MOV ZZZ,DX
MOV AH,4CH
INT 21H
CSEG ENDS
END START
例3：把16位二进制数转换为5位十进制数。为了简单，设二进制数是无符号的，采用8421BCD码表示十进制数。
16位二进制数能表示的最大十进制数只有5位，即最高位是“万位”。有多种转换方法。这里采用的方法是：
先把二进制数除以10000，得到的商即为十进制数的“万位”；再用余数除以1000，得到的商为十进制数的“千位”；
按照这样的顺序，分别用每次的余数除以100、10、1得到的商分别为十进制数的“百位”、“十位”和“个位”。
每次除后得到的商就是8421BCD码。
我们用一个循环次数确定为5的循环来实现转换。在每次循环中，先获取新的除数；然后进行除法；保存商；
由于使用16位除数，还要把除后的余数调整为32位作为新的被除数。源程序如下：
程序名：T3-11.ASM
功能：（略）
DSEG SEGMENT
DATA DW 23456
BUFFER DB 5 DUP (0)
JM DW 10000,1000,100,10,1
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,SEG DATA
MOV DS,AX
MOV DI,OFFSET JM
MOV Sl,OFFSET BUFFER
MOV CX,5
MOV AX,DATA
XOR DX,DX
NEXT:MOV BX,[DI]
DIV BX
MOV [Sl],AL
ADD Dl,2
INC SI
MOV AX,DX
XOR DX,DX
LOOP NEXT
MOV AX,4C00H
INT 21H
CSEG ENDS
END START
测试通过的完整程序如下
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
DATA DW 23456
BUFFER DB 5 DUP (0)
JM DW 10000,1000,100,10,1
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,SEG DATA
MOV DS,AX
MOV DI,OFFSET JM
MOV SI,OFFSET BUFFER
MOV CX,5
MOV AX,DATA
XOR DX,DX
NEXT:MOV BX,[DI]
DIV BX
MOV [SI],AL
ADD DI,2
INC SI
MOV AX,DX
XOR DX,DX
LOOP NEXT
MOV AX,4C00H
INT 21H
CSEG ENDS
END START
如果要把各位十进制数字用对应的ASCII码表示，那么只需在除法指令和保存商指令之间加入指令“ADD AL,30H”，
该指令实现把AL寄存器中的BCD码转换为对应的ASCII码。
利用王爽 汇编语言第三版中的dtoc和divdw子程序，实现把16位二进制数转换为对应十进制数的ASCII码。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
DATA DW 23456
BUFFER DB 6 DUP (0)
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,SEG DATA
MOV DS,AX
MOV SI,OFFSET BUFFER
MOV AX,DATA
XOR DX,DX
CALL DTOC
MOV AX,4C00H
INT 21H
dtoc:push dx
push cx
push bx
push ax
push si
push di
mov di,0
divide:mov cx,dx
jcxz finish_s
divide_s:mov cx,0AH
call divdw
inc di
push cx
jmp divide
finish_s:mov cx,ax
jcxz finish
jmp divide_s
finish:mov cx,di
string:pop bx
add bx,30h
mov ds:[si],bl
inc si
loop string
mov ds:[si],0
pop di
pop si
pop ax
pop bx
pop cx
pop dx
ret
divdw:push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
CSEG ENDS
END START
例4：写一个把字符串中的所有大写字母改为小写的程序。设字符串以0结尾。
图3.11是实现的流程图，具有图3.9（b）所示的结构。
它的主体是一个循环次数不确定（字符串长不确定），根据是否到达字符串尾这个条件来控制的循环。
源程序如下，数据段中的字符串起示例作用。
程序名：T3-12.ASM
功能：说明根据某个条件控制的循环
DSEG SEGMENT
STRING DB 'HOW are yoU?',0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV SI,OFFSET STRING
AGAIN:MOV AL,[SI]
OR AL,AL
JZ OK
CMP AL,'A'
JB NEXT
CMP AL,'Z'
JA NEXT
OR AL,20H
MOV [SI],AL
NEXT:INC SI
JMP AGAIN
OK:MOV AX,4C00H
INT 21H
CSEG ENDS
END START
测试通过的完整程序如下
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
STRING DB 'HOW are yoU?',0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV SI,OFFSET STRING
AGAIN:MOV AL,[SI]
OR AL,AL
JZ OK
CMP AL,'A'
JB NEXT
CMP AL,'Z'
JA NEXT
OR AL,20H
MOV [SI],AL
NEXT:INC SI
JMP AGAIN
OK:MOV AX,4C00H
INT 21H
CSEG ENDS
END START
上述的循环采用先判后执行的结构。此外，为了更有效，可作如下变形：
MOV SI,OFFSET STRING
AGAIN:MOV AL,[SI]
INC SI
OR AL,AL
JZ OK
CMP AL,'A'
JB AGAIN
CMP AL,'Z'
JA AGAIN
ADD AL,20H
MOV [SI-1],AL
JMP AGAIN
测试通过的完整程序如下
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
STRING DB 'HOW are yoU?',0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV SI,OFFSET STRING
AGAIN:MOV AL,[SI]
INC SI
OR AL,AL
JZ OK
CMP AL,'A'
JB AGAIN
CMP AL,'Z'
JA AGAIN
ADD AL,20H
MOV [SI-1],AL
JMP AGAIN
OK:MOV AX,4C00H
INT 21H
CSEG ENDS
END START
例5：写一个程序判定从地址0040：0000H开始的2048个内存字节单元中是否有字符’A'。如有则把第一个（按地址由小到大为序）
含此指定字符的存储单元的地址偏移送到0000：03FEH单元中；如没有则把特征值0FFFFH送上述指定单元。
图3.12是流程图，含有一个由计数和条件双重控制的一个循环，也就是最多循环N次，在N次循环过程中，如特定条件满足，
则提前结束循环。
实现上述流程的源程序不需要数据段。为了使程序便于阅读和修改，在程序开始定义了若干符号常量。
程序名：T3-13.ASM
功能：说明由计数和条件双重控制的循环
常量定义
SEGADDR = 40H
OFFADDR = 0
COUNT = 2048
KEYCHAR = 'A’
SEGRESU = 0
OFFRESU = 3FEH
CSEG SEGMENT
ASSUME CS:CSEG
START:MOV AX,SEGADDR
MOV DS,AX
MOV SI,OFFADDR
MOV CX,COUNT
MOV AL,KEYCHAR
NEXT:CMP AL,[SI]
JZ OK
INC SI
LOOP NEXT
MOV Sl,0FFFFH
OK:MOV AX,SEGRESU
MOV DS,AX
MOV BX,OFFRESU
MOV [BX],SI
MOV AH,4CH
INT 21H
CSEG ENDS
END START
测试通过的完整程序如下
SEGADDR = 40H
OFFADDR = 0
COUNT = 2048
KEYCHAR = 'A'
SEGRESU = 0
OFFRESU = 3FEH
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG
START:MOV AX,SEGADDR
MOV DS,AX
MOV SI,OFFADDR
MOV CX,COUNT
MOV AL,KEYCHAR
NEXT:CMP AL,[SI]
JZ OK
INC SI
LOOP NEXT
MOV SI,0FFFFH
OK:MOV AX,SEGRESU
MOV DS,AX
MOV BX,OFFRESU
MOV [BX],SI
MOV AH,4CH
INT 21H
CSEG ENDS
END START
例6：设缓冲区DATA中有一组单字节有符号数，以0为结束标志。写一个程序实现如下功能：
把前5个正数依次送入缓冲区PDATA，把前5个负数依次送入缓冲区MDATA；如正数或负数不足5个，则用0补足。
在把正数和负数送入对应缓冲区前，用0填正数和负数缓冲区，从而实现“如正数或负数不足5个，则用0补足”的要求。
这通过一个循环次数确定的循环完成。然后，获取前5个正数和负数，这也用一个循环结构来实现。
第二个循环的结束条件是：遇到结束标志，或者获取的正数个数和负数个数均已为5。图3.13给出了流程图。
我们用变址寄存器SI和Dl作为已获取的正数和负数的计数器，这样做不仅可方便地把获得的正数和负数送入相应的缓冲区，
而且有利于统计已取得的正数和负数的个数。源程序如下所示。
程序名：T3-14.ASM
功能：（略）
MAX_COUNT  = 5
DSEG SEGMENT
DATA DB 3,-4,5,6,-7,8,-9,-10,-1,-32,-123,27,58,44,-12,0
PDATA DB MAX_COUNT DUP (?)
MDATA DB MAX_COUNT DUP (?)
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV CX,MAX_COUNT
MOV SI,OFFSET PDATA
MOV DI,OFFSET MDATA
MOV AL,0
NEXT1:MOV [SI],AL
MOV [DI],AL
INC SI
INC DI
LOOP NEXT1
MOV BX,OFFSET DATA
XOR SI,SI
XOR DI,DI
NEXT2:MOV AL,[BX]
INC BX
CMP AL,0
JZ OVER
JG PLUS
CMP Dl,MAX_COUNT
JAE CONT
MOV MDATA[DI],AL
INC DI
JMP SHORT CONT
PLUS:CMP SI,MAX_COUNT
JAE CONT
MOV PDATA[SI],AL
INC SI
CONT:MOV AX,SI
ADD AX,DI
CMP AX,MAX_COUNT+MAX_COUNT
JB NEXT2
OVER:MOV AH,4CH
INT 21H
CSEG ENDS
END START
测试通过的完整程序如下
MAX_COUNT  = 5
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
DATA DB 3,-4,5,6,-7,8,-9,-10,-1,-32,-123,27,58,44,-12,0
PDATA DB MAX_COUNT DUP (?)
MDATA DB MAX_COUNT DUP (?)
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV CX,MAX_COUNT
MOV SI,OFFSET PDATA
MOV DI,OFFSET MDATA
MOV AL,0
NEXT1:MOV [SI],AL
MOV [DI],AL
INC SI
INC DI
LOOP NEXT1
MOV BX,OFFSET DATA
XOR SI,SI
XOR DI,DI
NEXT2:MOV AL,[BX]
INC BX
CMP AL,0
JZ OVER
JG PLUS
CMP DI,MAX_COUNT
JAE CONT
MOV MDATA[DI],AL
INC DI
JMP SHORT CONT
PLUS:CMP SI,MAX_COUNT
JAE CONT
MOV PDATA[SI],AL
INC SI
CONT:MOV AX,SI
ADD AX,DI
CMP AX,MAX_COUNT+MAX_COUNT
JB NEXT2
OVER:MOV AH,4CH
INT 21H
CSEG ENDS
END START
3.6.2多重循环程序举例
所谓多重循环就是循环之中还有循环。
例7：设BUFFER缓冲区中有10个单字节无符号整数，写一个程序将它们由小到大排序。
有各种各样的排序算法，这里为了方便地说明二重循环，采用“简单选择”法，图3.14是流程图。
源程序如下，其中SI相当于外层循环控制变量I，DI相当于内层循环控制变量J，为了使I从1开始递增，
排序数组开始地址先减1后再存入BX寄存器。
程序名：T3-15.ASM
功能：说明二重循环的实现
DSEG SEGMENT
BUFFER DB 23,12,45,32,127,3,9,58,81,72
N EQU 10
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV BX,OFFSET BUFFER-1
MOV SI,1
FORI:MOV DI,SI
INC DI
FORJ:MOV AL,[BX+SI]
CMP AL,[BX+DI]
JBE NEXTJ
XCHG AL,[BX+DI]
MOV [BX+SI],AL
NEXTJ:INC DI
CMP Dl,N
JBE FORJ
NEXTI:INC SI
CMP SI,N-1
JBE FORI
MOV AH,4CH
INT 21H
CSEG ENDS
END START
测试通过的完整程序如下
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
BUFFER DB 23,12,45,32,127,3,9,58,81,72
N EQU 10
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV BX,OFFSET BUFFER-1
MOV SI,1
FORI:MOV DI,SI
INC DI
FORJ:MOV AL,[BX+SI]
CMP AL,[BX+DI]
JBE NEXTJ
XCHG AL,[BX+DI]
MOV [BX+SI],AL
NEXTJ:INC DI
CMP DI,N
JBE FORJ
NEXTI:INC SI
CMP SI,N-1
JBE FORI
MOV AH,4CH
INT 21H
CSEG ENDS
END START
读者能否在保持算法的前提下，对上述程序作些优化工作。
优化在于MOV AL,[BX+SI]和MOV [BX+SI],AL
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
BUFFER DB 23,12,45,32,127,3,9,58,81,72
N EQU 10
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV BX,OFFSET BUFFER-1
MOV SI,1
FORI:MOV DI,SI
INC DI
MOV AL,[BX+SI]
FORJ:CMP AL,[BX+DI]
JBE NEXTJ
XCHG AL,[BX+DI]
NEXTJ:INC DI
CMP DI,N
JBE FORJ
MOV [BX+SI],AL
NEXTI:INC SI
CMP SI,N-1
JBE FORI
MOV AH,4CH
INT 21H
CSEG ENDS
END START
例8：设字符串1在数据段1中，字符串2在数据段2中，写一程序判别字符串2是否是字符串1的子字符串。
如是子字符串，则把数据段2中的FLAG单元置1，否则将其清0。设字符串以0结尾。
判别一个字符串是否是另一字符串的子字符串的方法很多，我们选取实现较简单的一种算法，源程序如下。
程序名：T3-16.ASM
功能：（略）
DSEG1 SEGMENT
STRM DB "THIS IS A STRING!",0
DSEG1 ENDS
DSEG2 SEGMENT
STRS DB "STRING",0
FLAG DB ?
DSEG2 ENDS
CODE SEGMENT
ASSUME CS:CODE,DS:DSEG1,ES:DSEG2
START:MOV AX,DSEG1
MOV DS,AX
MOV AX,DSEG2
MOV ES,AX
MOV DI,OFFSET STRS
MOV BX,DI
XOR CX,CX
DEC DI
WHILE1:INC DI
INC CX
CMP BYTE PTR ES:[DI],0
JNZ WHILE1
DEC CX
MOV DX,CX
MOV SI,OFFSET STRM
MOV BP,SI
FORI:MOV CX,DX
MOV DI,BX
FORJ:MOV AL,ES:[DI]
CMP [SI],AL
JNZ NEXTI
NEXTJ:INC DI
INC SI
LOOP FORJ
MOV FLAG,1
JMP OVER
NEXTI:CMP BYTE PTR [SI],0
JZ NOTF
INC BP
MOV SI,BP
JMP FORI
NOTF:MOV FLAG,0
OVER:MOV AH,4CH
INT 21H
CODE ENDS
END START
测试通过的完整程序如下
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG1 SEGMENT
STRM DB "THIS IS A STRING!",0
DSEG1 ENDS
DSEG2 SEGMENT
STRS DB "STRING",0
FLAG DB ?
DSEG2 ENDS
CODE SEGMENT
ASSUME CS:CODE,DS:DSEG1,ES:DSEG2
START:MOV AX,DSEG1
MOV DS,AX
MOV AX,DSEG2
MOV ES,AX
MOV DI,OFFSET STRS
MOV BX,DI
XOR CX,CX
DEC DI
WHILE1:INC DI
INC CX
CMP BYTE PTR ES:[DI],0
JNZ WHILE1
DEC CX
MOV DX,CX
MOV SI,OFFSET STRM
MOV BP,SI
FORI:MOV CX,DX
MOV DI,BX
FORJ:MOV AL,ES:[DI]
CMP [SI],AL
JNZ NEXTI
NEXTJ:INC DI
INC SI
LOOP FORJ
MOV FLAG,1
JMP OVER
NEXTI:CMP BYTE PTR [SI],0
JZ NOTF
INC BP
MOV SI,BP
JMP FORI
NOTF:MOV FLAG,0
OVER:MOV AH,4CH
INT 21H
CODE ENDS
END START
另请注意上面程序中ASSUME语句和给FLAG单元赋值的语句。
3.7习题
题3.1伪指令语句与指令语句的本质区别是什么？伪指令的主要作用是什么？
指令语句有着与其对应的机器指令，伪指令语句没有与其对应的机器指令。
伪指令语句指示汇编程序如何汇编源程序，包括符号的定义、变量的定义、段的定义等。
题3.2汇编语言中的表达式与高级语言中的表达式有何相同点和不同点？
相同点在于都通过运算符、操作符及括号把常数和符号连起来。
不同点在于汇编语言中的表达式除了数值表达式还有地址表达式。地址表达式所表示的是存储器操作数的地址。
题3.3汇编语言中数值表达式与地址表达式有何区别？
数值表达式的各部分在汇编时就能计算出数值。地址表达式的寄存器部分在汇编时无法确定具体的值。
题3.4汇编语言中的变量和标号有何异同之处？
变量和标号均表示存储器操作数，都具有如下三种属性：
（1）段值，变量或标号对应存储单元所在段的段值。
（2）偏移，变量或标号对应存储单元的起始地址的段内偏移。
（3）类型，变量的类型主要是字节（BYTE）、字（WORD）和双字（DWORD）；
标号的类型主要是近（NEAR）和远（FAR），近表示段内标号，远表示段间标号。
变量对应存储单元中存放数值；标号对应存储单元中存放机器指令代码。
汇编语言中各种运算符和操作符的优先级按高到低排列如下：
（1）圆括号，尖括号，方括号，圆点符，LENGTH，SIZE，WIDTH，MASK。
其中，尖括号使用于记录中，圆点符使用于结构中。
（2）PTR，OFFSET，SEG，TYPE，THIS，冒号。
其中，冒号用于表示段超越前缀。
（3）*，/，MOD，SHL，SHR。
（4）HIGH，LOW。
（5）+，-。
（6）EQ，NE，LT，LE，GT，GE。
（7）NOT。
（8）AND。
（9）OR，XOR。
（10）SHORT。
题3.5请计算如下各数值表达式的值：
（1）23H AND 45H OR 67H  = 67H
（2）1234H/16+10H = 133H
（3）NOT（65535 XOR 1234H）= 1234H
（4）1024 MOD 7+3 = 5
（5）LOW 1234 OR HIGH 5678H = D6H
（6）23H SHL 4 = 230H
（7）"Eb" GE 4562H XOR -1 = 0FFFFH XOR 0FFFFH = 0
（8）1234H SHR 6 = 0123H SHR 2 = 0048H
（9）'a' AND (NOT ('a'-'A')) = 41H
（10）'H' OR 00100000B = 68H
（11）76543Q LT 32768 XOR 76543Q = 32099 LT 32768 XOR 32099 = 0FFFFH XOR 7D63H = 829CH
（12）3645H AND 0FF00H = 3600H
题3.6请计算如下程序片段中各地址表达式的值，设BX=1000H，SI=2000H，DI=3000H，BP=4000H：
（1）[BX+100H] = [1100H]
（2）[DI][BP] = [7000H]
（3）2000H[SI] = [4000H]
（4）10H[BX][SI] = [3010H]
（5）[BP-128] = [3F80H]
（6）[BX][DI-2] = [3FFEH]
题3.7设在某个程序中有如下片段，请写出每条传送指令执行后寄存器AX的内容：
ORG 100H
VARW DW 1234H,5678H
VARB DB 3,4
VARD DD 12345678H
BUFF DB 10 DUP (?)
MESS DB 'HELLO'
BEGIN:MOV AX,OFFSET VARB + OFFSET MESS = 104H+114H=0218H
MOV AX,TYPE BUFF + TYPE MESS + TYPE VARD = 1 + 1 + 4 = 0006H
MOV AX,SIZE VARW + SIZE BUFF + SIZE MESS = 1*2 + 10*1 + 1*1 = 13 = 000DH
MOV AX,LENGTH VARW + LENGTH VARD = 1 + 1 = 0002H
MOV AX,LENGTH BUFF + SIZE VARW = 10 + 1*2 =12 = 000CH
MOV AX,TYPE BEGIN = -1 = 0FFFFH
MOV AX,OFFSET BEGIN = 0119H
题3.8设如下两条指令中的符号ABCD是变量名，请说明这两条指令的异同。
MOV AX,OFFSET ABCD
LEA AX,ABCD
相同点在于两条指令都能把变量ABCD的有效偏移地址传送给AX
不同点在于操作符OFFSET只能取得用数据定义伪指令定义的变量的有效地址，而LEA还能取得一般操作数的有效地址。
操作符OFFSET取得的有效地址是在汇编时由汇编程序计算出来的。
题3.9请指出如下指令中的不明确之处，并使其明确：
没有指明访问存储单元的类型
（1）MOV ES:[BP],5
改为MOV WORD PTR ES:[BP],5
没有指明访问存储单元的类型
（2）ADD CS:[1000H],10H
改为ADD WORD PTR CS:[1000H],10H
没有指明访问存储单元的类型
（3）DEC SS:[BX-8]
改为DEC WORD PTR SS:[BX-8]
没有指明是段内转移还是段间转移
（4）JMP CS:[SI+1000H]
改为JMP WORD PTR CS:[SI+1000H]
没有指明是8位乘法还是16位乘法
（5）MUL [BX+DI+2]
改为MUL WORD PTR [BX+DI+2]
没有指明是8位除法还是16位除法
（6）DIV [BP-4]
改为DIV WORD PTR [BP-4]
题3.10设在某个程序中有如下片段，请改正其中有错误的指令语句：
VARW DW 1234H,5678H
VARB DB 3,4
VARD DD 12345678H
MOV AX,VARB
改为MOV AL,VARB
MOV VARD,BX
改为MOV WORD PTR VARD,BX
MOV VARD+2,ES
改为MOV WORD PTR VARD+2,ES
MOV CL,VARW+3
改为MOV CL,BYTE PTR VARW+3
LES DI,VARW
改为LES DI,DWORD PTR VARW
题3.11请举例说明伪指令ASSUME的作用。
在源程序中使用ASSUME语句，可以确定段寄存器与段的对应关系，也可以改变已建立的对应关系。
例如，下面的ASSUME语句告诉汇编程序，从现在开始CS寄存器对应CSEG段，DS寄存器对应DSEG段。
ASSUME CS:CSEG,DS:DSEG
题3.12设在某个程序片段中有如下语句，请说明各符号的属性：
SYMB1 LABEL BYTE
符号的类型为BYTE
符号的段属性和偏移属性与SYMB3的段属性和偏移属性相同
SYMB2 EQU THIS BYTE
符号的类型为BYTE
符号的段属性和偏移属性与SYMB3的段属性和偏移属性相同
SYMB3 DW ?
符号的类型为WORD
SYMB4 EQU BYTE PTR SYMB3
符号的类型为BYTE
符号的段属性和偏移属性与SYMB3的段属性和偏移属性相同
题3.13为什么说汇编语言中的等价语句EQU可理解为简单的宏定义？请举例说明。
等价语句EQU可以用符号来代表常数、数值表达式、字符串、关键字、指令助记符、存储器操作数符号。这与简单的宏定义一样。
比如 HELLO EQU "How are you!"
HELLO MACRO
"How are you!"
ENDM
题3.14设在某个程序片段中有如下语句，请说明各符号所表示的值：
SYMB1=10
SYMB2=SYMB1*2 = 20 = 14H
SYMB1=SYMB1+SYMB2+4 = 34 = 22H
SYMB3 EQU SYMB1 = 34 = 22H
题3.15请改写3.3.3的程序T3-1.ASM，使其只有一个段。
CSEG SEGMENT
ASSUME CS:CSEG
JMP START
MESS DB 'HELLO',0DH,0AH,'$'
START:MOV AX,CSEG
MOV DS,AX
MOV DX,OFFSET MESS
MOV AH,9
INT 21H
MOV AH,4CH
INT 21H
CSEG ENDS
END START
题3.16请说明指令“JMP $+2”指令的机器码中的地址差值是多少。
指令的机器码为EB00，地址差值为0
表示转移到距当前指令第一字节后2字节处，指令本身长度就是2字节
当$用在指令中时，它表示本条指令第一字节的地址偏移。
题3.17源程序是否一定要以END语句结束？程序是否一定从代码段的偏移0开始执行？如果不是，那么如何指定？
源程序不一定以END语句结束，汇编程序在遇到END语句后，就不再对其后的任何语句进行汇编。
程序不一定从代码段的偏移0开始执行，END语句可带有一个已在程序中定义过的标号，程序将从标号所对应的指令开始执行。
题3.18利用查表的方法实现代码转换有何特点？利用查表的方法求函数值有何特点？
利用查表的方法实现代码转换，这种代码转换方法简明快捷，适用于代码集合较小且转换关系复杂的场合。
使用查表法求函数值的优点：（1）程序比较容易；（2）能够得到十进制或十六进制（或任何其他）格式的高精度函数值。
使用查表法求函数值的缺点：（1）函数值必须事先安排好因而有许多限制：（2）函数值的精度和准确性由程序员控制，
而不是由数学函数决定，当数据表的项较多时，难免有误差。
题3.19利用地址表实现多向分支有何特点？请举例说明。
利用地址表实现多向分支，事先必须安排一张入口地址表，再根据分支各路的条件确定对应处理程序的入口地址在地址表中的位置。
如果各处理程序均在同一代码段内，则入口地址只要用偏移表示，所以入口地址表的每一项只用一个字。
例如，MBRANCH的地址表可如下组织：
DSEG SEGMENT
……
COMTAB DW COMA,COMB,COMC,COMD
DW COME,COMF,COMG,COMH
……
DSEG ENDS
采用地址表实现多向分支的MBRANCH源程序的有关代码如下所示：
……
MOV AH,1
INT 21H
AND AL,11011111B
CMP AL,'A'
JB OK
CMP AL,'H'
JA OK
SUB AL,'A'
XOR AH,AH
ADD AX,AX
MOV BX,AX
JMP WORD PTR COMTAB[BX]
MOV AH,4CH
INT 21H
COMA:
……
JMP OK
COMB:
……
JMP OK
COMC:
……
JMP OK
……
COMH:
……
JMP OK
题3.20请举例说明如何避免条件转移超出转移范围。
把无条件转移指令和条件转移指令配合，实现远距离条件转移
CMP AH,1
JZ YES_1
JMP NOT_1
YES_1:
……
JMP OK
NOT_1: CMP AH,2
JZ YES_2
JMP NOT_2
YES_2:
……
JMP OK
NOT_2:CMP AH,3
JNZ NOT_3
YES_3:
……
JMP OK
NOT_3: CMP AH,4
JNZ NOT_4
YES_4:
……
JMP SHORT OK
NOT_4:
……
OK:
……
题3.21请写一个程序片段统计寄存器AX中置1位的个数。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
NUMBER DB 0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV AX,5678H
CALL COUNT1
MOV AH,4CH
INT 21H
COUNT1:PUSH BX
PUSH CX
MOV NUMBER,0
MOV BX,AX
XOR CX,CX
MOV CX,16
COUNT1_S:SHR BX,1
JNC NEXT
INC NUMBER
NEXT:NOP
LOOP COUNT1_S
POP CX
POP BX
RET
CSEG ENDS
END START
题3.22设一个32位有符号数存放在DX:AX中，请写一个求其补码的程序片段。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG
START:MOV AX,5678H
MOV DX,0FFFFH
CALL COMPLE
MOV AH,4CH
INT 21H
COMPLE:PUSH BX
mov bx,dx
and bx,8000h
cmp bx,0
jz ok
not dx
not ax
add ax,1
adc dx,0
or dx,8000h
ok:nop
POP BX
RET
CSEG ENDS
END START
题3.23写一个程序片段实现如下功能：依次重复寄存器AL中的每一位，得到16位的结果存放到DX寄存器中。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG
START:MOV AL,53H
CALL REPEAT1
MOV AH,4CH
INT 21H
REPEAT1:PUSH BX
PUSH CX
MOV BL,AL
MOV CX,8
XOR DX,DX
REPEAT_S:SHL DX,1
SHL DX,1
SHL BL,1
JNC NEXT
ADD DX,0003H
NEXT:NOP
LOOP REPEAT_S
POP CX
POP BX
RET
CSEG ENDS
END START
题3.24写一个程序片段实现如下功能：依次重复四次寄存器AL中的每一位，得到32位的结果存放到DX:AX寄存器中。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG
START:MOV AL,53H
CALL REPEAT1
MOV AH,4CH
INT 21H
REPEAT1:PUSH BX
PUSH CX
MOV BL,AL
MOV CX,4
XOR DX,DX
REPEAT_S1:SHL DX,1
SHL DX,1
SHL DX,1
SHL DX,1
SHL BL,1
JNC NEXT1
ADD DX,000FH
NEXT1:NOP
LOOP REPEAT_S1
MOV CX,4
XOR AX,AX
REPEAT_S2:SHL AX,1
SHL AX,1
SHL AX,1
SHL AX,1
SHL BL,1
JNC NEXT2
ADD AX,000FH
NEXT2:NOP
LOOP REPEAT_S2
POP CX
POP BX
RET
CSEG ENDS
END START
题3.25写一个程序片段实现如下功能：把寄存器AL和BL中的位依次交叉，得到的16位结果存放到DX寄存器中。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG
START:MOV AL,53H
MOV BL,62H
CALL REPEAT1
MOV AH,4CH
INT 21H
REPEAT1:PUSH AX
PUSH BX
PUSH CX
MOV CX,8
XOR DX,DX
REPEAT_S:SHL DX,1
SHL AL,1
JNC NEXT1
ADD DX,0001H
NEXT1:SHL DX,1
SHL BL,1
JNC NEXT2
ADD DX,0001H
NEXT2:NOP
LOOP REPEAT_S
POP CX
POP BX
POP AX
RET
CSEG ENDS
END START
题3.26写一个优化的程序片段，实现把字符串中的小写字母变换为对应的大写字母。设字符串以0结尾。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
STRING DB 'HOW are yoU?',0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV SI,OFFSET STRING
call letterc
mov ax,4c00h
int 21h
letterc:push ax
push si
letterc_s:mov al,ds:[si]
cmp al,0
je ok
cmp al,97
jb next
cmp al,122
ja next
and byte ptr ds:[si],11011111b
next:inc si
jmp letterc_s
ok:pop si
pop ax
ret
CSEG ENDS
END START
题3.27写一个优化的程序片段，统计字符串的长度。设字符串以0结尾。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
STRING DB 'HOW are yoU?',0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV SI,OFFSET STRING
call countc
mov ax,4c00h
int 21h
countc:push ax
push si
xor dx,dx
countc_s:mov al,ds:[si]
cmp al,0
je ok
inc dx
inc si
jmp countc_s
ok:pop si
pop ax
ret
CSEG ENDS
END START
题3.28写一个程序片段，滤去某个字符串中的空格符号（ASCII码20H）。设字符串以0结尾。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
STRING DB 'HOW are yoU?',0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV SI,OFFSET STRING
call spacec
mov ax,4c00h
int 21h
spacec:push ax
push bx
push si
mov bx,si
spacec_s:mov al,ds:[si]
cmp al,0
je ok
cmp al,32
je next1
cmp bx,si
je next2
xchg al,ds:[bx]
xchg al,ds:[si]
next2:inc bx
next1:inc si
jmp spacec_s
ok:mov byte ptr ds:[bx],0
pop si
pop bx
pop ax
ret
CSEG ENDS
END START
题3.29请写一个把两个字符串合并的示例程序。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
STRING1 DB 'WELCOME to hoME!',0
STRING2 DB 'HOW are yoU?',0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV BX,OFFSET STRING1
MOV SI,OFFSET STRING2
call concatc
mov ax,4c00h
int 21h
concatc:push ax
push bx
push si
concatc_s1:mov al,ds:[bx]
cmp al,0
je concatc_s2
inc bx
jmp concatc_s1
concatc_s2:mov al,ds:[si]
mov ds:[bx],al
cmp al,0
je ok
inc si
inc bx
jmp concatc_s2
ok:pop si
pop bx
pop ax
ret
CSEG ENDS
END START
题3.30请写一个可把某个字变量的值转换为对应二进制数ASCII码串的示例程序。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DATA SEGMENT
ASCII DB 16 DUP (?)
XX DW 5678
DATA ENDS
CODE SEGMENT
ASSUME CS:CODE,DS:DATA
START:MOV AX,DATA
MOV DS,AX
MOV SI,OFFSET ASCII
MOV AX,XX
call convert
mov ax,4c00h
int 21h
convert:push ax
push bx
push cx
push si
mov cx,16
convert_s:mov bl,30H
SHL AX,1
JNC NEXT
mov bl,31H
NEXT:mov ds:[si],bl
inc si
loop convert_s
pop si
pop cx
pop bx
pop ax
ret
CODE ENDS
END START
把某个字变量的值转换为对应十六进制数ASCII码串的示例程序
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DATA SEGMENT
ASCII DB 16 DUP (?)
XX DW 5678
DATA ENDS
CODE SEGMENT
ASSUME CS:CODE,DS:DATA
START:MOV AX,DATA
MOV DS,AX
MOV SI,OFFSET ASCII
MOV AX,XX
call convert
mov ax,4c00h
int 21h
convert:push ax
push bx
push cx
push si
mov cx,4
convert_s:ROL AX,1
ROL AX,1
ROL AX,1
ROL AX,1
mov bl,al
AND BL,0FH
ADD BL,30H
CMP BL,39H
JBE NEXT
ADD BL,07H
NEXT:mov ds:[si],bl
inc si
loop convert_s
pop si
pop cx
pop bx
pop ax
ret
CODE ENDS
END START
题3.31请写一个可把某个十进制数ASCII码串转换为对应非压缩BCD和压缩BCD的示例程序。
把某个十进制数ASCII码串转换为对应非压缩BCD码串
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
BCD DB 16 DUP (?)
ASCII DB '56789',0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV SI,OFFSET ASCII
MOV BX,OFFSET BCD
call convert
mov ax,4c00h
int 21h
convert:push ax
push bx
push si
convert_s:mov al,ds:[si]
cmp al,0
je ok
cmp al,30h
jb next
cmp al,39h
ja next
sub al,30h
mov ds:[bx],al
inc bx
next:inc si
jmp convert_s
ok:pop si
pop bx
pop ax
ret
CSEG ENDS
END START
把某个十进制数ASCII码串转换为对应压缩BCD码串
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
BCD DB 16 DUP (?)
ASCII DB '56789',0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV SI,OFFSET ASCII
MOV BX,OFFSET BCD
call convert
mov ax,4c00h
int 21h
convert:push ax
push bx
push si
xor ax,ax
convert_s:mov al,ds:[si]
cmp al,0
je ok1
cmp al,30h
jb next1
cmp al,39h
ja next1
cmp ah,0
je next2
sub ah,30h
sub al,30h
shl ah,1
shl ah,1
shl ah,1
shl ah,1
add ah,al
mov ds:[bx],ah
inc bx
xor ax,ax
jmp next1
next2:mov ah,al
next1:inc si
jmp convert_s
ok1:cmp ah,0
je ok2
sub ah,30h
shl ah,1
shl ah,1
shl ah,1
shl ah,1
mov ds:[bx],ah
ok2:
pop si
pop bx
pop ax
ret
CSEG ENDS
END START
题3.32请写一个可把某个十进制数ASCII码串转换为对应二进制数的示例程序。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
mul_table dw 1,10,100,1000,10000
res_ax dw 0
res_dx dw 0
ASCII DB '56789',0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV SI,OFFSET ASCII
call convert
mov ax,4c00h
int 21h
convert:push ax
push bx
push cx
push dx
push si
push di
xor cx,cx
convert_s1:mov al,ds:[si]
cmp al,0
je ok1
cmp al,30h
jb ok2
cmp al,39h
ja ok2
inc cx
inc si
jmp convert_s1
ok1:jcxz ok2
dec si
mov di,0
mov res_ax,0
mov res_dx,0
convert_s2:mov al,ds:[si]
sub al,30h
mov ah,0
mov bx,mul_table[di]
mul bx
add res_ax,ax
adc res_dx,dx
dec si
add di,2
loop convert_s2
ok2:pop di
pop si
pop dx
pop cx
pop bx
pop ax
ret
CSEG ENDS
END START
题3.33请写一个可把某个十六进制数ASCII码串转换为对应二进制数的示例程序。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
shl_table db 0,4,8,12,0,4,8,12
asciitohex db 8 dup (?)
res_ax dw 0
res_dx dw 0
ASCII DB '1278D',0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV SI,OFFSET ASCII
call convert
mov ax,4c00h
int 21h
convert:push ax
push bx
push cx
push dx
push si
push di
xor cx,cx
mov di,cx
convert_s1:mov al,ds:[si]
cmp al,0
je ok1
CMP AL,'0'
JB LAB5
MOV AH,AL
SUB AH,'0'
CMP AL,'9'
JBE LAB6
CMP AL,'A'
JB LAB5
MOV AH,AL
SUB AH,'A'-10
CMP AL,'F'
JBE LAB6
CMP AL,'a'
JB LAB5
MOV AH,AL
SUB AH,'a'-10
CMP AL,'f'
JBE LAB6
LAB5:MOV AH,-1
jmp ok2
LAB6:MOV asciitohex[di],AH
inc cx
inc di
inc si
jmp convert_s1
ok1:jcxz ok2
dec di
mov bx,0
mov res_ax,0
mov res_dx,0
convert_s2:push cx
cmp bx,3
ja next1
mov al,asciitohex[di]
mov ah,0
mov dx,0
mov cl,shl_table[bx]
shl ax,cl
add res_ax,ax
adc res_dx,dx
jmp next2
next1:mov dl,asciitohex[di]
mov dh,0
mov ax,0
mov cl,shl_table[bx]
shl dx,cl
add res_ax,ax
adc res_dx,dx
next2:dec di
inc bx
pop cx
loop convert_s2
ok2:pop di
pop si
pop dx
pop cx
pop bx
pop ax
ret
CSEG ENDS
END START
题3.34请写一个实现数据块移动的示例程序。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
STRING1 db 'how are you?',0
STRING2 db 32 dup (?)
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV SI,OFFSET STRING1
MOV DI,OFFSET STRING2
s1:mov al,ds:[si]
cmp al,0
je ok1
mov ds:[di],al
inc si
inc di
loop s1
ok1:mov ax,4c00h
int 21h
CSEG ENDS
END START
题3.35请编一个程序求从地址F000：0000H开始的64K字节内存区域的检验和，并转换为十六进制数的ASCII码串。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DATA SEGMENT
ASCII DB 16 DUP (?)
DATA ENDS
CODE SEGMENT
ASSUME CS:CODE
START:MOV AX,0F000H
MOV DS,AX
MOV SI,0
MOV CX,8000H
XOR AX,AX
AGAIN:ADD AX,DS:[SI]
INC SI
INC SI
LOOP AGAIN
ASSUME DS:DATA
MOV BX,DATA
MOV DS,BX
MOV SI,OFFSET ASCII
call convert
mov ax,4c00h
int 21h
convert:push ax
push bx
push cx
push si
mov cx,4
convert_s:ROL AX,1
ROL AX,1
ROL AX,1
ROL AX,1
mov bl,al
AND BL,0FH
ADD BL,30H
CMP BL,39H
JBE NEXT
ADD BL,07H
NEXT:mov ds:[si],bl
inc si
loop convert_s
pop si
pop cx
pop bx
pop ax
ret
CODE ENDS
END START
题3.36设已在地址F000：0000H开始的内存区域安排了100个字节的无符号8位二进制数。请编写一个程序求它们的和，
并转换为对应十进制数的ASCIl码串。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DATA SEGMENT
ASCII DB 16 DUP (?)
DATA ENDS
CODE SEGMENT
ASSUME CS:CODE
START:MOV AX,0F000H
MOV DS,AX
MOV SI,0
MOV CX,100
XOR AX,AX
XOR BX,BX
AGAIN:MOV AL,DS:[SI]
ADD BX,AX
INC SI
LOOP AGAIN
MOV AX,BX
XOR DX,DX
ASSUME DS:DATA
MOV BX,DATA
MOV DS,BX
MOV SI,OFFSET ASCII
CALL DTOC
MOV AX,4C00H
INT 21H
dtoc:push dx
push cx
push bx
push ax
push si
push di
mov di,0
divide:mov cx,dx
jcxz finish_s
divide_s:mov cx,0AH
call divdw
inc di
push cx
jmp divide
finish_s:mov cx,ax
jcxz finish
jmp divide_s
finish:mov cx,di
string:pop bx
add bx,30h
mov ds:[si],bl
inc si
loop string
mov ds:[si],0
pop di
pop si
pop ax
pop bx
pop cx
pop dx
ret
divdw:push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
CODE ENDS
END START
题3.37设已在地址F000：0000H开始的内存区域安排了1024个16位有符号数。
请编写一个程序统计其中的正数、负数和零的个数，并分别转换为对应十进制数的ASCII码串。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DATA SEGMENT
ASCII1 DB 8 DUP (?)
ASCII2 DB 8 DUP (?)
ASCII3 DB 8 DUP (?)
NUM1 DW 0
NUM2 DW 0
NUM3 DW 0
DATA ENDS
CODE SEGMENT
ASSUME CS:CODE
START:MOV AX,0F000H
MOV DS,AX
MOV SI,0
MOV CX,1024
XOR AX,AX
XOR BX,BX
XOR DX,DX
MOV DI,0
AGAIN:MOV AX,DS:[SI]
CMP AX,0
JNZ NEXT2
INC DI
JMP NEXT1
NEXT2:SHL AX,1
JNC NEXT3
INC DX
JMP NEXT1
NEXT3:INC BX
NEXT1:INC SI
INC SI
LOOP AGAIN
ASSUME DS:DATA
MOV AX,DATA
MOV DS,AX
MOV NUM1,BX
MOV NUM2,DX
MOV NUM3,DI
MOV SI,OFFSET ASCII1
MOV AX,NUM1
XOR DX,DX
CALL DTOC
MOV SI,OFFSET ASCII2
MOV AX,NUM2
XOR DX,DX
CALL DTOC
MOV SI,OFFSET ASCII3
MOV AX,NUM3
XOR DX,DX
CALL DTOC
MOV AX,4C00H
INT 21H
dtoc:push dx
push cx
push bx
push ax
push si
push di
mov di,0
divide:mov cx,dx
jcxz finish_s
divide_s:mov cx,0AH
call divdw
inc di
push cx
jmp divide
finish_s:mov cx,ax
jcxz finish
jmp divide_s
finish:mov cx,di
string:pop bx
add bx,30h
mov ds:[si],bl
inc si
loop string
mov ds:[si],0
pop di
pop si
pop ax
pop bx
pop cx
pop dx
ret
divdw:push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
CODE ENDS
END START
题3.38设从地址F000：0000H开始的内存区域是缓冲区，存放了一组单字节的正数或负数，以0结尾。
请编写一个程序确定其中最大的正数和最小的负数。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DATA SEGMENT
MIN_NUM DB 0
MAX_NUM DB 0
DATA ENDS
CODE SEGMENT
ASSUME CS:CODE
START:MOV AX,0F000H
MOV DS,AX
MOV SI,0
MOV CX,1024
XOR AX,AX
XOR BX,BX
AGAIN:MOV AL,DS:[SI]
CMP AL,0
JNZ NEXT2
JMP OK1
NEXT2:TEST AL,80H
JZ NEXT3
CMP AL,BL
JG NEXT1
XCHG AL,BL
JMP NEXT1
NEXT3:CMP AL,BH
JL NEXT1
XCHG AL,BH
NEXT1:INC SI
LOOP AGAIN
OK1:NOP
ASSUME DS:DATA
MOV AX,DATA
MOV DS,AX
MOV MIN_NUM,BL
MOV MAX_NUM,BH
MOV AX,4C00H
INT 21H
CODE ENDS
END START
题3.39设从地址F000：0000H开始的1K字节内存区域是缓冲区。请写一个可收集该区域内所有子串”OK"开始地址的程序。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DATA SEGMENT
ok_array dw 512 dup (0)
ok_top dw 0
DATA ENDS
CODE SEGMENT
ASSUME CS:CODE,ES:DATA
START:MOV AX,0F000H
MOV DS,AX
MOV SI,0
MOV AX,DATA
MOV ES,AX
MOV DI,0
MOV CX,1023
XOR AX,AX
MOV BX,SI
AGAIN:MOV AL,DS:[SI]
CMP AL,'O'
JNZ NEXT1
MOV AL,DS:[SI+1]
CMP AL,'K'
JNZ NEXT1
MOV ok_array[DI],SI
INC DI
INC DI
NEXT1:INC BX
MOV SI,BX
LOOP AGAIN
MOV ok_top,DI
MOV AX,4C00H
INT 21H
CODE ENDS
END START
题3.40请优化3.6.2节例7所示排序程序。
优化在于MOV AL,[BX+SI]和MOV [BX+SI],AL
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
BUFFER DB 23,12,45,32,127,3,9,58,81,72
N EQU 10
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV BX,OFFSET BUFFER-1
MOV SI,1
FORI:MOV DI,SI
INC DI
MOV AL,[BX+SI]
FORJ:CMP AL,[BX+DI]
JBE NEXTJ
XCHG AL,[BX+DI]
NEXTJ:INC DI
CMP DI,N
JBE FORJ
MOV [BX+SI],AL
NEXTI:INC SI
CMP SI,N-1
JBE FORI
MOV AH,4CH
INT 21H
CSEG ENDS
END START
题3.41请考虑TC或BC中for语句和while语句的实现方法。
for语句
void showchar(int, int, ...);
main()
{
    showchar(8, 2, 'a', 'b','c','d','e','f','g','h');
}
void showchar(int n, int color, ...)
{
    int a;
    for(a = 0; a != n; a++)
    {
        *(char far *)(0xb8000000 + 160 * 10 + 80 + a + a) = *(int *)(_BP + 8 + a + a);
	*(char far *)(0xb8000000 + 160 * 10 + 81 + a + a) = color;
    }
}
TC编译出来的程序使用DEBUG查看汇编代码
PUSH BP
MOV BP,SP
MOV AX,0068
PUSH AX
MOV AX,0067
PUSH AX
MOV AX,0066
PUSH AX
MOV AX,0065
PUSH AX
MOV AX,0064
PUSH AX
MOV AX,0063
PUSH AX
MOV AX,0062
PUSH AX
MOV AX,0061
PUSH AX
MOV AX,0002
PUSH AX
MOV AX,0008
PUSH AX
CALL 022D
ADD SP,+14
POP BP
RET
PUSH BP
MOV BP,SP
PUSH SI
XOR SI,SI
JMP 027E
MOV BX,BP
ADD BX,SI
ADD BX,SI
ADD BX,+08
MOV AL,[BX]
PUSH AX
MOV AX,SI
CWD
PUSH DX
PUSH AX
MOV AX,SI
CWD
POP BX
POP CX
ADD BX,AX
ADC CX,DX
ADD BX,0690
ADC CX,B800
MOV ES,CX
POP AX
ES:
MOV [BX],AL
MOV AL,[BP+06]
PUSH AX
MOV AX,SI
CWD
PUSH DX
PUSH AX
MOV AX,SI
CWD
POP BX
POP CX
ADD BX,AX
ADC CX,DX
ADD BX,0691
ADC CX,B800
MOV ES,CX
POP AX
ES:
MOV [BX],AL
INC SI
CMP SI,[BP+04]
JNZ 0235
POP SI
POP BP
RET
while语句
#define Buffer ((char *)*(int far *)0x02000000)
main()
{
    Buffer = (char *)malloc(20);
    Buffer[10] = 0;
    while(Buffer[10] != 8)
    {
        Buffer[Buffer[10]] = 'a' + Buffer[10];
        Buffer[10]++;
    }
    free(Buffer);
}
TC编译出来的程序使用DEBUG查看汇编代码
PUSH BP
MOV BP,SP
MOV AX,0014
PUSH AX
CALL 04EB
POP CX
MOV BX,0200
MOV ES,BX
XOR BX,BX
ES:
MOV [BX],AX
MOV BX,0200
MOV ES,BX
XOR BX,BX
ES:
MOV BX,[BX]
MOV BYTE PTR [BX+0A],00
JMP 025B
MOV BX,0200
MOV ES,BX
XOR BX,BX
ES:
MOV BX,[BX]
MOV AL,[BX+0A]
ADD AL,61
MOV BX,0200
MOV ES,BX
XOR BX,BX
ES:
MOV BX,[BX]
PUSH AX
PUSH BX
MOV BX,0200
MOV ES,BX
XOR BX,BX
ES:
MOV BX,[BX]
MOV AL,[BX+0A]
CBW
POP BX
ADD BX,AX
POP AX
MOV [BX],AL
MOV BX,0200
MOV ES,BX
XOR BX,BX
ES:
MOV BX,[BX]
INC BYTE PTR [BX+0A]
MOV BX,0200
MOV ES,BX
XOR BX,BX
ES:
MOV BX,[BX]
CMP BYTE PTR [BX+0A],08
JNZ 021F
MOV BX,0200
MOV ES,BX
XOR BX,BX
ES:
PUSH [BX]
CALL 06ED
POP CX
POP BP
RET
题3.42请考虑TC或BC中switch语句的实现方法。
switch语句
main()
{
    int a;
    int b;
    a = 2;
    a++;
    switch(a)
    {
    case 1:
        b = a + 1;
        break;
    case 2:
        b = a + 2;
        break;
    case 3:
        b = a + 3;
        break;
    default:
        b = a;
        break;
    }
    b++;
}
TC编译出来的程序使用DEBUG查看汇编代码
PUSH BP
MOV BP,SP
PUSH SI
PUSH DI
MOV SI,0002
INC SI
MOV AX,SI
CMP AX,0001
JZ 0216
CMP AX,0002
JZ 021B
CMP AX,0003
JZ 0221
JMP 0228
MOV DI,SI
INC DI
JMP 022C
MOV DI,SI
INC DI
INC DI
JMP 022C
MOV DI,SI
ADD DI,+03
JMP 022C
MOV DI,SI
JMP 022C
INC DI
POP DI
POP SI
POP BP
RET
for语句和switch语句
main()
{
    int c = 0, k;
    for (k = 1; k < 3; k++)
    {
        switch(k)
        {
        default:
            c += k;
        case2:
            c++;
            break;
        case 4:
            c += 2;
            break;
        }
    }
    c++;
}
TC编译出来的程序使用DEBUG查看汇编代码
PUSH BP
MOV BP,SP
PUSH SI
PUSH DI
XOR SI,SI
MOV DI,0001
JMP 021E
MOV AX,DI
CMP AX,0002
JZ 0216
CMP AX,0004
JZ 0219
JMP 0214
ADD SI,DI
INC SI
JMP 021D
INC SI
INC SI
JMP 021D
INC DI
CMP DI,+03
JL 0206
INC SI
POP DI
POP SI
POP BP
RET
第4章子程序设计和DOS功能调用
本章先介绍如何设计汇编语言子程序，然后把DOS功能调用视为子程序，介绍如何利用DOS系统功能调用。
最后介绍子程序的递归和重入概念。
4.1子程序设计
如果某个程序片段将反复在程序中出现，就把它设计成子程序。这样能有效地缩短程序长度、节约存储空间。
如果某个程序片段具有通用性，可供许多程序共享，就把它设计成子程序。
这样能大大减轻程序设计的工作量，例如标准函数程序。
此外，当某个程序片段的功能相对独立时，也可把它设计成子程序，这样便于模块化，也便于程序的阅读、调试和修改。
在80x86系列汇编语言中，子程序常常以过程的形式出现。
4.1.1过程调用和返回指令
过程调用指令和过程返回指令属于程序控制指令这一组。
通常，过程调用指令用于由主程序转子程序，过程返回指令用于由子程序返回主程序。
由于程序的代码可分为多个段，所以，像无条件转移指令一样，过程调用指令有段内调用和段间调用之分，与之相对应，
过程返回指令也有段内返回和段间返回之分。把段内调用和段内返回称为近调用和近返回，
把段间调用和段间返回称为远调用和远返回。在汇编语言中，过程也有远近类型之分。
1.过程调用指令
过程调用指令首先把子程序的返回地址（即CALL指令的下一条指令的地址）压入堆栈，
以便执行完子程序后返回调用程序（主程序）继续往下执行。然后转移到子程序的入口地址去执行子程序。
按照转移目标是否在同一段来分，调用指令分为段内调用和段间调用；
按照获得转移目标地址的方式来分，调用指令分为直接调用和间接调用。
下面介绍这四种调用指令，在汇编语言中，均用指令助记符CALL表示。
过程调用指令不影响标志。
（1）段内直接调用
段内直接调用指令用于调用当前段内的子程序，格式如下：
CALL 过程名
例如：
CALL SUB1
SUB1是近过程
CALL TOASCll
TOASCIl是近过程
该指令进行的具体操作分解如下：
SP=SP-2
[SP]=IP
IP=IP+disp
段内直接调用指令只把返回地址的偏移部分IP压入堆栈保存，堆栈变化如图4.1所示。
实际上，转移发生在同一段内，代码段寄存器CS的内容不发生变化。
然后把返回地址与子程序入口地址的差值（disp）加到指令指针IP上，使IP之内容为目标地址偏移，从而达到转移的目的。
与无条件段内直接转移指令相似，段内直接调用指令的转移是相对转移，指令由操作码和地址差构成。
地址差（disp）等于目标地址到CALL指令下一条指令开始地址的差，汇编程序在汇编时计算出disp。
在段内直接调用指令中，总用一个字表示disp，所以转移范围可达-32768~+32767。
（2）段内间接调用
段内间接调用指令也用于调用当前段内的子程序，格式如下：
CALL OPRD
OPRD是16位通用寄存器或字存储器操作数。
该指令进行的具体操作分解如下：
SP=SP-2
[SP]=IP
IP=（OPRD）
该指令只把返回地址的偏移部分IP压入堆栈保存，堆栈变化如图4.1所示。
如OPRD是16位通用寄存器操作数，则把寄存器之内容送IP；如OPRD是字存储器操作数，则把字存储单元之内容送IP。
例如：
CALL BX
CALL WORD PTR [BX]
CALL VARW
VARW是字变量
（3）段间直接调用
段间直接调用指令用于调用其它代码段中的子程序。格式如下：
CALL 过程名
该指令先把返回地址的段值压入堆栈，再把返回地址的偏移压入堆栈，达到保存返回地址的目的，堆栈的变化如图4.2所示。
然后把过程的入口地址的段值和偏移分别送入CS和IP，达到转移的目的。该指令进行的具体操作分解如下：
SP=SP-2
[SP]=CS
SP=SP-2
[SP]=IP
IP=过程入口地址的偏移
CS=过程入口地址的段值
段间直接调用指令与无条件段间直接转移指令相似，机器指令中含有转移目标地址。
例如：
CALL FAR PTR SUBRO
设SUBRO是远过程
CALL SUBF
设SUBF是远过程
汇编程序MASM能根据过程名所指定的被调用过程的类型决定采用段内直接调用指令还是段间直接调用指令。
如果先调用后定义，那么为了调用远过程须在过程名前叫上类型说明符号“FAR PTR”。
汇编程序TASM根据由过程名所指定的被调用过程与调用指令是否在同一段内决定采用段内直接调用指令还是段间直接调用指令。
（4）段间间接调用
段间间接调用指令也用于调用其它代码段中的子程序。格式如下：
CALL OPRD
OPRD是双字存储器操作数。该指令进行的具体操作可分解如下：
SP=SP-2
[SP]=CS
SP=SP-2
[SP]=IP
IP=OPRD之低字值
CS=OPRD之高字值
该指令把返回地址的段值CS和偏移IP分别压入堆栈保存（堆栈变化如图4.2所示），
然后把双字存储器操作数的低字送IP，把双字存储器操作数的高字送CS，从而实现远转移。
例如：
CALL DWORD PTR [BX]
CALL VARD
VARD是双字变量
对于间接调用，如果操作数是16位操作数，则汇编成段内间接调用，如果操作数是32位操作数，则汇编成段间间接调用。
如果发生调用指令语句在先，有关变量定义伪指令语句在后的情况，则需要在调用语句中用PTR等操作符加以说明。
2.过程返回指令
过程返回指令把子程序的返回地址从堆栈弹出到IP或CS和IP，从而返回调用程序（主程序）继续往下执行。
弹出的子程序返回地址一般应该就是由调用指令压入堆栈的返回地址。
过程返回指令不影响标志。
（1）段内返回指令
段内返回指令用于近过程的返回，格式如下：
RET
该指令完成的具体操作如下所示：
IP=[SP]
SP=SP+2
该指令只从堆栈弹出一个字，送到指令指针IP。
堆栈变化过程如图4.1（b）到图4.1（a）所示。它与段内调用指令相对应，使用在近过程中。
实际上，段内调用指令调用近过程时，仅把返回地址的偏移压入堆栈。
（2）段间返回指令
段间返回指令用于远过程的返回，格式如下：
RETF
该指令完成的具体操作如下所示：
IP=[SP]
SP=SP+2
CS=[SP]
SP=SP+2
该指令从堆栈弹出两个字，分别送到指令指针IP和代码段寄存器CS。堆栈变化过程如图4.2（b）到图4.2（a）所示。
它与段间调用指令相对应，使用在远过程中。实际上，段间调用指令调用远过程时，把返回地址的段值和偏移都压入堆栈。
尽管段内返回指令的助记符与段间返回指令的助记符是相同的，但它们的机器指令码是不同的。
汇编程序MASM能根据RET指令所在过程的类型决定采用段内返回指令还是采用段间返回指令，
只有当返回指令语句出现在远类型过程中时，MASM才把它汇编成段间返回指令。
汇编程序TASM除了具有上述功能外，还提供了段间返回指令的专门助记符RETF。例如：RETF
无论RETF出现在远过程中还是近过程中，汇编程序TASM总把它汇编成段间返回指令。
（3）段内带立即数返回指令
段内带立即数返回指令的格式如下：
RET 表达式
汇编程序把表达式的结果data取整。
该指令完成的具体操作如下所示：
IP=[SP]
SP=SP+2
SP=SP+data
先从堆栈弹出一个字作为返回地址，再额外根据data修改堆栈指针。
所以该指令不仅能实现段内返回，而且能同时再修改堆栈指针。
由于对堆栈的正常操作均是以字为单位，所以，表达式的结果一般应是偶数。例如：
RET 4
设在执行上面的指令前SP=B67EH，在执行后SP=B684H。
（4）段间带立即数返回指令
段间带立即数返回指令的格式如下：
RETF 表达式
该指令先从堆栈弹出两个字，分别送到指令指针IP和代码段寄存器CS，再额外修改堆栈指针，即把表达式的结果加到SP。
汇编程序把表达式的结果data取整。
该指令完成的具体操作如下所示：
IP=[SP]
SP=SP+2
CS=[SP]
SP=SP+2
SP=SP+data
所以该指令不仅能实现段间返回，而且能同时再修改堆栈指针。例如：
RETF 4
设在执行上面的指令前SP=B67EH，则在执行后SP=B686H。
4.1.2过程定义语句
利用过程定义伪指令语句,可把程序片段说明为具有近类型或远类型的过程，并且能给过程起一个名字。
过程定义语句的格式如下：
过程名 PROC [NEAR I FAR]
过程名 ENDP
过程的类型在过程定义开始语句PROC中指定，过程可以被定为近（NEAR）类型，也可以被指定为远（FAR）类型。
如果不指定，则通常默认为近类型。如前所述，使用段内调用指令还是段间调用指令调用一个过程，由被调用过程的类型决定。
因此，如果一个过程要被别的程序段调用，就应该把它说明为FAR类型。
如果某个过程具有NEAR类型，那么该过程仅能被其所在段调用。
定义一个过程的开始语句PROC和结束语句ENDP前的过程名称必须一致，从而保持配对。
过程名称的命名与普通标号的命名方法相同。像普通标号一样，过程名具有段值、偏移和类型这三个属性。
过程名的段值和偏移是对应过程入口（过程定义开始伪指令语句后的指令语句）的段值和偏移，过程名的类型就是过程的类型。
把一位十六进制数转换为对应ASCII码的过程可定义如下：
设欲转换的十六进制数码在AL的低4位
转换得到的ASCll码在AL中
HTOASC PROC NEAR
AND AL,0FH
ADD AL,30H
CMP AL,39H
JBE HTOASC1
ADD AL,7
HTOASC1:RET
HTOASC ENDP
为了能返回调用程序，一般说来，在一个过程中至少要有一条返回指令，也可含多条返回指令。
返回指令语句是过程的出口。但返回指令语句不一定非要安排在过程的最后。
为了说明在一个过程中使用多条RET指令，现将上述的“把一位十六进制数转换为对应ASCII码的过程”改写如下：
HTOASC PROC
AND AL,0FH
CMP AL,9
JBE HTOASC1
ADD AL,37H
RET
HTOASC1:ADD AL,30H
RET
HTOASC ENDP
还可把上述过程作如下改变，其中RET语句不在过程的最后：
HTOASC PROC
AND AL,0FH
CMP AL,9
JBE HTOASC1
ADD AL,37H
HTOASC2:RET
HTOASC1:ADD AL,30H
JMP HTOASC2
HTOASC ENDP
4.1.3子程序举例
例1：写一个把用ASCII码表示的两位十进制数转换为对应二进制数的子程序。
转换算法是：设x是十位数，y是个位数，计算10x+y。子程序源代码如下：
入口参数：DH=十位数ASCII码，DL=个位数ASCII码
出口参数：AL=对应二进制数
SUBR PROC
MOV AL,DH
AND AL,0FH
MOV AH,10
MUL,AH
MOV AH,DL
AND AH,0FH
ADD AL,AH
RET
SUBR ENDP
上述子程序SUBR没有判别作为入口参数提供的DH和DL寄存器中的内容是否是十进制数的ASCII码。
例2：写一个把16位二进制数转换为4位十六进制数ASCII码的子程序。
转换方法是：把16位二进制数向左循环移位四次，使高4位成为低四位，析出低四位，
调用子程序HTOASC转换出1位十六进制数的ASCII码，重复四次便完成转换。子程序源代码如下：
入口参数：DX=欲转换的二进制数 DS:BX=存放转换所得ASCII码串的缓冲区首地址
出口参数：十六进制数ASCII码串按高位到低位依次存放在指定的缓冲区中
HTASCS PROC
MOV CX,4
HTASCS1:ROL DX,1
ROL DX,1
ROL DX,1
ROL DX,1
MOV AL,DL
CALL HTOASC
MOV [BX],AL
INC BX
LOOP HTASCS1
RET
HTASCS ENDP
利用上述子程序HTASCS按十六进制数形式显示地址为F000：0000H的字单元内容的一个程序如下：
程序名：T4-1.ASM
功能：（略）
DSEG SEGMENT
BUFF DB 4 DUP (0)
DB 'H',0DH,0AH,'$'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV AX,0F000H
MOV ES,AX
MOV DX,ES:[0]
MOV BX,OFFSET BUFF
CALL HTASCS
MOV DX,OFFSET BUFF
MOV AH,9
INT 21H
MOV AX,4C00H
INT 21H
HTASCS PROC
HTASCS ENDP
HTOASC PROC
HTOASC ENDP
CSEG ENDS
END START
测试通过的完整程序如下
DSEG SEGMENT
BUFF DB 4 DUP (0)
DB 'H',0DH,0AH,'$'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV AX,0F000H
MOV ES,AX
MOV DX,ES:[0]
MOV BX,OFFSET BUFF
CALL HTASCS
MOV DX,OFFSET BUFF
MOV AH,9
INT 21H
MOV AX,4C00H
INT 21H
HTASCS PROC
MOV CX,4
HTASCS1:ROL DX,1
ROL DX,1
ROL DX,1
ROL DX,1
MOV AL,DL
CALL HTOASC
MOV DS:[BX],AL
INC BX
LOOP HTASCS1
RET
HTASCS ENDP
HTOASC PROC
AND AL,0FH
CMP AL,9
JBE HTOASC1
ADD AL,37H
JMP OK
HTOASC1:ADD AL,30H
OK:RET
HTOASC ENDP
CSEG ENDS
END START
例3：写一个把16位二进制数转换为5位十进制数ASCII码的子程序。为了简单，设二进制数是无符号的。
第三章中的程序T3-11.ASM实现“把16位二进制数转换为5位十进制的BCD码”，
把BCD码转换为对应ASCII码是容易的，所以可把T3-11.ASM改写成一个子程序。
但我们采用另一个算法把16位二进制数转换为5位十进制数的BCD码。该算法是：
把16位二进制数除以10，余数是“个位”数的BCD码；把商再除以10，余数就是“十位”数的BCD码；
如此，可依次得“百位”、“千位”和“万位”数的BCD码。这可利用一个循环来控制。
入口参数：AX=欲转换的二进制数
DS:BX=存放转换所得ASCII码串的缓冲区首地址
出口参数：十进制数ASCIl码串按万位到个位的序依次存放在指定的缓冲区中
BTOASC PROC
MOV SI,5
MOV CX,10
BTOASC1:XOR DX,DX
DIV CX
ADD DL,30H
DEC SI
MOV DS:[BX][SI],DL
OR SI,SI
JNZ BTOASC1
RET
BTOASC ENDP
在上面的子程序中，寄存器SI既作计数器使用又作变址指针使用。
4.1.4子程序说明信息
为了能正确地使用子程序，在给出子程序代码时还要给出子程序的说明信息。
子程序说明信息一般由如下几部分组成，每一部分内容应简明确切：
（1）子程序名。
（2）功能描述。
（3）入口和出口参数。
（4）所用的寄存器和存储单元。
（5）使用的算法和重要的性能指标。
（6）其他调用注意事项和说明信息。
（7）调用实例。
子程序说明信息至少应该包含前三部分内容。例如：
子程序名：AHTOASC
功能：把8位二进制数转换为2位十六进制数的ASCII码；
入口参数：AL=欲转换的8位二进制数；
出口参数：AH=十六进制数高位的ASCII码；AL=十六进制数低位的ASCII码
其他说明：（1）近过程（2）除AX寄存器外，不影响其他寄存器；（3）调用了HTOASC实现十六进制数到ASCIl码的转换
在看了上述关于子程序AHTOASC的说明信息后，即使不熟悉或不了解这个子程序本身，也就能够方便地调用它了。
子程序AHTOASC的源代码如下：
AHTOASC PROC
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL HTOASC
XCHG AH,AL
CALL HTOASC
RET
AHTOASC ENDP
4.1.5寄存器的保护与恢复
子程序为了完成其功能，通常要使用一些寄存器存放内容，有时还要使用一些存储单元存放内容。
也就是说，在子程序运行时通常会破坏一些寄存器或存储单元的原有内容。
所以，如果不采取措施，那么在调用子程序后，主程序就无法再使用存放在这些寄存器或存储单元中的原有内容了，
这常常会导致主程序的错误。为此，要对有关寄存器或存储单元的内容进行保护与恢复。
寄存器的保护与恢复有两种方法：
（1）把需要保护的寄存器的内容，在主程序中压入堆栈和弹出堆栈。
这种方法的优点是，在每次调用子程序时，只要把主程序所关心的寄存器压入堆栈。
但缺点是：在主程序中使用压入和弹出堆栈的操作会使主程序不易理解；
如果要多次调用子程序时，会很累赘，而且常常会忘了把某个寄存器压入堆栈。
（2）在子程序一开始就把在子程序中要改变的寄存器内容压入堆栈，而在返回之前再恢复这些寄存器的内容。
这种方法的优点是：在主程序中可方便地调用子程序，而无需考虑要把哪些寄存器压入堆栈；
只需要在子程序中写一次压入和弹出堆栈指令组即可。这种方法是常用的方法。
下面是重写的BTOASC子程序，它保护了所有被改变的寄存器内容，主程序在调用它时，不必担心各寄存器的内容受影响。
子程序说明信息略
BTOASC PROC
PUSH AX
PUSH CX
PUSH DX
PUSH SI
MOV SI,5
MOV CX,10
BTOASC1:XOR DX,DX
DIV CX
ADD DL,30H
DEC SI
MOV DS:[BX][SI],DL
OR SI,SI
JNZ BTOASC1
POP SI
POP DX
POP CX
POP AX
RET
BTOASC ENDP
还有几点说明，请注意：
（1）上述子程序BTOASC实际上还破坏了标志寄存器中的部分标志，可用PUSHF指令和POPF指令保护和恢复标志寄存器。
但一般不在子程序中保护和恢复标志寄存器。
（2）在利用堆栈进行寄存器的保护和恢复时，要注意堆栈的先进后出特性。
（3）有时为了简单，并不保护含有入口参数的寄存器。是否要保护入口参数寄存器，可以根据实际情况事先约定。
在BTOASC中，含有入口参数的AX寄存器得到了保护。
可像寄存器的保护和恢复那样，保护和恢复有关存储单元的内容，即在子程序开始时把有关存储单元的内容压入堆栈，
在子程序返回前恢复它们。在子程序中应尽量避免把普诵存储单示作为临时变量使用，可以利用堆栈元素作为临时变量使用。
4.2主程序与子程序间的参数传递
主程序在调用子程序时，往往要向子程序传递一些参数；同样，子程序运行后也经常要把一些结果参数传回给主程序。
主程序与子程序之间的这种信息传递称为参数传递。
我们把由主程序传给子程序的参数称为子程序的入口参数，把由子程序传给主程序的参数称为子程序的出口参数。
一般子程序既有入口参数，又有出口参数。但有的子程序只有入口参数，而没有出口参数；
有的子程序只有出口参数，而没有入口参数。
有多种参数传递的方法：寄存器传递法、约定内存单元传递法、堆栈传递法和CALL后续区传递法等。
主程序与子程序间传递参数的方法是根据具体情况而事先约定好的。有时可能同时采用多种方法。
4.2.1利用寄存器传递参数
利用寄存器传递参数就是把参数放在约定的寄存器中。这种方法的优点是实现简单和调用方便。
但由于寄存器的个数是有限的，且寄存器往往还要存放其他数据，所以只适用于要传递的参数较少的情况。
在4.1节中的子程序HTOASC和子程序AHTOASC等就是利用寄存器来传递参数的，现再举几例。
例1：写一个把大写字母改为小写字母的子程序。
在ASCII码表中，大写字母的ASCII码比对应小写字母的ASCII码小20H（即'a'='A'+20H），
所以在确定字符是大写字母后，把它转换为对应的小写字母是容易的。
子程序名：UPTOLW
功能：把大写字母转换为小写字母
入口参数：AL=字符ASCII码；出口参数：AL=字符ASCII码
说明：如果字符是大写字母，则转换为小写字母，其他字符不变
UPTOLW PROC
PUSHF
CMP AL,'A'
JB UPTOLW1
CMP AL,'Z'
JA UPTOLW1
ADD AL,'a'-'A'
UPTOLW1:POPF
RET
UPTOLW ENDP
上面的子程序还保护了标志寄存器，从而使得在执行该子程序后，各标志不受影响。
是否要保护标志可视具体情况而事先约定。有时还利用某些标志作为出入口参数。进位标志CF常常用作为出口参数。
例2：写一个判别字符是否为数字符的子程序。并利用该子程序把一个字符串中的所有数字符删除。
子程序ISDECM及其说明如下：
子程序名：ISDECM
功能：判别一个字符是否为数字符
入口参数：AL=字符
出口参数：CF为0表示字符是数字符，否则字符是非数字符
ISDECM PROC
CMP AL,'0'
JB ISDECM1
CMP AL,'9'
JA ISDECM1
CLC
RET
ISDECM1:STC
RET
ISDECM ENDP
对上述子程序可作些优化工作，改写过的ISDECM如下所示：
ISDECM PROC
CMP AL,'0'
JB ISDECM1
CMP AL,'9'+1
CMC
RET
ISDECM1:STC
RET
ISDECM ENDP
改写过的子程序ISDECM利用了CMP指令对标志的影响。
使用该子程序把字符串中的数字符删除的源程序如下，子程序位于主程序之前：
程序名：T4-2.ASM
功能：（略）
DSEG SEGMENT
STRING DB 'AB=C950=asd',0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
ISDECM PROC
CMP AL,'0'
JB ISDECM1
CMP AL,'9'
JA ISDECM1
CLC
RET
ISDECM1:STC
RET
ISDECM ENDP
START:MOV AX,DSEG
MOV DS,AX
MOV SI,OFFSET STRING
MOV Dl,SI
NEXT:MOV AL,[SI]
INC SI
OR AL,AL
JZ OK
CALL ISDECM
JNC NEXT
MOV [DI],AL
INC DI
JMP NEXT
OK:MOV [DI],AL
MOV AH,4CH
INT 21H
CSEG ENDS
END START
测试通过的完整程序如下
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
STRING DB 'AB=C950=asd',0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
ISDECM PROC
CMP AL,'0'
JB ISDECM1
CMP AL,'9'
JA ISDECM1
CLC
RET
ISDECM1:STC
RET
ISDECM ENDP
START:MOV AX,DSEG
MOV DS,AX
MOV SI,OFFSET STRING
MOV DI,SI
NEXT:MOV AL,[SI]
INC SI
OR AL,AL
JZ OK
CALL ISDECM
JNC NEXT
MOV [DI],AL
INC DI
JMP NEXT
OK:MOV [DI],AL
MOV AH,4CH
INT 21H
CSEG ENDS
END START
4.2.2利用约定存储单元传递参数
在传递参数较多的情况下，可利用约定的内存变量来传递参数。
这种方法的优点是子程序要处理的数据或送出的结果都有独立的存储单元，编写程序时不易出错。
但这种方法要占用一定的存储单元，此外还有其他缺点，我们在下文中说明。
例3：写一个实现32位数相加的子程序。
子程序名：MADD；
功能：32位数相加
入口参数：DATA1和DATA2缓冲区中分别存放要相加的32数；
出口参数：DATA3缓冲区中存放结果
说明：（1）32位数据的存放次序采用“高高低低”的原则（2）可能产生的进位存放在DATA3开始的第5字节中
MADD PROC
PUSH AX
PUSH CX
PUSH SI
MOV CX,2
XOR SI,SI
MADD1:MOV AX,WORD PTR DATA1[SI]
ADC AX,WORD PTR DATA2[SI]
MOV WORD PTR DATA3[SI],AX
INC SI
INC SI
LOOP MADD1
MOV AL,0
ADC AL,0
MOV BYTE PTR DATA3+4,AL
POP SI
POP CX
POP AX
RET
MADD ENDP
利用约定的存储单元传递参数，通用性较差。上述子程序MADD的通用性就较差。
为了递较多的参数，又要保持良好的通用性，通常把参数组织成一张参数表，存放在某个存储区，
然后把这个存储区的首地址传送给子程序。既可利用寄存器传递首地址，也可利用堆栈方法传递首地址。
例4：设计一个把以ASCII码表示的十进制数字串转换为二进制数的子程序。设表示的十进制数不大于65535。
假设要转换的十进制数字串存放在由DS:BX所指的缓冲区中，该缓冲区的第一字节含有十进制数字串的长度。
缓冲区结构如图4.3所示。
设十进制数字串中各位对应的BCD码是dn、dn-1、…、d2、d1，那么它所表示的二进制数可由下式计算出：
Y=（（（（0*10+dn）*10+dn-1）*10+…）*10+d2）*10+d1
可通过迭代的方法进行上式的计算，迭代公式如下，Y的初值为0：
Y=Y*10+di,（i=n，n-1.…1）
所以，当十进制数字串中数字的个数为n时，那么只需进行n次迭代计算。
由于假设数字串表示的十进制数不超过65535，所以用16位的AX寄存器存放迭代式中的Y，
也用AX寄存器返回转换后得到的二进制数。子程序源代码如下所示：
子程序名：DTOBIN
功能：把用ASCII码表示的十进制数字串转换为二进制数；
入口参数：DS:BX=缓冲区首地址（缓冲区结构如图4.3）
出口参数：AX=转换得到的二进制数
DTOBIN PROC
PUSH BX
PUSH CX
PUSH DX
XOR AX,AX
MOV CL,[BX]
INC BX
XOR CH,CH
JCXZ DTOBIN2
DTOBIN1:MOV DX,10
MUL DX
MOV DL,[BX]
INC BX
AND DL,0FH
XOR DH,DH
ADD AX,DX
LOOP DTOBIN1
DTOBIN2:POP DX
POP CX
POP BX
RET
DTOBIN ENDP
这个子程序有两点不足：
（1）没有检查数字串中是否有非十进制数字符存在，
（2）不适用于数字串表示的十进制数超过值65535的情况。
4.2.3利用堆栈传递参数
如果使用堆栈传递入口参数，那么主程序在调用子程序之前，把需要传递的参数依次压入堆栈，子程序从堆栈中取入口参数；
如果使用堆栈传递出口参数，那么子程序在返回前，把需要返回的参数存入堆栈，主程序在堆栈中取出口参数。
利用堆栈传递参数可以不占用寄存器，也无需使用额外的存储单元。
但由于参数和子程序的返回地址混杂在一起，有时还要考虑保护寄存器，所以较为复杂。
通常利用堆栈传递入口参数，而利用寄存器传递出口参数。
例5：写一个测量字符串长度的子程序。设字符串以0为结束标志。
利用堆栈来传递入口参数：字符串的起始地址（设包括段值和偏移）；
利用寄存器传递出口参数：字符串的长度。
设子程序STRLEN是一个近过程，那么主程序在调用它时，只把返回地址的偏移压入堆栈。
子程序名：STRLEN
功能：测量字符串的长度
入口参数：字符串起始地址的段值和偏移在堆栈中，见图4.4（a）
出口参数：AX=字符串长度
STRLEN PROC
PUSH BP
MOV BP,SP
PUSH DS
PUSH SI
MOV DS,[BP+6]
MOV SI,[BP+4]
MOV AL,0
STRLEN1:CMP AL,[SI]
JZ STRLEN2
INC SI
JMP STRLEN1
STRLEN2:MOV AX,SI
SUB AX,[BP+4]
POP SI
POP DS
POP BP
RET
STRLEN ENDP
子程序借助指针寄存器BP，采用寄存器相对寻址方式取得入口参数，
位移量与返回地址占用的字节数、为保护寄存器BP而使用的字节数、入口参数压入堆栈的次序有关。
另外，请注意当BP寄存器作为指针使用时，隐含使用的段寄存器是SS，这正是堆栈段。
主程序调用这个子程序的代码片段如下所示，它说明主程序与子程序一定要事先约定，密切配合：
……
MOV AX,SEG STRMESS
PUSH AX
MOV AX,OFFSET STRMESS
PUSH AX
CALL STRLEN
ADD SP,4
MOV LEN,AX
……
主程序在调用子程序STRLEN之前把要测量长度的字符串起始地址的段值和偏移作为入口参数压入堆栈，
然后就马上调用子程序STRLEN，这样堆栈就如图4.4（b）所示。
从子程序返回后堆栈如图4.4（d）所示，所以需要废除仍在堆栈中的入口参数，
本例中利用了指令“ADD SP,4”来平衡堆栈，使堆栈恢复到如图4.4（e）所示。
另一种废除堆栈中入口参数的方法是使用带立即数返回指令。
这可在子程序返回时就自动平衡堆栈，主程序就不需要再进行堆栈的平衡工作。
对于上述子程序，可采用如下的返回指令：
RET 4
此立即数与入口参数量有关
如果这样的话，上面主程序调用子程序的片段就不需要调整堆栈指针的指令“ADD SP,4”。
4.2.4利用CALL后续区传递参数
CALL后续区是指位于CALL指令后的存储区域。主程序在调用子程序之前，把入口参数存入CALL指令后的存储单元中，
子程序根据保存在堆栈中的返回地址找到入口参数，这种传递参数的方法称为CALL后续区传递参数法。
利用CALL后续区传递参数的子程序必须修改返回地址。
由于这种方法把数据和代码混在一起，所以在x86系列汇编语言程序中使用得不多。
例6：写一个把字符串中的大写字母改为小写字母的子程序（近过程）。设字符串以0为结束标志。
用CALL后续区传递字符串起始地址的段值和偏移。
子程序名：STRLWR
功能：把字符串中的所有大写字母改为小写字母
入口参数：字符串起始地址的段值和偏移在CALL后续区（见图4.5（a））。
出口参数：无
STRLWR PROC
PUSH BP
MOV BP,SP
PUSH AX
PUSH SI
PUSH DS
MOV SI,[BP+2]
MOV DS,CS:[SI+2]
MOV SI,CS:[SI]
STRLWR1:MOV AL,[SI]
CMP AL,0
JZ STRLWR3
CMP AL,'A'
JB STRLWR2
CMP AL,'Z'
JA STRLWR2
ADD AL,'a'-'A'
MOV [SI],AL
STRLWR2:INC SI
JMP STRLWR1
STRLWR3:ADD WORD PTR [BP+2],4
POP DS
POP SI
POP AX
POP BP
RET
STRLWR ENDP
调用上述子程序的源程序片段如下所示：
……
CALL STRLWR
DW OFFSET STRMESS
DW SEG DSEG
CONT:
……
图4.5是有关代码段、数据段和堆栈段的示意图，其中（a）是调用之前的情形，（b）是调用和保护有关寄存器后的情形，
（c）是修改返回地址后的情形。
4.3DOS功能调用及应用
尽管DOS正在逐步消亡，但目前在DOS平台上进行x86汇编语言程序设计的实习还是最有效的途径。
了解DOS功能调用，不仅有益于程序设计锻炼，也便于在DOS平台上进行汇编语言程序设计的实习。
4.3.1DOS功能调用概述
1.什么是DOS功能调用
MS-DOS（PC-DOS）内包含了许多涉及设备驱动和文件管理等方面的子程序，
DOS的各种命令就是通过适当地调用这些子程序实现的。
为了方便程序员使用，把这些子程序编写成相对独立的程序模块而且编上号。
程序员利用汇编语言可方便地调用这些子程序。这些子程序被精心编写，而且经过了大量的各种应用范围的实践考验。
程序员调用这些子程序可减少对系统硬件环境的考虑和依赖，从而一方面可大大精简应用程序的编写，
另一方面可使程序有良好的通用性。这些编了号的可由程序员调用的子程序就称为DOS的功能调用或称为系统调用。
一般认为DOS的各种命令是操作员与DOS的接口，而功能调用则是程序员与DOS的接口。
DOS功能调用主要包括三方面的子程序：设备驱动（基本I/O）、
文件管理和其他（包括内存管理、置取时间、置取中断向量、终止程序等）。
随着DOS版本的升级，这种称为DOS功能调用的子程序数量也不断增加，功能更加完备，使用也更加方便。
2.调用方法
可按如下方法调用DOS功能调用：
（1）根据需调用的功能调用准备入口参数。
有部分功能调用是不需要入口参数的，但大部分功能调用需要入口参数，在调用前应按要求准备好入口参数。
（2）把功能调用号送AH寄存器。
（3）发软中断指令“INT 21H”。
程序员不必关心有关子程序在何处，也不必关心它是如何实现其功能的。
例如：调用2号功能调用，使喇叭发出“嘟”的一声。
2号功能调用的功能是在屏幕上显示一个字符，入口参数是DL寄存器为要显示字符的ASCII码。
当要显示字符的ASCII码为07H时，并不在屏幕上显示字符，而是使喇叭发出“嘟”的一声。程序片段如下：
MOV DL,07H
MOV AH,2
INT 21H
大部分功能调用都有出口参数，在调用后，可根据有关功能调用的说明取得出口参数。
部分功能调用没有出口参数，如2号功能调用，调用它后，只是在屏幕上显示相应的字符，或发出“嘟”的一声。
还有个别功能调用很特殊，调用它后就不再返回。例如4CH号功能调用，其功能就是结束程序的运行而返回DOS。
我们已在多个程序中使用了这个功能调用。4CH号功能调用有一个存放在AL寄存器中的入口参数，该入口参数是程序的结束码，
其值的大小不影响程序的结束。例如：
MOV AL,0
MOV AH,4CH
INT 21H
4.3.2基本I/O功能调用
1.带回显键盘输入（1号功能调用）功能：从标准输入设备上读一字符，并将该字符回显在标准输出设备上。
通常情况下，标准输入设备就是键盘，标准输出设备就是屏幕。如果键盘无字符可读，则一直等待到有字符可读（即按键）。
入口参数：无。
出口参数：AL=读到字符的代码（ASCII码）。
说明：如果读到的字符是Ctrl+C或Ctrl+Break，则结束程序。
2.不带回显键盘输入（8号功能调用）除读到的输入字符不在屏幕上显示外，同1号功能调用。
3.直接键盘输入（7号功能调用）功能：从标准输入上读一字符。通常情况下，标准输入就是键盘。
如果键盘无字符可读，则一直等待到有字符可读（即按键）。
入口参数：无。
出口参数：AL=读到字符的代码。
说明：（1）不检查读到的字符是否是Ctrl+C或Ctrl+Break。
（2）不回显读到的字符。
4.显示输出（2号功能调用）功能：向标准输出设备写一字符。通常情况下，标准输出设备就是屏幕。
入口参数：DL=要输出的字符（ASCII码）。
出口参数：无。
说明：在显示输出时检查是否按Ctrl+C或Ctrl+Break键，如是则结束程序。
5.直接控制台输入输出（6号功能调用）功能：直接控制台输入输出。
通常情况下，控制台输入就是键盘输入，控制台输出就是屏幕输出。
入口参数：若DL=0FFH，表示输入；否则表示输出，DL=输出字符代码。
出口参数：输入时，ZF=1表示无字符可读；ZF=0表示读到字符，AL=输入字符代码；输出时，无。
说明：（1）在输入时，如无字符可读，并不等待。
（2）不检查Ctrl+C或Ctrl+Break键。
（3）在读到字符时也不回显。
（4）在输入时，如果AL=0，表示用户曾按过一个扩展键，在下一次调用该功能时返回扩展键的扫描码。
（5）在输出时，不解释制表符等特殊控制符。
6.显示字符串（9号功能调用）功能：在标准输出上显示一个字符串。通常情况下，标准输出就是屏幕。
入口参数：DS:DX=需要输出字符串的首地址，字符串以字符'$'为结束标志。
出口参数：无。
说明：在显示输出时检查是否按Ctrl+C或Ctrl+Break键，如是则结束程序。
7.输入字符串（0AH号功能调用）
会把当前输入的内容回显在标准输出设备上
功能：从标准输入上读一个字符串。通常情况下，标准输入就是键盘。
入口参数：DS:DX=缓冲区首地址。
出口参数：接收到的输入字符串在缓冲区中。
说明：（1）缓冲区第一字节置为缓冲区最大容量，可认为是入口参数；
缓冲区第二字节存放实际读入的字符数（不包括回车符），可认为是出口参数的一部分；第三字节开始存放接受的字符串。
（2）字符串以回车键结束，回车符是接受到的字符串的最后一个字符。也就是0DH 回车，不包含0AH 换行
（3）如果输入的字符数超过缓冲区所能容纳的最大字符数，则随后的输入字符被丢弃并且响铃，直到遇回车键为止。
（4）如果在输入时按Ctrl+C或Ctrl+Break键，则结束程序。
8.取键盘输入状态（0BH号功能调用）功能：判别在标准输入设备上是否有字符可读。
入口参数：无。
出口参数：AL=0，表示无字符可读；AL=0FFH，表示有字符可读。
说明：检查是否按Ctrl+C或Ctrl+Break键，如遇这种键，则程序结束。
9.清除输入缓冲区后再输入（0CH号功能调用）
功能：清除输入缓冲区，然后再执行某个输入功能。
入口参数：AL=清除输入缓冲区后要执行的功能号。
出口参数：决定于清除输入缓冲区后执行的功能。
说明：清除缓冲区后执行的功能应是01H、06H、07H、08H或0AH，如不是这样，则不输入。
例如：若AL=0，则在清除输入缓冲区后，没有进一步的处理。
10.打印输出（5号功能调用）
功能：向连接在第一个并行口上的打印机输出一字符。
入口参数：DL=要打印的字符（ASCII码）。
出口参数：无。
说明：打印机可能不立即打印出指定的字符。
4.3.3应用举例
例1：写一个程序，它用二进制数形式显示所按键的ASCII码。
首先利用1号功能调用接受一个字符，然后通过移位的方法从高到低依次把其ASCII码值的各位析出，再转换成ASCII码，
利用2号功能调用显示输出。源程序如下所示：它还含有一个形成回车换行（光标移到下一行首）的子程序。
程序名：T4-3.ASM
功能：（略）
CSEG SEGMENT
ASSUME CS:CSEG,DS:CSEG
START:MOV AH,1
INT 21H
CALL NEWLINE
MOV BL,AL
MOV CX,8
NEXT:SHL BL,1
MOV DL,30H
ADC DL,0
MOV AH,2
INT 21H
LOOP NEXT
MOV DL,'B'
MOV AH,2
INT 21H
MOV AH,4CH
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
CSEG ENDS
END START
测试通过的完整程序如下
CSEG SEGMENT
ASSUME CS:CSEG,DS:CSEG
START:MOV AH,1
INT 21H
CALL NEWLINE
MOV BL,AL
MOV CX,8
NEXT:SHL BL,1
MOV DL,30H
ADC DL,0
MOV AH,2
INT 21H
LOOP NEXT
MOV DL,'B'
MOV AH,2
INT 21H
MOV AH,4CH
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
CSEG ENDS
END START
例2：写一个程序，它先接受一个字符串，然后显示其中数字符的个数、英文字母的个数和字符串的长度。
先利用0AH号功能调用接受一个字符串，然后分别统计其中数字符的个数和英文字母的个数，最后用十进制数的形式显示它们。
整个字符串的长度可从0AH号功能调用的出口参数中取得。源程序如下所示：
程序名：T4-4.ASM
功能：（略）
MLENGTH=128
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
BUFF DB MLENGTH
DB ?
DB MLENGTH DUP (0)
MESS0 DB 'Please input:$'
MESS1 DB 'Length = $’
MESS2 DB 'X = $'
MESS3 DB 'Y = $'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESS0
CALL DISPMESS
MOV DX,OFFSET BUFF
MOV AH,10
INT 21H
CALL NEWLINE
MOV BH,0
MOV BL,0
MOV CL,BUFF+1
MOV CH,0
JCXZ COK
MOV SI,OFFSET BUFF+2
AGAIN:MOV AL,[SI]
INC SI
CMP AL,'0'
JB NEXT
CMP AL,'9'
JA NODEC
INC BH
JMP NEXT
NODEC:CMP AL,'A'
JB NEXT
OR AL,20H
CMP AL,'a'
JB NEXT
CMP AL,'z'
JA NEXT
INC BL
NEXT:LOOP AGAIN
COK:MOV DX,OFFSET MESS1
CALL DISPMESS
MOV AL,BUFF+1
XOR AH,AH
CALL DISPAL
CALL NEWLINE
MOV DX,OFFSET MESS2
CALL DISPMESS
MOV AL,BH
XOR AH,AH
CALL DISPAL
CALL NEWLINE
MOV DX,OFFSET MESS3
CALL DISPMESS
MOV AL,BL
XOR AH,AH
CALL DISPAL
CALL NEWLINE
MOV AX,4C00H
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
DISPAL PROC
PUSH AX
PUSH CX
PUSH DX
MOV CX,3
MOV DL,10
DISP1:DIV DL
XCHG AH,AL
ADD AL,'0'
PUSH AX
XCHG AH,AL
MOV AH,0
LOOP DISP1
MOV CX,3
DISP2:POP DX
CALL ECHOCH
LOOP DISP2
POP DX
POP CX
POP AX
RET
DISPAL ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
ECHOCH PROC
PUSH AX
MOV AH,2
INT 21H
POP AX
RET
ECHOCH ENDP
CSEG ENDS
END START
测试通过的完整程序如下
MLENGTH=128
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
BUFF DB MLENGTH
DB ?
DB MLENGTH DUP (0)
MESS0 DB 'Please input:$'
MESS1 DB 'Length = $'
MESS2 DB 'X = $'
MESS3 DB 'Y = $'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESS0
CALL DISPMESS
MOV DX,OFFSET BUFF
MOV AH,10
INT 21H
CALL NEWLINE
MOV BH,0
MOV BL,0
MOV CL,BUFF+1
MOV CH,0
JCXZ COK
MOV SI,OFFSET BUFF+2
AGAIN:MOV AL,[SI]
INC SI
CMP AL,'0'
JB NEXT
CMP AL,'9'
JA NODEC
INC BH
JMP NEXT
NODEC:CMP AL,'A'
JB NEXT
OR AL,20H
CMP AL,'a'
JB NEXT
CMP AL,'z'
JA NEXT
INC BL
NEXT:LOOP AGAIN
COK:MOV DX,OFFSET MESS1
CALL DISPMESS
MOV AL,BUFF+1
XOR AH,AH
CALL DISPAL
CALL NEWLINE
MOV DX,OFFSET MESS2
CALL DISPMESS
MOV AL,BH
XOR AH,AH
CALL DISPAL
CALL NEWLINE
MOV DX,OFFSET MESS3
CALL DISPMESS
MOV AL,BL
XOR AH,AH
CALL DISPAL
CALL NEWLINE
MOV AX,4C00H
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
DISPAL PROC
PUSH AX
PUSH CX
PUSH DX
MOV CX,3
MOV DL,10
DISP1:DIV DL
XCHG AH,AL
ADD AL,'0'
PUSH AX
XCHG AH,AL
MOV AH,0
LOOP DISP1
MOV CX,3
DISP2:POP DX
CALL ECHOCH
LOOP DISP2
POP DX
POP CX
POP AX
RET
DISPAL ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
ECHOCH PROC
PUSH AX
MOV AH,2
INT 21H
POP AX
RET
ECHOCH ENDP
CSEG ENDS
END START
带回显键盘输入（1号功能调用）功能：从标准输入设备上读一字符，并将该字符回显在标准输出设备上。
通常情况下，标准输入设备就是键盘，标准输出设备就是屏幕。如果键盘无字符可读，则一直等待到有字符可读（即按键）。
入口参数：无。
出口参数：AL=读到字符的代码（ASCII码）。
说明：如果读到的字符是Ctrl+C或Ctrl+Break，则结束程序。
不带回显键盘输入（8号功能调用）除读到的输入字符不在屏幕上显示外，同1号功能调用。
例3：写一个显示指定内存单元内容的程序。
具体要求是：允许用户按十六进制数的形式输入指定内存单元的段值和偏移，然后用十六进制数形式显示指定字节单元的内容。
该程序可分成如下几步：（1）接收段值和偏移；（2）把指定字节单元中的内容转换成2位十六进制数的ASCII码，边转换边显示。
为了接收段值和偏移，设计子程序GETADR。子程序GETADR接收用户输入的十六进制数串，并转换为二进制数。
根据功能划分，又派生出子程序GETSTR和子程序HTOBIN。
子程序GETSTR接收一个最大长度为4的十六进制数串；子程序HTOBIN负责把这个数串转换为二进制数。
所以，子程序GETADR调用GETSTR和HTOBIN实现其功能。在两次调用GETADR后，可分别得段值和偏移。
子程序GETADR没有入口参数，只有在寄存器中提供的出口参数。
子程序GETSTR较为复杂。它并没有调用0AH号功能接收字符串，而是循环调用8号功能接收单个字符。
这样处理后，如果用户按错键，就可使喇叭发出“嘟”的一声，作为提示。
为此，它要检查用户按的键是否是十六进制数码键，要处理退格键，还要控制接收的字符数不超过规定等。
子程序GETSTR的实现流程如图4.6所示。它通过约定的缓冲区传递参数。
子程序HTOBIN实现把4位十六进制数的ASCII码转换为一个二进制数。
它采用“X=16*X+Yi”的迭代公式，进行四次迭代计算。其中X的初值为0，Yi是根据十六进制数符的ASCII码转换得出的值。
程序名：T4-5.ASM
功能：用十六进制数的形式显示指定内存字节单元的内容
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
SEGOFF DD ?
MESS1 DB 'SEGMENT:$'
MESS2 DB 'OFFSET:$'
BUFFER DB 5 DUP (0)
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESS1
CALL DISPMESS
CALL GETADR
MOV WORD PTR SEGOFF+2,AX
MOV DX,OFFSET MESS2
CALL DISPMESS
CALL GETADR
MOV WORD PTR SEGOFF,AX
LES DI,SEGOFF
MOV AL,ES:[DI]
CALL SHOWAL
MOV AX,4C00H
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
HTOASC PROC
AND AL,0FH
CMP AL,9
JBE HTOASC1
ADD AL,37H
JMP HTOASCOK
HTOASC1:ADD AL,30H
HTOASCOK:RET
HTOASC ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
SHOWAL PROC
PUSH AX
PUSH CX
PUSH AX
MOV CL,4
ROL AL,CL
CALL HTOASC
CALL PUTCH
POP AX
CALL HTOASC
CALL PUTCH
POP CX
POP AX
RET
SHOWAL ENDP
GETADR PROC
PUSH DX
GETADR1:CALL GETSTR
CMP BUFFER,CR
JNZ GETADR2
CALL BELL
JMP GETADR1
GETADR2:MOV DX,OFFSET BUFFER
CALL HTOBIN
CALL NEWLINE
POP DX
RET
GETADR ENDP
GETSTR PROC
PUSH AX
PUSH BX
PUSH DI
MOV DI,OFFSET BUFFER
MOV BX,0
GETSTR1:CALL GETCH
CMP AL,CR
JZ GETSTR5
CMP AL,BACKSPACE
JNZ GETSTR4
CMP BX,0
JZ GETSTR2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTR1
GETSTR2:CALL BELL
JMP GETSTR1
GETSTR4:CMP BX,4
JZ GETSTR2
CALL ISHEX
JC GETSTR2
MOV [BX][DI],AL
INC BX
CALL PUTCH
JMP GETSTR1
GETSTR5:MOV [BX][DI],AL
POP DI
POP BX
POP AX
RET
GETSTR ENDP
HTOBIN PROC
PUSH CX
PUSH DX
PUSH SI
MOV SI,DX
XOR DX,DX
MOV CH,4
MOV CL,4
HTOBIN1:MOV AL,[SI]
INC SI
CMP AL,CR
JZ HTOBIN2
CALL ATOBIN
SHL DX,CL
OR DL,AL
DEC CH
JNZ HTOBIN1
HTOBIN2:MOV AX,DX
POP SI
POP DX
POP CX
RET
HTOBIN ENDP
ISHEX PROC
CMP AL,'0'
JB ISHEX2
CMP AL,'9'+1
JB ISHEX1
CMP AL,'A'
JB ISHEX2
CMP AL,'F'+1
JB ISHEX1
CMP AL,'a'
JB ISHEX2
CMP AL,'f'+1
ISHEX1:CMC
ISHEX2:RET
ISHEX ENDP
ATOBIN PROC
SUB AL,30H
CMP AL,9
JBE ATOBIN1
SUB AL,7
CMP AL,15
JBE ATOBIN1
SUB AL,20H
ATOBIN1:RET
ATOBIN ENDP
CSEG ENDS
END START
测试通过的完整程序如下
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
SEGOFF DD ?
MESS1 DB 'SEGMENT:$'
MESS2 DB 'OFFSET:$'
BUFFER DB 5 DUP (0)
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESS1
CALL DISPMESS
CALL GETADR
MOV WORD PTR SEGOFF+2,AX
MOV DX,OFFSET MESS2
CALL DISPMESS
CALL GETADR
MOV WORD PTR SEGOFF,AX
LES DI,SEGOFF
MOV AL,ES:[DI]
CALL SHOWAL
MOV AX,4C00H
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
HTOASC PROC
AND AL,0FH
CMP AL,9
JBE HTOASC1
ADD AL,37H
JMP HTOASCOK
HTOASC1:ADD AL,30H
HTOASCOK:RET
HTOASC ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
SHOWAL PROC
PUSH AX
PUSH CX
PUSH AX
MOV CL,4
ROL AL,CL
CALL HTOASC
CALL PUTCH
POP AX
CALL HTOASC
CALL PUTCH
POP CX
POP AX
RET
SHOWAL ENDP
GETADR PROC
PUSH DX
GETADR1:CALL GETSTR
CMP BUFFER,CR
JNZ GETADR2
CALL BELL
JMP GETADR1
GETADR2:MOV DX,OFFSET BUFFER
CALL HTOBIN
CALL NEWLINE
POP DX
RET
GETADR ENDP
GETSTR PROC
PUSH AX
PUSH BX
PUSH DI
MOV DI,OFFSET BUFFER
MOV BX,0
GETSTR1:CALL GETCH
CMP AL,CR
JZ GETSTR5
CMP AL,BACKSPACE
JNZ GETSTR4
CMP BX,0
JZ GETSTR2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTR1
GETSTR2:CALL BELL
JMP GETSTR1
GETSTR4:CMP BX,4
JZ GETSTR2
CALL ISHEX
JC GETSTR2
MOV [BX][DI],AL
INC BX
CALL PUTCH
JMP GETSTR1
GETSTR5:MOV [BX][DI],AL
POP DI
POP BX
POP AX
RET
GETSTR ENDP
HTOBIN PROC
PUSH CX
PUSH DX
PUSH SI
MOV SI,DX
XOR DX,DX
MOV CH,4
MOV CL,4
HTOBIN1:MOV AL,[SI]
INC SI
CMP AL,CR
JZ HTOBIN2
CALL ATOBIN
SHL DX,CL
OR DL,AL
DEC CH
JNZ HTOBIN1
HTOBIN2:MOV AX,DX
POP SI
POP DX
POP CX
RET
HTOBIN ENDP
ISHEX PROC
CMP AL,'0'
JB ISHEX2
CMP AL,'9'+1
JB ISHEX1
CMP AL,'A'
JB ISHEX2
CMP AL,'F'+1
JB ISHEX1
CMP AL,'a'
JB ISHEX2
CMP AL,'f'+1
ISHEX1:CMC
ISHEX2:RET
ISHEX ENDP
ATOBIN PROC
SUB AL,30H
CMP AL,9
JBE ATOBIN1
SUB AL,7
CMP AL,15
JBE ATOBIN1
SUB AL,20H
ATOBIN1:RET
ATOBIN ENDP
CSEG ENDS
END START
4.4磁盘文件管理及应用
DOS磁盘文件管理功能调用是DOS功能调用的重要组成部分，不仅有助于汇编语言程序设计练习，
也有助于对磁盘文件管理系统的理解。
4.4.1DOS磁盘文件管理功能调用
在下面介绍的DOS磁盘文件管理功能调用中，用于表示文件名的ASCII字符串必须以ASCII码值0结尾（不是数字符号0），
这样的字符串通常称为ASCIIZ串。文件名可以是包含盘符和路径的文件标识。
如没有盘符，那么认为是当前盘，如路径不是从根目录开始，那么就认为从当前目录开始。
这些功能调用均利用标志CF表示调用是否成功，如果不成功，那么AX含有错误代码。常见的错误代码有：
01 无效的功能号
02 文件未找到
03 路径未找到
04 同时打开文件太多
05 拒绝存取
06 无效的文件号（柄）
1.建立文件（3CH号功能调用）
功能：建立文件（创建新的，或刷新老的文件）。
入口参数：DS:DX=代表文件名的字符串的首地址。
CX=文件属性。
出口参数：CF=0表示成功，AX=文件号（柄）。
CF=1表示失败，AX=错误代码。
说明：（1）可指定的文件属性如下：
00H普通
01H只读
02H隐含
04H系统
（2）创建文件成功后，文件长度定为0。
2.打开文件（3DH号功能调用）
功能：打开文件。
入口参数：DS:DX=代表文件名的字符串的首地址。
AL=存取方式。
出口参数：CF=0表示成功，AX=文件号（柄）。
CF=1表示失败，AX=错误代码。
说明：（1）存取方式规定如下：
00H只读方式
01H只写方式
02H读写方式
（2）打开文件成功后，文件指针定位于开始的第一个字节（偏移0）处。
3.读文件（3FH号功能调用）
功能：读文件。
入口参数：BX=文件号（柄）。
CX=读入字节数。
DS:DX=准备存放所读数据的缓冲区的首地址。
出口参数：CF=0表示成功，AX=实际读到的字节数。
CF=1表示失败，AX=错误代码。
说明：（1）通常情况下，实际读到的字节数与欲读入的字节数相同，除非不够读。
（2）缓冲区应保证能容下所读到的数据。
（3）文件应以读或读写方式打开。
（4）读文件后，文件指针将定位到读出字节之后的第一个字节处。
4.写文件（40H号功能调用）
功能：写文件。
入口参数：BX=文件号（柄）；
CX=写盘字节数；
DS:DX=存放写数据的缓冲区的首地址。
出口参数：CF=0表示成功，AX=实际写出的字节数。
CF=1表示失败，AX=错误代码。
说明：（1）通常情况下，实际写出的字节数与欲写盘的字节数相同，除非磁盘满。
（2）文件应以写或读写方式打开。
（3）写文件后，文件指针将定位到写入字节之后的第一个字节处。
5.关闭文件（3EH号功能调用）
功能：关闭文件。
入口参数：BX=文件号（柄）。
出口参数：CF=0表示成功。
CF=1表示失败。
说明：文件号是打开该文件时系统所给定的文件号。
6.移动文件读写指针（42H号功能调用）
功能：移动文件（读写）指针。
入口参数：BX=文件号（柄）。
CX:DX=移动位移量。
AL=移动方式。
出口参数：CF=0表示成功，此时，DX:AX=移动后文件指针值。
CF=1表示失败，此时，（AX）=1表示无效的移动方式，（AX）=6表示无效的文件号。
说明：（1）文件指针值（双字）是以文件首字节为0计算的。
（2）移动方式和表示的意义如下：
00H 移动后文件指针值=0（文件头）+移动位移量
01H =当前文件指针值+移动位移量
02H =文件长（文件尾）+移动位移量
（3）在第一种移动方式中，移动位移量总是正的。
（4）在后两种移动方式中，移动位移量可正可负。
（5）该子功能不考虑文件指针是否超出文件范围。
7.删除文件（41H号功能调用）
功能：删除文件。
入口参数：DS:DX=代表文件名的字符串首地址。
出口参数：CF=0表示成功；
CF=1表示失败，AX=错误代码。
说明：只能删除一个普通文件。
打开文件（3DH号功能调用）
功能：打开文件。
入口参数：DS:DX=代表文件名的字符串的首地址。
AL=存取方式。
出口参数：CF=0表示成功，AX=文件号（柄）。
CF=1表示失败，AX=错误代码。
说明：（1）存取方式规定如下：
00H只读方式
01H只写方式
02H读写方式
读文件（3FH号功能调用）
功能：读文件。
入口参数：BX=文件号（柄）。
CX=读入字节数。
DS:DX=准备存放所读数据的缓冲区的首地址。
出口参数：CF=0表示成功，AX=实际读到的字节数。
CF=1表示失败，AX=错误代码。
关闭文件（3EH号功能调用）
功能：关闭文件。
入口参数：BX=文件号（柄）。
出口参数：CF=0表示成功。
CF=1表示失败。
说明：文件号是打开该文件时系统所给定的文件号。
4.4.2应用举例
例1：写一个显示文本文件内容的程序。文本文件固定为当前目录下的TEST.TXT文件。
具体算法是：先打开文件；然后顺序读文件，每次读一个字符，把所读字符在屏幕上显示出来，如此循环直到文件结束；
最后关闭文件。图4.7是流程图。考虑到TEST.TXT是文本文件，所以认为ASCII码值为1AH的字符就是文件结束符。
也就是说，在读到ASCII码值为1AH的字符，就认为文件结束。
设计一个子程序READCH，它每次从文件中顺序读一个字符。这个子程序通过进位标志CF来反映是否正确地读到字符，
如果读时发生错误，则CF置位，否则CF被清。调用它的程序应通过CF判别读文件操作是否成功。
考虑到万一文本文件没有文件结束符的情况，所以该子程序还判别是否的确已读到文件尾
（如果实际读到的字符数为0就意味着文件结束），当这种情况发生时，就返回一个文件结束符。源程序如下：
程序名：T4-6.ASM
功能：显示当前目录下的文本文件TEST.TXT内容
EOF = 1AH
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
FNAME DB 'TEST.TXT',0
ERROR1 DB 'File not found',07H,0
ERROR2 DB 'Reading error',07H,0
BUFFER DB ?
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET FNAME
MOV AX,3D00H
INT 21H
JNC OPEN_OK
MOV SI,OFFSET ERROR1
CALL DMESS
JMP OVER
OPEN_OK:MOV BX,AX
CONT:CALL READCH
JC READERR
CMP AL,EOF
JZ TYPE_OK
CALL PUTCH
JMP CONT
READERR:MOV SI,OFFSET ERROR2
CALL DMESS
TYPE_OK:MOV AH,3EH
INT 21H
OVER:MOV AH,4CH
INT 21H
READCH PROC
MOV CX,1
MOV DX,OFFSET BUFFER
MOV AH,3FH
INT 21H
JC READCH2
CMP AX,CX
MOV AL,EOF
JB READCH1
MOV AL,BUFFER
READCH1:CLC
READCH2:RET
READCH ENDP
DMESS PROC
DMESS1:MOV DL,[SI]
INC SI
OR DL,DL
JZ DMESS2
MOV AH,2
INT 21H
JMP DMESS1
DMESS2:RET
DMESS ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
CSEG ENDS
END START
测试通过的完整程序如下
EOF = 1AH
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
FNAME DB 'TEST.TXT',0
ERROR1 DB 'File not found',07H,0
ERROR2 DB 'Reading error',07H,0
BUFFER DB ?
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET FNAME
MOV AX,3D00H
INT 21H
JNC OPEN_OK
MOV SI,OFFSET ERROR1
CALL DMESS
JMP OVER
OPEN_OK:MOV BX,AX
CONT:CALL READCH
JC READERR
CMP AL,EOF
JZ TYPE_OK
CALL PUTCH
JMP CONT
READERR:MOV SI,OFFSET ERROR2
CALL DMESS
TYPE_OK:MOV AH,3EH
INT 21H
OVER:MOV AH,4CH
INT 21H
READCH PROC
PUSH CX
PUSH DX
MOV CX,1
MOV DX,OFFSET BUFFER
MOV AH,3FH
INT 21H
JC READCH2
CMP AX,CX
MOV AL,EOF
JB READCH1
MOV AL,BUFFER
READCH1:CLC
READCH2:POP DX
POP CX
RET
READCH ENDP
DMESS PROC
PUSH AX
PUSH DX
PUSH SI
DMESS1:MOV DL,[SI]
INC SI
OR DL,DL
JZ DMESS2
MOV AH,2
INT 21H
JMP DMESS1
DMESS2:POP SI
POP DX
POP AX
RET
DMESS ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
CSEG ENDS
END START
上述程序每次只从文件中读一个字节数据，读者可把它改为每次从文件中读若干字节数据。
如果文件TEST.TXT的中间带有文件结束符（1AH），则在结束符后的数据就不会在屏幕上显示出来，
请读者修改上述程序，使其不考虑文件结束符。
测试通过的完整程序如下
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
FNAME DB 'TEST.TXT',0
ERROR1 DB 'File not found',07H,0
ERROR2 DB 'Reading error',07H,0
BUFFER DB 16 DUP (?)
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET FNAME
MOV AX,3D00H
INT 21H
JNC OPEN_OK
MOV SI,OFFSET ERROR1
CALL DMESS
JMP OVER
OPEN_OK:MOV BX,AX
CONT:CALL READBUF
JC READERR
CMP AX,0
JZ TYPE_OK
CALL DBUF
JMP CONT
READERR:MOV SI,OFFSET ERROR2
CALL DMESS
TYPE_OK:MOV AH,3EH
INT 21H
OVER:MOV AH,4CH
INT 21H
READBUF PROC
PUSH CX
PUSH DX
MOV CX,16
MOV DX,OFFSET BUFFER
MOV AH,3FH
INT 21H
JC READBUF1
CLC
READBUF1:POP DX
POP CX
RET
READBUF ENDP
DBUF PROC
PUSH AX
PUSH CX
PUSH DX
PUSH SI
CMP AX,0
JZ DBUF1
MOV CX,AX
MOV SI,0
DBUF_S:MOV DL,BUFFER[SI]
INC SI
MOV AH,2
INT 21H
LOOP DBUF_S
DBUF1:POP SI
POP DX
POP CX
POP AX
RET
DBUF ENDP
DMESS PROC
PUSH AX
PUSH DX
PUSH SI
DMESS1:MOV DL,[SI]
INC SI
OR DL,DL
JZ DMESS2
MOV AH,2
INT 21H
JMP DMESS1
DMESS2:POP SI
POP DX
POP AX
RET
DMESS ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
CSEG ENDS
END START
建立文件（3CH号功能调用）
功能：建立文件（创建新的，或刷新老的文件）。
入口参数：DS:DX=代表文件名的字符串的首地址。
CX=文件属性。
出口参数：CF=0表示成功，AX=文件号（柄）。
CF=1表示失败，AX=错误代码。
说明：（1）可指定的文件属性如下：
00H普通
01H只读
02H隐含
04H系统
（2）创建文件成功后，文件长度定为0。
打开文件（3DH号功能调用）
功能：打开文件。
入口参数：DS:DX=代表文件名的字符串的首地址。
AL=存取方式。
出口参数：CF=0表示成功，AX=文件号（柄）。
CF=1表示失败，AX=错误代码。
说明：（1）存取方式规定如下：
00H只读方式
01H只写方式
02H读写方式
（2）打开文件成功后，文件指针定位于开始的第一个字节（偏移0）处。
读文件（3FH号功能调用）
功能：读文件。
入口参数：BX=文件号（柄）。
CX=读入字节数。
DS:DX=准备存放所读数据的缓冲区的首地址。
出口参数：CF=0表示成功，AX=实际读到的字节数。
CF=1表示失败，AX=错误代码。
说明：（1）通常情况下，实际读到的字节数与欲读入的字节数相同，除非不够读。
（2）缓冲区应保证能容下所读到的数据。
（3）文件应以读或读写方式打开。
（4）读文件后，文件指针将定位到读出字节之后的第一个字节处。
写文件（40H号功能调用）
功能：写文件。
入口参数：BX=文件号（柄）；
CX=写盘字节数；
DS:DX=存放写数据的缓冲区的首地址。
出口参数：CF=0表示成功，AX=实际写出的字节数。
CF=1表示失败，AX=错误代码。
说明：（1）通常情况下，实际写出的字节数与欲写盘的字节数相同，除非磁盘满。
（2）文件应以写或读写方式打开。
（3）写文件后，文件指针将定位到写入字节之后的第一个字节处。
关闭文件（3EH号功能调用）
功能：关闭文件。
入口参数：BX=文件号（柄）。
出口参数：CF=0表示成功。
CF=1表示失败。
说明：文件号是打开该文件时系统所给定的文件号。
带回显键盘输入（1号功能调用）功能：从标准输入设备上读一字符，并将该字符回显在标准输出设备上。
通常情况下，标准输入设备就是键盘，标准输出设备就是屏幕。如果键盘无字符可读，则一直等待到有字符可读（即按键）。
入口参数：无。
出口参数：AL=读到字符的代码（ASCII码）。
说明：如果读到的字符是Ctrl+C或Ctrl+Break，则结束程序。
不带回显键盘输入（8号功能调用）除读到的输入字符不在屏幕上显示外，同1号功能调用。
ctrl+字母的ASCII码=字母的ASCII码&0x1f
例2：写一个能把键盘上输入的全部字符（直到CTRL+Z键，值1AH）存入某个文件的程序。
为简单起见，文件固定为当前盘根目录下的TEST.TXT，如果它已存在，则更新它。
具体算法是：先建立指定文件；然后读键盘，把所读字符顺序写入文件，如此循环直到读到文件结束符（1AH）；关闭文件。
源程序如下：
程序名：T4-7.ASM
功能：把键盘上输入的字符全部存入文件TEST.TXT
EOF =1AH
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
FNAME DB '\TEST.TXT',0
ERRMESS1 DB 'Can not create file',07H,'$'
ERRMESS2 DB 'Writing error',07H,'$'
BUFFER DB ?
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET FNAME
MOV CX,0
MOV AH,3CH
INT 21H
JNC CREA_OK
MOV DX,OFFSET ERRMESS1
CALL DISPMESS
JMP OVER
CREA_OK:MOV BX,AX
CONT:CALL GETCHAR
PUSH AX
CALL WRITECH
POP AX
JC WERROR
CMP AL,EOF
JNZ CONT
JMP CLOSEF
WERROR:MOV DX,OFFSET ERRMESS2
CALL DISPMESS
CLOSEF:MOV AH,3EH
INT 21H
OVER:MOV AX,4C00H
INT 21H
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
WRITECH PROC
PUSH AX
PUSH CX
PUSH DX
MOV BUFFER,AL
MOV CX,1
MOV DX,OFFSET BUFFER
MOV AH,40H
INT 21H
POP DX
POP CX
POP AX
RET
WRITECH ENDP
GETCHAR PROC
MOV AH,1
INT 21H
RET
GETCHAR ENDP
CSEG ENDS
END START
上述程序每次只向文件写一个字节，读者可把它改成每次向文件写若干字节。
它通过1号功能调用读键盘，然后就把所读的字符写入文件，
如果实际运行这个程序，也许读者会发现在按退格键和回车键时有些特殊异常，如何解决就作为练习留给读者。
测试通过的完整程序如下
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
EOF =1AH
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
FNAME DB '\TEST.TXT',0
ERRMESS1 DB 'Can not create file',07H,'$'
ERRMESS2 DB 'Writing error',07H,'$'
BUFFER DB 128 DUP (0)
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET FNAME
MOV CX,0
MOV AH,3CH
INT 21H
JNC CREA_OK
MOV DX,OFFSET ERRMESS1
CALL DISPMESS
JMP OVER
CREA_OK:MOV BX,AX
MOV BUFFER,0
CONT:CALL GETSTR
CALL WRITESTR
JC WERROR
CMP BUFFER,EOF
JNZ CONT
JMP CLOSEF
WERROR:MOV DX,OFFSET ERRMESS2
CALL DISPMESS
CLOSEF:MOV AH,3EH
INT 21H
OVER:MOV AX,4C00H
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTR PROC
PUSH AX
PUSH BX
PUSH DI
MOV DI,OFFSET BUFFER
MOV BUFFER[1],0
MOV BX,0
GETSTR1:CALL GETCH
CMP AL,EOF
JZ GETSTR6
CMP AL,CR
JZ GETSTR5
CMP AL,BACKSPACE
JNZ GETSTR4
CMP BX,0
JZ GETSTR2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTR1
GETSTR2:CALL BELL
JMP GETSTR1
GETSTR4:CMP BX,78
JZ GETSTR2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTR1
GETSTR5:MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV BUFFER[1],BL
JMP GETSTR_OK
GETSTR6:MOV BUFFER,AL
MOV BUFFER[1],BL
GETSTR_OK:
POP DI
POP BX
POP AX
RET
GETSTR ENDP
WRITESTR PROC
PUSH AX
PUSH CX
PUSH DX
CMP BUFFER[1],0
JZ WRITESTR1
MOV CL,BUFFER[1]
XOR CH,CH
MOV DX,OFFSET BUFFER+2
MOV AH,40H
INT 21H
WRITESTR1:POP DX
POP CX
POP AX
RET
WRITESTR ENDP
CSEG ENDS
END START
建立文件（3CH号功能调用）
功能：建立文件（创建新的，或刷新老的文件）。
入口参数：DS:DX=代表文件名的字符串的首地址。
CX=文件属性。
出口参数：CF=0表示成功，AX=文件号（柄）。
CF=1表示失败，AX=错误代码。
说明：（1）可指定的文件属性如下：
00H普通
01H只读
02H隐含
04H系统
（2）创建文件成功后，文件长度定为0。
打开文件（3DH号功能调用）
功能：打开文件。
入口参数：DS:DX=代表文件名的字符串的首地址。
AL=存取方式。
出口参数：CF=0表示成功，AX=文件号（柄）。
CF=1表示失败，AX=错误代码。
说明：（1）存取方式规定如下：
00H只读方式
01H只写方式
02H读写方式
（2）打开文件成功后，文件指针定位于开始的第一个字节（偏移0）处。
读文件（3FH号功能调用）
功能：读文件。
入口参数：BX=文件号（柄）。
CX=读入字节数。
DS:DX=准备存放所读数据的缓冲区的首地址。
出口参数：CF=0表示成功，AX=实际读到的字节数。
CF=1表示失败，AX=错误代码。
说明：（1）通常情况下，实际读到的字节数与欲读入的字节数相同，除非不够读。
（2）缓冲区应保证能容下所读到的数据。
（3）文件应以读或读写方式打开。
（4）读文件后，文件指针将定位到读出字节之后的第一个字节处。
写文件（40H号功能调用）
功能：写文件。
入口参数：BX=文件号（柄）；
CX=写盘字节数；
DS:DX=存放写数据的缓冲区的首地址。
出口参数：CF=0表示成功，AX=实际写出的字节数。
CF=1表示失败，AX=错误代码。
说明：（1）通常情况下，实际写出的字节数与欲写盘的字节数相同，除非磁盘满。
（2）文件应以写或读写方式打开。
（3）写文件后，文件指针将定位到写入字节之后的第一个字节处。
关闭文件（3EH号功能调用）
功能：关闭文件。
入口参数：BX=文件号（柄）。
出口参数：CF=0表示成功。
CF=1表示失败。
说明：文件号是打开该文件时系统所给定的文件号。
移动文件读写指针（42H号功能调用）
功能：移动文件（读写）指针。
入口参数：BX=文件号（柄）。
CX:DX=移动位移量。
AL=移动方式。
出口参数：CF=0表示成功，此时，DX:AX=移动后文件指针值。
CF=1表示失败，此时，（AX）=1表示无效的移动方式，（AX）=6表示无效的文件号。
说明：（1）文件指针值（双字）是以文件首字节为0计算的。
（2）移动方式和表示的意义如下：
00H 移动后文件指针值=0（文件头）+移动位移量
01H =当前文件指针值+移动位移量
02H =文件长（文件尾）+移动位移量
（3）在第一种移动方式中，移动位移量总是正的。
（4）在后两种移动方式中，移动位移量可正可负。
（5）该子功能不考虑文件指针是否超出文件范围。
例3：写一个程序把文件2拼接到文件1上。文件1固定为当前目录下的TEST1，文件2固定为当前目录下的TEST2。
具体算法是：为写打开文件TEST1，为读打开文件TEST2；
把文件TEST1的读写指针移到尾；读TEST2的一块到缓冲区，写这一个块到TEST1，如此循环，直到TEST2结束；
最后关闭两个文件。源程序如下：
程序名：T4-8.ASM
功能：把文件TEST2拼接到文件TEST1之后
BUFFLEN=512
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
FNAME1 DB 'TEST1',0
FNAME2 DB 'TEST2',0
HANDLE1 DW 0
HANDLE2 DW 0
ERRMESS1 DB 'Can not open file',07H,'$'
ERRMESS2 DB 'Reading error',07h,'$'
ERRMESS3 DB 'Writing error',07H,'$'
BUFFER DB BUFFLEN DUP (0)
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET FNAME1
MOV AX,3D01H
INT 21H
JNC OPENOK1
ERR1:MOV DX,OFFSET ERRMESS1
CALL DISPMESS
JMP OVER
OPENOK1:MOV HANDLE1,AX
MOV DX,OFFSET FNAME2
MOV AX,3D00H
INT 21H
JNC OPENOK2
MOV BX,HANDLE1
MOV AH,3EH
INT 21H
JMP ERR1
OPENOK2:MOV HANDLE2,AX
MOV BX,HANDLE1
XOR CX,CX
XOR DX,DX
MOV AX,4202H
INT 21H
CONT:MOV DX,OFFSET BUFFER
MOV CX,BUFFLEN
MOV BX,HANDLE2
MOV AH,3FH
INT 21H
JC RERR
OR AX,AX
JZ COPYOK
MOV CX,AX
MOV BX,HANDLE1
MOV AH,40H
INT 21H
JNC CONT
WERR:MOV DX,OFFSET ERRMESS3
CALL DISPMESS
JMP COPYOK
RERR:MOV DX,OFFSET ERRMESS2
CALL DISPMESS
COPYOK:MOV BX,HANDLE1
MOV AH,3EH
INT 21H
MOV BX,HANDLE2
MOV AH,3EH
INT 21H
OVER:MOV AH,4CH
INT 21H
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
CSEG ENDS
END START
测试通过的完整程序如下
BUFFLEN=512
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
FNAME1 DB 'TEST1',0
FNAME2 DB 'TEST2',0
HANDLE1 DW 0
HANDLE2 DW 0
ERRMESS1 DB 'Can not open file',07H,'$'
ERRMESS2 DB 'Reading error',07h,'$'
ERRMESS3 DB 'Writing error',07H,'$'
BUFFER DB BUFFLEN DUP (0)
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET FNAME1
MOV AX,3D01H
INT 21H
JNC OPENOK1
ERR1:MOV DX,OFFSET ERRMESS1
CALL DISPMESS
JMP OVER
OPENOK1:MOV HANDLE1,AX
MOV DX,OFFSET FNAME2
MOV AX,3D00H
INT 21H
JNC OPENOK2
MOV BX,HANDLE1
MOV AH,3EH
INT 21H
JMP ERR1
OPENOK2:MOV HANDLE2,AX
MOV BX,HANDLE1
XOR CX,CX
XOR DX,DX
MOV AX,4202H
INT 21H
CONT:MOV DX,OFFSET BUFFER
MOV CX,BUFFLEN
MOV BX,HANDLE2
MOV AH,3FH
INT 21H
JC RERR
OR AX,AX
JZ COPYOK
MOV CX,AX
MOV BX,HANDLE1
MOV AH,40H
INT 21H
JNC CONT
WERR:MOV DX,OFFSET ERRMESS3
CALL DISPMESS
JMP COPYOK
RERR:MOV DX,OFFSET ERRMESS2
CALL DISPMESS
COPYOK:MOV BX,HANDLE1
MOV AH,3EH
INT 21H
MOV BX,HANDLE2
MOV AH,3EH
INT 21H
OVER:MOV AH,4CH
INT 21H
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
CSEG ENDS
END START
在上述程序中，文件名是固定的，读者可把它改成文件名由用户输入。读者也可把它扩展为把两个文件合并成第三个文件。
这些都留给读者作为练习。
测试通过的完整程序如下
BUFFLEN=512
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
MESS1 DB 'Please input filename1:$'
MESS2 DB 'Please input filename2:$'
MESS3 DB 'Please input filename3:$'
FNAME1 DB 16 DUP (0)
FNAME2 DB 16 DUP (0)
FNAME3 DB 16 DUP (0)
HANDLE1 DW 0
HANDLE2 DW 0
HANDLE3 DW 0
ERRMESS1 DB 'Can not open file',07H,'$'
ERRMESS2 DB 'Reading error',07h,'$'
ERRMESS3 DB 'Can not create file',07H,'$'
ERRMESS4 DB 'Writing error',07H,'$'
BUFFER DB BUFFLEN DUP (0)
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESS1
CALL DISPMESS
MOV DX,OFFSET FNAME1
CALL GETFNAME
MOV DX,OFFSET MESS2
CALL DISPMESS
MOV DX,OFFSET FNAME2
CALL GETFNAME
MOV DX,OFFSET MESS3
CALL DISPMESS
MOV DX,OFFSET FNAME3
CALL GETFNAME
MOV DX,OFFSET FNAME1
MOV AX,3D00H
INT 21H
JNC OPENOK1
ERR1:MOV DX,OFFSET ERRMESS1
CALL DISPMESS
JMP OVER
OPENOK1:MOV HANDLE1,AX
MOV DX,OFFSET FNAME2
MOV AX,3D00H
INT 21H
JNC OPENOK2
MOV BX,HANDLE1
MOV AH,3EH
INT 21H
JMP ERR1
OPENOK2:MOV HANDLE2,AX
MOV DX,OFFSET FNAME3
MOV CX,0
MOV AH,3CH
INT 21H
JNC CREA_OK
MOV BX,HANDLE1
MOV AH,3EH
INT 21H
MOV BX,HANDLE2
MOV AH,3EH
INT 21H
MOV DX,OFFSET ERRMESS3
CALL DISPMESS
JMP OVER
CREA_OK:MOV HANDLE3,AX
CONT1:MOV DX,OFFSET BUFFER
MOV CX,BUFFLEN
MOV BX,HANDLE1
MOV AH,3FH
INT 21H
JC RERR
OR AX,AX
JZ CONT2
MOV CX,AX
MOV BX,HANDLE3
MOV AH,40H
INT 21H
JNC CONT1
JMP WERR
CONT2:MOV DX,OFFSET BUFFER
MOV CX,BUFFLEN
MOV BX,HANDLE2
MOV AH,3FH
INT 21H
JC RERR
OR AX,AX
JZ COPYOK
MOV CX,AX
MOV BX,HANDLE3
MOV AH,40H
INT 21H
JNC CONT2
WERR:MOV DX,OFFSET ERRMESS4
CALL DISPMESS
JMP COPYOK
RERR:MOV DX,OFFSET ERRMESS2
CALL DISPMESS
COPYOK:MOV BX,HANDLE1
MOV AH,3EH
INT 21H
MOV BX,HANDLE2
MOV AH,3EH
INT 21H
MOV BX,HANDLE3
MOV AH,3EH
INT 21H
OVER:MOV AH,4CH
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETFNAME PROC
PUSH AX
PUSH BX
PUSH DI
MOV DI,DX
MOV BX,0
GETFNAME1:CALL GETCH
CMP AL,CR
JZ GETFNAME5
CMP AL,BACKSPACE
JNZ GETFNAME4
CMP BX,0
JZ GETFNAME2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETFNAME1
GETFNAME2:CALL BELL
JMP GETFNAME1
GETFNAME4:CMP BX,12
JZ GETFNAME2
MOV [BX][DI],AL
INC BX
CALL PUTCH
JMP GETFNAME1
GETFNAME5:CMP BX,0
JZ GETFNAME2
MOV [BX][DI],0
CALL NEWLINE
POP DI
POP BX
POP AX
RET
GETFNAME ENDP
CSEG ENDS
END START
4.5子程序的递归和重人
子程序是否可递归和是否可重入是子程序的两个重要特性，下面简单介绍这两个基本概念。
4.5.1递归子程序
如果一个子程序直接调用它自身，这种调用称为直接递归调用；
如果一个子程序间接调用它自身，这种调用称为间接递归调用。
具有递归调用的子程序就称为递归子程序。递归是嵌套的特殊情形。
递归子程序必须采用寄存器或堆栈传递参数。递归的深度受堆栈空间的限制。
下面的子程序FACT采用递归算法实现求阶乘，是递归子程序。
子程序名：FACT
功能：计算n！
入口参数：（AX）=n
出口参数：（AX）=n！
说明：（1）采用递归算法实现求阶乘；
（2）n不能超过8。
FACT PROC
PUSH DX
MOV DX,AX
CMP AX,0
JZ DONE
DEC AX
CALL FACT
MUL DX
POP DX
RET
DONE:MOV AX,1
POP DX
RET
FACT ENDP
该子程序限制入口参数n大小的主要原因，是只采用16位表示阶乘值。
4.5.2可重人子程序
子程序的重入是指子程序在中断后被重新调用。子程序的重入不同于子程序的递归，重入是被动行为，而递归是主动行为，
重入前的调用和重入调用往往是不相干的，而递归调用前后却是密切相关的。
我们把能够重入的子程序称为可重入子程序。在设计可重入子程序时，必须注意如下几点：
（1）不能利用约定存储单元传递参数。
下面的子程序NRENT的功能与子程序HTOASC相同，实现把一位16进制数转换为对应的ASCII码，但利用存储单元传递参数。
入口参数：欲转换的一位16进制数在变量HVAR中
出口参数：对应的ASCII码在变量RESULT中
NRENT PROC
PUSH AX
MOV AL,HVAR
AND AL,0FH
ADD AL,30H
CMP AL,39H
JBE HOK
ADD AL,7
HOK:MOV RESULT,AL
POP AX
RET
NRENT ENDP
如果在执行该子程序的第（1）或（2）条指令前被中断，并且中断处理程序重新调用该子程序，那么入口参数就会被破坏，
所以原调用的返回就不正确。
如果在执行该子程序的第（8）条指令后被中断，并且中断处理程序重新调用该子程序，那么第一次调用的出口参数就会被破坏。
所以上述子程序是不可重入的。
（2）不能使用约定的存储单元保存中间值。
原因是约定存储单元保存的中间值在重入时可能被破坏、如果子程序要使用临时变量保存中间值，那么临时变量须安排在堆栈中。
下面的例子说明如何把临时变量安排在堆栈中。
子程序名：SLEN
功能：测字符串的长度
入口参数：（DS:SI）=字符串首地址
出口参数：（AX）=字符串长度
说明：字符串以0结尾
SLEN PROC NEAR
PUSH BP
MOV BP,SP
SUB SP,2
MOV WORD PTR [BP-2],0
SLEN1:MOV AL,[SI]
INC SI
OR AL,AL
JZ SLEN2
INC WORD PTR [BP-2]
JMP SLEN1
SLEN2:MOV AX,[BP-2]
MOV SP,BP
POP BP
RET
SLEN ENDP
调用上述子程序后的堆栈如图4.8所示，BP-2所指单元为计数器使用的临时单元。
4.6习题
题4.1把怎样的程序片段设计成子程序或者过程？
如果某个程序片段将反复在程序中出现，就把它设计成子程序。
如果某个程序片段具有通用性，可供许多程序共享，就把它设计成子程序。
如果某个程序片段的功能相对独立，可把它设计成子程序。
在80x86系列汇编语言中，子程序常常以过程的形式出现。
题4.2子程序说明信息应包含哪些内容？举例说明之。
子程序说明信息一般由如下几部分组成，每一部分内容应简明确切：
（1）子程序名。
（2）功能描述。
（3）入口和出口参数。
（4）所用的寄存器和存储单元。
（5）使用的算法和重要的性能指标。
（6）其他调用注意事项和说明信息。
（7）调用实例。
子程序说明信息至少应该包含前三部分内容。例如：
子程序名：AHTOASC
功能：把8位二进制数转换为2位十六进制数的ASCII码；
入口参数：AL=欲转换的8位二进制数；
出口参数：AH=十六进制数高位的ASCII码；AL=十六进制数低位的ASCII码
其他说明：（1）近过程（2）除AX寄存器外，不影响其他寄存器；（3）调用了HTOASC实现十六进制数到ASCIl码的转换
题4.3请把过程调用指令CALL与无条件转移指令JMP作一番比较，说明它们的异同。
过程调用指令CALL首先把子程序的返回地址（即CALL指令的下一条指令的地址）压入堆栈，然后转移到子程序的入口地址去执行子程序。
无条件转移指令JMP没有进行压栈，这条指令使控制无条件地转移到目标地址处。
（1）段内直接调用
段内直接调用指令用于调用当前段内的子程序，格式如下：
CALL 过程名
该指令进行的具体操作分解如下：
SP=SP-2
[SP]=IP
IP=IP+disp
该指令只把返回地址的偏移部分IP压入堆栈保存
无条件段内直接转移指令的使用格式如下：
JMP 标号
这条指令使控制无条件地转移到标号地址处
（2）段内间接调用
段内间接调用指令也用于调用当前段内的子程序，格式如下：
CALL OPRD
OPRD是16位通用寄存器或字存储器操作数。
该指令进行的具体操作分解如下：
SP=SP-2
[SP]=IP
IP=（OPRD）
该指令只把返回地址的偏移部分IP压入堆栈保存
如OPRD是16位通用寄存器操作数，则把寄存器之内容送IP；如OPRD是字存储器操作数，则把字存储单元之内容送IP。
无条件段内间接转移指令的格式如下：
JMP OPRD
这条指令使控制无条件地转移到由操作数OPRD的内容给定的目标地址处。操作数OPRD可以是通用寄存器，也可以是字存储单元。
（3）段间直接调用
段间直接调用指令用于调用其它代码段中的子程序。格式如下：
CALL FAR PTR 过程名
该指令先把返回地址的段值压入堆栈，再把返回地址的偏移压入堆栈
然后把过程的入口地址的段值和偏移分别送入CS和IP，该指令进行的具体操作分解如下：
SP=SP-2
[SP]=CS
SP=SP-2
[SP]=IP
IP=过程入口地址的偏移
CS=过程入口地址的段值
无条件段间直接转移指令的使用格式如下：
JMP FAR PTR 标号
这条指令使控制无条件地转移到标号所对应的地址处。
无条件段间直接转移指令的具体动作是把指令中包含的目标地址的段值和偏移分别置入CS和IP。
（4）段间间接调用
段间间接调用指令也用于调用其它代码段中的子程序。格式如下：
CALL OPRD
OPRD是双字存储器操作数。该指令进行的具体操作可分解如下：
SP=SP-2
[SP]=CS
SP=SP-2
[SP]=IP
IP=OPRD之低字值
CS=OPRD之高字值
该指令把返回地址的段值CS和偏移IP分别压入堆栈保存，
然后把双字存储器操作数的低字送IP，把双字存储器操作数的高字送CS
无条件段间间接转移指令的格式如下：
JMP OPRD
这条指令使控制无条件地转移到由操作数OPRD的内容给定的目标地址处。操作数OPRD必须是双字存储单元。
双字存储单元的低字内容送IP 双字存储单元的高字内容送CS
题4.4是否可用段内调用指令调用远过程？如果可以，请举例说明。
可以，先把过程的类型定为远类型，后面调用远过程时可以省略FAR PTR，
此时的段间直接调用可以写成CALL 过程名与段内直接调用的格式一样
远类型过程SUBF定义语句
SUBF PROC FAR
......
SUBF ENDP
调用SUBF
CALL SUBF
题4.5是否可用过程返回指令RET调用某个过程？如果可能，请写出实现的程序片段。
先模拟CALL指令的push ip，再push 过程的地址，使用ret跳转到对应过程的地址
DSEG SEGMENT
BUFF DB 4 DUP (0)
DB 'H',0DH,0AH,'$'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV AX,0F000H
MOV ES,AX
MOV DX,ES:[0]
MOV BX,OFFSET BUFF
MOV AX,OFFSET DBUF
PUSH AX
MOV AX,OFFSET HTASCS
PUSH AX
RET
DBUF:MOV DX,OFFSET BUFF
MOV AH,9
INT 21H
MOV AX,4C00H
INT 21H
HTASCS PROC
MOV CX,4
HTASCS1:ROL DX,1
ROL DX,1
ROL DX,1
ROL DX,1
MOV AL,DL
CALL HTOASC
MOV DS:[BX],AL
INC BX
LOOP HTASCS1
RET
HTASCS ENDP
HTOASC PROC
AND AL,0FH
CMP AL,9
JBE HTOASC1
ADD AL,37H
JMP OK
HTOASC1:ADD AL,30H
OK:RET
HTOASC ENDP
CSEG ENDS
END START
题4.6请对保护和恢复寄存器的两种方法作比较。
寄存器的保护与恢复有两种方法：
（1）把需要保护的寄存器的内容，在主程序中压入堆栈和弹出堆栈。
这种方法的优点是，在每次调用子程序时，只要把主程序所关心的寄存器压入堆栈。
但缺点是：在主程序中使用压入和弹出堆栈的操作会使主程序不易理解；
如果要多次调用子程序时，会很累赘，而且常常会忘了把某个寄存器压入堆栈。
（2）在子程序一开始就把在子程序中要改变的寄存器内容压入堆栈，而在返回之前再恢复这些寄存器的内容。
这种方法的优点是：在主程序中可方便地调用子程序，而无需考虑要把哪些寄存器压入堆栈；
只需要在子程序中写一次压入和弹出堆栈指令组即可。这种方法是常用的方法。
题4.7在汇编语言中，主程序与子程序之间如何传递参数？请举例说明每种方法，并对这些方法作比较。
主程序与子程序间传递参数的方法：寄存器传递法、约定内存单元传递法、堆栈传递法和CALL后续区传递法等。
1、利用寄存器传递参数
利用寄存器传递参数就是把参数放在约定的寄存器中。这种方法的优点是实现简单和调用方便。
但由于寄存器的个数是有限的，且寄存器往往还要存放其他数据，所以只适用于要传递的参数较少的情况。
例1：写一个把大写字母改为小写字母的子程序。
子程序名：UPTOLW
功能：把大写字母转换为小写字母
入口参数：AL=字符ASCII码；出口参数：AL=字符ASCII码
说明：如果字符是大写字母，则转换为小写字母，其他字符不变
UPTOLW PROC
PUSHF
CMP AL,'A'
JB UPTOLW1
CMP AL,'Z'
JA UPTOLW1
ADD AL,'a'-'A'
UPTOLW1:POPF
RET
UPTOLW ENDP
2、利用约定存储单元传递参数
在传递参数较多的情况下，可利用约定的内存变量来传递参数。
这种方法的优点是子程序要处理的数据或送出的结果都有独立的存储单元，编写程序时不易出错。
但这种方法要占用一定的存储单元，利用约定的存储单元传递参数，通用性较差。
例3：写一个实现32位数相加的子程序。
子程序名：MADD；
功能：32位数相加
入口参数：DATA1和DATA2缓冲区中分别存放要相加的32数；
出口参数：DATA3缓冲区中存放结果
说明：（1）32位数据的存放次序采用“高高低低”的原则（2）可能产生的进位存放在DATA3开始的第5字节中
MADD PROC
PUSH AX
PUSH CX
PUSH SI
MOV CX,2
XOR SI,SI
MADD1:MOV AX,WORD PTR DATA1[SI]
ADC AX,WORD PTR DATA2[SI]
MOV WORD PTR DATA3[SI],AX
INC SI
INC SI
LOOP MADD1
MOV AL,0
ADC AL,0
MOV BYTE PTR DATA3+4,AL
POP SI
POP CX
POP AX
RET
MADD ENDP
3、利用堆栈传递参数
如果使用堆栈传递入口参数，那么主程序在调用子程序之前，把需要传递的参数依次压入堆栈，子程序从堆栈中取入口参数；
如果使用堆栈传递出口参数，那么子程序在返回前，把需要返回的参数存入堆栈，主程序在堆栈中取出口参数。
利用堆栈传递参数可以不占用寄存器，也无需使用额外的存储单元。
但由于参数和子程序的返回地址混杂在一起，有时还要考虑保护寄存器，所以较为复杂。
通常利用堆栈传递入口参数，而利用寄存器传递出口参数。
例5：写一个测量字符串长度的子程序。设字符串以0为结束标志。
利用堆栈来传递入口参数：字符串的起始地址（设包括段值和偏移）；
利用寄存器传递出口参数：字符串的长度。
设子程序STRLEN是一个近过程，那么主程序在调用它时，只把返回地址的偏移压入堆栈。
子程序名：STRLEN
功能：测量字符串的长度
入口参数：字符串起始地址的段值和偏移在堆栈中
出口参数：AX=字符串长度
STRLEN PROC
PUSH BP
MOV BP,SP
PUSH DS
PUSH SI
MOV DS,[BP+6]
MOV SI,[BP+4]
MOV AL,0
STRLEN1:CMP AL,[SI]
JZ STRLEN2
INC SI
JMP STRLEN1
STRLEN2:MOV AX,SI
SUB AX,[BP+4]
POP SI
POP DS
POP BP
RET
STRLEN ENDP
主程序调用这个子程序的代码片段如下所示
……
MOV AX,SEG STRMESS
PUSH AX
MOV AX,OFFSET STRMESS
PUSH AX
CALL STRLEN
ADD SP,4
MOV LEN,AX
……
4、利用CALL后续区传递参数
CALL后续区是指位于CALL指令后的存储区域。主程序在调用子程序之前，把入口参数存入CALL指令后的存储单元中，
子程序根据保存在堆栈中的返回地址找到入口参数，这种传递参数的方法称为CALL后续区传递参数法。
利用CALL后续区传递参数的子程序必须修改返回地址。
由于这种方法把数据和代码混在一起，所以在x86系列汇编语言程序中使用得不多。
例6：写一个把字符串中的大写字母改为小写字母的子程序（近过程）。设字符串以0为结束标志。
用CALL后续区传递字符串起始地址的段值和偏移。
子程序名：STRLWR
功能：把字符串中的所有大写字母改为小写字母
入口参数：字符串起始地址的段值和偏移在CALL后续区（见图4.5（a））。
出口参数：无
STRLWR PROC
PUSH BP
MOV BP,SP
PUSH AX
PUSH SI
PUSH DS
MOV SI,[BP+2]
MOV DS,CS:[SI+2]
MOV SI,CS:[SI]
STRLWR1:MOV AL,[SI]
CMP AL,0
JZ STRLWR3
CMP AL,'A'
JB STRLWR2
CMP AL,'Z'
JA STRLWR2
ADD AL,'a'-'A'
MOV [SI],AL
STRLWR2:INC SI
JMP STRLWR1
STRLWR3:ADD WORD PTR [BP+2],4
POP DS
POP SI
POP AX
POP BP
RET
STRLWR ENDP
调用上述子程序的源程序片段如下所示：
……
CALL STRLWR
DW OFFSET STRMESS
DW SEG DSEG
CONT:
……
题4.8如果利用堆栈传递参数，那么有两种平衡堆栈的方法，请比较这两种方法。
测量字符串长度的子程序。设字符串以0为结束标志。
利用堆栈来传递入口参数：字符串的起始地址（设包括段值和偏移）；
利用寄存器传递出口参数：字符串的长度。
子程序名：STRLEN
功能：测量字符串的长度
入口参数：字符串起始地址的段值和偏移在堆栈中
出口参数：AX=字符串长度
STRLEN PROC
PUSH BP
MOV BP,SP
PUSH DS
PUSH SI
MOV DS,[BP+6]
MOV SI,[BP+4]
MOV AL,0
STRLEN1:CMP AL,[SI]
JZ STRLEN2
INC SI
JMP STRLEN1
STRLEN2:MOV AX,SI
SUB AX,[BP+4]
POP SI
POP DS
POP BP
RET
STRLEN ENDP
主程序调用这个子程序的代码片段如下所示
……
MOV AX,SEG STRMESS
PUSH AX
MOV AX,OFFSET STRMESS
PUSH AX
CALL STRLEN
ADD SP,4
MOV LEN,AX
……
主程序在调用子程序STRLEN之前把要测量长度的字符串起始地址的段值和偏移作为入口参数压入堆栈，
从子程序返回后，需要废除仍在堆栈中的入口参数，
本例中利用了指令“ADD SP,4”来平衡堆栈，
另一种废除堆栈中入口参数的方法是使用带立即数返回指令。
这可在子程序返回时就自动平衡堆栈，主程序就不需要再进行堆栈的平衡工作。
对于上述子程序，可采用如下的返回指令：
RET 4
此立即数与入口参数量有关
如果这样的话，上面主程序调用子程序的片段就不需要调整堆栈指针的指令“ADD SP,4”。
题4.9子程序的递归和重入有何异同？
如果一个子程序直接调用它自身，这种调用称为直接递归调用；
如果一个子程序间接调用它自身，这种调用称为间接递归调用。
具有递归调用的子程序就称为递归子程序。
递归子程序必须采用寄存器或堆栈传递参数。递归的深度受堆栈空间的限制。
子程序的重入是指子程序在中断后被重新调用。子程序的重入不同于子程序的递归，重入是被动行为，而递归是主动行为，
重入前的调用和重入调用往往是不相干的，而递归调用前后却是密切相关的。
我们把能够重入的子程序称为可重入子程序。
可重入子程序不能使用约定的存储单元传递参数、保存中间值。
题4.10对于可重入的子程序，为什么不能利用固定的存储单元保存中间值？为什么不能利用约定存储单元传递参数？
这些存储单元在子程序被中断后，可能会被其他程序使用，这样存储单元保存的内容就可能发生了变化。
如果发生过变化，则在重入时就得不到正确的结果。
题4.11编写一个求32位补码的子程序。通过寄存器传递出入口参数。
32位有符号数存放在DX:AX中
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG
START:MOV AX,5678H
MOV DX,0FFFFH
CALL COMPLE
MOV AH,4CH
INT 21H
COMPLE PROC
PUSH BX
mov bx,dx
and bx,8000h
cmp bx,0
jz ok
not dx
not ax
add ax,1
adc dx,0
or dx,8000h
ok:nop
POP BX
RET
COMPLE ENDP
CSEG ENDS
END START
题4.12编写一个利用查表的方法实现把1位十六进制数转换为对应ASCII码的子程序。出入口参数传递的方法自定。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG
START:MOV AL,6AH
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
MOV AH,4CH
INT 21H
HTOASC PROC
JMP HTOASC1
table db '0123456789ABCDEF'
HTOASC1:PUSH BX
AND AL,0FH
MOV BL,AL
MOV BH,0
MOV AL,table[BX]
POP BX
RET
HTOASC ENDP
AHTOASC PROC
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL HTOASC
XCHG AH,AL
CALL HTOASC
RET
AHTOASC ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
CSEG ENDS
END START
题4.13按要求分别编写实现如下功能的子程序：把由十进制数ASCII码组成的字符串转换为对应的数值。
过程SUBA通过寄存器传递入口参数，通过寄存器传递出口参数。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
mul_table dw 1,10,100,1000,10000
res_ax dw 0
res_dx dw 0
ASCII DB '56789',0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV SI,OFFSET ASCII
call convert
mov ax,4c00h
int 21h
convert PROC
push ax
push bx
push cx
push dx
push si
push di
xor cx,cx
convert_s1:mov al,ds:[si]
cmp al,0
je ok1
cmp al,30h
jb ok2
cmp al,39h
ja ok2
inc cx
inc si
jmp convert_s1
ok1:jcxz ok2
dec si
mov di,0
mov res_ax,0
mov res_dx,0
convert_s2:mov al,ds:[si]
sub al,30h
mov ah,0
mov bx,mul_table[di]
mul bx
add res_ax,ax
adc res_dx,dx
dec si
add di,2
loop convert_s2
ok3:pop di
pop si
pop dx
pop cx
pop bx
pop ax
mov ax,res_ax
mov dx,res_dx
ret
ok2:pop di
pop si
pop dx
pop cx
pop bx
pop ax
ret
convert ENDP
CSEG ENDS
END START
过程SUBB通过堆栈传递入口参数，通过寄存器传递出口参数。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
mul_table dw 1,10,100,1000,10000
res_ax dw 0
res_dx dw 0
ASCII DB '56789',0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
PUSH AX
MOV AX,OFFSET ASCII
PUSH AX
call convert
ADD SP,4
mov ax,4c00h
int 21h
convert PROC
PUSH BP
MOV BP,SP
PUSH DS
PUSH SI
MOV DS,[BP+6]
MOV SI,[BP+4]
push ax
push bx
push cx
push dx
push si
push di
xor cx,cx
convert_s1:mov al,ds:[si]
cmp al,0
je ok1
cmp al,30h
jb ok2
cmp al,39h
ja ok2
inc cx
inc si
jmp convert_s1
ok1:jcxz ok2
dec si
mov di,0
mov res_ax,0
mov res_dx,0
convert_s2:mov al,ds:[si]
sub al,30h
mov ah,0
mov bx,mul_table[di]
mul bx
add res_ax,ax
adc res_dx,dx
dec si
add di,2
loop convert_s2
ok3:pop di
pop si
pop dx
pop cx
pop bx
pop ax
mov ax,res_ax
mov dx,res_dx
POP SI
POP DS
POP BP
ret
ok2:pop di
pop si
pop dx
pop cx
pop bx
pop ax
POP SI
POP DS
POP BP
ret
convert ENDP
CSEG ENDS
END START
过程SUBC通过堆栈传递入口参数，通过堆栈传递出口参数。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
mul_table dw 1,10,100,1000,10000
res_ax dw 0
res_dx dw 0
ASCII DB '98765',0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
PUSH AX
PUSH AX
PUSH AX
MOV AX,OFFSET ASCII
PUSH AX
call convert
ADD SP,4
POP AX
POP DX
mov ax,4c00h
int 21h
convert PROC
PUSH BP
MOV BP,SP
PUSH DS
PUSH SI
MOV DS,[BP+6]
MOV SI,[BP+4]
push ax
push bx
push cx
push dx
push si
push di
xor cx,cx
convert_s1:mov al,ds:[si]
cmp al,0
je ok1
cmp al,30h
jb ok2
cmp al,39h
ja ok2
inc cx
inc si
jmp convert_s1
ok1:jcxz ok2
dec si
mov di,0
mov res_ax,0
mov res_dx,0
convert_s2:mov al,ds:[si]
sub al,30h
mov ah,0
mov bx,mul_table[di]
mul bx
add res_ax,ax
adc res_dx,dx
dec si
add di,2
loop convert_s2
ok3:pop di
pop si
pop dx
pop cx
pop bx
pop ax
PUSH AX
MOV AX,res_ax
MOV [BP+8],AX
POP AX
PUSH DX
MOV DX,res_dx
MOV [BP+10],DX
POP DX
POP SI
POP DS
POP BP
ret
ok2:pop di
pop si
pop dx
pop cx
pop bx
pop ax
POP SI
POP DS
POP BP
ret
convert ENDP
CSEG ENDS
END START
作为入口参数的字符串首地址由段值和偏移构成，其他参数或要求自定。
题4.14按要求分别编写实现如下功能的子程序：把16位二进制数转换为对应十进制数ASCII码串。
作为入口参数的二进制数是有符号的，采用补码形式表示。通过堆栈传递入口参数。
过程SUBA是近过程，堆栈由主程序平衡。过程SUBB是近过程，堆栈由子程序平衡。过程SUBC是远过程，堆栈由主程序平衡。
过程SUBD是远过程，堆栈由子程序平衡。
验证补码形式表示的16位二进制负数求对应绝对值的子程序
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG
START:MOV AX,-12345
CALL ABSOLU
MOV AH,4CH
INT 21H
ABSOLU PROC
PUSH BX
mov bx,ax
and bx,8000h
cmp bx,0
jz ok
not ax
add ax,1
ok:POP BX
RET
ABSOLU ENDP
CSEG ENDS
END START
验证出入口参数都用寄存器的情况
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
DATA DW 0
BUFFER DB 8 DUP (0)
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV SI,OFFSET BUFFER
MOV AX,DATA
CALL BTOASC
MOV AX,4C00H
INT 21H
ABSOLU PROC
PUSH BX
mov bx,ax
and bx,8000h
cmp bx,0
jz ok
not ax
add ax,1
ok:POP BX
RET
ABSOLU ENDP
DTOC PROC
push dx
push cx
push bx
push ax
push si
push di
mov di,0
divide:mov cx,dx
jcxz finish_s
divide_s:mov cx,0AH
call divdw
inc di
push cx
jmp divide
finish_s:mov cx,ax
jcxz finish
jmp divide_s
finish:mov cx,di
jcxz dtoc_ok
string:pop bx
add bx,30h
mov ds:[si],bl
inc si
loop string
mov ds:[si],0
dtoc_ok:
pop di
pop si
pop ax
pop bx
pop cx
pop dx
ret
DTOC ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
BTOASC PROC
PUSH AX
PUSH SI
CMP AX,0
JL BTOASC1
JZ BTOASC3
XOR DX,DX
CALL DTOC
JMP BTOASC2
BTOASC3:mov byte ptr ds:[si],'0'
INC SI
mov byte ptr ds:[si],0
JMP BTOASC2
BTOASC1:CALL ABSOLU
mov byte ptr ds:[si],'-'
INC SI
XOR DX,DX
CALL DTOC
BTOASC2:POP SI
POP AX
RET
BTOASC ENDP
CSEG ENDS
END START
过程SUBA是近过程，堆栈由主程序平衡。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
DATA DW 0
BUFFER DB 8 DUP (0)
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
PUSH AX
MOV AX,OFFSET BUFFER
PUSH AX
PUSH DATA
CALL BTOASC
ADD SP,6
MOV AX,4C00H
INT 21H
ABSOLU PROC
PUSH BX
mov bx,ax
and bx,8000h
cmp bx,0
jz ok
not ax
add ax,1
ok:POP BX
RET
ABSOLU ENDP
DTOC PROC
push dx
push cx
push bx
push ax
push si
push di
mov di,0
divide:mov cx,dx
jcxz finish_s
divide_s:mov cx,0AH
call divdw
inc di
push cx
jmp divide
finish_s:mov cx,ax
jcxz finish
jmp divide_s
finish:mov cx,di
jcxz dtoc_ok
string:pop bx
add bx,30h
mov ds:[si],bl
inc si
loop string
mov ds:[si],0
dtoc_ok:
pop di
pop si
pop ax
pop bx
pop cx
pop dx
ret
DTOC ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
BTOASC PROC
PUSH BP
MOV BP,SP
PUSH DS
PUSH SI
MOV DS,[BP+8]
MOV SI,[BP+6]
PUSH AX
MOV AX,[BP+4]
PUSH SI
CMP AX,0
JL BTOASC1
JZ BTOASC3
XOR DX,DX
CALL DTOC
JMP BTOASC2
BTOASC3:mov byte ptr ds:[si],'0'
INC SI
mov byte ptr ds:[si],0
JMP BTOASC2
BTOASC1:CALL ABSOLU
mov byte ptr ds:[si],'-'
INC SI
XOR DX,DX
CALL DTOC
BTOASC2:POP SI
POP AX
POP SI
POP DS
POP BP
RET
BTOASC ENDP
CSEG ENDS
END START
过程SUBB是近过程，堆栈由子程序平衡。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
DATA DW 0
BUFFER DB 8 DUP (0)
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
PUSH AX
MOV AX,OFFSET BUFFER
PUSH AX
PUSH DATA
CALL BTOASC
MOV AX,4C00H
INT 21H
ABSOLU PROC
PUSH BX
mov bx,ax
and bx,8000h
cmp bx,0
jz ok
not ax
add ax,1
ok:POP BX
RET
ABSOLU ENDP
DTOC PROC
push dx
push cx
push bx
push ax
push si
push di
mov di,0
divide:mov cx,dx
jcxz finish_s
divide_s:mov cx,0AH
call divdw
inc di
push cx
jmp divide
finish_s:mov cx,ax
jcxz finish
jmp divide_s
finish:mov cx,di
jcxz dtoc_ok
string:pop bx
add bx,30h
mov ds:[si],bl
inc si
loop string
mov ds:[si],0
dtoc_ok:
pop di
pop si
pop ax
pop bx
pop cx
pop dx
ret
DTOC ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
BTOASC PROC
PUSH BP
MOV BP,SP
PUSH DS
PUSH SI
MOV DS,[BP+8]
MOV SI,[BP+6]
PUSH AX
MOV AX,[BP+4]
PUSH SI
CMP AX,0
JL BTOASC1
JZ BTOASC3
XOR DX,DX
CALL DTOC
JMP BTOASC2
BTOASC3:mov byte ptr ds:[si],'0'
INC SI
mov byte ptr ds:[si],0
JMP BTOASC2
BTOASC1:CALL ABSOLU
mov byte ptr ds:[si],'-'
INC SI
XOR DX,DX
CALL DTOC
BTOASC2:POP SI
POP AX
POP SI
POP DS
POP BP
RET 6
BTOASC ENDP
CSEG ENDS
END START
过程SUBC是远过程，堆栈由主程序平衡。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
DATA DW 32767
BUFFER DB 8 DUP (0)
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
PUSH AX
MOV AX,OFFSET BUFFER
PUSH AX
PUSH DATA
CALL FAR PTR BTOASC
ADD SP,6
MOV AX,4C00H
INT 21H
ABSOLU PROC
PUSH BX
mov bx,ax
and bx,8000h
cmp bx,0
jz ok
not ax
add ax,1
ok:POP BX
RET
ABSOLU ENDP
DTOC PROC
push dx
push cx
push bx
push ax
push si
push di
mov di,0
divide:mov cx,dx
jcxz finish_s
divide_s:mov cx,0AH
call divdw
inc di
push cx
jmp divide
finish_s:mov cx,ax
jcxz finish
jmp divide_s
finish:mov cx,di
jcxz dtoc_ok
string:pop bx
add bx,30h
mov ds:[si],bl
inc si
loop string
mov ds:[si],0
dtoc_ok:
pop di
pop si
pop ax
pop bx
pop cx
pop dx
ret
DTOC ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
BTOASC PROC FAR
PUSH BP
MOV BP,SP
PUSH DS
PUSH SI
MOV DS,[BP+10]
MOV SI,[BP+8]
PUSH AX
MOV AX,[BP+6]
PUSH SI
CMP AX,0
JL BTOASC1
JZ BTOASC3
XOR DX,DX
CALL DTOC
JMP BTOASC2
BTOASC3:mov byte ptr ds:[si],'0'
INC SI
mov byte ptr ds:[si],0
JMP BTOASC2
BTOASC1:CALL ABSOLU
mov byte ptr ds:[si],'-'
INC SI
XOR DX,DX
CALL DTOC
BTOASC2:POP SI
POP AX
POP SI
POP DS
POP BP
RETF
BTOASC ENDP
CSEG ENDS
END START
过程SUBD是远过程，堆栈由子程序平衡。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
DATA DW 32767
BUFFER DB 8 DUP (0)
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
PUSH AX
MOV AX,OFFSET BUFFER
PUSH AX
PUSH DATA
CALL FAR PTR BTOASC
MOV AX,4C00H
INT 21H
ABSOLU PROC
PUSH BX
mov bx,ax
and bx,8000h
cmp bx,0
jz ok
not ax
add ax,1
ok:POP BX
RET
ABSOLU ENDP
DTOC PROC
push dx
push cx
push bx
push ax
push si
push di
mov di,0
divide:mov cx,dx
jcxz finish_s
divide_s:mov cx,0AH
call divdw
inc di
push cx
jmp divide
finish_s:mov cx,ax
jcxz finish
jmp divide_s
finish:mov cx,di
jcxz dtoc_ok
string:pop bx
add bx,30h
mov ds:[si],bl
inc si
loop string
mov ds:[si],0
dtoc_ok:
pop di
pop si
pop ax
pop bx
pop cx
pop dx
ret
DTOC ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
BTOASC PROC FAR
PUSH BP
MOV BP,SP
PUSH DS
PUSH SI
MOV DS,[BP+10]
MOV SI,[BP+8]
PUSH AX
MOV AX,[BP+6]
PUSH SI
CMP AX,0
JL BTOASC1
JZ BTOASC3
XOR DX,DX
CALL DTOC
JMP BTOASC2
BTOASC3:mov byte ptr ds:[si],'0'
INC SI
mov byte ptr ds:[si],0
JMP BTOASC2
BTOASC1:CALL ABSOLU
mov byte ptr ds:[si],'-'
INC SI
XOR DX,DX
CALL DTOC
BTOASC2:POP SI
POP AX
POP SI
POP DS
POP BP
RETF 6
BTOASC ENDP
CSEG ENDS
END START
验证补码形式表示的32位二进制负数求对应绝对值的子程序
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG
START:MOV AX,0FFFFH
MOV DX,0FFFEH
CALL ABSOLU
MOV AH,4CH
INT 21H
ABSOLU PROC
PUSH BX
mov bx,dx
and bx,8000h
cmp bx,0
jz absolu_ok
not dx
not ax
add ax,1
adc dx,0
absolu_ok:POP BX
RET
ABSOLU ENDP
CSEG ENDS
END START
验证出入口参数都用寄存器的情况
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
BUFFER DB 16 DUP (0)
DATA DD 123456789
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV SI,OFFSET BUFFER
MOV AX,WORD PTR DATA
MOV DX,WORD PTR DATA+2
CALL BTOASC
MOV AX,4C00H
INT 21H
ABSOLU PROC
PUSH BX
mov bx,dx
and bx,8000h
cmp bx,0
jz absolu_ok
not dx
not ax
add ax,1
adc dx,0
absolu_ok:POP BX
RET
ABSOLU ENDP
DTOC PROC
push dx
push cx
push bx
push ax
push si
push di
mov di,0
divide:mov cx,dx
jcxz finish_s
divide_s:mov cx,0AH
call divdw
inc di
push cx
jmp divide
finish_s:mov cx,ax
jcxz finish
jmp divide_s
finish:mov cx,di
jcxz dtoc_ok
string:pop bx
add bx,30h
mov ds:[si],bl
inc si
loop string
mov ds:[si],0
dtoc_ok:
pop di
pop si
pop ax
pop bx
pop cx
pop dx
ret
DTOC ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
BTOASC PROC
PUSH AX
PUSH DX
PUSH SI
CMP DX,0
JL BTOASC1
JZ BTOASC3
BTOASC4:CALL DTOC
JMP BTOASC2
BTOASC3:CMP AX,0
JNZ BTOASC4
mov byte ptr ds:[si],'0'
INC SI
mov byte ptr ds:[si],0
JMP BTOASC2
BTOASC1:CALL ABSOLU
mov byte ptr ds:[si],'-'
INC SI
CALL DTOC
BTOASC2:POP SI
POP DX
POP AX
RET
BTOASC ENDP
CSEG ENDS
END START
过程SUBA是近过程，堆栈由主程序平衡。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
BUFFER DB 16 DUP (0)
DATA DD 123456789
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
PUSH AX
MOV AX,OFFSET BUFFER
PUSH AX
PUSH WORD PTR DATA
PUSH WORD PTR DATA+2
CALL BTOASC
ADD SP,8
MOV AX,4C00H
INT 21H
ABSOLU PROC
PUSH BX
mov bx,dx
and bx,8000h
cmp bx,0
jz absolu_ok
not dx
not ax
add ax,1
adc dx,0
absolu_ok:POP BX
RET
ABSOLU ENDP
DTOC PROC
push dx
push cx
push bx
push ax
push si
push di
mov di,0
divide:mov cx,dx
jcxz finish_s
divide_s:mov cx,0AH
call divdw
inc di
push cx
jmp divide
finish_s:mov cx,ax
jcxz finish
jmp divide_s
finish:mov cx,di
jcxz dtoc_ok
string:pop bx
add bx,30h
mov ds:[si],bl
inc si
loop string
mov ds:[si],0
dtoc_ok:
pop di
pop si
pop ax
pop bx
pop cx
pop dx
ret
DTOC ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
BTOASC PROC
PUSH BP
MOV BP,SP
PUSH DS
PUSH SI
MOV DS,[BP+10]
MOV SI,[BP+8]
PUSH AX
MOV AX,[BP+6]
PUSH DX
MOV DX,[BP+4]
PUSH SI
CMP DX,0
JL BTOASC1
JZ BTOASC3
BTOASC4:CALL DTOC
JMP BTOASC2
BTOASC3:CMP AX,0
JNZ BTOASC4
mov byte ptr ds:[si],'0'
INC SI
mov byte ptr ds:[si],0
JMP BTOASC2
BTOASC1:CALL ABSOLU
mov byte ptr ds:[si],'-'
INC SI
CALL DTOC
BTOASC2:POP SI
POP DX
POP AX
POP SI
POP DS
POP BP
RET
BTOASC ENDP
CSEG ENDS
END START
过程SUBB是近过程，堆栈由子程序平衡。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
BUFFER DB 16 DUP (0)
DATA DD 123456789
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
PUSH AX
MOV AX,OFFSET BUFFER
PUSH AX
PUSH WORD PTR DATA
PUSH WORD PTR DATA+2
CALL BTOASC
MOV AX,4C00H
INT 21H
ABSOLU PROC
PUSH BX
mov bx,dx
and bx,8000h
cmp bx,0
jz absolu_ok
not dx
not ax
add ax,1
adc dx,0
absolu_ok:POP BX
RET
ABSOLU ENDP
DTOC PROC
push dx
push cx
push bx
push ax
push si
push di
mov di,0
divide:mov cx,dx
jcxz finish_s
divide_s:mov cx,0AH
call divdw
inc di
push cx
jmp divide
finish_s:mov cx,ax
jcxz finish
jmp divide_s
finish:mov cx,di
jcxz dtoc_ok
string:pop bx
add bx,30h
mov ds:[si],bl
inc si
loop string
mov ds:[si],0
dtoc_ok:
pop di
pop si
pop ax
pop bx
pop cx
pop dx
ret
DTOC ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
BTOASC PROC
PUSH BP
MOV BP,SP
PUSH DS
PUSH SI
MOV DS,[BP+10]
MOV SI,[BP+8]
PUSH AX
MOV AX,[BP+6]
PUSH DX
MOV DX,[BP+4]
PUSH SI
CMP DX,0
JL BTOASC1
JZ BTOASC3
BTOASC4:CALL DTOC
JMP BTOASC2
BTOASC3:CMP AX,0
JNZ BTOASC4
mov byte ptr ds:[si],'0'
INC SI
mov byte ptr ds:[si],0
JMP BTOASC2
BTOASC1:CALL ABSOLU
mov byte ptr ds:[si],'-'
INC SI
CALL DTOC
BTOASC2:POP SI
POP DX
POP AX
POP SI
POP DS
POP BP
RET 8
BTOASC ENDP
CSEG ENDS
END START
过程SUBC是远过程，堆栈由主程序平衡。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
BUFFER DB 16 DUP (0)
DATA DD 123456789
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
PUSH AX
MOV AX,OFFSET BUFFER
PUSH AX
PUSH WORD PTR DATA
PUSH WORD PTR DATA+2
CALL FAR PTR BTOASC
ADD SP,8
MOV AX,4C00H
INT 21H
ABSOLU PROC
PUSH BX
mov bx,dx
and bx,8000h
cmp bx,0
jz absolu_ok
not dx
not ax
add ax,1
adc dx,0
absolu_ok:POP BX
RET
ABSOLU ENDP
DTOC PROC
push dx
push cx
push bx
push ax
push si
push di
mov di,0
divide:mov cx,dx
jcxz finish_s
divide_s:mov cx,0AH
call divdw
inc di
push cx
jmp divide
finish_s:mov cx,ax
jcxz finish
jmp divide_s
finish:mov cx,di
jcxz dtoc_ok
string:pop bx
add bx,30h
mov ds:[si],bl
inc si
loop string
mov ds:[si],0
dtoc_ok:
pop di
pop si
pop ax
pop bx
pop cx
pop dx
ret
DTOC ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
BTOASC PROC FAR
PUSH BP
MOV BP,SP
PUSH DS
PUSH SI
MOV DS,[BP+12]
MOV SI,[BP+10]
PUSH AX
MOV AX,[BP+8]
PUSH DX
MOV DX,[BP+6]
PUSH SI
CMP DX,0
JL BTOASC1
JZ BTOASC3
BTOASC4:CALL DTOC
JMP BTOASC2
BTOASC3:CMP AX,0
JNZ BTOASC4
mov byte ptr ds:[si],'0'
INC SI
mov byte ptr ds:[si],0
JMP BTOASC2
BTOASC1:CALL ABSOLU
mov byte ptr ds:[si],'-'
INC SI
CALL DTOC
BTOASC2:POP SI
POP DX
POP AX
POP SI
POP DS
POP BP
RETF
BTOASC ENDP
CSEG ENDS
END START
过程SUBD是远过程，堆栈由子程序平衡。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
BUFFER DB 16 DUP (0)
DATA DD 123456789
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
PUSH AX
MOV AX,OFFSET BUFFER
PUSH AX
PUSH WORD PTR DATA
PUSH WORD PTR DATA+2
CALL FAR PTR BTOASC
MOV AX,4C00H
INT 21H
ABSOLU PROC
PUSH BX
mov bx,dx
and bx,8000h
cmp bx,0
jz absolu_ok
not dx
not ax
add ax,1
adc dx,0
absolu_ok:POP BX
RET
ABSOLU ENDP
DTOC PROC
push dx
push cx
push bx
push ax
push si
push di
mov di,0
divide:mov cx,dx
jcxz finish_s
divide_s:mov cx,0AH
call divdw
inc di
push cx
jmp divide
finish_s:mov cx,ax
jcxz finish
jmp divide_s
finish:mov cx,di
jcxz dtoc_ok
string:pop bx
add bx,30h
mov ds:[si],bl
inc si
loop string
mov ds:[si],0
dtoc_ok:
pop di
pop si
pop ax
pop bx
pop cx
pop dx
ret
DTOC ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
BTOASC PROC FAR
PUSH BP
MOV BP,SP
PUSH DS
PUSH SI
MOV DS,[BP+12]
MOV SI,[BP+10]
PUSH AX
MOV AX,[BP+8]
PUSH DX
MOV DX,[BP+6]
PUSH SI
CMP DX,0
JL BTOASC1
JZ BTOASC3
BTOASC4:CALL DTOC
JMP BTOASC2
BTOASC3:CMP AX,0
JNZ BTOASC4
mov byte ptr ds:[si],'0'
INC SI
mov byte ptr ds:[si],0
JMP BTOASC2
BTOASC1:CALL ABSOLU
mov byte ptr ds:[si],'-'
INC SI
CALL DTOC
BTOASC2:POP SI
POP DX
POP AX
POP SI
POP DS
POP BP
RETF 8
BTOASC ENDP
CSEG ENDS
END START
题4.15编写具有如下功能的子程序：把32位无符号二进制数转换为对应十进制数ASCII码串。
作为入口参数的指示存放ASCII码串缓冲区首地址由段值和偏移两部分构成，其他具体要求与习题4.14相同。
过程SUBA是近过程，堆栈由主程序平衡。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
BUFFER DB 16 DUP (0)
DATA DD 123456789
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
PUSH AX
MOV AX,OFFSET BUFFER
PUSH AX
PUSH WORD PTR DATA
PUSH WORD PTR DATA+2
CALL BTOASC
ADD SP,8
MOV AX,4C00H
INT 21H
ABSOLU PROC
PUSH BX
mov bx,dx
and bx,8000h
cmp bx,0
jz absolu_ok
not dx
not ax
add ax,1
adc dx,0
absolu_ok:POP BX
RET
ABSOLU ENDP
DTOC PROC
push dx
push cx
push bx
push ax
push si
push di
mov di,0
divide:mov cx,dx
jcxz finish_s
divide_s:mov cx,0AH
call divdw
inc di
push cx
jmp divide
finish_s:mov cx,ax
jcxz finish
jmp divide_s
finish:mov cx,di
jcxz dtoc_ok
string:pop bx
add bx,30h
mov ds:[si],bl
inc si
loop string
mov ds:[si],0
dtoc_ok:
pop di
pop si
pop ax
pop bx
pop cx
pop dx
ret
DTOC ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
BTOASC PROC
PUSH BP
MOV BP,SP
PUSH DS
PUSH SI
MOV DS,[BP+10]
MOV SI,[BP+8]
PUSH AX
MOV AX,[BP+6]
PUSH DX
MOV DX,[BP+4]
PUSH SI
CMP DX,0
JZ BTOASC3
BTOASC4:CALL DTOC
JMP BTOASC2
BTOASC3:CMP AX,0
JNZ BTOASC4
mov byte ptr ds:[si],'0'
INC SI
mov byte ptr ds:[si],0
BTOASC2:POP SI
POP DX
POP AX
POP SI
POP DS
POP BP
RET
BTOASC ENDP
CSEG ENDS
END START
过程SUBB是近过程，堆栈由子程序平衡。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
BUFFER DB 16 DUP (0)
DATA DD 3123456789
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
PUSH AX
MOV AX,OFFSET BUFFER
PUSH AX
PUSH WORD PTR DATA
PUSH WORD PTR DATA+2
CALL BTOASC
MOV AX,4C00H
INT 21H
ABSOLU PROC
PUSH BX
mov bx,dx
and bx,8000h
cmp bx,0
jz absolu_ok
not dx
not ax
add ax,1
adc dx,0
absolu_ok:POP BX
RET
ABSOLU ENDP
DTOC PROC
push dx
push cx
push bx
push ax
push si
push di
mov di,0
divide:mov cx,dx
jcxz finish_s
divide_s:mov cx,0AH
call divdw
inc di
push cx
jmp divide
finish_s:mov cx,ax
jcxz finish
jmp divide_s
finish:mov cx,di
jcxz dtoc_ok
string:pop bx
add bx,30h
mov ds:[si],bl
inc si
loop string
mov ds:[si],0
dtoc_ok:
pop di
pop si
pop ax
pop bx
pop cx
pop dx
ret
DTOC ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
BTOASC PROC
PUSH BP
MOV BP,SP
PUSH DS
PUSH SI
MOV DS,[BP+10]
MOV SI,[BP+8]
PUSH AX
MOV AX,[BP+6]
PUSH DX
MOV DX,[BP+4]
PUSH SI
CMP DX,0
JZ BTOASC3
BTOASC4:CALL DTOC
JMP BTOASC2
BTOASC3:CMP AX,0
JNZ BTOASC4
mov byte ptr ds:[si],'0'
INC SI
mov byte ptr ds:[si],0
BTOASC2:POP SI
POP DX
POP AX
POP SI
POP DS
POP BP
RET 8
BTOASC ENDP
CSEG ENDS
END START
过程SUBC是远过程，堆栈由主程序平衡。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
BUFFER DB 16 DUP (0)
DATA DD 3123456789
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
PUSH AX
MOV AX,OFFSET BUFFER
PUSH AX
PUSH WORD PTR DATA
PUSH WORD PTR DATA+2
CALL FAR PTR BTOASC
ADD SP,8
MOV AX,4C00H
INT 21H
ABSOLU PROC
PUSH BX
mov bx,dx
and bx,8000h
cmp bx,0
jz absolu_ok
not dx
not ax
add ax,1
adc dx,0
absolu_ok:POP BX
RET
ABSOLU ENDP
DTOC PROC
push dx
push cx
push bx
push ax
push si
push di
mov di,0
divide:mov cx,dx
jcxz finish_s
divide_s:mov cx,0AH
call divdw
inc di
push cx
jmp divide
finish_s:mov cx,ax
jcxz finish
jmp divide_s
finish:mov cx,di
jcxz dtoc_ok
string:pop bx
add bx,30h
mov ds:[si],bl
inc si
loop string
mov ds:[si],0
dtoc_ok:
pop di
pop si
pop ax
pop bx
pop cx
pop dx
ret
DTOC ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
BTOASC PROC FAR
PUSH BP
MOV BP,SP
PUSH DS
PUSH SI
MOV DS,[BP+12]
MOV SI,[BP+10]
PUSH AX
MOV AX,[BP+8]
PUSH DX
MOV DX,[BP+6]
PUSH SI
CMP DX,0
JZ BTOASC3
BTOASC4:CALL DTOC
JMP BTOASC2
BTOASC3:CMP AX,0
JNZ BTOASC4
mov byte ptr ds:[si],'0'
INC SI
mov byte ptr ds:[si],0
BTOASC2:POP SI
POP DX
POP AX
POP SI
POP DS
POP BP
RETF
BTOASC ENDP
CSEG ENDS
END START
过程SUBD是远过程，堆栈由子程序平衡。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
BUFFER DB 16 DUP (0)
DATA DD 3123456789
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
PUSH AX
MOV AX,OFFSET BUFFER
PUSH AX
PUSH WORD PTR DATA
PUSH WORD PTR DATA+2
CALL FAR PTR BTOASC
MOV AX,4C00H
INT 21H
ABSOLU PROC
PUSH BX
mov bx,dx
and bx,8000h
cmp bx,0
jz absolu_ok
not dx
not ax
add ax,1
adc dx,0
absolu_ok:POP BX
RET
ABSOLU ENDP
DTOC PROC
push dx
push cx
push bx
push ax
push si
push di
mov di,0
divide:mov cx,dx
jcxz finish_s
divide_s:mov cx,0AH
call divdw
inc di
push cx
jmp divide
finish_s:mov cx,ax
jcxz finish
jmp divide_s
finish:mov cx,di
jcxz dtoc_ok
string:pop bx
add bx,30h
mov ds:[si],bl
inc si
loop string
mov ds:[si],0
dtoc_ok:
pop di
pop si
pop ax
pop bx
pop cx
pop dx
ret
DTOC ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
BTOASC PROC FAR
PUSH BP
MOV BP,SP
PUSH DS
PUSH SI
MOV DS,[BP+12]
MOV SI,[BP+10]
PUSH AX
MOV AX,[BP+8]
PUSH DX
MOV DX,[BP+6]
PUSH SI
CMP DX,0
JZ BTOASC3
BTOASC4:CALL DTOC
JMP BTOASC2
BTOASC3:CMP AX,0
JNZ BTOASC4
mov byte ptr ds:[si],'0'
INC SI
mov byte ptr ds:[si],0
BTOASC2:POP SI
POP DX
POP AX
POP SI
POP DS
POP BP
RETF 8
BTOASC ENDP
CSEG ENDS
END START
题4.16写一个程序在屏幕上依次循环显示10个数字符号，每行显示13个。最初所显示的两行如下所示：
0 1 2 3 4 5 6 7 8 9 0 1 2
3 4 5 6 7 8 9 0 1 2 3 4 5
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
M EQU 13
N EQU 13
CSEG SEGMENT
ASSUME CS:CSEG
START:MOV BX,0
MOV SI,1
FORI:MOV DI,1
FORJ:MOV AX,BX
MOV CL,0AH
DIV CL
XCHG AH,AL
CALL HTOASC
CALL PUTCH
INC BX
INC DI
CMP DI,N
JA FINISHJ
MOV AL,20H
CALL PUTCH
JMP FORJ
FINISHJ:CALL NEWLINE
INC SI
CMP SI,M
JBE FORI
MOV AH,4CH
INT 21H
HTOASC PROC
JMP HTOASC1
table db '0123456789ABCDEF'
HTOASC1:PUSH BX
AND AL,0FH
MOV BL,AL
MOV BH,0
MOV AL,table[BX]
POP BX
RET
HTOASC ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
CSEG ENDS
END START
添加DELAY子程序之后
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
M EQU 13
N EQU 13
CSEG SEGMENT
ASSUME CS:CSEG
START:MOV BX,0
MOV SI,1
FORI:MOV DI,1
FORJ:MOV AX,BX
MOV CL,0AH
DIV CL
XCHG AH,AL
CALL HTOASC
CALL PUTCH
INC BX
INC DI
push dx
mov dx,5000h
call delay
pop dx
CMP DI,N
JA FINISHJ
MOV AL,20H
CALL PUTCH
JMP FORJ
FINISHJ:CALL NEWLINE
INC SI
CMP SI,M
JBE FORI
MOV AH,4CH
INT 21H
HTOASC PROC
JMP HTOASC1
table db '0123456789ABCDEF'
HTOASC1:PUSH BX
AND AL,0FH
MOV BL,AL
MOV BH,0
MOV AL,table[BX]
POP BX
RET
HTOASC ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DELAY PROC
push ax
push dx
mov ax,0
delay_s:sub ax,1
sbb dx,0
cmp ax,0
jne delay_s
cmp dx,0
jne delay_s
pop dx
pop ax
ret
DELAY ENDP
CSEG ENDS
END START
题4.17写一个程序实现习题4.16的功能，但在按回车键时，结束程序。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
M EQU 13
N EQU 13
CR = 0DH
LF = 0AH
CSEG SEGMENT
ASSUME CS:CSEG
START:MOV AX,0C00H
INT 21H
MOV BX,0
MOV SI,1
FORI:MOV DI,1
FORJ:MOV AX,BX
MOV CL,0AH
DIV CL
XCHG AH,AL
CALL HTOASC
CALL PUTCH
INC BX
INC DI
push dx
mov dx,5000h
call delay
pop dx
MOV AH,06H
MOV DL,0FFH
INT 21H
JZ NEXTJ
CMP AL,CR
JZ FINISHI
MOV AX,0C00H
INT 21H
NEXTJ:CMP DI,N
JA FINISHJ
MOV AL,20H
CALL PUTCH
JMP FORJ
FINISHJ:CALL NEWLINE
INC SI
CMP SI,M
JBE FORI
FINISHI:MOV AH,4CH
INT 21H
HTOASC PROC
JMP HTOASC1
table db '0123456789ABCDEF'
HTOASC1:PUSH BX
AND AL,0FH
MOV BL,AL
MOV BH,0
MOV AL,table[BX]
POP BX
RET
HTOASC ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DELAY PROC
push ax
push dx
mov ax,0
delay_s:sub ax,1
sbb dx,0
cmp ax,0
jne delay_s
cmp dx,0
jne delay_s
pop dx
pop ax
ret
DELAY ENDP
CSEG ENDS
END START
题4.18写一个程序把从键盘上接收到的小写字母用大写字母显示出来，其他字符原样显示。按回车键结束程序。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
CSEG SEGMENT
ASSUME CS:CSEG
START:CALL GETSTR
MOV AH,4CH
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
LWTOUP PROC
PUSHF
CMP AL,'a'
JB LWTOUP1
CMP AL,'z'
JA LWTOUP1
SUB AL,'a'-'A'
LWTOUP1:POPF
RET
LWTOUP ENDP
GETCH PROC
MOV AH,8
INT 21H
CALL LWTOUP
RET
GETCH ENDP
GETSTR PROC
PUSH AX
PUSH BX
MOV BX,0
GETSTR1:CALL GETCH
CMP AL,CR
JZ GETSTR5
CMP AL,BACKSPACE
JNZ GETSTR4
CMP BX,0
JZ GETSTR2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTR1
GETSTR2:CALL BELL
JMP GETSTR1
GETSTR4:CMP BX,78
JZ GETSTR2
INC BX
CALL PUTCH
JMP GETSTR1
GETSTR5:CALL NEWLINE
GETSTR_OK:
POP BX
POP AX
RET
GETSTR ENDP
CSEG ENDS
END START
题4.19写一个程序实现如下功能：先从键盘上输入一个字符串，然后再在另一行按相反顺序显示该字符串。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
DSEG SEGMENT
BUFFER DB 128 DUP (0)
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL GETSTR
CALL DISPSTR
MOV AH,4CH
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTR PROC
PUSH AX
PUSH BX
PUSH DI
MOV DI,OFFSET BUFFER
MOV WORD PTR BUFFER,0
MOV BX,0
GETSTR1:CALL GETCH
CMP AL,CR
JZ GETSTR5
CMP AL,BACKSPACE
JNZ GETSTR4
CMP BX,0
JZ GETSTR2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTR1
GETSTR2:CALL BELL
JMP GETSTR1
GETSTR4:CMP BX,78
JZ GETSTR2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTR1
GETSTR5:MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR BUFFER,BX
GETSTR_OK:
POP DI
POP BX
POP AX
RET
GETSTR ENDP
DISPSTR PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DI
MOV DI,OFFSET BUFFER
MOV BX,WORD PTR BUFFER
CMP BX,3
JB DISPSTR_OK
SUB BX,2
MOV CX,BX
DISPSTR1:DEC BX
MOV AL,[BX][DI+2]
CALL PUTCH
LOOP DISPSTR1
CALL NEWLINE
DISPSTR_OK:
POP DI
POP CX
POP BX
POP AX
RET
DISPSTR ENDP
CSEG ENDS
END START
题4.20写一个程序显示所按字符键对应的ASCII码。先用2位十六进制数显示ASCII码；再用3位八进制数显示ASCII码。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
DSEG SEGMENT
BUFFER DB 128 DUP (0)
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL GETSTR
CALL DISPSTR
MOV AH,4CH
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
HTOASC PROC
JMP HTOASC1
htable db '0123456789ABCDEF'
HTOASC1:PUSH BX
AND AL,0FH
MOV BL,AL
MOV BH,0
MOV AL,htable[BX]
POP BX
RET
HTOASC ENDP
AHTOASC PROC
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL HTOASC
XCHG AH,AL
CALL HTOASC
RET
AHTOASC ENDP
OTOASC PROC
JMP OTOASC1
otable db '01234567'
OTOASC1:PUSH BX
AND AL,07H
MOV BL,AL
MOV BH,0
MOV AL,otable[BX]
POP BX
RET
OTOASC ENDP
AOTOASC PROC
MOV AH,AL
MOV DL,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL OTOASC
XCHG DL,AL
SHR AL,1
SHR AL,1
SHR AL,1
CALL OTOASC
XCHG AH,AL
CALL OTOASC
RET
AOTOASC ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTR PROC
PUSH AX
PUSH BX
PUSH DI
MOV DI,OFFSET BUFFER
MOV WORD PTR BUFFER,0
MOV BX,0
GETSTR1:CALL GETCH
CMP AL,CR
JZ GETSTR5
CMP AL,BACKSPACE
JNZ GETSTR4
CMP BX,0
JZ GETSTR2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTR1
GETSTR2:CALL BELL
JMP GETSTR1
GETSTR4:CMP BX,18
JZ GETSTR2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTR1
GETSTR5:MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR BUFFER,BX
GETSTR_OK:
POP DI
POP BX
POP AX
RET
GETSTR ENDP
DISPSTR PROC
PUSH AX
PUSH BX
PUSH DX
PUSH SI
PUSH DI
MOV DI,OFFSET BUFFER
MOV BX,WORD PTR BUFFER
CMP BX,3
JB DISPSTR_OK
SUB BX,2
MOV SI,BX
XOR BX,BX
DISPSTR1:MOV AL,[BX][DI+2]
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
INC BX
CMP BX,SI
JAE DISPSTR2
MOV AL,20H
CALL PUTCH
JMP DISPSTR1
DISPSTR2:CALL NEWLINE
XOR BX,BX
DISPSTR3:MOV AL,[BX][DI+2]
CALL AOTOASC
PUSH AX
MOV AL,DL
CALL PUTCH
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
INC BX
CMP BX,SI
JAE DISPSTR4
MOV AL,20H
CALL PUTCH
JMP DISPSTR3
DISPSTR4:CALL NEWLINE
DISPSTR_OK:
POP DI
POP SI
POP DX
POP BX
POP AX
RET
DISPSTR ENDP
CSEG ENDS
END START
题4.21写一个程序实现如下功能：先从键盘上输入一个字符串，然后显示该字符串中非数字字符或字母字符的个数。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
DSEG SEGMENT
BUFFER DB 128 DUP (0)
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL GETSTR
CALL DISPSTR
MOV AH,4CH
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
HTOASC PROC
JMP HTOASC1
htable db '0123456789ABCDEF'
HTOASC1:PUSH BX
AND AL,0FH
MOV BL,AL
MOV BH,0
MOV AL,htable[BX]
POP BX
RET
HTOASC ENDP
AHTOASC PROC
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL HTOASC
XCHG AH,AL
CALL HTOASC
RET
AHTOASC ENDP
OTOASC PROC
JMP OTOASC1
otable db '01234567'
OTOASC1:PUSH BX
AND AL,07H
MOV BL,AL
MOV BH,0
MOV AL,otable[BX]
POP BX
RET
OTOASC ENDP
AOTOASC PROC
MOV AH,AL
MOV DL,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL OTOASC
XCHG DL,AL
SHR AL,1
SHR AL,1
SHR AL,1
CALL OTOASC
XCHG AH,AL
CALL OTOASC
RET
AOTOASC ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTR PROC
PUSH AX
PUSH BX
PUSH DI
MOV DI,OFFSET BUFFER
MOV WORD PTR BUFFER,0
MOV BX,0
GETSTR1:CALL GETCH
CMP AL,CR
JZ GETSTR5
CMP AL,BACKSPACE
JNZ GETSTR4
CMP BX,0
JZ GETSTR2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTR1
GETSTR2:CALL BELL
JMP GETSTR1
GETSTR4:CMP BX,18
JZ GETSTR2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTR1
GETSTR5:MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR BUFFER,BX
GETSTR_OK:
POP DI
POP BX
POP AX
RET
GETSTR ENDP
DISPSTR PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV DI,OFFSET BUFFER
MOV BX,WORD PTR BUFFER
CMP BX,3
JB DISPSTR_OK
SUB BX,2
MOV SI,BX
XOR BX,BX
XOR CX,CX
DISPSTR1:MOV AL,[BX][DI+2]
CMP AL,'0'
JB DISPNEXT
CMP AL,'9'
JA DISPNODEC1
INC CH
JMP DISPNEXT
DISPNODEC1:CMP AL,'A'
JB DISPNEXT
CMP AL,'Z'
JA DISPNODEC2
INC CL
JMP DISPNEXT
DISPNODEC2:CMP AL,'a'
JB DISPNEXT
CMP AL,'z'
JA DISPNEXT
INC CL
DISPNEXT:CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
INC BX
CMP BX,SI
JAE DISPSTR2
MOV AL,20H
CALL PUTCH
JMP DISPSTR1
DISPSTR2:CALL NEWLINE
XOR BX,BX
DISPSTR3:MOV AL,[BX][DI+2]
CALL AOTOASC
PUSH AX
MOV AL,DL
CALL PUTCH
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
INC BX
CMP BX,SI
JAE DISPSTR4
MOV AL,20H
CALL PUTCH
JMP DISPSTR3
DISPSTR4:CALL NEWLINE
MOV AL,CH
XOR AH,AH
XOR DX,DX
CALL BTOASC
MOV AL,20H
CALL PUTCH
MOV AL,CL
XOR AH,AH
XOR DX,DX
CALL BTOASC
CALL NEWLINE
DISPSTR_OK:
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DISPSTR ENDP
DTOC PROC
push dx
push cx
push bx
push ax
push di
mov di,0
divide:mov cx,dx
jcxz finish_s
divide_s:mov cx,0AH
call divdw
inc di
push cx
jmp divide
finish_s:mov cx,ax
jcxz finish
jmp divide_s
finish:mov cx,di
jcxz dtoc_ok
string:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string
dtoc_ok:
pop di
pop ax
pop bx
pop cx
pop dx
ret
DTOC ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
BTOASC PROC
PUSH AX
PUSH DX
CMP DX,0
JZ BTOASC3
BTOASC4:CALL DTOC
JMP BTOASC2
BTOASC3:CMP AX,0
JNZ BTOASC4
mov AL,'0'
CALL PUTCH
BTOASC2:POP DX
POP AX
RET
BTOASC ENDP
CSEG ENDS
END START
题4.22写一个程序实现如下功能：先从键盘上输入一个字符串，然后在下一行显示滤去字母符号后的字符串；
最后在另一行显示大小写字母翻转的字符串。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
DSEG SEGMENT
BUFFER DB 128 DUP (0)
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL GETSTR
CALL DISPSTR
MOV AH,4CH
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
HTOASC PROC
JMP HTOASC1
htable db '0123456789ABCDEF'
HTOASC1:PUSH BX
AND AL,0FH
MOV BL,AL
MOV BH,0
MOV AL,htable[BX]
POP BX
RET
HTOASC ENDP
AHTOASC PROC
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL HTOASC
XCHG AH,AL
CALL HTOASC
RET
AHTOASC ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTR PROC
PUSH AX
PUSH BX
PUSH DI
MOV DI,OFFSET BUFFER
MOV WORD PTR BUFFER,0
MOV BX,0
GETSTR1:CALL GETCH
CMP AL,CR
JZ GETSTR5
CMP AL,BACKSPACE
JNZ GETSTR4
CMP BX,0
JZ GETSTR2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTR1
GETSTR2:CALL BELL
JMP GETSTR1
GETSTR4:CMP BX,26
JZ GETSTR2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTR1
GETSTR5:MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR BUFFER,BX
GETSTR_OK:
POP DI
POP BX
POP AX
RET
GETSTR ENDP
DISPSTR PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV DI,OFFSET BUFFER
MOV BX,WORD PTR BUFFER
CMP BX,3
JB DISPSTR_OK
SUB BX,2
MOV SI,BX
XOR BX,BX
XOR CX,CX
DISPSTR1:MOV AL,[BX][DI+2]
CMP AL,'0'
JB DISPNEXT
CMP AL,'9'
JA DISPNODEC1
INC CH
JMP DISPNEXT
DISPNODEC1:CMP AL,'A'
JB DISPNEXT
CMP AL,'Z'
JA DISPNODEC2
INC CL
JMP DISPNEXT
DISPNODEC2:CMP AL,'a'
JB DISPNEXT
CMP AL,'z'
JA DISPNEXT
INC CL
DISPNEXT:CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
INC BX
CMP BX,SI
JAE DISPSTR2
MOV AL,20H
CALL PUTCH
JMP DISPSTR1
DISPSTR2:CALL NEWLINE
XOR BX,BX
DISPSTR3:MOV AL,[BX][DI+2]
CMP AL,'A'
JB DISPNEXT3
CMP AL,'Z'
JA DISPNODEC3
MOV AL,20H
JMP DISPNEXT3
DISPNODEC3:CMP AL,'a'
JB DISPNEXT3
CMP AL,'z'
JA DISPNEXT3
MOV AL,20H
DISPNEXT3:CALL PUTCH
INC BX
CMP BX,SI
JAE DISPSTR4
MOV AL,20H
CALL PUTCH
JMP DISPSTR3
DISPSTR4:CALL NEWLINE
XOR BX,BX
DISPSTR5:MOV AL,[BX][DI+2]
CMP AL,'A'
JB DISPNEXT5
CMP AL,'Z'
JA DISPNODEC5
ADD AL,20H
JMP DISPNEXT5
DISPNODEC5:CMP AL,'a'
JB DISPNEXT5
CMP AL,'z'
JA DISPNEXT5
SUB AL,20H
DISPNEXT5:CALL PUTCH
INC BX
CMP BX,SI
JAE DISPSTR6
MOV AL,20H
CALL PUTCH
JMP DISPSTR5
DISPSTR6:CALL NEWLINE
MOV AL,CH
XOR AH,AH
XOR DX,DX
CALL BTOASC
MOV AL,20H
CALL PUTCH
MOV AL,CL
XOR AH,AH
XOR DX,DX
CALL BTOASC
CALL NEWLINE
DISPSTR_OK:
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DISPSTR ENDP
DTOC PROC
push dx
push cx
push bx
push ax
push di
mov di,0
divide:mov cx,dx
jcxz finish_s
divide_s:mov cx,0AH
call divdw
inc di
push cx
jmp divide
finish_s:mov cx,ax
jcxz finish
jmp divide_s
finish:mov cx,di
jcxz dtoc_ok
string:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string
dtoc_ok:
pop di
pop ax
pop bx
pop cx
pop dx
ret
DTOC ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
BTOASC PROC
PUSH AX
PUSH DX
CMP DX,0
JZ BTOASC3
BTOASC4:CALL DTOC
JMP BTOASC2
BTOASC3:CMP AX,0
JNZ BTOASC4
mov AL,'0'
CALL PUTCH
BTOASC2:POP DX
POP AX
RET
BTOASC ENDP
CSEG ENDS
END START
题4.23写一个程序实现如下功能：先从键盘上输入一个较长的字符串和一个较短的字符串，
然后判断较短的字符串是否是较长字符串的子串，最后显示提示信息说明判断结果。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
DSEG SEGMENT
BUFFER1 DB 128 DUP (0)
BUFFER2 DB 128 DUP (0)
ARRAY DB 128 DUP (0)
MESS DB 'Can not find string','$'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DI,OFFSET BUFFER1
CALL GETSTR
MOV DI,OFFSET BUFFER2
CALL GETSTR
MOV SI,OFFSET BUFFER1
MOV DI,OFFSET BUFFER2
CALL FINDSTR
CALL DISPSTR
MOV AH,4CH
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTR PROC
PUSH AX
PUSH BX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTR1:CALL GETCH
CMP AL,CR
JZ GETSTR5
CMP AL,BACKSPACE
JNZ GETSTR4
CMP BX,0
JZ GETSTR2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTR1
GETSTR2:CALL BELL
JMP GETSTR1
GETSTR4:CMP BX,78
JZ GETSTR2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTR1
GETSTR5:MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTR_OK:
POP DI
POP BX
POP AX
RET
GETSTR ENDP
FINDSTR PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV AX,0
MOV WORD PTR ARRAY,AX
MOV AX,WORD PTR [SI]
MOV BX,WORD PTR [DI]
CMP AX,3
JB FINDSTR_OK2
CMP BX,3
JB FINDSTR_OK2
CMP AX,BX
JB FINDSTR_OK2
SUB AX,2
SUB BX,2
PUSH AX
PUSH BX
SUB AX,BX
ADD AX,SI
PUSH AX
PUSH BP
MOV BP,SP
SUB SP,4
MOV WORD PTR [BP-2],0
MOV WORD PTR [BP-4],SI
FORI:MOV AX,WORD PTR [BP-4]
CMP AX,WORD PTR [BP+2]
JA FINDSTR1
MOV CX,WORD PTR [BP+4]
MOV DI,WORD PTR [BP+8]
MOV SI,WORD PTR [BP-4]
FORJ:MOV AL,[DI+2]
CMP [SI+2],AL
JNZ NEXTI
NEXTJ:INC DI
INC SI
LOOP FORJ
MOV AX,WORD PTR [BP-4]
SUB AX,WORD PTR [BP+10]
MOV BX,WORD PTR [BP-2]
MOV BYTE PTR ARRAY[BX+2],AL
INC WORD PTR [BP-2]
NEXTI:INC WORD PTR [BP-4]
JMP FORI
FINDSTR1:MOV BX,WORD PTR [BP-2]
MOV AL,CR
MOV BYTE PTR ARRAY[BX+2],AL
INC BX
MOV AL,LF
MOV BYTE PTR ARRAY[BX+2],AL
INC BX
MOV WORD PTR ARRAY,BX
FINDSTR_OK1:MOV SP,BP
POP BP
POP AX
POP BX
POP AX
FINDSTR_OK2:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
FINDSTR ENDP
DISPSTR PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV DI,OFFSET ARRAY
MOV BX,WORD PTR ARRAY
CMP BX,2
JB DISPSTR_OK
JA DISPSTR_A
MOV DX,OFFSET MESS
CALL DISPMESS
CALL NEWLINE
JMP DISPSTR_OK
DISPSTR_A:SUB BX,2
MOV SI,BX
XOR BX,BX
DISPSTR1:MOV AL,[BX][DI+2]
XOR AH,AH
XOR DX,DX
CALL BTOASC
INC BX
CMP BX,SI
JAE DISPSTR2
MOV AL,20H
CALL PUTCH
JMP DISPSTR1
DISPSTR2:CALL NEWLINE
DISPSTR_OK:
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DISPSTR ENDP
DTOC PROC
push dx
push cx
push bx
push ax
push di
mov di,0
divide:mov cx,dx
jcxz finish_s
divide_s:mov cx,0AH
call divdw
inc di
push cx
jmp divide
finish_s:mov cx,ax
jcxz finish
jmp divide_s
finish:mov cx,di
jcxz dtoc_ok
string:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string
dtoc_ok:
pop di
pop ax
pop bx
pop cx
pop dx
ret
DTOC ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
BTOASC PROC
PUSH AX
PUSH DX
CMP DX,0
JZ BTOASC3
BTOASC4:CALL DTOC
JMP BTOASC2
BTOASC3:CMP AX,0
JNZ BTOASC4
mov AL,'0'
CALL PUTCH
BTOASC2:POP DX
POP AX
RET
BTOASC ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
CSEG ENDS
END START
题4.24设A1=0，A2=1，当n>=3时，An=An-1+3*An-2。请编写一个求An的子程序，要求采用递归算法。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG
START:MOV AX,9
XOR DX,DX
CALL CALCUL
CALL BTOASC
CALL NEWLINE
MOV AH,4CH
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DTOC PROC
push dx
push cx
push bx
push ax
push di
mov di,0
divide:mov cx,dx
jcxz finish_s
divide_s:mov cx,0AH
call divdw
inc di
push cx
jmp divide
finish_s:mov cx,ax
jcxz finish
jmp divide_s
finish:mov cx,di
jcxz dtoc_ok
string:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string
dtoc_ok:
pop di
pop ax
pop bx
pop cx
pop dx
ret
DTOC ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
BTOASC PROC
PUSH AX
PUSH DX
CMP DX,0
JZ BTOASC3
BTOASC4:CALL DTOC
JMP BTOASC2
BTOASC3:CMP AX,0
JNZ BTOASC4
mov AL,'0'
CALL PUTCH
BTOASC2:POP DX
POP AX
RET
BTOASC ENDP
CALCUL PROC
PUSH BX
PUSH DX
MOV BX,3
CALL FACT
POP DX
POP BX
RET
CALCUL ENDP
FACT PROC
PUSH DX
PUSH BP
MOV BP,SP
SUB SP,2
MOV WORD PTR [BP-2],0
MOV DX,AX
CMP AX,1
JZ FACT1
CMP AX,2
JZ FACT2
DEC AX
CALL FACT
MOV [BP-2],AX
MOV AX,DX
SUB AX,2
CALL FACT
MUL BX
ADD AX,[BP-2]
MOV SP,BP
POP BP
POP DX
RET
FACT1:MOV AX,0
MOV SP,BP
POP BP
POP DX
RET
FACT2:MOV AX,1
MOV SP,BP
POP BP
POP DX
RET
FACT ENDP
CSEG ENDS
END START
题4.25请编写一个利用选择法实现排序的子程序。要求该子程序具有可重入性，并且至少使用一个安排在堆栈中的变量。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
BUFFER DB 23,12,45,32,127,3,9,58,81,72,16,66,78,188,222,162
N EQU 16
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV BX,OFFSET BUFFER
MOV CX,N
CALL SORTBUF
MOV DI,OFFSET BUFFER
MOV BX,N
CALL DISPBUF
MOV AH,4CH
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
CMP BX,1
JB DISPBUF_OK
MOV SI,BX
XOR BX,BX
DISPBUF1:MOV AL,[BX][DI]
XOR AH,AH
XOR DX,DX
CALL BTOASC
INC BX
CMP BX,SI
JAE DISPBUF2
MOV AL,20H
CALL PUTCH
JMP DISPBUF1
DISPBUF2:CALL NEWLINE
DISPBUF_OK:
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DISPBUF ENDP
DTOC PROC
push dx
push cx
push bx
push ax
push di
mov di,0
divide:mov cx,dx
jcxz finish_s
divide_s:mov cx,0AH
call divdw
inc di
push cx
jmp divide
finish_s:mov cx,ax
jcxz finish
jmp divide_s
finish:mov cx,di
jcxz dtoc_ok
string:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string
dtoc_ok:
pop di
pop ax
pop bx
pop cx
pop dx
ret
DTOC ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
BTOASC PROC
PUSH AX
PUSH DX
CMP DX,0
JZ BTOASC3
BTOASC4:CALL DTOC
JMP BTOASC2
BTOASC3:CMP AX,0
JNZ BTOASC4
mov AL,'0'
CALL PUTCH
BTOASC2:POP DX
POP AX
RET
BTOASC ENDP
SORTBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV BP,SP
CMP CX,2
JB SORTBUF_OK
SUB SP,4
MOV [BP-2],CX
MOV [BP-4],CX
SUB WORD PTR [BP-2],2
DEC WORD PTR [BP-4]
MOV SI,0
FORI:MOV DI,SI
INC DI
MOV AL,[BX+SI]
FORJ:CMP AL,[BX+DI]
JBE NEXTJ
XCHG AL,[BX+DI]
NEXTJ:INC DI
CMP DI,WORD PTR [BP-4]
JBE FORJ
MOV [BX+SI],AL
NEXTI:INC SI
CMP SI,WORD PTR [BP-2]
JBE FORI
SORTBUF_OK:MOV SP,BP
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
SORTBUF ENDP
CSEG ENDS
END START
题4.26写一个程序在屏幕上（或在打印机上）列出小于65535的素数（质数）。
计算素数的c语言程序如下
#define N 1023
char buffer[1024];
int array[1024];
void init()
{
    int i, j, len = 0;
    for(i = 1; i <= N; i++)
    {
        buffer[i] = 0;
    }
    for(i = 2; i < N; i++)
    {
        if(buffer[i] == 0)
        {
            array[len] = i;
            printf(" %d ", i);
            len++;
        }
        if(i <= N / 2)
        {
            for(j = 0; j < len && array[j]*i < N; j++)
            {
                buffer[array[j]*i] = 1;
                if(i%array[j] == 0) break;
            }
        }
    }
}
main()
{
    init();
}
按照上面的算法，测试通过的完整程序如下
不包含break部分
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG1 SEGMENT
BUFFER DB 65535 DUP (0)
DSEG1 ENDS
DSEG2 SEGMENT
ARRAY DW 8192 DUP (0)
LEN DW 0
DSEG2 ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG1,ES:DSEG2
START:MOV AX,DSEG1
MOV DS,AX
MOV AX,DSEG2
MOV ES,AX
CALL CALCUL
MOV AH,4CH
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DTOC PROC
push dx
push cx
push bx
push ax
push di
mov di,0
divide:mov cx,dx
jcxz finish_s
divide_s:mov cx,0AH
call divdw
inc di
push cx
jmp divide
finish_s:mov cx,ax
jcxz finish
jmp divide_s
finish:mov cx,di
jcxz dtoc_ok
string:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string
dtoc_ok:
pop di
pop ax
pop bx
pop cx
pop dx
ret
DTOC ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
BTOASC PROC
PUSH AX
PUSH DX
CMP DX,0
JZ BTOASC3
BTOASC4:CALL DTOC
JMP BTOASC2
BTOASC3:CMP AX,0
JNZ BTOASC4
mov AL,'0'
CALL PUTCH
BTOASC2:POP DX
POP AX
RET
BTOASC ENDP
CALCUL PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
XOR AX,AX
MOV LEN,AX
MOV SI,2
FORI:CMP SI,65534
JAE CALCUL_OK
MOV AL,BUFFER[SI]
CMP AL,0
JNZ CALCUL1
MOV AX,LEN
MOV BX,AX
ADD BX,BX
MOV ARRAY[BX],SI
INC AX
MOV LEN,AX
MOV AX,SI
XOR DX,DX
CALL BTOASC
MOV AL,20H
CALL PUTCH
CALCUL1:CMP SI,32767
JA NEXTI
XOR AX,AX
MOV DI,AX
FORJ:CMP DI,LEN
JAE NEXTI
MOV BX,DI
ADD BX,BX
MOV AX,ARRAY[BX]
MUL SI
CMP DX,0
JNZ NEXTI
CMP AX,65534
JAE NEXTI
MOV BX,AX
MOV AL,1
MOV BUFFER[BX],AL
NEXTJ:INC DI
JMP FORJ
NEXTI:INC SI
JMP FORI
CALCUL_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
CALCUL ENDP
CSEG ENDS
END START
包含break部分
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG1 SEGMENT
BUFFER DB 65535 DUP (0)
DSEG1 ENDS
DSEG2 SEGMENT
ARRAY DW 8192 DUP (0)
LEN DW 0
DSEG2 ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG1,ES:DSEG2
START:MOV AX,DSEG1
MOV DS,AX
MOV AX,DSEG2
MOV ES,AX
CALL CALCUL
MOV AH,4CH
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DTOC PROC
push dx
push cx
push bx
push ax
push di
mov di,0
divide:mov cx,dx
jcxz finish_s
divide_s:mov cx,0AH
call divdw
inc di
push cx
jmp divide
finish_s:mov cx,ax
jcxz finish
jmp divide_s
finish:mov cx,di
jcxz dtoc_ok
string:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string
dtoc_ok:
pop di
pop ax
pop bx
pop cx
pop dx
ret
DTOC ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
BTOASC PROC
PUSH AX
PUSH DX
CMP DX,0
JZ BTOASC3
BTOASC4:CALL DTOC
JMP BTOASC2
BTOASC3:CMP AX,0
JNZ BTOASC4
mov AL,'0'
CALL PUTCH
BTOASC2:POP DX
POP AX
RET
BTOASC ENDP
CALCUL PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
XOR AX,AX
MOV LEN,AX
MOV SI,2
FORI:CMP SI,65534
JAE CALCUL_OK
MOV AL,BUFFER[SI]
CMP AL,0
JNZ CALCUL1
MOV AX,LEN
MOV BX,AX
ADD BX,BX
MOV ARRAY[BX],SI
INC AX
MOV LEN,AX
MOV AX,SI
XOR DX,DX
CALL BTOASC
MOV AL,20H
CALL PUTCH
CALCUL1:CMP SI,32767
JA NEXTI
XOR AX,AX
MOV DI,AX
FORJ:CMP DI,LEN
JAE NEXTI
MOV BX,DI
ADD BX,BX
MOV AX,ARRAY[BX]
MOV CX,AX
MUL SI
CMP DX,0
JNZ NEXTI
CMP AX,65534
JAE NEXTI
MOV BX,AX
MOV AL,1
MOV BUFFER[BX],AL
MOV AX,SI
XOR DX,DX
CALL DIVDW
JCXZ NEXTI
NEXTJ:INC DI
JMP FORJ
NEXTI:INC SI
JMP FORI
CALCUL_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
CALCUL ENDP
CSEG ENDS
END START
把结果再输出到文件
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG1 SEGMENT
BUFFER DB 65535 DUP (0)
DSEG1 ENDS
DSEG2 SEGMENT
ARRAY DW 8192 DUP (0)
BUF_STR DB 128 DUP (0)
BUF_LEN DW 0
LEN DW 0
NUM1 DW 0
NUM2 DW 0
HANDLE1 DW 0
FNAME DB 'TEST.TXT',0
ERRMESS1 DB 'Can not create file',07H,'$'
ERRMESS2 DB 'Writing error',07H,'$'
DSEG2 ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG1,ES:DSEG2
START:MOV AX,DSEG1
MOV DS,AX
MOV AX,DSEG2
MOV ES,AX
CALL CALCUL
CALL WRITEBUF
MOV AH,4CH
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DTOC PROC
push dx
push cx
push bx
push ax
push di
mov di,0
divide:mov cx,dx
jcxz finish_s
divide_s:mov cx,0AH
call divdw
inc di
push cx
jmp divide
finish_s:mov cx,ax
jcxz finish
jmp divide_s
finish:mov cx,di
jcxz dtoc_ok
string:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string
dtoc_ok:
pop di
pop ax
pop bx
pop cx
pop dx
ret
DTOC ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
BTOASC PROC
PUSH AX
PUSH DX
CMP DX,0
JZ BTOASC3
BTOASC4:CALL DTOC
JMP BTOASC2
BTOASC3:CMP AX,0
JNZ BTOASC4
mov AL,'0'
CALL PUTCH
BTOASC2:POP DX
POP AX
RET
BTOASC ENDP
CALCUL PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
XOR AX,AX
MOV LEN,AX
MOV SI,2
FORI:CMP SI,65534
JAE CALCUL_OK
MOV AL,BUFFER[SI]
CMP AL,0
JNZ CALCUL1
MOV AX,LEN
MOV BX,AX
ADD BX,BX
MOV ARRAY[BX],SI
INC AX
MOV LEN,AX
MOV AX,SI
XOR DX,DX
CALL BTOASC
MOV AL,20H
CALL PUTCH
CALCUL1:CMP SI,32767
JA NEXTI
XOR AX,AX
MOV DI,AX
FORJ:CMP DI,LEN
JAE NEXTI
MOV BX,DI
ADD BX,BX
MOV AX,ARRAY[BX]
MOV CX,AX
MUL SI
CMP DX,0
JNZ NEXTI
CMP AX,65534
JAE NEXTI
MOV BX,AX
MOV AL,1
MOV BUFFER[BX],AL
MOV AX,SI
XOR DX,DX
CALL DIVDW
JCXZ NEXTI
NEXTJ:INC DI
JMP FORJ
NEXTI:INC SI
JMP FORI
CALCUL_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
CALCUL ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
WRITEBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH DS
PUSH BP
ASSUME DS:DSEG2
MOV AX,DSEG2
MOV DS,AX
MOV AX,LEN
CMP AX,1
JB WRITEBUF_OK
XOR DX,DX
MOV CX,0AH
CALL DIVDW
MOV NUM1,AX
MOV NUM2,CX
MOV DX,OFFSET FNAME
MOV CX,0
MOV AH,3CH
INT 21H
JNC CREA_OK
MOV DX,OFFSET ERRMESS1
CALL DISPMESS
JMP WRITEBUF_OK
CREA_OK:MOV HANDLE1,AX
MOV BP,0
MOV SI,0
FORI1:CMP BP,LEN
JAE CLOSEF
CMP SI,NUM1
JZ WRITEBUF1
JA CLOSEF
MOV BUF_LEN,0
MOV DI,0
FORJ1:CMP DI,10
JAE FINISHJ1
MOV BX,BP
ADD BX,BX
MOV AX,ARRAY[BX]
XOR DX,DX
CALL DTOBUF
NEXTJ1:INC BP
INC DI
JMP FORJ1
FINISHJ1:MOV BX,BUF_LEN
MOV BYTE PTR BUF_STR[BX],0DH
INC BX
MOV BYTE PTR BUF_STR[BX],0AH
INC BX
MOV BUF_LEN,BX
MOV CX,BX
MOV DX,OFFSET BUF_STR
MOV BX,HANDLE1
MOV AH,40H
INT 21H
JC WERROR
JMP NEXTI1
WRITEBUF1:
MOV AX,NUM2
CMP AX,1
JB NEXTI1
MOV BUF_LEN,0
MOV DI,0
FORJ2:CMP DI,NUM2
JAE FINISHJ2
MOV BX,BP
ADD BX,BX
MOV AX,ARRAY[BX]
XOR DX,DX
CALL DTOBUF
NEXTJ2:INC BP
INC DI
JMP FORJ2
FINISHJ2:MOV BX,BUF_LEN
MOV BYTE PTR BUF_STR[BX],0DH
INC BX
MOV BYTE PTR BUF_STR[BX],0AH
INC BX
MOV BUF_LEN,BX
MOV CX,BX
MOV DX,OFFSET BUF_STR
MOV BX,HANDLE1
MOV AH,40H
INT 21H
JC WERROR
NEXTI1:INC SI
JMP FORI1
WERROR:MOV DX,OFFSET ERRMESS2
CALL DISPMESS
CLOSEF:MOV BX,HANDLE1
MOV AH,3EH
INT 21H
WRITEBUF_OK:POP BP
POP DS
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
WRITEBUF ENDP
DTOBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
CMP DX,0
JNZ DTOBUF1
CMP AX,0
JNZ DTOBUF1
MOV SI,WORD PTR BUF_LEN
MOV BYTE PTR BUF_STR[SI],'0'
INC SI
MOV BYTE PTR BUF_STR[SI],20H
INC SI
MOV WORD PTR BUF_LEN,SI
JMP DTOBUF_OK
DTOBUF1:MOV SI,WORD PTR BUF_LEN
mov di,0
divide_buf:mov cx,dx
jcxz finish_s_buf
divide_s_buf:mov cx,0AH
call divdw
inc di
push cx
jmp divide_buf
finish_s_buf:mov cx,ax
jcxz finish_buf
jmp divide_s_buf
finish_buf:mov cx,di
jcxz DTOBUF_OK
string_buf:pop bx
add bx,30h
MOV BYTE PTR BUF_STR[SI],BL
INC SI
loop string_buf
MOV BYTE PTR BUF_STR[SI],20H
INC SI
MOV WORD PTR BUF_LEN,SI
DTOBUF_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOBUF ENDP
CSEG ENDS
END START
题4.27请写一个程序实现如下功能：把从内存单元F000：0000H开始的200个字节作为无符号整数，求它们的和，
并用十进制数在屏幕上显示出来；把该区域作为100个无符号16位的字，求它们的和，并用十进制数在屏幕上显示出来。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
SUM1 DW 0
SUM2_A DW 0
SUM2_D DW 0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL CALCUL
MOV AH,4CH
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DTOC PROC
push dx
push cx
push bx
push ax
push di
mov di,0
divide:mov cx,dx
jcxz finish_s
divide_s:mov cx,0AH
call divdw
inc di
push cx
jmp divide
finish_s:mov cx,ax
jcxz finish
jmp divide_s
finish:mov cx,di
jcxz dtoc_ok
string:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string
dtoc_ok:
pop di
pop ax
pop bx
pop cx
pop dx
ret
DTOC ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
BTOASC PROC
PUSH AX
PUSH DX
CMP DX,0
JZ BTOASC3
BTOASC4:CALL DTOC
JMP BTOASC2
BTOASC3:CMP AX,0
JNZ BTOASC4
mov AL,'0'
CALL PUTCH
BTOASC2:POP DX
POP AX
RET
BTOASC ENDP
CALCUL PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
MOV AX,0F000H
MOV ES,AX
MOV WORD PTR SUM1,0
XOR AX,AX
MOV SI,0000H
FORI:CMP SI,200
JAE FINISHI
MOV AL,ES:[SI]
ADD WORD PTR SUM1,AX
NEXTI:INC SI
JMP FORI
FINISHI:MOV WORD PTR SUM2_A,0
MOV WORD PTR SUM2_D,0
XOR AX,AX
MOV DI,0000H
FORJ:CMP DI,200
JAE FINISHJ
MOV AX,ES:[DI]
ADD WORD PTR SUM2_A,AX
ADC WORD PTR SUM2_D,0
NEXTJ:INC DI
INC DI
JMP FORJ
FINISHJ:MOV AX,SUM1
XOR DX,DX
CALL BTOASC
CALL NEWLINE
MOV AX,SUM2_A
MOV DX,SUM2_D
CALL BTOASC
CALL NEWLINE
CALCUL_OK:POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
CALCUL ENDP
CSEG ENDS
END START
题4.28请写一个程序实现如下功能：把内存单元F000：0000H开始的1024个字节作为有符号数，分别统计其中的正数、负数和0的个数，并显示。
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
NUMG DW 0
NUMZ DW 0
NUML DW 0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL CALCUL
MOV AH,4CH
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DTOC PROC
push dx
push cx
push bx
push ax
push di
mov di,0
divide:mov cx,dx
jcxz finish_s
divide_s:mov cx,0AH
call divdw
inc di
push cx
jmp divide
finish_s:mov cx,ax
jcxz finish
jmp divide_s
finish:mov cx,di
jcxz dtoc_ok
string:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string
dtoc_ok:
pop di
pop ax
pop bx
pop cx
pop dx
ret
DTOC ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
BTOASC PROC
PUSH AX
PUSH DX
CMP DX,0
JZ BTOASC3
BTOASC4:CALL DTOC
JMP BTOASC2
BTOASC3:CMP AX,0
JNZ BTOASC4
mov AL,'0'
CALL PUTCH
BTOASC2:POP DX
POP AX
RET
BTOASC ENDP
CALCUL PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
MOV AX,0F000H
MOV ES,AX
MOV WORD PTR NUMG,0
MOV WORD PTR NUMZ,0
MOV WORD PTR NUML,0
XOR AX,AX
MOV SI,0000H
FORI:CMP SI,1024
JAE FINISHI
MOV AL,ES:[SI]
CMP AL,0
JL CALCUL1
JZ CALCUL2
INC WORD PTR NUMG
JMP NEXTI
CALCUL1:INC WORD PTR NUML
JMP NEXTI
CALCUL2:INC WORD PTR NUMZ
NEXTI:INC SI
JMP FORI
FINISHI:MOV AX,NUMG
XOR DX,DX
CALL BTOASC
CALL NEWLINE
MOV AX,NUML
XOR DX,DX
CALL BTOASC
CALL NEWLINE
MOV AX,NUMZ
XOR DX,DX
CALL BTOASC
CALL NEWLINE
CALCUL_OK:POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
CALCUL ENDP
CSEG ENDS
END START
题4.29请写一个程序实现如下功能：把指定开始地址的内存区域作为存放16位字数组的缓冲区，依次顺序显示其值。
具体要求是：开始地址由键盘输入；每此在一行中以多种进制形式显示一个字单元的内容，行首标上用十六进制表示的存储单元的段值和偏移。
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
DIS_BUF DB 128 DUP (0)
GET_BUF DB 16 DUP (0)
ARRAY_SEG DW 0
ARRAY_OFF DW 0
ARRAY_LEN DW 0
DIS_LEN DW 0
MESS_SEG DB 'SEGMENT:$'
MESS_OFF DB 'OFFSET:$'
MESS_LEN DB 'LENGTH:$'
mul_table dw 1,10,100,1000,10000
shl_table db 0,4,8,12
res_ax dw 0
num_dx dw 0
num_cx dw 0
num_bx dw 0
num_ax dw 0
HANDLE1 DW 0
FNAME DB 'TEST.TXT',0
ERRMESS1 DB 'Can not create file',07H,'$'
ERRMESS2 DB 'Writing error',07H,'$'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESS_SEG
CALL DISPMESS
MOV DI,OFFSET GET_BUF
CALL GETSTRH
MOV SI,OFFSET GET_BUF
ADD SI,2
MOV CX,WORD PTR GET_BUF
SUB CX,2
CALL HTOBIN
MOV AX,WORD PTR RES_AX
MOV WORD PTR ARRAY_SEG,AX
MOV DX,OFFSET MESS_OFF
CALL DISPMESS
MOV DI,OFFSET GET_BUF
CALL GETSTRH
MOV SI,OFFSET GET_BUF
ADD SI,2
MOV CX,WORD PTR GET_BUF
SUB CX,2
CALL HTOBIN
MOV AX,WORD PTR RES_AX
MOV WORD PTR ARRAY_OFF,AX
MOV DX,OFFSET MESS_LEN
CALL DISPMESS
MOV DI,OFFSET GET_BUF
CALL GETSTRD
MOV SI,OFFSET GET_BUF
ADD SI,2
MOV CX,WORD PTR GET_BUF
SUB CX,2
CALL DTOBIN
MOV AX,WORD PTR RES_AX
MOV WORD PTR ARRAY_LEN,AX
MOV AX,ARRAY_SEG
XOR DX,DX
CALL DHTOASC
CALL NEWLINE
MOV AX,ARRAY_OFF
XOR DX,DX
CALL DHTOASC
CALL NEWLINE
MOV AX,ARRAY_LEN
XOR DX,DX
CALL DTOASC
CALL NEWLINE
MOV AX,ARRAY_SEG
MOV ES,AX
MOV AX,ARRAY_OFF
MOV DI,AX
MOV CX,ARRAY_LEN
CALL DISARRAY
CALL WRITEARRAY
MOV AH,4CH
INT 21H
ISHEX PROC
CMP AL,'0'
JB ISHEX_NOHEX
CMP AL,'9'
JA ISHEX_NODEC1
CLC
JMP ISHEX_OK
ISHEX_NODEC1:CMP AL,'A'
JB ISHEX_NOHEX
CMP AL,'F'
JA ISHEX_NODEC2
CLC
JMP ISHEX_OK
ISHEX_NODEC2:CMP AL,'a'
JB ISHEX_NOHEX
CMP AL,'f'
JA ISHEX_NOHEX
CLC
JMP ISHEX_OK
ISHEX_NOHEX:STC
ISHEX_OK:RET
ISHEX ENDP
ISDEC PROC
CMP AL,'0'
JB ISDEC_NODEC
CMP AL,'9'
JA ISDEC_NODEC
CLC
JMP ISDEC_OK
ISDEC_NODEC:STC
ISDEC_OK:RET
ISDEC ENDP
ATOBIN PROC
SUB AL,30H
CMP AL,9
JBE ATOBIN_OK
SUB AL,7
CMP AL,15
JBE ATOBIN_OK
SUB AL,20H
ATOBIN_OK:RET
ATOBIN ENDP
HTOBIN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV DI,SI
ADD DI,CX
DEC DI
MOV BX,0
MOV RES_AX,0
XOR DX,DX
HTOBIN_FORJ:CMP DI,SI
JB HTOBIN_FINISHJ
MOV AL,DS:[DI]
CALL ATOBIN
MOV AH,0
MOV CL,SHL_TABLE[BX]
SHL AX,CL
ADD DX,AX
HTOBIN_NEXTJ:DEC DI
INC BX
JMP HTOBIN_FORJ
HTOBIN_FINISHJ:MOV RES_AX,DX
HTOBIN_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
HTOBIN ENDP
DTOBIN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV DI,SI
ADD DI,CX
DEC DI
MOV BX,0
MOV RES_AX,0
DTOBIN_FORJ:CMP DI,SI
JB DTOBIN_OK
MOV AL,DS:[DI]
CALL ATOBIN
MOV AH,0
MOV CX,MUL_TABLE[BX]
MUL CX
ADD RES_AX,AX
DTOBIN_NEXTJ:DEC DI
INC BX
INC BX
JMP DTOBIN_FORJ
DTOBIN_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOBIN ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRH PROC
PUSH AX
PUSH BX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRH1:CALL GETCH
CMP AL,CR
JZ GETSTRH5
CMP AL,BACKSPACE
JNZ GETSTRH4
CMP BX,0
JZ GETSTRH2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRH1
GETSTRH2:CALL BELL
JMP GETSTRH1
GETSTRH4:CMP BX,4
JZ GETSTRH2
CALL ISHEX
JC GETSTRH2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRH1
GETSTRH5:CMP BX,0
JZ GETSTRH2
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRH_OK:
POP DI
POP BX
POP AX
RET
GETSTRH ENDP
GETSTRD PROC
PUSH AX
PUSH BX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRD1:CALL GETCH
CMP AL,CR
JZ GETSTRD5
CMP AL,BACKSPACE
JNZ GETSTRD4
CMP BX,0
JZ GETSTRD2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRD1
GETSTRD2:CALL BELL
JMP GETSTRD1
GETSTRD4:CMP BX,4
JZ GETSTRD2
CALL ISDEC
JC GETSTRD2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRD1
GETSTRD5:CMP BX,0
JZ GETSTRD2
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRD_OK:
POP DI
POP BX
POP AX
RET
GETSTRD ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
DTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
CMP DX,0
JNZ DTOASC1
CMP AX,0
JNZ DTOASC1
MOV AL,'0'
CALL PUTCH
JMP DTOASC_OK
DTOASC1:mov di,0
divide_asc:mov cx,dx
jcxz finish_s_asc
divide_s_asc:mov cx,0AH
call divdw
inc di
push cx
jmp divide_asc
finish_s_asc:mov cx,ax
jcxz finish_asc
jmp divide_s_asc
finish_asc:mov cx,di
jcxz DTOASC_OK
string_asc:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string_asc
DTOASC_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOASC ENDP
HTOASC PROC
AND AL,0FH
ADD AL,30H
CMP AL,39H
JA HTOASC_NODEC
JMP HTOASC_OK
HTOASC_NODEC:ADD AL,7
HTOASC_OK:RET
HTOASC ENDP
AHTOASC PROC
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL HTOASC
XCHG AH,AL
CALL HTOASC
RET
AHTOASC ENDP
OTOASC PROC
AND AL,07H
ADD AL,30H
RET
OTOASC ENDP
AOTOASC PROC
MOV AH,AL
MOV DL,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL OTOASC
XCHG DL,AL
SHR AL,1
SHR AL,1
SHR AL,1
CALL OTOASC
XCHG AH,AL
CALL OTOASC
RET
AOTOASC ENDP
WAOTOASC PROC
PUSH BX
MOV BX,AX
MOV CL,15
SHR AX,CL
CALL OTOASC
MOV DH,AL
MOV AX,BX
MOV CL,12
SHR AX,CL
CALL OTOASC
MOV DL,AL
MOV AX,BX
MOV CL,9
SHR AX,CL
CALL OTOASC
MOV CH,AL
MOV AX,BX
MOV CL,6
SHR AX,CL
CALL OTOASC
MOV CL,AL
MOV AL,BL
SHR AL,1
SHR AL,1
SHR AL,1
CALL OTOASC
MOV AH,AL
MOV AL,BL
CALL OTOASC
POP BX
RET
WAOTOASC ENDP
BTOASC PROC
AND AL,01H
ADD AL,30H
RET
BTOASC ENDP
ABTOASC PROC
MOV AH,AL
MOV BL,AL
MOV BH,AL
MOV CL,AL
MOV CH,AL
MOV DL,AL
MOV DH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL BTOASC
XCHG DH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL BTOASC
XCHG DL,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL BTOASC
XCHG CH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL BTOASC
XCHG CL,AL
SHR AL,1
SHR AL,1
SHR AL,1
CALL BTOASC
XCHG BH,AL
SHR AL,1
SHR AL,1
CALL BTOASC
XCHG BL,AL
SHR AL,1
CALL BTOASC
XCHG AH,AL
CALL BTOASC
RET
ABTOASC ENDP
DHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH AX
XCHG AH,AL
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DHTOASC ENDP
DOTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH AX
XCHG AH,AL
CALL AOTOASC
PUSH AX
MOV AL,DL
CALL PUTCH
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
CALL AOTOASC
PUSH AX
MOV AL,DL
CALL PUTCH
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DOTOASC ENDP
WDOTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
CALL WAOTOASC
PUSH AX
MOV AL,DH
CALL PUTCH
MOV AL,DL
CALL PUTCH
MOV AL,CH
CALL PUTCH
MOV AL,CL
CALL PUTCH
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
WDOTOASC ENDP
DBTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH AX
XCHG AH,AL
CALL ABTOASC
PUSH AX
MOV AL,DH
CALL PUTCH
MOV AL,DL
CALL PUTCH
MOV AL,CH
CALL PUTCH
MOV AL,CL
CALL PUTCH
MOV AL,BH
CALL PUTCH
MOV AL,BL
CALL PUTCH
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
CALL ABTOASC
PUSH AX
MOV AL,DH
CALL PUTCH
MOV AL,DL
CALL PUTCH
MOV AL,CH
CALL PUTCH
MOV AL,CL
CALL PUTCH
MOV AL,BH
CALL PUTCH
MOV AL,BL
CALL PUTCH
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DBTOASC ENDP
DISARRAY PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
CMP DI,0FFFEH
JA DISARRAY_OK
MOV SI,CX
MOV BP,0FFFFH
XOR DX,DX
MOV AX,ES
MOV CX,16
MUL CX
ADD AX,DI
ADC DX,0
MOV NUM_DX,DX
MOV NUM_AX,AX
MOV DX,000FH
MOV AX,0FFFFH
SUB AX,NUM_AX
SBB DX,NUM_DX
ADD AX,1
ADC DX,0
MOV CX,02H
CALL DIVDW
CMP DX,0
JNZ DISARRAY2
MOV BP,AX
DISARRAY2:XOR DX,DX
MOV AX,0FFFFH
SUB AX,DI
ADD AX,1
ADC DX,0
MOV CX,02H
CALL DIVDW
CMP AX,BP
JBE DISARRAY3
MOV AX,BP
DISARRAY3:CMP AX,SI
JAE DISARRAY1
MOV SI,AX
DISARRAY1:MOV CX,SI
MOV BX,DI
DISARRAY_S:MOV AX,ES
CALL DHTOASC
MOV AL,20H
CALL PUTCH
MOV AL,':'
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AX,BX
CALL DHTOASC
MOV AL,20H
CALL PUTCH
MOV AX,ES:[BX]
MOV DX,AX
CALL DHTOASC
MOV AL,20H
CALL PUTCH
MOV AX,DX
CALL WDOTOASC
MOV AL,20H
CALL PUTCH
MOV AX,DX
CALL DBTOASC
MOV AL,20H
CALL PUTCH
MOV AX,DX
XOR DX,DX
CALL DTOASC
CALL NEWLINE
INC BX
INC BX
LOOP DISARRAY_S
DISARRAY_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DISARRAY ENDP
DTOBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
CMP DX,0
JNZ DTOBUF1
CMP AX,0
JNZ DTOBUF1
MOV SI,WORD PTR DIS_LEN
MOV BYTE PTR DIS_BUF[SI],'0'
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV WORD PTR DIS_LEN,SI
JMP DTOBUF_OK
DTOBUF1:MOV SI,WORD PTR DIS_LEN
mov di,0
divide_buf:mov cx,dx
jcxz finish_s_buf
divide_s_buf:mov cx,0AH
call divdw
inc di
push cx
jmp divide_buf
finish_s_buf:mov cx,ax
jcxz finish_buf
jmp divide_s_buf
finish_buf:mov cx,di
jcxz DTOBUF_OK
string_buf:pop bx
add bx,30h
MOV BYTE PTR DIS_BUF[SI],BL
INC SI
loop string_buf
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV WORD PTR DIS_LEN,SI
DTOBUF_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOBUF ENDP
DHTOBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV SI,WORD PTR DIS_LEN
PUSH AX
XCHG AH,AL
CALL AHTOASC
MOV BYTE PTR DIS_BUF[SI],AH
INC SI
MOV BYTE PTR DIS_BUF[SI],AL
INC SI
POP AX
CALL AHTOASC
MOV BYTE PTR DIS_BUF[SI],AH
INC SI
MOV BYTE PTR DIS_BUF[SI],AL
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV WORD PTR DIS_LEN,SI
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DHTOBUF ENDP
WDOTOBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV SI,WORD PTR DIS_LEN
CALL WAOTOASC
MOV BYTE PTR DIS_BUF[SI],DH
INC SI
MOV BYTE PTR DIS_BUF[SI],DL
INC SI
MOV BYTE PTR DIS_BUF[SI],CH
INC SI
MOV BYTE PTR DIS_BUF[SI],CL
INC SI
MOV BYTE PTR DIS_BUF[SI],AH
INC SI
MOV BYTE PTR DIS_BUF[SI],AL
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV WORD PTR DIS_LEN,SI
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
WDOTOBUF ENDP
DBTOBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV SI,WORD PTR DIS_LEN
PUSH AX
XCHG AH,AL
CALL ABTOASC
MOV BYTE PTR DIS_BUF[SI],DH
INC SI
MOV BYTE PTR DIS_BUF[SI],DL
INC SI
MOV BYTE PTR DIS_BUF[SI],CH
INC SI
MOV BYTE PTR DIS_BUF[SI],CL
INC SI
MOV BYTE PTR DIS_BUF[SI],BH
INC SI
MOV BYTE PTR DIS_BUF[SI],BL
INC SI
MOV BYTE PTR DIS_BUF[SI],AH
INC SI
MOV BYTE PTR DIS_BUF[SI],AL
INC SI
POP AX
CALL ABTOASC
MOV BYTE PTR DIS_BUF[SI],DH
INC SI
MOV BYTE PTR DIS_BUF[SI],DL
INC SI
MOV BYTE PTR DIS_BUF[SI],CH
INC SI
MOV BYTE PTR DIS_BUF[SI],CL
INC SI
MOV BYTE PTR DIS_BUF[SI],BH
INC SI
MOV BYTE PTR DIS_BUF[SI],BL
INC SI
MOV BYTE PTR DIS_BUF[SI],AH
INC SI
MOV BYTE PTR DIS_BUF[SI],AL
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV WORD PTR DIS_LEN,SI
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DBTOBUF ENDP
WRITEARRAY PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
CMP DI,0FFFEH
JA WRITEARRAY_OK
MOV SI,CX
MOV BP,0FFFFH
XOR DX,DX
MOV AX,ES
MOV CX,16
MUL CX
ADD AX,DI
ADC DX,0
MOV NUM_DX,DX
MOV NUM_AX,AX
MOV DX,000FH
MOV AX,0FFFFH
SUB AX,NUM_AX
SBB DX,NUM_DX
ADD AX,1
ADC DX,0
MOV CX,02H
CALL DIVDW
CMP DX,0
JNZ WRITEARRAY2
MOV BP,AX
WRITEARRAY2:XOR DX,DX
MOV AX,0FFFFH
SUB AX,DI
ADD AX,1
ADC DX,0
MOV CX,02H
CALL DIVDW
CMP AX,BP
JBE WRITEARRAY3
MOV AX,BP
WRITEARRAY3:CMP AX,SI
JAE WRITEARRAY1
MOV SI,AX
WRITEARRAY1:MOV DX,OFFSET FNAME
MOV CX,0
MOV AH,3CH
INT 21H
JNC CREA_OK
MOV DX,OFFSET ERRMESS1
CALL DISPMESS
JMP WRITEARRAY_OK
CREA_OK:MOV HANDLE1,AX
MOV CX,SI
MOV BX,DI
WRITEARRAY_S:MOV NUM_CX,CX
MOV NUM_BX,BX
MOV DIS_LEN,0
MOV AX,ES
CALL DHTOBUF
MOV SI,DIS_LEN
MOV BYTE PTR DIS_BUF[SI],':'
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV DIS_LEN,SI
MOV AX,BX
CALL DHTOBUF
MOV AX,ES:[BX]
MOV DX,AX
CALL DHTOBUF
MOV AX,DX
CALL WDOTOBUF
MOV AX,DX
CALL DBTOBUF
MOV AX,DX
XOR DX,DX
CALL DTOBUF
MOV SI,DIS_LEN
MOV BYTE PTR DIS_BUF[SI],0DH
INC SI
MOV BYTE PTR DIS_BUF[SI],0AH
INC SI
MOV DIS_LEN,SI
MOV CX,SI
MOV DX,OFFSET DIS_BUF
MOV BX,HANDLE1
MOV AH,40H
INT 21H
JC WERROR
MOV BX,NUM_BX
INC BX
INC BX
MOV CX,NUM_CX
LOOP WRITEARRAY_S
JMP CLOSEF
WERROR:MOV DX,OFFSET ERRMESS2
CALL DISPMESS
CLOSEF:MOV BX,HANDLE1
MOV AH,3EH
INT 21H
WRITEARRAY_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
WRITEARRAY ENDP
CSEG ENDS
END START
题4.30请编写一个能够按DEBUG的D命令格式显示内存单元内容的小型工具程序。
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
DIS_BUF DB 128 DUP (0)
GET_BUF DB 16 DUP (0)
ARRAY_SEG DW 0
ARRAY_OFF DW 0
ARRAY_LEN DW 0
DIS_LEN DW 0
MESS_SEG DB 'SEGMENT:$'
MESS_OFF DB 'OFFSET:$'
MESS_LEN DB 'LENGTH:$'
mul_table dw 1,10,100,1000,10000
shl_table db 0,4,8,12
res_ax dw 0
num_dx dw 0
num_cx dw 0
num_bx dw 0
num_ax dw 0
HANDLE1 DW 0
FNAME DB 'TEST.TXT',0
ERRMESS1 DB 'Can not create file',07H,'$'
ERRMESS2 DB 'Writing error',07H,'$'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESS_SEG
CALL DISPMESS
MOV DI,OFFSET GET_BUF
CALL GETSTRH
MOV SI,OFFSET GET_BUF
ADD SI,2
MOV CX,WORD PTR GET_BUF
SUB CX,2
CALL HTOBIN
MOV AX,WORD PTR RES_AX
MOV WORD PTR ARRAY_SEG,AX
MOV DX,OFFSET MESS_OFF
CALL DISPMESS
MOV DI,OFFSET GET_BUF
CALL GETSTRH
MOV SI,OFFSET GET_BUF
ADD SI,2
MOV CX,WORD PTR GET_BUF
SUB CX,2
CALL HTOBIN
MOV AX,WORD PTR RES_AX
MOV WORD PTR ARRAY_OFF,AX
MOV DX,OFFSET MESS_LEN
CALL DISPMESS
MOV DI,OFFSET GET_BUF
CALL GETSTRD
MOV SI,OFFSET GET_BUF
ADD SI,2
MOV CX,WORD PTR GET_BUF
SUB CX,2
CALL DTOBIN
MOV AX,WORD PTR RES_AX
MOV WORD PTR ARRAY_LEN,AX
MOV AX,ARRAY_SEG
XOR DX,DX
CALL DHTOASC
CALL NEWLINE
MOV AX,ARRAY_OFF
XOR DX,DX
CALL DHTOASC
CALL NEWLINE
MOV AX,ARRAY_LEN
XOR DX,DX
CALL DTOASC
CALL NEWLINE
MOV AX,ARRAY_SEG
MOV ES,AX
MOV AX,ARRAY_OFF
MOV DI,AX
MOV CX,ARRAY_LEN
CALL DISARRAY
CALL WRITEARRAY
MOV AH,4CH
INT 21H
ISHEX PROC
CMP AL,'0'
JB ISHEX_NOHEX
CMP AL,'9'
JA ISHEX_NODEC1
CLC
JMP ISHEX_OK
ISHEX_NODEC1:CMP AL,'A'
JB ISHEX_NOHEX
CMP AL,'F'
JA ISHEX_NODEC2
CLC
JMP ISHEX_OK
ISHEX_NODEC2:CMP AL,'a'
JB ISHEX_NOHEX
CMP AL,'f'
JA ISHEX_NOHEX
CLC
JMP ISHEX_OK
ISHEX_NOHEX:STC
ISHEX_OK:RET
ISHEX ENDP
ISDEC PROC
CMP AL,'0'
JB ISDEC_NODEC
CMP AL,'9'
JA ISDEC_NODEC
CLC
JMP ISDEC_OK
ISDEC_NODEC:STC
ISDEC_OK:RET
ISDEC ENDP
ATOBIN PROC
SUB AL,30H
CMP AL,9
JBE ATOBIN_OK
SUB AL,7
CMP AL,15
JBE ATOBIN_OK
SUB AL,20H
ATOBIN_OK:RET
ATOBIN ENDP
HTOBIN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV DI,SI
ADD DI,CX
DEC DI
MOV BX,0
MOV RES_AX,0
XOR DX,DX
HTOBIN_FORJ:CMP DI,SI
JB HTOBIN_FINISHJ
MOV AL,DS:[DI]
CALL ATOBIN
MOV AH,0
MOV CL,SHL_TABLE[BX]
SHL AX,CL
ADD DX,AX
HTOBIN_NEXTJ:DEC DI
INC BX
JMP HTOBIN_FORJ
HTOBIN_FINISHJ:MOV RES_AX,DX
HTOBIN_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
HTOBIN ENDP
DTOBIN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV DI,SI
ADD DI,CX
DEC DI
MOV BX,0
MOV RES_AX,0
DTOBIN_FORJ:CMP DI,SI
JB DTOBIN_OK
MOV AL,DS:[DI]
CALL ATOBIN
MOV AH,0
MOV CX,MUL_TABLE[BX]
MUL CX
ADD RES_AX,AX
DTOBIN_NEXTJ:DEC DI
INC BX
INC BX
JMP DTOBIN_FORJ
DTOBIN_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOBIN ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRH PROC
PUSH AX
PUSH BX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRH1:CALL GETCH
CMP AL,CR
JZ GETSTRH5
CMP AL,BACKSPACE
JNZ GETSTRH4
CMP BX,0
JZ GETSTRH2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRH1
GETSTRH2:CALL BELL
JMP GETSTRH1
GETSTRH4:CMP BX,4
JZ GETSTRH2
CALL ISHEX
JC GETSTRH2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRH1
GETSTRH5:CMP BX,0
JZ GETSTRH2
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRH_OK:
POP DI
POP BX
POP AX
RET
GETSTRH ENDP
GETSTRD PROC
PUSH AX
PUSH BX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRD1:CALL GETCH
CMP AL,CR
JZ GETSTRD5
CMP AL,BACKSPACE
JNZ GETSTRD4
CMP BX,0
JZ GETSTRD2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRD1
GETSTRD2:CALL BELL
JMP GETSTRD1
GETSTRD4:CMP BX,4
JZ GETSTRD2
CALL ISDEC
JC GETSTRD2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRD1
GETSTRD5:CMP BX,0
JZ GETSTRD2
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRD_OK:
POP DI
POP BX
POP AX
RET
GETSTRD ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
DTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
CMP DX,0
JNZ DTOASC1
CMP AX,0
JNZ DTOASC1
MOV AL,'0'
CALL PUTCH
JMP DTOASC_OK
DTOASC1:mov di,0
divide_asc:mov cx,dx
jcxz finish_s_asc
divide_s_asc:mov cx,0AH
call divdw
inc di
push cx
jmp divide_asc
finish_s_asc:mov cx,ax
jcxz finish_asc
jmp divide_s_asc
finish_asc:mov cx,di
jcxz DTOASC_OK
string_asc:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string_asc
DTOASC_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOASC ENDP
HTOASC PROC
AND AL,0FH
ADD AL,30H
CMP AL,39H
JA HTOASC_NODEC
JMP HTOASC_OK
HTOASC_NODEC:ADD AL,7
HTOASC_OK:RET
HTOASC ENDP
ALTOASC PROC
CMP AL,20H
JB ALTOASC1
CMP AL,7EH
JA ALTOASC1
JMP ALTOASC_OK
ALTOASC1:MOV AL,'.'
ALTOASC_OK:RET
ALTOASC ENDP
AHTOASC PROC
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL HTOASC
XCHG AH,AL
CALL HTOASC
RET
AHTOASC ENDP
OTOASC PROC
AND AL,07H
ADD AL,30H
RET
OTOASC ENDP
AOTOASC PROC
MOV AH,AL
MOV DL,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL OTOASC
XCHG DL,AL
SHR AL,1
SHR AL,1
SHR AL,1
CALL OTOASC
XCHG AH,AL
CALL OTOASC
RET
AOTOASC ENDP
WAOTOASC PROC
PUSH BX
MOV BX,AX
MOV CL,15
SHR AX,CL
CALL OTOASC
MOV DH,AL
MOV AX,BX
MOV CL,12
SHR AX,CL
CALL OTOASC
MOV DL,AL
MOV AX,BX
MOV CL,9
SHR AX,CL
CALL OTOASC
MOV CH,AL
MOV AX,BX
MOV CL,6
SHR AX,CL
CALL OTOASC
MOV CL,AL
MOV AL,BL
SHR AL,1
SHR AL,1
SHR AL,1
CALL OTOASC
MOV AH,AL
MOV AL,BL
CALL OTOASC
POP BX
RET
WAOTOASC ENDP
BTOASC PROC
AND AL,01H
ADD AL,30H
RET
BTOASC ENDP
ABTOASC PROC
MOV AH,AL
MOV BL,AL
MOV BH,AL
MOV CL,AL
MOV CH,AL
MOV DL,AL
MOV DH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL BTOASC
XCHG DH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL BTOASC
XCHG DL,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL BTOASC
XCHG CH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL BTOASC
XCHG CL,AL
SHR AL,1
SHR AL,1
SHR AL,1
CALL BTOASC
XCHG BH,AL
SHR AL,1
SHR AL,1
CALL BTOASC
XCHG BL,AL
SHR AL,1
CALL BTOASC
XCHG AH,AL
CALL BTOASC
RET
ABTOASC ENDP
DHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH AX
XCHG AH,AL
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DHTOASC ENDP
DOTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH AX
XCHG AH,AL
CALL AOTOASC
PUSH AX
MOV AL,DL
CALL PUTCH
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
CALL AOTOASC
PUSH AX
MOV AL,DL
CALL PUTCH
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DOTOASC ENDP
WDOTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
CALL WAOTOASC
PUSH AX
MOV AL,DH
CALL PUTCH
MOV AL,DL
CALL PUTCH
MOV AL,CH
CALL PUTCH
MOV AL,CL
CALL PUTCH
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
WDOTOASC ENDP
DBTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH AX
XCHG AH,AL
CALL ABTOASC
PUSH AX
MOV AL,DH
CALL PUTCH
MOV AL,DL
CALL PUTCH
MOV AL,CH
CALL PUTCH
MOV AL,CL
CALL PUTCH
MOV AL,BH
CALL PUTCH
MOV AL,BL
CALL PUTCH
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
CALL ABTOASC
PUSH AX
MOV AL,DH
CALL PUTCH
MOV AL,DL
CALL PUTCH
MOV AL,CH
CALL PUTCH
MOV AL,CL
CALL PUTCH
MOV AL,BH
CALL PUTCH
MOV AL,BL
CALL PUTCH
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DBTOASC ENDP
DAHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DAHTOASC ENDP
DISARRAY PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
CMP CX,1
JB DISARRAY_OK
CMP CX,8000H
JA DISARRAY_OK
MOV SI,CX
MOV BP,0FFFFH
XOR DX,DX
MOV AX,ES
MOV CX,16
MUL CX
ADD AX,DI
ADC DX,0
CMP DX,000FH
JA DISARRAY_OK
MOV NUM_DX,DX
MOV NUM_AX,AX
MOV DX,000FH
MOV AX,0FFFFH
SUB AX,NUM_AX
SBB DX,NUM_DX
ADD AX,1
ADC DX,0
CMP DX,0
JNZ DISARRAY2
MOV BP,AX
DISARRAY2:XOR DX,DX
MOV AX,0FFFFH
SUB AX,DI
ADD AX,1
ADC DX,0
CMP DX,0
JZ DISARRAY5
MOV AX,0FFFFH
DISARRAY5:CMP AX,BP
JBE DISARRAY3
MOV AX,BP
DISARRAY3:CMP AX,SI
JAE DISARRAY1
MOV SI,AX
DISARRAY1:MOV AX,SI
XOR DX,DX
MOV CX,16
CALL DIVDW
MOV NUM_AX,AX
MOV NUM_CX,CX
MOV CX,SI
MOV BX,DI
MOV BP,0
MOV SI,0
DISARRAY_FORI1:CMP BP,CX
JAE DISARRAY_OK
CMP SI,NUM_AX
JZ DISARRAYZ
JA DISARRAY_OK
MOV NUM_BX,SI
MOV DIS_LEN,0
MOV AX,ES
CALL DHTOBUF
MOV SI,DIS_LEN
MOV BYTE PTR DIS_BUF[SI],':'
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV DIS_LEN,SI
MOV AX,BX
CALL DHTOBUF
MOV SI,NUM_BX
MOV DI,0
DISARRAY_FORJ1:CMP DI,16
JAE DISARRAY_FINISHJ1
MOV AL,ES:[BX]
CALL DAHTOBUF
CALL ALTOASC
MOV DIS_BUF[DI+62],AL
DISARRAY_NEXTJ1:INC DI
INC BP
INC BX
JMP DISARRAY_FORJ1
DISARRAY_FINISHJ1:MOV SI,DIS_LEN
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
ADD SI,16
MOV BYTE PTR DIS_BUF[SI],0DH
INC SI
MOV BYTE PTR DIS_BUF[SI],0AH
INC SI
MOV DIS_LEN,SI
MOV NUM_DX,CX
MOV CX,SI
MOV SI,NUM_BX
MOV NUM_BX,BX
MOV BX,0
DISARRAY_S1:MOV DL,DIS_BUF[BX]
MOV AH,2
INT 21H
INC BX
LOOP DISARRAY_S1
JMP DISARRAY_NEXTI2
DISARRAYZ:MOV AX,NUM_CX
CMP AX,1
JB DISARRAY_NEXTI1
MOV NUM_BX,SI
MOV DIS_LEN,0
MOV AX,ES
CALL DHTOBUF
MOV SI,DIS_LEN
MOV BYTE PTR DIS_BUF[SI],':'
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV DIS_LEN,SI
MOV AX,BX
CALL DHTOBUF
MOV SI,NUM_BX
MOV DI,0
DISARRAY_FORJ2:CMP DI,NUM_CX
JAE DISARRAY_FINISHJ2
MOV AL,ES:[BX]
CALL DAHTOBUF
CALL ALTOASC
MOV DIS_BUF[DI+62],AL
DISARRAY_NEXTJ2:INC DI
INC BP
INC BX
JMP DISARRAY_FORJ2
DISARRAY_FINISHJ2:MOV SI,DIS_LEN
DISARRAY_FORJ3:CMP DI,16
JAE DISARRAY_FINISHJ3
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV BYTE PTR DIS_BUF[DI+62],20H
DISARRAY_NEXTJ3:INC DI
JMP DISARRAY_FORJ3
DISARRAY_FINISHJ3:
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
ADD SI,16
MOV BYTE PTR DIS_BUF[SI],0DH
INC SI
MOV BYTE PTR DIS_BUF[SI],0AH
INC SI
MOV DIS_LEN,SI
MOV NUM_DX,CX
MOV CX,SI
MOV SI,NUM_BX
MOV NUM_BX,BX
MOV BX,0
DISARRAY_S2:MOV DL,DIS_BUF[BX]
MOV AH,2
INT 21H
INC BX
LOOP DISARRAY_S2
DISARRAY_NEXTI2:MOV BX,NUM_BX
MOV CX,NUM_DX
DISARRAY_NEXTI1:INC SI
JMP DISARRAY_FORI1
DISARRAY_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DISARRAY ENDP
DTOBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
CMP DX,0
JNZ DTOBUF1
CMP AX,0
JNZ DTOBUF1
MOV SI,WORD PTR DIS_LEN
MOV BYTE PTR DIS_BUF[SI],'0'
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV WORD PTR DIS_LEN,SI
JMP DTOBUF_OK
DTOBUF1:MOV SI,WORD PTR DIS_LEN
mov di,0
divide_buf:mov cx,dx
jcxz finish_s_buf
divide_s_buf:mov cx,0AH
call divdw
inc di
push cx
jmp divide_buf
finish_s_buf:mov cx,ax
jcxz finish_buf
jmp divide_s_buf
finish_buf:mov cx,di
jcxz DTOBUF_OK
string_buf:pop bx
add bx,30h
MOV BYTE PTR DIS_BUF[SI],BL
INC SI
loop string_buf
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV WORD PTR DIS_LEN,SI
DTOBUF_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOBUF ENDP
DHTOBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV SI,WORD PTR DIS_LEN
PUSH AX
XCHG AH,AL
CALL AHTOASC
MOV BYTE PTR DIS_BUF[SI],AH
INC SI
MOV BYTE PTR DIS_BUF[SI],AL
INC SI
POP AX
CALL AHTOASC
MOV BYTE PTR DIS_BUF[SI],AH
INC SI
MOV BYTE PTR DIS_BUF[SI],AL
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV WORD PTR DIS_LEN,SI
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DHTOBUF ENDP
WDOTOBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV SI,WORD PTR DIS_LEN
CALL WAOTOASC
MOV BYTE PTR DIS_BUF[SI],DH
INC SI
MOV BYTE PTR DIS_BUF[SI],DL
INC SI
MOV BYTE PTR DIS_BUF[SI],CH
INC SI
MOV BYTE PTR DIS_BUF[SI],CL
INC SI
MOV BYTE PTR DIS_BUF[SI],AH
INC SI
MOV BYTE PTR DIS_BUF[SI],AL
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV WORD PTR DIS_LEN,SI
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
WDOTOBUF ENDP
DBTOBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV SI,WORD PTR DIS_LEN
PUSH AX
XCHG AH,AL
CALL ABTOASC
MOV BYTE PTR DIS_BUF[SI],DH
INC SI
MOV BYTE PTR DIS_BUF[SI],DL
INC SI
MOV BYTE PTR DIS_BUF[SI],CH
INC SI
MOV BYTE PTR DIS_BUF[SI],CL
INC SI
MOV BYTE PTR DIS_BUF[SI],BH
INC SI
MOV BYTE PTR DIS_BUF[SI],BL
INC SI
MOV BYTE PTR DIS_BUF[SI],AH
INC SI
MOV BYTE PTR DIS_BUF[SI],AL
INC SI
POP AX
CALL ABTOASC
MOV BYTE PTR DIS_BUF[SI],DH
INC SI
MOV BYTE PTR DIS_BUF[SI],DL
INC SI
MOV BYTE PTR DIS_BUF[SI],CH
INC SI
MOV BYTE PTR DIS_BUF[SI],CL
INC SI
MOV BYTE PTR DIS_BUF[SI],BH
INC SI
MOV BYTE PTR DIS_BUF[SI],BL
INC SI
MOV BYTE PTR DIS_BUF[SI],AH
INC SI
MOV BYTE PTR DIS_BUF[SI],AL
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV WORD PTR DIS_LEN,SI
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DBTOBUF ENDP
DAHTOBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV SI,WORD PTR DIS_LEN
CALL AHTOASC
MOV BYTE PTR DIS_BUF[SI],AH
INC SI
MOV BYTE PTR DIS_BUF[SI],AL
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV WORD PTR DIS_LEN,SI
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DAHTOBUF ENDP
WRITEARRAY PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
CMP CX,1
JB WRITEARRAY_OK
CMP CX,8000H
JA WRITEARRAY_OK
MOV SI,CX
MOV BP,0FFFFH
XOR DX,DX
MOV AX,ES
MOV CX,16
MUL CX
ADD AX,DI
ADC DX,0
CMP DX,000FH
JA WRITEARRAY_OK
MOV NUM_DX,DX
MOV NUM_AX,AX
MOV DX,000FH
MOV AX,0FFFFH
SUB AX,NUM_AX
SBB DX,NUM_DX
ADD AX,1
ADC DX,0
CMP DX,0
JNZ WRITEARRAY2
MOV BP,AX
WRITEARRAY2:XOR DX,DX
MOV AX,0FFFFH
SUB AX,DI
ADD AX,1
ADC DX,0
CMP DX,0
JZ WRITEARRAY5
MOV AX,0FFFFH
WRITEARRAY5:CMP AX,BP
JBE WRITEARRAY3
MOV AX,BP
WRITEARRAY3:CMP AX,SI
JAE WRITEARRAY1
MOV SI,AX
WRITEARRAY1:MOV DX,OFFSET FNAME
MOV CX,0
MOV AH,3CH
INT 21H
JNC CREA_OK
MOV DX,OFFSET ERRMESS1
CALL DISPMESS
JMP WRITEARRAY_OK
CREA_OK:MOV HANDLE1,AX
MOV AX,SI
XOR DX,DX
MOV CX,16
CALL DIVDW
MOV NUM_AX,AX
MOV NUM_CX,CX
MOV CX,SI
MOV BX,DI
MOV BP,0
MOV SI,0
WRITEARRAY_FORI1:CMP BP,CX
JAE CLOSEF
CMP SI,NUM_AX
JZ WRITEARRAYZ
JA CLOSEF
MOV NUM_BX,SI
MOV DIS_LEN,0
MOV AX,ES
CALL DHTOBUF
MOV SI,DIS_LEN
MOV BYTE PTR DIS_BUF[SI],':'
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV DIS_LEN,SI
MOV AX,BX
CALL DHTOBUF
MOV SI,NUM_BX
MOV DI,0
WRITEARRAY_FORJ1:CMP DI,16
JAE WRITEARRAY_FINISHJ1
MOV AL,ES:[BX]
CALL DAHTOBUF
CALL ALTOASC
MOV DIS_BUF[DI+62],AL
WRITEARRAY_NEXTJ1:INC DI
INC BP
INC BX
JMP WRITEARRAY_FORJ1
WRITEARRAY_FINISHJ1:MOV SI,DIS_LEN
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
ADD SI,16
MOV BYTE PTR DIS_BUF[SI],0DH
INC SI
MOV BYTE PTR DIS_BUF[SI],0AH
INC SI
MOV DIS_LEN,SI
MOV NUM_DX,CX
MOV CX,SI
MOV SI,NUM_BX
MOV DX,OFFSET DIS_BUF
MOV NUM_BX,BX
MOV BX,HANDLE1
MOV AH,40H
INT 21H
JC WERROR
JMP WRITEARRAY_NEXTI2
WRITEARRAYZ:MOV AX,NUM_CX
CMP AX,1
JB WRITEARRAY_NEXTI1
MOV NUM_BX,SI
MOV DIS_LEN,0
MOV AX,ES
CALL DHTOBUF
MOV SI,DIS_LEN
MOV BYTE PTR DIS_BUF[SI],':'
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV DIS_LEN,SI
MOV AX,BX
CALL DHTOBUF
MOV SI,NUM_BX
MOV DI,0
WRITEARRAY_FORJ2:CMP DI,NUM_CX
JAE WRITEARRAY_FINISHJ2
MOV AL,ES:[BX]
CALL DAHTOBUF
CALL ALTOASC
MOV DIS_BUF[DI+62],AL
WRITEARRAY_NEXTJ2:INC DI
INC BP
INC BX
JMP WRITEARRAY_FORJ2
WRITEARRAY_FINISHJ2:MOV SI,DIS_LEN
WRITEARRAY_FORJ3:CMP DI,16
JAE WRITEARRAY_FINISHJ3
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV BYTE PTR DIS_BUF[DI+62],20H
WRITEARRAY_NEXTJ3:INC DI
JMP WRITEARRAY_FORJ3
WRITEARRAY_FINISHJ3:
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
ADD SI,16
MOV BYTE PTR DIS_BUF[SI],0DH
INC SI
MOV BYTE PTR DIS_BUF[SI],0AH
INC SI
MOV DIS_LEN,SI
MOV NUM_DX,CX
MOV CX,SI
MOV SI,NUM_BX
MOV DX,OFFSET DIS_BUF
MOV NUM_BX,BX
MOV BX,HANDLE1
MOV AH,40H
INT 21H
JC WERROR
WRITEARRAY_NEXTI2:MOV BX,NUM_BX
MOV CX,NUM_DX
WRITEARRAY_NEXTI1:INC SI
JMP WRITEARRAY_FORI1
WERROR:MOV DX,OFFSET ERRMESS2
CALL DISPMESS
CLOSEF:MOV BX,HANDLE1
MOV AH,3EH
INT 21H
WRITEARRAY_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
WRITEARRAY ENDP
CSEG ENDS
END START
题4.31请编写一个能够在最低端的640K内存区域内搜索指定信息的小型工具程序。使用说明自定。
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
SEG_ARRAY DW 128 DUP (0)
OFF_ARRAY DW 128 DUP (0)
DIS_BUF DB 128 DUP (0)
GET_BUF DB 16 DUP (0)
FIND_BUF DB 16 DUP (0)
FIND_LEN DW 0
DIS_LEN DW 0
RES_LEN DW 0
NUM_LEN DW 0
MESS_STR DB 'Please input HEX string:','$'
MESS_RES DB 'Can not find string','$'
num_dx dw 0
num_cx dw 0
num_bx dw 0
num_ax dw 0
num_si dw 0
num_di dw 0
num_bp dw 0
HANDLE1 DW 0
FNAME DB 'TEST.TXT',0
ERRMESS1 DB 'Can not create file',07H,'$'
ERRMESS2 DB 'Writing error',07H,'$'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESS_STR
CALL DISPMESS
MOV DI,OFFSET GET_BUF
CALL GETSTRH
MOV SI,OFFSET GET_BUF
ADD SI,2
MOV CX,WORD PTR GET_BUF
SUB CX,2
CALL HTOBUF
CALL FINDSTR
MOV AH,4CH
INT 21H
ISHEX PROC
CMP AL,'0'
JB ISHEX_NOHEX
CMP AL,'9'
JA ISHEX_NODEC1
CLC
JMP ISHEX_OK
ISHEX_NODEC1:CMP AL,'A'
JB ISHEX_NOHEX
CMP AL,'F'
JA ISHEX_NODEC2
CLC
JMP ISHEX_OK
ISHEX_NODEC2:CMP AL,'a'
JB ISHEX_NOHEX
CMP AL,'f'
JA ISHEX_NOHEX
CLC
JMP ISHEX_OK
ISHEX_NOHEX:STC
ISHEX_OK:RET
ISHEX ENDP
ATOBIN PROC
SUB AL,30H
CMP AL,9
JBE ATOBIN_OK
SUB AL,7
CMP AL,15
JBE ATOBIN_OK
SUB AL,20H
ATOBIN_OK:RET
ATOBIN ENDP
HTOBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DI,OFFSET FIND_BUF
MOV BP,0
MOV BX,0
HTOBUF_FORJ:CMP BP,CX
JAE HTOBUF_FINISHJ
MOV AL,DS:[SI]
CALL ATOBIN
MOV AH,AL
MOV AL,DS:[SI+1]
CALL ATOBIN
SHL AH,1
SHL AH,1
SHL AH,1
SHL AH,1
ADD AH,AL
MOV DS:[BX][DI],AH
HTOBUF_NEXTJ:INC BP
INC BP
INC BX
INC SI
INC SI
JMP HTOBUF_FORJ
HTOBUF_FINISHJ:MOV FIND_LEN,BX
HTOBUF_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
HTOBUF ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRH PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRH1:CALL GETCH
CMP AL,CR
JZ GETSTRH5
CMP AL,BACKSPACE
JNZ GETSTRH4
CMP BX,0
JZ GETSTRH2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRH1
GETSTRH2:CALL BELL
JMP GETSTRH1
GETSTRH4:CMP BX,12
JZ GETSTRH2
CALL ISHEX
JC GETSTRH2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRH1
GETSTRH5:CMP BX,2
JB GETSTRH2
MOV AX,BX
XOR DX,DX
MOV CX,2
CALL DIVDW
CMP CX,0
JNZ GETSTRH2
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRH_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRH ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
HTOASC PROC
AND AL,0FH
ADD AL,30H
CMP AL,39H
JA HTOASC_NODEC
JMP HTOASC_OK
HTOASC_NODEC:ADD AL,7
HTOASC_OK:RET
HTOASC ENDP
ALTOASC PROC
CMP AL,20H
JB ALTOASC1
CMP AL,7EH
JA ALTOASC1
JMP ALTOASC_OK
ALTOASC1:MOV AL,'.'
ALTOASC_OK:RET
ALTOASC ENDP
AHTOASC PROC
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL HTOASC
XCHG AH,AL
CALL HTOASC
RET
AHTOASC ENDP
DAHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DAHTOASC ENDP
DAHTOBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV SI,WORD PTR DIS_LEN
CALL AHTOASC
MOV BYTE PTR DIS_BUF[SI],AH
INC SI
MOV BYTE PTR DIS_BUF[SI],AL
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV WORD PTR DIS_LEN,SI
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DAHTOBUF ENDP
DHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH AX
XCHG AH,AL
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DHTOASC ENDP
DHTOBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV SI,WORD PTR DIS_LEN
PUSH AX
XCHG AH,AL
CALL AHTOASC
MOV BYTE PTR DIS_BUF[SI],AH
INC SI
MOV BYTE PTR DIS_BUF[SI],AL
INC SI
POP AX
CALL AHTOASC
MOV BYTE PTR DIS_BUF[SI],AH
INC SI
MOV BYTE PTR DIS_BUF[SI],AL
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV WORD PTR DIS_LEN,SI
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DHTOBUF ENDP
DISARRAY PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
CMP CX,1
JB DISARRAY_OK
CMP CX,8000H
JA DISARRAY_OK
MOV SI,CX
MOV BP,0FFFFH
XOR DX,DX
MOV AX,ES
MOV CX,16
MUL CX
ADD AX,DI
ADC DX,0
CMP DX,000FH
JA DISARRAY_OK
MOV NUM_DX,DX
MOV NUM_AX,AX
MOV DX,000FH
MOV AX,0FFFFH
SUB AX,NUM_AX
SBB DX,NUM_DX
ADD AX,1
ADC DX,0
CMP DX,0
JNZ DISARRAY2
MOV BP,AX
DISARRAY2:XOR DX,DX
MOV AX,0FFFFH
SUB AX,DI
ADD AX,1
ADC DX,0
CMP DX,0
JZ DISARRAY5
MOV AX,0FFFFH
DISARRAY5:CMP AX,BP
JBE DISARRAY3
MOV AX,BP
DISARRAY3:CMP AX,SI
JAE DISARRAY1
MOV SI,AX
DISARRAY1:MOV AX,SI
XOR DX,DX
MOV CX,16
CALL DIVDW
MOV NUM_AX,AX
MOV NUM_CX,CX
MOV CX,SI
MOV BX,DI
MOV BP,0
MOV SI,0
DISARRAY_FORI1:CMP BP,CX
JAE DISARRAY_OK
CMP SI,NUM_AX
JZ DISARRAYZ
JA DISARRAY_OK
MOV NUM_BX,SI
MOV DIS_LEN,0
MOV AX,ES
CALL DHTOBUF
MOV SI,DIS_LEN
MOV BYTE PTR DIS_BUF[SI],':'
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV DIS_LEN,SI
MOV AX,BX
CALL DHTOBUF
MOV SI,NUM_BX
MOV DI,0
DISARRAY_FORJ1:CMP DI,16
JAE DISARRAY_FINISHJ1
MOV AL,ES:[BX]
CALL DAHTOBUF
CALL ALTOASC
MOV DIS_BUF[DI+62],AL
DISARRAY_NEXTJ1:INC DI
INC BP
INC BX
JMP DISARRAY_FORJ1
DISARRAY_FINISHJ1:MOV SI,DIS_LEN
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
ADD SI,16
MOV BYTE PTR DIS_BUF[SI],0DH
INC SI
MOV BYTE PTR DIS_BUF[SI],0AH
INC SI
MOV DIS_LEN,SI
MOV NUM_DX,CX
MOV CX,SI
MOV SI,NUM_BX
MOV NUM_BX,BX
MOV BX,0
DISARRAY_S1:MOV DL,DIS_BUF[BX]
MOV AH,2
INT 21H
INC BX
LOOP DISARRAY_S1
JMP DISARRAY_NEXTI2
DISARRAYZ:MOV AX,NUM_CX
CMP AX,1
JB DISARRAY_NEXTI1
MOV NUM_BX,SI
MOV DIS_LEN,0
MOV AX,ES
CALL DHTOBUF
MOV SI,DIS_LEN
MOV BYTE PTR DIS_BUF[SI],':'
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV DIS_LEN,SI
MOV AX,BX
CALL DHTOBUF
MOV SI,NUM_BX
MOV DI,0
DISARRAY_FORJ2:CMP DI,NUM_CX
JAE DISARRAY_FINISHJ2
MOV AL,ES:[BX]
CALL DAHTOBUF
CALL ALTOASC
MOV DIS_BUF[DI+62],AL
DISARRAY_NEXTJ2:INC DI
INC BP
INC BX
JMP DISARRAY_FORJ2
DISARRAY_FINISHJ2:MOV SI,DIS_LEN
DISARRAY_FORJ3:CMP DI,16
JAE DISARRAY_FINISHJ3
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV BYTE PTR DIS_BUF[DI+62],20H
DISARRAY_NEXTJ3:INC DI
JMP DISARRAY_FORJ3
DISARRAY_FINISHJ3:
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
ADD SI,16
MOV BYTE PTR DIS_BUF[SI],0DH
INC SI
MOV BYTE PTR DIS_BUF[SI],0AH
INC SI
MOV DIS_LEN,SI
MOV NUM_DX,CX
MOV CX,SI
MOV SI,NUM_BX
MOV NUM_BX,BX
MOV BX,0
DISARRAY_S2:MOV DL,DIS_BUF[BX]
MOV AH,2
INT 21H
INC BX
LOOP DISARRAY_S2
DISARRAY_NEXTI2:MOV BX,NUM_BX
MOV CX,NUM_DX
DISARRAY_NEXTI1:INC SI
JMP DISARRAY_FORI1
DISARRAY_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DISARRAY ENDP
DISARRAYSEGOFF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
MOV BX,0
MOV BP,0
DISARRAYSEGOFF_FORJ1:CMP BP,NUM_LEN
JAE DISARRAYSEGOFF_OK
MOV AX,SEG_ARRAY[BX]
MOV ES,AX
MOV AX,OFF_ARRAY[BX]
MOV DI,AX
MOV CX,8
CALL DISARRAY
DISARRAYSEGOFF_NEXTJ1:INC BP
INC BX
INC BX
JMP DISARRAYSEGOFF_FORJ1
DISARRAYSEGOFF_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DISARRAYSEGOFF ENDP
WRITEARRAY PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
CMP CX,1
JB WRITEARRAY_OK
CMP CX,8000H
JA WRITEARRAY_OK
MOV SI,CX
MOV BP,0FFFFH
XOR DX,DX
MOV AX,ES
MOV CX,16
MUL CX
ADD AX,DI
ADC DX,0
CMP DX,000FH
JA WRITEARRAY_OK
MOV NUM_DX,DX
MOV NUM_AX,AX
MOV DX,000FH
MOV AX,0FFFFH
SUB AX,NUM_AX
SBB DX,NUM_DX
ADD AX,1
ADC DX,0
CMP DX,0
JNZ WRITEARRAY2
MOV BP,AX
WRITEARRAY2:XOR DX,DX
MOV AX,0FFFFH
SUB AX,DI
ADD AX,1
ADC DX,0
CMP DX,0
JZ WRITEARRAY5
MOV AX,0FFFFH
WRITEARRAY5:CMP AX,BP
JBE WRITEARRAY3
MOV AX,BP
WRITEARRAY3:CMP AX,SI
JAE WRITEARRAY1
MOV SI,AX
WRITEARRAY1:MOV AX,SI
XOR DX,DX
MOV CX,16
CALL DIVDW
MOV NUM_AX,AX
MOV NUM_CX,CX
MOV CX,SI
MOV BX,DI
MOV BP,0
MOV SI,0
WRITEARRAY_FORI1:CMP BP,CX
JAE CLOSEF
CMP SI,NUM_AX
JZ WRITEARRAYZ
JA CLOSEF
MOV NUM_BX,SI
MOV DIS_LEN,0
MOV AX,ES
CALL DHTOBUF
MOV SI,DIS_LEN
MOV BYTE PTR DIS_BUF[SI],':'
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV DIS_LEN,SI
MOV AX,BX
CALL DHTOBUF
MOV SI,NUM_BX
MOV DI,0
WRITEARRAY_FORJ1:CMP DI,16
JAE WRITEARRAY_FINISHJ1
MOV AL,ES:[BX]
CALL DAHTOBUF
CALL ALTOASC
MOV DIS_BUF[DI+62],AL
WRITEARRAY_NEXTJ1:INC DI
INC BP
INC BX
JMP WRITEARRAY_FORJ1
WRITEARRAY_FINISHJ1:MOV SI,DIS_LEN
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
ADD SI,16
MOV BYTE PTR DIS_BUF[SI],0DH
INC SI
MOV BYTE PTR DIS_BUF[SI],0AH
INC SI
MOV DIS_LEN,SI
MOV NUM_DX,CX
MOV CX,SI
MOV SI,NUM_BX
MOV DX,OFFSET DIS_BUF
MOV NUM_BX,BX
MOV BX,HANDLE1
MOV AH,40H
INT 21H
JC WERROR
JMP WRITEARRAY_NEXTI2
WRITEARRAYZ:MOV AX,NUM_CX
CMP AX,1
JB WRITEARRAY_NEXTI1
MOV NUM_BX,SI
MOV DIS_LEN,0
MOV AX,ES
CALL DHTOBUF
MOV SI,DIS_LEN
MOV BYTE PTR DIS_BUF[SI],':'
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV DIS_LEN,SI
MOV AX,BX
CALL DHTOBUF
MOV SI,NUM_BX
MOV DI,0
WRITEARRAY_FORJ2:CMP DI,NUM_CX
JAE WRITEARRAY_FINISHJ2
MOV AL,ES:[BX]
CALL DAHTOBUF
CALL ALTOASC
MOV DIS_BUF[DI+62],AL
WRITEARRAY_NEXTJ2:INC DI
INC BP
INC BX
JMP WRITEARRAY_FORJ2
WRITEARRAY_FINISHJ2:MOV SI,DIS_LEN
WRITEARRAY_FORJ3:CMP DI,16
JAE WRITEARRAY_FINISHJ3
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV BYTE PTR DIS_BUF[DI+62],20H
WRITEARRAY_NEXTJ3:INC DI
JMP WRITEARRAY_FORJ3
WRITEARRAY_FINISHJ3:
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
ADD SI,16
MOV BYTE PTR DIS_BUF[SI],0DH
INC SI
MOV BYTE PTR DIS_BUF[SI],0AH
INC SI
MOV DIS_LEN,SI
MOV NUM_DX,CX
MOV CX,SI
MOV SI,NUM_BX
MOV DX,OFFSET DIS_BUF
MOV NUM_BX,BX
MOV BX,HANDLE1
MOV AH,40H
INT 21H
JC WERROR
WRITEARRAY_NEXTI2:MOV BX,NUM_BX
MOV CX,NUM_DX
WRITEARRAY_NEXTI1:INC SI
JMP WRITEARRAY_FORI1
WERROR:MOV DX,OFFSET ERRMESS2
CALL DISPMESS
CALL NEWLINE
STC
JMP WRITEARRAY_OK
CLOSEF:CLC
WRITEARRAY_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
WRITEARRAY ENDP
WRITEARRAYSEGOFF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
MOV BX,0
MOV BP,0
WRITEARRAYSEGOFF_FORJ1:CMP BP,NUM_LEN
JAE WRITEARRAYSEGOFF_FINISHJ1
MOV AX,SEG_ARRAY[BX]
MOV ES,AX
MOV AX,OFF_ARRAY[BX]
MOV DI,AX
MOV CX,8
CALL WRITEARRAY
JC WRITEARRAYSEGOFF_WERROR
WRITEARRAYSEGOFF_NEXTJ1:INC BP
INC BX
INC BX
JMP WRITEARRAYSEGOFF_FORJ1
WRITEARRAYSEGOFF_WERROR:STC
JMP WRITEARRAYSEGOFF_OK
WRITEARRAYSEGOFF_FINISHJ1:CLC
WRITEARRAYSEGOFF_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
WRITEARRAYSEGOFF ENDP
FINDSTR PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
MOV AX,0
MOV ES,AX
MOV BP,AX
MOV NUM_LEN,AX
MOV RES_LEN,AX
MOV AX,8000H
SUB AX,FIND_LEN
MOV NUM_BP,AX
MOV DX,OFFSET FNAME
MOV CX,0
MOV AH,3CH
INT 21H
JNC FINDSTR_CREA_OK
MOV DX,OFFSET ERRMESS1
CALL DISPMESS
CALL NEWLINE
JMP FINDSTR_OK
FINDSTR_CREA_OK:MOV HANDLE1,AX
FINDSTR_FORI1:MOV AX,ES
CMP AX,9800H
JA FINDSTR_CLOSEF
JZ FINDSTR_FORI1Z
JMP FINDSTR_FORI1B
FINDSTR_FORI1Z:MOV AX,BP
CMP AX,NUM_BP
JA FINDSTR_CLOSEF
FINDSTR_FORI1B:MOV CX,FIND_LEN
MOV DI,OFFSET FIND_BUF
MOV SI,BP
FINDSTR_FORJ1:MOV AL,DS:[DI]
CMP ES:[SI],AL
JNZ FINDSTR_NEXTI1
FINDSTR_NEXTJ1:INC DI
INC SI
LOOP FINDSTR_FORJ1
MOV BX,NUM_LEN
ADD BX,BX
MOV AX,ES
MOV SEG_ARRAY[BX],AX
MOV AX,BP
MOV OFF_ARRAY[BX],AX
MOV AX,NUM_LEN
INC AX
MOV NUM_LEN,AX
INC WORD PTR RES_LEN
CMP AX,8
JB FINDSTR_NEXTI1
CALL DISARRAYSEGOFF
CALL WRITEARRAYSEGOFF
JC FINDSTR_WERROR
MOV AX,0
MOV NUM_LEN,AX
FINDSTR_NEXTI1:INC BP
CMP BP,8000H
JAE FINDSTR_NEXTI2
JMP FINDSTR_FORI1
FINDSTR_NEXTI2:MOV AX,ES
ADD AX,0800H
MOV ES,AX
SUB BP,8000H
JMP FINDSTR_FORI1
FINDSTR_WERROR:MOV BX,HANDLE1
MOV AH,3EH
INT 21H
STC
JMP FINDSTR_OK
FINDSTR_CLOSEF:MOV AX,NUM_LEN
CMP AX,1
JB FINDSTR_CLOSEFOK
CALL DISARRAYSEGOFF
CALL WRITEARRAYSEGOFF
JC FINDSTR_WERROR
MOV AX,0
MOV NUM_LEN,AX
FINDSTR_CLOSEFOK:MOV BX,HANDLE1
MOV AH,3EH
INT 21H
MOV AX,RES_LEN
CMP AX,0
JNZ FINDSTR_RESOK
MOV DX,OFFSET MESS_RES
CALL DISPMESS
CALL NEWLINE
FINDSTR_RESOK:CLC
FINDSTR_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
FINDSTR ENDP
CSEG ENDS
END START
16位乘法实现32位乘法的公式
(N*A+B)*(N*C+D)=[N*N]*(A*C)+[N]*(A*D+B*C)+(B*D)
1、A*C
2、B*D
3、A*D
4、B*C
题4.32请编写一个实现多种数制（十六进制、十进制、八进制和二进制）转换的小型工具程序。适用于小范围内的整数，其他要求和说明自定。
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
GET_BUF DB 128 DUP (0)
MESS_FORMAT DB 'Please choose input format[0 Hex,1 Dec,2 Oct,3 Bin]:','$'
MESS_HEXSTR DB 'Please input HEX string:','$'
MESS_DECSTR DB 'Please input DEC string:','$'
MESS_OCTSTR DB 'Please input OCT string:','$'
MESS_BINSTR DB 'Please input BIN string:','$'
res_dx dw 0
res_cx dw 0
res_bx dw 0
res_ax dw 0
num_dx dw 0
num_cx dw 0
num_bx dw 0
num_ax dw 0
val_dx dw 0
val_cx dw 0
val_bx dw 0
val_ax dw 0
mul_table dd 1,10,100,1000,10000,100000,1000000,10000000,100000000
shl_table db 0,4,8,12,0,4,8,12
sol_table db 0,3,6,9,12,15,2,5,8,11,14
sbl_table db 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL CONVERT
MOV AH,4CH
INT 21H
ISHEX PROC
CMP AL,'0'
JB ISHEX_NOHEX
CMP AL,'9'
JA ISHEX_NODEC1
CLC
JMP ISHEX_OK
ISHEX_NODEC1:CMP AL,'A'
JB ISHEX_NOHEX
CMP AL,'F'
JA ISHEX_NODEC2
CLC
JMP ISHEX_OK
ISHEX_NODEC2:CMP AL,'a'
JB ISHEX_NOHEX
CMP AL,'f'
JA ISHEX_NOHEX
CLC
JMP ISHEX_OK
ISHEX_NOHEX:STC
ISHEX_OK:RET
ISHEX ENDP
ISDEC PROC
CMP AL,'0'
JB ISDEC_NODEC
CMP AL,'9'
JA ISDEC_NODEC
CLC
JMP ISDEC_OK
ISDEC_NODEC:STC
ISDEC_OK:RET
ISDEC ENDP
ISOCT PROC
CMP AL,'0'
JB ISOCT_NOOCT
CMP AL,'7'
JA ISOCT_NOOCT
CLC
JMP ISOCT_OK
ISOCT_NOOCT:STC
ISOCT_OK:RET
ISOCT ENDP
ISBIN PROC
CMP AL,'0'
JB ISBIN_NOBIN
CMP AL,'1'
JA ISBIN_NOBIN
CLC
JMP ISBIN_OK
ISBIN_NOBIN:STC
ISBIN_OK:RET
ISBIN ENDP
ISFMT PROC
CMP AL,'0'
JB ISFMT_NOFMT
CMP AL,'3'
JA ISFMT_NOFMT
CLC
JMP ISFMT_OK
ISFMT_NOFMT:STC
ISFMT_OK:RET
ISFMT ENDP
ATOBIN PROC
SUB AL,30H
CMP AL,9
JBE ATOBIN_OK
SUB AL,7
CMP AL,15
JBE ATOBIN_OK
SUB AL,20H
ATOBIN_OK:RET
ATOBIN ENDP
HTOBIN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV DI,SI
ADD DI,CX
DEC DI
MOV BX,0
MOV VAL_AX,0
MOV VAL_DX,0
HTOBIN_FORJ:CMP DI,SI
JB HTOBIN_OK
MOV AL,DS:[DI]
CALL ATOBIN
MOV AH,0
CMP BX,3
JA HTOBIN_JAD
MOV DX,0
MOV CL,SHL_TABLE[BX]
SHL AX,CL
ADD VAL_AX,AX
ADC VAL_DX,DX
JMP HTOBIN_NEXTJ
HTOBIN_JAD:MOV DX,AX
MOV AX,0
MOV CL,SHL_TABLE[BX]
SHL DX,CL
ADD VAL_AX,AX
ADC VAL_DX,DX
HTOBIN_NEXTJ:DEC DI
INC BX
JMP HTOBIN_FORJ
HTOBIN_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
HTOBIN ENDP
DTOBIN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DI,SI
ADD DI,CX
DEC DI
MOV BP,0
MOV VAL_AX,0
MOV VAL_DX,0
DTOBIN_FORJ:CMP DI,SI
JB DTOBIN_OK
MOV AL,DS:[DI]
CALL ATOBIN
MOV AH,0
MOV BX,AX
MOV AX,0
MOV DX,WORD PTR MUL_TABLE[BP]
MOV CX,WORD PTR MUL_TABLE[BP+2]
CALL MULDW
ADD VAL_AX,AX
ADC VAL_DX,BX
DTOBIN_NEXTJ:DEC DI
INC BP
INC BP
INC BP
INC BP
JMP DTOBIN_FORJ
DTOBIN_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOBIN ENDP
OTOBIN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV DI,SI
ADD DI,CX
DEC DI
MOV BX,0
MOV VAL_AX,0
MOV VAL_DX,0
OTOBIN_FORJ:CMP DI,SI
JB OTOBIN_OK
MOV AL,DS:[DI]
CALL ATOBIN
MOV AH,0
CMP BX,5
JA OTOBIN_JAD
JZ OTOBIN_JZAD
MOV DX,0
MOV CL,SOL_TABLE[BX]
SHL AX,CL
ADD VAL_AX,AX
ADC VAL_DX,DX
JMP OTOBIN_NEXTJ
OTOBIN_JZAD:MOV DX,AX
MOV CL,SOL_TABLE[BX]
SHL AX,CL
SHR DX,1
ADD VAL_AX,AX
ADC VAL_DX,DX
JMP OTOBIN_NEXTJ
OTOBIN_JAD:MOV DX,AX
MOV AX,0
MOV CL,SOL_TABLE[BX]
SHL DX,CL
ADD VAL_AX,AX
ADC VAL_DX,DX
OTOBIN_NEXTJ:DEC DI
INC BX
JMP OTOBIN_FORJ
OTOBIN_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
OTOBIN ENDP
BTOBIN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV DI,SI
ADD DI,CX
DEC DI
MOV BX,0
MOV VAL_AX,0
MOV VAL_DX,0
BTOBIN_FORJ:CMP DI,SI
JB BTOBIN_OK
MOV AL,DS:[DI]
CALL ATOBIN
MOV AH,0
CMP BX,15
JA BTOBIN_JAD
MOV DX,0
MOV CL,SBL_TABLE[BX]
SHL AX,CL
ADD VAL_AX,AX
ADC VAL_DX,DX
JMP BTOBIN_NEXTJ
BTOBIN_JAD:MOV DX,AX
MOV AX,0
MOV CL,SBL_TABLE[BX]
SHL DX,CL
ADD VAL_AX,AX
ADC VAL_DX,DX
BTOBIN_NEXTJ:DEC DI
INC BX
JMP BTOBIN_FORJ
BTOBIN_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
BTOBIN ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRH PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRH1:CALL GETCH
CMP AL,CR
JZ GETSTRH5
CMP AL,BACKSPACE
JNZ GETSTRH4
CMP BX,0
JZ GETSTRH2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRH1
GETSTRH2:CALL BELL
JMP GETSTRH1
GETSTRH4:CMP BX,8
JZ GETSTRH2
CALL ISHEX
JC GETSTRH2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRH1
GETSTRH5:CMP BX,1
JB GETSTRH2
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRH_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRH ENDP
GETSTRD PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRD1:CALL GETCH
CMP AL,CR
JZ GETSTRD5
CMP AL,BACKSPACE
JNZ GETSTRD4
CMP BX,0
JZ GETSTRD2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRD1
GETSTRD2:CALL BELL
JMP GETSTRD1
GETSTRD4:CMP BX,9
JZ GETSTRD2
CALL ISDEC
JC GETSTRD2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRD1
GETSTRD5:CMP BX,1
JB GETSTRD2
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRD_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRD ENDP
GETSTRO PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRO1:CALL GETCH
CMP AL,CR
JZ GETSTRO5
CMP AL,BACKSPACE
JNZ GETSTRO4
CMP BX,0
JZ GETSTRO2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRO1
GETSTRO2:CALL BELL
JMP GETSTRO1
GETSTRO4:CMP BX,10
JZ GETSTRO2
CALL ISOCT
JC GETSTRO2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRO1
GETSTRO5:CMP BX,1
JB GETSTRO2
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRO_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRO ENDP
GETSTRB PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRB1:CALL GETCH
CMP AL,CR
JZ GETSTRB5
CMP AL,BACKSPACE
JNZ GETSTRB4
CMP BX,0
JZ GETSTRB2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRB1
GETSTRB2:CALL BELL
JMP GETSTRB1
GETSTRB4:CMP BX,32
JZ GETSTRB2
CALL ISBIN
JC GETSTRB2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRB1
GETSTRB5:CMP BX,1
JB GETSTRB2
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRB_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRB ENDP
GETSTRF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRF1:CALL GETCH
CMP AL,CR
JZ GETSTRF5
CMP AL,BACKSPACE
JNZ GETSTRF4
CMP BX,0
JZ GETSTRF2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRF1
GETSTRF2:CALL BELL
JMP GETSTRF1
GETSTRF4:CMP BX,1
JZ GETSTRF2
CALL ISFMT
JC GETSTRF2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRF1
GETSTRF5:CMP BX,1
JB GETSTRF2
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRF_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRF ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
MULDW PROC
MOV NUM_AX,AX
MOV NUM_BX,BX
MOV NUM_CX,CX
MOV NUM_DX,DX
MOV AX,NUM_AX
MOV BX,NUM_CX
MUL BX
MOV RES_DX,DX
MOV RES_CX,AX
MOV AX,NUM_BX
MOV BX,NUM_DX
MUL BX
MOV RES_BX,DX
MOV RES_AX,AX
MOV AX,NUM_AX
MOV BX,NUM_DX
MUL BX
ADD AX,RES_BX
ADC WORD PTR RES_CX,0
ADC WORD PTR RES_DX,0
ADD DX,RES_CX
ADC WORD PTR RES_DX,0
MOV RES_CX,DX
MOV RES_BX,AX
MOV AX,NUM_BX
MOV BX,NUM_CX
MUL BX
ADD AX,RES_BX
ADC WORD PTR RES_CX,0
ADC WORD PTR RES_DX,0
ADD DX,RES_CX
ADC WORD PTR RES_DX,0
MOV RES_CX,DX
MOV RES_BX,AX
MOV DX,RES_DX
MOV CX,RES_CX
MOV BX,RES_BX
MOV AX,RES_AX
RET
MULDW ENDP
HTOASC PROC
AND AL,0FH
ADD AL,30H
CMP AL,39H
JA HTOASC_NODEC
JMP HTOASC_OK
HTOASC_NODEC:ADD AL,7
HTOASC_OK:RET
HTOASC ENDP
AHTOASC PROC
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL HTOASC
XCHG AH,AL
CALL HTOASC
RET
AHTOASC ENDP
OTOASC PROC
AND AL,07H
ADD AL,30H
RET
OTOASC ENDP
DAOTOASCA PROC
PUSH BX
MOV BX,AX
MOV CL,15
SHR AX,CL
SHL DX,1
ADD AX,DX
CALL OTOASC
MOV DH,AL
MOV AX,BX
MOV CL,12
SHR AX,CL
CALL OTOASC
MOV DL,AL
MOV AX,BX
MOV CL,9
SHR AX,CL
CALL OTOASC
MOV CH,AL
MOV AX,BX
MOV CL,6
SHR AX,CL
CALL OTOASC
MOV CL,AL
MOV AL,BL
SHR AL,1
SHR AL,1
SHR AL,1
CALL OTOASC
MOV AH,AL
MOV AL,BL
CALL OTOASC
POP BX
RET
DAOTOASCA ENDP
DAOTOASCD PROC
PUSH BX
MOV AX,DX
MOV BX,AX
MOV CL,14
SHR AX,CL
CALL OTOASC
MOV DH,AL
MOV AX,BX
MOV CL,11
SHR AX,CL
CALL OTOASC
MOV DL,AL
MOV AX,BX
MOV CL,8
SHR AX,CL
CALL OTOASC
MOV CH,AL
MOV AX,BX
MOV CL,5
SHR AX,CL
CALL OTOASC
MOV CL,AL
MOV AL,BL
SHR AL,1
SHR AL,1
CALL OTOASC
MOV AH,AL
POP BX
RET
DAOTOASCD ENDP
BTOASC PROC
AND AL,01H
ADD AL,30H
RET
BTOASC ENDP
ABTOASC PROC
MOV AH,AL
MOV BL,AL
MOV BH,AL
MOV CL,AL
MOV CH,AL
MOV DL,AL
MOV DH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL BTOASC
XCHG DH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL BTOASC
XCHG DL,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL BTOASC
XCHG CH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL BTOASC
XCHG CL,AL
SHR AL,1
SHR AL,1
SHR AL,1
CALL BTOASC
XCHG BH,AL
SHR AL,1
SHR AL,1
CALL BTOASC
XCHG BL,AL
SHR AL,1
CALL BTOASC
XCHG AH,AL
CALL BTOASC
RET
ABTOASC ENDP
DTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
CMP DX,0
JNZ DTOASC1
CMP AX,0
JNZ DTOASC1
MOV AL,'0'
CALL PUTCH
JMP DTOASC_OK
DTOASC1:mov di,0
divide_asc:mov cx,dx
jcxz finish_s_asc
divide_s_asc:mov cx,0AH
call divdw
inc di
push cx
jmp divide_asc
finish_s_asc:mov cx,ax
jcxz finish_asc
jmp divide_s_asc
finish_asc:mov cx,di
jcxz DTOASC_OK
string_asc:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string_asc
DTOASC_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOASC ENDP
DDHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH AX
MOV AL,DH
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
MOV AL,DL
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
PUSH AX
XCHG AH,AL
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DDHTOASC ENDP
DDOTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DX
PUSH AX
CALL DAOTOASCD
MOV AL,DH
CALL PUTCH
MOV AL,DL
CALL PUTCH
MOV AL,CH
CALL PUTCH
MOV AL,CL
CALL PUTCH
MOV AL,AH
CALL PUTCH
POP AX
POP DX
CALL DAOTOASCA
PUSH AX
MOV AL,DH
CALL PUTCH
MOV AL,DL
CALL PUTCH
MOV AL,CH
CALL PUTCH
MOV AL,CL
CALL PUTCH
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DDOTOASC ENDP
DDBTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DX
PUSH AX
MOV AL,DH
CALL ABTOASC
PUSH AX
MOV AL,DH
CALL PUTCH
MOV AL,DL
CALL PUTCH
MOV AL,CH
CALL PUTCH
MOV AL,CL
CALL PUTCH
MOV AL,BH
CALL PUTCH
MOV AL,BL
CALL PUTCH
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
POP DX
PUSH DX
PUSH AX
MOV AL,DL
CALL ABTOASC
PUSH AX
MOV AL,DH
CALL PUTCH
MOV AL,DL
CALL PUTCH
MOV AL,CH
CALL PUTCH
MOV AL,CL
CALL PUTCH
MOV AL,BH
CALL PUTCH
MOV AL,BL
CALL PUTCH
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
POP DX
PUSH DX
PUSH AX
XCHG AH,AL
CALL ABTOASC
PUSH AX
MOV AL,DH
CALL PUTCH
MOV AL,DL
CALL PUTCH
MOV AL,CH
CALL PUTCH
MOV AL,CL
CALL PUTCH
MOV AL,BH
CALL PUTCH
MOV AL,BL
CALL PUTCH
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
POP DX
CALL ABTOASC
PUSH AX
MOV AL,DH
CALL PUTCH
MOV AL,DL
CALL PUTCH
MOV AL,CH
CALL PUTCH
MOV AL,CL
CALL PUTCH
MOV AL,BH
CALL PUTCH
MOV AL,BL
CALL PUTCH
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DDBTOASC ENDP
CONVERT PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV DX,OFFSET MESS_FORMAT
CALL DISPMESS
MOV DI,OFFSET GET_BUF
CALL GETSTRF
MOV SI,OFFSET GET_BUF
ADD SI,2
MOV AL,DS:[SI]
CMP AL,'0'
JZ CONVERT_HEX
CMP AL,'1'
JZ CONVERT_DEC
CMP AL,'2'
JZ CONVERT_OCT
CMP AL,'3'
JZ CONVERT_BIN
JMP CONVERT_OK
CONVERT_HEX:MOV DX,OFFSET MESS_HEXSTR
CALL DISPMESS
MOV DI,OFFSET GET_BUF
CALL GETSTRH
MOV SI,OFFSET GET_BUF
ADD SI,2
MOV CX,WORD PTR GET_BUF
SUB CX,2
CALL HTOBIN
MOV DX,VAL_DX
MOV AX,VAL_AX
CALL DDHTOASC
CALL NEWLINE
CALL DDOTOASC
CALL NEWLINE
CALL DDBTOASC
CALL NEWLINE
CALL DTOASC
CALL NEWLINE
JMP CONVERT_OK
CONVERT_DEC:MOV DX,OFFSET MESS_DECSTR
CALL DISPMESS
MOV DI,OFFSET GET_BUF
CALL GETSTRD
MOV SI,OFFSET GET_BUF
ADD SI,2
MOV CX,WORD PTR GET_BUF
SUB CX,2
CALL DTOBIN
MOV DX,VAL_DX
MOV AX,VAL_AX
CALL DDHTOASC
CALL NEWLINE
CALL DDOTOASC
CALL NEWLINE
CALL DDBTOASC
CALL NEWLINE
CALL DTOASC
CALL NEWLINE
JMP CONVERT_OK
CONVERT_OCT:MOV DX,OFFSET MESS_OCTSTR
CALL DISPMESS
MOV DI,OFFSET GET_BUF
CALL GETSTRO
MOV SI,OFFSET GET_BUF
ADD SI,2
MOV CX,WORD PTR GET_BUF
SUB CX,2
CALL OTOBIN
MOV DX,VAL_DX
MOV AX,VAL_AX
CALL DDHTOASC
CALL NEWLINE
CALL DDOTOASC
CALL NEWLINE
CALL DDBTOASC
CALL NEWLINE
CALL DTOASC
CALL NEWLINE
JMP CONVERT_OK
CONVERT_BIN:MOV DX,OFFSET MESS_BINSTR
CALL DISPMESS
MOV DI,OFFSET GET_BUF
CALL GETSTRB
MOV SI,OFFSET GET_BUF
ADD SI,2
MOV CX,WORD PTR GET_BUF
SUB CX,2
CALL BTOBIN
MOV DX,VAL_DX
MOV AX,VAL_AX
CALL DDHTOASC
CALL NEWLINE
CALL DDOTOASC
CALL NEWLINE
CALL DDBTOASC
CALL NEWLINE
CALL DTOASC
CALL NEWLINE
CONVERT_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
CONVERT ENDP
CSEG ENDS
END START
采用移位相减模拟除法运算过程
64位除以32位
DX CX BX AX / DI SI 
商 DX CX BX AX
余数 DI SI
DIVDD PROC
MOV NUM_DX,DX
MOV NUM_CX,CX
MOV NUM_BX,BX
MOV NUM_AX,AX
MOV RES_BX,DI
MOV RES_AX,SI
XOR AX,AX
MOV VAL_DX,AX
MOV VAL_CX,AX
MOV VAL_BX,AX
MOV VAL_AX,AX
MOV RES_DX,AX
MOV RES_CX,AX
XOR CX,CX
DIVDD_FORJ1:CMP CX,64
JAE DIVDD_FINISHJ1
CLC
RCL NUM_AX,1
RCL NUM_BX,1
RCL NUM_CX,1
RCL NUM_DX,1
RCL RES_CX,1
RCL RES_DX,1
PUSHF
POP BX
MOV AX,RES_CX
MOV DX,RES_DX
SUB AX,RES_AX
SBB DX,RES_BX
PUSHF
TEST BL,01H
JNZ DIVDD_A1
POPF
JNC DIVDD_A2
JMP DIVDD_B1
DIVDD_A1:POPF
DIVDD_A2:MOV RES_CX,AX
MOV RES_DX,DX
STC
RCL VAL_AX,1
RCL VAL_BX,1
RCL VAL_CX,1
RCL VAL_DX,1
JMP DIVDD_NEXTJ1
DIVDD_B1:CLC
RCL VAL_AX,1
RCL VAL_BX,1
RCL VAL_CX,1
RCL VAL_DX,1
DIVDD_NEXTJ1:INC CX
JMP DIVDD_FORJ1
DIVDD_FINISHJ1:MOV DX,VAL_DX
MOV CX,VAL_CX
MOV BX,VAL_BX
MOV AX,VAL_AX
MOV DI,RES_DX
MOV SI,RES_CX
RET
DIVDD ENDP
题4.33请编写一个可实现两个在0-65535范围内的整数进行加、减、乘或除运算的小型工具程序。使用说明自定。
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
GET_BUF DB 128 DUP (0)
MESS_FORMAT DB 'Please choose arithmetic format[0 ADD,1 SUB,2 MUL,3 DIV]:','$'
MESS_DECSTR1 DB 'Please input DEC string1:','$'
MESS_DECSTR2 DB 'Please input DEC string2:','$'
num1_d dw 0
num1_a dw 0
num2_d dw 0
num2_a dw 0
res_dx dw 0
res_cx dw 0
res_bx dw 0
res_ax dw 0
num_dx dw 0
num_cx dw 0
num_bx dw 0
num_ax dw 0
val_dx dw 0
val_cx dw 0
val_bx dw 0
val_ax dw 0
mul_table dd 1,10,100,1000,10000,100000,1000000,10000000,100000000
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL CONVERT
MOV AH,4CH
INT 21H
ISDEC PROC
CMP AL,'0'
JB ISDEC_NODEC
CMP AL,'9'
JA ISDEC_NODEC
CLC
JMP ISDEC_OK
ISDEC_NODEC:STC
ISDEC_OK:RET
ISDEC ENDP
ISFMT PROC
CMP AL,'0'
JB ISFMT_NOFMT
CMP AL,'3'
JA ISFMT_NOFMT
CLC
JMP ISFMT_OK
ISFMT_NOFMT:STC
ISFMT_OK:RET
ISFMT ENDP
ATOBIN PROC
SUB AL,30H
CMP AL,9
JBE ATOBIN_OK
SUB AL,7
CMP AL,15
JBE ATOBIN_OK
SUB AL,20H
ATOBIN_OK:RET
ATOBIN ENDP
DTOBIN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DI,SI
ADD DI,CX
DEC DI
MOV BP,0
MOV VAL_AX,0
MOV VAL_DX,0
DTOBIN_FORJ:CMP DI,SI
JB DTOBIN_OK
MOV AL,DS:[DI]
CALL ATOBIN
MOV AH,0
MOV BX,AX
MOV AX,0
MOV DX,WORD PTR MUL_TABLE[BP]
MOV CX,WORD PTR MUL_TABLE[BP+2]
CALL MULDW
ADD VAL_AX,AX
ADC VAL_DX,BX
DTOBIN_NEXTJ:DEC DI
INC BP
INC BP
INC BP
INC BP
JMP DTOBIN_FORJ
DTOBIN_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOBIN ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRD PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRD1:CALL GETCH
CMP AL,CR
JZ GETSTRD5
CMP AL,BACKSPACE
JNZ GETSTRD4
CMP BX,0
JZ GETSTRD2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRD1
GETSTRD2:CALL BELL
JMP GETSTRD1
GETSTRD4:CMP BX,9
JZ GETSTRD2
CALL ISDEC
JC GETSTRD2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRD1
GETSTRD5:CMP BX,1
JB GETSTRD2
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRD_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRD ENDP
GETSTRF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRF1:CALL GETCH
CMP AL,CR
JZ GETSTRF5
CMP AL,BACKSPACE
JNZ GETSTRF4
CMP BX,0
JZ GETSTRF2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRF1
GETSTRF2:CALL BELL
JMP GETSTRF1
GETSTRF4:CMP BX,1
JZ GETSTRF2
CALL ISFMT
JC GETSTRF2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRF1
GETSTRF5:CMP BX,1
JB GETSTRF2
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRF_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRF ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
MULDW PROC
MOV NUM_AX,AX
MOV NUM_BX,BX
MOV NUM_CX,CX
MOV NUM_DX,DX
MOV AX,NUM_AX
MOV BX,NUM_CX
MUL BX
MOV RES_DX,DX
MOV RES_CX,AX
MOV AX,NUM_BX
MOV BX,NUM_DX
MUL BX
MOV RES_BX,DX
MOV RES_AX,AX
MOV AX,NUM_AX
MOV BX,NUM_DX
MUL BX
ADD AX,RES_BX
ADC WORD PTR RES_CX,0
ADC WORD PTR RES_DX,0
ADD DX,RES_CX
ADC WORD PTR RES_DX,0
MOV RES_CX,DX
MOV RES_BX,AX
MOV AX,NUM_BX
MOV BX,NUM_CX
MUL BX
ADD AX,RES_BX
ADC WORD PTR RES_CX,0
ADC WORD PTR RES_DX,0
ADD DX,RES_CX
ADC WORD PTR RES_DX,0
MOV RES_CX,DX
MOV RES_BX,AX
MOV DX,RES_DX
MOV CX,RES_CX
MOV BX,RES_BX
MOV AX,RES_AX
RET
MULDW ENDP
DIVDD PROC
MOV NUM_DX,DX
MOV NUM_CX,CX
MOV NUM_BX,BX
MOV NUM_AX,AX
MOV RES_BX,DI
MOV RES_AX,SI
XOR AX,AX
MOV VAL_DX,AX
MOV VAL_CX,AX
MOV VAL_BX,AX
MOV VAL_AX,AX
MOV RES_DX,AX
MOV RES_CX,AX
XOR CX,CX
DIVDD_FORJ1:CMP CX,64
JAE DIVDD_FINISHJ1
CLC
RCL NUM_AX,1
RCL NUM_BX,1
RCL NUM_CX,1
RCL NUM_DX,1
RCL RES_CX,1
RCL RES_DX,1
PUSHF
POP BX
MOV AX,RES_CX
MOV DX,RES_DX
SUB AX,RES_AX
SBB DX,RES_BX
PUSHF
TEST BL,01H
JNZ DIVDD_A1
POPF
JNC DIVDD_A2
JMP DIVDD_B1
DIVDD_A1:POPF
DIVDD_A2:MOV RES_CX,AX
MOV RES_DX,DX
STC
RCL VAL_AX,1
RCL VAL_BX,1
RCL VAL_CX,1
RCL VAL_DX,1
JMP DIVDD_NEXTJ1
DIVDD_B1:CLC
RCL VAL_AX,1
RCL VAL_BX,1
RCL VAL_CX,1
RCL VAL_DX,1
DIVDD_NEXTJ1:INC CX
JMP DIVDD_FORJ1
DIVDD_FINISHJ1:MOV DX,VAL_DX
MOV CX,VAL_CX
MOV BX,VAL_BX
MOV AX,VAL_AX
MOV DI,RES_DX
MOV SI,RES_CX
RET
DIVDD ENDP
ABSOLU PROC
PUSH BX
mov bx,dx
and bx,8000h
cmp bx,0
jz absolu_ok
not dx
not ax
add ax,1
adc dx,0
absolu_ok:POP BX
RET
ABSOLU ENDP
DTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
CMP DX,0
JNZ DTOASC1
CMP AX,0
JNZ DTOASC1
MOV AL,'0'
CALL PUTCH
JMP DTOASC_OK
DTOASC1:mov di,0
divide_asc:mov cx,dx
jcxz finish_s_asc
divide_s_asc:mov cx,0AH
call divdw
inc di
push cx
jmp divide_asc
finish_s_asc:mov cx,ax
jcxz finish_asc
jmp divide_s_asc
finish_asc:mov cx,di
jcxz DTOASC_OK
string_asc:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string_asc
DTOASC_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOASC ENDP
DDTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CMP DX,0
JNZ DDTOASC1
CMP CX,0
JNZ DDTOASC1
CMP BX,0
JNZ DDTOASC1
CMP AX,0
JNZ DDTOASC1
MOV AL,'0'
CALL PUTCH
JMP DDTOASC_OK
DDTOASC1:mov bp,0
divide_ddtoasc:cmp dx,0
jz finish_s_ddtoasc1
divide_s_ddtoasc:mov di,0
mov si,10
call divdd
inc bp
push si
jmp divide_ddtoasc
finish_s_ddtoasc1:cmp cx,0
jz finish_s_ddtoasc2
jmp divide_s_ddtoasc
finish_s_ddtoasc2:cmp bx,0
jz finish_s_ddtoasc3
jmp divide_s_ddtoasc
finish_s_ddtoasc3:cmp ax,0
jz finish_ddtoasc
jmp divide_s_ddtoasc
finish_ddtoasc:mov cx,bp
jcxz DDTOASC_OK
string_ddtoasc:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string_ddtoasc
DDTOASC_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DDTOASC ENDP
CONVERT PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DX,OFFSET MESS_DECSTR1
CALL DISPMESS
MOV DI,OFFSET GET_BUF
CALL GETSTRD
MOV SI,OFFSET GET_BUF
ADD SI,2
MOV CX,WORD PTR GET_BUF
SUB CX,2
CALL DTOBIN
MOV DX,VAL_DX
MOV AX,VAL_AX
MOV NUM1_D,DX
MOV NUM1_A,AX
MOV DX,OFFSET MESS_DECSTR2
CALL DISPMESS
MOV DI,OFFSET GET_BUF
CALL GETSTRD
MOV SI,OFFSET GET_BUF
ADD SI,2
MOV CX,WORD PTR GET_BUF
SUB CX,2
CALL DTOBIN
MOV DX,VAL_DX
MOV AX,VAL_AX
MOV NUM2_D,DX
MOV NUM2_A,AX
MOV DX,OFFSET MESS_FORMAT
CALL DISPMESS
MOV DI,OFFSET GET_BUF
CALL GETSTRF
MOV SI,OFFSET GET_BUF
ADD SI,2
MOV AL,DS:[SI]
CMP AL,'0'
JZ CONVERT_ADD
CMP AL,'1'
JZ CONVERT_SUB
CMP AL,'2'
JZ CONVERT_MUL
CMP AL,'3'
JZ CONVERT_DIV
JMP CONVERT_OK
CONVERT_ADD:MOV AX,NUM1_A
MOV DX,NUM1_D
ADD AX,NUM2_A
ADC DX,NUM2_D
CALL DTOASC
CALL NEWLINE
JMP CONVERT_OK
CONVERT_SUB:MOV AX,NUM1_A
MOV DX,NUM1_D
SUB AX,NUM2_A
SBB DX,NUM2_D
JNC CONVERT_SUB1
PUSH AX
MOV AL,'-'
CALL PUTCH
POP AX
CALL ABSOLU
CONVERT_SUB1:CALL DTOASC
CALL NEWLINE
JMP CONVERT_OK
CONVERT_MUL:MOV AX,NUM1_D
MOV BX,NUM1_A
MOV CX,NUM2_D
MOV DX,NUM2_A
CALL MULDW
CALL DDTOASC
CALL NEWLINE
JMP CONVERT_OK
CONVERT_DIV:MOV DX,0
MOV CX,0
MOV BX,NUM1_D
MOV AX,NUM1_A
MOV DI,NUM2_D
MOV SI,NUM2_A
CALL DIVDD
CALL DDTOASC
CALL NEWLINE
MOV DX,DI
MOV AX,SI
CALL DTOASC
CALL NEWLINE
CONVERT_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
CONVERT ENDP
CSEG ENDS
END START
题4.34写一个能够复制文件的程序。源文件标识和目标文件标识由键盘输入。
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
FILEBUF_RW DB 512 DUP (0)
FNAME_SRC DB 128 DUP (0)
FNAME_DST DB 128 DUP (0)
MESS_FNSRC DB 'Please input source filename:','$'
MESS_FNDST DB 'Please input destination filename:','$'
HANDLE_SRC DW 0
HANDLE_DST DW 0
MESS_OPENERR DB 'Can not open file',07H,'$'
MESS_READERR DB 'Reading error',07h,'$'
MESS_CREAERR DB 'Can not create file',07H,'$'
MESS_WRITERR DB 'Writing error',07H,'$'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL COPYFILE
MOV AH,4CH
INT 21H
ISFNM PROC
CMP AL,2BH
JB ISFNM_NOFNM
CMP AL,3BH
JA ISFNM_NODEC1
CLC
JMP ISFNM_OK
ISFNM_NODEC1:CMP AL,41H
JB ISFNM_NOFNM
CMP AL,5FH
JA ISFNM_NODEC2
CLC
JMP ISFNM_OK
ISFNM_NODEC2:CMP AL,61H
JB ISFNM_NOFNM
CMP AL,7AH
JA ISFNM_NOFNM
CLC
JMP ISFNM_OK
ISFNM_NOFNM:STC
ISFNM_OK:RET
ISFNM ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRFN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRFN1:CALL GETCH
CMP AL,CR
JZ GETSTRFN5
CMP AL,BACKSPACE
JNZ GETSTRFN4
CMP BX,0
JZ GETSTRFN2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRFN1
GETSTRFN2:CALL BELL
JMP GETSTRFN1
GETSTRFN4:CMP BX,78
JZ GETSTRFN2
CALL ISFNM
JC GETSTRFN2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRFN1
GETSTRFN5:CMP BX,1
JB GETSTRFN2
MOV AL,0
MOV [BX][DI+2],AL
INC BX
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRFN_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRFN ENDP
COPYFILE PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DX,OFFSET MESS_FNSRC
CALL DISPMESS
MOV DI,OFFSET FNAME_SRC
CALL GETSTRFN
MOV DX,OFFSET MESS_FNDST
CALL DISPMESS
MOV DI,OFFSET FNAME_DST
CALL GETSTRFN
MOV DX,OFFSET FNAME_SRC
ADD DX,2
MOV AX,3D00H
INT 21H
JNC COPYFILE_OPENOKSRC
COPYFILE_OPENERRSRC:MOV DX,OFFSET MESS_OPENERR
CALL DISPMESS
JMP COPYFILE_OK
COPYFILE_OPENOKSRC:MOV HANDLE_SRC,AX
MOV DX,OFFSET FNAME_DST
ADD DX,2
MOV CX,0
MOV AH,3CH
INT 21H
JNC COPYFILE_CREAOKDST
COPYFILE_CREAERRDST:MOV BX,HANDLE_SRC
MOV AH,3EH
INT 21H
MOV DX,OFFSET MESS_CREAERR
CALL DISPMESS
JMP COPYFILE_OK
COPYFILE_CREAOKDST:MOV HANDLE_DST,AX
COPYFILE_RWBUF:MOV DX,OFFSET FILEBUF_RW
MOV CX,512
MOV BX,HANDLE_SRC
MOV AH,3FH
INT 21H
JC COPYFILE_READERR
CMP AX,0
JZ COPYFILE_RWFINISH
MOV CX,AX
MOV BX,HANDLE_DST
MOV AH,40H
INT 21H
JC COPYFILE_WRITERR
JMP COPYFILE_RWBUF
COPYFILE_WRITERR:MOV DX,OFFSET MESS_WRITERR
CALL DISPMESS
JMP COPYFILE_RWFINISH
COPYFILE_READERR:MOV DX,OFFSET MESS_READERR
CALL DISPMESS
COPYFILE_RWFINISH:MOV BX,HANDLE_SRC
MOV AH,3EH
INT 21H
MOV BX,HANDLE_DST
MOV AH,3EH
INT 21H
COPYFILE_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
COPYFILE ENDP
CSEG ENDS
END START
题4.35改写4.4.2节的例1、例2和例3，使它们更完善。
例1：写一个显示文本文件内容的程序。
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
FILEBUF_RW DB 512 DUP (0)
FNAME_SRC DB 128 DUP (0)
MESS_FNSRC DB 'Please input source filename:','$'
HANDLE_SRC DW 0
MESS_OPENERR DB 'Can not open file',07H,'$'
MESS_READERR DB 'Reading error',07h,'$'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL DISPFILE
MOV AH,4CH
INT 21H
ISFNM PROC
CMP AL,2BH
JB ISFNM_NOFNM
CMP AL,3BH
JA ISFNM_NODEC1
CLC
JMP ISFNM_OK
ISFNM_NODEC1:CMP AL,41H
JB ISFNM_NOFNM
CMP AL,5FH
JA ISFNM_NODEC2
CLC
JMP ISFNM_OK
ISFNM_NODEC2:CMP AL,61H
JB ISFNM_NOFNM
CMP AL,7AH
JA ISFNM_NOFNM
CLC
JMP ISFNM_OK
ISFNM_NOFNM:STC
ISFNM_OK:RET
ISFNM ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRFN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRFN1:CALL GETCH
CMP AL,CR
JZ GETSTRFN5
CMP AL,BACKSPACE
JNZ GETSTRFN4
CMP BX,0
JZ GETSTRFN2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRFN1
GETSTRFN2:CALL BELL
JMP GETSTRFN1
GETSTRFN4:CMP BX,78
JZ GETSTRFN2
CALL ISFNM
JC GETSTRFN2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRFN1
GETSTRFN5:CMP BX,1
JB GETSTRFN2
MOV AL,0
MOV [BX][DI+2],AL
INC BX
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRFN_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRFN ENDP
DISPFILE PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DX,OFFSET MESS_FNSRC
CALL DISPMESS
MOV DI,OFFSET FNAME_SRC
CALL GETSTRFN
MOV DX,OFFSET FNAME_SRC
ADD DX,2
MOV AX,3D00H
INT 21H
JNC DISPFILE_OPENOKSRC
DISPFILE_OPENERRSRC:MOV DX,OFFSET MESS_OPENERR
CALL DISPMESS
JMP DISPFILE_OK
DISPFILE_OPENOKSRC:MOV HANDLE_SRC,AX
DISPFILE_RWBUF:MOV DX,OFFSET FILEBUF_RW
MOV CX,512
MOV BX,HANDLE_SRC
MOV AH,3FH
INT 21H
JC DISPFILE_READERR
CMP AX,0
JZ DISPFILE_RWFINISH
MOV CX,AX
MOV SI,0
DISPFILE_DBUF:MOV DL,FILEBUF_RW[SI]
INC SI
MOV AH,2
INT 21H
LOOP DISPFILE_DBUF
JMP DISPFILE_RWBUF
DISPFILE_READERR:MOV DX,OFFSET MESS_READERR
CALL DISPMESS
DISPFILE_RWFINISH:MOV BX,HANDLE_SRC
MOV AH,3EH
INT 21H
DISPFILE_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DISPFILE ENDP
CSEG ENDS
END START
例2：写一个能把键盘上输入的全部字符（直到CTRL+Z键，值1AH）存入某个文件的程序。
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
EOF =1AH
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
FILEBUF_RW DB 512 DUP (0)
FNAME_DST DB 128 DUP (0)
MESS_FNDST DB 'Please input destination filename:','$'
HANDLE_DST DW 0
MESS_CREAERR DB 'Can not create file',07H,'$'
MESS_WRITERR DB 'Writing error',07H,'$'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL WRITEFILE
MOV AH,4CH
INT 21H
ISFNM PROC
CMP AL,2BH
JB ISFNM_NOFNM
CMP AL,3BH
JA ISFNM_NODEC1
CLC
JMP ISFNM_OK
ISFNM_NODEC1:CMP AL,41H
JB ISFNM_NOFNM
CMP AL,5FH
JA ISFNM_NODEC2
CLC
JMP ISFNM_OK
ISFNM_NODEC2:CMP AL,61H
JB ISFNM_NOFNM
CMP AL,7AH
JA ISFNM_NOFNM
CLC
JMP ISFNM_OK
ISFNM_NOFNM:STC
ISFNM_OK:RET
ISFNM ENDP
ISDISPASC PROC
CMP AL,20H
JB ISDISPASC_NODISPASC
CMP AL,7EH
JA ISDISPASC_NODISPASC
CLC
JMP ISDISPASC_OK
ISDISPASC_NODISPASC:STC
ISDISPASC_OK:RET
ISDISPASC ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRFN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRFN1:CALL GETCH
CMP AL,CR
JZ GETSTRFN5
CMP AL,BACKSPACE
JNZ GETSTRFN4
CMP BX,0
JZ GETSTRFN2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRFN1
GETSTRFN2:CALL BELL
JMP GETSTRFN1
GETSTRFN4:CMP BX,78
JZ GETSTRFN2
CALL ISFNM
JC GETSTRFN2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRFN1
GETSTRFN5:CMP BX,1
JB GETSTRFN2
MOV AL,0
MOV [BX][DI+2],AL
INC BX
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRFN_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRFN ENDP
GETSTRDISP PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRDISP1:CALL GETCH
CMP AL,EOF
JZ GETSTRDISP6
CMP AL,CR
JZ GETSTRDISP5
CMP AL,BACKSPACE
JNZ GETSTRDISP4
CMP BX,0
JZ GETSTRDISP2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRDISP1
GETSTRDISP2:CALL BELL
JMP GETSTRDISP1
GETSTRDISP4:CMP BX,78
JZ GETSTRDISP2
CALL ISDISPASC
JC GETSTRDISP2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRDISP1
GETSTRDISP5:MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
JMP GETSTRDISP_OK
GETSTRDISP6:MOV WORD PTR [DI],BX
MOV AL,EOF
MOV [DI+1],AL
GETSTRDISP_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRDISP ENDP
WRITEFILE PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DX,OFFSET MESS_FNDST
CALL DISPMESS
MOV DI,OFFSET FNAME_DST
CALL GETSTRFN
MOV DX,OFFSET FNAME_DST
ADD DX,2
MOV CX,0
MOV AH,3CH
INT 21H
JNC WRITEFILE_CREAOKDST
WRITEFILE_CREAERRDST:MOV DX,OFFSET MESS_CREAERR
CALL DISPMESS
JMP WRITEFILE_OK
WRITEFILE_CREAOKDST:MOV HANDLE_DST,AX
WRITEFILE_RWBUF:MOV DI,OFFSET FILEBUF_RW
CALL GETSTRDISP
MOV AX,WORD PTR FILEBUF_RW
MOV AH,0
CMP AX,0
JZ WRITEFILE_RWFINISH
MOV CX,AX
MOV DX,OFFSET FILEBUF_RW
ADD DX,2
MOV BX,HANDLE_DST
MOV AH,40H
INT 21H
JC WRITEFILE_WRITERR
MOV AX,WORD PTR FILEBUF_RW
CMP AH,EOF
JZ WRITEFILE_RWFINISH
JMP WRITEFILE_RWBUF
WRITEFILE_WRITERR:MOV DX,OFFSET MESS_WRITERR
CALL DISPMESS
WRITEFILE_RWFINISH:MOV BX,HANDLE_DST
MOV AH,3EH
INT 21H
WRITEFILE_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
WRITEFILE ENDP
CSEG ENDS
END START
例3：写一个程序把文件2拼接到文件1上。
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
FILEBUF_RW DB 512 DUP (0)
FNAME_SRC DB 128 DUP (0)
FNAME_DST DB 128 DUP (0)
MESS_FNSRC DB 'Please input source filename:','$'
MESS_FNDST DB 'Please input destination filename:','$'
HANDLE_SRC DW 0
HANDLE_DST DW 0
MESS_OPENERR DB 'Can not open file',07H,'$'
MESS_READERR DB 'Reading error',07h,'$'
MESS_WRITERR DB 'Writing error',07H,'$'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL APPENDFILE
MOV AH,4CH
INT 21H
ISFNM PROC
CMP AL,2BH
JB ISFNM_NOFNM
CMP AL,3BH
JA ISFNM_NODEC1
CLC
JMP ISFNM_OK
ISFNM_NODEC1:CMP AL,41H
JB ISFNM_NOFNM
CMP AL,5FH
JA ISFNM_NODEC2
CLC
JMP ISFNM_OK
ISFNM_NODEC2:CMP AL,61H
JB ISFNM_NOFNM
CMP AL,7AH
JA ISFNM_NOFNM
CLC
JMP ISFNM_OK
ISFNM_NOFNM:STC
ISFNM_OK:RET
ISFNM ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRFN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRFN1:CALL GETCH
CMP AL,CR
JZ GETSTRFN5
CMP AL,BACKSPACE
JNZ GETSTRFN4
CMP BX,0
JZ GETSTRFN2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRFN1
GETSTRFN2:CALL BELL
JMP GETSTRFN1
GETSTRFN4:CMP BX,78
JZ GETSTRFN2
CALL ISFNM
JC GETSTRFN2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRFN1
GETSTRFN5:CMP BX,1
JB GETSTRFN2
MOV AL,0
MOV [BX][DI+2],AL
INC BX
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRFN_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRFN ENDP
APPENDFILE PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DX,OFFSET MESS_FNSRC
CALL DISPMESS
MOV DI,OFFSET FNAME_SRC
CALL GETSTRFN
MOV DX,OFFSET MESS_FNDST
CALL DISPMESS
MOV DI,OFFSET FNAME_DST
CALL GETSTRFN
MOV DX,OFFSET FNAME_SRC
ADD DX,2
MOV AX,3D00H
INT 21H
JNC APPENDFILE_OPENOKSRC
APPENDFILE_OPENERRSRC:MOV DX,OFFSET MESS_OPENERR
CALL DISPMESS
JMP APPENDFILE_OK
APPENDFILE_OPENOKSRC:MOV HANDLE_SRC,AX
MOV DX,OFFSET FNAME_DST
ADD DX,2
MOV AX,3D01H
INT 21H
JNC APPENDFILE_OPENOKDST
APPENDFILE_OPENERRDST:MOV BX,HANDLE_SRC
MOV AH,3EH
INT 21H
MOV DX,OFFSET MESS_OPENERR
CALL DISPMESS
JMP APPENDFILE_OK
APPENDFILE_OPENOKDST:MOV HANDLE_DST,AX
MOV BX,HANDLE_DST
XOR CX,CX
XOR DX,DX
MOV AX,4202H
INT 21H
APPENDFILE_RWBUF:MOV DX,OFFSET FILEBUF_RW
MOV CX,512
MOV BX,HANDLE_SRC
MOV AH,3FH
INT 21H
JC APPENDFILE_READERR
CMP AX,0
JZ APPENDFILE_RWFINISH
MOV CX,AX
MOV BX,HANDLE_DST
MOV AH,40H
INT 21H
JC APPENDFILE_WRITERR
JMP APPENDFILE_RWBUF
APPENDFILE_WRITERR:MOV DX,OFFSET MESS_WRITERR
CALL DISPMESS
JMP APPENDFILE_RWFINISH
APPENDFILE_READERR:MOV DX,OFFSET MESS_READERR
CALL DISPMESS
APPENDFILE_RWFINISH:MOV BX,HANDLE_SRC
MOV AH,3EH
INT 21H
MOV BX,HANDLE_DST
MOV AH,3EH
INT 21H
APPENDFILE_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
APPENDFILE ENDP
CSEG ENDS
END START
把两个文件合并成第三个文件
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
FILEBUF_RW DB 512 DUP (0)
FNAME_SOC DB 128 DUP (0)
FNAME_SRC DB 128 DUP (0)
FNAME_DST DB 128 DUP (0)
MESS_FNSOC DB 'Please input source1 filename:','$'
MESS_FNSRC DB 'Please input source2 filename:','$'
MESS_FNDST DB 'Please input destination filename:','$'
HANDLE_SOC DW 0
HANDLE_SRC DW 0
HANDLE_DST DW 0
MESS_OPENERR DB 'Can not open file',07H,'$'
MESS_READERR DB 'Reading error',07h,'$'
MESS_CREAERR DB 'Can not create file',07H,'$'
MESS_WRITERR DB 'Writing error',07H,'$'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL APPENDFILE
MOV AH,4CH
INT 21H
ISFNM PROC
CMP AL,2BH
JB ISFNM_NOFNM
CMP AL,3BH
JA ISFNM_NODEC1
CLC
JMP ISFNM_OK
ISFNM_NODEC1:CMP AL,41H
JB ISFNM_NOFNM
CMP AL,5FH
JA ISFNM_NODEC2
CLC
JMP ISFNM_OK
ISFNM_NODEC2:CMP AL,61H
JB ISFNM_NOFNM
CMP AL,7AH
JA ISFNM_NOFNM
CLC
JMP ISFNM_OK
ISFNM_NOFNM:STC
ISFNM_OK:RET
ISFNM ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRFN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRFN1:CALL GETCH
CMP AL,CR
JZ GETSTRFN5
CMP AL,BACKSPACE
JNZ GETSTRFN4
CMP BX,0
JZ GETSTRFN2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRFN1
GETSTRFN2:CALL BELL
JMP GETSTRFN1
GETSTRFN4:CMP BX,78
JZ GETSTRFN2
CALL ISFNM
JC GETSTRFN2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRFN1
GETSTRFN5:CMP BX,1
JB GETSTRFN2
MOV AL,0
MOV [BX][DI+2],AL
INC BX
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRFN_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRFN ENDP
APPENDFILE PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DX,OFFSET MESS_FNSOC
CALL DISPMESS
MOV DI,OFFSET FNAME_SOC
CALL GETSTRFN
MOV DX,OFFSET MESS_FNSRC
CALL DISPMESS
MOV DI,OFFSET FNAME_SRC
CALL GETSTRFN
MOV DX,OFFSET MESS_FNDST
CALL DISPMESS
MOV DI,OFFSET FNAME_DST
CALL GETSTRFN
MOV DX,OFFSET FNAME_SOC
ADD DX,2
MOV AX,3D00H
INT 21H
JNC APPENDFILE_OPENOKSOC
APPENDFILE_OPENERRSOC:MOV DX,OFFSET MESS_OPENERR
CALL DISPMESS
JMP APPENDFILE_OK
APPENDFILE_OPENOKSOC:MOV HANDLE_SOC,AX
MOV DX,OFFSET FNAME_SRC
ADD DX,2
MOV AX,3D00H
INT 21H
JNC APPENDFILE_OPENOKSRC
APPENDFILE_OPENERRSRC:MOV BX,HANDLE_SOC
MOV AH,3EH
INT 21H
MOV DX,OFFSET MESS_OPENERR
CALL DISPMESS
JMP APPENDFILE_OK
APPENDFILE_OPENOKSRC:MOV HANDLE_SRC,AX
MOV DX,OFFSET FNAME_DST
ADD DX,2
MOV CX,0
MOV AH,3CH
INT 21H
JNC APPENDFILE_CREAOKDST
APPENDFILE_CREAERRDST:MOV BX,HANDLE_SOC
MOV AH,3EH
INT 21H
MOV BX,HANDLE_SRC
MOV AH,3EH
INT 21H
MOV DX,OFFSET MESS_CREAERR
CALL DISPMESS
JMP APPENDFILE_OK
APPENDFILE_CREAOKDST:MOV HANDLE_DST,AX
APPENDFILE_RWBUFSOC:MOV DX,OFFSET FILEBUF_RW
MOV CX,512
MOV BX,HANDLE_SOC
MOV AH,3FH
INT 21H
JC APPENDFILE_READERR
CMP AX,0
JZ APPENDFILE_RWBUFSRC
MOV CX,AX
MOV BX,HANDLE_DST
MOV AH,40H
INT 21H
JC APPENDFILE_WRITERR
JMP APPENDFILE_RWBUFSOC
APPENDFILE_RWBUFSRC:MOV DX,OFFSET FILEBUF_RW
MOV CX,512
MOV BX,HANDLE_SRC
MOV AH,3FH
INT 21H
JC APPENDFILE_READERR
CMP AX,0
JZ APPENDFILE_RWFINISH
MOV CX,AX
MOV BX,HANDLE_DST
MOV AH,40H
INT 21H
JC APPENDFILE_WRITERR
JMP APPENDFILE_RWBUFSRC
APPENDFILE_WRITERR:MOV DX,OFFSET MESS_WRITERR
CALL DISPMESS
JMP APPENDFILE_RWFINISH
APPENDFILE_READERR:MOV DX,OFFSET MESS_READERR
CALL DISPMESS
APPENDFILE_RWFINISH:MOV BX,HANDLE_SOC
MOV AH,3EH
INT 21H
MOV BX,HANDLE_SRC
MOV AH,3EH
INT 21H
MOV BX,HANDLE_DST
MOV AH,3EH
INT 21H
APPENDFILE_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
APPENDFILE ENDP
CSEG ENDS
END START
题4.36写一个程序实现如下功能：把内存区域最低端的1K字节存放到文件MEM.DAT中。
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
FNAME_DST DB 128 DUP (0)
MESS_FNDST DB 'Please input destination filename:','$'
HANDLE_DST DW 0
MESS_CREAERR DB 'Can not create file',07H,'$'
MESS_WRITERR DB 'Writing error',07H,'$'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL WRITEFILE
MOV AH,4CH
INT 21H
ISFNM PROC
CMP AL,2BH
JB ISFNM_NOFNM
CMP AL,3BH
JA ISFNM_NODEC1
CLC
JMP ISFNM_OK
ISFNM_NODEC1:CMP AL,41H
JB ISFNM_NOFNM
CMP AL,5FH
JA ISFNM_NODEC2
CLC
JMP ISFNM_OK
ISFNM_NODEC2:CMP AL,61H
JB ISFNM_NOFNM
CMP AL,7AH
JA ISFNM_NOFNM
CLC
JMP ISFNM_OK
ISFNM_NOFNM:STC
ISFNM_OK:RET
ISFNM ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRFN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRFN1:CALL GETCH
CMP AL,CR
JZ GETSTRFN5
CMP AL,BACKSPACE
JNZ GETSTRFN4
CMP BX,0
JZ GETSTRFN2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRFN1
GETSTRFN2:CALL BELL
JMP GETSTRFN1
GETSTRFN4:CMP BX,78
JZ GETSTRFN2
CALL ISFNM
JC GETSTRFN2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRFN1
GETSTRFN5:CMP BX,1
JB GETSTRFN2
MOV AL,0
MOV [BX][DI+2],AL
INC BX
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRFN_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRFN ENDP
WRITEFILE PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DX,OFFSET MESS_FNDST
CALL DISPMESS
MOV DI,OFFSET FNAME_DST
CALL GETSTRFN
MOV DX,OFFSET FNAME_DST
ADD DX,2
MOV CX,0
MOV AH,3CH
INT 21H
JNC WRITEFILE_CREAOKDST
WRITEFILE_CREAERRDST:MOV DX,OFFSET MESS_CREAERR
CALL DISPMESS
JMP WRITEFILE_OK
WRITEFILE_CREAOKDST:MOV HANDLE_DST,AX
MOV CX,1024
MOV DX,0
MOV BX,HANDLE_DST
MOV AX,0
MOV DS,AX
MOV AH,40H
INT 21H
JC WRITEFILE_WRITERR
MOV AX,DSEG
MOV DS,AX
JMP WRITEFILE_RWFINISH
WRITEFILE_WRITERR:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESS_WRITERR
CALL DISPMESS
WRITEFILE_RWFINISH:MOV BX,HANDLE_DST
MOV AH,3EH
INT 21H
WRITEFILE_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
WRITEFILE ENDP
CSEG ENDS
END START
题4.37写一个程序实现如下功能：把内存区域最低端的1K字节作为256个双字，依次把每个双字转换为对应的8字节十六进制ASCIl码串，
顺序存放到文件MEM.TXT中，每存放一个8字节ASCII码串，再存放回车和换行符（ODH和0AH）。
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
FNAME_DST DB 128 DUP (0)
DIS_BUF DB 128 DUP (0)
HANDLE_DST DW 0
DIS_LEN DW 0
NUM_DX DW 0
NUM_CX DW 0
NUM_BX DW 0
NUM_AX DW 0
MESS_FNDST DB 'Please input destination filename:','$'
MESS_CREAERR DB 'Can not create file',07H,'$'
MESS_WRITERR DB 'Writing error',07H,'$'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL WRITEFILE
MOV AH,4CH
INT 21H
ISFNM PROC
CMP AL,2BH
JB ISFNM_NOFNM
CMP AL,3BH
JA ISFNM_NODEC1
CLC
JMP ISFNM_OK
ISFNM_NODEC1:CMP AL,41H
JB ISFNM_NOFNM
CMP AL,5FH
JA ISFNM_NODEC2
CLC
JMP ISFNM_OK
ISFNM_NODEC2:CMP AL,61H
JB ISFNM_NOFNM
CMP AL,7AH
JA ISFNM_NOFNM
CLC
JMP ISFNM_OK
ISFNM_NOFNM:STC
ISFNM_OK:RET
ISFNM ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRFN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRFN1:CALL GETCH
CMP AL,CR
JZ GETSTRFN5
CMP AL,BACKSPACE
JNZ GETSTRFN4
CMP BX,0
JZ GETSTRFN2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRFN1
GETSTRFN2:CALL BELL
JMP GETSTRFN1
GETSTRFN4:CMP BX,78
JZ GETSTRFN2
CALL ISFNM
JC GETSTRFN2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRFN1
GETSTRFN5:CMP BX,1
JB GETSTRFN2
MOV AL,0
MOV [BX][DI+2],AL
INC BX
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRFN_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRFN ENDP
HTOASC PROC
AND AL,0FH
ADD AL,30H
CMP AL,39H
JA HTOASC_NODEC
JMP HTOASC_OK
HTOASC_NODEC:ADD AL,7
HTOASC_OK:RET
HTOASC ENDP
AHTOASC PROC
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL HTOASC
XCHG AH,AL
CALL HTOASC
RET
AHTOASC ENDP
DDHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH AX
MOV AL,DH
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
MOV AL,DL
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
PUSH AX
XCHG AH,AL
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DDHTOASC ENDP
DDHTOBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV SI,WORD PTR DIS_LEN
PUSH AX
MOV AL,DH
CALL AHTOASC
MOV BYTE PTR DIS_BUF[SI],AH
INC SI
MOV BYTE PTR DIS_BUF[SI],AL
INC SI
MOV AL,DL
CALL AHTOASC
MOV BYTE PTR DIS_BUF[SI],AH
INC SI
MOV BYTE PTR DIS_BUF[SI],AL
INC SI
POP AX
PUSH AX
XCHG AH,AL
CALL AHTOASC
MOV BYTE PTR DIS_BUF[SI],AH
INC SI
MOV BYTE PTR DIS_BUF[SI],AL
INC SI
POP AX
CALL AHTOASC
MOV BYTE PTR DIS_BUF[SI],AH
INC SI
MOV BYTE PTR DIS_BUF[SI],AL
INC SI
MOV BYTE PTR DIS_BUF[SI],CR
INC SI
MOV BYTE PTR DIS_BUF[SI],LF
INC SI
MOV WORD PTR DIS_LEN,SI
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DDHTOBUF ENDP
WRITEFILE PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
MOV DX,OFFSET MESS_FNDST
CALL DISPMESS
MOV DI,OFFSET FNAME_DST
CALL GETSTRFN
MOV DX,OFFSET FNAME_DST
ADD DX,2
MOV CX,0
MOV AH,3CH
INT 21H
JNC WRITEFILE_CREAOKDST
WRITEFILE_CREAERRDST:MOV DX,OFFSET MESS_CREAERR
CALL DISPMESS
JMP WRITEFILE_OK
WRITEFILE_CREAOKDST:MOV HANDLE_DST,AX
MOV CX,256
MOV AX,0
MOV ES,AX
MOV BX,0
WRITEFILE_S:MOV NUM_CX,CX
MOV NUM_BX,BX
MOV DIS_LEN,0
MOV AX,ES:[BX]
MOV DX,ES:[BX+2]
CALL DDHTOBUF
MOV CX,DIS_LEN
MOV DX,OFFSET DIS_BUF
MOV BX,HANDLE_DST
MOV AH,40H
INT 21H
JC WRITEFILE_WRITERR
MOV BX,NUM_BX
INC BX
INC BX
INC BX
INC BX
MOV CX,NUM_CX
LOOP WRITEFILE_S
JMP WRITEFILE_RWFINISH
WRITEFILE_WRITERR:MOV DX,OFFSET MESS_WRITERR
CALL DISPMESS
WRITEFILE_RWFINISH:MOV BX,HANDLE_DST
MOV AH,3EH
INT 21H
WRITEFILE_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
WRITEFILE ENDP
CSEG ENDS
END START
显示顺序
MOV AX,ES:[BX]
MOV DX,ES:[BX+2]
BX+3、BX+2、BX+1、BX

CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
FNAME_DST DB 128 DUP (0)
DIS_BUF DB 128 DUP (0)
HANDLE_DST DW 0
DIS_LEN DW 0
NUM_DX DW 0
NUM_CX DW 0
NUM_BX DW 0
NUM_AX DW 0
MESS_FNDST DB 'Please input destination filename:','$'
MESS_CREAERR DB 'Can not create file',07H,'$'
MESS_WRITERR DB 'Writing error',07H,'$'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL WRITEFILE
MOV AH,4CH
INT 21H
ISFNM PROC
CMP AL,2BH
JB ISFNM_NOFNM
CMP AL,3BH
JA ISFNM_NODEC1
CLC
JMP ISFNM_OK
ISFNM_NODEC1:CMP AL,41H
JB ISFNM_NOFNM
CMP AL,5FH
JA ISFNM_NODEC2
CLC
JMP ISFNM_OK
ISFNM_NODEC2:CMP AL,61H
JB ISFNM_NOFNM
CMP AL,7AH
JA ISFNM_NOFNM
CLC
JMP ISFNM_OK
ISFNM_NOFNM:STC
ISFNM_OK:RET
ISFNM ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRFN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRFN1:CALL GETCH
CMP AL,CR
JZ GETSTRFN5
CMP AL,BACKSPACE
JNZ GETSTRFN4
CMP BX,0
JZ GETSTRFN2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRFN1
GETSTRFN2:CALL BELL
JMP GETSTRFN1
GETSTRFN4:CMP BX,78
JZ GETSTRFN2
CALL ISFNM
JC GETSTRFN2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRFN1
GETSTRFN5:CMP BX,1
JB GETSTRFN2
MOV AL,0
MOV [BX][DI+2],AL
INC BX
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRFN_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRFN ENDP
HTOASC PROC
AND AL,0FH
ADD AL,30H
CMP AL,39H
JA HTOASC_NODEC
JMP HTOASC_OK
HTOASC_NODEC:ADD AL,7
HTOASC_OK:RET
HTOASC ENDP
AHTOASC PROC
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL HTOASC
XCHG AH,AL
CALL HTOASC
RET
AHTOASC ENDP
DDHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH AX
MOV AL,DH
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
MOV AL,DL
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
PUSH AX
XCHG AH,AL
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DDHTOASC ENDP
DDHTOBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV SI,WORD PTR DIS_LEN
PUSH AX
MOV AL,DH
CALL AHTOASC
MOV BYTE PTR DIS_BUF[SI],AH
INC SI
MOV BYTE PTR DIS_BUF[SI],AL
INC SI
MOV AL,DL
CALL AHTOASC
MOV BYTE PTR DIS_BUF[SI],AH
INC SI
MOV BYTE PTR DIS_BUF[SI],AL
INC SI
POP AX
PUSH AX
XCHG AH,AL
CALL AHTOASC
MOV BYTE PTR DIS_BUF[SI],AH
INC SI
MOV BYTE PTR DIS_BUF[SI],AL
INC SI
POP AX
CALL AHTOASC
MOV BYTE PTR DIS_BUF[SI],AH
INC SI
MOV BYTE PTR DIS_BUF[SI],AL
INC SI
MOV BYTE PTR DIS_BUF[SI],CR
INC SI
MOV BYTE PTR DIS_BUF[SI],LF
INC SI
MOV WORD PTR DIS_LEN,SI
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DDHTOBUF ENDP
WRITEFILE PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
MOV DX,OFFSET MESS_FNDST
CALL DISPMESS
MOV DI,OFFSET FNAME_DST
CALL GETSTRFN
MOV DX,OFFSET FNAME_DST
ADD DX,2
MOV CX,0
MOV AH,3CH
INT 21H
JNC WRITEFILE_CREAOKDST
WRITEFILE_CREAERRDST:MOV DX,OFFSET MESS_CREAERR
CALL DISPMESS
JMP WRITEFILE_OK
WRITEFILE_CREAOKDST:MOV HANDLE_DST,AX
MOV CX,256
MOV AX,0
MOV ES,AX
MOV BX,0
WRITEFILE_S:MOV NUM_CX,CX
MOV NUM_BX,BX
MOV DIS_LEN,0
MOV AL,ES:[BX+3]
MOV AH,ES:[BX+2]
MOV DL,ES:[BX+1]
MOV DH,ES:[BX]
CALL DDHTOBUF
MOV CX,DIS_LEN
MOV DX,OFFSET DIS_BUF
MOV BX,HANDLE_DST
MOV AH,40H
INT 21H
JC WRITEFILE_WRITERR
MOV BX,NUM_BX
INC BX
INC BX
INC BX
INC BX
MOV CX,NUM_CX
LOOP WRITEFILE_S
JMP WRITEFILE_RWFINISH
WRITEFILE_WRITERR:MOV DX,OFFSET MESS_WRITERR
CALL DISPMESS
WRITEFILE_RWFINISH:MOV BX,HANDLE_DST
MOV AH,3EH
INT 21H
WRITEFILE_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
WRITEFILE ENDP
CSEG ENDS
END START
修改显示顺序
MOV AL,ES:[BX+3]
MOV AH,ES:[BX+2]
MOV DL,ES:[BX+1]
MOV DH,ES:[BX]
BX、BX+1、BX+2、BX+3
题4.38写一个能够显示当前工作目录下文件TEST.TXT长度的程序。改进程序使其可显示任一指定文件的长度，文件标识由键盘输入。
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
FNAME_SRC DB 128 DUP (0)
MESS_FNSRC DB 'Please input source filename:','$'
HANDLE_SRC DW 0
MESS_OPENERR DB 'Can not open file',07H,'$'
MESS_FILEPTRERR DB 'Can not get file length',07H,'$'
RES_DX DW 0
RES_CX DW 0
RES_BX DW 0
RES_AX DW 0
NUM_DX DW 0
NUM_CX DW 0
NUM_BX DW 0
NUM_AX DW 0
VAL_DX DW 0
VAL_CX DW 0
VAL_BX DW 0
VAL_AX DW 0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL DISPFILELEN
MOV AH,4CH
INT 21H
ISFNM PROC
CMP AL,2BH
JB ISFNM_NOFNM
CMP AL,3BH
JA ISFNM_NODEC1
CLC
JMP ISFNM_OK
ISFNM_NODEC1:CMP AL,41H
JB ISFNM_NOFNM
CMP AL,5FH
JA ISFNM_NODEC2
CLC
JMP ISFNM_OK
ISFNM_NODEC2:CMP AL,61H
JB ISFNM_NOFNM
CMP AL,7AH
JA ISFNM_NOFNM
CLC
JMP ISFNM_OK
ISFNM_NOFNM:STC
ISFNM_OK:RET
ISFNM ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRFN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRFN1:CALL GETCH
CMP AL,CR
JZ GETSTRFN5
CMP AL,BACKSPACE
JNZ GETSTRFN4
CMP BX,0
JZ GETSTRFN2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRFN1
GETSTRFN2:CALL BELL
JMP GETSTRFN1
GETSTRFN4:CMP BX,78
JZ GETSTRFN2
CALL ISFNM
JC GETSTRFN2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRFN1
GETSTRFN5:CMP BX,1
JB GETSTRFN2
MOV AL,0
MOV [BX][DI+2],AL
INC BX
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRFN_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRFN ENDP
DIVDD PROC
MOV NUM_DX,DX
MOV NUM_CX,CX
MOV NUM_BX,BX
MOV NUM_AX,AX
MOV RES_BX,DI
MOV RES_AX,SI
XOR AX,AX
MOV VAL_DX,AX
MOV VAL_CX,AX
MOV VAL_BX,AX
MOV VAL_AX,AX
MOV RES_DX,AX
MOV RES_CX,AX
XOR CX,CX
DIVDD_FORJ1:CMP CX,64
JAE DIVDD_FINISHJ1
CLC
RCL NUM_AX,1
RCL NUM_BX,1
RCL NUM_CX,1
RCL NUM_DX,1
RCL RES_CX,1
RCL RES_DX,1
PUSHF
POP BX
MOV AX,RES_CX
MOV DX,RES_DX
SUB AX,RES_AX
SBB DX,RES_BX
PUSHF
TEST BL,01H
JNZ DIVDD_A1
POPF
JNC DIVDD_A2
JMP DIVDD_B1
DIVDD_A1:POPF
DIVDD_A2:MOV RES_CX,AX
MOV RES_DX,DX
STC
RCL VAL_AX,1
RCL VAL_BX,1
RCL VAL_CX,1
RCL VAL_DX,1
JMP DIVDD_NEXTJ1
DIVDD_B1:CLC
RCL VAL_AX,1
RCL VAL_BX,1
RCL VAL_CX,1
RCL VAL_DX,1
DIVDD_NEXTJ1:INC CX
JMP DIVDD_FORJ1
DIVDD_FINISHJ1:MOV DX,VAL_DX
MOV CX,VAL_CX
MOV BX,VAL_BX
MOV AX,VAL_AX
MOV DI,RES_DX
MOV SI,RES_CX
RET
DIVDD ENDP
DDTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CMP DX,0
JNZ DDTOASC1
CMP CX,0
JNZ DDTOASC1
CMP BX,0
JNZ DDTOASC1
CMP AX,0
JNZ DDTOASC1
MOV AL,'0'
CALL PUTCH
JMP DDTOASC_OK
DDTOASC1:mov bp,0
divide_ddtoasc:cmp dx,0
jz finish_s_ddtoasc1
divide_s_ddtoasc:mov di,0
mov si,10
call divdd
inc bp
push si
jmp divide_ddtoasc
finish_s_ddtoasc1:cmp cx,0
jz finish_s_ddtoasc2
jmp divide_s_ddtoasc
finish_s_ddtoasc2:cmp bx,0
jz finish_s_ddtoasc3
jmp divide_s_ddtoasc
finish_s_ddtoasc3:cmp ax,0
jz finish_ddtoasc
jmp divide_s_ddtoasc
finish_ddtoasc:mov cx,bp
jcxz DDTOASC_OK
string_ddtoasc:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string_ddtoasc
DDTOASC_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DDTOASC ENDP
DISPFILELEN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DX,OFFSET MESS_FNSRC
CALL DISPMESS
MOV DI,OFFSET FNAME_SRC
CALL GETSTRFN
MOV DX,OFFSET FNAME_SRC
ADD DX,2
MOV AX,3D00H
INT 21H
JNC DISPFILELEN_OPENOKSRC
DISPFILELEN_OPENERRSRC:MOV DX,OFFSET MESS_OPENERR
CALL DISPMESS
JMP DISPFILELEN_OK
DISPFILELEN_OPENOKSRC:MOV HANDLE_SRC,AX
MOV BX,HANDLE_SRC
XOR CX,CX
XOR DX,DX
MOV AX,4202H
INT 21H
JC DISPFILELEN_FILEPTRERR
MOV BX,DX
MOV DX,0
MOV CX,0
CALL DDTOASC
CALL NEWLINE
JMP DISPFILELEN_RWFINISH
DISPFILELEN_FILEPTRERR:MOV DX,OFFSET MESS_FILEPTRERR
CALL DISPMESS
DISPFILELEN_RWFINISH:MOV BX,HANDLE_SRC
MOV AH,3EH
INT 21H
DISPFILELEN_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DISPFILELEN ENDP
CSEG ENDS
END START
题4.39写一个程序统计当前工作目录下文本文件TEST.TXT中的各十进制数字符和各英文字母的个数。
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
FILEBUF_RW DB 512 DUP (0)
FNAME_SRC DB 128 DUP (0)
MESS_FNSRC DB 'Please input source filename:','$'
HANDLE_SRC DW 0
MESS_OPENERR DB 'Can not open file',07H,'$'
MESS_READERR DB 'Reading error',07h,'$'
UPPERARRAY DD 32 DUP (0)
LOWERARRAY DD 32 DUP (0)
DIGITARRAY DD 32 DUP (0)
RES_DX DW 0
RES_CX DW 0
RES_BX DW 0
RES_AX DW 0
NUM_DX DW 0
NUM_CX DW 0
NUM_BX DW 0
NUM_AX DW 0
VAL_DX DW 0
VAL_CX DW 0
VAL_BX DW 0
VAL_AX DW 0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL SUMFILE
MOV AH,4CH
INT 21H
ISDIGIT PROC
CMP AL,'0'
JB ISDIGIT_NODIGIT
CMP AL,'9'
JA ISDIGIT_NODIGIT
CLC
JMP ISDIGIT_OK
ISDIGIT_NODIGIT:STC
ISDIGIT_OK:RET
ISDIGIT ENDP
ISUPPER PROC
CMP AL,'A'
JB ISUPPER_NOUPPER
CMP AL,'Z'
JA ISUPPER_NOUPPER
CLC
JMP ISUPPER_OK
ISUPPER_NOUPPER:STC
ISUPPER_OK:RET
ISUPPER ENDP
ISLOWER PROC
CMP AL,'a'
JB ISLOWER_NOLOWER
CMP AL,'z'
JA ISLOWER_NOLOWER
CLC
JMP ISLOWER_OK
ISLOWER_NOLOWER:STC
ISLOWER_OK:RET
ISLOWER ENDP
IDXDIGIT PROC
SUB AL,'0'
ADD AL,AL
ADD AL,AL
RET
IDXDIGIT ENDP
IDXUPPER PROC
SUB AL,'A'
ADD AL,AL
ADD AL,AL
RET
IDXUPPER ENDP
IDXLOWER PROC
SUB AL,'a'
ADD AL,AL
ADD AL,AL
RET
IDXLOWER ENDP
ISFNM PROC
CMP AL,2BH
JB ISFNM_NOFNM
CMP AL,3BH
JA ISFNM_NODEC1
CLC
JMP ISFNM_OK
ISFNM_NODEC1:CMP AL,41H
JB ISFNM_NOFNM
CMP AL,5FH
JA ISFNM_NODEC2
CLC
JMP ISFNM_OK
ISFNM_NODEC2:CMP AL,61H
JB ISFNM_NOFNM
CMP AL,7AH
JA ISFNM_NOFNM
CLC
JMP ISFNM_OK
ISFNM_NOFNM:STC
ISFNM_OK:RET
ISFNM ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRFN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRFN1:CALL GETCH
CMP AL,CR
JZ GETSTRFN5
CMP AL,BACKSPACE
JNZ GETSTRFN4
CMP BX,0
JZ GETSTRFN2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRFN1
GETSTRFN2:CALL BELL
JMP GETSTRFN1
GETSTRFN4:CMP BX,78
JZ GETSTRFN2
CALL ISFNM
JC GETSTRFN2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRFN1
GETSTRFN5:CMP BX,1
JB GETSTRFN2
MOV AL,0
MOV [BX][DI+2],AL
INC BX
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRFN_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRFN ENDP
DIVDD PROC
MOV NUM_DX,DX
MOV NUM_CX,CX
MOV NUM_BX,BX
MOV NUM_AX,AX
MOV RES_BX,DI
MOV RES_AX,SI
XOR AX,AX
MOV VAL_DX,AX
MOV VAL_CX,AX
MOV VAL_BX,AX
MOV VAL_AX,AX
MOV RES_DX,AX
MOV RES_CX,AX
XOR CX,CX
DIVDD_FORJ1:CMP CX,64
JAE DIVDD_FINISHJ1
CLC
RCL NUM_AX,1
RCL NUM_BX,1
RCL NUM_CX,1
RCL NUM_DX,1
RCL RES_CX,1
RCL RES_DX,1
PUSHF
POP BX
MOV AX,RES_CX
MOV DX,RES_DX
SUB AX,RES_AX
SBB DX,RES_BX
PUSHF
TEST BL,01H
JNZ DIVDD_A1
POPF
JNC DIVDD_A2
JMP DIVDD_B1
DIVDD_A1:POPF
DIVDD_A2:MOV RES_CX,AX
MOV RES_DX,DX
STC
RCL VAL_AX,1
RCL VAL_BX,1
RCL VAL_CX,1
RCL VAL_DX,1
JMP DIVDD_NEXTJ1
DIVDD_B1:CLC
RCL VAL_AX,1
RCL VAL_BX,1
RCL VAL_CX,1
RCL VAL_DX,1
DIVDD_NEXTJ1:INC CX
JMP DIVDD_FORJ1
DIVDD_FINISHJ1:MOV DX,VAL_DX
MOV CX,VAL_CX
MOV BX,VAL_BX
MOV AX,VAL_AX
MOV DI,RES_DX
MOV SI,RES_CX
RET
DIVDD ENDP
DDTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CMP DX,0
JNZ DDTOASC1
CMP CX,0
JNZ DDTOASC1
CMP BX,0
JNZ DDTOASC1
CMP AX,0
JNZ DDTOASC1
MOV AL,'0'
CALL PUTCH
JMP DDTOASC_OK
DDTOASC1:mov bp,0
divide_ddtoasc:cmp dx,0
jz finish_s_ddtoasc1
divide_s_ddtoasc:mov di,0
mov si,10
call divdd
inc bp
push si
jmp divide_ddtoasc
finish_s_ddtoasc1:cmp cx,0
jz finish_s_ddtoasc2
jmp divide_s_ddtoasc
finish_s_ddtoasc2:cmp bx,0
jz finish_s_ddtoasc3
jmp divide_s_ddtoasc
finish_s_ddtoasc3:cmp ax,0
jz finish_ddtoasc
jmp divide_s_ddtoasc
finish_ddtoasc:mov cx,bp
jcxz DDTOASC_OK
string_ddtoasc:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string_ddtoasc
DDTOASC_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DDTOASC ENDP
SUMFILE PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DX,OFFSET MESS_FNSRC
CALL DISPMESS
MOV DI,OFFSET FNAME_SRC
CALL GETSTRFN
MOV DX,OFFSET FNAME_SRC
ADD DX,2
MOV AX,3D00H
INT 21H
JNC SUMFILE_OPENOKSRC
SUMFILE_OPENERRSRC:MOV DX,OFFSET MESS_OPENERR
CALL DISPMESS
JMP SUMFILE_OK
SUMFILE_OPENOKSRC:MOV HANDLE_SRC,AX
SUMFILE_RWBUFSRC:MOV DX,OFFSET FILEBUF_RW
MOV CX,512
MOV BX,HANDLE_SRC
MOV AH,3FH
INT 21H
JC SUMFILE_READERR
CMP AX,0
JZ SUMFILE_RWFINISH
MOV BP,AX
MOV SI,0
SUMFILE_FORI1:CMP SI,BP
JAE SUMFILE_FINISHI1
MOV AL,FILEBUF_RW[SI]
CALL ISDIGIT
JC SUMFILE_NODIGIT
MOV AH,0
CALL IDXDIGIT
MOV DI,AX
MOV AX,WORD PTR DIGITARRAY[DI]
MOV DX,WORD PTR DIGITARRAY[DI+2]
ADD AX,1
ADC DX,0
MOV WORD PTR DIGITARRAY[DI],AX
MOV WORD PTR DIGITARRAY[DI+2],DX
JMP SUMFILE_NEXTI1
SUMFILE_NODIGIT:CALL ISUPPER
JC SUMFILE_NOUPPER
MOV AH,0
CALL IDXUPPER
MOV DI,AX
MOV AX,WORD PTR UPPERARRAY[DI]
MOV DX,WORD PTR UPPERARRAY[DI+2]
ADD AX,1
ADC DX,0
MOV WORD PTR UPPERARRAY[DI],AX
MOV WORD PTR UPPERARRAY[DI+2],DX
JMP SUMFILE_NEXTI1
SUMFILE_NOUPPER:CALL ISLOWER
JC SUMFILE_NEXTI1
MOV AH,0
CALL IDXLOWER
MOV DI,AX
MOV AX,WORD PTR LOWERARRAY[DI]
MOV DX,WORD PTR LOWERARRAY[DI+2]
ADD AX,1
ADC DX,0
MOV WORD PTR LOWERARRAY[DI],AX
MOV WORD PTR LOWERARRAY[DI+2],DX
SUMFILE_NEXTI1:INC SI
JMP SUMFILE_FORI1
SUMFILE_FINISHI1:JMP SUMFILE_RWBUFSRC
SUMFILE_READERR:MOV DX,OFFSET MESS_READERR
CALL DISPMESS
SUMFILE_RWFINISH:MOV BX,HANDLE_SRC
MOV AH,3EH
INT 21H
MOV BP,10
MOV SI,0
MOV DI,0
SUMFILE_FORJ1:CMP SI,BP
JAE SUMFILE_FINISHJ1
MOV AX,SI
ADD AL,'0'
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,':'
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AX,WORD PTR DIGITARRAY[DI]
MOV BX,WORD PTR DIGITARRAY[DI+2]
MOV CX,0
MOV DX,0
CALL DDTOASC
MOV AL,20H
CALL PUTCH
MOV AX,SI
INC AX
ADD AL,'0'
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,':'
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AX,WORD PTR DIGITARRAY[DI+4]
MOV BX,WORD PTR DIGITARRAY[DI+6]
MOV CX,0
MOV DX,0
CALL DDTOASC
CALL NEWLINE
SUMFILE_NEXTJ1:ADD SI,2
ADD DI,8
JMP SUMFILE_FORJ1
SUMFILE_FINISHJ1:MOV BP,26
MOV SI,0
MOV DI,0
SUMFILE_FORJ2:CMP SI,BP
JAE SUMFILE_OK
MOV AX,SI
ADD AL,'A'
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,':'
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AX,WORD PTR UPPERARRAY[DI]
MOV BX,WORD PTR UPPERARRAY[DI+2]
MOV CX,0
MOV DX,0
CALL DDTOASC
MOV AL,20H
CALL PUTCH
MOV AX,SI
INC AX
ADD AL,'A'
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,':'
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AX,WORD PTR UPPERARRAY[DI+4]
MOV BX,WORD PTR UPPERARRAY[DI+6]
MOV CX,0
MOV DX,0
CALL DDTOASC
MOV AL,20H
CALL PUTCH
MOV AX,SI
ADD AL,'a'
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,':'
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AX,WORD PTR LOWERARRAY[DI]
MOV BX,WORD PTR LOWERARRAY[DI+2]
MOV CX,0
MOV DX,0
CALL DDTOASC
MOV AL,20H
CALL PUTCH
MOV AX,SI
INC AX
ADD AL,'a'
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,':'
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AX,WORD PTR LOWERARRAY[DI+4]
MOV BX,WORD PTR LOWERARRAY[DI+6]
MOV CX,0
MOV DX,0
CALL DDTOASC
CALL NEWLINE
SUMFILE_NEXTJ2:ADD SI,2
ADD DI,8
JMP SUMFILE_FORJ2
SUMFILE_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
SUMFILE ENDP
CSEG ENDS
END START
验证按行读取文件GETLNBUF
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
FILEBUF_RW DB 512 DUP (0)
FNAME_SRC DB 128 DUP (0)
FNAME_DST DB 128 DUP (0)
MESS_FNSRC DB 'Please input source filename:','$'
MESS_FNDST DB 'Please input destination filename:','$'
HANDLE_SRC DW 0
HANDLE_DST DW 0
MESS_OPENERR DB 'Can not open file',07H,'$'
MESS_READERR DB 'Reading error',07h,'$'
MESS_CREAERR DB 'Can not create file',07H,'$'
MESS_WRITERR DB 'Writing error',07H,'$'
MESS_FILEPTRERR DB 'Can not adjust file pointer',07H,'$'
MESS_GETLNERR DB 'Reading one line error',07h,'$'
NUM_DX DW 0
NUM_CX DW 0
NUM_BX DW 0
NUM_AX DW 0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL COPYFILE
MOV AH,4CH
INT 21H
ISFNM PROC
CMP AL,2BH
JB ISFNM_NOFNM
CMP AL,3BH
JA ISFNM_NODEC1
CLC
JMP ISFNM_OK
ISFNM_NODEC1:CMP AL,41H
JB ISFNM_NOFNM
CMP AL,5FH
JA ISFNM_NODEC2
CLC
JMP ISFNM_OK
ISFNM_NODEC2:CMP AL,61H
JB ISFNM_NOFNM
CMP AL,7AH
JA ISFNM_NOFNM
CLC
JMP ISFNM_OK
ISFNM_NOFNM:STC
ISFNM_OK:RET
ISFNM ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRFN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRFN1:CALL GETCH
CMP AL,CR
JZ GETSTRFN5
CMP AL,BACKSPACE
JNZ GETSTRFN4
CMP BX,0
JZ GETSTRFN2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRFN1
GETSTRFN2:CALL BELL
JMP GETSTRFN1
GETSTRFN4:CMP BX,78
JZ GETSTRFN2
CALL ISFNM
JC GETSTRFN2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRFN1
GETSTRFN5:CMP BX,1
JB GETSTRFN2
MOV AL,0
MOV [BX][DI+2],AL
INC BX
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRFN_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRFN ENDP
GETLNBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV NUM_BX,BX
MOV NUM_DX,DX
MOV DI,DX
MOV WORD PTR [DI],0
ADD DX,2
MOV CX,256
MOV AH,3FH
INT 21H
JC GETLNBUF_READERR
CMP AX,0
JZ GETLNBUF_FINISH
MOV BP,AX
MOV BX,NUM_DX
MOV SI,0
MOV DI,0
GETLNBUF_FORI1:CMP SI,BP
JAE GETLNBUF_FINISHI1
MOV AL,[BX][DI+2]
CMP AL,LF
JZ GETLNBUF_NEXTI2
JMP GETLNBUF_NEXTI1
GETLNBUF_NEXTI2:INC SI
INC DI
JMP GETLNBUF_FINISHI1
GETLNBUF_NEXTI1:INC SI
INC DI
JMP GETLNBUF_FORI1
GETLNBUF_FINISHI1:MOV WORD PTR [BX],SI
CMP SI,BP
JAE GETLNBUF_FINISH
MOV DX,SI
SUB DX,BP
MOV CX,0FFFFH
MOV BX,NUM_BX
MOV AX,4201H
INT 21H
JC GETLNBUF_FILEPTRERR
JMP GETLNBUF_FINISH
GETLNBUF_READERR:MOV DX,OFFSET MESS_READERR
CALL DISPMESS
STC
JMP GETLNBUF_OK
GETLNBUF_FILEPTRERR:MOV DX,OFFSET MESS_FILEPTRERR
CALL DISPMESS
STC
JMP GETLNBUF_OK
GETLNBUF_FINISH:CLC
GETLNBUF_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
GETLNBUF ENDP
COPYFILE PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DX,OFFSET MESS_FNSRC
CALL DISPMESS
MOV DI,OFFSET FNAME_SRC
CALL GETSTRFN
MOV DX,OFFSET MESS_FNDST
CALL DISPMESS
MOV DI,OFFSET FNAME_DST
CALL GETSTRFN
MOV DX,OFFSET FNAME_SRC
ADD DX,2
MOV AX,3D00H
INT 21H
JNC COPYFILE_OPENOKSRC
COPYFILE_OPENERRSRC:MOV DX,OFFSET MESS_OPENERR
CALL DISPMESS
JMP COPYFILE_OK
COPYFILE_OPENOKSRC:MOV HANDLE_SRC,AX
MOV DX,OFFSET FNAME_DST
ADD DX,2
MOV CX,0
MOV AH,3CH
INT 21H
JNC COPYFILE_CREAOKDST
COPYFILE_CREAERRDST:MOV BX,HANDLE_SRC
MOV AH,3EH
INT 21H
MOV DX,OFFSET MESS_CREAERR
CALL DISPMESS
JMP COPYFILE_OK
COPYFILE_CREAOKDST:MOV HANDLE_DST,AX
COPYFILE_RWBUF:MOV DX,OFFSET FILEBUF_RW
MOV BX,HANDLE_SRC
CALL GETLNBUF
JC COPYFILE_READERR
MOV AX,WORD PTR FILEBUF_RW
CMP AX,0
JZ COPYFILE_RWFINISH
MOV CX,AX
MOV BX,HANDLE_DST
MOV DX,OFFSET FILEBUF_RW
ADD DX,2
MOV AH,40H
INT 21H
JC COPYFILE_WRITERR
JMP COPYFILE_RWBUF
COPYFILE_WRITERR:MOV DX,OFFSET MESS_WRITERR
CALL DISPMESS
JMP COPYFILE_RWFINISH
COPYFILE_READERR:MOV DX,OFFSET MESS_GETLNERR
CALL DISPMESS
COPYFILE_RWFINISH:MOV BX,HANDLE_SRC
MOV AH,3EH
INT 21H
MOV BX,HANDLE_DST
MOV AH,3EH
INT 21H
COPYFILE_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
COPYFILE ENDP
CSEG ENDS
END START
题4.40写一个能够比较文本文件的程序。设文本文件由若干行组成，文本行以回车符0DH和换行符0AH结束。
比较依行为单位进行。如果对应的两行不等，那么就显示这两行，并标上行号
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
FILEBUF_SOC DB 512 DUP (0)
FILEBUF_SRC DB 512 DUP (0)
FNAME_SOC DB 128 DUP (0)
FNAME_SRC DB 128 DUP (0)
FNAME_DST DB 128 DUP (0)
DIS_BUF DB 128 DUP (0)
MESS_FNSOC DB 'Please input source1 filename:','$'
MESS_FNSRC DB 'Please input source2 filename:','$'
MESS_FNDST DB 'Please input destination filename:','$'
HANDLE_SOC DW 0
HANDLE_SRC DW 0
HANDLE_DST DW 0
MESS_OPENERR DB 'Can not open file',07H,'$'
MESS_READERR DB 'Reading error',07h,'$'
MESS_CREAERR DB 'Can not create file',07H,'$'
MESS_WRITERR DB 'Writing error',07H,'$'
MESS_FILEPTRERR DB 'Can not adjust file pointer',07H,'$'
MESS_GETLNERR DB 'Reading one line error',07h,'$'
MESS_APPENDLNERR DB 'Writing one line error',07h,'$'
DIS_LEN DW 0
NUMLNO_D DW 0
NUMLNO_A DW 0
NUMLNR_D DW 0
NUMLNR_A DW 0
NUM_DX DW 0
NUM_CX DW 0
NUM_BX DW 0
NUM_AX DW 0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL CMPFILE
MOV AH,4CH
INT 21H
ISFNM PROC
CMP AL,2BH
JB ISFNM_NOFNM
CMP AL,3BH
JA ISFNM_NODEC1
CLC
JMP ISFNM_OK
ISFNM_NODEC1:CMP AL,41H
JB ISFNM_NOFNM
CMP AL,5FH
JA ISFNM_NODEC2
CLC
JMP ISFNM_OK
ISFNM_NODEC2:CMP AL,61H
JB ISFNM_NOFNM
CMP AL,7AH
JA ISFNM_NOFNM
CLC
JMP ISFNM_OK
ISFNM_NOFNM:STC
ISFNM_OK:RET
ISFNM ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRFN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRFN1:CALL GETCH
CMP AL,CR
JZ GETSTRFN5
CMP AL,BACKSPACE
JNZ GETSTRFN4
CMP BX,0
JZ GETSTRFN2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRFN1
GETSTRFN2:CALL BELL
JMP GETSTRFN1
GETSTRFN4:CMP BX,78
JZ GETSTRFN2
CALL ISFNM
JC GETSTRFN2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRFN1
GETSTRFN5:CMP BX,1
JB GETSTRFN2
MOV AL,0
MOV [BX][DI+2],AL
INC BX
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRFN_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRFN ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
DTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CMP DX,0
JNZ DTOASC1
CMP AX,0
JNZ DTOASC1
MOV AL,'0'
CALL PUTCH
JMP DTOASC_OK
DTOASC1:mov bp,0
divide_dtoasc:cmp dx,0
jz finish_s_dtoasc1
divide_s_dtoasc:mov cx,10
call divdw
inc bp
push cx
jmp divide_dtoasc
finish_s_dtoasc1:cmp ax,0
jz finish_dtoasc
jmp divide_s_dtoasc
finish_dtoasc:mov cx,bp
jcxz DTOASC_OK
string_dtoasc:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string_dtoasc
DTOASC_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOASC ENDP
DTOBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CMP DX,0
JNZ DTOBUF1
CMP AX,0
JNZ DTOBUF1
MOV SI,WORD PTR DIS_LEN
MOV BYTE PTR DIS_BUF[SI],'0'
INC SI
MOV WORD PTR DIS_LEN,SI
JMP DTOBUF_OK
DTOBUF1:MOV SI,WORD PTR DIS_LEN
mov bp,0
divide_dtobuf:cmp dx,0
jz finish_s_dtobuf1
divide_s_dtobuf:mov cx,10
call divdw
inc bp
push cx
jmp divide_dtobuf
finish_s_dtobuf1:cmp ax,0
jz finish_dtobuf
jmp divide_s_dtobuf
finish_dtobuf:mov cx,bp
jcxz DTOBUF_OK
string_dtobuf:pop bx
add bx,30h
MOV BYTE PTR DIS_BUF[SI],BL
INC SI
loop string_dtobuf
MOV WORD PTR DIS_LEN,SI
DTOBUF_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOBUF ENDP
GETLNBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV NUM_BX,BX
MOV NUM_DX,DX
MOV DI,DX
MOV WORD PTR [DI],0
ADD DX,2
MOV CX,256
MOV AH,3FH
INT 21H
JC GETLNBUF_READERR
CMP AX,0
JZ GETLNBUF_FINISH
MOV BP,AX
MOV BX,NUM_DX
MOV SI,0
MOV DI,0
GETLNBUF_FORI1:CMP SI,BP
JAE GETLNBUF_FINISHI1
MOV AL,[BX][DI+2]
CMP AL,LF
JZ GETLNBUF_NEXTI2
JMP GETLNBUF_NEXTI1
GETLNBUF_NEXTI2:INC SI
INC DI
JMP GETLNBUF_FINISHI1
GETLNBUF_NEXTI1:INC SI
INC DI
JMP GETLNBUF_FORI1
GETLNBUF_FINISHI1:MOV WORD PTR [BX],SI
CMP SI,BP
JAE GETLNBUF_FINISH
MOV DX,SI
SUB DX,BP
MOV CX,0FFFFH
MOV BX,NUM_BX
MOV AX,4201H
INT 21H
JC GETLNBUF_FILEPTRERR
JMP GETLNBUF_FINISH
GETLNBUF_READERR:MOV DX,OFFSET MESS_READERR
CALL DISPMESS
STC
JMP GETLNBUF_OK
GETLNBUF_FILEPTRERR:MOV DX,OFFSET MESS_FILEPTRERR
CALL DISPMESS
STC
JMP GETLNBUF_OK
GETLNBUF_FINISH:CLC
GETLNBUF_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
GETLNBUF ENDP
GETDISBUFO PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV SI,0
MOV BYTE PTR DIS_BUF[SI],CR
INC SI
MOV BYTE PTR DIS_BUF[SI],LF
INC SI
MOV BYTE PTR DIS_BUF[SI],'<'
INC SI
MOV WORD PTR DIS_LEN,SI
MOV DX,NUMLNO_D
MOV AX,NUMLNO_A
CALL DTOBUF
MOV SI,WORD PTR DIS_LEN
MOV BP,13
GETDISBUFO_FORI1:CMP SI,BP
JAE GETDISBUFO_FINISHI1
MOV BYTE PTR DIS_BUF[SI],20H
GETDISBUFO_NEXTI1:INC SI
JMP GETDISBUFO_FORI1
GETDISBUFO_FINISHI1:MOV BYTE PTR DIS_BUF[SI],'<'
INC SI
MOV WORD PTR DIS_LEN,SI
GETDISBUFO_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
GETDISBUFO ENDP
GETDISBUFR PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV SI,0
MOV BYTE PTR DIS_BUF[SI],CR
INC SI
MOV BYTE PTR DIS_BUF[SI],LF
INC SI
MOV BYTE PTR DIS_BUF[SI],'>'
INC SI
MOV WORD PTR DIS_LEN,SI
MOV DX,NUMLNR_D
MOV AX,NUMLNR_A
CALL DTOBUF
MOV SI,WORD PTR DIS_LEN
MOV BP,13
GETDISBUFR_FORI1:CMP SI,BP
JAE GETDISBUFR_FINISHI1
MOV BYTE PTR DIS_BUF[SI],20H
GETDISBUFR_NEXTI1:INC SI
JMP GETDISBUFR_FORI1
GETDISBUFR_FINISHI1:MOV BYTE PTR DIS_BUF[SI],'>'
INC SI
MOV WORD PTR DIS_LEN,SI
GETDISBUFR_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
GETDISBUFR ENDP
APPENDLNO PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CALL GETDISBUFO
MOV CX,DIS_LEN
MOV BX,HANDLE_DST
MOV DX,OFFSET DIS_BUF
MOV AH,40H
INT 21H
JC APPENDLNO_WRITERR
MOV CX,WORD PTR FILEBUF_SOC
MOV BX,HANDLE_DST
MOV DX,OFFSET FILEBUF_SOC
ADD DX,2
MOV AH,40H
INT 21H
JC APPENDLNO_WRITERR
JMP APPENDLNO_FINISH
APPENDLNO_WRITERR:MOV DX,OFFSET MESS_WRITERR
CALL DISPMESS
STC
JMP APPENDLNO_OK
APPENDLNO_FINISH:CLC
APPENDLNO_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
APPENDLNO ENDP
APPENDLNR PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CALL GETDISBUFR
MOV CX,DIS_LEN
MOV BX,HANDLE_DST
MOV DX,OFFSET DIS_BUF
MOV AH,40H
INT 21H
JC APPENDLNR_WRITERR
MOV CX,WORD PTR FILEBUF_SRC
MOV BX,HANDLE_DST
MOV DX,OFFSET FILEBUF_SRC
ADD DX,2
MOV AH,40H
INT 21H
JC APPENDLNR_WRITERR
JMP APPENDLNR_FINISH
APPENDLNR_WRITERR:MOV DX,OFFSET MESS_WRITERR
CALL DISPMESS
STC
JMP APPENDLNR_OK
APPENDLNR_FINISH:CLC
APPENDLNR_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
APPENDLNR ENDP
CMPLNBUFOR PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV AX,WORD PTR FILEBUF_SOC
MOV BX,WORD PTR FILEBUF_SRC
CMP AX,BX
JNZ CMPLNBUFOR_NZ
MOV SI,OFFSET FILEBUF_SOC
ADD SI,2
MOV DI,OFFSET FILEBUF_SRC
ADD DI,2
MOV BP,BX
MOV BX,0
CMPLNBUFOR_FORI1:CMP BX,BP
JAE CMPLNBUFOR_FINISHI1
MOV AL,DS:[SI]
CMP AL,DS:[DI]
JNZ CMPLNBUFOR_NZ
CMPLNBUFOR_NEXTI1:INC SI
INC DI
INC BX
JMP CMPLNBUFOR_FORI1
CMPLNBUFOR_FINISHI1:CLC
JMP CMPLNBUFOR_OK
CMPLNBUFOR_NZ:STC
CMPLNBUFOR_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
CMPLNBUFOR ENDP
CMPFILE PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DX,OFFSET MESS_FNSOC
CALL DISPMESS
MOV DI,OFFSET FNAME_SOC
CALL GETSTRFN
MOV DX,OFFSET MESS_FNSRC
CALL DISPMESS
MOV DI,OFFSET FNAME_SRC
CALL GETSTRFN
MOV DX,OFFSET MESS_FNDST
CALL DISPMESS
MOV DI,OFFSET FNAME_DST
CALL GETSTRFN
MOV DX,OFFSET FNAME_SOC
ADD DX,2
MOV AX,3D00H
INT 21H
JNC CMPFILE_OPENOKSOC
CMPFILE_OPENERRSOC:MOV DX,OFFSET MESS_OPENERR
CALL DISPMESS
JMP CMPFILE_OK
CMPFILE_OPENOKSOC:MOV HANDLE_SOC,AX
MOV DX,OFFSET FNAME_SRC
ADD DX,2
MOV AX,3D00H
INT 21H
JNC CMPFILE_OPENOKSRC
CMPFILE_OPENERRSRC:MOV BX,HANDLE_SOC
MOV AH,3EH
INT 21H
MOV DX,OFFSET MESS_OPENERR
CALL DISPMESS
JMP CMPFILE_OK
CMPFILE_OPENOKSRC:MOV HANDLE_SRC,AX
MOV DX,OFFSET FNAME_DST
ADD DX,2
MOV CX,0
MOV AH,3CH
INT 21H
JNC CMPFILE_CREAOKDST
CMPFILE_CREAERRDST:MOV BX,HANDLE_SOC
MOV AH,3EH
INT 21H
MOV BX,HANDLE_SRC
MOV AH,3EH
INT 21H
MOV DX,OFFSET MESS_CREAERR
CALL DISPMESS
JMP CMPFILE_OK
CMPFILE_CREAOKDST:MOV HANDLE_DST,AX
CMPFILE_RWBUFOR:MOV DX,OFFSET FILEBUF_SOC
MOV BX,HANDLE_SOC
CALL GETLNBUF
JC CMPFILE_READERR
MOV SI,WORD PTR FILEBUF_SOC
MOV DX,OFFSET FILEBUF_SRC
MOV BX,HANDLE_SRC
CALL GETLNBUF
JC CMPFILE_READERR
MOV DI,WORD PTR FILEBUF_SRC
CMP SI,0
JNZ CMPFILE_RWBUFOR1
CMP DI,0
JNZ CMPFILE_RWLNR
JMP CMPFILE_RWFINISH
CMPFILE_RWBUFOR1:CMP DI,0
JNZ CMPFILE_RWLNOR
JMP CMPFILE_RWLNO
CMPFILE_RWLNOR:MOV DX,NUMLNO_D
MOV AX,NUMLNO_A
ADD AX,1
ADC DX,0
MOV NUMLNO_D,DX
MOV NUMLNO_A,AX
MOV DX,NUMLNR_D
MOV AX,NUMLNR_A
ADD AX,1
ADC DX,0
MOV NUMLNR_D,DX
MOV NUMLNR_A,AX
CALL CMPLNBUFOR
JC CMPFILE_RWBUFOR2
JMP CMPFILE_RWBUFOR
CMPFILE_RWBUFOR2:CALL APPENDLNO
JC CMPFILE_WRITERR
CALL APPENDLNR
JC CMPFILE_WRITERR
JMP CMPFILE_RWBUFOR
CMPFILE_RWLNO:MOV DX,NUMLNO_D
MOV AX,NUMLNO_A
ADD AX,1
ADC DX,0
MOV NUMLNO_D,DX
MOV NUMLNO_A,AX
CALL APPENDLNO
JC CMPFILE_WRITERR
CMPFILE_S_RWLNO:MOV DX,OFFSET FILEBUF_SOC
MOV BX,HANDLE_SOC
CALL GETLNBUF
JC CMPFILE_READERR
MOV SI,WORD PTR FILEBUF_SOC
CMP SI,0
JZ CMPFILE_RWFINISH
MOV DX,NUMLNO_D
MOV AX,NUMLNO_A
ADD AX,1
ADC DX,0
MOV NUMLNO_D,DX
MOV NUMLNO_A,AX
CALL APPENDLNO
JC CMPFILE_WRITERR
JMP CMPFILE_S_RWLNO
CMPFILE_RWLNR:MOV DX,NUMLNR_D
MOV AX,NUMLNR_A
ADD AX,1
ADC DX,0
MOV NUMLNR_D,DX
MOV NUMLNR_A,AX
CALL APPENDLNR
JC CMPFILE_WRITERR
CMPFILE_S_RWLNR:MOV DX,OFFSET FILEBUF_SRC
MOV BX,HANDLE_SRC
CALL GETLNBUF
JC CMPFILE_READERR
MOV DI,WORD PTR FILEBUF_SRC
CMP DI,0
JZ CMPFILE_RWFINISH
MOV DX,NUMLNR_D
MOV AX,NUMLNR_A
ADD AX,1
ADC DX,0
MOV NUMLNR_D,DX
MOV NUMLNR_A,AX
CALL APPENDLNR
JC CMPFILE_WRITERR
JMP CMPFILE_S_RWLNR
CMPFILE_WRITERR:MOV DX,OFFSET MESS_APPENDLNERR
CALL DISPMESS
JMP CMPFILE_RWFINISH
CMPFILE_READERR:MOV DX,OFFSET MESS_GETLNERR
CALL DISPMESS
CMPFILE_RWFINISH:MOV BX,HANDLE_SOC
MOV AH,3EH
INT 21H
MOV BX,HANDLE_SRC
MOV AH,3EH
INT 21H
MOV BX,HANDLE_DST
MOV AH,3EH
INT 21H
CMPFILE_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
CMPFILE ENDP
CSEG ENDS
END START
题4.41请问BC或TC如何实现函数参数的传递？如何安排局部变量？
函数参数的传递方式是由右到左,当被调用的函数结束之后,由调用函数本身来清除堆栈上的参数数据。
通过把参数PUSH到栈，使用BP访问栈中的参数
通过调整SP，使用栈保存局部变量，也可以使用寄存器保存局部变量
void add(int, int, int);
main()
{
    int a = 1;
    int b = 2;
    int c = 0;
    add(a, b, c);
    c++;
}
void add(int a, int b, int c)
{
    c = a + b;
}

PUSH BP
MOV BP,SP
SUB SP,+02
PUSH SI
PUSH DI
MOV DI,0001
MOV WORD PTR [BP-02] ,0002
XOR SI,SI
PUSH SI
PUSH [BP-02]
PUSH DI
CALL 021E
ADD SP,+06
INC SI
POP DI
POP SI
MOV SP,BP
POP BP
RET
PUSH BP
MOV BP,SP
MOV AX,[BP+04]
ADD AX,[BP+06]
MOV [BP+08],AX
POP BP
RET

char a[5] = "BaSiC";
char b[5] = "MinIX";
main()
{
    int i;
    i = 0;
    do
    {
        a[i] = a[i] & 0xDF;
        b[i] = b[i] | 0x20;
        i++;
    }
    while(i < 5);
}
TC编译出来的程序使用DEBUG查看汇编代码
PUSH BP
MOV BP,SP
PUSH SI
XOR SI,SI
MOV AL,[SI+0194]
AND AL,DF
MOV [SI+0194],AL
MOV AL,[SI+0199]
OR AL,20
MOV [SI+0199],AL
INC SI
CMP SI,+05
JL 0200
POP SI
POP BP
RET

main()
{
    int a;
    int b;
    a = 2;
    a++;
    switch(a)
    {
    case 1:
        b = a + 1;
        break;
    case 2:
        b = a + 2;
        break;
    case 3:
        b = a + 3;
        break;
    default:
        b = a;
        break;
    }
    b++;
}
TC编译出来的程序使用DEBUG查看汇编代码
PUSH BP
MOV BP,SP
PUSH SI
PUSH DI
MOV SI,0002
INC SI
MOV AX,SI
CMP AX,0001
JZ 0216
CMP AX,0002
JZ 021B
CMP AX,0003
JZ 0221
JMP 0228
MOV DI,SI
INC DI
JMP 022C
MOV DI,SI
INC DI
INC DI
JMP 022C
MOV DI,SI
ADD DI,+03
JMP 022C
MOV DI,SI
JMP 022C
INC DI
POP DI
POP SI
POP BP
RET

main()
{
    int c = 0, k;
    for (k = 1; k < 3; k++)
    {
        switch(k)
        {
        default:
            c += k;
        case2:
            c++;
            break;
        case 4:
            c += 2;
            break;
        }
    }
    c++;
}
TC编译出来的程序使用DEBUG查看汇编代码
PUSH BP
MOV BP,SP
PUSH SI
PUSH DI
XOR SI,SI
MOV DI,0001
JMP 021E
MOV AX,DI
CMP AX,0002
JZ 0216
CMP AX,0004
JZ 0219
JMP 0214
ADD SI,DI
INC SI
JMP 021D
INC SI
INC SI
JMP 021D
INC DI
CMP DI,+03
JL 0206
INC SI
POP DI
POP SI
POP BP
RET
题4.42请问Turbo Pascal如何实现函数参数的传递？如何安排局部变量？
函数参数的传递方式是由左到右,当被调用的函数结束之后,由被调用函数来清除堆栈上的参数数据。
通过调整SP，使用栈保存局部变量，也可以使用寄存器保存局部变量
第5章输人输出与中断
通常用汇编语言编写与硬件关系密切的程序。输入输出和中断与硬件关系密切，所以相关的程序往往用汇编语言编写。
本章介绍输入输出与中断的基本概念，结合实例说明如何用汇编语言编写输入输出程序和中断处理程序。
5.1 输人和输出的基本概念
每种输入输出设备都要通过一个硬件接口或控制器和CPU相连。例如，打印机通过打印接口与系统相连；显示器通过显示控制器和系统相连。
从程序设计的角度看，接口由一组寄存器组成，是完成输入输出的桥梁。程序利用I/O指令，存取接口上的寄存器，获得外部设备的状态信息，
控制外部设备的动作，从而实现输入输出。
本章所说的输入和输出是站在处理器或主机立场上而言的，也即输入是指输入到处理器或主机，输出是指从处理器或主机输出。
5.1.1 I/O端口地址和I/O指令
1.I/O端口地址
为了存取接口上的寄存器，系统给这些寄存器分配专门的存取地址，这样的地址称为I/O端口地址。
在某些微型机上，I/O端口地址和存储单元地址统一编址。这相当于把I/O接口（设备）视为一个或几个存储单元，
利用存取内存单元的指令就可存取接口上的寄存器。但这会减少原本就有限的一部分存储空间，
同时由于访问内存的指令一般超过2字节.从而延长了外部设备与处理器进行数据交换的时间。
在以Intel的80x86家族处理器为CPU的系统中，I/O端口地址和存储单元的地址是各自独立的，分占两个不同的地址空间。
8086/8088提供的I/O端口地址空间达64K，因而可接64K个8位端口，或可接32K个16位端口。
但实际上，PC及其兼容机一般只使用0到3FFH之间的I/O端口地址，只占整个I/O端口地址空间的很小一部分。
2.I/O 指令
由于8086/8088的I/O端口地址和内存单元地址是独立的，所以要用专门的I/O指令来存取端口上的寄存器。
也就是说要用专门的I/O指令进行输入输出。I/O指令属于数据传送指令组。
（1）输入指令
输入指令的一般格式如下：IN 累加器,端口地址
输入指令从一个输入端口读取一个字节或一个字，传送至AL（若是一个字节）或AX（若是一个字）。
端口地址可采用直接方式表示，也可采用间接方式表示。
当采用直接方式表示端口地址时，端口地址仅为8位，即0~255；
当采用间接方式表示端口地址时，端口地址存放在DX寄存器中，端口地址可为16位。
所以输入指令有如下四种具体格式：
IN AL,PORT
IN AX,PORT            AH PORT+1 AL PORT
IN AL,DX
IN AX,DX                AH DX+1 AL DX
前两种格式是直接端口寻址，端口地址PORT是一个8位的立即数，例如：IN AL,21H
后两种是间接端口寻址，端口地址在寄存器DX中。当端口地址超过255时，只能采用DX间接端口寻址。
例如：MOV DX,2FCH
IN AX,DX
注意：当从端口n输入一个字时，相当于同时从端口n和n+1分别读取一个字节。
如果上述两条指令连续执行，相当于从端口2FCH输入一个字节送AL，从2FDH输入一个字节送AH。
（2）输出指令
输出指令的一般 格式如下：OUT 端口地址,累加器
输出指令将AL中的一个字节，或在AX中的一个字，输出到指定端口。
像输入指令一样，端口地址可采用直接方式表示，也可采用间接方式表示。
当采用直接方式表示端口地址时，端口地址仅为8位，即0~255；
当采用间接方式表示端口地址时，端口地址存放在DX寄存器中，端口地址可为16位。
所以输出指令也有如下四种具体格式：
OUT PORT,AL
OUT PORT,AX      PORT+1 AH PORT AL
OUT DX,AL
OUT DX,AX          DX+1 AH DX AL
注意：当向端口n输出一个字时，相当于向端口n输出AL中的内容和向端口n+1输出AH中的内容。
例如，下面的程序片段向2FCH端口输出23H，向2FDH端口输出45H：
MOV AX,4523H
MOV DX,2FCH
OUT DX,AX
5.1.2数据传送方式
1.CPU与外设之间交换的信息
CPU与外设之间交换的信息包括数据、控制和状态信息。尽管这三种信息具有不同性质，但它们都通过IN和OUT指令在数据总线上进行传送，
所以通常采用分配不同端口的方法将它们加以区别。
数据是CPU和外设真正要交换的信息。数据通常为8位或16位，可分为各种不同类型。不同的外设要传送的数据类型也是不同的。
控制信息输出到I/O接口，告诉接口和设备要做什么工作。
从接口输入的状态信息表示I/O设备当前的状态。在输入数据前，通常要先取得表示设备是否已准备好的状态信息；
在输出数据前，往往要先取得表示设备是否忙的状态信息。
2.数据传送方式
系统中数据传送的方式主要有：
（1）无条件传送方式
在不需要查询外设的状态，即已知外设已准备好或不忙时，可以直接使用IN或OUT指令实现数据传送。
这种方式软件实现简单，只要在指令中指明端口地址，就可选通指定外设进行输入输出。
无条件传送方式是方便的，但要求外设工作速度能与CPU同步，否则就可能出错。
例如，在外设还没有准备好的情况下，就用IN指令得到的数据就可能是不正确的数据。
（2）查询方式
查询传送方式适用于CPU与外设不同步的情况。输入之前，查询外设数据是否已准备好，若数据已准备好，则输入；
否则继续查询，直到数据准备好。输出之前，查询外设是否“忙”，若不“忙”，则输出；否则继续查询，直到不“忙”。
也就是说，要等待到外设准备好时才能输入或输出数据，而通常外设速度远远慢于CPU速度，于是查询过程就将花费大量的时间。
（3）中断方式
为了提高CPU的效率，可采用中断方式。当外设准备好时，外设向CPU发出中断请求，CPU转入中断处理程序，完成输入输出工作。
（4）直接存储器传送（DMA）方式
由于高速I/O设备（如磁盘机等）准备数据的时间短，要求传送速度快等特点，所以一般采用直接存储器传送方式，
即高速设备与内存储器直接交换数据。这种方式传送数据是成组进行的。
其过程是：先把数据在高速外设中存放的起始位置、数据在内存储器中存放的起始地址、
传送数据长度等参数输出到连接高速外设的接口（控制器），然后启动高速外设，设备准备开始直接传送数据。
当高速外设直接传送准备好后，向处理机发送一个直接传送的请求信号，处理机以最短时间批准进行直接传送，并让出总线控制权，
高速外设在其控制器控制下交换数据。数据交换完毕后，由高速外设发出“完成中断请求”，并交回总线控制权。
处理机响应上述中断，由对应的中断处理程序对高速外设进行控制或对已经传送的数据进行处理，中断返回后，原程序继续运行。
5.1.3 存取RT/CMOS RAM
1.关于RT/CMOS RAM
在IBM PC/AT及其兼容机上均安装有一个RT/COMS RAM芯片，它是互补金属氧化物半导体随机存取存储器，
不仅可长期保存系统配置状况，而且记录包括世纪、年、月、日和时分秒在内的实时钟（Real Time Clock）信息。
RT/CMOS RAM作为一个I/O接口芯片，系统分配的I/O端口地址区为70H至7FH，通过IN和OUT指令可对其进行存取。
它共提供64个字节RAM单元，分配使用情况如表5.1所示。前14个字节用于实时钟，剩下的50个字节用于系统配置。
2.存取RT/CMOS RAM
在存取RT/CMOS RAM芯片内部的64个字节内容时，往往要分两步进行。
即先把要存取单元的地址送端口70H，然后再存取端口71H。
还需注意，14个记录实时钟信息的单元（位移0至0DH）的地址就是表中位移，其他单元的地址是表5.1所示位移上加80H。
汇编语言用符号“$”表示地址计数器的值。允许程序员在指令和伪指令中直接用符号$引用地址计数器的当前值。
（1）读操作代码片段如下：MOV AL,n
OUT 70H,AL
JMP $+2
IN AL,71H
（2）写操作代码片段如下：MOV AL,n
OUT 70H,AL
JMP $+2
MOV AL,m
OUT 71H,AL
需要指出，在对同一个I/O设备或端口相继发送I/O指令时，为确保I/O设备或端口有足够的电路恢复时间，
一般在I/O指令之间使用一条转移指令“JMP $+2”。该指令的动作是转移到下一条指令执行，其意义是延时，以满足I/O端口的需要。
3.CMOS RAM累加和检查
在对系统配置时，要对CMOS RAM的位移10H~2DH的系统配置信息按字节求累加和，其值存放在位移2E~2FH的单元中。
低字节存放在2EH单元中，高字节存放在2FH单元中。在系统加电自检时，将对CMOS RAM的位移10H~2DH单元的内容求和，
并与保存的累加和比较。若两者不等，则置诊断状态字节的第6位，表明累加和错。这往往会导致要求用户重新进行系统配置。
下面的程序片段进行累加和检查，在累加和错时设置诊断状态字节的位6。
CMOS_PORT EQU 70H
CMOS_BEGIN EQU 90H
CMOS_END EQU ADH
CHECK_SUM EQU AEH
DIAG_STATUS EQU 8EH
BAD_CKSUM EQU 40H
SUB BX,BX
MOV CL,CMOS_BEGIN
MOV CH,CMOS_END+1
SUB AH,AH
CMOS2:MOV AL,CL
OUT CMOS_PORT,AL
JMP $+2
IN AL CMOS_PORT+1
ADD BX,AX
INC CL
CMP CH,CL
JNZ CMOS2
MOV AL,CHECK_SUM+1
OUT CMOS_PORT,AL
JMP $+2
IN AL,CMOS_PORT+1
MOV AH,AL
MOV AL,CHECK_SUM
OUT CMOS_PORT,AL
JMP $+2
IN AL,CMOS_PORT+1
CMP AX,BX
JZ CMOS4
MOV AL,DIAG_STATUS
OUT CMOS_PORT,AL
JMP $+2
IN AL,CMOS PORT+1
MOV AH,AL
OR AH,BAD_CKSUM
MOV AL,DIAG_STATUS
OUT CMOS_PORT,AL
JMP $+2
MOV AL,AH
OUT CMOS_PORT+1,AL
CMOS4:
......
5.2 查询方式传送数据
本节在介绍查询传送方式概念后，举例说明查询传送方式的实现。
5.2.1查询传送方式
查询方式的基本思想是由CPU主动地通过输入输出指令查询指定的外部设备的当前状态，
若设备就绪，则立即与设备进行数据交换，否则循环查询。
具体地说，在输入之前，要查询外设的数据是否已准备好，直到外设把数据准备好后才输入；
在输出之前，要查询外设是否“忙”，直到外设不“忙”后才输出。查询传送方式适用于CPU与外设不同步的情况。
查询方式输入输出的示意流程如图5.1所示。
为了采用查询方式输入或输出，相应的外设（或接口）不仅要有数据寄存器，而且还要有状态寄存器，有些外设还有控制寄存器。
数据寄存器用来存放要传送的数据，状态寄存器用来存放表示设备所处状态的信息。
通常，在状态寄存器中有一个“就绪（Ready）”位或一个“忙（Busy）"位来反映外设是否已准备好。
在实际应用中，为防止设备因某种原因发生故障而无法就绪或空闲，从而导致CPU在无限循环之中，通常都设计一个等待超时值，
其值随设备而定。一旦设备在规定时间内还无法就绪或空闲，也中止循环查询过程。
如此，图5.1所示的流程图修改为图5.2所示的流程图。大多数情况下，等待超时值用查询次数表示，每查询一次，查询次数减一，
如果查询次数减到0，那么查询等待也就结束。
有时系统中同时有几个设备要求输入输出数据，那么对每个设备都可编写一段执行输入输出数据的程序，
然后轮流查询这些设备的状态寄存器中的就绪位，当某一设备准备好允许输入或输出数据时，就调用这个设备的I/O程序完成数据传送，
否则依次查询下一设备是否准备好。
查询方式的优点是：软硬件实现比较简单；当同时查询多个外设时，可以由程序安排查询的先后次序。
缺点是浪费了CPU原本可执行大量指令的时间。
5.2.2 读实时钟
RT/CMOS RAM的状态寄存器A的位7是计时更新标志位，为1表示实时钟正在计时，为0表示实时钟信息可用于读出。
所以，在读实时钟前，要判别该标志位是否为0。
下面的程序片段读实时种，并把读到的秒、分和时数保存到相应的变量中。
CMOS_PORT EQU 70H
CMOS_REGA EQU 0AH
UPDATE_F EQU 80H
CMOS_SEC EQU 00H
CMOS MIN EQU 02H
CMOS_HOUR EQU 04H
SECOND DB ?
MINUTE DB ?
HOUR DB ?
MOV AX,SEG SECOND
MOV DS,AX
UIP:MOV AL,CMOS_REGA
OUT CMOS_PORT,AL
JMP $+2
IN AL,CMOS_PORT+1
TEST AL,UPDATE_F
JNZ UIP
MOV AL,CMOS_SEC
OUT CMOS_PORT,AL
JMP $+2
IN AL,CMOS PORT+1
MOV SECOND,AL
MOV AL,CMOS_MIN
OUT CMOS_PORT,AL
JMP $+2
IN AL,CMOS_PORT+1
MOV MINUTE,AL
MOV AL,CMOS_HOUR
OUT CMOS_PORT,AL
JMP $+2
IN AL,CMOS PORT+1
MOV HOUR,AL
把更新标志位理解为状态寄存器中的“就绪”位，上面的程序片段采用查询方式检测是否就绪，但没有限制检测次数，符合如图5.1所示的流程。
5.2.3 查询方式打印输出
在IBM PC系列及其兼容机上，打印机通过打印接口（打印适配卡）连入系统。
打印接口的功能是传递打印命令和数据到打印机并返回打印机状态，为此它包含数据寄存器、状态寄存器和控制寄存器。
打印接口的状态寄存器和控制寄存器各位的定义如图5.3所示。
上述三个寄存器有各自的端口地址，并且三个端口地址是连续的。
设数据寄存器端口地址是378H，那么，状态寄存器端口地址是379H，控制寄存器端口地址是37AH。
在系统加电初始化期间，数据寄存器端口地址被保存到BIOS数据区。
在确定查询次数和取得数据寄存器端口地址后，利用查询方式打印一个字符的流程如图5.4所示。
首先输出打印数据，但此时打印机并未接受，随后读取状态信息，判打印机是否忙碌，一直等到打印机不忙碌，才向打印机发出选通命令。
下面的子程序实现了上述流程。
；子程序名：PRINT
；功能：打印一个字符
；入口参数：DX=数据寄存器端口地址
                     BL=超时参数
；                  AL=打印字符的代码
；出口参数：AH=打印机状态，各位意义如下：
；位0：1表示超时，即超过规定的查询次数；
；位1和位2：不用
；位3：1表示出错
；位4：1表示联机
；位5：1表示无纸
；位6：1表示应答  如果为1，表示打印机已经应答，准备好接受打印字符，如果为0，则表示打印机没有应答，不能打印字符
；位7：0表示忙碌
打印机状态为90H，位6为0表示打印机没有应答，不能打印字符
PRINT PROC
PUSH DX
PUSH AX
OUT DX,AL
INC DX
WAIT:XOR CX,CX
WAIT1:IN AL,DX
MOV AH,AL
TEST AL,80H
JNZ NEXT
LOOP WAIT1
DEC BL
JNZ WAIT
AND AH,0F8H
OR AH,1
JMP EXIT
NEXT:INC DX
MOV AL,0DH
OUT DX,AL
MOV AL,0CH
JMP $+2
OUT DX,AL
AND AH,0F8H
EXIT:XOR AH,48H
POP DX
MOV AL,DL
POP DX
RET
PRINT ENDP
在上面的子程序中，使用了一个超时参数，一个超时参数单位表示查询65536次，超时参数应根据系统具体情况而定。
在发出选通命令和复位选通之间使用了一条转移指令，该指令起延时作用，保证有足够的选通时间。
另外，为了使AH寄存器含有规定的出口参数，要取反应答位和错误位的值，所以在子程序结束前，用异或指令取反这两位。
5.3 中断
本节以PC系统为背景介绍中断的基本概念和8086/8088响应中断的过程。
5.3.1中断和中断传送方式
1.中断和中断源
中断是一种使CPU挂起正在执行的程序而转去处理特殊事件的操作。这些引起中断的事件称为中断源。
它们可能是来自外设的输入输出请求，例如，由按键引起的键盘中断，由串行口接收到信息引起的串行口中断等；
也可能是计算机的一些异常事件或其他的内部原因，例如：除数为0。
2.中断传送方式
中断传送方式的具体过程是：当CPU需要输入或输出数据时，先作一些必要的准备工作（有时包括启动外部设备），然后继续执行程序；
当外设完成一个数据的输入或输出后，则向CPU发出中断请求，CPU就挂起正在执行的程序，转去执行输入或输出操作，
在完成输入或输出操作后，返回原程序继续执行。中断传送方式是CPU和外部设备进行输入输出的有效方式，一直被大多数计算机所采用，
它可以避免因反复查询外部设备的状态而浪费时间，从而提高CPU的效率。不过，每中断一次，只传送一次数据，数据传送的效率并不高，
所以，中断传送方式一般用于低速外设。另外，与查询方式相比，中断传送方式实现比较复杂，对硬件的条件也较多。
5.3.2 中断向量表
1.中断向量表
IBM PC系列及其兼容机共能支持256种类型的中断，系统给每一种中断都安排一个中断类型号（简称为中断号），中断类型号依次为0~0FFH。
例如，属于外部中断的定时器中断类型号为08和键盘中断类型号为09。属于内部中断的除法出错中断类型号为0等等。
每种类型的中断都由相应的中断处理程序来处理，为了使系统在响应中断后，CPU能快速地转入对应的中断处理程序。
系统用一张表来保存这些中断处理程序的入口地址，该表就称为中断向量表。
中断向量表的每一项保存一个中断处理程序的入口地址，它相当于一个指向中断处理程序的指针，所以就称它为中断向量。
中断向量也依次编号为0~0FFH，n号中断向量就保存处理中断类型为n的中断处理程序的入口地址。
所以，一般不再区分中断类型号和中断向量号。中断向量表如图5.5所示，它被安排在内存最低端的1K字节空间中。
其中每个中断向量占用四个字节，前（低地址）两字节保存中断处理程序入口地址的偏移，
后（高地址）两字节保存中断处理程序入口地址的段值，所以含有256个中断向量的中断向量表需要占用1K字节内存空间。
按照上述中断向量表的结构和存放位置，根据中断向量号（或类型号）可方便地计算出中断向量所在单元的地址。
设中断向量号为n，则中断向量所在单元的开始地址是4*n
2.中断向量号的分配
在系统中，某个中断类型号分配给哪个中断，即某个中断向量含有哪个中断处理程序的入口地址有一些规定和约定。
应用程序不能违反规定，不宜不遵守约定。在IBM PC系列及其兼容机上，除保留给用户使用的60H~68H和F1H~FFH中断向量号外，
可以认为其他中断向量号已被分配。表5.2列出了部分中断向量号的分配情况。
顺便说一下，中断向量不一定非要指向中断处理程序，也可作为指向一组数据的指针。
例如，1DH号中断向量就指向显示器参数，1EH号中断向量指向软盘基数。
当然，如果中断向量m没有指向中断处理程序，那么就不应发生类型为m的中断。
3.设置和获取中断向量
在系统程序或应用程序由于某种需要而提供新的中断处理程序时，就要设置对应的中断向量，使其指向新的中断处理程序。
下面的程序片段直接设置n号中断向量，假设对应中断处理程序的入口标号是INTHAND：
......
MOV AX,0
MOV DS,AX
MOV BX,n*4
CLI
MOV WORD PTR [BX],OFFSET INTHAND
MOV WORD PTR [BX+2],SEG INTHAND
STI
在上面的程序片段中，使用了关中断指令CLI，目的是保证真正用于设置中断向量的两条传送指令能够连续执行。
在执行完前一条传送指令后，n号中断向量就暂时被破坏，既不指向原中断处理程序，也不指向新的中断处理程序，
如果此时发生类型为n的中断，那么就不能正确地转到中断处理程序执行，这是最糟糕的事了。
如果能确定当前是关中断状态，当然就不再需要使用该关中断指令，也不需要随后的开中断指令。
另外，如果能肯定在设置n号中断向量的过程中不发生类型为n的中断，那么可不考虑是否为关中断状态，
这种情况只有在对应的中断处理程序仅供应用程序自己使用时才有可能。
实际上，总是尽量避免采用上述直接设置中断向量的方法（有时是必须的），而是利用DOS提供的25H号系统功能调用来设置中断向量，
这可避免考虑许名细节
25H号系统功能调用是设置中断向量，其入口参数如下：AL=中断向量（类型）号
DS=中断处理程序入口地址的段值
DX=中断处理程序入口地址的偏移
下面的程序片段设置n号中断向量，假设对应中断处理程序入口标号是INTHAND：
......
MOV AX,SEG INTHAND
MOV DS,AX
MOV DX,OFFSET INTHAND
MOV AH,25H
MOV AL,n
INT 21H
有时需要取得中断向量。例如：在应用程序要用自已的中断处理程序代替系统中原有的某个中断处理程序时，
先要保存原中断向量，待应用程序结束时再恢复原中断向量。
下面的程序片段直接从中断向量表中取得n号中断向量，并且保存到双字变量OLDVECTOR中：
......
XOR AX,AX
MOV ES,AX
MOV AX,ES:[n*4]
MOV WORD PTR OLDVECTOR,AX
MOV AX,ES:[n*4+2]
MOV WORD PTR OLDVECTOR+2,AX
......
与利用DOS功能调用设置中断向量一样，实际上一般都利用DOS提供的35H号系统功能调用取得中断向量。
35H号系统调用的功能是获取中断向量，其出入口参数如下：入口参数：AL=中断向量（类型）号
出口参数：ES=中断处理程序入口地址的段值
BX=中断处理程序入口地址的偏移
下面的程序片段取得n号中断向量，并将其保存到双字变量OLDVECTOR中：
......
MOV AH,35H
MOV AL,N
INT 21H
MOV WORD PTR OLDVECTOR+2,ES
MOV WORD PTR OLDVECTOR,BX
......
5.3.3 中断响应过程
1.中断响应过程
通常CPU在执行完每一条指令后均要检测是否有中断请求。在有中断请求且满足一定系件时就响应中断，这个过程如图5.6所示。
在中断响应的过程中，由硬件自动完成如下工作：
（1）取得中断类型号；
（2）把标志寄存器内容压入堆栈；
（3）禁止外部中断和单步中断（使IF和TF标志位为0）；
（4）把下一条要执行指令的地址（中断返回地址）压入堆栈（CS和IP内容压入堆栈）；
（5）根据中断类型号从中断向量表中取中断处理程序入口地址；
（6）转入中断处理程序。
在CPU响应中断转入中断处理程序时，堆栈如图5.7所示。中断处理程序在最后从堆栈中弹出返回地址和原标志值结束中断，返回被中断程序。
2.中断返回指令
中断处理程序利用中断返回指令从堆栈中弹出返回地址和原标志值。
中断返回指令的格式如下：IRET
该指令的功能是从中断返回。具体操作如下所示：
IP←[SP]
SP=SP+2
CS←[SP]
SP=SP+2
FLAGS←[SP]
在执行中断返回指令IRET时的堆栈变化如图5.7（b）到（a）。
5.3.4 外部中断
由发生在CPU外部的某个事件引起的中断称为外部中断。如输入输出设备和协处理器等引起的中断就是外部中断。
外部中断以完全随机的方式中断现行程序。8086/8088有两条外部中断请求线：INTR接受可屏蔽中断请求，NMI接受非屏蔽中断请求。
1.可屏蔽中断
在IBM PC系列及其兼容机中，键盘和硬盘等外设的中断请求都通过中断控制器8259A传给可屏蔽中断请求线INTR，如图5.8所示，
中断控制器8259A共能接收8个独立的中断请求信号IRQ0至IRQ7。在AT机上，有两个中断控制器8259A，一主一从，
从8259A连接到主8259A的IRQ2上，这样AT系统就可接收15个独立的中断请求信号：
中断控制器8259A在控制外设中断方面起着重要的作用。如果接收到一个中断请求信号，并且满足一定的条件，
那么它就把中断请求信号传到CPU的可屏蔽中断请求线INTR。使CPU感知到有外部中断请求；同时也把相应的中断类型号送给CPU。
使CPU在响应中断时可根据中断类型号取得中断向量，转相应的中断处理程序。中断控制器8259A是可编程的，
也就是说可由程序设置它如何控制中断。在机器系统加电初始化期间，已对8259A进行过初始化。
在初始化时规定了在传出中断请求IRQ0至IRQ7时、送出的对应中断类型号分别是08H~0FH，请参见表5.2。
例如，设传出中断请求IRQ1，即传出键盘中断请求，那么送出的中断类型号为9，所以键盘中断的中断类型号为9，
键盘中断处理程序的入口地址存放在9号中断向量中。
从普通汇编语言程序设计者的角度看，中断控制器8259A包含两个寄存器：中断屏蔽寄存器和中断命令寄存器。
它们决定了传出一个中断请求信号的条件。中断屏蔽寄存器的I/O端口地址是21H，它的8位对应控制8个外部设备，
通过设置这个寄存器的某位为0或为1来允许或禁止相应外部设备中断。
当第i位为0时，表示允许传出来自IRQi的中断请求信号，当第i位为1时，表示禁止传出来自IRQi的中断请求信号。
中断屏蔽寄存器的内容称为中断屏蔽字。在PC系列及其兼容机上，中断屏蔽寄存器各位与对应外设的关系如图5.9所示。
例如：为了使中断控制器8259A只传出来自键盘的中断请求信号，可设置中断屏蔽字1111101B。程序片段如下：
MOV AL,11111101B
OUT 21H,AL
例如：下面的程序片段使中断屏蔽寄存器的位4为0.从而允许传出来自串行通信口2的中断请求信号：
IN AL,21H
AND AL,11101111B
OUT 21H,AL
从图5.6可知，尽管中断控制器把外设的中断请求信号由INTR传给CPU，但CPU是否响应还取决于中断允许标志IF。
如果IF为0，则CPU仍不响应由INTR传入的中断请求；只有在IF为1时，CPU才响应由INTR传入的中断请求。
所以，由INTR传入的外部中断请求称为可屏蔽的外部中断请求，由此引起的中断称为可屏蔽中断。
由于外设的中断请求均由INTR传给CPU，所以，当IF为0时，CPU不响应所有外设中断请求，当IF为1时，才响应外设中断请求。
CPU响应外设中断请求称为开中断（IF= 1），反之称为关中断（IF=0）。
CPU在响应中断时会自动关中断，从而避免在中断过程中再响应其他外设中断。
当然，程序员也可根据需要在程序中安排关中断指令CLI和开中断指令STI。
综上所述，在IBM PC系列及其兼容机中，所有的外设中断均是可屏蔽中断；
CPU响应某个外设中断请求的两个必要条件是：中断屏蔽寄存器中的相应位为0和处于开中断状态。
通过对这两个必要条件的控制，可使CPU响应某些外设中断请求，而不响应另外一些外设中断请求。
2.非屏蔽外部中断
从图5.6可知，当收到从NMI传来的中断请求信号时，不论是否处于开中断状态，CPU总会响应。
所以，由NMI传入的外部中断请求称为非屏蔽外部中断请求，由此而引起的中断称为非屏蔽中断。
不可屏蔽中断请求由电源掉电、存储器出错或者总线奇偶校验错等紧急故障产生，要求CPU及时处理。
在IBM PC系列及其兼容机上，非屏蔽中断的中断类型号规定为2。
CPU在响应非屏蔽中断请求时，总是转入由2号中断向量所指定的中断处理程序。
5.3.5 内部中断
由发生在CPU内部的某个事件引起的中断称为内部中断。由于内部中断是CPU在执行某些指令时产生，所以也称为软件中断。
其特点是：不需要外部硬件的支持：不受中断允许标志IF的控制。
1.中断指令INT引起的中断
中断指令的一般格式如下：INT n
其中，n是一个0~0FFH的立即数。
CPU在执行上面的中断指令后，便产生一个类型号为n的中断，从而转入对应的中断处理程序。
例如，为了调用DOS系统功能，就在程序中安排如下的中断指令：INT 21H
当CPU执行该指令后，就产生一个类型为21H的中断，从而转入对应的中断处理程序，也即转入DOS系统功能服务程序。
执行中断指令后的堆栈如图5.7所示。值得指出的是，程序员根据需要在程序中安排中断指令。所以它不会真正随机产生，而完全受程序控制。
2.CPU遇到特殊情况引起的中断
（1）除法错中断
在执行除法指令时，如果CPU发现除数为0或者商超过了规定的范围，那么就产生一个除法错中断。中断类型号规定为0。
例如，在执行下面的程序片段时，会产生一个0号类型的中断：
MOV AX,1234
MOV CL,3
DIV CL
商超过255（AL容纳不下）
为了避免产生0号类型的中断，可改写上述程序片段如下：
MOV AX,1234
MOV CL,3
XOR DX,DX
XOR CH,CH
DIV CX
（2）溢出中断
8086/8088提供一条专门检测运算溢出的指令，该指令的格式如下：INTO
在溢出标志OF置1时，如果执行该指令，则产生溢出中断。溢出中断的类型号规定为4。
如果溢出标志OF为0，则执行该指令后并不产生溢出中断。
3.用于程序调试的中断
（1）单步中断
如单步标志TF为1，则在每条指令执行后产生一个单步中断，中断类型号规定为1。
产生单步中断后，CPU就执行单步中断处理程序。由于CPU在响应中断时，已把TF置为0。
所以，不会以单步方式执行单步中断处理程序。通常由调试工具（如DEBUG等）把TF置1，
在执行完一条被调试程序的指令后，就转入单步中断处理程序，
一般情况下，单步中断处理程序报告各寄存器的当前内容，程序员可据此调试程序。
（2）断点中断
8086/8088提供一条特殊的中断指令“INT 3”，调试工具（如DEBUG等）可用它替换断点处的代码，
当CPU执行这条中断指令后，就产生类型号为3的中断。这种中断称为断点中断。
通常情况下断点中断处理程序恢复被替换的代码，并报告各寄存器的当前内容，程序员可据此调试程序。
所以说中断指令"INT 3”特殊是因为它只有一个字节长，其他的中断指令长2字节。
5.3.6 中断优先级和中断嵌套
1.中断优先级
系统中有多个中断源，当多个中断源同时向CPU请求中断时，CPU按系统设计时规定的优先级响应中断请求。
在IBM PC系列及其兼容机系统中，如图5.6所示，规定的优先级如下：
优先级最高 内部中断（除法错，INTO，INT）
↓                  非屏蔽中断（NMI）
↓                  可屏蔽中断（INTR）
最低             单步中断
如图5.8所示，外设的中断请求都通过中断控制器8259A传给CPU的INTR引线。
在对8259A初始化时规定了8个优先级。在正常的优先级方式下，优先级次序如下：IRQ0，IRQ1，IRQ2，IRQ3，IRQ4，1RQ5，IRQ6，IRQ7
但在必要的情况下，通过设置中断控制器8259A中的中断命令寄存器的有关位可改变上述优先级次序。
中断命令寄存器的I/O端口地址是20H，其各位的定义如图5.10所示。
其中的L2~L0三位指定IRQ0~IRQ7中具有最低优先级的中断请求，R位和SL位控制IRQ0~IRQ7的中断优先级的次序。
当R位和SL位全为0时，表示采用正常优先级方式，即上述优先级次序。在一般情况下，总采用这种正常优先级方式。
在以后的章节中，如无特别说明，外设中断的优先级次序是上述正常优先级次序。
中断命令寄存器中EOI位是中断结束位，当把它置为1时，表示当前中断处理结束。
在对中断控制器8259A初始化时规定，在CPU响应某个外设的中断请求后，中断控制器8259A不再传出中断级相同或较低的外设中断请求，
直到8259A接收到中断结束命令为止。例如：CPU在响应来自IRQ1的9号键盘中断后，8259A就不再传出来自IRQ1~IRQ7的外设中断请求，
直到通知8259A键盘中断已结束为止。所以，在外设中断处理程序结束时，要通知8259A中断已结束，
以便使8259A传出中断级相同或较低的外设中断请求，从而使CPU响应它们。下面程序片段通知8259A当前中断结束：
MOV AL,20H
OUT 20H,AL
注意，通知中断控制器8259A当前中断结束，并非中断返回。只有在执行了中断返回指令后，才返回被中断程序。
在对8259A初始化时作上述规定的理由是，使CPU在响应外设中断请求后，只要开中断，那么就可响应优先级高的外设中断请求，
而不会响应优先级相同或低的外设中断请求。
2.中断嵌套
CPU在执行中断处理程序时，又发生中断，这种情况称为中断嵌套。
在中断处理过程中，发生内部中断，引起中断嵌套是经常的事。例如：CPU在执行中断处理程序时，遇到软中断指令，就会引起中断嵌套。
在中断处理过程中，发生非屏蔽中断，也会引起中断嵌套。
由于CPU在响应中断的过程中，已自动关中断，所以，CPU也就不会再自动响应可屏蔽中断。
如果需要在中断处理过程的某些时候响应可屏蔽中断，那么可在中断处理程序中安排开中断指令，
CPU在执行开中断指令后，就处于开中断状态，也就可以响应可屏蔽中断了，直到再关中断。
所以，如果在中断处理程序中使用了开中断指令，也就可能会发生可屏蔽中断引起的中断嵌套。
8086/8088没有限制中断嵌套的深度（层次），但客观上受到堆栈容量的限制。
5.3.7中断处理程序的设计
CPU在响应中断后，自动根据中断类型，取中断向量并转入中断处理程序，所以，具体的处理工作由中断处理程序完成。
不同的中断处理，由不同的中断处理程序完成。对应外设中断的外设中断处理程序和对应指令中断的软中断处理程序有些区别，
下面对它们的设计分别作些原则性的介绍。
1.外设中断处理程序
在开中断的情况下，外设中断的发生是随机的，在设计外设中断处理程序时必须充分注意到这一点。外设中断处理程序的主要步骤如下：
（1）必须保护现场。这里的现场可理解为中断发生时CPU各内部寄存器的内容。
CPU在响应中断时，已把各标志和返回地址压入堆栈，所以要保护的现场主要是指通用寄存器的内容和除代码段寄存器外的
其他三个段寄存器的内容。因为中断的发生是随机的，所以凡是中断处理程序中要重新赋值的各寄存器的原有内容必须先预保护。
保护的一般方法是把它们压入堆栈。
（2）尽快完成中断处理。外设中断处理必须尽快完成，所以外设中断处理必须追求速度上的高效率。
因为在进行外设中断处理时，往往不再响应其它外设的中断请求。因此必须快，以免影响对其他外设的中断请求。
（3）恢复现场。在中断处理完成后，依次恢复被保护寄存器的原有内容。
（4）通知中断控制器中断已结束。如果应用需要，也可提早通知中断控制器中断结束，这样做必须考虑到外设中断的嵌套。
（5）利用IRET指令实现中断返回。
此外，应及时开中断。除非必要，中断处理程序应尽早开中断，以便CPU响应具有更高优先级的中断请求。
2.软中断处理程序
由中断指令引起的软件中断尽管是不可屏蔽的，但它不会随机发生，只有在CPU执行了中断指令后才会发生。
所以，中断指令类似于子程序调用指令，相应的软中断处理程序在很大程度上类似于子程序，但并不等同于子程序。
软中断处理程序的主要步骤如下：
（1）考虑切换堆栈。由于软中断处理程序往往在开中断状态下执行，并且可能较复杂（要占用大量的堆栈空间），所以应该考虑切换堆栈。
切换堆栈对实现中断嵌套等均较为有利。
（2）及时开中断。开中断后，CPU就可响应可屏蔽的外设中断请求，或者说使外设中断请求可及时得到处理。
但要注意，如果该软中断程序要被外设中断处理程序“调用”。则是否要开中断或者何时开中断应另外考虑。
（3）应该保护现场。应该保护中断处理程序要重新赋值的寄存器原有内容。这样在使用软中断指令时，可不必考虑有关寄存器内容的保护问题。
（4）完成中断处理。但不必过分追求速度上的高效率，除非它是被外设中断处理程序“调用”的。
（5）恢复现场。依次恢复被保护寄存器的原内容。
（6）堆栈切换。如果在开始时切换了堆栈，那么也要再重新切换回原堆栈。
（7）一般利用IRET指令实现中断返回。
5.4基本输人输出系统BIOS
本节在介绍BIOS基本概念的基础上，介绍键盘输入、显示和打印输出三方面的BIOS及部分细节。
5.4.1基本输入输出系统BIOS概述
固化在ROM中的基本输入输出系统BIOS（Basic Input/Output System）包含了主要I/O设备的处理程序和许多常用例行程序，
它们一般以中断处理程序的形式存在。
例如：负责显示输出的显示I/O程序作为10H号中断处理程序存在，负责打印输出的打印I/O程序作为17H号中断处理程序存在，
而负责键盘输入的键盘I/O程序作为16H号中断处理程序存在。再如，获取内存容量的例行程序就作为12H号中断处理程序存在。
BIOS直接建立在硬件基础上。磁盘操作系统DOS（Disk Operating System）建立在BIOS的基础上，通过BIOS操纵控制硬件。
例如DOS调用BIOS显示I/O程序完成显示输出，调用打印I/O程序完成打印输出，调用键盘I/O程序完成键盘输入。
尽管DOS和BIOS都提供某些相同的功能，但它们之间的层次关系是明显的。应用程序，DOS、BIOS和外设接口之间的关系如图5.11所示，
通常应用程序应该调用DOS提供的系统功能完成输入输出或其他操作。这样做不仅实现容易，而且对硬件的依赖性最少。
但有时DOS不提供某种服务，例如，取打印机状态信息，那么就不能调用DOS实现了。应用程序可以通过BIOS进行输入输出或完成其他功能。
在下列三种场合可考虑调用BIOS：一是需要利用BIOS提供而DOS不提供的某个功能的场合；二是不能利用DOS功能调用的场合；
三是出于某种原因需要绕过DOS的场合。由于BIOS提供的设备处理程序和常用例行程序都以中断处理程序的形式存在，
所以应用程序调用BIOS较为方便。但BIOS毕竟比DOS更靠近硬件。应用程序也可以直接操纵外设接口来控制外设，从而获得速度上最高的效率，
但这样的应用程序不仅复杂而且与硬件关系十分密切，此外，还需要程序员对硬件性能比较了解熟悉。
所以，应用程序一般不直接与硬件发生关系。值得指出的是，有时应用程序需要扩充或替换ROM BIOS中的某些处理程序或例行程序，
那么这些新的BIOS程序原则上不能调用DOS提供的功能。
5.4.2 键盘输入
1.键盘中断处理程序
当用户按键时，键盘接口会得到一个代表被按键的键盘扫描码，同时产生一个中断请求。从图5.8和图5.9可知，
如果键盘中断是允许的（中断屏蔽字中的位1为0），并且CPU处于开中断状态（IF=1），那么CPU通常就会响应中断请求。
由于键盘中断的中断类型号安排为9，所以CPU响应键盘中断，就是转入9号中断处理程序。
我们把9号中断处理程序称为键盘中断处理程序，它属于外设中断处理程序这一类。
键盘中断处理程序首先从键盘接口取得代表被按键的扫描码，然后根据扫描码判定用户所按的键并作相应的处理，
最后通知中断控制器中断结束并实现中断返回。我们把键盘上的键简单地分成五种类型：
字符键（字母、数字和符号等），功能键（如F1和PgUp等），控制键（Ctrl、Alt和左右Shift），双态键（如NumLock和CapsLock等），
特殊请求键（如Printscreen等）。键盘中断处理程序对五种键的基本处理方法如下：如果用户按的是双态键，那么就设置有关标志，
在AT以上档次的系统上还要改变LED指示器状态。如果用户按的是控制键，那么就设置有关标志。如果用户按的是功能键，
那么就根据键盘扫描码和是否按下某些控制键（如Alt）确定系统扫描码，把系统扫描码和一个全0字节一起存入键盘缓冲区。
如果用户按的是字符键，那么就根据键盘扫描码和是否按下某些控制键（如Ctrl）确定系统扫描码，并且得出对应的ASCII码，
把系统扫描码和ASCII码一起存入键盘缓冲区。如果用户按的是特殊请求键，那么就产生一个相对应的动作。
例如用户按Printscreen键，那么就调用5H号中断处理程序打印屏幕。
2.键盘缓冲区
键盘缓冲区是一个先进先出的环形队列，结构和占用的内存区域如下：
BUFF_HEAD DW ?   0040：001AH
BUFF_TAIL DW ?     0040：001CH
KB_BUFFER DW 16 DUP (?) 0040：001EH~ 003DH
BUFF_HEAD和BUFF_TAIL是缓冲区的头指针和尾指针，当这两个指针相等时，表示缓冲区为空。
由于缓冲区本身长16个字，而存放一个键的扫描码和对应的ASCII码需要占用一个字，所以键盘缓冲区可实际存放15个键的扫描码和ASCII码。
键盘中断处理程序把所按字符键或功能键的扫描码和对应的ASCII码（如为功能键，对应的ASCII码理解为0）依次存入键盘缓冲区。
如缓冲区已满，则不再存入，而是发出“嘟”的一声。
顺便说一下，键盘中断处理程序根据控制键和双态键建立的标志在内存单元0040：0017字单元中。
3、键盘I/O程序
尽管系统程序和应用程序可从键盘缓冲区中取得用户所按键的代码，但除非特殊情况，一般不宜直接存取键盘缓冲区，
而应调用BIOS提供的键盘I/O程序。键盘I/O程序以16H号中断处理程序的形式存在，它属于软中断处理程序这一类。
它的主要功能是进行键盘输入。一般情况下，系统程序和应用程序的键盘输入最后都是调用它完成的。
简单的键盘I/O程序从键盘缓冲区中取出所按键的ASCII码和扫描码返回给调用者。
键盘中断程序、键盘缓冲区和键盘I/O程序之间的关系如图5.12所示。
4.键盘I/O程序的功能和调用方法
键盘I/O程序提供的主要功能列于表5.3，每一个功能有一个编号。在调用键盘I/O程序时，把功能编号置入AH寄存器，
然后发出中断指令“INT 16H”。调用返回后，从有关寄存器中取得出口参数。除保存出口参数的寄存器外，其他寄存器内容保持不变。
我们把控制键和双态键统称为变换键，调用键盘I/O程序的2号功能可获得各变换键的状态。
奕换键状态字节各位的定义如图5.13所示，其中高四位记录双态键的变换情况，每按一下双态键，则对应的位值取反；
低四位反映控制键是否正被按下，按着某个控制键时，对应的位为1。
下面的程序片段从键盘读一个字符：
MOV AH,0
INT 16H
如果键盘缓冲区中有字符，那么中断处理就会极快结束，即调用就会极快返回，读到的字符是调用发出之前用户按下的字符。
如果键盘缓冲区空，那么要等待用户按键后调用才会返回，读到的字符是调用发出之后按下的字符。
如果程序员出于某种理由，要从键盘取得在调用发出之后用户按下的字符，那么就要先清除键盘缓冲区。
下面的程序片段先清除键盘缓冲区，然后再从键盘读一个字符：
......
AGAIN:MOV AH,1
INT 16H
JZ NEXT
MOV AH,0
INT 16H
JMP AGAIN
NEXT:MOV AH,0
INT 16H
......
当然，程序员也可通过直接修改键盘缓冲区头指针的方法清除键盘缓冲区，但我们不鼓励这样做。
例1：写一个程序完成如下功能：读键盘，并把所按键盘显示出来，在检测到按下SHIFT键后，就结束运行。
调用键盘I/O程序的2号功能取得变换键状态字节，进而判断是否按下了SHIFT键。
在调用0号功能读键盘之前，先调用1号功能判键盘是否有键可读，否则会导致不能及时检测到用户按下的SHIFT。源程序如下：
；程序名：T5-1.ASM
；功能：（略）
；常量定义
L_SHIFT = 00000010B
R_SHIFT = 00000001B
CSEG SEGMENT
ASSUME CS:CSEG
START:MOV AH,2
INT 16H
TEST AL,L_SHIFT+ R_SHIFT
JNZ OVER
MOV AH,1
INT 16H
JZ START
MOV AH,0
INT 16H
MOV DL,AL
MOV AH,6
INT 21H
JMP START
OVER:MOV AH,4CH
INT 21H
CSEG ENDS
END START
测试通过的完整程序如下
L_SHIFT = 00000010B
R_SHIFT = 00000001B
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG
START:MOV AH,2
INT 16H
TEST AL,L_SHIFT + R_SHIFT
JNZ OVER
MOV AH,1
INT 16H
JZ START
MOV AH,0
INT 16H
MOV DL,AL
MOV AH,6
INT 21H
JMP START
OVER:MOV AH,4CH
INT 21H
CSEG ENDS
END START
5.4.3 显示输出
显示器通过显示适配卡与系统相连，显示适配卡是显示输出的接口。早先的显示适配卡是CGA和EGA等，
目前常用的显示适配卡是VGA和TVGA等。它们都支持两类显示方式：文本显示方式和图形显示方式。每一类显示方式还含有多种显示模式。
1.文本显示方式
所谓文本显示方式是指以字符为单位显示的方式。字符通常是指字母、数字、普通符号（如运算符号）和一些特殊符号（如菱形块和矩形块）。
通常0~3号显示模式为文本显示方式，它们之间的区别是每屏可显示的字符数和可使用的颜色数目不同。用得最普遍的是3号显示模式。
我们就以3号显示模式为代表作介绍。在3号文本显示模式下，显示器的屏幕被划分成80列25行，所以每一屏最多可显示2000（80X25）个字符。
我们用行号和列号组成的坐标来定位屏幕上的每个可显示位置，左上角的坐标规定为（0，0），向右增加列号，向下增加行号，
这样右下角的坐标便是（79，24）。如图5.15所示。
2.显示属性
屏幕上显示的字符取决于字符代码及字符属性。这里的属性是指显示属性。它规定字符显示时的特性。
在单色显示时，属性定义了闪烁、反相和高亮度等显示特性。在彩色显示时，属性还定义了前景色和背景色。
图5.14给出了彩色显示时属性字节各位的定义。
在属性字节中，RGB分别表示红、绿、蓝，I表示亮度，BL表示闪烁。
位0~位3组合16种前景颜色，位4~位6组合8种背景颜色。亮度和闪烁只能用于前景。
当I位为1时，表示高亮度，当I位为0时，表示普通亮度。当BL位为1时，表示闪烁，当BL位为0时，表示不闪烁。
表5.4给出了彩色文本模式下IRGB组合成的通常颜色。前景颜色和背景颜色一起确定字符的显示效果，表5.5列出了几种典型的属性值。
当前景和背景相同时，字符就看不出了。
3.显示存储区
显示适配卡带有显示存储器，用于存放屏幕上显示文本的代码及属性或图形信息。显示存储器作为系统存储器的一部分，
可用访问普通内存的方法访问显示存储器。通常，为显示存储器安排的存储地址空间的段值是B800H或B000H，
对应的内存区域就称为显示存储区。我们假设段值是B800H。
在3号文本显示模式下，屏幕上的每一个显示位置依次对应显示存储区中的两个字节单元，这种对应关系如图5.15所示。
为了在屏幕上某个位置显示字符，只需把要显示字符的代码及其属性填到显示存储区中的对应存储单元即可。
下面的程序片段实现在屏幕的左上角以黑底白字显示字符"A"：
......
MOV AX,B800H
MOV DS,AX
MOV BX,0
MOV AL,'A'
MOV AH,07H
MOV [BX],AX
......
为了了解屏幕上某个显示位置所显示的字符是什么，或显示的颜色是什么，
那么只要从显示存储区中的对应存储单元中取出字符的代码和属性即可。
下面的程序片段取得屏幕右下角所显示字符的代码及属性：
......
MOV AX,B800H
MOV DS,AX
MOV BX,(80*24+79)*2
MOV AX,[BX]
......
这种直接存取显示存储器进行显示的方法称为直接写屏。
例2：采用直接写屏法在屏幕上用多种属性显示字符串“HELLO”。
先用一种属性在屏幕上显示指定信息，然后在用户按一键后再换一种属性显示，如按ESC键，则结束。
其中的显示子程序ECHO采用了直接写屏方法实现显示。源程序如下：
；源程序名：T5-2.ASM
；功能：（略）
；子程序名：ECHO
；功 能：直接写屏显示字符串
；入口参数：DS:SI=字符串首地址 
                     CX=字符串长度
                     BL=属性 
                     DH=显示开始行号
                     DL=显示开始列号
ROW = 5
COLUM = 10
ESCKEY = 1BH
DSEG SEGMENT
MESS DB 'HELLO'
MESS_LEN = $ - OFFSET MESS
COLORB DB 07H,17H,0FH,70H,74H
COLORE LABEL BYTE
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DI,OFFSET COLORB-1
NEXTC:INC DI
CMP DI,OFFSET COLORE
JNZ NEXTE
MOV DI,OFFSET COLORB
NEXTE:MOV BL,[DI]
MOV SI,OFFSET MESS
MOV CX,MESS_LEN
MOV DH,ROW
MOV DL,COLUM
CALL ECHO
MOV AH,0
INT 16H
CMP AL,ESCKEY
JNZ NEXTC
MOV AX,4C00H
INT 21H
ECHO PROC
MOV AX,0B800H
MOV ES,AX
MOV AL,80
MUL DH
XOR DH,DH
ADD AX,DX
ADD AX,AX
XCHG AX,BX
MOV AH,AL
JCXZ ECHO2
ECHO1:MOV AL,[SI]
INC SI
MOV ES:[BX],AX
INC BX
INC BX
LOOP ECHO1
ECHO2:RET
ECHO ENDP
CSEG ENDS
END START
测试通过的完整程序如下
ROW = 5
COLUM = 10
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
MESS DB 'HELLO'
MESS_LEN = $ - OFFSET MESS
COLORB DB 07H,17H,0FH,70H,74H
COLORE LABEL BYTE
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DI,OFFSET COLORB-1
NEXTC:INC DI
CMP DI,OFFSET COLORE
JNZ NEXTE
MOV DI,OFFSET COLORB
NEXTE:MOV BL,[DI]
MOV SI,OFFSET MESS
MOV CX,MESS_LEN
MOV DH,ROW
MOV DL,COLUM
CALL SHOWSTR
MOV AH,0
INT 16H
CMP AL,ESCKEY
JNZ NEXTC
MOV AX,4C00H
INT 21H
SHOWSTR PROC
MOV AX,0B800H
MOV ES,AX
MOV AL,80
MUL DH
XOR DH,DH
ADD AX,DX
ADD AX,AX
XCHG AX,BX
MOV AH,AL
JCXZ SHOWSTR2
SHOWSTR1:MOV AL,[SI]
INC SI
MOV ES:[BX],AX
INC BX
INC BX
LOOP SHOWSTR1
SHOWSTR2:RET
SHOWSTR ENDP
CSEG ENDS
END START
4.显示I/O程序的功能和调用方法
利用直接写屏方法，程序可实现快速显示。但为了实现直接写屏，必须了解显示存储器占用存储空间的具体细节和
显示存储区与屏幕显示位置的对应关系，并且最终的程序也与显示适配卡相关。所以，除非追求显示速度，一般不采用直接写屏方法，
而是调用BIOS提供的显示I/O程序。
BIOS提供的显示I/O程序作为10H号中断处理程序存在。
显示I/O程序的主要功能列于表5.6，每一个功能有一个编号。在调用显示I/O程序的某个功能时，应根据要求设置好入口参数，
把功能编号置入AH寄存器，然后发出中断指令“INT 10H"。调用返回后，从有关寄存器中取得出口参数。
除保存出口参数的寄存器外，其他寄存器内容保持不变。
现就显示页号作些说明。为了支持屏幕上显示2000个字符，需要的显示存储器容量约为4KB。
如果显示存储器的容量为32KB，那么显示存储器可存放8屏显示内容。为此，把显示存储器再分成若干段，称为显示页。
调用显示I/O程序的5号功能，可选择当前显示页。通常，总是使用第0页。
5.举例
调用显示I/O程序的5号功能，可选择当前显示页。下面的程序片段选择第0页作为当前显示页：
......
MOV AL,0
MOV AH,5
INT 10H
......
如果要知道当前显示页号，则可调用显示I/O程序的0FH号功能，同时可知道当前显示模式和该模式下的最大显示列数，
下面的程序片段调用0FH号功能：
......
MOV AH,0FH
INT 10H
......
下面的程序片段调用显示I/O程序的9号功能在当前光标位置处显示指定属性的字符，但不移动光标：
MOV BH,0
MOV BL,47H
MOV CX,1
MOV AL,'A'
MOV AH,9
INT 10H
在窗口滚屏时，如果滚屏行数为0，就表示清除整个窗口。如果把整个屏幕作为窗口，那么就可实现清屏。
下面的程序假设屏幕为80列，它先清除屏幕，然后把光标定到左上角：
......
MOV CH,0
MOV CL,0
MOV DH,24
MOV DL,79
MOV BH,07
MOV AL,0
MOV AH,6
INT 10H
MOV BH,0
MOV DH,0
MOV DL,0
MOV AH,2
INT 10H
......
例3：写一个程序完成如下功能：在屏幕中间部位开出一个窗口，随后接收用户按键，并把按键字符显示在窗口的最底行，
当窗口底行显示满时，窗口内容就向上滚动一行；用户按Ctrl+C键时，结束运行。
调用显示I/O程序可方便地实现该程序。源程序如下：
；程序名：T5-3.ASM
；功能：（略）
WINWIDTH = 40
WINTOP = 8
WINLEFT = 20
WINBOTTOM = 17
WINRIGHT = WINLEFT + WINWIDTH - 1
COLOR = 74H
PAGEN = 0
CTRL_C = 03H
CSEG SEGMENT
ASSUME CS:CSEG
START:MOV AL,PAGEN
MOV AH,5
INT 10H
MOV CH,WINTOP
MOV CL,WINLEFT
MOV DH,WINBOTTOM
MOV DL,WINRIGHT
MOV BH,COLOR
MOV AL,0
MOV AH,6
INT 10H
MOV BH,PAGEN
MOV DH,WINBOTTOM
MOV DL,WINLEFT
MOV AH,2
INT 10H
NEXT:MOV AH,0
INT 16H
CMP AL,CTRL_C
JZ EXIT
MOV BH,PAGEN
MOV CX,1
MOV AH,0AH
INT 10H
INC DL
CMP DL,WINRIGHT+1
JNZ SETCUR
MOV CH,WINTOP
MOV CL,WINLEFT
MOV DH,WINBOTTOM
MOV DL,WINRIGHT
MOV BH,COLOR
MOV AL,1
MOV AH,6
INT 10H
MOV DL,WINLEFT
SETCUR:MOV BH,PAGEN
MOV AH,2
INT 10H
JMP NEXT
EXIT:MOV AX,4C00H
INT 21H
CSEG ENDS
END START
测试通过的完整程序如下
WINWIDTH = 40
WINTOP = 8
WINLEFT = 20
WINBOTTOM = 17
WINRIGHT = WINLEFT + WINWIDTH - 1
COLOR = 74H
PAGEN = 0
CTRL_C = 03H
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG
START:MOV AL,PAGEN
MOV AH,5
INT 10H
MOV CH,WINTOP
MOV CL,WINLEFT
MOV DH,WINBOTTOM
MOV DL,WINRIGHT
MOV BH,COLOR
MOV AL,0
MOV AH,6
INT 10H
MOV BH,PAGEN
MOV DH,WINBOTTOM
MOV DL,WINLEFT
MOV AH,2
INT 10H
NEXT:MOV AH,0
INT 16H
CMP AL,CTRL_C
JZ EXIT
MOV BH,PAGEN
MOV CX,1
MOV AH,0AH
INT 10H
INC DL
CMP DL,WINRIGHT+1
JNZ SETCUR
MOV CH,WINTOP
MOV CL,WINLEFT
MOV DH,WINBOTTOM
MOV DL,WINRIGHT
MOV BH,COLOR
MOV AL,1
MOV AH,6
INT 10H
MOV DL,WINLEFT
SETCUR:MOV BH,PAGEN
MOV AH,2
INT 10H
JMP NEXT
EXIT:MOV AX,4C00H
INT 21H
CSEG ENDS
END START
例4：调用显示I/O程序来实现程序T5-2.ASM中的显示子程序ECHO。
方法之一：调用I/O程序中的13H号功能直接显示字符串。源程序代码如下：
；子程序名：ECHOA
；功能：调用显示I/O程序的13H号功能显示字符串
；入口参数：DS:SI=字符串首地址
                     CX=字符串长度
                     BL=属性
                     DH=显示开始行号
                     DL=显示开始列号
；出口参数：无
ECHOA PROC
PUSH ES
PUSH BP
PUSH DS
POP ES
MOV BP,SI
MOV BH,0
MOV AL,0
MOV AH,13H
INT 10H
POP BP
POP ES
RET
ECHOA ENDP
测试通过的完整程序如下
ROW = 5
COLUM = 10
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
MESS DB 'HELLO'
MESS_LEN = $ - OFFSET MESS
COLORB DB 07H,17H,0FH,70H,74H
COLORE LABEL BYTE
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DI,OFFSET COLORB-1
NEXTC:INC DI
CMP DI,OFFSET COLORE
JNZ NEXTE
MOV DI,OFFSET COLORB
NEXTE:MOV BL,[DI]
MOV SI,OFFSET MESS
MOV CX,MESS_LEN
MOV DH,ROW
MOV DL,COLUM
CALL SHOWSTRA
MOV AH,0
INT 16H
CMP AL,ESCKEY
JNZ NEXTC
MOV AX,4C00H
INT 21H
SHOWSTR PROC
MOV AX,0B800H
MOV ES,AX
MOV AL,80
MUL DH
XOR DH,DH
ADD AX,DX
ADD AX,AX
XCHG AX,BX
MOV AH,AL
JCXZ SHOWSTR2
SHOWSTR1:MOV AL,[SI]
INC SI
MOV ES:[BX],AX
INC BX
INC BX
LOOP SHOWSTR1
SHOWSTR2:RET
SHOWSTR ENDP
SHOWSTRA PROC
PUSH ES
PUSH BP
PUSH DS
POP ES
MOV BP,SI
MOV BH,0
MOV AL,0
MOV AH,13H
INT 10H
POP BP
POP ES
RET
SHOWSTRA ENDP
CSEG ENDS
END START
该子程序与ECHO稍有不同：第一是13H号功能解释回车和换行等控制码，所以如果要显示的字符串中含有这样的控制码，
那么显示效果就会有差异；第二是当显示超出最后一行的最后一列时，13H功能要引起滚屏。
方法之二：先调用显示I/O程序的2号功能把光标定到指定位置，然后利用显示I/O程序的TTY显示功能逐个显示字符串中的字符。
但由于TTY方式显示不含属性，所以先调用9号功能把指定属性写到显示字符串的位置处。源程序代码如下：
；子程序名：ECHOB
；其他说明信息略
ECHO PROC
JCXZ ECHO2
MOV BH,0
MOV AH,2
INT 10H
MOV AL,20H
MOV AH,9
INT 10H
MOV AH,0EH
ECHO1:MOV AL,[SI]
INC SI
INT 10H
LOOP ECHO1
ECHO2:RET
ECHO ENDP
测试通过的完整程序如下
ROW = 5
COLUM = 10
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
MESS DB 'HELLO'
MESS_LEN = $ - OFFSET MESS
COLORB DB 07H,17H,0FH,70H,74H
COLORE LABEL BYTE
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DI,OFFSET COLORB-1
NEXTC:INC DI
CMP DI,OFFSET COLORE
JNZ NEXTE
MOV DI,OFFSET COLORB
NEXTE:MOV BL,[DI]
MOV SI,OFFSET MESS
MOV CX,MESS_LEN
MOV DH,ROW
MOV DL,COLUM
CALL SHOWSTRB
MOV AH,0
INT 16H
CMP AL,ESCKEY
JNZ NEXTC
MOV AX,4C00H
INT 21H
SHOWSTR PROC
MOV AX,0B800H
MOV ES,AX
MOV AL,80
MUL DH
XOR DH,DH
ADD AX,DX
ADD AX,AX
XCHG AX,BX
MOV AH,AL
JCXZ SHOWSTR2
SHOWSTR1:MOV AL,[SI]
INC SI
MOV ES:[BX],AX
INC BX
INC BX
LOOP SHOWSTR1
SHOWSTR2:RET
SHOWSTR ENDP
SHOWSTRA PROC
PUSH ES
PUSH BP
PUSH DS
POP ES
MOV BP,SI
MOV BH,0
MOV AL,0
MOV AH,13H
INT 10H
POP BP
POP ES
RET
SHOWSTRA ENDP
SHOWSTRB PROC
JCXZ SHOWSTRB2
MOV BH,0
MOV AH,2
INT 10H
MOV AL,20H
MOV AH,9
INT 10H
MOV AH,0EH
SHOWSTRB1:MOV AL,[SI]
INC SI
INT 10H
LOOP SHOWSTRB1
SHOWSTRB2:RET
SHOWSTRB ENDP
CSEG ENDS
END START
该子程序与ECHO也稍有不同：第一，TTY方式显示也解释控制符，所以如果要显示的字符串中含有控制符，则显示效果就不一样；
第二，是当TTY方式在屏幕的右下角显示一个字符后要上滚屏幕；第三是字符串显示完后，光标定位在字符串之后。
方法之三：先读取当前光标位置且保存；定位光标到指定位置；调用显示I/O程序的9号功能逐个显示字符，每显示一个字符后，
把光标向后移一个位置；最后把光标回到原位。注意，在把光标向后移一个位置时，要判别是否超越屏幕右边界和是否已到达屏幕的右下角。
请读者作为练习完成子程序ECHOC。
测试通过的完整程序如下
WINTOP = 0
WINLEFT = 0
WINBOTTOM = 24
WINRIGHT = 79
COLOR = 07H
ROW = 5
COLUM = 10
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
MESS DB 'HELLO'
MESS_LEN = $ - OFFSET MESS
COLORB DB 07H,17H,0FH,70H,74H
COLORE LABEL BYTE
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DI,OFFSET COLORB-1
NEXTC:INC DI
CMP DI,OFFSET COLORE
JNZ NEXTE
MOV DI,OFFSET COLORB
NEXTE:MOV BL,[DI]
MOV SI,OFFSET MESS
MOV CX,MESS_LEN
MOV DH,ROW
MOV DL,COLUM
CALL SHOWSTRC
MOV AH,0
INT 16H
CMP AL,ESCKEY
JNZ NEXTC
MOV AX,4C00H
INT 21H
SHOWSTR PROC
MOV AX,0B800H
MOV ES,AX
MOV AL,80
MUL DH
XOR DH,DH
ADD AX,DX
ADD AX,AX
XCHG AX,BX
MOV AH,AL
JCXZ SHOWSTR2
SHOWSTR1:MOV AL,[SI]
INC SI
MOV ES:[BX],AX
INC BX
INC BX
LOOP SHOWSTR1
SHOWSTR2:RET
SHOWSTR ENDP
SHOWSTRA PROC
PUSH ES
PUSH BP
PUSH DS
POP ES
MOV BP,SI
MOV BH,0
MOV AL,0
MOV AH,13H
INT 10H
POP BP
POP ES
RET
SHOWSTRA ENDP
SHOWSTRB PROC
JCXZ SHOWSTRB2
MOV BH,0
MOV AH,2
INT 10H
MOV AL,20H
MOV AH,9
INT 10H
MOV AH,0EH
SHOWSTRB1:MOV AL,[SI]
INC SI
INT 10H
LOOP SHOWSTRB1
SHOWSTRB2:RET
SHOWSTRB ENDP
ISDISPASC PROC
CMP AL,20H
JB ISDISPASC_NODISPASC
CMP AL,7EH
JA ISDISPASC_NODISPASC
CLC
JMP ISDISPASC_OK
ISDISPASC_NODISPASC:STC
ISDISPASC_OK:RET
ISDISPASC ENDP
SHOWSTRC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
MOV BP,SP
MOV BH,0
MOV AH,3
INT 10H
PUSH DX
MOV BX,WORD PTR [BP+12]
MOV CX,WORD PTR [BP+10]
MOV DX,WORD PTR [BP+8]
MOV BH,0
MOV AH,2
INT 10H
MOV DI,0
SHOWSTRC_FORI1:CMP DI,WORD PTR [BP+10]
JAE SHOWSTRC_FINISHI1
MOV AL,DS:[SI]
CALL ISDISPASC
JC SHOWSTRC_NEXTI1
MOV BH,0
MOV CX,1
MOV AH,9
INT 10H
INC DL
CMP DL,WINRIGHT
JBE SHOWSTRC_SETCUR
MOV DL,WINLEFT
INC DH
CMP DH,WINBOTTOM
JBE SHOWSTRC_SETCUR
MOV CH,WINTOP
MOV CL,WINLEFT
MOV DH,WINBOTTOM
MOV DL,WINRIGHT
MOV BH,COLOR
MOV AL,1
MOV AH,6
INT 10H
MOV DL,WINLEFT
SHOWSTRC_SETCUR:MOV BH,0
MOV AH,2
INT 10H
SHOWSTRC_NEXTI1:INC DI
INC SI
JMP SHOWSTRC_FORI1
SHOWSTRC_FINISHI1:POP DX
MOV BH,0
MOV AH,2
INT 10H
SHOWSTRC_OK:MOV SP,BP
POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
SHOWSTRC ENDP
CSEG ENDS
END START
5.4.4 打印输出
1.打印I/O程序的功能和调用方法
BIOS提供的打印I/O程序作为17H号中断处理程序存在。打印I/O程序的主要功能列于表5.7，每一个功能有一个编号。
系统可连接多台打印机，用打印机号选择打印机，打印机号为0、1和2。调用返回的出口参数只是打印机状态字节。
打印机状态，各位意义如下：
；位0：1表示超时
；位1和位2：不用
；位3：1表示出错
；位4：1表示联机
；位5：1表示无纸
；位6：1表示应答  如果为1，表示打印机已经应答，准备好接受打印字符，如果为0，则表示打印机没有应答，不能打印字符
；位7：0表示忙碌
打印机状态为90H，位6为0表示打印机没有应答，不能打印字符
打印机状态字节各位的定义类似与图5.3给出的打印接口中状态寄存器的定义，有两点区别：
（1）第0位定义成超时标志位，当打印机在规定时间内仍处于忙，即不能接受打印数据时，就置超时标志。
（2）第6位（应答位）和第3位（错误位）都规定状态有效为1（与状态寄存器的定义相反）。
在调用打印I/O程序的某个功能时，应根据要求设置好入口参数，把功能编号置入AH寄存器，然后发出中断指令“INT 17H”。
除保存出口参数的寄存器外，其他寄存器内容保持不变。通常系统只连接一台打印机，打印机号为0。
2.举例
例5：写一个在0号打印机上打印屏幕内容的程序。
程序流程如图5.16所示，现结合流程作些说明。为了把屏幕上的内容打印出来，先要获得屏幕上的显示内容，
这可利用显示I/O程序提供的8号功能实现。以行为单位从左到右打印屏幕上的内容，从顶行开始到底行结束，这样就形成一个二重循环。
在把一行屏幕内容输出到打印机后，追加输出一个回车符和一个换行符，使打印机实施打印动作。
在输出一个字符到打印机后，还判打印机是否正常工作，
判打印机是否正常工作的依据是测打印机状态字节中的超时标志、IO错误标志和纸尽标志。
由于要移动光标，所以在移动前先保存光标位置，最后恢复原光标位置。
；程序名：T5-4.ASM
；功能：打印屏幕内容
TIME_OUT = 00000001B
IO_ERROR = 00001000B
OUT_OF_P = 00100000B
FLAG = TIME_OUT + IO_ERROR + OUT_OF_P
NO_ACK = 01000000B
CSEG SEGMENT
MOV AH,0FH
INT 10H
MOV CL,AH
MOV CH,25
PUSH CX
MOV AH,3
INT 10H
POP CX
PUSH DX
XOR DX,DX
PRI1:MOV AH,2
INT 10H
MOV AH,8
INT 10H
OR AL,AL
JNZ PRI2
MOV AL,20H
PRI2:PUSH DX
XOR DX,DX
XOR AH,AH
INT 17H
POP DX
TEST AH,FLAG
JNZ ERR1
INC DL
CMP CL,DL
JNZ PRI1
PUSH DX
XOR DX,DX
MOV AX,0DH
INT 17H
MOV AX,0AH
INT 17H
POP DX
XOR DL,DL
INC DH
CMP CH,DH
JNZ PRI1
POP DX
MOV AH,2
INT 10H
JMP SHORT EXIT
ERR1:POP DX
MOV AH,2
INT 10H
ERR2:MOV AL,7
MOV AH,0EH
INT 10H
INT 10H
INT 10H
EXIT:MOV AH,4CH
INT 21H
CSEG ENDS
END START
BIOS提供的屏幕打印程序的实现方法和上述程序是相同的，只是作为5H号中断处理程序而存在。
5.5 软中断处理程序举例
本节以打印I/O程序和时钟显示程序的实现为例介绍软中断处理程序的设计。
5.5.1 打印I/O程序
我们在5.4.4节介绍了由BIOS提供的打印I/O程序的功能和调用方法。现在介绍打印I/O程序的源程序，把它作为BIOS中断处理程序设计的例子。
每个打印接口有三个寄存器：数据寄存器、状态寄存器和控制寄存器，它们的端口地址都是连续的，
在系统加电初始化期间，数据寄存器端口地址被依次保存到BIOS数据区，从40H段的偏移8处开始。
尽管通过中断控制器8259A可实现中断方式打印输出，但BIOS提供的打印I/O程序却采用在5.2.3节中介绍的查询方式实现打印输出。
查询时使用的超时参数也在BIOS数据区中，从40H段的偏移78H开始。
BIOS提供的打印I/O程序作为17H号中断处理程序存在。实现流程如图5.17所示。作为BIOS软中断处理程序，没有自己的堆栈，
而是使用主程序的堆栈。首先开中断，以便使CPU及时响应外设中断请求。然后保护要使用到的各寄存器内容。
再从BIOS数据区中取出指定打印机的数据寄存器端口地址，如端口地址值为0，表示没有安装指定的打印接口。
接下来根据功能号分情况处理。源程序如下所示：
CODE SEGMENT PUBLIC
ASSUME CS:CODE,DS:DATA
PRINT_TIM_OUT = 78H
PRINTER_BASE = 8
BIOS_DATA_SEG = 40H
PRINTER_IO PROC FAR
STI
PUSH DS
PUSH DX
PUSH SI
PUSH CX
PUSH BX
MOV BX,BIOS_DATA_SEG
MOV DS,BX
MOV SI,DX
MOV BL,PRINT_TIM OUT[SI]
SHL SI,1
MOV DX,PRINTER_BASE[SI]
OR DX,DX
JZ B1
OR AH,AH
JZ B2
DEC AH
JZ B8
DEC AH
JZ B5
B1:POP BX
POP CX
POP SI
POP DX
POP DS
IRET
B2:PUSH AX
OUT DX,AL
INC DX
PUSH BX
SUB BH,BH
RCL BX,1
RCL BX,1
B3:SUB CX,CX
B3_1:IN AL,DX
MOV AH,AL
TEST AL,80H
JNZ B4
LOOP B3_1
DEC BX
JNZ B3
POP BX
OR AH,1
AND AH,0F9H
JMP SHORT B7
B4:POP BX
MOV AL,0DH
INC DX
OUT DX,AL
MOV AL,0CH
JMP $+2
OUT DX,AL
POP AX
B5:PUSH AX
B6:MOV DX,PRINTER_BASE[SI]
INC DX
IN AL,DX
MOV AH,AL
AND AH,0F8H
B7:POP DX
MOV AL,DL
XOR AH,48H
JMP B1
B8:PUSH AX
INC DX
INC DX
MOV AL,8
OUT DX,AL
MOV AX,10000
B9:DEC AX
JNZ B9
MOV AL,0CH
OUT DX,AL
JMP B6
PRINTER_IO ENDP
CODE ENDS
END
上述17H号中断处理程序直接操纵控制打印接口，没有再调用其他程序。
5.5.2 时钟显示程序
在系统加电初始化其间，把系统定时器初始化为每隔约55毫秒发出一次中断请求。
据图5.9.CPU在响应定时中断请求后转入8H号中断处理程序。BIOS提供的8H号中断处理程序中有一条中断指令“INT 1CH"，
所以每秒要调用到约18.2次1CH号中断处理程序。而BIOS的ICH号中断处理程序实际上并没有做任何工作，只有一条中断返回指令。
这样安排的目的是为应用程序留下一个软接口。应用程序只要提供新的1CH号中断处理程序，就可能实现某些周期性的工作。
下面介绍的时钟显示程序就是利用这个软接口，实现时钟显示。
在新的1CH号中断处理程序中安排一个计数器，记录调用它的次数，当计数满18次后，就在屏幕的右上角显示当前的时间（时分秒），清计数器。
这样约每秒显示一次当前时间。当前时间的获取是调用1AH号中断处理程序的2号功能完成的，
该功能在CH、CL和DH寄存器中返回时、分和秒的BCD码。在把BCD码转换为对应十进制数的ASCII码后，调用显示I/O程序完成显示。
功能号：02H
功能：读取时间
入口参数：AH＝02H
出口参数：CH＝BCD码格式的小时
         CL＝BCD码格式的分钟
         DH＝BCD码格式的秒
         DL＝00H 标准时间，否则，夏令时
         CF＝0 时钟在走，否则，时钟停止
功能号：03H
功能： 设置时间
入口参数：AH＝03H
         CH＝BCD码格式的小时
         CL＝BCD码格式的分钟
         DH＝BCD码格式的秒
         DL＝00H 标准时间，否则，夏令时
出口参数： 无
功能号：04H
功能：读取日期
入口参数：AH＝04H
出口参数：CH＝BCD码格式的世纪
         CL＝BCD码格式的年
         DH＝BCD码格式的月
         DL＝BCD码格式的日
         CF＝0 时钟在走，否则，时钟停止
功能号：05H
功能：设置日期
入口参数：AH＝05H
         CH＝BCD码格式的世纪
         CL＝BCD码格式的年
         DH＝BCD码格式的月
         DL＝BCD码格式的日
出口参数： 无
主程序首先保存原1CH号中断向量，然后设置新的1CH号中断向量，在完成主程序的其他工作后，再恢复原1CH号中断向量。
在主程序设置新的1CH号中断向量后，时钟就开始工作。作为例子，这里的主程序实际上并没有进行实质性的工作，只是等待按键。
；程序名：T5-5.ASM
；功能：（略）
COUNT_VAL= 18
DPAGE = 0
ROW = 0
COLUMN = 80 - BUFF_LEN
COLOR = 07H
CSEG SEGMENT
ASSUME CS:CSEG,DS:CSEG
COUNT DW COUNT_VAL
HHHH DB ?,?,':'
MMMM DB ?,?,':'
SSSS DB ?,?
BUFF_LEN = $ - OFFSET HHHH
CURSOR DW ?
NEW1CH:CMP CS:COUNT,0
JZ NEXT
DEC CS:COUNT
IRET
NEXT:MOV CS:COUNT,COUNT_VAL
STI
PUSH DS
PUSH ES
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH BP
PUSH CS
POP DS
PUSH DS
POP ES
CALL GET_T
MOV BH,DPAGE
MOV AH,3
INT 10H
MOV CURSOR,DX
MOV BP,OFFSET HHHH
MOV BH,DPAGE
MOV DH,ROW
MOV DL,COLUMN
MOV BL,COLOR
MOV CX,MESS_LEN
MOV AL,0
MOV AH,13H
INT 10H
MOV BH,DPAGE
MOV DX,CURSOR
MOV AH,2
INT 10H
POP BP
POP SI
POP DX
POP CX
POP BX
POP AX
POP ES
POP DS
IRET
GET_T PROC
MOV AH,2
INT 1AH
MOV AL,CH
CALL TTASC
XCHG AH,AL
MOV WORD PTR HHHH,AX
MOV AL,CL
CALL TTASC
XCHG AH,AL
MOV WORD PTR MMMM,AX
MOV AL,DH
CALL TTASC
XCHG AH,AL
MOV WORD PTR SSSS,AX
RET
GET_T ENDP
TTASC PROC
MOV AH,AL
AND AL,0FH
SHR AH,1
SHR AH,1
SHR AH,1
SHR AH,1
ADD AX,3030H
RET
TTASC ENDP
OLD1CH DD ?
START:PUSH CS
POP DS
MOV AX,351CH
INT 21H
MOV WORD PTR OLD1CH,BX
MOV WORD PTR OLD1CH+2,ES
MOV DX,OFFSET NEW1CH
MOV AX,251CH
INT 21H
MOV AH,0
INT 16H
LDS DX,OLD1CH
MOV AX,251CH
INT 21H
MOV AH,4CH
INT 21H
CSEG ENDS
END START
测试通过的完整程序如下
COUNT_VAL= 18
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:CSEG
OLD1CH DD ?
NEW1CH_OFF = 200H
NEW1CH_SEG = 0
NEW1CH_BEGIN:JMP SHORT NEW1CH_START
COUNT DW COUNT_VAL
HHHH DB ?,?,':'
MMMM DB ?,?,':'
SSSS DB ?,?
BUFF_LEN = $ - OFFSET HHHH
DPAGE = 0
ROW = 0
COLUMN = 80 - BUFF_LEN
COLOR = 07H
CURSOR DW ?
NEW1CH_START:CMP WORD PTR CS:(offset COUNT - offset NEW1CH_BEGIN + NEW1CH_OFF)[0],0
JZ NEXT
DEC WORD PTR CS:(offset COUNT - offset NEW1CH_BEGIN + NEW1CH_OFF)[0]
IRET
NEXT:MOV WORD PTR CS:(offset COUNT - offset NEW1CH_BEGIN + NEW1CH_OFF)[0],COUNT_VAL
STI
PUSH DS
PUSH ES
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH BP
PUSH CS
POP DS
PUSH DS
POP ES
CALL GET_TIME
MOV BH,DPAGE
MOV AH,3
INT 10H
MOV WORD PTR CS:(offset CURSOR - offset NEW1CH_BEGIN + NEW1CH_OFF)[0],DX
MOV BP,offset HHHH - offset NEW1CH_BEGIN + NEW1CH_OFF
MOV BH,DPAGE
MOV DH,ROW
MOV DL,COLUMN
MOV BL,COLOR
MOV CX,BUFF_LEN
MOV AL,0
MOV AH,13H
INT 10H
MOV BH,DPAGE
MOV DX,WORD PTR CS:(offset CURSOR - offset NEW1CH_BEGIN + NEW1CH_OFF)[0]
MOV AH,2
INT 10H
POP BP
POP SI
POP DX
POP CX
POP BX
POP AX
POP ES
POP DS
IRET
GET_TIME PROC
MOV AH,2
INT 1AH
MOV AL,CH
CALL TTASC
XCHG AH,AL
MOV WORD PTR CS:(offset HHHH - offset NEW1CH_BEGIN + NEW1CH_OFF)[0],AX
MOV AL,CL
CALL TTASC
XCHG AH,AL
MOV WORD PTR CS:(offset MMMM - offset NEW1CH_BEGIN + NEW1CH_OFF)[0],AX
MOV AL,DH
CALL TTASC
XCHG AH,AL
MOV WORD PTR CS:(offset SSSS - offset NEW1CH_BEGIN + NEW1CH_OFF)[0],AX
RET
GET_TIME ENDP
TTASC PROC
MOV AH,AL
AND AL,0FH
SHR AH,1
SHR AH,1
SHR AH,1
SHR AH,1
ADD AX,3030H
RET
TTASC ENDP
NEW1CH_LEN = $ - OFFSET NEW1CH_BEGIN
START:PUSH CS
POP DS
mov si,offset NEW1CH_BEGIN
mov ax,NEW1CH_SEG
mov es,ax
mov di,NEW1CH_OFF
mov cx,NEW1CH_LEN
cld
rep movsb
MOV AX,351CH
INT 21H
MOV WORD PTR OLD1CH,BX
MOV WORD PTR OLD1CH+2,ES
mov ax,NEW1CH_SEG
mov ds,ax
MOV DX,NEW1CH_OFF
MOV AX,251CH
INT 21H
PUSH CS
POP DS
MOV AH,0
INT 16H
LDS DX,OLD1CH
MOV AX,251CH
INT 21H
MOV AH,4CH
INT 21H
CSEG ENDS
END START
上述1CH号中断处理程序没有调用DOS系统功能显示时间，而是调用显示I/O程序显示时间。另外，它除了管理计数器外，还使用了若干变量。
5.6 习题
题5.1什么是I/O端口地址？8086/8088 的I/O端口地址空间有多大？
每种输入输出设备都要通过硬件接口、控制器、总线和CPU相连，在这些接口中都有一组可以由CPU读写的寄存器。
程序利用I/O指令，存取接口上的寄存器，获得外部设备的状态信息，控制外部设备的动作，从而实现输入输出。
从CPU的角度，将这些寄存器都当作端口，对它们进行统一编址，从而建立了一个统一的端口地址空间。
每一个端口在地址空间中都有一个地址，这样的地址称为I/O端口地址。在访问端口的时候，CPU通过端口地址来定位端口。
因为端口所在的芯片和CPU通过总线相连，所以，端口地址和内存地址一样，通过地址总线来传送。
在PC系统中，8086/8088CPU最多可以定位64KB个不同的端口。则端口地址的范围为0~65535。
题5.2请说明指令“IN AX,DX"和如下程序片段的异同：
IN AL,DX
INC DX
IN AL,DX
MOV AH,AL
相同的地方：都从端口DX和DX+1分别读取一个字节到AL和AH
不同的地方：一条指令读取一个字，多条指令分别读取一个字节
端口读取指令有如下四种具体格式：
IN AL,PORT
IN AX,PORT
IN AL,DX
IN AX,DX
前两种格式是直接端口寻址，端口地址PORT是一个8位的立即数，后两种是间接端口寻址，端口地址在寄存器DX中。
当端口地址超过255时，只能采用DX间接端口寻址。当从端口n读取一个字时，相当于同时从端口n和n+1分别读取一个字节到AL和AH。
题5.3请说明指令“OUT 20H,AL"和如下程序片段的异同：
MOV DX,20H
OUT DX,AL
相同的地方：都向端口20H输出AL中的内容
不同的地方：分别采用直接方式表示端口地址和间接方式表示端口地址
端口输出指令也有如下四种具体格式：
OUT PORT,AL
OUT PORT,AX
OUT DX,AL
OUT DX,AX
当采用直接方式表示端口地址时，端口地址仅为8位，即0~255；
当采用间接方式表示端口地址时，端口地址存放在DX寄存器中，端口地址可为16位。
当向端口n输出一个字时，相当于向端口n输出AL中的内容和向端口n+1输出AH中的内容。
题5.4 CPU 与外设之间交换的信息可分为哪几类？如何区分它们？
CPU与外设之间交换的信息包括数据、控制和状态信息。
三种信息都通过IN和OUT指令在数据总线上进行传送，通常采用分配不同端口的方法将它们加以区别。
数据是CPU和外设真正要交换的信息。控制信息输出到I/O接口，告诉接口和设备要做什么工作。
从接口输入的状态信息表示I/O设备当前的状态。
题5.5微机系统常采用哪些方式实现输入输出？
（1）无条件传送方式
不需要查询外设的状态，只要在IN或OUT指令中指明端口地址，就可选通指定外设进行输入输出。
要求外设工作速度能与CPU同步，否则就可能出错。
（2）查询传送方式
输入之前，查询外设数据是否已准备好，若数据已准备好，则输入；否则继续查询，直到数据准备好。
输出之前，查询外设是否“忙”，若不“忙”，则输出；否则继续查询，直到不“忙”。
查询传送方式适用于CPU与外设不同步的情况。通常外设速度远远慢于CPU速度，于是查询过程就将花费大量的时间。
（3）中断传送方式
当外设准备好时，外设向CPU发出中断请求，CPU转入中断处理程序，完成输入输出工作。
（4）直接存储器访问传送方式（DMA）
外部的高速I/O设备不通过CPU而直接与系统内存交换数据。这样数据的传送速度就取决于存储器和外设的工作速度。
这种方式传送数据是成组进行的。其过程是：先把数据在高速外设中存放的起始位置、数据在内存中存放的起始地址、
传送数据长度等参数输出到连接高速外设的接口（控制器），然后启动高速外设，设备准备开始直接传送数据。
当高速外设直接传送准备好后，向处理机发送一个直接传送的请求信号，处理机以最短时间批准进行直接传送，并让出总线控制权，
高速外设在其控制器控制下交换数据。数据交换完毕后，由高速外设发出“完成中断请求”，并交回总线控制权。
处理机响应上述中断，由对应的中断处理程序对高速外设进行控制或对已经传送的数据进行处理，中断返回后，原程序继续运行。
题5.6简述查询传输方式的优缺点。请画出一般查询方式的实现流程图。
查询传送方式的优点是：软硬件实现比较简单；当同时查询多个外设时，可以由程序安排查询的先后次序。
缺点是浪费了CPU原本可执行大量指令的时间。
CPU主动通过输入输出指令查询指定的外部设备的当前状态，若设备就绪，则立即与设备进行数据交换，否则循环查询。
查询方式输入输出的示意流程如图5.1所示。
在实际应用中，通常都设计一个等待超时值，其值随设备而定。一旦设备在规定时间内还无法就绪或空闲，也中止循环查询过程。
如此，图5.1所示的流程图修改为图5.2所示的流程图。
题5.7简述中断传输方式及其优缺点。
中断传送方式的具体过程是：当CPU需要输入或输出数据时，先作一些必要的准备工作（有时包括启动外部设备），然后继续执行程序；
当外设完成一个数据的输入或输出后，则向CPU发出中断请求，CPU就挂起正在执行的程序，转去执行输入或输出操作，
在完成输入或输出操作后，返回原程序继续执行。
中断传送方式的优点：可以避免因反复查询外部设备的状态而浪费时间，从而提高CPU的效率。
中断传送方式的缺点：每中断一次，只传送一次数据，数据传送的效率并不高。
所以，中断传送方式一般用于低速外设。另外，与查询方式相比，中断传送方式实现比较复杂，对硬件的条件也较多。
题5.8什么是中断？什么是中断源？
中断是一种使CPU挂起正在执行的程序而转去处理特殊事件的操作。
引起中断的事件称为中断源，可能是来自外设的输入输出请求，也可能是计算机的一些异常事件或其他的内部原因。
题5.9中断向量表的作用是什么？中断向量表有多大？安排在哪里？
为了使系统在响应中断后，CPU能快速地转入对应的中断处理程序。
系统用一张表来保存这些中断处理程序的入口地址，该表就称为中断向量表。
中断向量表的每一项保存一个中断处理程序的入口地址，它相当于一个指向中断处理程序的指针，所以就称它为中断向量。
中断向量表如图5.5所示，它被安排在内存最低端的1K字节空间中。
其中每个中断向量占用四个字节，前（低地址）两字节保存中断处理程序入口地址的偏移，
后（高地址）两字节保存中断处理程序入口地址的段值，所以含有256个中断向量的中断向量表需要占用1K字节内存空间。
题5.10请简述中断响应的过程。
在中断响应的过程中，由硬件自动完成如下工作：
（1）取得中断类型号；
（2）把标志寄存器内容压入堆栈；
（3）禁止外部中断和单步中断（使IF和TF标志位为0）；
（4）把下一条要执行指令的地址（中断返回地址）压入堆栈（CS和IP内容压入堆栈）；
（5）根据中断类型号从中断向量表中取中断处理程序入口地址；
（6）转入中断处理程序。
中断处理程序在最后从堆栈中弹出返回地址和原标志值结束中断，返回被中断程序。
题5.11中断返回指令IRET与如下两组指令有何不同？
（1）RETF 2
（2）RETF POPF
中断返回指令IRET的功能用汇编语法描述为：
pop IP
pop CS
popf
在中断响应的过程中，寄存器入栈的顺序是标志寄存器、CS、IP，而iret的出栈顺序是IP、CS、标志寄存器，刚好和其相对应。
CPU执行retf指令时，相当于进行：
pop IP
pop CS
相同点：CPU都会回到执行中断处理程序前的执行点继续执行程序。
不同点：IRET和RETF POPF会用执行中断处理程序前的CPU现场恢复标志寄存器，RETF 2不会恢复标志寄存器
题5.12如何不使用软中断指令INT调用16H号中断处理程序。
INT 16H的模拟过程为：
（1）标志寄存器入栈；
（2）IF=0，TF=0：
（3）call dword ptr ds:[88]。
push ax
push ds
mov ax,0
mov ds,ax
pushf
pushf
pop ax
and ah,11111100b
push ax
popf
call dword ptr ds:[88]
pop ds
pop ax
题5.13外部中断与内部中断有何异同？举例说明内部中断和外部中断。
外部中断是由发生在CPU外部的某个事件引起的中断。外部中断以完全随机的方式中断现行程序。
外部中断包括键盘和硬盘等外设的中断，由电源掉电、存储器出错或者总线奇偶校验错等紧急故障产生的中断。
内部中断是由发生在CPU内部的某个事件引起的中断。内部中断是CPU在执行某些指令时产生，不是完全随机产生。
内部中断不需要外部硬件的支持，不受中断允许标志IF的控制。
内部中断包括中断指令INT引起的中断，CPU遇到特殊情况引起的中断，用于程序调试的中断。
题5.14可屏蔽中断与不可屏蔽中断（非屏蔽中断）有何异同？
可屏蔽中断请求是键盘和硬盘等外设的中断请求，由INTR中断请求线传给CPU。
如果中断允许标志IF为0，则CPU不响应由INTR传入的中断请求。
如果中断允许标志IF为1，则CPU响应由INTR传入的中断请求。
不可屏蔽中断请求是由电源掉电、存储器出错或者总线奇偶校验错等紧急故障产生的中断请求，由NMI中断请求线传给CPU。
不论中断允许标志IF的值是多少，CPU总会响应。
不可屏蔽中断的中断类型号规定为2，CPU在响应不可屏蔽中断请求时，总是转入由2号中断向量所指定的中断处理程序。
题5.15在什么条件下才会响应键盘中断？
当中断屏蔽寄存器的第i位为0时，表示允许传出来自IRQi的中断请求信号，
当中断屏蔽寄存器的第i位为1时，表示禁止传出来自IRQi的中断请求信号。
如果中断允许标志IF为0，则CPU不响应由INTR传入的中断请求。
如果中断允许标志IF为1，则CPU响应由INTR传入的中断请求。
中断屏蔽寄存器中的第1位为0，允许传出来自IRQ1的中断请求信号，即传出键盘中断请求。
中断允许标志IF为1，CPU响应由INTR传入的键盘中断请求。
题5.16 PC 系统如何实现中断优先级和中断嵌套？
当多个中断源同时向CPU请求中断时，CPU按系统设计时规定的优先级响应中断请求。
在PC系统中，规定的优先级如下：
优先级最高   内部中断（除法错，INTO，INT）
↓                   不可屏蔽中断（NMI）
↓                   可屏蔽中断（INTR）
优先级最低   单步中断
外设的中断请求都通过中断控制器8259A传给CPU的INTR引线。中断控制器8259A初始化时规定了8个优先级，
在正常的优先级方式下，优先级次序如下：IRQ0，IRQ1，IRQ2，IRQ3，IRQ4，1RQ5，IRQ6，IRQ7。
中断控制器8259A初始化时还规定，在CPU响应某个外设的中断请求后，中断控制器8259A不再传出中断级相同或较低的外设中断请求，
直到8259A接收到中断结束命令为止。所以，在外设中断处理程序结束时，要通知8259A中断已结束，
以便使8259A传出中断级相同或较低的外设中断请求，从而使CPU响应它们。
CPU在执行中断处理程序时，又发生中断，这种情况称为中断嵌套。
由于CPU在响应中断的过程中，已自动关中断，所以，CPU也就不会再自动响应可屏蔽中断。
如果需要在中断处理过程的某些时候响应可屏蔽中断，那么可在中断处理程序中安排开中断指令，
CPU在执行开中断指令后，就处于开中断状态，也就可以响应可屏蔽中断了，直到再关中断。
所以，如果在中断处理程序中使用了开中断指令，也就可能会发生可屏蔽中断引起的中断嵌套。
CPU在执行中断处理程序时，遇到软中断指令，会引起中断嵌套。
CPU在执行中断处理程序时，发生非屏蔽中断，也会引起中断嵌套。
题5.17设计中断处理程序时应该遵循哪些原则？PC系统中的中断处理程序通常应该含有哪些步骤？
如果中断处理程序要占用大量的堆栈空间，可以考虑切换堆栈。
中断处理程序要先保护中断发生时CPU各内部寄存器的内容，方法是把它们压入堆栈。
中断处理程序应尽早开中断，中断处理程序的执行时间要尽量短，以便CPU及时响应具有更高优先级的中断请求。
中断处理完成后，要依次恢复被保护的CPU各内部寄存器的原有内容。
如果在开始时切换了堆栈，那么也要在中断处理完成后，重新切换回原堆栈。
外设中断处理程序的主要步骤如下：
（1）保护现场。
（2）完成中断处理。
（3）恢复现场。
（4）通知中断控制器中断已结束。
（5）利用IRET指令实现中断返回。
软中断处理程序的主要步骤如下：
（1）考虑切换堆栈。
（2）考虑开中断。
（3）保护现场。
（4）完成中断处理。
（5）恢复现场。
（6）堆栈切换。如果在开始时切换了堆栈，那么也要再重新切换回原堆栈。
（7）利用IRET指令实现中断返回。
题5.18基本输入/输出系统BIOS主要含有哪些内容？
基本输入输出系统BIOS直接建立在硬件基础上，包含了主要I/O设备的处理程序和许多常用例行程序，它们一般以中断处理程序的形式存在。
例如，负责显示输出的显示I/O程序作为10H号中断处理程序存在，负责打印输出的打印I/O程序作为17H号中断处理程序存在，
负责键盘输入的键盘I/O程序作为16H号中断处理程序存在，负责获取内存容量的例行程序就作为12H号中断处理程序存在。
题5.19应用程序、操作系统、BIOS和外设接口之间的相互关系如何？
BIOS直接建立在硬件基础上。磁盘操作系统DOS建立在BIOS的基础上。
例如，DOS调用BIOS显示I/O程序完成显示输出，调用打印I/O程序完成打印输出，调用键盘I/O程序完成键盘输入。
一般情况下，应用程序调用DOS提供的系统功能完成输入输出或其他操作。
特殊情况下，应用程序可调用BIOS提供的系统功能。比如，需要利用BIOS提供而DOS不提供的某个功能，或者需要绕过DOS。
极个别情况下，应用程序也可以直接操纵外设接口来控制外设，从而获得速度上最高的效率，应用程序一般不直接与硬件发生关系。
题5.20有哪些方法可在屏幕的左上角显示AB两个字符？请比较这些方法。
可以利用直接写屏显示字符串，也可以调用BIOS提供的显示I/O程序。
入口参数：DS:SI=字符串首地址 
                  CX=字符串长度
                  BL=属性 
                  DH=显示开始行号
                  DL=显示开始列号
SHOWSTR 直接写屏显示字符串
SHOWSTRA 调用显示I/O程序的13H号功能显示字符串
SHOWSTRB 先调用显示I/O程序的2号功能把光标定到指定位置，然后调用显示I/O程序的9号功能把指定属性写到显示字符串的位置处，
再利用显示I/O程序的TTY显示功能逐个显示字符串中的字符。
SHOWSTRC 先读取当前光标位置且保存，再定位光标到指定位置，然后调用显示I/O程序的9号功能逐个显示字符，每显示一个字符后，
把光标向后移一个位置，最后把光标回到原位。
SHOWSTRA与SHOWSTR稍有不同：第一是13H号功能解释回车和换行等控制符，所以如果要显示的字符串中含有这样的控制符，
那么显示效果就会有差异；第二是当显示超出最后一行的最后一列时，13H功能要引起滚屏。
SHOWSTRB与SHOWSTR也稍有不同：第一是TTY方式显示也解释控制符，所以如果要显示的字符串中含有控制符，那么显示效果就会有差异；
第二是当TTY方式在屏幕的右下角显示一个字符后要上滚屏幕；第三是字符串显示完后，光标定位在字符串之后。
SHOWSTRC与SHOWSTR也稍有不同：第一是显示过程中会过滤控制符，所以如果要显示的字符串中含有控制符，那么显示效果就会有差异；
第二是在屏幕的右下角显示一个字符后要上滚屏幕。
测试通过的完整程序如下
WINTOP = 0
WINLEFT = 0
WINBOTTOM = 24
WINRIGHT = 79
COLOR = 07H
ROW = 5
COLUM = 10
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
GETSTR_BUF DB 128 DUP (0)
MESS_GETSTR DB 'Please input one string:','$'
COLORB DB 07H,17H,0FH,70H,74H
COLORE LABEL BYTE
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESS_GETSTR
CALL DISPMESS
MOV DI,OFFSET GETSTR_BUF
CALL GETSTRDISP
MOV DI,OFFSET COLORB
FORCOLOR:CMP DI,OFFSET COLORE
JB SETCOLOR
MOV DI,OFFSET COLORB
SETCOLOR:MOV BL,DS:[DI]
MOV SI,OFFSET GETSTR_BUF
ADD SI,2
MOV CX,WORD PTR GETSTR_BUF
SUB CX,2
MOV DH,ROW
MOV DL,COLUM
CALL SHOWSTR
MOV DH,ROW+1
MOV DL,COLUM
CALL SHOWSTRA
MOV DH,ROW+2
MOV DL,COLUM
CALL SHOWSTRB
MOV DH,ROW+3
MOV DL,COLUM
CALL SHOWSTRC
MOV AH,0
INT 16H
CMP AL,ESCKEY
JZ FINISHCOLOR
NEXTCOLOR:INC DI
JMP FORCOLOR
FINISHCOLOR:MOV BL,COLOR
MOV SI,OFFSET GETSTR_BUF
ADD SI,2
MOV CX,WORD PTR GETSTR_BUF
SUB CX,2
MOV DH,ROW+6
MOV DL,COLUM
CALL SHOWSTR
MOV AX,4C00H
INT 21H
ISDISPASC PROC
CMP AL,20H
JB ISDISPASC_NODISPASC
CMP AL,7EH
JA ISDISPASC_NODISPASC
CLC
JMP ISDISPASC_OK
ISDISPASC_NODISPASC:STC
ISDISPASC_OK:RET
ISDISPASC ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRDISP PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRDISP1:CALL GETCH
CMP AL,CR
JZ GETSTRDISP5
CMP AL,BACKSPACE
JNZ GETSTRDISP4
CMP BX,0
JZ GETSTRDISP2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRDISP1
GETSTRDISP2:CALL BELL
JMP GETSTRDISP1
GETSTRDISP4:CMP BX,78
JZ GETSTRDISP2
CALL ISDISPASC
JC GETSTRDISP2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRDISP1
GETSTRDISP5:CMP BX,1
JB GETSTRDISP2
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRDISP_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRDISP ENDP
SHOWSTR PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
MOV AX,0B800H
MOV ES,AX
MOV AL,80
MUL DH
XOR DH,DH
ADD AX,DX
ADD AX,AX
XCHG AX,BX
MOV AH,AL
JCXZ SHOWSTR_OK
SHOWSTR_S:MOV AL,DS:[SI]
INC SI
MOV ES:[BX],AX
INC BX
INC BX
LOOP SHOWSTR_S
SHOWSTR_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
SHOWSTR ENDP
SHOWSTRA PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
JCXZ SHOWSTRA_OK
PUSH DS
POP ES
MOV BP,SI
MOV BH,0
MOV AL,0
MOV AH,13H
INT 10H
SHOWSTRA_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
SHOWSTRA ENDP
SHOWSTRB PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
JCXZ SHOWSTRB_OK
MOV BH,0
MOV AH,2
INT 10H
MOV AL,20H
MOV AH,9
INT 10H
MOV AH,0EH
SHOWSTRB_S:MOV AL,DS:[SI]
INC SI
INT 10H
LOOP SHOWSTRB_S
SHOWSTRB_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
SHOWSTRB ENDP
SHOWSTRC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
MOV BP,SP
MOV BH,0
MOV AH,3
INT 10H
PUSH DX
MOV BX,WORD PTR [BP+12]
MOV CX,WORD PTR [BP+10]
MOV DX,WORD PTR [BP+8]
MOV BH,0
MOV AH,2
INT 10H
MOV DI,0
SHOWSTRC_FORI1:CMP DI,WORD PTR [BP+10]
JAE SHOWSTRC_FINISHI1
MOV AL,DS:[SI]
CALL ISDISPASC
JC SHOWSTRC_NEXTI1
MOV BH,0
MOV CX,1
MOV AH,9
INT 10H
INC DL
CMP DL,WINRIGHT
JBE SHOWSTRC_SETCUR
MOV DL,WINLEFT
INC DH
CMP DH,WINBOTTOM
JBE SHOWSTRC_SETCUR
MOV CH,WINTOP
MOV CL,WINLEFT
MOV DH,WINBOTTOM
MOV DL,WINRIGHT
MOV BH,COLOR
MOV AL,1
MOV AH,6
INT 10H
MOV DL,WINLEFT
SHOWSTRC_SETCUR:MOV BH,0
MOV AH,2
INT 10H
SHOWSTRC_NEXTI1:INC DI
INC SI
JMP SHOWSTRC_FORI1
SHOWSTRC_FINISHI1:POP DX
MOV BH,0
MOV AH,2
INT 10H
SHOWSTRC_OK:MOV SP,BP
POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
SHOWSTRC ENDP
CSEG ENDS
END START
题5.21简述键盘中断处理程序、键盘I/O程序和键盘缓冲区三者之间的关系。这样安排有何优点？
当用户按键时，键盘接口会得到一个代表被按键的键盘扫描码，同时产生一个中断请求。
如果键盘中断是允许的（中断屏蔽字中的位1为0），并且CPU处于开中断状态（IF=1），
那么CPU就会响应键盘中断，转入9号键盘中断处理程序。
键盘中断处理程序首先从键盘接口取得代表被按键的扫描码，然后根据扫描码判定用户所按的键并作相应的处理。
如果用户按的是字符键或功能键，那么就把所按键的扫描码和对应的ASCII码存入键盘缓冲区。如果键盘缓冲区已满，则不再存入。
如果用户按的是控制键或双态键，那么就设置有关标志。如果用户按的是特殊请求键，那么就产生一个相对应的动作。
最后通知中断控制器中断结束并实现中断返回。
键盘I/O程序以16H号中断处理程序的形式存在，一般情况下，应用程序的键盘输入最后都是调用它完成的。
键盘I/O程序从键盘缓冲区中取出所按键的ASCII码和扫描码返回给调用者。
这样安排的优点是把键盘中断的处理和应用程序的键盘输入分开。键盘中断的处理就能尽快完成，应用程序就能专注于键盘输入的内容。
题5.22软中断处理程序与硬中断处理程序有何异同？
软中断是不可屏蔽的，它不会随机发生。软中断处理程序不必过分追求速度上的高效率。
外设的中断请求是可屏蔽的，外设中断的发生是随机的。外设中断的处理必须尽快完成，处理完成后还要通知中断控制器中断已结束。
都遵循以下原则
如果中断处理程序要占用大量的堆栈空间，可以考虑切换堆栈。
中断处理程序要先保护中断发生时CPU各内部寄存器的内容。
中断处理程序应尽早开中断，中断处理程序的执行时间要尽量短，以便CPU及时响应具有更高优先级的中断请求。
中断处理完成后，要依次恢复被保护的CPU各内部寄存器的原有内容。
如果在开始时切换了堆栈，那么也要在中断处理完成后，重新切换回原堆栈。
题5.23请写一个程序显示打印接口的当前状态。
WINTOP = 0
WINLEFT = 0
WINBOTTOM = 24
WINRIGHT = 79
COLOR = 07H
ROW = 5
COLUM = 10
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
GETSTR_BUF DB 128 DUP (0)
MESS_GETSTR DB 'Please input printer number:','$'
NUM_PRN DW 0
res_dx dw 0
res_cx dw 0
res_bx dw 0
res_ax dw 0
num_dx dw 0
num_cx dw 0
num_bx dw 0
num_ax dw 0
val_dx dw 0
val_cx dw 0
val_bx dw 0
val_ax dw 0
mul_table dd 1,10,100,1000,10000,100000,1000000,10000000,100000000
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESS_GETSTR
CALL DISPMESS
MOV DI,OFFSET GETSTR_BUF
CALL GETSTRD
MOV SI,OFFSET GETSTR_BUF
ADD SI,2
MOV CX,WORD PTR GETSTR_BUF
SUB CX,2
CALL DTOBIN
MOV AX,VAL_AX
MOV NUM_PRN,AX
MOV DX,NUM_PRN
MOV AH,1
INT 17H
CALL DHTOASC
CALL NEWLINE
MOV DX,NUM_PRN
MOV AH,2
INT 17H
CALL DHTOASC
CALL NEWLINE
MOV AX,4C00H
INT 21H
ISDEC PROC
CMP AL,'0'
JB ISDEC_NODEC
CMP AL,'9'
JA ISDEC_NODEC
CLC
JMP ISDEC_OK
ISDEC_NODEC:STC
ISDEC_OK:RET
ISDEC ENDP
ISDISPASC PROC
CMP AL,20H
JB ISDISPASC_NODISPASC
CMP AL,7EH
JA ISDISPASC_NODISPASC
CLC
JMP ISDISPASC_OK
ISDISPASC_NODISPASC:STC
ISDISPASC_OK:RET
ISDISPASC ENDP
ATOBIN PROC
SUB AL,30H
CMP AL,9
JBE ATOBIN_OK
SUB AL,7
CMP AL,15
JBE ATOBIN_OK
SUB AL,20H
ATOBIN_OK:RET
ATOBIN ENDP
DTOBIN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DI,SI
ADD DI,CX
DEC DI
MOV BP,0
MOV VAL_AX,0
MOV VAL_DX,0
DTOBIN_FORJ:CMP DI,SI
JB DTOBIN_OK
MOV AL,DS:[DI]
CALL ATOBIN
MOV AH,0
MOV BX,AX
MOV AX,0
MOV DX,WORD PTR MUL_TABLE[BP]
MOV CX,WORD PTR MUL_TABLE[BP+2]
CALL MULDW
ADD VAL_AX,AX
ADC VAL_DX,BX
DTOBIN_NEXTJ:DEC DI
INC BP
INC BP
INC BP
INC BP
JMP DTOBIN_FORJ
DTOBIN_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOBIN ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRDISP PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRDISP1:CALL GETCH
CMP AL,CR
JZ GETSTRDISP5
CMP AL,BACKSPACE
JNZ GETSTRDISP4
CMP BX,0
JZ GETSTRDISP2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRDISP1
GETSTRDISP2:CALL BELL
JMP GETSTRDISP1
GETSTRDISP4:CMP BX,78
JZ GETSTRDISP2
CALL ISDISPASC
JC GETSTRDISP2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRDISP1
GETSTRDISP5:CMP BX,1
JB GETSTRDISP2
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRDISP_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRDISP ENDP
GETSTRD PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRD1:CALL GETCH
CMP AL,CR
JZ GETSTRD5
CMP AL,BACKSPACE
JNZ GETSTRD4
CMP BX,0
JZ GETSTRD2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRD1
GETSTRD2:CALL BELL
JMP GETSTRD1
GETSTRD4:CMP BX,1
JZ GETSTRD2
CALL ISDEC
JC GETSTRD2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRD1
GETSTRD5:CMP BX,1
JB GETSTRD2
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRD_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRD ENDP
MULDW PROC
MOV NUM_AX,AX
MOV NUM_BX,BX
MOV NUM_CX,CX
MOV NUM_DX,DX
MOV AX,NUM_AX
MOV BX,NUM_CX
MUL BX
MOV RES_DX,DX
MOV RES_CX,AX
MOV AX,NUM_BX
MOV BX,NUM_DX
MUL BX
MOV RES_BX,DX
MOV RES_AX,AX
MOV AX,NUM_AX
MOV BX,NUM_DX
MUL BX
ADD AX,RES_BX
ADC WORD PTR RES_CX,0
ADC WORD PTR RES_DX,0
ADD DX,RES_CX
ADC WORD PTR RES_DX,0
MOV RES_CX,DX
MOV RES_BX,AX
MOV AX,NUM_BX
MOV BX,NUM_CX
MUL BX
ADD AX,RES_BX
ADC WORD PTR RES_CX,0
ADC WORD PTR RES_DX,0
ADD DX,RES_CX
ADC WORD PTR RES_DX,0
MOV RES_CX,DX
MOV RES_BX,AX
MOV DX,RES_DX
MOV CX,RES_CX
MOV BX,RES_BX
MOV AX,RES_AX
RET
MULDW ENDP
HTOASC PROC
AND AL,0FH
ADD AL,30H
CMP AL,39H
JA HTOASC_NODEC
JMP HTOASC_OK
HTOASC_NODEC:ADD AL,7
HTOASC_OK:RET
HTOASC ENDP
AHTOASC PROC
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL HTOASC
XCHG AH,AL
CALL HTOASC
RET
AHTOASC ENDP
DAHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DAHTOASC ENDP
DHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH AX
XCHG AH,AL
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DHTOASC ENDP
SHOWSTRC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
MOV BP,SP
MOV BH,0
MOV AH,3
INT 10H
PUSH DX
MOV BX,WORD PTR [BP+12]
MOV CX,WORD PTR [BP+10]
MOV DX,WORD PTR [BP+8]
MOV BH,0
MOV AH,2
INT 10H
MOV DI,0
SHOWSTRC_FORI1:CMP DI,WORD PTR [BP+10]
JAE SHOWSTRC_FINISHI1
MOV AL,DS:[SI]
CALL ISDISPASC
JC SHOWSTRC_NEXTI1
MOV BH,0
MOV CX,1
MOV AH,9
INT 10H
INC DL
CMP DL,WINRIGHT
JBE SHOWSTRC_SETCUR
MOV DL,WINLEFT
INC DH
CMP DH,WINBOTTOM
JBE SHOWSTRC_SETCUR
MOV CH,WINTOP
MOV CL,WINLEFT
MOV DH,WINBOTTOM
MOV DL,WINRIGHT
MOV BH,COLOR
MOV AL,1
MOV AH,6
INT 10H
MOV DL,WINLEFT
SHOWSTRC_SETCUR:MOV BH,0
MOV AH,2
INT 10H
SHOWSTRC_NEXTI1:INC DI
INC SI
JMP SHOWSTRC_FORI1
SHOWSTRC_FINISHI1:POP DX
MOV BH,0
MOV AH,2
INT 10H
SHOWSTRC_OK:MOV SP,BP
POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
SHOWSTRC ENDP
CSEG ENDS
END START
题5.24从RT/COMS RAM中可获得系统当前日期和时间。写一个程序显示RT/CMOS RAM中的系统当前日期和时间。
WINTOP = 0
WINLEFT = 0
WINBOTTOM = 24
WINRIGHT = 79
COLOR = 07H
DPAGE = 0
ROW = 5
COLUM = 10
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:CSEG
OLD1CH DD ?
NEW1CH_OFF = 200H
NEW1CH_SEG = 0
COUNT_VAL= 18
NEW1CH_BEGIN:JMP SHORT NEW1CH_START
COUNT DW COUNT_VAL
DATETIME_BUF DB 19 DUP (?)
CURSOR DW ?
NEW1CH_START:CMP WORD PTR CS:(offset COUNT - offset NEW1CH_BEGIN + NEW1CH_OFF)[0],0
JZ NEXT
DEC WORD PTR CS:(offset COUNT - offset NEW1CH_BEGIN + NEW1CH_OFF)[0]
IRET
NEXT:MOV WORD PTR CS:(offset COUNT - offset NEW1CH_BEGIN + NEW1CH_OFF)[0],COUNT_VAL
STI
PUSH DS
PUSH ES
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH BP
PUSH CS
POP DS
PUSH DS
POP ES
MOV SI,offset DATETIME_BUF - offset NEW1CH_BEGIN + NEW1CH_OFF
CALL GETDATETIME
MOV BH,DPAGE
MOV AH,3
INT 10H
MOV WORD PTR CS:(offset CURSOR - offset NEW1CH_BEGIN + NEW1CH_OFF)[0],DX
MOV BP,offset DATETIME_BUF - offset NEW1CH_BEGIN + NEW1CH_OFF
MOV BH,DPAGE
MOV DH,ROW
MOV DL,COLUM
MOV BL,COLOR
MOV CX,19
MOV AL,0
MOV AH,13H
INT 10H
MOV BH,DPAGE
MOV DX,WORD PTR CS:(offset CURSOR - offset NEW1CH_BEGIN + NEW1CH_OFF)[0]
MOV AH,2
INT 10H
POP BP
POP SI
POP DX
POP CX
POP BX
POP AX
POP ES
POP DS
IRET
GETDATETIME PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV AH,4
INT 1AH
MOV AL,CH
CALL TTASC
MOV BYTE PTR DS:[SI],AH
MOV BYTE PTR DS:[SI+1],AL
MOV AL,CL
CALL TTASC
MOV BYTE PTR DS:[SI+2],AH
MOV BYTE PTR DS:[SI+3],AL
MOV BYTE PTR DS:[SI+4],'-'
MOV AL,DH
CALL TTASC
MOV BYTE PTR DS:[SI+5],AH
MOV BYTE PTR DS:[SI+6],AL
MOV BYTE PTR DS:[SI+7],'-'
MOV AL,DL
CALL TTASC
MOV BYTE PTR DS:[SI+8],AH
MOV BYTE PTR DS:[SI+9],AL
MOV BYTE PTR DS:[SI+10],20H
MOV AH,2
INT 1AH
MOV AL,CH
CALL TTASC
MOV BYTE PTR DS:[SI+11],AH
MOV BYTE PTR DS:[SI+12],AL
MOV BYTE PTR DS:[SI+13],':'
MOV AL,CL
CALL TTASC
MOV BYTE PTR DS:[SI+14],AH
MOV BYTE PTR DS:[SI+15],AL
MOV BYTE PTR DS:[SI+16],':'
MOV AL,DH
CALL TTASC
MOV BYTE PTR DS:[SI+17],AH
MOV BYTE PTR DS:[SI+18],AL
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
GETDATETIME ENDP
TTASC PROC
MOV AH,AL
AND AL,0FH
SHR AH,1
SHR AH,1
SHR AH,1
SHR AH,1
ADD AX,3030H
RET
TTASC ENDP
NEW1CH_LEN = $ - OFFSET NEW1CH_BEGIN
START:PUSH CS
POP DS
mov si,offset NEW1CH_BEGIN
mov ax,NEW1CH_SEG
mov es,ax
mov di,NEW1CH_OFF
mov cx,NEW1CH_LEN
cld
rep movsb
MOV AX,351CH
INT 21H
MOV WORD PTR OLD1CH,BX
MOV WORD PTR OLD1CH+2,ES
mov ax,NEW1CH_SEG
mov ds,ax
MOV DX,NEW1CH_OFF
MOV AX,251CH
INT 21H
PUSH CS
POP DS
MOV AH,0
INT 16H
LDS DX,OLD1CH
MOV AX,251CH
INT 21H
MOV AH,4CH
INT 21H
CSEG ENDS
END START
题5.25请写一个程序打印一份中断向量表。
WINTOP = 0
WINLEFT = 0
WINBOTTOM = 24
WINRIGHT = 79
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
DIS_BUF DB 128 DUP (0)
DIS_LEN DW 0
res_dx dw 0
res_cx dw 0
res_bx dw 0
res_ax dw 0
num_dx dw 0
num_cx dw 0
num_bx dw 0
num_ax dw 0
val_dx dw 0
val_cx dw 0
val_bx dw 0
val_ax dw 0
HANDLE_DST DW 0
FNAME_DST DB 'TEST.TXT',0
MESS_CREAERR DB 'Can not create file',07H,'$'
MESS_WRITERR DB 'Writing error',07H,'$'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL DISINTVECTAB
CALL WRITEINTVECTAB
MOV AH,4CH
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
HTOASC PROC
AND AL,0FH
ADD AL,30H
CMP AL,39H
JA HTOASC_NODEC
JMP HTOASC_OK
HTOASC_NODEC:ADD AL,7
HTOASC_OK:RET
HTOASC ENDP
AHTOASC PROC
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL HTOASC
XCHG AH,AL
CALL HTOASC
RET
AHTOASC ENDP
DHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH AX
XCHG AH,AL
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DHTOASC ENDP
DAHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DAHTOASC ENDP
DHTOBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV SI,WORD PTR DIS_LEN
PUSH AX
XCHG AH,AL
CALL AHTOASC
MOV BYTE PTR DIS_BUF[SI],AH
INC SI
MOV BYTE PTR DIS_BUF[SI],AL
INC SI
POP AX
CALL AHTOASC
MOV BYTE PTR DIS_BUF[SI],AH
INC SI
MOV BYTE PTR DIS_BUF[SI],AL
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV WORD PTR DIS_LEN,SI
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DHTOBUF ENDP
DAHTOBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV SI,WORD PTR DIS_LEN
CALL AHTOASC
MOV BYTE PTR DIS_BUF[SI],AH
INC SI
MOV BYTE PTR DIS_BUF[SI],AL
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV WORD PTR DIS_LEN,SI
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DAHTOBUF ENDP
DISARRAY PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
CMP CX,1
JB DISARRAY_OK
CMP CX,8000H
JA DISARRAY_OK
MOV SI,CX
MOV BP,0FFFFH
XOR DX,DX
MOV AX,ES
MOV CX,16
MUL CX
ADD AX,DI
ADC DX,0
CMP DX,000FH
JA DISARRAY_OK
MOV NUM_DX,DX
MOV NUM_AX,AX
MOV DX,000FH
MOV AX,0FFFFH
SUB AX,NUM_AX
SBB DX,NUM_DX
ADD AX,1
ADC DX,0
CMP DX,0
JNZ DISARRAY2
MOV BP,AX
DISARRAY2:XOR DX,DX
MOV AX,0FFFFH
SUB AX,DI
ADD AX,1
ADC DX,0
CMP DX,0
JZ DISARRAY5
MOV AX,0FFFFH
DISARRAY5:CMP AX,BP
JBE DISARRAY3
MOV AX,BP
DISARRAY3:CMP AX,SI
JAE DISARRAY1
MOV SI,AX
DISARRAY1:MOV AX,SI
XOR DX,DX
MOV CX,16
CALL DIVDW
MOV NUM_AX,AX
MOV NUM_CX,CX
MOV CX,SI
MOV BX,DI
MOV BP,0
MOV SI,0
DISARRAY_FORI1:CMP BP,CX
JAE DISARRAY_OK
CMP SI,NUM_AX
JZ DISARRAYZ
JA DISARRAY_OK
MOV NUM_BX,SI
MOV DIS_LEN,0
MOV AX,ES
CALL DHTOBUF
MOV SI,DIS_LEN
MOV BYTE PTR DIS_BUF[SI],':'
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV DIS_LEN,SI
MOV AX,BX
CALL DHTOBUF
MOV SI,NUM_BX
MOV DI,0
DISARRAY_FORJ1:CMP DI,16
JAE DISARRAY_FINISHJ1
MOV AL,ES:[BX]
CALL DAHTOBUF
DISARRAY_NEXTJ1:INC DI
INC BP
INC BX
JMP DISARRAY_FORJ1
DISARRAY_FINISHJ1:MOV SI,DIS_LEN
MOV BYTE PTR DIS_BUF[SI],0DH
INC SI
MOV BYTE PTR DIS_BUF[SI],0AH
INC SI
MOV DIS_LEN,SI
MOV NUM_DX,CX
MOV CX,SI
MOV SI,NUM_BX
MOV NUM_BX,BX
MOV BX,0
DISARRAY_S1:MOV DL,DIS_BUF[BX]
MOV AH,2
INT 21H
INC BX
LOOP DISARRAY_S1
JMP DISARRAY_NEXTI2
DISARRAYZ:MOV AX,NUM_CX
CMP AX,1
JB DISARRAY_NEXTI1
MOV NUM_BX,SI
MOV DIS_LEN,0
MOV AX,ES
CALL DHTOBUF
MOV SI,DIS_LEN
MOV BYTE PTR DIS_BUF[SI],':'
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV DIS_LEN,SI
MOV AX,BX
CALL DHTOBUF
MOV SI,NUM_BX
MOV DI,0
DISARRAY_FORJ2:CMP DI,NUM_CX
JAE DISARRAY_FINISHJ2
MOV AL,ES:[BX]
CALL DAHTOBUF
DISARRAY_NEXTJ2:INC DI
INC BP
INC BX
JMP DISARRAY_FORJ2
DISARRAY_FINISHJ2:MOV SI,DIS_LEN
MOV BYTE PTR DIS_BUF[SI],0DH
INC SI
MOV BYTE PTR DIS_BUF[SI],0AH
INC SI
MOV DIS_LEN,SI
MOV NUM_DX,CX
MOV CX,SI
MOV SI,NUM_BX
MOV NUM_BX,BX
MOV BX,0
DISARRAY_S2:MOV DL,DIS_BUF[BX]
MOV AH,2
INT 21H
INC BX
LOOP DISARRAY_S2
DISARRAY_NEXTI2:MOV BX,NUM_BX
MOV CX,NUM_DX
DISARRAY_NEXTI1:INC SI
JMP DISARRAY_FORI1
DISARRAY_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DISARRAY ENDP
WRITEARRAY PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
CMP CX,1
JB WRITEARRAY_OK
CMP CX,8000H
JA WRITEARRAY_OK
MOV SI,CX
MOV BP,0FFFFH
XOR DX,DX
MOV AX,ES
MOV CX,16
MUL CX
ADD AX,DI
ADC DX,0
CMP DX,000FH
JA WRITEARRAY_OK
MOV NUM_DX,DX
MOV NUM_AX,AX
MOV DX,000FH
MOV AX,0FFFFH
SUB AX,NUM_AX
SBB DX,NUM_DX
ADD AX,1
ADC DX,0
CMP DX,0
JNZ WRITEARRAY2
MOV BP,AX
WRITEARRAY2:XOR DX,DX
MOV AX,0FFFFH
SUB AX,DI
ADD AX,1
ADC DX,0
CMP DX,0
JZ WRITEARRAY5
MOV AX,0FFFFH
WRITEARRAY5:CMP AX,BP
JBE WRITEARRAY3
MOV AX,BP
WRITEARRAY3:CMP AX,SI
JAE WRITEARRAY1
MOV SI,AX
WRITEARRAY1:MOV AX,SI
XOR DX,DX
MOV CX,16
CALL DIVDW
MOV NUM_AX,AX
MOV NUM_CX,CX
MOV CX,SI
MOV BX,DI
MOV BP,0
MOV SI,0
WRITEARRAY_FORI1:CMP BP,CX
JAE WRITEARRAY_CLOSEF
CMP SI,NUM_AX
JZ WRITEARRAYZ
JA WRITEARRAY_CLOSEF
MOV NUM_BX,SI
MOV DIS_LEN,0
MOV AX,ES
CALL DHTOBUF
MOV SI,DIS_LEN
MOV BYTE PTR DIS_BUF[SI],':'
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV DIS_LEN,SI
MOV AX,BX
CALL DHTOBUF
MOV SI,NUM_BX
MOV DI,0
WRITEARRAY_FORJ1:CMP DI,16
JAE WRITEARRAY_FINISHJ1
MOV AL,ES:[BX]
CALL DAHTOBUF
WRITEARRAY_NEXTJ1:INC DI
INC BP
INC BX
JMP WRITEARRAY_FORJ1
WRITEARRAY_FINISHJ1:MOV SI,DIS_LEN
MOV BYTE PTR DIS_BUF[SI],0DH
INC SI
MOV BYTE PTR DIS_BUF[SI],0AH
INC SI
MOV DIS_LEN,SI
MOV NUM_DX,CX
MOV CX,SI
MOV SI,NUM_BX
MOV DX,OFFSET DIS_BUF
MOV NUM_BX,BX
MOV BX,HANDLE_DST
MOV AH,40H
INT 21H
JC WIRTEARRAY_WERROR
JMP WRITEARRAY_NEXTI2
WRITEARRAYZ:MOV AX,NUM_CX
CMP AX,1
JB WRITEARRAY_NEXTI1
MOV NUM_BX,SI
MOV DIS_LEN,0
MOV AX,ES
CALL DHTOBUF
MOV SI,DIS_LEN
MOV BYTE PTR DIS_BUF[SI],':'
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV DIS_LEN,SI
MOV AX,BX
CALL DHTOBUF
MOV SI,NUM_BX
MOV DI,0
WRITEARRAY_FORJ2:CMP DI,NUM_CX
JAE WRITEARRAY_FINISHJ2
MOV AL,ES:[BX]
CALL DAHTOBUF
WRITEARRAY_NEXTJ2:INC DI
INC BP
INC BX
JMP WRITEARRAY_FORJ2
WRITEARRAY_FINISHJ2:MOV SI,DIS_LEN
MOV BYTE PTR DIS_BUF[SI],0DH
INC SI
MOV BYTE PTR DIS_BUF[SI],0AH
INC SI
MOV DIS_LEN,SI
MOV NUM_DX,CX
MOV CX,SI
MOV SI,NUM_BX
MOV DX,OFFSET DIS_BUF
MOV NUM_BX,BX
MOV BX,HANDLE_DST
MOV AH,40H
INT 21H
JC WIRTEARRAY_WERROR
WRITEARRAY_NEXTI2:MOV BX,NUM_BX
MOV CX,NUM_DX
WRITEARRAY_NEXTI1:INC SI
JMP WRITEARRAY_FORI1
WIRTEARRAY_WERROR:STC
JMP WRITEARRAY_OK
WRITEARRAY_CLOSEF:CLC
WRITEARRAY_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
WRITEARRAY ENDP
DISINTVECTAB PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
MOV BX,0
MOV BP,0
DISINTVECTAB_FORJ1:CMP BP,256
JAE DISINTVECTAB_OK
MOV AX,0
MOV ES,AX
MOV DI,BX
MOV CX,4
MOV AX,BP
CALL DAHTOASC
MOV AL,20H
CALL PUTCH
MOV AX,ES:[DI+2]
CALL DHTOASC
MOV AL,20H
CALL PUTCH
MOV AX,ES:[DI]
CALL DHTOASC
MOV AL,20H
CALL PUTCH
CALL DISARRAY
DISINTVECTAB_NEXTJ1:INC BP
INC BX
INC BX
INC BX
INC BX
JMP DISINTVECTAB_FORJ1
DISINTVECTAB_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DISINTVECTAB ENDP
WRITEINTVECTAB PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
MOV DX,OFFSET FNAME_DST
MOV CX,0
MOV AH,3CH
INT 21H
JNC WRITEINTVECTAB_CREAOK
MOV DX,OFFSET MESS_CREAERR
CALL DISPMESS
CALL NEWLINE
JMP WRITEINTVECTAB_OK
WRITEINTVECTAB_CREAOK:MOV HANDLE_DST,AX
MOV BX,0
MOV BP,0
WRITEINTVECTAB_FORJ1:CMP BP,256
JAE WRITEINTVECTAB_CLOSEF
MOV AX,0
MOV ES,AX
MOV DI,BX
MOV CX,4
MOV DIS_LEN,0
MOV AX,BP
CALL DAHTOBUF
MOV AX,ES:[DI+2]
CALL DHTOBUF
MOV AX,ES:[DI]
CALL DHTOBUF
MOV SI,DIS_LEN
MOV NUM_DX,CX
MOV CX,SI
MOV DX,OFFSET DIS_BUF
MOV NUM_BX,BX
MOV BX,HANDLE_DST
MOV AH,40H
INT 21H
JC WRITEINTVECTAB_WERROR
MOV BX,NUM_BX
MOV CX,NUM_DX
CALL WRITEARRAY
JC WRITEINTVECTAB_WERROR
WRITEINTVECTAB_NEXTJ1:INC BP
INC BX
INC BX
INC BX
INC BX
JMP WRITEINTVECTAB_FORJ1
WRITEINTVECTAB_WERROR:MOV DX,OFFSET MESS_WRITERR
CALL DISPMESS
CALL NEWLINE
MOV BX,HANDLE_DST
MOV AH,3EH
INT 21H
STC
JMP WRITEINTVECTAB_OK
WRITEINTVECTAB_CLOSEF:MOV BX,HANDLE_DST
MOV AH,3EH
INT 21H
CLC
WRITEINTVECTAB_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
WRITEINTVECTAB ENDP
CSEG ENDS
END START
题5.26请写一个能够显示指定向量号的中断向量的程序。
WINTOP = 0
WINLEFT = 0
WINBOTTOM = 24
WINRIGHT = 79
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
GETSTR_BUF DB 128 DUP (0)
DIS_BUF DB 128 DUP (0)
DIS_LEN DW 0
NUM_INTVEC DW 0
res_dx dw 0
res_cx dw 0
res_bx dw 0
res_ax dw 0
num_dx dw 0
num_cx dw 0
num_bx dw 0
num_ax dw 0
val_dx dw 0
val_cx dw 0
val_bx dw 0
val_ax dw 0
mul_table dd 1,10,100,1000,10000,100000,1000000,10000000,100000000
shl_table db 0,4,8,12,0,4,8,12
HANDLE_DST DW 0
FNAME_DST DB 'TEST.TXT',0
MESS_CREAERR DB 'Can not create file',07H,'$'
MESS_WRITERR DB 'Writing error',07H,'$'
MESS_GETSTR DB 'Please input hex interrupt vector number:','$'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESS_GETSTR
CALL DISPMESS
MOV DI,OFFSET GETSTR_BUF
CALL GETSTRH
MOV SI,OFFSET GETSTR_BUF
ADD SI,2
MOV CX,WORD PTR GETSTR_BUF
SUB CX,2
CALL HTOBIN
MOV AX,VAL_AX
MOV NUM_INTVEC,AX
CALL DISINTVEC
MOV AH,4CH
INT 21H
ISHEX PROC
CMP AL,'0'
JB ISHEX_NOHEX
CMP AL,'9'
JA ISHEX_NODEC1
CLC
JMP ISHEX_OK
ISHEX_NODEC1:CMP AL,'A'
JB ISHEX_NOHEX
CMP AL,'F'
JA ISHEX_NODEC2
CLC
JMP ISHEX_OK
ISHEX_NODEC2:CMP AL,'a'
JB ISHEX_NOHEX
CMP AL,'f'
JA ISHEX_NOHEX
CLC
JMP ISHEX_OK
ISHEX_NOHEX:STC
ISHEX_OK:RET
ISHEX ENDP
ISDEC PROC
CMP AL,'0'
JB ISDEC_NODEC
CMP AL,'9'
JA ISDEC_NODEC
CLC
JMP ISDEC_OK
ISDEC_NODEC:STC
ISDEC_OK:RET
ISDEC ENDP
ATOBIN PROC
SUB AL,30H
CMP AL,9
JBE ATOBIN_OK
SUB AL,7
CMP AL,15
JBE ATOBIN_OK
SUB AL,20H
ATOBIN_OK:RET
ATOBIN ENDP
HTOBIN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV DI,SI
ADD DI,CX
DEC DI
MOV BX,0
MOV VAL_AX,0
MOV VAL_DX,0
HTOBIN_FORJ:CMP DI,SI
JB HTOBIN_OK
MOV AL,DS:[DI]
CALL ATOBIN
MOV AH,0
CMP BX,3
JA HTOBIN_JAD
MOV DX,0
MOV CL,SHL_TABLE[BX]
SHL AX,CL
ADD VAL_AX,AX
ADC VAL_DX,DX
JMP HTOBIN_NEXTJ
HTOBIN_JAD:MOV DX,AX
MOV AX,0
MOV CL,SHL_TABLE[BX]
SHL DX,CL
ADD VAL_AX,AX
ADC VAL_DX,DX
HTOBIN_NEXTJ:DEC DI
INC BX
JMP HTOBIN_FORJ
HTOBIN_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
HTOBIN ENDP
DTOBIN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DI,SI
ADD DI,CX
DEC DI
MOV BP,0
MOV VAL_AX,0
MOV VAL_DX,0
DTOBIN_FORJ:CMP DI,SI
JB DTOBIN_OK
MOV AL,DS:[DI]
CALL ATOBIN
MOV AH,0
MOV BX,AX
MOV AX,0
MOV DX,WORD PTR MUL_TABLE[BP]
MOV CX,WORD PTR MUL_TABLE[BP+2]
CALL MULDW
ADD VAL_AX,AX
ADC VAL_DX,BX
DTOBIN_NEXTJ:DEC DI
INC BP
INC BP
INC BP
INC BP
JMP DTOBIN_FORJ
DTOBIN_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOBIN ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRH PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRH1:CALL GETCH
CMP AL,CR
JZ GETSTRH5
CMP AL,BACKSPACE
JNZ GETSTRH4
CMP BX,0
JZ GETSTRH2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRH1
GETSTRH2:CALL BELL
JMP GETSTRH1
GETSTRH4:CMP BX,2
JZ GETSTRH2
CALL ISHEX
JC GETSTRH2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRH1
GETSTRH5:CMP BX,1
JB GETSTRH2
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRH_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRH ENDP
GETSTRD PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRD1:CALL GETCH
CMP AL,CR
JZ GETSTRD5
CMP AL,BACKSPACE
JNZ GETSTRD4
CMP BX,0
JZ GETSTRD2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRD1
GETSTRD2:CALL BELL
JMP GETSTRD1
GETSTRD4:CMP BX,3
JZ GETSTRD2
CALL ISDEC
JC GETSTRD2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRD1
GETSTRD5:CMP BX,1
JB GETSTRD2
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRD_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRD ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
MULDW PROC
MOV NUM_AX,AX
MOV NUM_BX,BX
MOV NUM_CX,CX
MOV NUM_DX,DX
MOV AX,NUM_AX
MOV BX,NUM_CX
MUL BX
MOV RES_DX,DX
MOV RES_CX,AX
MOV AX,NUM_BX
MOV BX,NUM_DX
MUL BX
MOV RES_BX,DX
MOV RES_AX,AX
MOV AX,NUM_AX
MOV BX,NUM_DX
MUL BX
ADD AX,RES_BX
ADC WORD PTR RES_CX,0
ADC WORD PTR RES_DX,0
ADD DX,RES_CX
ADC WORD PTR RES_DX,0
MOV RES_CX,DX
MOV RES_BX,AX
MOV AX,NUM_BX
MOV BX,NUM_CX
MUL BX
ADD AX,RES_BX
ADC WORD PTR RES_CX,0
ADC WORD PTR RES_DX,0
ADD DX,RES_CX
ADC WORD PTR RES_DX,0
MOV RES_CX,DX
MOV RES_BX,AX
MOV DX,RES_DX
MOV CX,RES_CX
MOV BX,RES_BX
MOV AX,RES_AX
RET
MULDW ENDP
HTOASC PROC
AND AL,0FH
ADD AL,30H
CMP AL,39H
JA HTOASC_NODEC
JMP HTOASC_OK
HTOASC_NODEC:ADD AL,7
HTOASC_OK:RET
HTOASC ENDP
AHTOASC PROC
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL HTOASC
XCHG AH,AL
CALL HTOASC
RET
AHTOASC ENDP
DHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH AX
XCHG AH,AL
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DHTOASC ENDP
DAHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DAHTOASC ENDP
DHTOBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV SI,WORD PTR DIS_LEN
PUSH AX
XCHG AH,AL
CALL AHTOASC
MOV BYTE PTR DIS_BUF[SI],AH
INC SI
MOV BYTE PTR DIS_BUF[SI],AL
INC SI
POP AX
CALL AHTOASC
MOV BYTE PTR DIS_BUF[SI],AH
INC SI
MOV BYTE PTR DIS_BUF[SI],AL
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV WORD PTR DIS_LEN,SI
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DHTOBUF ENDP
DAHTOBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV SI,WORD PTR DIS_LEN
CALL AHTOASC
MOV BYTE PTR DIS_BUF[SI],AH
INC SI
MOV BYTE PTR DIS_BUF[SI],AL
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV WORD PTR DIS_LEN,SI
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DAHTOBUF ENDP
DISARRAY PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
CMP CX,1
JB DISARRAY_OK
CMP CX,8000H
JA DISARRAY_OK
MOV SI,CX
MOV BP,0FFFFH
XOR DX,DX
MOV AX,ES
MOV CX,16
MUL CX
ADD AX,DI
ADC DX,0
CMP DX,000FH
JA DISARRAY_OK
MOV NUM_DX,DX
MOV NUM_AX,AX
MOV DX,000FH
MOV AX,0FFFFH
SUB AX,NUM_AX
SBB DX,NUM_DX
ADD AX,1
ADC DX,0
CMP DX,0
JNZ DISARRAY2
MOV BP,AX
DISARRAY2:XOR DX,DX
MOV AX,0FFFFH
SUB AX,DI
ADD AX,1
ADC DX,0
CMP DX,0
JZ DISARRAY5
MOV AX,0FFFFH
DISARRAY5:CMP AX,BP
JBE DISARRAY3
MOV AX,BP
DISARRAY3:CMP AX,SI
JAE DISARRAY1
MOV SI,AX
DISARRAY1:MOV AX,SI
XOR DX,DX
MOV CX,16
CALL DIVDW
MOV NUM_AX,AX
MOV NUM_CX,CX
MOV CX,SI
MOV BX,DI
MOV BP,0
MOV SI,0
DISARRAY_FORI1:CMP BP,CX
JAE DISARRAY_OK
CMP SI,NUM_AX
JZ DISARRAYZ
JA DISARRAY_OK
MOV NUM_BX,SI
MOV DIS_LEN,0
MOV AX,ES
CALL DHTOBUF
MOV SI,DIS_LEN
MOV BYTE PTR DIS_BUF[SI],':'
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV DIS_LEN,SI
MOV AX,BX
CALL DHTOBUF
MOV SI,NUM_BX
MOV DI,0
DISARRAY_FORJ1:CMP DI,16
JAE DISARRAY_FINISHJ1
MOV AL,ES:[BX]
CALL DAHTOBUF
DISARRAY_NEXTJ1:INC DI
INC BP
INC BX
JMP DISARRAY_FORJ1
DISARRAY_FINISHJ1:MOV SI,DIS_LEN
MOV BYTE PTR DIS_BUF[SI],0DH
INC SI
MOV BYTE PTR DIS_BUF[SI],0AH
INC SI
MOV DIS_LEN,SI
MOV NUM_DX,CX
MOV CX,SI
MOV SI,NUM_BX
MOV NUM_BX,BX
MOV BX,0
DISARRAY_S1:MOV DL,DIS_BUF[BX]
MOV AH,2
INT 21H
INC BX
LOOP DISARRAY_S1
JMP DISARRAY_NEXTI2
DISARRAYZ:MOV AX,NUM_CX
CMP AX,1
JB DISARRAY_NEXTI1
MOV NUM_BX,SI
MOV DIS_LEN,0
MOV AX,ES
CALL DHTOBUF
MOV SI,DIS_LEN
MOV BYTE PTR DIS_BUF[SI],':'
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV DIS_LEN,SI
MOV AX,BX
CALL DHTOBUF
MOV SI,NUM_BX
MOV DI,0
DISARRAY_FORJ2:CMP DI,NUM_CX
JAE DISARRAY_FINISHJ2
MOV AL,ES:[BX]
CALL DAHTOBUF
DISARRAY_NEXTJ2:INC DI
INC BP
INC BX
JMP DISARRAY_FORJ2
DISARRAY_FINISHJ2:MOV SI,DIS_LEN
MOV BYTE PTR DIS_BUF[SI],0DH
INC SI
MOV BYTE PTR DIS_BUF[SI],0AH
INC SI
MOV DIS_LEN,SI
MOV NUM_DX,CX
MOV CX,SI
MOV SI,NUM_BX
MOV NUM_BX,BX
MOV BX,0
DISARRAY_S2:MOV DL,DIS_BUF[BX]
MOV AH,2
INT 21H
INC BX
LOOP DISARRAY_S2
DISARRAY_NEXTI2:MOV BX,NUM_BX
MOV CX,NUM_DX
DISARRAY_NEXTI1:INC SI
JMP DISARRAY_FORI1
DISARRAY_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DISARRAY ENDP
WRITEARRAY PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
CMP CX,1
JB WRITEARRAY_OK
CMP CX,8000H
JA WRITEARRAY_OK
MOV SI,CX
MOV BP,0FFFFH
XOR DX,DX
MOV AX,ES
MOV CX,16
MUL CX
ADD AX,DI
ADC DX,0
CMP DX,000FH
JA WRITEARRAY_OK
MOV NUM_DX,DX
MOV NUM_AX,AX
MOV DX,000FH
MOV AX,0FFFFH
SUB AX,NUM_AX
SBB DX,NUM_DX
ADD AX,1
ADC DX,0
CMP DX,0
JNZ WRITEARRAY2
MOV BP,AX
WRITEARRAY2:XOR DX,DX
MOV AX,0FFFFH
SUB AX,DI
ADD AX,1
ADC DX,0
CMP DX,0
JZ WRITEARRAY5
MOV AX,0FFFFH
WRITEARRAY5:CMP AX,BP
JBE WRITEARRAY3
MOV AX,BP
WRITEARRAY3:CMP AX,SI
JAE WRITEARRAY1
MOV SI,AX
WRITEARRAY1:MOV AX,SI
XOR DX,DX
MOV CX,16
CALL DIVDW
MOV NUM_AX,AX
MOV NUM_CX,CX
MOV CX,SI
MOV BX,DI
MOV BP,0
MOV SI,0
WRITEARRAY_FORI1:CMP BP,CX
JAE WRITEARRAY_CLOSEF
CMP SI,NUM_AX
JZ WRITEARRAYZ
JA WRITEARRAY_CLOSEF
MOV NUM_BX,SI
MOV DIS_LEN,0
MOV AX,ES
CALL DHTOBUF
MOV SI,DIS_LEN
MOV BYTE PTR DIS_BUF[SI],':'
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV DIS_LEN,SI
MOV AX,BX
CALL DHTOBUF
MOV SI,NUM_BX
MOV DI,0
WRITEARRAY_FORJ1:CMP DI,16
JAE WRITEARRAY_FINISHJ1
MOV AL,ES:[BX]
CALL DAHTOBUF
WRITEARRAY_NEXTJ1:INC DI
INC BP
INC BX
JMP WRITEARRAY_FORJ1
WRITEARRAY_FINISHJ1:MOV SI,DIS_LEN
MOV BYTE PTR DIS_BUF[SI],0DH
INC SI
MOV BYTE PTR DIS_BUF[SI],0AH
INC SI
MOV DIS_LEN,SI
MOV NUM_DX,CX
MOV CX,SI
MOV SI,NUM_BX
MOV DX,OFFSET DIS_BUF
MOV NUM_BX,BX
MOV BX,HANDLE_DST
MOV AH,40H
INT 21H
JC WIRTEARRAY_WERROR
JMP WRITEARRAY_NEXTI2
WRITEARRAYZ:MOV AX,NUM_CX
CMP AX,1
JB WRITEARRAY_NEXTI1
MOV NUM_BX,SI
MOV DIS_LEN,0
MOV AX,ES
CALL DHTOBUF
MOV SI,DIS_LEN
MOV BYTE PTR DIS_BUF[SI],':'
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV DIS_LEN,SI
MOV AX,BX
CALL DHTOBUF
MOV SI,NUM_BX
MOV DI,0
WRITEARRAY_FORJ2:CMP DI,NUM_CX
JAE WRITEARRAY_FINISHJ2
MOV AL,ES:[BX]
CALL DAHTOBUF
WRITEARRAY_NEXTJ2:INC DI
INC BP
INC BX
JMP WRITEARRAY_FORJ2
WRITEARRAY_FINISHJ2:MOV SI,DIS_LEN
MOV BYTE PTR DIS_BUF[SI],0DH
INC SI
MOV BYTE PTR DIS_BUF[SI],0AH
INC SI
MOV DIS_LEN,SI
MOV NUM_DX,CX
MOV CX,SI
MOV SI,NUM_BX
MOV DX,OFFSET DIS_BUF
MOV NUM_BX,BX
MOV BX,HANDLE_DST
MOV AH,40H
INT 21H
JC WIRTEARRAY_WERROR
WRITEARRAY_NEXTI2:MOV BX,NUM_BX
MOV CX,NUM_DX
WRITEARRAY_NEXTI1:INC SI
JMP WRITEARRAY_FORI1
WIRTEARRAY_WERROR:STC
JMP WRITEARRAY_OK
WRITEARRAY_CLOSEF:CLC
WRITEARRAY_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
WRITEARRAY ENDP
DISINTVECTAB PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
MOV BX,0
MOV BP,0
DISINTVECTAB_FORJ1:CMP BP,256
JAE DISINTVECTAB_OK
MOV AX,0
MOV ES,AX
MOV DI,BX
MOV CX,4
MOV AX,BP
CALL DAHTOASC
MOV AL,20H
CALL PUTCH
MOV AX,ES:[DI+2]
CALL DHTOASC
MOV AL,20H
CALL PUTCH
MOV AX,ES:[DI]
CALL DHTOASC
MOV AL,20H
CALL PUTCH
CALL DISARRAY
DISINTVECTAB_NEXTJ1:INC BP
INC BX
INC BX
INC BX
INC BX
JMP DISINTVECTAB_FORJ1
DISINTVECTAB_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DISINTVECTAB ENDP
WRITEINTVECTAB PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
MOV DX,OFFSET FNAME_DST
MOV CX,0
MOV AH,3CH
INT 21H
JNC WRITEINTVECTAB_CREAOK
MOV DX,OFFSET MESS_CREAERR
CALL DISPMESS
CALL NEWLINE
JMP WRITEINTVECTAB_OK
WRITEINTVECTAB_CREAOK:MOV HANDLE_DST,AX
MOV BX,0
MOV BP,0
WRITEINTVECTAB_FORJ1:CMP BP,256
JAE WRITEINTVECTAB_CLOSEF
MOV AX,0
MOV ES,AX
MOV DI,BX
MOV CX,4
MOV DIS_LEN,0
MOV AX,BP
CALL DAHTOBUF
MOV AX,ES:[DI+2]
CALL DHTOBUF
MOV AX,ES:[DI]
CALL DHTOBUF
MOV SI,DIS_LEN
MOV NUM_DX,CX
MOV CX,SI
MOV DX,OFFSET DIS_BUF
MOV NUM_BX,BX
MOV BX,HANDLE_DST
MOV AH,40H
INT 21H
JC WRITEINTVECTAB_WERROR
MOV BX,NUM_BX
MOV CX,NUM_DX
CALL WRITEARRAY
JC WRITEINTVECTAB_WERROR
WRITEINTVECTAB_NEXTJ1:INC BP
INC BX
INC BX
INC BX
INC BX
JMP WRITEINTVECTAB_FORJ1
WRITEINTVECTAB_WERROR:MOV DX,OFFSET MESS_WRITERR
CALL DISPMESS
CALL NEWLINE
MOV BX,HANDLE_DST
MOV AH,3EH
INT 21H
STC
JMP WRITEINTVECTAB_OK
WRITEINTVECTAB_CLOSEF:MOV BX,HANDLE_DST
MOV AH,3EH
INT 21H
CLC
WRITEINTVECTAB_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
WRITEINTVECTAB ENDP
DISINTVEC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
MOV BX,NUM_INTVEC
ADD BX,BX
ADD BX,BX
MOV BP,NUM_INTVEC
MOV AX,0
MOV ES,AX
MOV DI,BX
MOV CX,4
MOV AX,BP
CALL DAHTOASC
MOV AL,20H
CALL PUTCH
MOV AX,ES:[DI+2]
CALL DHTOASC
MOV AL,20H
CALL PUTCH
MOV AX,ES:[DI]
CALL DHTOASC
MOV AL,20H
CALL PUTCH
CALL DISARRAY
DISINTVEC_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DISINTVEC ENDP
CSEG ENDS
END START
题5.27写一个程序采用十六进制数的形式显示所按键的扫描码及对应的ASCII码。当连续两次按回车键时终止程序。
WINTOP = 0
WINLEFT = 0
WINBOTTOM = 24
WINRIGHT = 79
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
res_dx dw 0
res_cx dw 0
res_bx dw 0
res_ax dw 0
num_dx dw 0
num_cx dw 0
num_bx dw 0
num_ax dw 0
val_dx dw 0
val_cx dw 0
val_bx dw 0
val_ax dw 0
prev_dx dw 0
prev_cx dw 0
prev_bx dw 0
prev_ax dw 0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL GETSTRKB
MOV AH,4CH
INT 21H
CLEARBUFKB PROC
PUSH AX
CLEARBUFKB_S:MOV AH,1
INT 16H
JZ CLEARBUFKB_OK
MOV AH,0
INT 16H
JMP CLEARBUFKB_S
CLEARBUFKB_OK:POP AX
RET
CLEARBUFKB ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
GETCH PROC
MOV AH,0
INT 16H
RET
GETCH ENDP
GETSTRKB PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
CALL CLEARBUFKB
MOV BX,0
GETSTRKB1:CALL GETCH
CMP AL,CR
JZ GETSTRKB5
CMP BX,20
JB GETSTRKB2
CALL NEWLINE
MOV BX,0
GETSTRKB2:CALL DHTOASC
INC BX
MOV PREV_AX,AX
JMP GETSTRKB1
GETSTRKB5:CMP BX,20
JB GETSTRKB3
CALL NEWLINE
MOV BX,0
GETSTRKB3:CALL DHTOASC
INC BX
CMP BYTE PTR PREV_AX,CR
JZ GETSTRKB_OK
MOV PREV_AX,AX
JMP GETSTRKB1
GETSTRKB_OK:
POP DX
POP CX
POP BX
POP AX
RET
GETSTRKB ENDP
HTOASC PROC
AND AL,0FH
ADD AL,30H
CMP AL,39H
JA HTOASC_NODEC
JMP HTOASC_OK
HTOASC_NODEC:ADD AL,7
HTOASC_OK:RET
HTOASC ENDP
AHTOASC PROC
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL HTOASC
XCHG AH,AL
CALL HTOASC
RET
AHTOASC ENDP
DHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH AX
XCHG AH,AL
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DHTOASC ENDP
DAHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DAHTOASC ENDP
CSEG ENDS
END START
题5.28写一个清屏程序。
WINTOP = 0
WINLEFT = 0
WINBOTTOM = 24
WINRIGHT = 79
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
res_dx dw 0
res_cx dw 0
res_bx dw 0
res_ax dw 0
num_dx dw 0
num_cx dw 0
num_bx dw 0
num_ax dw 0
val_dx dw 0
val_cx dw 0
val_bx dw 0
val_ax dw 0
prev_dx dw 0
prev_cx dw 0
prev_bx dw 0
prev_ax dw 0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL CLEARSCREEN
MOV AH,4CH
INT 21H
CLEARSCREEN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AL,DPAGE
MOV AH,5
INT 10H
MOV CH,WINTOP
MOV CL,WINLEFT
MOV DH,WINBOTTOM
MOV DL,WINRIGHT
MOV BH,COLOR
MOV AL,0
MOV AH,6
INT 10H
MOV BH,DPAGE
MOV DH,WINTOP
MOV DL,WINLEFT
MOV AH,2
INT 10H
CLEARSCREEN_OK:POP DX
POP CX
POP BX
POP AX
RET
CLEARSCREEN ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
CSEG ENDS
END START
题5.29写一个程序采用直接填显示缓冲区的方法在屏幕上循环显示26个大写字母。
当按任一键后终止程序，通过调用BIOS键盘管理模块的1号功能判别是否有键按下。
WINTOP = 0
WINLEFT = 0
WINBOTTOM = 24
WINRIGHT = 79
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
CLEARSTR_BUF DB 256 DUP (20H)
res_dx dw 0
res_cx dw 0
res_bx dw 0
res_ax dw 0
num_dx dw 0
num_cx dw 0
num_bx dw 0
num_ax dw 0
val_dx dw 0
val_cx dw 0
val_bx dw 0
val_ax dw 0
UPPERCHAR DB 8 DUP (0)
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL DISUPPERCHAR
MOV AH,4CH
INT 21H
SHOWSTR PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
MOV AX,0B800H
MOV ES,AX
MOV AL,80
MUL DH
XOR DH,DH
ADD AX,DX
ADD AX,AX
XCHG AX,BX
MOV AH,AL
JCXZ SHOWSTR_OK
SHOWSTR_S:MOV AL,DS:[SI]
INC SI
MOV ES:[BX],AX
INC BX
INC BX
LOOP SHOWSTR_S
SHOWSTR_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
SHOWSTR ENDP
CLEARSTR PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV SI,OFFSET CLEARSTR_BUF
MOV BL,COLOR
CALL SHOWSTR
CLEARSTR_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
CLEARSTR ENDP
DELAY PROC
push ax
push dx
mov ax,0
delay_s:sub ax,1
sbb dx,0
cmp ax,0
jne delay_s
cmp dx,0
jne delay_s
pop dx
pop ax
ret
DELAY ENDP
CLEARBUFKB PROC
PUSH AX
CLEARBUFKB_S:MOV AH,1
INT 16H
JZ CLEARBUFKB_OK
MOV AH,0
INT 16H
JMP CLEARBUFKB_S
CLEARBUFKB_OK:POP AX
RET
CLEARBUFKB ENDP
CHECKBUFKB PROC
PUSH AX
MOV AH,1
INT 16H
CHECKBUFKB_OK:POP AX
RET
CHECKBUFKB ENDP
GETCH PROC
MOV AH,0
INT 16H
RET
GETCH ENDP
DISUPPERCHAR PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CALL CLEARBUFKB
DISUPPERCHAR_FORBEGIN:MOV BYTE PTR UPPERCHAR,'A'
MOV DH,ROW
MOV DL,COLUMN
MOV BP,0
DISUPPERCHAR_FORI1:CMP BP,26
JAE DISUPPERCHAR_FINISHI1
MOV SI,OFFSET UPPERCHAR
MOV CX,1
MOV BL,COLOR
CALL SHOWSTR
push dx
mov dx,5000h
call delay
pop dx
CALL CHECKBUFKB
JZ DISUPPERCHAR_NEXTI1
CALL CLEARBUFKB
JMP DISUPPERCHAR_OK
DISUPPERCHAR_NEXTI1:INC BP
INC BYTE PTR UPPERCHAR
INC DL
INC DL
JMP DISUPPERCHAR_FORI1
DISUPPERCHAR_FINISHI1:MOV CX,52
MOV DH,ROW
MOV DL,COLUMN
CALL CLEARSTR
JMP DISUPPERCHAR_FORBEGIN
DISUPPERCHAR_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DISUPPERCHAR ENDP
CSEG ENDS
END START
题5.30写一个程序在屏幕上循环显示26个大写字母，每行显示10个，逐行变换显示的颜色。当按下ALT+F1键时终止程序。
按下ALT+F1键，系统扫描码为68H，ascii码为00H，判断按下ALT+F1键就是判断扫描码和ascii码是否为6800H
WINTOP = 0
WINLEFT = 0
WINBOTTOM = 24
WINRIGHT = 79
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ALTF1 = 6800H
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
CLEARSTR_BUF DB 256 DUP (20H)
res_dx dw 0
res_cx dw 0
res_bx dw 0
res_ax dw 0
num_dx dw 0
num_cx dw 0
num_bx dw 0
num_ax dw 0
val_dx dw 0
val_cx dw 0
val_bx dw 0
val_ax dw 0
UPPERCHAR DB 8 DUP (0)
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL DISUPPERCHAR
MOV AH,4CH
INT 21H
SHOWSTR PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
MOV AX,0B800H
MOV ES,AX
MOV AL,80
MUL DH
XOR DH,DH
ADD AX,DX
ADD AX,AX
XCHG AX,BX
MOV AH,AL
JCXZ SHOWSTR_OK
SHOWSTR_S:MOV AL,DS:[SI]
INC SI
MOV ES:[BX],AX
INC BX
INC BX
LOOP SHOWSTR_S
SHOWSTR_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
SHOWSTR ENDP
CLEARSTR PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV SI,OFFSET CLEARSTR_BUF
MOV BL,COLOR
CALL SHOWSTR
CLEARSTR_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
CLEARSTR ENDP
DELAY PROC
push ax
push dx
mov ax,0
delay_s:sub ax,1
sbb dx,0
cmp ax,0
jne delay_s
cmp dx,0
jne delay_s
pop dx
pop ax
ret
DELAY ENDP
CLEARBUFKB PROC
PUSH AX
CLEARBUFKB_S:MOV AH,1
INT 16H
JZ CLEARBUFKB_OK
MOV AH,0
INT 16H
JMP CLEARBUFKB_S
CLEARBUFKB_OK:POP AX
RET
CLEARBUFKB ENDP
CHECKBUFKB PROC
PUSH AX
MOV AH,1
INT 16H
CHECKBUFKB_OK:POP AX
RET
CHECKBUFKB ENDP
GETCH PROC
MOV AH,0
INT 16H
RET
GETCH ENDP
DISUPPERCHAR PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CALL CLEARBUFKB
DISUPPERCHAR_FORBEGIN:MOV BYTE PTR UPPERCHAR,'A'
MOV DH,ROW
MOV DL,COLUMN
MOV BL,COLOR
MOV BP,0
DISUPPERCHAR_FORI1:CMP BP,26
JAE DISUPPERCHAR_FINISHI1
CMP BP,10
JZ DISUPPERCHAR_LINE2
CMP BP,20
JZ DISUPPERCHAR_LINE3
JMP DISUPPERCHAR_LINE123
DISUPPERCHAR_LINE2:MOV DH,ROW + 1
MOV DL,COLUMN
MOV BL,COLOR + 2
JMP DISUPPERCHAR_LINE123
DISUPPERCHAR_LINE3:MOV DH,ROW + 2
MOV DL,COLUMN
MOV BL,COLOR + 3
JMP DISUPPERCHAR_LINE123
DISUPPERCHAR_LINE123:MOV SI,OFFSET UPPERCHAR
MOV CX,1
CALL SHOWSTR
push dx
mov dx,5000h
call delay
pop dx
DISUPPERCHAR_CHECK123:CALL CHECKBUFKB
JZ DISUPPERCHAR_NEXTI1
CALL GETCH
CMP AX,ALTF1
JZ DISUPPERCHAR_CHECKFN
JMP DISUPPERCHAR_CHECK123
DISUPPERCHAR_CHECKFN:CALL CLEARBUFKB
JMP DISUPPERCHAR_OK
DISUPPERCHAR_NEXTI1:INC BP
INC BYTE PTR UPPERCHAR
INC DL
INC DL
JMP DISUPPERCHAR_FORI1
DISUPPERCHAR_FINISHI1:MOV CX,172
MOV DH,ROW
MOV DL,COLUMN
CALL CLEARSTR
JMP DISUPPERCHAR_FORBEGIN
DISUPPERCHAR_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DISUPPERCHAR ENDP
CSEG ENDS
END START
题5.31写一个程序把屏幕上显示的大写字母全部变换为对应的小写字母。
WINTOP = 0
WINLEFT = 0
WINBOTTOM = 24
WINRIGHT = 79
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ALTF1 = 6800H
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
res_dx dw 0
res_cx dw 0
res_bx dw 0
res_ax dw 0
num_dx dw 0
num_cx dw 0
num_bx dw 0
num_ax dw 0
val_dx dw 0
val_cx dw 0
val_bx dw 0
val_ax dw 0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL CONVERTSCREEN
MOV AH,4CH
INT 21H
ISUPPER PROC
CMP AL,'A'
JB ISUPPER_NOUPPER
CMP AL,'Z'
JA ISUPPER_NOUPPER
CLC
JMP ISUPPER_OK
ISUPPER_NOUPPER:STC
ISUPPER_OK:RET
ISUPPER ENDP
ISLOWER PROC
CMP AL,'a'
JB ISLOWER_NOLOWER
CMP AL,'z'
JA ISLOWER_NOLOWER
CLC
JMP ISLOWER_OK
ISLOWER_NOLOWER:STC
ISLOWER_OK:RET
ISLOWER ENDP
CONVERTSCREEN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
MOV AH,0FH
INT 10H
MOV CL,AH
MOV CH,25
MOV DI,CX
MOV AH,3
INT 10H
MOV CX,DI
MOV BP,DX
MOV DH,0
CONVERTSCREEN_FORI1:CMP DH,CH
JAE CONVERTSCREEN_FINISHI1
MOV DL,0
CONVERTSCREEN_FORJ1:CMP DL,CL
JAE CONVERTSCREEN_NEXTI1
MOV AH,2
INT 10H
MOV AH,8
INT 10H
CALL ISUPPER
JC CONVERTSCREEN_NEXTJ1
ADD AL,20H
MOV CX,1
MOV AH,0AH
INT 10H
MOV CX,DI
CONVERTSCREEN_NEXTJ1:INC DL
JMP CONVERTSCREEN_FORJ1
CONVERTSCREEN_NEXTI1:INC DH
JMP CONVERTSCREEN_FORI1
CONVERTSCREEN_FINISHI1:MOV DX,BP
MOV AH,2
INT 10H
CONVERTSCREEN_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
CONVERTSCREEN ENDP
CSEG ENDS
END START
题5.32写一个程序统计当前屏幕上显示的字母个数。
WINTOP = 0
WINLEFT = 0
WINBOTTOM = 24
WINRIGHT = 79
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ALTF1 = 6800H
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
res_dx dw 0
res_cx dw 0
res_bx dw 0
res_ax dw 0
num_dx dw 0
num_cx dw 0
num_bx dw 0
num_ax dw 0
val_dx dw 0
val_cx dw 0
val_bx dw 0
val_ax dw 0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL SUMSCREEN
MOV AH,4CH
INT 21H
ISUPLOW PROC
CMP AL,'A'
JB ISUPLOW_NOUPLOW
CMP AL,'Z'
JA ISUPLOW_NOUPPER
CLC
JMP ISUPLOW_OK
ISUPLOW_NOUPPER:CMP AL,'a'
JB ISUPLOW_NOUPLOW
CMP AL,'z'
JA ISUPLOW_NOUPLOW
CLC
JMP ISUPLOW_OK
ISUPLOW_NOUPLOW:STC
ISUPLOW_OK:RET
ISUPLOW ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
DTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CMP DX,0
JNZ DTOASC1
CMP AX,0
JNZ DTOASC1
MOV AL,'0'
CALL PUTCH
JMP DTOASC_OK
DTOASC1:mov bp,0
divide_dtoasc:cmp dx,0
jz finish_s_dtoasc1
divide_s_dtoasc:mov cx,10
call divdw
inc bp
push cx
jmp divide_dtoasc
finish_s_dtoasc1:cmp ax,0
jz finish_dtoasc
jmp divide_s_dtoasc
finish_dtoasc:mov cx,bp
jcxz DTOASC_OK
string_dtoasc:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string_dtoasc
DTOASC_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOASC ENDP
SUMSCREEN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
MOV AH,0FH
INT 10H
MOV CL,AH
MOV CH,25
MOV DI,CX
MOV AH,3
INT 10H
MOV CX,DI
MOV BP,DX
MOV SI,0
MOV DH,0
SUMSCREEN_FORI1:CMP DH,CH
JAE SUMSCREEN_FINISHI1
MOV DL,0
SUMSCREEN_FORJ1:CMP DL,CL
JAE SUMSCREEN_NEXTI1
MOV AH,2
INT 10H
MOV AH,8
INT 10H
CALL ISUPLOW
JC SUMSCREEN_NEXTJ1
INC SI
MOV CX,DI
SUMSCREEN_NEXTJ1:INC DL
JMP SUMSCREEN_FORJ1
SUMSCREEN_NEXTI1:INC DH
JMP SUMSCREEN_FORI1
SUMSCREEN_FINISHI1:MOV DX,BP
MOV AH,2
INT 10H
MOV AX,SI
XOR DX,DX
CALL DTOASC
CALL NEWLINE
SUMSCREEN_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
SUMSCREEN ENDP
CSEG ENDS
END START
题5.33写一个程序判别屏幕上是否显示字符串“AB”。在屏幕的最底行显示提示信息，按任意键后终止程序。
WINTOP = 0
WINLEFT = 0
WINBOTTOM = 24
WINRIGHT = 79
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ALTF1 = 6800H
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
SCREEN_BUF DB 2048 DUP (0)
IDX_ARRAY DW 1024 DUP (0)
CLEARSTR_BUF DB 256 DUP (20H)
res_dx dw 0
res_cx dw 0
res_bx dw 0
res_ax dw 0
num_dx dw 0
num_cx dw 0
num_bx dw 0
num_ax dw 0
val_dx dw 0
val_cx dw 0
val_bx dw 0
val_ax dw 0
FIND_BUF DB 'AB'
FIND_LEN DW 2
RES_LEN DW 0
NUM_BP DW 0
MESS_RES DB 'Can not find string','$'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL CLEARBUFKB
GETFIND_CHECK:CALL GETSCREEN
CALL FINDSTR
push dx
mov dx,5000h
call delay
pop dx
CALL CHECKBUFKB
JZ GETFIND_CHECK
CALL CLEARBUFKB
MOV AH,4CH
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
DTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CMP DX,0
JNZ DTOASC1
CMP AX,0
JNZ DTOASC1
MOV AL,'0'
CALL PUTCH
JMP DTOASC_OK
DTOASC1:mov bp,0
divide_dtoasc:cmp dx,0
jz finish_s_dtoasc1
divide_s_dtoasc:mov cx,10
call divdw
inc bp
push cx
jmp divide_dtoasc
finish_s_dtoasc1:cmp ax,0
jz finish_dtoasc
jmp divide_s_dtoasc
finish_dtoasc:mov cx,bp
jcxz DTOASC_OK
string_dtoasc:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string_dtoasc
DTOASC_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOASC ENDP
GETSCREEN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
MOV AH,0FH
INT 10H
MOV CL,AH
MOV CH,25
MOV DI,CX
MOV AH,3
INT 10H
MOV CX,DI
MOV BP,DX
MOV SI,OFFSET SCREEN_BUF 
MOV DH,0
GETSCREEN_FORI1:CMP DH,CH
JAE GETSCREEN_FINISHI1
MOV DL,0
GETSCREEN_FORJ1:CMP DL,CL
JAE GETSCREEN_NEXTI1
MOV AH,2
INT 10H
MOV AH,8
INT 10H
MOV DS:[SI],AL
INC SI
GETSCREEN_NEXTJ1:INC DL
JMP GETSCREEN_FORJ1
GETSCREEN_NEXTI1:INC DH
JMP GETSCREEN_FORI1
GETSCREEN_FINISHI1:MOV DX,BP
MOV AH,2
INT 10H
GETSCREEN_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
GETSCREEN ENDP
DISIDXARRAY PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
MOV BH,0
MOV DH,WINBOTTOM
MOV DL,WINLEFT
MOV AH,2
INT 10H
MOV DI,OFFSET IDX_ARRAY
MOV BP,0
DISIDXARRAY_FORI1:CMP BP,WORD PTR RES_LEN
JAE DISIDXARRAY_FINISHI1
MOV AX,DS:[DI]
XOR DX,DX
MOV CX,80
CALL DIVDW
CALL DTOASC
MOV AL,2CH
CALL PUTCH
MOV AX,CX
XOR DX,DX
CALL DTOASC
MOV AL,20H
CALL PUTCH
DISIDXARRAY_NEXTI1:INC BP
INC DI
INC DI
JMP DISIDXARRAY_FORI1
DISIDXARRAY_FINISHI1:CALL NEWLINE
DISIDXARRAY_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DISIDXARRAY ENDP
SHOWSTR PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
MOV AX,0B800H
MOV ES,AX
MOV AL,80
MUL DH
XOR DH,DH
ADD AX,DX
ADD AX,AX
XCHG AX,BX
MOV AH,AL
JCXZ SHOWSTR_OK
SHOWSTR_S:MOV AL,DS:[SI]
INC SI
MOV ES:[BX],AX
INC BX
INC BX
LOOP SHOWSTR_S
SHOWSTR_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
SHOWSTR ENDP
CLEARSTR PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV SI,OFFSET CLEARSTR_BUF
MOV BL,COLOR
CALL SHOWSTR
CLEARSTR_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
CLEARSTR ENDP
DELAY PROC
push ax
push dx
mov ax,0
delay_s:sub ax,1
sbb dx,0
cmp ax,0
jne delay_s
cmp dx,0
jne delay_s
pop dx
pop ax
ret
DELAY ENDP
CLEARBUFKB PROC
PUSH AX
CLEARBUFKB_S:MOV AH,1
INT 16H
JZ CLEARBUFKB_OK
MOV AH,0
INT 16H
JMP CLEARBUFKB_S
CLEARBUFKB_OK:POP AX
RET
CLEARBUFKB ENDP
CHECKBUFKB PROC
PUSH AX
MOV AH,1
INT 16H
CHECKBUFKB_OK:POP AX
RET
CHECKBUFKB ENDP
GETCH PROC
MOV AH,0
INT 16H
RET
GETCH ENDP
FINDSTR PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
MOV AX,0
MOV BP,AX
MOV RES_LEN,AX
MOV WORD PTR FIND_LEN,2
MOV AX,2000
SUB AX,FIND_LEN
MOV NUM_BP,AX
FINDSTR_FORI1:MOV AX,BP
CMP AX,NUM_BP
JA FINDSTR_FINISHI1
MOV CX,FIND_LEN
MOV DI,OFFSET FIND_BUF
MOV SI,BP
FINDSTR_FORJ1:MOV AL,DS:[DI]
CMP SCREEN_BUF[SI],AL
JNZ FINDSTR_NEXTI1
FINDSTR_NEXTJ1:INC DI
INC SI
LOOP FINDSTR_FORJ1
MOV BX,RES_LEN
ADD BX,BX
MOV AX,BP
MOV IDX_ARRAY[BX],AX
INC WORD PTR RES_LEN
FINDSTR_NEXTI1:INC BP
JMP FINDSTR_FORI1
FINDSTR_FINISHI1:MOV AX,RES_LEN
CMP AX,0
JNZ FINDSTR_RESOK
MOV CX,80
MOV DH,WINBOTTOM
MOV DL,WINLEFT
CALL CLEARSTR
MOV BH,0
MOV DH,WINBOTTOM
MOV DL,WINLEFT
MOV AH,2
INT 10H
MOV DX,OFFSET MESS_RES
CALL DISPMESS
CALL NEWLINE
JMP FINDSTR_OK
FINDSTR_RESOK:MOV CX,80
MOV DH,WINBOTTOM
MOV DL,WINLEFT
CALL CLEARSTR
CALL DISIDXARRAY
FINDSTR_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
FINDSTR ENDP
CSEG ENDS
END START
题5.34通过调整BIOS中的键盘中断处理程序，可使到所按的大写字母全部变换为对应的小写字母。写一个测试程序验证上述方法。
0040：17单元存储键盘状态字节，该字节记录了控制键和切换键的状态。
键盘状态字节各位记录的信息如下。
0：右shift状态，置1表示按下右shift键；
1：左shift状态，置1表示按下左shift键；
2：Ctrl状态，置1表示按下Ctrl键；
3：Alt状态，置1表示按下Alt键；
4：ScrollLock状态，置1表示Scroll指示灯亮；
5：NumLock状态，置1表示小键盘输入的是数字；
6：CapsLock状态，置1表示输入大写字母；
7：Insert状态，置1表示处于删除态。
10111100b 位6、1、0的值为0，则输入的字母都是小写字母
在新的9号中断处理程序中调用了原来BIOS的9号中断处理程序，并且在调用完成后把键盘状态字节位6、1、0的值修改为0
WINTOP = 0
WINLEFT = 0
WINBOTTOM = 24
WINRIGHT = 79
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ALTF1 = 6800H
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:CSEG
OLD09H DD ?
NEW09H_OFF = 200H
NEW09H_SEG = 0
NEW09H_BEGIN:PUSH DS
PUSH ES
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,CSEG
MOV DS,AX
pushf
pushf
pop bx
and bh,11111100b
push bx
popf
call dword ptr ds:[0]
mov ax,0040H
mov es,ax
mov al,es:[0017H]
and al,10111100b
mov es:[0017H],al
POP DX
POP CX
POP BX
POP AX
POP ES
POP DS
IRET
NEW09H_LEN = $ - OFFSET NEW09H_BEGIN
START:PUSH CS
POP DS
mov si,offset NEW09H_BEGIN
mov ax,NEW09H_SEG
mov es,ax
mov di,NEW09H_OFF
mov cx,NEW09H_LEN
cld
rep movsb
MOV AX,3509H
INT 21H
MOV WORD PTR OLD09H,BX
MOV WORD PTR OLD09H+2,ES
mov ax,NEW09H_SEG
mov ds,ax
MOV DX,NEW09H_OFF
MOV AX,2509H
INT 21H
PUSH CS
POP DS
CHECK_KB:CALL GETCH
CALL PUTCH
CMP AX,ALTF1
JNZ CHECK_KB
LDS DX,OLD09H
MOV AX,2509H
INT 21H
MOV AH,4CH
INT 21H
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
GETCH PROC
MOV AH,0
INT 16H
RET
GETCH ENDP
CSEG ENDS
END START
题5.35通过调整BIOS中的键盘I/O程序，可使到所按的大写字母全部变换为对应的小写字母。写一个测试程序验证上述方法。
在新的16H号中断处理程序中调用了原来BIOS的16H号中断处理程序，并且在调用完成后判断是否为大写字母。
如果是大写字母，则转换为小写字母。
WINTOP = 0
WINLEFT = 0
WINBOTTOM = 24
WINRIGHT = 79
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ALTF1 = 6800H
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:CSEG
OLD16H DD ?
NEW16H_OFF = 200H
NEW16H_SEG = 0
NEW16H_BEGIN:PUSH DS
PUSH ES
PUSH BX
PUSH CX
PUSH DX
MOV DX,AX
MOV AX,CSEG
MOV DS,AX
MOV AX,DX
pushf
pushf
pop bx
and bh,11111100b
push bx
popf
call dword ptr ds:[0]
CMP DH,02H
JAE NEW16H_OK
CALL ISUPPER
JC NEW16H_OK
ADD AL,20H
NEW16H_OK:
POP DX
POP CX
POP BX
POP ES
POP DS
IRET
ISUPPER PROC
CMP AL,'A'
JB ISUPPER_NOUPPER
CMP AL,'Z'
JA ISUPPER_NOUPPER
CLC
JMP ISUPPER_OK
ISUPPER_NOUPPER:STC
ISUPPER_OK:RET
ISUPPER ENDP
NEW16H_LEN = $ - OFFSET NEW16H_BEGIN
START:PUSH CS
POP DS
mov si,offset NEW16H_BEGIN
mov ax,NEW16H_SEG
mov es,ax
mov di,NEW16H_OFF
mov cx,NEW16H_LEN
cld
rep movsb
MOV AX,3516H
INT 21H
MOV WORD PTR OLD16H,BX
MOV WORD PTR OLD16H+2,ES
mov ax,NEW16H_SEG
mov ds,ax
MOV DX,NEW16H_OFF
MOV AX,2516H
INT 21H
PUSH CS
POP DS
CHECK_KB:CALL GETCH
CALL PUTCH
CMP AX,ALTF1
JNZ CHECK_KB
LDS DX,OLD16H
MOV AX,2516H
INT 21H
MOV AH,4CH
INT 21H
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
GETCH PROC
MOV AH,0
INT 16H
RET
GETCH ENDP
CSEG ENDS
END START
题5.36通过调整BIOS中的显示I/O程序是否可使屏幕上只显示小写字母？为什么？编写程序测试之。
可以，但是10H号中断处理程序中13H号功能仍然可以显示大写字母
在新的10H号中断处理程序中调用了原来BIOS的10H号中断处理程序，并且在调用之前判断是否为大写字母。
如果是大写字母，则转换为小写字母。
WINTOP = 0
WINLEFT = 0
WINBOTTOM = 24
WINRIGHT = 79
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ALTF1 = 6800H
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:CSEG
OLD10H DD ?
NEW10H_OFF = 200H
NEW10H_SEG = 0
NEW10H_BEGIN:PUSH DS
PUSH SI
PUSH DI
MOV SI,AX
MOV AX,CSEG
MOV DS,AX
MOV AX,SI
SHR SI,1
SHR SI,1
SHR SI,1
SHR SI,1
SHR SI,1
SHR SI,1
SHR SI,1
SHR SI,1
CMP SI,09H
JZ NEW10H_CHECK
CMP SI,0AH
JZ NEW10H_CHECK
CMP SI,0EH
JZ NEW10H_CHECK
JMP NEW10H_NOCHECK
NEW10H_CHECK:CALL ISUPPER
JC NEW10H_NOCHECK
ADD AL,20H
NEW10H_NOCHECK:MOV DI,BX
pushf
pushf
pop bx
and bh,11111100b
push bx
popf
MOV BX,DI
call dword ptr ds:[0]
NEW10H_OK:
POP DI
POP SI
POP DS
IRET
ISUPPER PROC
CMP AL,'A'
JB ISUPPER_NOUPPER
CMP AL,'Z'
JA ISUPPER_NOUPPER
CLC
JMP ISUPPER_OK
ISUPPER_NOUPPER:STC
ISUPPER_OK:RET
ISUPPER ENDP
NEW10H_LEN = $ - OFFSET NEW10H_BEGIN
START:PUSH CS
POP DS
mov si,offset NEW10H_BEGIN
mov ax,NEW10H_SEG
mov es,ax
mov di,NEW10H_OFF
mov cx,NEW10H_LEN
cld
rep movsb
MOV AX,3510H
INT 21H
MOV WORD PTR OLD10H,BX
MOV WORD PTR OLD10H+2,ES
mov ax,NEW10H_SEG
mov ds,ax
MOV DX,NEW10H_OFF
MOV AX,2510H
INT 21H
PUSH CS
POP DS
CHECK_KB:CALL GETCH
CALL PUTCH
CMP AX,ALTF1
JNZ CHECK_KB
LDS DX,OLD10H
MOV AX,2510H
INT 21H
MOV AH,4CH
INT 21H
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
GETCH PROC
MOV AH,0
INT 16H
RET
GETCH ENDP
CSEG ENDS
END START
题5.37请写一个程序把当前目录下的TEST.TXT文件打印输出。
WINTOP = 0
WINLEFT = 0
WINBOTTOM = 24
WINRIGHT = 79
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ALTF1 = 6800H
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
PRINT_ERR = 00101000B
PRINT_ACK = 01000000B
DSEG SEGMENT
FILEBUF_RW DB 512 DUP (0)
FNAME_SRC DB 128 DUP (0)
GETSTR_BUF DB 128 DUP (0)
MESS_FNSRC DB 'Please input source filename:','$'
MESS_GETSTR DB 'Please input printer number:','$'
HANDLE_SRC DW 0
NUM_PRN DW 0
MESS_OPENERR DB 'Can not open file',07H,'$'
MESS_READERR DB 'Reading error',07h,'$'
MESS_FILEPTRERR DB 'Can not adjust file pointer',07H,'$'
MESS_GETLNERR DB 'Reading one line error',07h,'$'
MESS_PRINTERR DB 'print one char error',07h,'$'
MESS_PRINTNOT DB 'printer is not ready',07h,'$'
MESS_PRINTERRNOT DB 'Can not print',07h,'$'
res_dx dw 0
res_cx dw 0
res_bx dw 0
res_ax dw 0
num_dx dw 0
num_cx dw 0
num_bx dw 0
num_ax dw 0
val_dx dw 0
val_cx dw 0
val_bx dw 0
val_ax dw 0
mul_table dd 1,10,100,1000,10000,100000,1000000,10000000,100000000
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL PRINTFILE
MOV AH,4CH
INT 21H
ISDEC PROC
CMP AL,'0'
JB ISDEC_NODEC
CMP AL,'9'
JA ISDEC_NODEC
CLC
JMP ISDEC_OK
ISDEC_NODEC:STC
ISDEC_OK:RET
ISDEC ENDP
ISFNM PROC
CMP AL,2BH
JB ISFNM_NOFNM
CMP AL,3BH
JA ISFNM_NODEC1
CLC
JMP ISFNM_OK
ISFNM_NODEC1:CMP AL,41H
JB ISFNM_NOFNM
CMP AL,5FH
JA ISFNM_NODEC2
CLC
JMP ISFNM_OK
ISFNM_NODEC2:CMP AL,61H
JB ISFNM_NOFNM
CMP AL,7AH
JA ISFNM_NOFNM
CLC
JMP ISFNM_OK
ISFNM_NOFNM:STC
ISFNM_OK:RET
ISFNM ENDP
ATOBIN PROC
SUB AL,30H
CMP AL,9
JBE ATOBIN_OK
SUB AL,7
CMP AL,15
JBE ATOBIN_OK
SUB AL,20H
ATOBIN_OK:RET
ATOBIN ENDP
DTOBIN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DI,SI
ADD DI,CX
DEC DI
MOV BP,0
MOV VAL_AX,0
MOV VAL_DX,0
DTOBIN_FORJ:CMP DI,SI
JB DTOBIN_OK
MOV AL,DS:[DI]
CALL ATOBIN
MOV AH,0
MOV BX,AX
MOV AX,0
MOV DX,WORD PTR MUL_TABLE[BP]
MOV CX,WORD PTR MUL_TABLE[BP+2]
CALL MULDW
ADD VAL_AX,AX
ADC VAL_DX,BX
DTOBIN_NEXTJ:DEC DI
INC BP
INC BP
INC BP
INC BP
JMP DTOBIN_FORJ
DTOBIN_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOBIN ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRD PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRD1:CALL GETCH
CMP AL,CR
JZ GETSTRD5
CMP AL,BACKSPACE
JNZ GETSTRD4
CMP BX,0
JZ GETSTRD2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRD1
GETSTRD2:CALL BELL
JMP GETSTRD1
GETSTRD4:CMP BX,1
JZ GETSTRD2
CALL ISDEC
JC GETSTRD2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRD1
GETSTRD5:CMP BX,1
JB GETSTRD2
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRD_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRD ENDP
GETSTRFN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRFN1:CALL GETCH
CMP AL,CR
JZ GETSTRFN5
CMP AL,BACKSPACE
JNZ GETSTRFN4
CMP BX,0
JZ GETSTRFN2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRFN1
GETSTRFN2:CALL BELL
JMP GETSTRFN1
GETSTRFN4:CMP BX,78
JZ GETSTRFN2
CALL ISFNM
JC GETSTRFN2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRFN1
GETSTRFN5:CMP BX,1
JB GETSTRFN2
MOV AL,0
MOV [BX][DI+2],AL
INC BX
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRFN_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRFN ENDP
MULDW PROC
MOV NUM_AX,AX
MOV NUM_BX,BX
MOV NUM_CX,CX
MOV NUM_DX,DX
MOV AX,NUM_AX
MOV BX,NUM_CX
MUL BX
MOV RES_DX,DX
MOV RES_CX,AX
MOV AX,NUM_BX
MOV BX,NUM_DX
MUL BX
MOV RES_BX,DX
MOV RES_AX,AX
MOV AX,NUM_AX
MOV BX,NUM_DX
MUL BX
ADD AX,RES_BX
ADC WORD PTR RES_CX,0
ADC WORD PTR RES_DX,0
ADD DX,RES_CX
ADC WORD PTR RES_DX,0
MOV RES_CX,DX
MOV RES_BX,AX
MOV AX,NUM_BX
MOV BX,NUM_CX
MUL BX
ADD AX,RES_BX
ADC WORD PTR RES_CX,0
ADC WORD PTR RES_DX,0
ADD DX,RES_CX
ADC WORD PTR RES_DX,0
MOV RES_CX,DX
MOV RES_BX,AX
MOV DX,RES_DX
MOV CX,RES_CX
MOV BX,RES_BX
MOV AX,RES_AX
RET
MULDW ENDP
HTOASC PROC
AND AL,0FH
ADD AL,30H
CMP AL,39H
JA HTOASC_NODEC
JMP HTOASC_OK
HTOASC_NODEC:ADD AL,7
HTOASC_OK:RET
HTOASC ENDP
AHTOASC PROC
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL HTOASC
XCHG AH,AL
CALL HTOASC
RET
AHTOASC ENDP
DAHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DAHTOASC ENDP
DHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH AX
XCHG AH,AL
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DHTOASC ENDP
GETLNBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV NUM_BX,BX
MOV NUM_DX,DX
MOV DI,DX
MOV WORD PTR [DI],0
ADD DX,2
MOV CX,256
MOV AH,3FH
INT 21H
JC GETLNBUF_READERR
CMP AX,0
JZ GETLNBUF_FINISH
MOV BP,AX
MOV BX,NUM_DX
MOV SI,0
MOV DI,0
GETLNBUF_FORI1:CMP SI,BP
JAE GETLNBUF_FINISHI1
MOV AL,[BX][DI+2]
CMP AL,LF
JZ GETLNBUF_NEXTI2
JMP GETLNBUF_NEXTI1
GETLNBUF_NEXTI2:INC SI
INC DI
JMP GETLNBUF_FINISHI1
GETLNBUF_NEXTI1:INC SI
INC DI
JMP GETLNBUF_FORI1
GETLNBUF_FINISHI1:MOV WORD PTR [BX],SI
CMP SI,BP
JAE GETLNBUF_FINISH
MOV DX,SI
SUB DX,BP
MOV CX,0FFFFH
MOV BX,NUM_BX
MOV AX,4201H
INT 21H
JC GETLNBUF_FILEPTRERR
JMP GETLNBUF_FINISH
GETLNBUF_READERR:MOV DX,OFFSET MESS_READERR
CALL DISPMESS
STC
JMP GETLNBUF_OK
GETLNBUF_FILEPTRERR:MOV DX,OFFSET MESS_FILEPTRERR
CALL DISPMESS
STC
JMP GETLNBUF_OK
GETLNBUF_FINISH:CLC
GETLNBUF_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
GETLNBUF ENDP
PRINTLINE PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV NUM_BX,BX
MOV NUM_DX,DX
MOV DI,DX
MOV BP,WORD PTR [DI]
ADD DI,2
MOV SI,0
PRINTLINE_FORI1:CMP SI,BP
JAE PRINTLINE_FINISH
MOV AL,[DI]
MOV AH,0
MOV DX,NUM_BX
INT 17H
TEST AH,PRINT_ERR
JNZ PRINTLINE_PRINTERR
TEST AH,PRINT_ACK
JZ PRINTLINE_PRINTNOT
PRINTLINE_NEXTI1:INC SI
INC DI
JMP PRINTLINE_FORI1
PRINTLINE_PRINTERR:MOV DX,OFFSET MESS_PRINTERR
CALL DISPMESS
STC
JMP PRINTLINE_OK
PRINTLINE_PRINTNOT:MOV DX,OFFSET MESS_PRINTNOT
CALL DISPMESS
STC
JMP PRINTLINE_OK
PRINTLINE_FINISH:CLC
PRINTLINE_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
PRINTLINE ENDP
PRINTFILE PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DX,OFFSET MESS_FNSRC
CALL DISPMESS
MOV DI,OFFSET FNAME_SRC
CALL GETSTRFN
MOV DX,OFFSET MESS_GETSTR
CALL DISPMESS
MOV DI,OFFSET GETSTR_BUF
CALL GETSTRD
MOV DX,OFFSET FNAME_SRC
ADD DX,2
MOV AX,3D00H
INT 21H
JNC PRINTFILE_OPENOKSRC
PRINTFILE_OPENERRSRC:MOV DX,OFFSET MESS_OPENERR
CALL DISPMESS
JMP PRINTFILE_OK
PRINTFILE_OPENOKSRC:MOV HANDLE_SRC,AX
MOV SI,OFFSET GETSTR_BUF
ADD SI,2
MOV CX,WORD PTR GETSTR_BUF
SUB CX,2
CALL DTOBIN
MOV AX,VAL_AX
MOV NUM_PRN,AX
MOV DX,NUM_PRN
MOV AH,1
INT 17H
TEST AH,PRINT_ACK
JZ PRINTLINE_PRINTNOT
PRINTFILE_RWBUF:MOV DX,OFFSET FILEBUF_RW
MOV BX,HANDLE_SRC
CALL GETLNBUF
JC PRINTFILE_READERR
MOV AX,WORD PTR FILEBUF_RW
CMP AX,0
JZ PRINTFILE_RWFINISH
MOV BX,NUM_PRN
MOV DX,OFFSET FILEBUF_RW
CALL PRINTLINE
JC PRINTFILE_PRINTERRNOT
JMP PRINTFILE_RWBUF
PRINTFILE_PRINTNOT:MOV DX,OFFSET MESS_PRINTNOT
CALL DISPMESS
JMP PRINTFILE_RWFINISH
PRINTFILE_PRINTERRNOT:MOV DX,OFFSET MESS_PRINTERRNOT
CALL DISPMESS
JMP PRINTFILE_RWFINISH
PRINTFILE_READERR:MOV DX,OFFSET MESS_GETLNERR
CALL DISPMESS
PRINTFILE_RWFINISH:MOV BX,HANDLE_SRC
MOV AH,3EH
INT 21H
PRINTFILE_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
PRINTFILE ENDP
CSEG ENDS
END START
题5.38 写一个程序在屏幕中央显示系统当前时间，当同时按下左右SHIFT键时清屏，结束程序。
WINTOP = 0
WINLEFT = 0
WINBOTTOM = 24
WINRIGHT = 79
COLOR = 07H
DPAGE = 0
ROW = 12
COLUMN = 28
ALTF1 = 6800H
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:CSEG
OLD1CH DD ?
NEW1CH_OFF = 200H
NEW1CH_SEG = 0
COUNT_VAL= 18
NEW1CH_BEGIN:JMP SHORT NEW1CH_START
COUNT DW COUNT_VAL
DATETIME_BUF DB 19 DUP (?)
CURSOR DW ?
NEW1CH_START:CMP WORD PTR CS:(offset COUNT - offset NEW1CH_BEGIN + NEW1CH_OFF)[0],0
JZ NEXT
DEC WORD PTR CS:(offset COUNT - offset NEW1CH_BEGIN + NEW1CH_OFF)[0]
IRET
NEXT:MOV WORD PTR CS:(offset COUNT - offset NEW1CH_BEGIN + NEW1CH_OFF)[0],COUNT_VAL
STI
PUSH DS
PUSH ES
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH BP
PUSH CS
POP DS
PUSH DS
POP ES
MOV SI,offset DATETIME_BUF - offset NEW1CH_BEGIN + NEW1CH_OFF
CALL GETDATETIME
MOV BH,DPAGE
MOV AH,3
INT 10H
MOV WORD PTR CS:(offset CURSOR - offset NEW1CH_BEGIN + NEW1CH_OFF)[0],DX
MOV BP,offset DATETIME_BUF - offset NEW1CH_BEGIN + NEW1CH_OFF
MOV BH,DPAGE
MOV DH,ROW
MOV DL,COLUMN
MOV BL,COLOR
MOV CX,19
MOV AL,0
MOV AH,13H
INT 10H
MOV BH,DPAGE
MOV DX,WORD PTR CS:(offset CURSOR - offset NEW1CH_BEGIN + NEW1CH_OFF)[0]
MOV AH,2
INT 10H
POP BP
POP SI
POP DX
POP CX
POP BX
POP AX
POP ES
POP DS
IRET
GETDATETIME PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV AH,4
INT 1AH
MOV AL,CH
CALL TTASC
MOV BYTE PTR DS:[SI],AH
MOV BYTE PTR DS:[SI+1],AL
MOV AL,CL
CALL TTASC
MOV BYTE PTR DS:[SI+2],AH
MOV BYTE PTR DS:[SI+3],AL
MOV BYTE PTR DS:[SI+4],'-'
MOV AL,DH
CALL TTASC
MOV BYTE PTR DS:[SI+5],AH
MOV BYTE PTR DS:[SI+6],AL
MOV BYTE PTR DS:[SI+7],'-'
MOV AL,DL
CALL TTASC
MOV BYTE PTR DS:[SI+8],AH
MOV BYTE PTR DS:[SI+9],AL
MOV BYTE PTR DS:[SI+10],20H
MOV AH,2
INT 1AH
MOV AL,CH
CALL TTASC
MOV BYTE PTR DS:[SI+11],AH
MOV BYTE PTR DS:[SI+12],AL
MOV BYTE PTR DS:[SI+13],':'
MOV AL,CL
CALL TTASC
MOV BYTE PTR DS:[SI+14],AH
MOV BYTE PTR DS:[SI+15],AL
MOV BYTE PTR DS:[SI+16],':'
MOV AL,DH
CALL TTASC
MOV BYTE PTR DS:[SI+17],AH
MOV BYTE PTR DS:[SI+18],AL
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
GETDATETIME ENDP
TTASC PROC
MOV AH,AL
AND AL,0FH
SHR AH,1
SHR AH,1
SHR AH,1
SHR AH,1
ADD AX,3030H
RET
TTASC ENDP
NEW1CH_LEN = $ - OFFSET NEW1CH_BEGIN
START:PUSH CS
POP DS
mov si,offset NEW1CH_BEGIN
mov ax,NEW1CH_SEG
mov es,ax
mov di,NEW1CH_OFF
mov cx,NEW1CH_LEN
cld
rep movsb
MOV AX,351CH
INT 21H
MOV WORD PTR OLD1CH,BX
MOV WORD PTR OLD1CH+2,ES
mov ax,NEW1CH_SEG
mov ds,ax
MOV DX,NEW1CH_OFF
MOV AX,251CH
INT 21H
PUSH CS
POP DS
CHECK_LR:CALL CHECKLRSHIFT
JC CHECK_LR
CALL CLEARBUFKB
CALL CLEARSCREEN
LDS DX,OLD1CH
MOV AX,251CH
INT 21H
MOV AH,4CH
INT 21H
CLEARSCREEN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AL,DPAGE
MOV AH,5
INT 10H
MOV CH,WINTOP
MOV CL,WINLEFT
MOV DH,WINBOTTOM
MOV DL,WINRIGHT
MOV BH,COLOR
MOV AL,0
MOV AH,6
INT 10H
MOV BH,DPAGE
MOV DH,WINTOP
MOV DL,WINLEFT
MOV AH,2
INT 10H
CLEARSCREEN_OK:POP DX
POP CX
POP BX
POP AX
RET
CLEARSCREEN ENDP
CLEARBUFKB PROC
PUSH AX
CLEARBUFKB_S:MOV AH,1
INT 16H
JZ CLEARBUFKB_OK
MOV AH,0
INT 16H
JMP CLEARBUFKB_S
CLEARBUFKB_OK:POP AX
RET
CLEARBUFKB ENDP
CHECKLRSHIFT PROC
PUSH AX
PUSH ES
mov ax,0040H
mov es,ax
mov al,es:[0017H]
and al,00000011b
cmp al,03H
JZ CHECKLRSHIFT_LR
STC
JMP CHECKLRSHIFT_OK
CHECKLRSHIFT_LR:CLC
CHECKLRSHIFT_OK:POP ES
POP AX
RET
CHECKLRSHIFT ENDP
CSEG ENDS
END START
题5.39请谈谈汇编语言与机器系统的关系。
CPU能直接识别并遵照执行的指令称为机器指令。机器语言是用二进制编码的机器指令的集合及一组使用机器指令的规则。
汇编语言是汇编格式指令、伪指令的集合及一组使用这些指令的规则。
汇编格式指令是机器指令的符号表示，机器指令与CPU有着密切的关系，因此汇编语言也与CPU有着密切的关系。
通常，CPU的种类不同，对应的机器指令也就不同，使用的汇编语言也不同。
汇编语言与机器指令关系密切，可直接和有效地操纵硬件。
王爽汇编语言 课程设计一 重写后测试通过的完整程序如下
WINTOP = 0
WINLEFT = 0
WINBOTTOM = 24
WINRIGHT = 79
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ALTF1 = 6800H
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
DIS_BUF DB 128 DUP (0)
STR_BLANK DB 128 DUP (20H)
STR_YEAR_ARRAY db '1975','1976','1977','1978','1979','1980','1981','1982','1983'
db '1984','1985','1986','1987','1988','1989','1990','1991','1992'
db '1993','1994','1995'
NUM_INCOME_ARRAY dd 16,22,382,1356,2390,8000,16000,24486,50065
dd 97479,140417,197514,345980,590827,803530,1183000,1843000,2759000
dd 3753000,4649000,5937000
NUM_PEOPLE_ARRAY dw 3,7,9,13,28,38,130,220,476
dw 778,1001,1442,2258,2793,4037,5635,8226,11542
dw 14430,15257,17800
NUM_AVERAGE_ARRAY dd 21 DUP (0)
DIS_LEN DW 0
res_dx dw 0
res_cx dw 0
res_bx dw 0
res_ax dw 0
num_dx dw 0
num_cx dw 0
num_bx dw 0
num_ax dw 0
val_dx dw 0
val_cx dw 0
val_bx dw 0
val_ax dw 0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL DISARRAYINCOMEAVG
MOV AH,4CH
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
MULDW PROC
MOV NUM_AX,AX
MOV NUM_BX,BX
MOV NUM_CX,CX
MOV NUM_DX,DX
MOV AX,NUM_AX
MOV BX,NUM_CX
MUL BX
MOV RES_DX,DX
MOV RES_CX,AX
MOV AX,NUM_BX
MOV BX,NUM_DX
MUL BX
MOV RES_BX,DX
MOV RES_AX,AX
MOV AX,NUM_AX
MOV BX,NUM_DX
MUL BX
ADD AX,RES_BX
ADC WORD PTR RES_CX,0
ADC WORD PTR RES_DX,0
ADD DX,RES_CX
ADC WORD PTR RES_DX,0
MOV RES_CX,DX
MOV RES_BX,AX
MOV AX,NUM_BX
MOV BX,NUM_CX
MUL BX
ADD AX,RES_BX
ADC WORD PTR RES_CX,0
ADC WORD PTR RES_DX,0
ADD DX,RES_CX
ADC WORD PTR RES_DX,0
MOV RES_CX,DX
MOV RES_BX,AX
MOV DX,RES_DX
MOV CX,RES_CX
MOV BX,RES_BX
MOV AX,RES_AX
RET
MULDW ENDP
DIVDD PROC
MOV NUM_DX,DX
MOV NUM_CX,CX
MOV NUM_BX,BX
MOV NUM_AX,AX
MOV RES_BX,DI
MOV RES_AX,SI
XOR AX,AX
MOV VAL_DX,AX
MOV VAL_CX,AX
MOV VAL_BX,AX
MOV VAL_AX,AX
MOV RES_DX,AX
MOV RES_CX,AX
XOR CX,CX
DIVDD_FORJ1:CMP CX,64
JAE DIVDD_FINISHJ1
CLC
RCL NUM_AX,1
RCL NUM_BX,1
RCL NUM_CX,1
RCL NUM_DX,1
RCL RES_CX,1
RCL RES_DX,1
PUSHF
POP BX
MOV AX,RES_CX
MOV DX,RES_DX
SUB AX,RES_AX
SBB DX,RES_BX
PUSHF
TEST BL,01H
JNZ DIVDD_A1
POPF
JNC DIVDD_A2
JMP DIVDD_B1
DIVDD_A1:POPF
DIVDD_A2:MOV RES_CX,AX
MOV RES_DX,DX
STC
RCL VAL_AX,1
RCL VAL_BX,1
RCL VAL_CX,1
RCL VAL_DX,1
JMP DIVDD_NEXTJ1
DIVDD_B1:CLC
RCL VAL_AX,1
RCL VAL_BX,1
RCL VAL_CX,1
RCL VAL_DX,1
DIVDD_NEXTJ1:INC CX
JMP DIVDD_FORJ1
DIVDD_FINISHJ1:MOV DX,VAL_DX
MOV CX,VAL_CX
MOV BX,VAL_BX
MOV AX,VAL_AX
MOV DI,RES_DX
MOV SI,RES_CX
RET
DIVDD ENDP
DTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CMP DX,0
JNZ DTOASC1
CMP AX,0
JNZ DTOASC1
MOV AL,'0'
CALL PUTCH
JMP DTOASC_OK
DTOASC1:mov bp,0
divide_dtoasc:cmp dx,0
jz finish_s_dtoasc1
divide_s_dtoasc:mov cx,10
call divdw
inc bp
push cx
jmp divide_dtoasc
finish_s_dtoasc1:cmp ax,0
jz finish_dtoasc
jmp divide_s_dtoasc
finish_dtoasc:mov cx,bp
jcxz DTOASC_OK
string_dtoasc:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string_dtoasc
DTOASC_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOASC ENDP
DDTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CMP DX,0
JNZ DDTOASC1
CMP CX,0
JNZ DDTOASC1
CMP BX,0
JNZ DDTOASC1
CMP AX,0
JNZ DDTOASC1
MOV AL,'0'
CALL PUTCH
JMP DDTOASC_OK
DDTOASC1:mov bp,0
divide_ddtoasc:cmp dx,0
jz finish_s_ddtoasc1
divide_s_ddtoasc:mov di,0
mov si,10
call divdd
inc bp
push si
jmp divide_ddtoasc
finish_s_ddtoasc1:cmp cx,0
jz finish_s_ddtoasc2
jmp divide_s_ddtoasc
finish_s_ddtoasc2:cmp bx,0
jz finish_s_ddtoasc3
jmp divide_s_ddtoasc
finish_s_ddtoasc3:cmp ax,0
jz finish_ddtoasc
jmp divide_s_ddtoasc
finish_ddtoasc:mov cx,bp
jcxz DDTOASC_OK
string_ddtoasc:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string_ddtoasc
DDTOASC_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DDTOASC ENDP
DTOBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CMP DX,0
JNZ DTOBUF1
CMP AX,0
JNZ DTOBUF1
MOV SI,WORD PTR DIS_LEN
MOV BYTE PTR DIS_BUF[SI],'0'
INC SI
MOV WORD PTR DIS_LEN,SI
JMP DTOBUF_OK
DTOBUF1:MOV SI,WORD PTR DIS_LEN
mov bp,0
divide_dtobuf:cmp dx,0
jz finish_s_dtobuf1
divide_s_dtobuf:mov cx,10
call divdw
inc bp
push cx
jmp divide_dtobuf
finish_s_dtobuf1:cmp ax,0
jz finish_dtobuf
jmp divide_s_dtobuf
finish_dtobuf:mov cx,bp
jcxz DTOBUF_OK
string_dtobuf:pop bx
add bx,30h
MOV BYTE PTR DIS_BUF[SI],BL
INC SI
loop string_dtobuf
MOV WORD PTR DIS_LEN,SI
MOV CX,16
SUB CX,BP
MOV SI,OFFSET STR_BLANK
CALL STRTOBUF
DTOBUF_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOBUF ENDP
STRTOBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
JCXZ STRTOBUF_OK
MOV DI,SI
MOV BX,WORD PTR DIS_LEN
MOV BP,0
STRTOBUF_FORI1:CMP BP,CX
JAE STRTOBUF_FINISHI1
MOV AL,DS:[DI]
MOV BYTE PTR DIS_BUF[BX],AL
INC BX
STRTOBUF_NEXTI1:INC BP
INC DI
JMP STRTOBUF_FORI1
STRTOBUF_FINISHI1:MOV WORD PTR DIS_LEN,BX
STRTOBUF_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
STRTOBUF ENDP
SHOWSTR PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
MOV AX,0B800H
MOV ES,AX
MOV AL,80
MUL DH
XOR DH,DH
ADD AX,DX
ADD AX,AX
XCHG AX,BX
MOV AH,AL
JCXZ SHOWSTR_OK
SHOWSTR_S:MOV AL,DS:[SI]
INC SI
MOV ES:[BX],AX
INC BX
INC BX
LOOP SHOWSTR_S
SHOWSTR_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
SHOWSTR ENDP
CLEARSCREEN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AL,DPAGE
MOV AH,5
INT 10H
MOV CH,WINTOP
MOV CL,WINLEFT
MOV DH,WINBOTTOM
MOV DL,WINRIGHT
MOV BH,COLOR
MOV AL,0
MOV AH,6
INT 10H
MOV BH,DPAGE
MOV DH,WINTOP
MOV DL,WINLEFT
MOV AH,2
INT 10H
CLEARSCREEN_OK:POP DX
POP CX
POP BX
POP AX
RET
CLEARSCREEN ENDP
DISARRAYINCOMEAVG PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CALL CLEARSCREEN
MOV DI,0
MOV BX,0
MOV BP,0
DISARRAYINCOMEAVG_FORI1:CMP BP,21
JAE DISARRAYINCOMEAVG_FINISHI1
MOV AX,WORD PTR NUM_INCOME_ARRAY[DI]
MOV DX,WORD PTR NUM_INCOME_ARRAY[DI+2]
MOV CX,NUM_PEOPLE_ARRAY[BX]
CALL DIVDW
MOV WORD PTR NUM_AVERAGE_ARRAY[DI+2],DX
MOV WORD PTR NUM_AVERAGE_ARRAY[DI],AX
DISARRAYINCOMEAVG_NEXTI1:INC BP
ADD BX,2
ADD DI,4
JMP DISARRAYINCOMEAVG_FORI1
DISARRAYINCOMEAVG_FINISHI1:MOV WORD PTR NUM_DX,0309H
MOV DI,0
MOV BX,0
MOV BP,0
DISARRAYINCOMEAVG_FORI2:CMP BP,21
JAE DISARRAYINCOMEAVG_OK
MOV WORD PTR DIS_LEN,0
MOV SI,OFFSET STR_YEAR_ARRAY
ADD SI,DI
MOV CX,4
CALL STRTOBUF
MOV SI,OFFSET STR_BLANK
MOV CX,12
CALL STRTOBUF
MOV AX,WORD PTR NUM_INCOME_ARRAY[DI]
MOV DX,WORD PTR NUM_INCOME_ARRAY[DI+2]
CALL DTOBUF
MOV AX,NUM_PEOPLE_ARRAY[BX]
MOV DX,0
CALL DTOBUF
MOV AX,WORD PTR NUM_AVERAGE_ARRAY[DI]
MOV DX,WORD PTR NUM_AVERAGE_ARRAY[DI+2]
CALL DTOBUF
MOV SI,OFFSET DIS_BUF
MOV CX,DIS_LEN
MOV NUM_BX,BX
MOV BL,COLOR
MOV DX,NUM_DX
CALL SHOWSTR
MOV BX,NUM_BX
DISARRAYINCOMEAVG_NEXTI2:INC BP
ADD BX,2
ADD DI,4
INC BYTE PTR NUM_DX[1]
JMP DISARRAYINCOMEAVG_FORI2
DISARRAYINCOMEAVG_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DISARRAYINCOMEAVG ENDP
CSEG ENDS
END START
使用INT 10H和INT 16H实现NEWLINE、PUTCH、GETCH这3个子程序
NEWLINE PROC
PUSH AX
PUSH BX
MOV BH,0
MOV AL,0DH
MOV AH,0EH
INT 10H
MOV AL,0AH
MOV AH,0EH
INT 10H
POP BX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH BX
MOV BH,0
MOV AH,0EH
INT 10H
POP BX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,0
INT 16H
RET
GETCH ENDP
王爽汇编语言 课程设计二 重写后测试通过的完整程序如下
WINTOP = 0
WINLEFT = 0
WINBOTTOM = 24
WINRIGHT = 79
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ALTF1 = 6800H
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
CSEG SEGMENT
ASSUME CS:CSEG,DS:CSEG
start:mov ax,cs
mov es,ax
mov bx,offset boot_main
mov ah,3
mov al,3
mov ch,0
mov cl,1
mov dh,0
mov dl,0
int 13h
mov ax,4c00h
int 21h
boot_main:jmp main_menu
STR_MENU1 db '1) Reset PC'
LEN_MENU1 = $ - OFFSET STR_MENU1
STR_MENU2 db '2) Start System'
LEN_MENU2 = $ - OFFSET STR_MENU2
STR_MENU3 db '3) Show Clock'
LEN_MENU3 = $ - OFFSET STR_MENU3
STR_MENU4 db '4) Set Clock'
LEN_MENU4 = $ - OFFSET STR_MENU4
STR_CHOICE db 'Please Enter Your Choice[1-4]'
LEN_CHOICE = $ - OFFSET STR_CHOICE
STR_DATETIME db 'Press F1 to change the color and Press ESC to return'
LEN_DATETIME = $ - OFFSET STR_DATETIME
STR_CLOCK db 'Press Input DateTime[YYYYMMDDhhmmss]'
LEN_CLOCK = $ - OFFSET STR_CLOCK
GETSTR_BUF DB 18 DUP (0)
DATETIME_BUF DB 19 DUP (?)
main_menu:mov ax,cs
mov es,ax
mov bx,7e00h
mov ah,2
mov al,2
mov ch,0
mov cl,2
mov dh,0
mov dl,0
int 13h
main_menu_start:CALL CLEARSCREEN
mov bx,cs
mov ds,bx
MOV SI,offset STR_MENU1 - offset boot_main + 7c00h
MOV CX,LEN_MENU1
MOV BL,COLOR
MOV DH,ROW
MOV DL,COLUMN
CALL SHOWSTR
MOV SI,offset STR_MENU2 - offset boot_main + 7c00h
MOV CX,LEN_MENU2
MOV DH,ROW + 1
CALL SHOWSTR
MOV SI,offset STR_MENU3 - offset boot_main + 7c00h
MOV CX,LEN_MENU3
MOV DH,ROW + 2
CALL SHOWSTR
MOV SI,offset STR_MENU4 - offset boot_main + 7c00h
MOV CX,LEN_MENU4
MOV DH,ROW + 3
CALL SHOWSTR
MOV SI,offset STR_CHOICE - offset boot_main + 7c00h
MOV CX,LEN_CHOICE
MOV DH,ROW + 4
CALL SHOWSTR
MOV BH,DPAGE
MOV DH,ROW + 5
MOV DL,COLUMN
MOV AH,2
INT 10H
CALL CLEARBUFKB
MOV DI,OFFSET GETSTR_BUF - offset boot_main + 7c00h
CALL GETSTRMN
CMP BYTE PTR CS:(offset GETSTR_BUF - offset boot_main + 7c00h)[2],'1'
JZ CHOICE_MENU1
CMP BYTE PTR CS:(offset GETSTR_BUF - offset boot_main + 7c00h)[2],'2'
JZ CHOICE_MENU2
CMP BYTE PTR CS:(offset GETSTR_BUF - offset boot_main + 7c00h)[2],'3'
JZ CHOICE_MENU3
CMP BYTE PTR CS:(offset GETSTR_BUF - offset boot_main + 7c00h)[2],'4'
JZ CHOICE_MENU4
JMP main_menu_start
CHOICE_MENU1:call RESETPC
JMP main_menu_start
CHOICE_MENU2:call STARTSYSTEM
JMP main_menu_start
CHOICE_MENU3:call SHOWCLOCK
JMP main_menu_start
CHOICE_MENU4:call SETCLOCK
JMP main_menu_start
SHOWSTR PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
MOV AX,0B800H
MOV ES,AX
MOV AL,80
MUL DH
XOR DH,DH
ADD AX,DX
ADD AX,AX
XCHG AX,BX
MOV AH,AL
JCXZ SHOWSTR_OK
SHOWSTR_S:MOV AL,DS:[SI]
INC SI
MOV ES:[BX],AX
INC BX
INC BX
LOOP SHOWSTR_S
SHOWSTR_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
SHOWSTR ENDP
CLEARSCREEN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AL,DPAGE
MOV AH,5
INT 10H
MOV CH,WINTOP
MOV CL,WINLEFT
MOV DH,WINBOTTOM
MOV DL,WINRIGHT
MOV BH,COLOR
MOV AL,0
MOV AH,6
INT 10H
MOV BH,DPAGE
MOV DH,WINTOP
MOV DL,WINLEFT
MOV AH,2
INT 10H
CLEARSCREEN_OK:POP DX
POP CX
POP BX
POP AX
RET
CLEARSCREEN ENDP
DELAY PROC
push ax
push dx
mov ax,0
delay_s:sub ax,1
sbb dx,0
cmp ax,0
jne delay_s
cmp dx,0
jne delay_s
pop dx
pop ax
ret
DELAY ENDP
CLEARBUFKB PROC
PUSH AX
CLEARBUFKB_S:MOV AH,1
INT 16H
JZ CLEARBUFKB_OK
MOV AH,0
INT 16H
JMP CLEARBUFKB_S
CLEARBUFKB_OK:POP AX
RET
CLEARBUFKB ENDP
CHECKBUFKB PROC
PUSH AX
MOV AH,1
INT 16H
CHECKBUFKB_OK:POP AX
RET
CHECKBUFKB ENDP
NEWLINE PROC
PUSH AX
PUSH BX
MOV BH,0
MOV AL,0DH
MOV AH,0EH
INT 10H
MOV AL,0AH
MOV AH,0EH
INT 10H
POP BX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH BX
MOV BH,0
MOV AH,0EH
INT 10H
POP BX
POP AX
RET
PUTCH ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,0
INT 16H
RET
GETCH ENDP
ISDEC PROC
CMP AL,'0'
JB ISDEC_NODEC
CMP AL,'9'
JA ISDEC_NODEC
CLC
JMP ISDEC_OK
ISDEC_NODEC:STC
ISDEC_OK:RET
ISDEC ENDP
ISMNU PROC
CMP AL,'1'
JB ISMNU_NOFMT
CMP AL,'4'
JA ISMNU_NOFMT
CLC
JMP ISMNU_OK
ISMNU_NOFMT:STC
ISMNU_OK:RET
ISMNU ENDP
GETSTRD PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRD1:CALL GETCH
CMP AL,CR
JZ GETSTRD5
CMP AL,BACKSPACE
JNZ GETSTRD4
CMP BX,0
JZ GETSTRD2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRD1
GETSTRD2:CALL BELL
JMP GETSTRD1
GETSTRD4:CMP BX,14
JZ GETSTRD2
CALL ISDEC
JC GETSTRD2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRD1
GETSTRD5:CMP BX,14
JB GETSTRD2
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRD_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRD ENDP
GETSTRMN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRMN1:CALL GETCH
CMP AL,CR
JZ GETSTRMN5
CMP AL,BACKSPACE
JNZ GETSTRMN4
CMP BX,0
JZ GETSTRMN2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRMN1
GETSTRMN2:CALL BELL
JMP GETSTRMN1
GETSTRMN4:CMP BX,1
JZ GETSTRMN2
CALL ISMNU
JC GETSTRMN2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRMN1
GETSTRMN5:CMP BX,1
JB GETSTRMN2
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRMN_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRMN ENDP
GETDATETIME PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV AH,4
INT 1AH
MOV AL,CH
CALL TTASC
MOV BYTE PTR DS:[SI],AH
MOV BYTE PTR DS:[SI+1],AL
MOV AL,CL
CALL TTASC
MOV BYTE PTR DS:[SI+2],AH
MOV BYTE PTR DS:[SI+3],AL
MOV BYTE PTR DS:[SI+4],'-'
MOV AL,DH
CALL TTASC
MOV BYTE PTR DS:[SI+5],AH
MOV BYTE PTR DS:[SI+6],AL
MOV BYTE PTR DS:[SI+7],'-'
MOV AL,DL
CALL TTASC
MOV BYTE PTR DS:[SI+8],AH
MOV BYTE PTR DS:[SI+9],AL
MOV BYTE PTR DS:[SI+10],20H
MOV AH,2
INT 1AH
MOV AL,CH
CALL TTASC
MOV BYTE PTR DS:[SI+11],AH
MOV BYTE PTR DS:[SI+12],AL
MOV BYTE PTR DS:[SI+13],':'
MOV AL,CL
CALL TTASC
MOV BYTE PTR DS:[SI+14],AH
MOV BYTE PTR DS:[SI+15],AL
MOV BYTE PTR DS:[SI+16],':'
MOV AL,DH
CALL TTASC
MOV BYTE PTR DS:[SI+17],AH
MOV BYTE PTR DS:[SI+18],AL
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
GETDATETIME ENDP
TTASC PROC
MOV AH,AL
AND AL,0FH
SHR AH,1
SHR AH,1
SHR AH,1
SHR AH,1
ADD AX,3030H
RET
TTASC ENDP
CHANGECOLOR PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
MOV AX,0B800H
MOV ES,AX
MOV BX,1
MOV CX,2000
CHANGECOLOR_S:INC BYTE PTR ES:[BX]
OR BYTE PTR ES:[BX],00001000b
AND BYTE PTR ES:[BX],00001111b
INC BX
INC BX
LOOP CHANGECOLOR_S
CHANGECOLOR_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
CHANGECOLOR ENDP
SHOWCLOCK PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CALL CLEARSCREEN
MOV SI,offset STR_DATETIME - offset boot_main + 7c00h
MOV CX,LEN_DATETIME
MOV BL,COLOR
MOV DH,ROW
MOV DL,COLUMN
CALL SHOWSTR
MOV BH,DPAGE
MOV DH,ROW + 2
MOV DL,COLUMN
MOV AH,2
INT 10H
CALL CLEARBUFKB
SHOWCLOCK_START:MOV SI,offset DATETIME_BUF - offset boot_main + 7c00h
CALL GETDATETIME
MOV AX,0B800H
MOV ES,AX
MOV CX,19
MOV BL,ES:[1]
MOV DH,ROW + 2
MOV DL,COLUMN
CALL SHOWSTR
push dx
mov dx,2000h
call delay
pop dx
SHOWCLOCK_CHECK:CALL CHECKBUFKB
JZ SHOWCLOCK_START
CALL GETCH
CMP AH,3BH
JZ SHOWCLOCK_F1
CMP AL,1BH
JZ SHOWCLOCK_ESC
JMP SHOWCLOCK_CHECK
SHOWCLOCK_F1:CALL CHANGECOLOR
CALL CLEARBUFKB
JMP SHOWCLOCK_START
SHOWCLOCK_ESC:CALL CLEARBUFKB
SHOWCLOCK_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
SHOWCLOCK ENDP
SETCLOCK PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CALL CLEARSCREEN
MOV SI,offset STR_CLOCK - offset boot_main + 7c00h
MOV CX,LEN_CLOCK
MOV BL,COLOR
MOV DH,ROW
MOV DL,COLUMN
CALL SHOWSTR
MOV BH,DPAGE
MOV DH,ROW + 1
MOV DL,COLUMN
MOV AH,2
INT 10H
CALL CLEARBUFKB
MOV DI,OFFSET GETSTR_BUF - offset boot_main + 7c00h
CALL GETSTRD
ADD DI,2
MOV SI,offset DATETIME_BUF - offset boot_main + 7c00h
MOV BP,0
SETCLOCK_FORI1:CMP BP,14
JAE SETCLOCK_SETDATETIME
MOV AH,DS:[DI]
MOV AL,DS:[DI+1]
SUB AH,30H
SUB AL,30H
MOV CL,4
SHL AH,CL
AND AL,00001111b
OR AH,AL
MOV DS:[SI],AH
SETCLOCK_NEXTI1:INC BP
INC BP
INC DI
INC DI
INC SI
JMP SETCLOCK_FORI1
SETCLOCK_SETDATETIME:MOV SI,offset DATETIME_BUF - offset boot_main + 7c00h
MOV CH,DS:[SI]
MOV CL,DS:[SI+1]
MOV DH,DS:[SI+2]
MOV DL,DS:[SI+3]
MOV AH,05H
INT 1AH
MOV CH,DS:[SI+4]
MOV CL,DS:[SI+5]
MOV DH,DS:[SI+6]
MOV DL,0
MOV AH,03H
INT 1AH
SETCLOCK_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
SETCLOCK ENDP
STARTSYSTEM PROC
mov bx,cs
mov ds,bx
mov es,bx
mov si,offset copy_start - offset boot_main + 7c00h
mov di,8200h
mov cx,COPY_LEN
cld
rep movsb
mov bx,8200h
push bx
ret
copy_start:mov ax,0
mov es,ax
mov bx,7c00h
mov ah,2
mov al,1
mov ch,0
mov cl,1
mov dh,0
mov dl,80h
int 13h
mov bx,0
push bx
mov bx,7c00h
push bx
retf
COPY_LEN = $ - OFFSET copy_start
STARTSYSTEM ENDP
RESETPC PROC
mov bx,0FFFFh
push bx
mov bx,0
push bx
retf
RESETPC ENDP
CSEG ENDS
END START
第6章简单应用程序的设计
8086/8088指令集含有专门的字符串操作指令，利用它们可有效地进行字符串操作。
指令集还有十进制数算术运算调整指令，利用它们可快速地实现十进制数算术运算。
本章先介绍这些指令，然后结合若干特殊情况处理程序说明简单应用程序的设计方法。
6.1字符串处理
字符串是字符的一个序列。对字符串的操作处理包括复制、检索、插入、删除和替换等。
为了便于对字符串进行有效的处理，8086/8088提供专门用于处理字符串的指令，我们称之为字符串操作指令，简称为串操作指令。
本节先介绍串操作指令及与串操作指令密切相关的重复前缀，然后举例说明如何利用它们进行字符串处理。
6.1.1字符串操作指令
1.一般说明
8086/8088共有五种基本的串操作指令。
每种基本的串操作指令包括两条指令，一条适用于以字节为单元的字符串，另一条适用于以字为单元的字符串。
在字符串操作指令中，由变址寄存器SI指向源操作数（串），由变址寄存器DI指向目的操作数（串）。
规定源串存放在当前数据段中，目的串存放在当前附加段中，
也即在涉及源操作数时，引用数据段寄存器DS，在涉及目的操作数时，引用附加段寄存器ES。
换句话说，DS:SI指向源串，ES:DI指向目的串。
串操作指令执行时会自动调整作为指针使用的寄存器SI或DI之值。
如串操作的单元是字节，则调整值为1；如串操作的单元是字，则调整值为2。
此外，字符串操作的方向（处理字符串中单元的次序）由标志寄存器中的方向标志DF控制。
当方向标志DF复位（为0）时，按递增方式调整寄存器SI或DI之值；
当方向标志DF置位（为1）时，按递减方式调整寄存器SI或DI之值。
2.字符串装入指令（LOAD String）
字符串装入指令的格式如下：
LODSB 装入字节（Byte）
LODSW 装入字（Word）
字符串装入指令只是把字符串中的一个字符装入到累加器中。
字节装入指令LODSB把寄存器SI所指向的一个字节数据装入到累加器AL中，然后根据方向标志DF复位或置位使SI之值增1或减1。
它类似下面的两条指令：
MOV AL,[SI]
INC SI或DEC SI
字装入指令LODSW把寄存器SI所指向的一个字数据装入到累加器AX中，然后根据方向标志DF复位或置位使SI之值增2或减2。
类似于如下的两条指令：
MOV AX,[SI]
ADD SI,2或SUB SI,2
字符串装入指令的源操作是存储操作数，所以引用数据段寄存器DS。
字符串装入指令不影响标志。
下面的子程序使用了LODSB指令。此外，该子程序算法也较好，所以它的效率较高。
请与3.6节中的例4作比较。
；子程序名：STRLWR
：功能：把字符串中的大写字母转化为小写（字符串以0结尾）
；入口参数：DS:SI=字符串首地址的段值：偏移
；出口参数：无
STRLWR PROC
PUSH SI
CLD
JMP SHORT STRLWR2
STRLWR1:SUB AL,'A'
CMP AL,'Z'-'A'
JA STRLWR2
ADD AL,'a'
MOV [SI-1],AL
STRLWR2:LODSB
AND AL,AL
JNZ STRLWR1
POP SI
RET
STRLWR ENDP
在汇编语言中，两条字符串装入指令的格式可统一为如下一种格式：
LODS OPRD
汇编程序根据操作数的类型决定使用字节装入指令还是字装入指令。
也即，如果操作数的类型为字节，则采用LODSB指令；如果操作数的类型为字，则采用LODSW指令。
请注意，操作数OPRD不影响指针寄存器SI之值，所以在使用上述格式的串装入指令时，仍必须先给SI赋合适的值。例如：
......
MESS DB 'HELLO',0
TAB DW 123,43,332,44,-1
......
MOV SI,OFFSET MESS
LODS MESS
......
MOV SI,OFFSET TAB
LODS TAB
......
3.字符串存储指令（STORE String）
字符串存储指令的格式如下：
STOSB 存储字节
STOSW 存储字
字符串存储指令只是把累加器的值存到字符串中，即替换字符串中一个字符。
字节存储指令STOSB把累加器AL的内容送到寄存器DI所指向的存储单元中，然后根据方向标志DF复位或置位使DI之值增1或减1。
它类似下面的两条指令：
MOV ES:[DI],AL
INC DI或DEC DI
字装入指令STOSW把累加器AX的内容送到寄存器DI所指向的存储单元中，然后根据方向标志DF复位或置位使DI之值增2或减2。
类似于如下的两条指令：
MOV ES:[DI],AX
ADD Dl,2或SUB DI,2
字符串存储指令的源操作是累加器AL或AX，目的操作是存储操作数，所以引用当前附加段寄存器ES。
字符串存储指令不影响标志。
在汇编语言中，两条字符串存储指令的格式可统一为如下一种格式：
STOS OPRD
汇编程序根据操作数OPRD的类型决定使用字节存储指令还是字存储指令。操作数OPRD不影响指针寄存器DI之值。
例如：如下程序片段把当前数据段中偏移1000H开始的100个字节的数据传送到从偏移2000H开始的单元中。
......
CLD
PUSH DS
POP ES
MOV SI,1000H
MOV DI,2000H
MOV CX,100
NEXT:LODSB
STOSB
LOOP NEXT
......
如果方向标志已清，则清方向标志的指令可省；如果当前附加段和当前数据段已是重叠的，则也就无需再给ES赋值。
4.字符串传送指令（MOVE String）
字符串传送指令的格式如下：
MOVSB 字节传送
MOVSW 字传送
字节传送指令MOVSB把寄存器SI所指向的一个字节数据传送到由寄存器DI所指向的存储单元中，
然后根据方向标志DF复位或置位使SI和DI之值分别增1或减1。
字传送指令MOVSW把寄存器SI所指向的一个字数据传送到由寄存器DI所指向的存储单元中，
然后根据方向标志DF复位或置位使SI和DI之值分别增2或减2。
注意，根据DS和SI计算源操作数地址，根据ES和DI计算目的操作数地址。
字符串传送指令不影响标志。
该指令的源操作数和目的操作均在存储器中，它与下面的字符串比较指令一起属于特殊情况。
在汇编语言中，两条字符串传送指令的格式可统一为如下一种格式：
MOVS OPRD1,OPRD2
两个操作数的类型应该一致。
汇编程序根据操作数的类型决定使用字节传送指令还是字传送指令。
也即，如果操作数的类型为字节，则采用MOVSB指令；如果操作数的类型为字，则采用MOVSW指令。
请注意，操作数OPRD1或OPRD2可起到方便阅读程序的作用，但不影响寄存器SI和DI之值，
所以在使用上述格式的串传送指令时，仍必须先给SI和DI赋合适的值。
上面我们利用了字符串装入指令和字符串存储指令的结合实现数据块的移动，
现在利用字符串传送指令实现数据块的移动。
假设要求同上，程序片段如下，请作比较。
......
CLD
PUSH DS
POP ES
MOV SI,1000H
MOV DI,2000H
MOV CX,100
NEXT:MOVSB
LOOP NEXT
......
现在循环体中只有一条串传送指令，执行速度可明显提高。
在这个程序片段中，把100个字节的数据当作以字节为单元的字符串，所以利用了字节传送指令。
如果把这100个字节的数据当作以字为单元的字符串，那么这个字符串也就只有50个单元了，
于是循环次数可减少一半，执行速度还会提高。改写后的程序片段如下：
......
CLD
PUSH DS
POP ES
MOV SI,1000H
MOV DI,2000H
MOV CX,50
NEXT:MOVSW
LOOP NEXT
......
5.字符串扫描指令（SCAN String）
字符串扫描指令的格式如下：
SCASB 字节扫描
SCASW 字扫描
字节扫描指令SCASB把累加器AL的内容与由寄存器DI所指向一个字节数据采用相减方式比较，
相减结果反映到各有关标志位（AF，CF，OF，PF，SF和ZF），但不影响两个操作数，
然后根据方向标志DF复位或置位使DI之值增1或减1。
字扫描指令SCASW把累加器AX的内容与由寄存器DI所指向的一个字数据比较，结果影响标志，然后DI之值增2或减2。
下面的程序片段判断AL中的字符是否为十六进制数符：
......
STRING DB '0123456789ABCDEFabcdef'
STRINGL EQU $ - OFFSET STRING
......  把要判断的字符送AL
CLD
MOV DX,SEG STRING
MOV ES,DX
MOV CX,STRINGL
MOV DI,OFFSET STRING
NEXT:SCASB
LOOPNZ NEXT
JNZ NOT_FOUND
FOUND:
......
NOT_FOUND:
......
在汇编语言中，两条字符串扫描指令的格式可统一为如下一种格式：
SCAS OPRD
汇编程序根据操作数的类型决定使用字节扫描指令还是字扫描指令。
6.字符串比较指令（COMPARE String）
字符串比较指令的格式如下：
CMPSB 字节比较
CMPSW 字比较
字节比较指令CMPSB把寄存器SI所指向的一个字节数据与由寄存器DI所指向一个字节数据采用相减方式比较，
相减结果反映到各有关标志位（AF，CF，OF，PF，SF和ZF），但不影响两个操作数，
然后根据方向标志DF复位或置位使SI和DI之值分别增1或减1。
字比较指令CMPSW把寄存器SI所指向的一个字数据与由寄存器DI所指向的一个字数据比较，结果影响标志，然后按调整值2调整SI和DI之值。
在汇编语言中，两条字符串比较指令的格式可统一为如下一种格式：
CMPS OPRD1,OPRD2
两个操作数的类型应该一致。
汇编程序根据操作数的类型决定使用字节比较指令还是字比较指令。
请注意，OPRD1或OPRD2不影响寄存器SI和DI之值和段寄存器DS和ES之值。
6.1.2重复前缀
由于串操作指令每次只能对字符串中的一个字符进行处理，所以使用了一个循环，以便完成对整个字符串的处理。
为了进一步提高效率，8086/8088还提供了重复指令前缀。
重复前缀可加在串操作指令之前，达到重复执行其后的串操作指令的目的。
1.重复前缀REP
REP用作为一个串操作指令的前缀，它重复其后的串操作指令动作。
每一次重复都先判断CX是否为0，如为0就结束重复，否则CX的值减1，重复其后的串操作指令。
所以当CX值为0时，就不执行其后的字符串操作指令。
它类似于LOOP指令，但LOOP指令是先把CX的值减1，后再判是否为0。
注意，在重复过程中的CX减1操作，不影啊各标志。
重复前缀REP主要用在字符串传送指令MOVS和字符串存储指令STOS之前。
值得指出的是，一般不在LODSB或LODSW指令之前使用任何重复前缀。
使用重复前缀REP，可进一步改写前面的移动数据块的程序片段如下，请作比较：
......
CLD
PUSH DS
POP ES
MOV SI,1000H
MOV DI,2000H
MOV CX,50
REP MOVSW
......
在下面的子程序中，重复前缀REP与字符串存储指令配合，实现用指定的字符填充指定的缓冲区。
；子程序名：FILLB
；功能：用指定字符填充指定缓冲区
；入口参数：ES:DI=缓冲区首地址
；                 CX=缓冲区长度，AL=充填字符
；出口参数：无
FILLB PROC
PUSH AX
PUSH DI
JCXZ FILLB_1
CLD
SHR CX,1
MOV AH,AL
REP STOSW
JNC FILLB_1
STOSB
FILLB_1:POP DI
POP AX
RET
FILLB ENDP
在上面的子程序中，先按字填充缓冲区，然后再处理可能出现的“零头”，这与重复CX次字节填充相比，可获得更高的效率。
注意，字符串存储指令STOSW不影响标志。
2.重复前缀REPZ/REPE
REPZ与REPE是一个前缀的两个助记符，下面的介绍以REPZ为代表。
REPZ用作为一个串操作指令的前缀，它重复其后的串操作指令动作。
每重复一次，CX的值减1，重复一直进行到CX为0或串操作指令使零标志ZF为0时止。
重复结束条件的检查是在重复开始之前进行的。
注意，在重复过程中的CX值减1操作，不影响标志。
重复前缀REPZ主要用在字符串比较指令CMPS和字符串扫描指令SCAS之前。由于字符串传送指令MOVS和字符串存储指令STOS都不影响标志，
不判断ZF标志，所以，在这些串操作指令前使用前缀REP和前缀REPZ的效果一样。
在下面的子程序中，重复前缀REPZ与串比较指令CMPSB配合，实现两个字符串的比较。
重复前缀REPZ与CMPSB的配合表示当相同时继续比较。
：子程序名：STRCMP
；功能：比较字符串是否相同
；入口参数：DS:SI=字符串1首地址的段值：偏移
；                 ES:DI=字符串2首地址的段值：偏移
；                 出口参数：AX=0表示两字符串相同，否则表示字符串不同
；说明：设字符串均以0为结束标志
STRCMP PROC
PUSH CX
PUSH SI
PUSH DI
CLD
PUSH DI
XOR AL,AL
MOV CX,0FFFFH
NEXT:SCASB
LOOPNZ NEXT
NOT CX
POP DI
REPZ CMPSB
MOV AL,[SI-1]
MOV BL,ES:[DI-1]
XOR AH,AH
MOV BH,AH
SUB AX,BX
POP DI
POP SI
POP CX
RET
STRCMP ENDP
在上面子程序中最后使用的比较方法稍繁，但CF反映了两个字符串的字典序。
3.重复前缀REPNZ/REPNE
REPNZ与REPNE是一个前缀的两个助记符，下面的介绍以REPNZ为代表。
REPNZ用作为一个串操作指令的前缀。与REPZ类似，所不同的是重复一直进行到CX为0或串操作指令使零标志ZF为1时止。
重复前缀REPNZ主要用在字符串扫描指令SCAS之前。
重复前缀REPNZ与SCASB指令配合，表示当不等时继续扫描，一直搜索到字符串结束。
如果搜索到，则ZF标志为1，CX之值可能为0；如果没有搜索到，则ZF标志为0，CX之值一定为0。
上述的判断AL中的字符是否为十六进制数符的程序片段改写如下：

......
STRING DB '0123456789ABCDEFabcdef'
STRINGL EQU $ - OFFSET STRING
......  把要判断的字符送AL
CLD
MOV DX,SEG STRING
MOV ES,DX
MOV CX,STRINGL
MOV DI,OFFSET STRING
REPNZ SCASB
JNZ NOT_FOUND
FOUND:
......
NOT_FOUND:
......
下面的子程序测字符串的长度，设字符串以0结尾。它巧妙地利用了重复前缀REPNZ和字符串扫描指令SCASB。
；子程序名：STRLEN
；功能：测字符串长度
；入口参数：ES:DI=字符串首地址的段值：偏移
；出口参数：AX=字符串长度
；说明：字符串以0结尾
；字符串长度不包括结尾标志
STRLEN PROC
PUSH CX
PUSH DI
CLD
XOR AL,AL
MOV CX,0FFFFH
REPNZ SCASB
MOV AX,CX
NOT AX
DEC AX
POP DI
POP CX
RET
STRLEN ENDP
如果重复前缀REPZ与SCASB相配合，则表示当相等时继续搜索，直到第一个不等时为止（当然CX之值决定了最终搜索的次数）。
4.说明
重复的字符串处理操作过程可被中断。CPU在处理字符串的下一个字符之前识别中断。
如果发生中断，那么在中断处理返回以后，重复过程再从中断点继续执行下去。
但应注意，如指令前还有其他前缀（段超越前缀或锁定前缀）的话，中断返回时其他的前缀就不再有效。
因为CPU在中断时，只能“记住”一个前缀，即字符串操作指令前的重复前缀。
如字符串操作指令必须使用一个以上的前缀，则可在此之前禁止中断。
6.1.3字符串操作举例
下面再举几例来说明字符串操作指令和重复前缀的使用，同时说明如何进行字符串操作。
例1：写一个判别字符是否在字符串中出现的子程序。设字符串以0结尾。
字符串扫描指令可用于在字符串中搜索指定的字符，从而判别字符是否属于字符串。
下面的子程序并没有利用串扫描指令，代码虽长，自有其独到之处，请注意。
；子程序名：STRCHR
；功能：判断字符是否属于字符串
；入口参数：DS:SI=搜索字符串首地址的段值：偏移，AL=字符代码
；出口参数：CF=0表示字符在字符串中，AX=字符首次出现处的偏移
；                 CF=1表示字符不在字符串中
STRCHR PROC
PUSH BX
PUSH DX
PUSH SI
MOV DX,SI
CLD
MOV BL,AL
TEST SI,1
JZ STRCHR1
LODSB
CMP AL,BL
JZ STRCHR3
AND AL,AL
JZ STRCHR2
STRCHR1:LODSW
CMP AL,BL
JZ STRCHR4
AND AL,AL
JZ STRCHR2
CMP AH,BL
JZ STRCHR3
AND AH,AH
JZ STRCHR2
JMP STRCHR1
STRCHR2:STC
JMP SHORT STRCHR5
STRCHR3:LEA AX,[SI-1]
SUB AX,DX
JMP SHORT STRCHR5
STRCHR4:LEA AX,[SI-2]
SUB AX,DX
STRCHR5:POP SI
POP DX
POP BX
RET
STRCHR ENDP
上面的子程序对从奇地址开始存放的字符串的第一个字符作了特别处理。
在随后的循环处理中，字符串便总从偶地址开始，每次取一个字，即两个字符，再逐个字符比较。
为什么要从偶地址开始取一个字？较好的理由留给读者思考。
CPU每次都把偶地址放到地址总线上。CPU每次都从内存读取2个字节。
读取内存中的2个字节，偏移地址是奇数，CPU需要读取内存两次，偏移地址是偶数，CPU需要读取内存一次。
例2：写一个在字符串1后追加字符串2的子程序。设字符串均以0结尾。
该子程序的实现流程如图6.1所示。现再作几点说明：
（1）要传送的字符串2包括其结束标志；
（2）字符串2的传送以字传送为主，考虑了从偶地址开始进行字的传送；
（3）最后处理可能遗留的一字节
；子程序名：STRCAT
；功能：在字符串1末追加字符串2
；入口参数：DS:SI=字符串1起始地址的段值：偏移
；                 DS:DI=字符串2起始地址的段值：偏移
；出口参数：无
；说明：不考虑在字符串1后是否留有足够的空间
STRCAT PROC
PUSH AX
PUSH CX
PUSH SI
PUSH DI
PUSH ES
CLD
PUSH DS
POP ES
PUSH DI
MOV DI,SI
XOR AL,AL
MOV CX,0FFFFH
REPNZ SCASB
LEA SI,[DI-1]
POP DI
MOV CX,0FFFFH
REPNZ SCASB
NOT CX
SUB DI,CX
XCHG SI,DI
TEST SI,1
JZ STRCAT1
MOVSB
DEC CX
STRCAT1:SHR CX,1
REP MOVSW
JNC STRCAT2
MOVSB
STRCAT2:POP ES
POP DI
POP SI
POP CX
POP AX
RET
STRCAT ENDP
例3：写一个程序，它先接收一个字符串，然后抽去其中的空格，最后按相反的顺序显示它。
程序如下所示，请注意删除空格的方法和方向标志的变化。
；程序名：T6-1.ASM
；功能：接收一个字符串，去掉其中的空格后按相反的顺序显示它
MAXLEN = 64
SPACE = 20H
CR = 0DH
LF = 0AH
DSEG SEGMENT
BUFFER DB MAXLEN+1,0,MAXLEN+1 DUP (0)
STRING DB MAXLEN+3 DUP (0)
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG,ES:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV ES,AX
MOV DX,OFFSET BUFFER
MOV AH,10
INT 21H
XOR CH,CH
MOV CL,BUFFER+1
JCXZ OK
CLD
MOV SI,OFFSET BUFFER+2
MOV Dl,OFFSET STRING
XOR AL,AL
STOSB
PP1:XCHG SI,DI
MOV AL,SPACE
REPZ SCASB
XCHG SI,DI
DEC SI
CMP BYTE PTR [SI],SPACE
JZ PP3
INC CX
PP2:CMP BYTE PTR [SI],SPACE
JZ PP1
MOVSB
LOOP PP2
PP3:MOV AL,CR
STOSB
MOV AL,LF
MOV [DI],AL
STD
MOV SI,DI
PP4:LODSB
OR AL,AL
JZ OK
MOV DL,AL
MOV AH,2
INT 21H
JMP PP4
OK:MOV AH,4CH
INT 21H
CSEG ENDS
END START
测试通过的完整程序如下
MAXLEN = 64
SPACE = 20H
CR = 0DH
LF = 0AH
DSEG SEGMENT
BUFFER DB MAXLEN+1,0,MAXLEN+1 DUP (0)
STRING DB MAXLEN+3 DUP (0)
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG,ES:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV ES,AX
MOV DX,OFFSET BUFFER
MOV AH,10
INT 21H
XOR CH,CH
MOV CL,BUFFER+1
JCXZ OK
CLD
MOV SI,OFFSET BUFFER+2
MOV DI,OFFSET STRING
XOR AL,AL
STOSB
PP1:XCHG SI,DI
MOV AL,SPACE
REPZ SCASB
XCHG SI,DI
DEC SI
CMP BYTE PTR [SI],SPACE
JZ PP3
INC CX
PP2:CMP BYTE PTR [SI],SPACE
JZ PP1
MOVSB
LOOP PP2
PP3:MOV AL,CR
STOSB
MOV AL,LF
MOV [DI],AL
STD
MOV SI,DI
PP4:LODSB
OR AL,AL
JZ OK
MOV DL,AL
MOV AH,2
INT 21H
JMP PP4
OK:MOV AH,4CH
INT 21H
CSEG ENDS
END START
例4：写一个判字符串2是否为字符串1子串的子程序。
具体要求如下：
（1）子程序是一个远过程；
（2）指向字符串的指针是远指针（即包括段值）；
（3）通过堆栈传递两个分别指向字符串1和字符串2的远指针；
（4）由DX:AX返回指向字符串2在字符串1中首次出现处的指针，如果字符串2不是字符串1的子串，则返回空指针；
（5）字符串均以0为结束符。
第3章中的程序T3-16.ASM完成类似的工作，现在利用串操作指令来实现它，图6.2是实现的流程图，请比较。图6.3是调用进入该子程序后的堆栈。
；子程序名：STRSTR
；功能：判字符串2是否为字符串1的子串
；入口参数：指向字符串的远指针（见调用方法）
；出口参数：DX:AX返回指向字符串2在字符串1中首次出现处的指针
；说明：调用方法如下：
（1）压入字符串2的远指针
（2）压入字符串1的远指针
（3）CALL FAR PTR STRSTR
调用完之后恢复堆栈ADD SP,8
比如
PUSH DS
PUSH DI
PUSH DS
PUSH SI
CALL FAR PTR STRSTR
ADD SP,8
STRSTR PROC FAR
PUSH BP
MOV BP,SP
PUSH BX
PUSH CX
PUSH SI
PUSH DI
PUSH DS
PUSH ES
LES BX,[BP+10]
CMP BYTE PTR ES:[BX],0
JNZ STRSTR1
MOV DX,[BP+8]
MOV AX,[BP+6]
JMP SHORT STRSTR6
STRSTR1:CLD
LES DI,[BP+6]
PUSH ES
MOV BX,DI
XOR AX,AX
MOV CX,0FFFFH
REPNZ SCASB
NOT CX
MOV DX,CX
LES DI,[BP+10]
PUSH ES
MOV BP,DI
XOR AX,AX
MOV CX,0FFFFH
REPNZ SCASB
NOT CX
DEC CX
POP DS
POP ES
STRSTR2:MOV SI,BP
LODSB
MOV DI,BX
XCHG CX,DX
REPNZ SCASB
MOV BX,DI
JNZ STRSTR3
CMP CX,DX
JNB STRSTR4
STRSTR3:XOR BX,BX
MOV ES,BX
MOV BX,1
JMP SHORT STRSTR5
STRSTR4:XCHG CX,DX
MOV AX,CX
DEC CX
REPZ CMPSB
MOV CX,AX
JNZ STRSTR2
STRSTR5:MOV AX,BX
DEC AX
MOV DX,ES
STRSTR6:POP ES
POP DS
POP DI
POP SI
POP CX
POP BX
POP BP
RETF
STRSTR ENDP
6.2十进制数算术运算调整指令及应用
在2.4节中介绍的算术运算指令都是对二进制数进行操作，为了方便地进行十进制数的算术运算，8086/8088提供了各种调整指令。
本节介绍这些调整指令和举例说明它们的应用。
8086/8088的十进制数算术运算调整指令所认可的十进制数是以8421BCD码（见表1.1）表示的，
它分为未组合（或非压缩）的和组合（或压缩）的两种。
组合的BCD码是指一字节含两位BCD码；未组合的BCD码是指一字节含一位BCD码，字节的高四位无意义。
数字的ASCII码是一种非组合的BCD码。因为数字的ASCII码的低四位是对应的8421BCD码。
6.2.1组合BCD码的算术运算调整指令
1.组合的BCD码加法调整指令DAA（Decimal Adjust for Addition）
组合的BCD码加法调整指令的格式如下：
DAA
这条指令对在AL中的和（由两个组合的BCD码相加后的结果）进行调整，产生一个组合的BCD码。
调整方法如下：
（1）如AL中的低4位在A~F之间，或AF为1，则AL<-(AL)+6，且AF位置1；
（2）如AL中的高4位在A~F之间，或CF为1，则AL<-(AL)+60H，且CF位置1。
该指令影响标志AF，CF，PF，SF和ZF，但不影响标志OF。
下面是为了说明该指令而写的一个程序片段，每条指令执行后的结果作为注释给出。
第一条指令使AL含表示两位十进制数34的组合BCD码；
第二条指令进行加操作，因ADD是二进制数相加，所以结果为7BH，但作为十进制数34加47的结果应为81。
第三条指令进行调整，得正确结果81。
第五条指令又把由第四条指令相加的结果进行调整，得结果68（百位进入CF）。
第七条指令把由第六条指令相加的结果进行调整，得结果48（百位进入CF）。
8086CPU的flag寄存器的结构如图11.1所示。
15 14 13 12 11 10  9  8   7   6   5   4  3  2  1  0
                    OF DF IF TF SF ZF       AF   PF     CF
flag的1、3、5、12、13、14、15位在8086CPU中没有使用，不具有任何含义。
而0、2、4、6、7、8、9、10、11位都具有特殊的含义。
MOV AL,34H
ADD AL,47H
AL=7BH,AF=0,CF=0
DAA
AL=81H,AF=1,CF=0
ADC AL,87H
AL=08H,AF=0,CF=1
DAA
AL=68H,AF=0,CF=1
ADC AL,79H
AL=E2H,AF=1,CF=0
DAA
AL=48H,AF=1,CF=1
2.组合的BCD码减法调整指令DAS（Decimal Adjust for Subtraction）
组合的BCD码减法调整指令的格式如下：
DAS
这条指令对在AL中的差（由两个组合的BCD码相减后的结果）进行调整，产生一个组合的BCD码。
调整方法如下：
（1）如AL中的低4位在A~F之间，或AF为1，则AL<-(AL)-6，且AF位置1；
（2）如AL中的高4位在A~F之间，或CF为1，则AL<-(AL)-60H，且CF位置1。
该指令影响标志AF，CF，PF，SF和ZF，但不影响标志OF。
下面是为了说明该指令而写的一个程序片段，每条指令执行后的结果作为注释给出。
第一条指令使AL含表示两位十进制数35的组合BCD码；
第二条指令进行减操作，因SUB是二进制数相减，所以结果为1EH，但作为十进制数45减27的结果应为18。
第三条指令进行调整，得正确结果18。
第五条指令又把由第四条指令相减的结果进行调整，得结果69（百位上的借位在CF中）。
MOV AL,45H
SUB AL,27H
AL=1EH,AF=1,CF=0
DAS
AL=18H,AF=1,CF=0
SBB AL,49H
AL=CFH,AF=1,CF=1
DAS
AL=69H,AF=1,CF=1
6.2.2未组合BCD码的算术运算调整指令
1.未组合的BCD码加法调整指令AAA（ASCll Adjust for Addition）
未组合的BCD码加法调整指令的格式如下：
AAA
这条指令对在AL中的和（由两个未组合的BCD码相加后的结果）进行调整，产生一个未组合的BCD码。
调整方法如下：
（1）如AL中的低4位在0~9之间，且AF为0，则转（3）；
（2）如AL中的低4位在A~F之间，或AF为1，则AL<-(AL)+6，AH<-(AH)+1，且AF位置1；
（3）清除AL的高4位；
（4）AF位的值送CF位。
该指令影响标志AF和CF，对其他标志均无定义。
下面是为了说明该指令而写的一个程序片段，每条指令执行后的结果作为注释给出，请注意比较：
MOV AX,7
ADD AL,6
AL=0DH,AH=00H,AF=0,CF=0
AAA
AL=03H,AH=01H,AF=1,CF=1
ADC AL,5
AL=09H,AH=01H,AF=0,CF=0
AAA
AL=09H,AH=01H,AF=0,CF=0
ADD AL,39H
AL=42H,AH=01H,AF=1,CF=0
AAA
AL=08H,AH=02H,AF=1,CF=1
2.未组合的BCD码减法调整指令AAS（ASCII Adjust for Subtraction）
未组合的BCD码减法调整指令的格式如下：
AAS
这条指令对在AL中的差（由两个未组合的BCD码相减后的结果）进行调整，产生一个未组合的BCD码。
调整方法如下：
（1）如AL中的低4位在0~9之间，且AF为0，则转（3）；
（2）如AL中的低4位在A~F之间，或AF为1，则AL<-(AL)-6，AH<-(AH)-1，且AF位置1；
（3）清除AL的高4位；
（4）AF位的值送CF位。
该指令影响标志AF和CF，对其他标志均无定义。
下面是为了说明该指令而写的一个程序片段，每条指令执行后的结果作为注释给出，请注意比较：
MOV AL,34H
SUB AL,09H
AL=2BH,AF=1,CF=0
AAS
AL=05H,AF=1,CF=1
3.未组合的BCD码乘法调整指令AAM（ASCII Adjust for Multiplication）
未组合的BCD码乘法调整指令的格式如下：
AAM
这条指令对在AL中的积（由两个未组合的BCD码相乘MUL所得的的结果）进行调整，产生两个未组合的BCD码。
调整方法如下：
把AL中的值除以10，商放在AH中，余数放在AL中。该指令影响标志SF，ZF和PF，对其他标志无影响。
下面是为了说明该指令而写的一个程序片段，每条指令执行后的结果作为注释给出，请注意比较：
MOV AL,03H
MOV BL,04H
MUL BL
AL=0CH,AH=00H
AAM
AL=02H,AH=01H
4.未组合的BCD码除法调整指令AAD（ASCII Adjust for Division）
未组合的BCD码除法调整指令的格式如下：
AAD
该指令和其他调整指令的使用次序上不同，其他调整指令均安排在有关算术运算指令后，而这条指令应安排在除运算指令之前。
它的功能是：把存放在寄存器AH（高位十进制数）及存放在寄存器AL中的两位非组合BCD码，调整为一个二进制数，存放在寄存器AL中。
调整的方法如下：
AL=AH*10+(AL)
AH=0
由于采用上述调整方法，存放在AL和AH中的非组合BCD的高四位应为0。
该指令影响标志SF，ZF和PF，对其他标志无影响。
下面是为了说明该指令而写的一个程序片段，每条指令执行后的结果作为注释给出，请注意比较：
MOV AH,04H
MOV AL,03H
MOV BL,08H
AAD
AL=2BH,AH=00H
DIV BL
AL=05H,AH=03H
6.2.3应用举例
例1：设在缓冲区DATA中存放着12个组合的BCD码，求它们的和，把结果存放到缓冲区SUM中。
有关的程序片段如下：
......
NUM_DARRAY DB 23H,45H,67H,89H,32H,93H,36H,12H,66H,78H,43H,99H
RESULT DB 2 DUP (0)
......
MOV AX,SEG NUM_DARRAY
MOV DS,AX
MOV BX,OFFSET NUM_DARRAY
MOV CX,12
XOR AL,AL
XOR AH,AH
NEXT:ADD AL,[BX]
DAA
ADC AH,0
XCHG AH,AL
DAA
XCHG AH,AL
INC BX
LOOP NEXT
XCHG AH,AL
MOV WORD PTR RESULT,AX
......
测试通过的完整程序如下
......
NUM_DARRAY DB 23H,45H,67H,89H,32H,93H,36H,12H,66H,78H,43H,99H
......
MOV BX,OFFSET NUM_DARRAY
MOV CX,12
XOR AX,AX
DARRAY_S:ADD AL,DS:[BX]
DAA
ADC AH,0
XCHG AH,AL
DAA
XCHG AH,AL
INC BX
LOOP DARRAY_S
CALL DHTOASC
CALL NEWLINE
12个组合的BCD码，它们的和为AH=06H,AL=83H
例2：利用DAA指令改写把一位十六进制数转换为对应的ASCIl码符的子程序HTOASC。
下面的子程序巧妙地利用了加法调整指令DAA，使得在子程序中没有条件转移指令。
；子程序名：HTOASC
；功能：把一位十六进制数转换为对应的ASCII码
：入口参数：AL的低4位为要转换的十六进制数
；出口参数：AL含对应的ASCIl码
HTOASC PROC
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
RET
HTOASC ENDP
90-99,CF=0->D0-D9,CF=0->30-39,CF=1
9A-9F->A0-A5,AF=1->00-05,CF=1->41-46,CF=0
请读者仔细考虑上述子程序。选几个十六进制数试试。
例3：写一个能实现两个十进制数的加法运算处理的程序。设每个十进制数最多10位。
如果不采用十进制数算术运算调整指令，那么在接收了以ASCII码串表示的十进制数后，要把它转换为二进制数。
在对二进制数进行运算后，还要把结果转换为十进制数的ASCII码。当要处理的十进制数位数较多时，这种转换较麻烦。
现采用十进制数算术运算调整指令完成它。
该程序分为如下四步：
（1）接收按十进制表示的被加数，并作适当的处理；
（2）接收按十进制表示的加数，也作适当的处理；
（3）进行加法处理；
（4）显示结果。
为此，设计三个子程序。
它们分别是：子程序GETNUM接收按十进制数表示的数串并作适当的处理；子程序ADDITION进行加法处理；子程序DISPNUM显示结果。
在子程序ADDITION中，使用非组合的BCD码加法调整指令AAA，所以十位的被加数和加数均保持非组合的BCD码串形式，
产生的11位和也是非组合的BCD码串。
子程序GETNUM通过DOS的0AH号系统功能调用，接收一个字符串，然后检查用户输入是否确实输入了一个十进制数，
最后形成一个十位的非组合的BCD码串（不足用0补足）。
子程序DISPNUM比较容易，先跳过结果中可能存在的前导的0，然后把非组合的BCD码转换为ASCII码后显示之。
；程序名：T6-2.ASM
；功能：完成两个由用户输入的10位十进制数的加法运算
MAXLEN = 10
DSEG SEGMENT
BUFF1 DB 32 DUP (?)
BUFF2 DB 32 DUP (?)
RESULT DB 32 DUP (24H)
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG,ES:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV ES,AX
MOV DX,OFFSET BUFF1
CALL GETNUM
MOV DX,OFFSET BUFF2
CALL GETNUM
MOV SI,OFFSET BUFF1 + 2
MOV DI,OFFSET BUFF2 + 2
MOV BX,OFFSET RESULT
MOV CX,MAXLEN
CALL ADDITION
MOV DX,OFFSET RESULT
CALL DISPNUM
MOV AH,4CH
INT 21H
GETNUM PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV DI,DX
CALL GETSTRD
MOV DI,DX
MOV CX,WORD PTR [DI]
SUB CX,2
ADD DI,2
ADD DI,MAXLEN
DEC DI
MOV SI,DX
ADD SI,2
ADD SI,CX
DEC SI
CMP SI,DI
JAE GETNUM_OK
MOV AX,MAXLEN
SUB AX,CX
STD
REP MOVSB
MOV CX,AX
XOR AL,AL
REP STOSB
CLD
GETNUM_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
GETNUM ENDP
ADDITION PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
ADD BX,CX
ADD SI,CX
ADD DI,CX
DEC SI
DEC DI
XCHG DI,BX
STD
CLC
ADDP1:LODSB
ADC AL,[BX]
AAA
STOSB
DEC BX
LOOP ADDP1
MOV AL,0
ADC AL,0
STOSB
CLD
ADDITION_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
ADDITION ENDP
DISPNUM PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV DI,DX
MOV AL,0
MOV CX,MAXLEN + 1
REPZ SCASB
DEC DI
MOV DX,DI
MOV SI,DI
INC CX
CLD
DISPNUM_S:LODSB
ADD AL,30H
STOSB
LOOP DISPNUM_S
MOV AH,9
INT 21H
DISPNUM_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DISPNUM ENDP
ISDEC PROC
CMP AL,'0'
JB ISDEC_NODEC
CMP AL,'9'
JA ISDEC_NODEC
CLC
JMP ISDEC_OK
ISDEC_NODEC:STC
ISDEC_OK:RET
ISDEC ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRD PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRD1:CALL GETCH
CMP AL,CR
JZ GETSTRD5
CMP AL,BACKSPACE
JNZ GETSTRD4
CMP BX,0
JZ GETSTRD2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRD1
GETSTRD2:CALL BELL
JMP GETSTRD1
GETSTRD4:CMP BX,MAXLEN
JZ GETSTRD2
CALL ISDEC
JC GETSTRD2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRD1
GETSTRD5:CMP BX,1
JB GETSTRD2
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRD_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRD ENDP
CSEG ENDS
END START
测试通过的完整程序如下
MAXLEN = 10
WINTOP = 0
WINLEFT = 0
WINBOTTOM = 24
WINRIGHT = 79
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ALTF1 = 6800H
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
DSEG SEGMENT
BUFF1 DB 32 DUP (?)
BUFF2 DB 32 DUP (?)
RESULT DB 32 DUP (24H)
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG,ES:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV ES,AX
MOV DX,OFFSET BUFF1
CALL GETNUM
MOV DX,OFFSET BUFF2
CALL GETNUM
MOV SI,OFFSET BUFF1 + 2
MOV DI,OFFSET BUFF2 + 2
MOV BX,OFFSET RESULT
MOV CX,MAXLEN
CALL ADDITION
MOV DX,OFFSET RESULT
CALL DISPNUM
MOV AH,4CH
INT 21H
GETNUM PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV DI,DX
CALL GETSTRD
MOV DI,DX
MOV CX,WORD PTR [DI]
SUB CX,2
ADD DI,2
ADD DI,MAXLEN
DEC DI
MOV SI,DX
ADD SI,2
ADD SI,CX
DEC SI
CMP SI,DI
JAE GETNUM_OK
MOV AX,MAXLEN
SUB AX,CX
STD
REP MOVSB
MOV CX,AX
XOR AL,AL
REP STOSB
CLD
GETNUM_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
GETNUM ENDP
ADDITION PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
ADD BX,CX
ADD SI,CX
ADD DI,CX
DEC SI
DEC DI
XCHG DI,BX
STD
CLC
ADDP1:LODSB
ADC AL,[BX]
AAA
STOSB
DEC BX
LOOP ADDP1
MOV AL,0
ADC AL,0
STOSB
CLD
ADDITION_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
ADDITION ENDP
DISPNUM PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV DI,DX
MOV AL,0
MOV CX,MAXLEN + 1
REPZ SCASB
DEC DI
MOV DX,DI
MOV SI,DI
INC CX
CLD
DISPNUM_S:LODSB
ADD AL,30H
STOSB
LOOP DISPNUM_S
MOV AH,9
INT 21H
DISPNUM_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DISPNUM ENDP
ISDEC PROC
CMP AL,'0'
JB ISDEC_NODEC
CMP AL,'9'
JA ISDEC_NODEC
CLC
JMP ISDEC_OK
ISDEC_NODEC:STC
ISDEC_OK:RET
ISDEC ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRD PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRD1:CALL GETCH
CMP AL,CR
JZ GETSTRD5
CMP AL,BACKSPACE
JNZ GETSTRD4
CMP BX,0
JZ GETSTRD2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRD1
GETSTRD2:CALL BELL
JMP GETSTRD1
GETSTRD4:CMP BX,MAXLEN
JZ GETSTRD2
CALL ISDEC
JC GETSTRD2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRD1
GETSTRD5:CMP BX,1
JB GETSTRD2
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRD_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRD ENDP
CSEG ENDS
END START
6.3DOS程序段前缀和特殊情况处理程序
本节把几个特殊情况处理程序作为简单应用程序的实例作介绍，其中也说明了软中断处理程序的设计方法。
6.3.1DOS程序段前缀PSP
1.程序段前缀PSP
程序段前缀（Program Segment Prefix）是DOS加载一个外部命令或应用程序（EXE或COM类型）时，
在程序段之前设置的一个具有256字节的信息区。PSP含有许多可用信息，其中常用信息的安排如表6.1所示。
当DOS把控制权转给外部命令或应用程序之时，数据段寄存器DS和附加段寄存器ES均指向其PSP，
即均含有PSP的段值，并不指向程序的数据段和附加段。这样应用程序可方便地使用到PSP中的有关信息。
2.终止程序的另一途径
利用DOS的4CH号系统功能调用能终止程序，把控制权转交回DOS，这是我们现在常用的方法。
但早先常利用DOS提供的20H号中断处理程序来终止程序。
通过20H号中断处理程序终止程序有一个条件，即进入20H号中断处理程序之前，代码段寄存器CS必须含有PSP的段值。
由于对EXE类型的应用程序而言，其代码段与PSP不是同一个段，所以不能简单地直接利用指令“INT 20H”来终止程序。
DOS注意到了这一点，在PSP的偏移0处，安排了一条“INT 20H”指令（其机器码为CD20）。
于是，应用程序只要设法转到PSP的偏移0处，就能实现程序的终止。
下面是一个例子，它是程序T3-1.ASM的改写。
；程序名：T6-3.ASM
；功能：显示信息“HELLO”
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
MESS DB 'HELLO',0DH,0AH,'$'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:PUSH DS
XOR AX,AX
PUSH AX
MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESS
MOV AH,9
INT 21H
RETF
CSEG ENDS
END START
测试通过的完整程序如下
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
MESS DB 'HELLO',0DH,0AH,'$'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:PUSH DS
XOR AX,AX
PUSH AX
MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESS
MOV AH,9
INT 21H
RETF
CSEG ENDS
END START
在标号START开始处的三条指令把PSP的段值和偏移0压入堆栈，
最后的返回指令RETF从堆栈弹出程序开始时压入堆栈的PSP段值和偏移0到CS和IP，
随后CPU就执行位于PSP偏移0的指令“INT 20H”，此时的CS含PSP段值，程序终止，控制转回DOS。
但我们不鼓励采用上述方法终止程序，而是推荐通过DOS系统功能调用4CH终止程序。
3.应用程序取得命令行参数
DOS加载一个外部命令或应用程序时，允许在被加载的程序名之后，输入多达127个字符（包括最后的回车符）的参数，
并把这些参数送到PSP的非格式化参数区，即PSP中从偏移80H开始的区域。
应用程序可从PSP中获得命令行参数。PSP的偏移80H处含命令行参数的长度（字节数），从PSP的偏移81H开始存放命令行参数。
命令行参数通常以空格符引导，至回车符（0DH）结束。注意，命令行中的重定向符和管道符及有关信息不作为命令行参数送到PSP。
例1：写一个显示命令行参数的程序。先从PSP中把命令行参数传到程序定义的缓冲区中，然后再显示。
源程序如下所示，数据段和代码段相重
；程序名：T6-4.ASM
；功能：显示命令行参数
CSEG SEGMENT
ASSUME CS:CSEG,DS:CSEG
BUFFER DB 128 DUP (?)
START:CLD
MOV SI,80H
LODSB
MOV CL,AL
XOR CH,CH
JCXZ OVER
CALL DAHTOASC
CALL NEWLINE
PUSH CS
POP ES
MOV DI,OFFSET BUFFER
PUSH CX
REP MOVSB
POP CX
PUSH ES
POP DS
MOV SI,OFFSET BUFFER
NEXT:LODSB
MOV DL,AL
MOV AH,2
INT 21H
LOOP NEXT
OVER:MOV AX,4C00H
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
HTOASC PROC
AND AL,0FH
ADD AL,30H
CMP AL,39H
JA HTOASC_NODEC
JMP HTOASC_OK
HTOASC_NODEC:ADD AL,7
HTOASC_OK:RET
HTOASC ENDP
HTOASCDA PROC
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
RET
HTOASCDA ENDP
AHTOASC PROC
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL HTOASCDA
XCHG AH,AL
CALL HTOASCDA
RET
AHTOASC ENDP
DAHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DAHTOASC ENDP
DHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH AX
XCHG AH,AL
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DHTOASC ENDP
CSEG ENDS
END START
例2：写一个显示文本文件内容的程序。文件名作为命令行参数给出。
程序T4-6.ASM显示当前盘当前目录下的文本文件TEST.TXT的内容，只要对它稍作修改，即把由用户输入的命令行参数传送到文件名缓冲区就可。
此外，当没有命令行参数，或命令行参数仅是空格等符号时，给出有关提示信息；为了简单，没有具体分析命令行参数，仅仅去掉前导空格符后，
就把余下的参数作为文件标识符处理。源程序如下：
；程序名：T6-5.ASM
；功能：显示文本文件的内容
WINTOP = 0
WINLEFT = 0
WINBOTTOM = 24
WINRIGHT = 79
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ALTF1 = 6800H
ESCKEY = 1BH
SPACE = 20H
TAB = 09H
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
FILEBUF_RW DB 512 DUP (0)
FNAME_SRC DB 128 DUP (0)
HANDLE_SRC DW 0
MESS_OPENERR DB 'Can not open file',07H,'$'
MESS_READERR DB 'Reading error',07h,'$'
MESS_FILEPTRERR DB 'Can not adjust file pointer',07H,'$'
MESS_GETLNERR DB 'Reading one line error',07h,'$'
MESS_FNSRCMISS DB 'Required filename missing',07h,'$'
res_dx dw 0
res_cx dw 0
res_bx dw 0
res_ax dw 0
num_dx dw 0
num_cx dw 0
num_bx dw 0
num_ax dw 0
val_dx dw 0
val_cx dw 0
val_bx dw 0
val_ax dw 0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:CLD
MOV SI,80H
LODSB
MOV CL,AL
XOR CH,CH
JCXZ FNSRCMISS
CALL DAHTOASC
CALL NEWLINE
GETFNSRC_S:LODSB
CMP AL,SPACE
JZ GETFNSRC_NEXT
CMP AL,TAB
JZ GETFNSRC_NEXT
JMP FNSRCOK
GETFNSRC_NEXT:LOOP GETFNSRC_S
JMP FNSRCMISS
FNSRCOK:DEC SI
MOV AX,SEG FNAME_SRC
MOV ES,AX
MOV DI,OFFSET FNAME_SRC
PUSH CX
REP MOVSB
POP CX
XOR AL,AL
STOSB
PUSH ES
POP DS
MOV SI,OFFSET FNAME_SRC
DISPFNSRC_S:LODSB
MOV DL,AL
MOV AH,2
INT 21H
LOOP DISPFNSRC_S
CALL NEWLINE
MOV AX,DSEG
MOV DS,AX
CALL DISPLAYFILE
JMP DISPFINISH
FNSRCMISS:MOV AX,SEG MESS_FNSRCMISS
MOV DS,AX
MOV DX,OFFSET MESS_FNSRCMISS
CALL DISPMESS
DISPFINISH:MOV AH,4CH
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
HTOASC PROC
AND AL,0FH
ADD AL,30H
CMP AL,39H
JA HTOASC_NODEC
JMP HTOASC_OK
HTOASC_NODEC:ADD AL,7
HTOASC_OK:RET
HTOASC ENDP
HTOASCDA PROC
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
RET
HTOASCDA ENDP
AHTOASC PROC
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL HTOASCDA
XCHG AH,AL
CALL HTOASCDA
RET
AHTOASC ENDP
DAHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DAHTOASC ENDP
DHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH AX
XCHG AH,AL
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DHTOASC ENDP
GETLNBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV NUM_BX,BX
MOV NUM_DX,DX
MOV DI,DX
MOV WORD PTR [DI],0
ADD DX,2
MOV CX,256
MOV AH,3FH
INT 21H
JC GETLNBUF_READERR
CMP AX,0
JZ GETLNBUF_FINISH
MOV BP,AX
MOV BX,NUM_DX
MOV SI,0
MOV DI,0
GETLNBUF_FORI1:CMP SI,BP
JAE GETLNBUF_FINISHI1
MOV AL,[BX][DI+2]
CMP AL,LF
JZ GETLNBUF_NEXTI2
JMP GETLNBUF_NEXTI1
GETLNBUF_NEXTI2:INC SI
INC DI
JMP GETLNBUF_FINISHI1
GETLNBUF_NEXTI1:INC SI
INC DI
JMP GETLNBUF_FORI1
GETLNBUF_FINISHI1:MOV WORD PTR [BX],SI
CMP SI,BP
JAE GETLNBUF_FINISH
MOV DX,SI
SUB DX,BP
MOV CX,0FFFFH
MOV BX,NUM_BX
MOV AX,4201H
INT 21H
JC GETLNBUF_FILEPTRERR
JMP GETLNBUF_FINISH
GETLNBUF_READERR:MOV DX,OFFSET MESS_READERR
CALL DISPMESS
STC
JMP GETLNBUF_OK
GETLNBUF_FILEPTRERR:MOV DX,OFFSET MESS_FILEPTRERR
CALL DISPMESS
STC
JMP GETLNBUF_OK
GETLNBUF_FINISH:CLC
GETLNBUF_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
GETLNBUF ENDP
DISPLAYLINE PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DI,DX
MOV BP,WORD PTR [DI]
ADD DI,2
MOV SI,0
DISPLAYLINE_FORI1:CMP SI,BP
JAE DISPLAYLINE_OK
MOV AL,[DI]
MOV DL,AL
MOV AH,2
INT 21H
DISPLAYLINE_NEXTI1:INC SI
INC DI
JMP DISPLAYLINE_FORI1
DISPLAYLINE_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DISPLAYLINE ENDP
DISPLAYFILE PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DX,OFFSET FNAME_SRC
MOV AX,3D00H
INT 21H
JNC DISPLAYFILE_OPENOKSRC
DISPLAYFILE_OPENERRSRC:MOV DX,OFFSET MESS_OPENERR
CALL DISPMESS
JMP DISPLAYFILE_OK
DISPLAYFILE_OPENOKSRC:MOV HANDLE_SRC,AX
DISPLAYFILE_RWBUF:MOV DX,OFFSET FILEBUF_RW
MOV BX,HANDLE_SRC
CALL GETLNBUF
JC DISPLAYFILE_READERR
MOV AX,WORD PTR FILEBUF_RW
CMP AX,0
JZ DISPLAYFILE_RWFINISH
MOV DX,OFFSET FILEBUF_RW
CALL DISPLAYLINE
JMP DISPLAYFILE_RWBUF
DISPLAYFILE_READERR:MOV DX,OFFSET MESS_GETLNERR
CALL DISPMESS
DISPLAYFILE_RWFINISH:MOV BX,HANDLE_SRC
MOV AH,3EH
INT 21H
DISPLAYFILE_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DISPLAYFILE ENDP
CSEG ENDS
END START
6.3.2 对Ctrl+C键和Ctrl+Break键的处理
1.Ctrl+C键的处理程序
先看下面的程序T6-6.ASM。它的功能是在屏幕上显示用户所按字符，直到用户按ESC键为止。
；程序名：T6-6.ASM
；功能：（略）
CR = 0DH
LF = 0AH
ESCKEY = 1BH
CSEG SEGMENT
ASSUME CS:CSEG,DS:CSEG
START:PUSH CS
POP DS
CONT:MOV AH,8
INT 21H
CMP AL,ESCKEY
JZ OVER
CMP AL,CR
JZ CONT_LINE
MOV DL,AL
MOV AH,2
INT 21H
JMP CONT
CONT_LINE:MOV DL,CR
MOV AH,2
INT 21H
MOV DL,LF
MOV AH,2
INT 21H
JMP CONT
OVER:MOV AH,4CH
INT 21H
CSEG ENDS
END START
就上述程序而言，按ESC键能终止程序运行，这是符合程序功能要求的。但按Ctrl+C键却能中止程序的运行。
当应用程序利用DOS系统功能调用进行字符输入输出（如键盘输入和显示输出等）时，DOS通常要检测Ctrl+C键（对应ASCII码为03H），
请参见4.3节中给出的常用DOS功能调用。如检测，那么DOS在遇到Ctrl+C键后，就先显示符号"^C"，并产生INT 23H，
缺省的23H号中断处理程序是中止程序的运行。DOS提供的这一功能便于用户随机地中止一个执行错误或不必继续执行的程序。
上述程序调用DOS的8号功能输入和2号功能输出，其间DOS要检测Ctrl+C键，所以按Ctrl+C键能中止上述程序的运行。
DOS为应用程序改变这种处理方法作了准备。应用程序只要改变23H号中断处理程序，就可基本控制住对Ctrl+C键的处理。
为了改变23H号中断处理程序，应用程序得提供一个新的23H号中断处理程序，然后修改23H号中断向量，使其指向新的23H号中断处理程序。
由于DOS在设置PSP时，已把当时的23H号中断向量（即Ctrl+C键处理中断向量）保存到PSP中，且在程序终止时再自动从PSP中取出并恢复。
近以，应用程序在修改23H号中断向量后，可不必恢复它。
下面的程序T6-6A.ASM就增加了23H号中断处理程序，该处理程序极其简单，只有一条中断返回指令IRET，也即不作任何处理。
所以在运行程序T6-6A时，按Ctrl+C键就不能再中止程序的运行。
只要应用程序需要，可把按Ctrl+C键后要进行的工作安排在23H号中断处理程序中。
；程序名：T6-6A.ASM
；功能：（略）
CR = 0DH
LF = 0AH
ESCKEY = 1BH
CSEG SEGMENT
ASSUME CS:CSEG,DS:CSEG
NEW23H:IRET
START:PUSH CS
POP DS
MOV DX,OFFSET NEW23H
MOV AX,2523H
INT 21H
CONT:MOV AH,8
INT 21H
CMP AL,ESCKEY
JZ OVER
CMP AL,CR
JZ CONT_LINE
MOV DL,AL
MOV AH,2
INT 21H
JMP CONT
CONT_LINE:MOV DL,CR
MOV AH,2
INT 21H
MOV DL,LF
MOV AH,2
INT 21H
JMP CONT
OVER:MOV AH,4CH
INT 21H
CSEG ENDS
END START
尽管按Ctrl+C键不再能中止T6-6A的运行，但屏幕上却会显示出符号"^C"。如果应用程序不在乎由于按Ctrl+C键带来的符号，
那么上述处理就可接受，如果应用程序"讨厌"由Ctrl+C键带来的符号，那么如下几种处理方法也许可满足需要：
（1）应用程序使用不检测Ctrl+C键的DOS功能调用进行字符输入输出；
（2）应用程序不利用DOS功能调用进行字符输入输出。
就上述程序T6-6.ASM这样的应用程序而言，这两种方法都是可行的。对一般应用程序而言，这两种方法不完全有效。
首先，应用程序不利用DOS功能调用进行字符输入输出，就要利用BIOS进行字符输入输出或直接进行输入输出，有时这是麻烦的。
其次，在大多数DOS系统功能调用（不仅仅是输入输出功能调用）其间，DOS要查看Ctrl+Break键是否被按下，如发现Ctrl+Break键被按，
则也会显示符号"^C"和产生INT 23H，下面先介绍对Ctrl+Break键的处理，然后再看一个基本解决问题的例子。
Ctrl+Break和Ctrl+C键的扫描码和ASCII码分别为0000H和2E03H
2.对Ctrl+Break键的处理
键盘中断处理程序（9H号中断处理程序）发现Ctrl+Break键被按时，将产生INT 1BH。
在DOS自举时，由DOS提供的1BH号中断处理程序将在约定的内存单元中设置一个标志，然后结束。
DOS通过该标志检测Ctrl+Break键是否被按下，如果发现被按下过，则象处理Ctrl+C那样显示符号"^C"和产生INT 23H。
如果应用程序要自己处理Ctrl+Break键，则可通过提供新的1BH号中断处理程序的方法来实现。
所以，如果应用程序要使得Ctrl+Break键不干扰程序的运行，只要使1BH号中断处理程序不设置与DOS约定的内存单元。
但要注意，DOS并不自动保存和恢复1BH号中断向量，所以如果应用程序要提供新的1BH号中断处理程序，
那么在修改1BH号中断向量之前，先要保存原1BH号中断向量，在程序结束前恢复它。
下面的程序T6-6B.ASM是对T6-6A.ASM的修改，提供了新的1BH号中断处理程序。
作为例子，新的1BH号中断处理程序只显示信息"**BREAK**"，然后就返回，所以在运行T6-6B.ASM时，按Ctrl+Break键不会出现符号"^C"。
；程序名：T6-6B.ASM
；功能：（略）
CR = 0DH
LF = 0AH
ESCKEY = 1BH
CSEG SEGMENT
ASSUME CS:CSEG,DS:CSEG
OLD1BH DD ?
VPAGE DB ?
MESS DB '**BREAK**',0
NEW1BH:PUSH DS
PUSH AX
PUSH BX
PUSH SI
PUSH CS
POP DS
CLD
MOV SI,OFFSET MESS
MOV BH,VPAGE
MOV AH,0EH
BRKNEXT:LODSB
OR AL,AL
JZ SHORT BRKEXIT
INT 10H
JMP BRKNEXT
BRKEXIT:POP SI
POP BX
POP AX
POP DS
IRET
NEW23H:IRET
START:PUSH CS
POP DS
MOV AH,0FH
INT 10H
MOV VPAGE,BH
MOV AX,351BH
INT 21H
MOV WORD PTR OLD1BH,BX
MOV WORD PTR OLD1BH+2,ES
MOV DX,OFFSET NEW23H
MOV AX,2523H
INT 21H
MOV DX,OFFSET NEW1BH
MOV AX,251BH
INT 21H
CONT:MOV AH,8
INT 21H
CMP AL,ESCKEY
JZ OVER
CMP AL,CR
JZ CONT_LINE
MOV DL,AL
MOV AH,2
INT 21H
JMP CONT
CONT_LINE:MOV DL,CR
MOV AH,2
INT 21H
MOV DL,LF
MOV AH,2
INT 21H
JMP CONT
OVER:LDS DX,OLD1BH
MOV AX,251BH
INT 21H
MOV AH,4CH
INT 21H
CSEG ENDS
END START
有一点值得指出，如果在T6-6B.ASM中不提供新的23H号中断处理程序，可能会导致麻烦。
因为如果按Ctrl+C键将中止程序的运行，而原1BH号中断处理程序得不到恢复。
3.一个能控制住Ctrl+C键和Ctrl+Break键的例子
在上述程序T6-6B中，控制住了Ctrl+Break键。在其运行时，按Ctrl+C键也不中止程序的运行，但仍会出现符号"^C"。
现在我们修改键盘管理程序（16H号中断处理程序），使其不返回Ctrl+C键（即ASCII码03H）。
在下面的程序中，提供了新的16H号中断处理程序，它"吃掉"了Ctrl+C键，同时也滤掉了Ctrl+2键（它类似于Ctrl+C，其扫描码为03H），
还滤掉了按Ctrl+Break键产生的0000H（扫描码为00H，ASCII码为00H）。
这样，DOS就不可能检测到Ctrl+C键了。新的1BH号中断处理程序仅是一条中断返回指令。所以，我们就不再提供新的23H号中断处理程序。
验证修改16H号中断处理程序
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:CSEG
OLD16H DD ?
NEW16H_OFF = 200H
NEW16H_SEG = 0
NEW16H_BEGIN:PUSH DS
PUSH ES
PUSH BX
PUSH CX
PUSH DX
MOV DX,AX
MOV AX,CSEG
MOV DS,AX
MOV AX,DX
pushf
pushf
pop bx
and bh,11111100b
push bx
popf
call dword ptr ds:[0]
NEW16H_OK:
POP DX
POP CX
POP BX
POP ES
POP DS
IRET
NEW16H_LEN = $ - OFFSET NEW16H_BEGIN
START:PUSH CS
POP DS
mov si,offset NEW16H_BEGIN
mov ax,NEW16H_SEG
mov es,ax
mov di,NEW16H_OFF
mov cx,NEW16H_LEN
cld
rep movsb
MOV AX,3516H
INT 21H
MOV WORD PTR OLD16H,BX
MOV WORD PTR OLD16H+2,ES
mov ax,NEW16H_SEG
mov ds,ax
MOV DX,NEW16H_OFF
MOV AX,2516H
INT 21H
PUSH CS
POP DS
CHECK_KB:CALL GETCH
CALL PUTCH
CMP AL,ESCKEY
JNZ CHECK_KB
LDS DX,OLD16H
MOV AX,2516H
INT 21H
MOV AH,4CH
INT 21H
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
GETCH PROC
MOV AH,0
INT 16H
RET
GETCH ENDP
CSEG ENDS
END START
修改16H号中断之后，用原16H号中断返回的标志寄存器值修改现16H号中断返回要恢复的标志寄存器值
调用21H号中断处理程序的8号功能进行键盘输入
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:CSEG
OLD16H DD ?
NEW16H_OFF = 204H
NEW16H_SEG = 0
NEW16H_BEGIN:PUSH BP
MOV BP,SP
PUSH BX
INT 80H
PUSHF
POP BX
MOV WORD PTR SS:[BP+6],BX
POP BX
POP BP
IRET
NEW16H_LEN = $ - OFFSET NEW16H_BEGIN
START:PUSH CS
POP DS
MOV AL,'1'
CALL PUTCH
mov ah,8
INT 21H
CALL PUTCH
MOV AL,'1'
CALL PUTCH
mov si,offset NEW16H_BEGIN
mov ax,NEW16H_SEG
mov es,ax
mov di,NEW16H_OFF
mov cx,NEW16H_LEN
cld
rep movsb
MOV AX,3516H
INT 21H
mov ax,NEW16H_SEG
mov ds,ax
MOV WORD PTR ds:[200H],BX
MOV WORD PTR ds:[202H],ES
mov ax,NEW16H_SEG
mov ds,ax
MOV DX,NEW16H_OFF
MOV AX,2516H
INT 21H
PUSH CS
POP DS
CONT:MOV AL,'2'
CALL PUTCH
CALL GETCH
CALL PUTCH
CMP AL,ESCKEY
JZ OVER
CMP AL,CR
JZ CONT_LINE
CALL PUTCH
JMP CONT
CONT_LINE:CALL PUTCH
MOV AL,LF
CALL PUTCH
JMP CONT
OVER:mov ax,NEW16H_SEG
mov ds,ax
LDS DX,ds:[200H]
MOV AX,2516H
INT 21H
MOV AL,'1'
CALL PUTCH
mov ah,8
INT 21H
CALL PUTCH
MOV AL,'1'
CALL PUTCH
MOV AH,4CH
INT 21H
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
CSEG ENDS
END START
；程序名：T6-6C.ASM
；功能：（略）
CR = 0DH
LF = 0AH
ESCKEY = 1BH
CSEG SEGMENT
ASSUME CS:CSEG,DS:CSEG
OLD16H DD ?
OLD1BH DD ?
NEW16H:PUSH BP
MOV BP,SP
PUSH BX
PUSH DS
PUSH CS
POP DS
CMP AH,10H
JZ PKEY
CMP AH,11H
JZ PKEY2
CMP AH,0
JZ PKEY
CMP AH,1
JZ PKEY2
PUSHF
CALL DWORD PTR DS:[0]
PUSHF
POP BX
MOV WORD PTR SS:[BP+6],BX
POP DS
POP BX
POP BP
IRET
PKEY:PUSH AX
PUSHF
CALL DWORD PTR DS:[0]
PUSHF
POP BX
MOV WORD PTR SS:[BP+6],BX
CMP AL,03H
JZ PKEY_NEXT
CMP AX,0300H
JZ PKEY_NEXT
CMP AX,0000H
JZ PKEY_NEXT
ADD SP,2
POP DS
POP BX
POP BP
IRET
PKEY_NEXT:POP AX
JMP PKEY
PKEY2:PUSH AX
PUSHF
CALL DWORD PTR DS:[0]
PUSHF
POP BX
MOV WORD PTR SS:[BP+6],BX
JZ PKEY6
CMP AL,03H
JZ PKEY4
CMP AX,0300H
JZ PKEY4
CMP AX,0000H
JZ PKEY4
JMP PKEY5
PKEY4:XOR AH,AH
PUSHF
CALL DWORD PTR DS:[0]
POP AX
JMP PKEY2
PKEY5:ADD SP,2
POP DS
POP BX
POP BP
IRET
PKEY6:ADD SP,2
POP DS
POP BX
POP BP
IRET
NEW1BH:IRET
START:PUSH CS
POP DS
MOV AX,3516H
INT 21H
MOV WORD PTR OLD16H,BX
MOV WORD PTR OLD16H+2,ES
MOV AX,351BH
INT 21H
MOV WORD PTR OLD1BH,BX
MOV WORD PTR OLD1BH+2,ES
MOV DX,OFFSET NEW16H
MOV AX,2516H
INT 21H
MOV DX,OFFSET NEW1BH
MOV AX,251BH
INT 21H
CONT:CALL GETCH
CMP AL,ESCKEY
JZ OVER
CMP AL,CR
JZ CONT_LINE
CALL PUTCH
JMP CONT
CONT_LINE:CALL NEWLINE
JMP CONT
OVER:PUSH CS
POP DS
LDS DX,OLD1BH
MOV AX,251BH
INT 21H
PUSH CS
POP DS
LDS DX,OLD16H
MOV AX,2516H
INT 21H
MOV AH,4CH
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
CSEG ENDS
END START
6.4 TSR程序设计举例
TSR（Terminate and Stay Resident）意为结束并驻留。TSR程序是一种特殊的DOS应用程序，不同于结束即退出的一般DOS应用程序。
TSR程序装入内存并初次运行后，程序的大部分仍驻留内存，被某种条件激活后又投入运行。
它能及时地处理许多暂驻程序不能处理的事件，并可为单任务操作系统DOS增添一定的多任务处理能力。
编写TSR程序时要考虑许多方面的问题，诸如TSR的激活条件和资源使用的冲突等，对这些问题的讨论超出了本教程的范围，
所以本节仅举两个例子说明如何编写简单的TSR 程序。
6.4.1 驻留的时钟显示程序
通常TSR程序由驻留内存部分和初始化部分组成。把TSR程序装入内存时，初次运行的是初始化部分。
初始化程序的主要功能是，对驻留部分完成必要的初始化工作；使驻留部分保留在内存中。
下面的时钟显示程序是对在5.5.2节中介绍的时钟显示程序的扩充。初始化后驻留在内存的程序由时钟中断激活。
；程序名：T6-7.ASM
；功能：在内存中驻留显示时钟的程序
COLOR = 07H
DPAGE = 0
ROW = 12
COLUMN = 28
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
CSEG SEGMENT
ASSUME CS:CSEG,DS:CSEG
OLD1CH DD ?
COUNT_VAL= 18
NEW1CH_BEGIN:JMP SHORT NEW1CH_START
COUNT DW COUNT_VAL
DATETIME_BUF DB 19 DUP (?)
CURSOR DW ?
NEW1CH_START:CMP WORD PTR CS:COUNT,0
JZ NEXT
DEC WORD PTR CS:COUNT
PUSHF
CALL DWORD PTR CS:[0]
IRET
NEXT:MOV WORD PTR CS:COUNT,COUNT_VAL
STI
PUSH DS
PUSH ES
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH BP
PUSH CS
POP DS
PUSH DS
POP ES
MOV SI,offset DATETIME_BUF
CALL GETDATETIME
MOV BH,DPAGE
MOV AH,3
INT 10H
MOV WORD PTR CS:CURSOR,DX
MOV BP,offset DATETIME_BUF
MOV BH,DPAGE
MOV DH,ROW
MOV DL,COLUMN
MOV BL,COLOR
MOV CX,19
MOV AL,0
MOV AH,13H
INT 10H
MOV BH,DPAGE
MOV DX,WORD PTR CS:CURSOR
MOV AH,2
INT 10H
POP BP
POP SI
POP DX
POP CX
POP BX
POP AX
POP ES
POP DS
PUSHF
CALL DWORD PTR CS:[0]
IRET
GETDATETIME PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV AH,4
INT 1AH
MOV AL,CH
CALL TTASC
MOV BYTE PTR DS:[SI],AH
MOV BYTE PTR DS:[SI+1],AL
MOV AL,CL
CALL TTASC
MOV BYTE PTR DS:[SI+2],AH
MOV BYTE PTR DS:[SI+3],AL
MOV BYTE PTR DS:[SI+4],'-'
MOV AL,DH
CALL TTASC
MOV BYTE PTR DS:[SI+5],AH
MOV BYTE PTR DS:[SI+6],AL
MOV BYTE PTR DS:[SI+7],'-'
MOV AL,DL
CALL TTASC
MOV BYTE PTR DS:[SI+8],AH
MOV BYTE PTR DS:[SI+9],AL
MOV BYTE PTR DS:[SI+10],20H
MOV AH,2
INT 1AH
MOV AL,CH
CALL TTASC
MOV BYTE PTR DS:[SI+11],AH
MOV BYTE PTR DS:[SI+12],AL
MOV BYTE PTR DS:[SI+13],':'
MOV AL,CL
CALL TTASC
MOV BYTE PTR DS:[SI+14],AH
MOV BYTE PTR DS:[SI+15],AL
MOV BYTE PTR DS:[SI+16],':'
MOV AL,DH
CALL TTASC
MOV BYTE PTR DS:[SI+17],AH
MOV BYTE PTR DS:[SI+18],AL
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
GETDATETIME ENDP
TTASC PROC
MOV AH,AL
AND AL,0FH
SHR AH,1
SHR AH,1
SHR AH,1
SHR AH,1
ADD AX,3030H
RET
TTASC ENDP
START:PUSH CS
POP DS
MOV AX,351CH
INT 21H
MOV WORD PTR OLD1CH,BX
MOV WORD PTR OLD1CH+2,ES
MOV DX,NEW1CH_BEGIN
MOV AX,251CH
INT 21H
MOV DX,OFFSET START
ADD DX,15
MOV CL,4
SHR DX,CL
ADD DX,10H
MOV AH,31H
INT 21H
CSEG ENDS
END START
把上面的程序与T5-5.ASM相比较可知，其中的1CH号中断处理程序基本相同；
初始化部分包含了驻留退出的代码，把1CH号中断处理程序驻留在内存中，此外还把保存原1CH号中断向量的双字变量OLD1CH移到驻留区。
通过DOS的31H号功能调用进行驻留退出。该功能调用的主要入口参数是含在DX中的驻留节数（1节等于16字节），
驻留的内容从程序段前缀开始计算，所以在计算驻留节数时，除了计算要驻留的数据和代码的长度外，还需要加上PSP的10H节。
把DOS的31H号功能调用与4CH号功能调用相比，所不同的是它在交出控制权时没有全部交出占用的内存资源，
而是根据要求（由入口参数规定）保留了部分。
6.4.2 热键激活的TSR程序
有多种方式或方法激活驻留的程序，键盘激活是常见的一种方法。
例如可驻留一个保存屏幕画面的程序，然后当屏幕上出现需要保存的画面时，按一个约定的激活键来激活它。这样的键称为热键。
下面的程序T6-8.ASM是一个简单的热键激活TSR程序的例子。热键设定为CTRL+F8，
在驻留后，每按一次CTRL+F8键，就在屏幕约定的位置显示一字符串。
The BIOS has a default memory area for the keyboard buffer which holds up to 16 keystrokes.
This area starts at 0040:001Eh and is 32 bytes in length. (16 2-byte scancodes)
The word (2 bytes) at 0040:001Ah hold the current head of the BIOS keyboard buffer.
The word (2 bytes) at 0040:001Ch hold the current tail of the BIOS keyboard buffer.
If these two pointers are different, then there is a keystroke ready for extraction.
BIOS键盘缓冲区0040:001AH、0040:001CH分别指向循环队列的头、尾
09H号中断把用户所按键的扫描码和ASCII码放入BIOS键盘缓冲区，同时调整循环队列的尾
每放入一个，循环队列的尾加2，加2之后大等于0040:003E，则重新指向0040:001E
16H号中断0号功能从BIOS键盘缓冲区取一个键的扫描码和ASCII码，同时调整循环队列的头
每取一个，循环队列的头加2，加2之后大等于0040:003E，则重新指向0040:001E
修改16H号中断之后，注意用原16H号中断返回的标志寄存器值修改现16H号中断返回要恢复的标志寄存器值
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:CSEG
OLD16H DD ?
NEW16H_OFF = 204H
NEW16H_SEG = 0
NEW16H_BEGIN:PUSH BP
MOV BP,SP
PUSH BX
INT 80H
PUSHF
POP BX
MOV WORD PTR SS:[BP+6],BX
POP BX
POP BP
IRET
NEW16H_LEN = $ - OFFSET NEW16H_BEGIN
START:PUSH CS
POP DS
mov si,offset NEW16H_BEGIN
mov ax,NEW16H_SEG
mov es,ax
mov di,NEW16H_OFF
mov cx,NEW16H_LEN
cld
rep movsb
MOV AX,3516H
INT 21H
mov ax,NEW16H_SEG
mov ds,ax
MOV WORD PTR ds:[200H],BX
MOV WORD PTR ds:[202H],ES
mov ax,NEW16H_SEG
mov ds,ax
MOV DX,NEW16H_OFF
MOV AX,2516H
INT 21H
PUSH CS
POP DS
CALL CLEARBUFKB
CALL DISPLAYBUFKB
CALL NEWLINE
CONT:CALL GETCH
CMP AL,ESCKEY
JZ OVER
CMP AL,CR
JZ CONT_LINE
CALL PUTCH
CALL DHTOASC
CALL NEWLINE
CALL DISPLAYBUFKB
CALL NEWLINE
JMP CONT
CONT_LINE:CALL PUTCH
MOV AL,LF
CALL PUTCH
JMP CONT
OVER:mov ax,NEW16H_SEG
mov ds,ax
LDS DX,ds:[200H]
MOV AX,2516H
INT 21H
MOV AH,4CH
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
GETCH PROC
MOV AH,0
INT 16H
RET
GETCH ENDP
CLEARBUFKB PROC
PUSH AX
CLEARBUFKB_S:MOV AH,1
INT 16H
JZ CLEARBUFKB_OK
MOV AH,0
INT 16H
JMP CLEARBUFKB_S
CLEARBUFKB_OK:POP AX
RET
CLEARBUFKB ENDP
DISPLAYBUFKB PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
MOV AX,0040H
MOV DS,AX
MOV BX,001AH
MOV BP,0
DISPLAYBUFKB_FORI1:CMP BP,18
JAE DISPLAYBUFKB_OK
MOV AX,DS:[BX]
CALL DHTOASC
MOV AL,20H
CALL PUTCH
DISPLAYBUFKB_NEXTI1:INC BP
INC BX
INC BX
JMP DISPLAYBUFKB_FORI1
DISPLAYBUFKB_OK:POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DISPLAYBUFKB ENDP
HTOASC PROC
AND AL,0FH
ADD AL,30H
CMP AL,39H
JA HTOASC_NODEC
JMP HTOASC_OK
HTOASC_NODEC:ADD AL,7
HTOASC_OK:RET
HTOASC ENDP
HTOASCDA PROC
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
RET
HTOASCDA ENDP
AHTOASC PROC
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL HTOASCDA
XCHG AH,AL
CALL HTOASCDA
RET
AHTOASC ENDP
DAHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DAHTOASC ENDP
DHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH AX
XCHG AH,AL
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DHTOASC ENDP
CSEG ENDS
END START
；程序名：T6-8.ASM
：功能：简单的热键激活TSR程序
BUFF_HEAD = 1AH
BUFF_TAIL = 1CH
BUFF_START = 1EH
BUFF_END = 3ЕН
CTRL_F8 = 6500H
ROW = 3
COLUMN = 0
PAGEN = 0
CSEG SEGMENT
ASSUME CS:CSEG,DS:CSEG
OLD09H DD ?
MESS DB 'Hello!'
MESSLEN EQU $ - OFFSET MESS
NEW09H:PUSHF
CALL CS:OLD09H
STI
PUSH DS
PUSH AX
PUSH BX
MOV AX,40H
MOV DS,AX
MOV BX,DS:[BUFF_HEAD]
CMP BX,DS:[BUFF_TAIL]
JZ IOVER
MOV AX,DS:[BX]
CMP AX,CTRL_F8
JZ YES
IOVER:POP BX
POP AX
POP DS
IRET
YES:INC BX
INC BX
CMP BX,BUFF_END
JNZ YES1
MOV BX,BUFF_START
YES1:MOV DS:[BUFF_HEAD],BX
PUSH CX
PUSH DX
PUSH BP
PUSH ES
MOV AX,CS
MOV ES,AX
MOV BP,OFFSET MESS
MOV CX,MESSLEN
MOV DH,ROW
MOV DL,COLUMN
MOV BH,PAGEN
MOV BL,07H
MOV AL,0
MOV AH,13H
INT 10H
POP ES
POP BP
POP DX
POP CX
JMP IOVER
START:PUSH CS
POP DS
MOV AX,3509H
INT 21H
MOV WORD PTR OLD09H,BX
MOV WORD PTR OLD09H+2,ES
MOV DX,OFFSET NEW09H
MOV AX,2509H
INT 21H
MOV DX,OFFSET START
ADD DX,15
MOV CL,4
SHR DX,CL
ADD DX,10H
MOV AL,0
MOV AH,31H
INT 21H
CSEG ENDS
END START
测试通过的完整程序如下
BIOS键盘缓冲区0040:001AH、0040:001CH分别指向循环队列的头、尾
09H号中断把用户所按键的扫描码和ASCII码放入BIOS键盘缓冲区，同时调整循环队列的尾
每放入一个，循环队列的尾加2，加2之后大等于0040:003E，则重新指向0040:001E
16H号中断0号功能从BIOS键盘缓冲区取一个键的扫描码和ASCII码，同时调整循环队列的头
每取一个，循环队列的头加2，加2之后大等于0040:003E，则重新指向0040:001E
这个程序需要有外部程序不断从键盘缓冲区中读出按键的扫描码和ASCII码，
这个程序总是取键盘缓冲区head指向的按键相应码进行判断
BUFF_HEAD = 1AH
BUFF_TAIL = 1CH
BUFF_START = 1EH
BUFF_END = 3EH
CTRL_F8 = 6500H
COLOR = 07H
DPAGE = 0
ROW = 12
COLUMN = 28
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
CSEG SEGMENT
ASSUME CS:CSEG,DS:CSEG
OLD09H DD ?
NEW09H_BEGIN:JMP SHORT NEW09H_START
MESS DB 'Hello!'
NEW09H_START:PUSHF
CALL DWORD PTR CS:[0]
STI
PUSH DS
PUSH AX
PUSH BX
MOV AX,40H
MOV DS,AX
MOV BX,DS:[BUFF_HEAD]
CMP BX,DS:[BUFF_TAIL]
JZ NEW09H_OVER
MOV AX,DS:[BX]
CMP AX,CTRL_F8
JZ YES
NEW09H_OVER:POP BX
POP AX
POP DS
IRET
YES:INC BX
INC BX
CMP BX,BUFF_END
JNZ YES1
MOV BX,BUFF_START
YES1:MOV DS:[BUFF_HEAD],BX
PUSH CX
PUSH DX
PUSH BP
PUSH ES
MOV AX,CS
MOV ES,AX
MOV BP,OFFSET MESS
MOV CX,6
MOV DH,ROW
MOV DL,COLUMN
MOV BH,DPAGE
MOV BL,COLOR
MOV AL,0
MOV AH,13H
INT 10H
POP ES
POP BP
POP DX
POP CX
JMP NEW09H_OVER
START:PUSH CS
POP DS
CALL CLEARBUFKB
MOV AX,3509H
INT 21H
MOV WORD PTR OLD09H,BX
MOV WORD PTR OLD09H+2,ES
MOV DX,OFFSET NEW09H_BEGIN
MOV AX,2509H
INT 21H
MOV DX,OFFSET START
ADD DX,15
MOV CL,4
SHR DX,CL
ADD DX,10H
MOV AL,0
MOV AH,31H
INT 21H
CLEARBUFKB PROC
PUSH AX
CLEARBUFKB_S:MOV AH,1
INT 16H
JZ CLEARBUFKB_OK
MOV AH,0
INT 16H
JMP CLEARBUFKB_S
CLEARBUFKB_OK:POP AX
RET
CLEARBUFKB ENDP
CSEG ENDS
END START
上面程序的初始化部分先保存了9号中断向量（原键盘中断处理程序的入口地址），
然后设置新的9号中断向量，使其指向新的键盘中断处理程序，最后驻留结束。这样每当按键，就会运行新的键盘中断处理程序。
新的键盘中断处理程序先调用老的键盘中断处理程序完成按键处理工作，然后通过检查键盘缓冲区，判断是否按了约定的热键CTRL+F8，
当判断出按了CTRL+F8后，就显示一预定的提示信息。
6.5习题
题6.1请说明标志DF的作用。如何设置DF？
字符串操作指令执行时会自动调整作为指针使用的寄存器SI或DI之值。方向标志DF控制字符串操作的方向（处理字符串中单元的次序）。
当方向标志DF为0时，按递增方式调整寄存器SI或DI之值；当方向标志DF为1时，按递减方式调整寄存器SI或DI之值。
CLD 方向标志DF为0
STD 方向标志DF为1
题6.2在8086/8088的指令集中，哪些指令属于两个操作数都可以是存储器操作数这种例外情况？
字符串传送指令和字符串比较指令的源操作数和目的操作均在存储器中
MOVSB 字节传送
MOVSW 字传送
CMPSB 字节比较
CMPSW 字比较
题6.3”请说明指令“LODSB”与如下程序片段的异同：MOV AL,[SI] INC SI
相同点都把寄存器SI所指向的一个字节数据装入到累加器AL中，不同点LODSB根据方向标志DF为0或为1使SI之值增1或减1。
题6.4请说明指 令“STSOW"与如下程序片段的异同：MOV [DI],AX ADD DI,2
STOSW把累加器AX的内容送到寄存器DI所指向的存储单元中，然后根据方向标志DF复位或置位使DI之值增2或减2。
类似于如下的两条指令：
MOV ES:[DI],AX
ADD Dl,2或SUB DI,2
相同点都把累加器AX的内容送到寄存器DI所指向的存储单元中
不同点STOSW是ES:[DI]，不是DS:[DI]，STOSW根据方向标志DF为0或为1使DI之值增2或减2。
题6.5请说明指令“SCASB"与如下程序片段的异同：CMP AL,ES:[DI] INC DI
SCASB把累加器AL的内容与由寄存器DI所指向一个字节数据采用相减方式比较，
相减结果反映到各有关标志位（AF，CF，OF，PF，SF和ZF），但不影响两个操作数，
然后根据方向标志DF复位或置位使DI之值增1或减1。
相同点都把累加器AL的内容与由寄存器DI所指向一个字节数据采用相减方式比较
不同点SCASB根据方向标志DF为0或为1使DI之值增1或减1。SCASB把相减结果反映到各有关标志位（AF，CF，OF，PF，SF和ZF），
其中DI之值增1或减1不影响这些标志位。而INC DI会影响这些标志位。
题6.6请写一个程序片段代替指令“REP MOVSW”。
REP用作为一个串操作指令的前缀，它重复其后的串操作指令动作。
每一次重复都先判断CX是否为0，如为0就结束重复，否则CX的值减1，重复其后的串操作指令。
它类似于LOOP指令，但LOOP指令是先把CX的值减1，后再判是否为0。
注意，在重复过程中的CX减1操作，不影啊各标志。
s1:JCXZ s1fn
MOVSW
DEC CX
JMP s1
s1fn:
题6.7请写一个程序片段代替指令"REPNZ CMPSB"。
REPZ用作为一个串操作指令的前缀，它重复其后的串操作指令动作。
每重复一次，CX的值减1，重复一直进行到CX为0或串操作指令使零标志ZF为0时止。
重复结束条件的检查是在重复开始之前进行的。
注意，在重复过程中的CX值减1操作，不影响标志。
REPNZ用作为一个串操作指令的前缀。与REPZ类似，所不同的是重复一直进行到CX为0或串操作指令使零标志ZF为1时止。
LOOPZ 标号
这条指令使寄存器CX的值减1，如果结果不等于0，并且零标志ZF等于1，那么则转移到标号，否则顺序执行。
注意指令本身实施的寄存器CX减1操作不影响标志。
LOOPNZ 标号
这条指令使寄存器CX的值减1，如果结果不等于0，并且零标志ZF等于0，那么则转移到标号，否则顺序执行。
注意指令本身实施的寄存器CX减1操作不影响标志。
s1:JCXZ s1fn
CMPSB
pushf
DEC CX
popf
JNZ s1
s1fn:
题6.8请考察重复前缀REP与重复前缀REPZ/REPE的机器码。
REPNZ的机器码F2
REPZ的机器码F3
REP的机器码和REPZ一样都是F3
题6.9编写一个实现数据块移动的近过程。通过寄存器传递参数。
MEMCOPY PROC
PUSHF
PUSH CX
PUSH SI
PUSH DI
CLD
TEST SI,1
JZ MEMCOPY_1
MOVSB
DEC CX
MEMCOPY_1:SHR CX,1
REP MOVSW
JNC MEMCOPY_OK
MOVSB
MEMCOPY_OK:POP DI
POP SI
POP CX
POPF
RET
MEMCOPY ENDP
DS:SI,ES:DI,CX作为入口参数
PUSH CS
POP DS
mov si,offset NEW1CH_BEGIN
mov ax,NEW1CH_SEG
mov es,ax
mov di,NEW1CH_OFF
mov cx,NEW1CH_LEN
CALL MEMCOPY
题6.10编写一个实现字符串拷贝的近过程。通过堆栈传递作为参数的源和目标字符串首地址的偏移。
MEMCOPY PROC
PUSHF
PUSH CX
PUSH SI
PUSH DI
CLD
TEST SI,1
JZ MEMCOPY_1
MOVSB
DEC CX
MEMCOPY_1:SHR CX,1
REP MOVSW
JNC MEMCOPY_OK
MOVSB
MEMCOPY_OK:POP DI
POP SI
POP CX
POPF
RET
MEMCOPY ENDP
STRCOPY PROC
PUSH BP
MOV BP,SP
PUSHF
PUSH AX
PUSH CX
PUSH SI
PUSH DI
PUSH ES
MOV SI,[BP+6]
MOV DI,[BP+4]
CLD
PUSH DS
POP ES
PUSH DI
MOV DI,SI
XOR AL,AL
MOV CX,0FFFFH
REPNZ SCASB
NOT CX
POP DI
CALL MEMCOPY
STRCOPY_OK:POP ES
POP DI
POP SI
POP CX
POP AX
POPF
POP BP
RET
STRCOPY ENDP
DS:SI,DS:DI作为入口参数，通过堆栈传递
MOV AX,OFFSET FNAME_SRC
ADD AX,2
PUSH AX
MOV AX,OFFSET STR_CP
PUSH AX
CALL STRCOPY
ADD SP,4
MOV SI,AX
MOV CX,9
MOV BL,COLOR
MOV DH,ROW + 12
MOV DL,COLUMN
CALL SHOWSTR
题6.11编写一个把字符串中的小写字母转换为大写（字符串以0结尾）的远过程。通过堆栈传递包括段值和偏移在内的字符串首地址。
ISLOWER PROC
CMP AL,'a'
JB ISLOWER_NOLOWER
CMP AL,'z'
JA ISLOWER_NOLOWER
CLC
JMP ISLOWER_OK
ISLOWER_NOLOWER:STC
ISLOWER_OK:RET
ISLOWER ENDP
STRLRTOUR PROC FAR
PUSH BP
MOV BP,SP
PUSHF
PUSH SI
PUSH DS
MOV DS,[BP+8]
MOV SI,[BP+6]
CLD
TEST SI,1
JZ STRLRTOUR_1
LODSB
AND AL,AL
JZ STRLRTOUR_OK
CALL ISLOWER
JC STRLRTOUR_1
SUB AL,20H
MOV DS:[SI-1],AL
STRLRTOUR_1:LODSW
AND AL,AL
JZ STRLRTOUR_OK
CALL ISLOWER
JC STRLRTOUR_2
SUB AL,20H
MOV DS:[SI-2],AL
STRLRTOUR_2:AND AH,AH
JZ STRLRTOUR_OK
MOV AL,AH
CALL ISLOWER
JC STRLRTOUR_3
SUB AL,20H
MOV DS:[SI-1],AL
STRLRTOUR_3:JMP STRLRTOUR_1
STRLRTOUR_OK:POP DS
POP SI
POPF
POP BP
RETF
STRLRTOUR ENDP
DS:SI作为入口参数，通过堆栈传递
MOV SI,OFFSET STR_LR
PUSH DS
PUSH SI
CALL FAR PTR STRLRTOUR
ADD SP,4
MOV SI,OFFSET STR_LR
MOV CX,9
MOV BL,COLOR
MOV DH,ROW + 13
MOV DL,COLUMN
CALL SHOWSTR
题6.12改写6.1.3中的例1和例2，通过堆栈传递入口参数。
改写STRCHR
STRCHRB PROC
PUSH BP
MOV BP,SP
PUSHF
PUSH BX
PUSH DX
PUSH SI
PUSH DS
MOV DS,[BP+8]
MOV SI,[BP+6]
MOV AX,[BP+4]
MOV DX,SI
MOV BL,AL
CLD
TEST SI,1
JZ STRCHRB_1
LODSB
AND AL,AL
JZ STRCHRB_NOTF
CMP AL,BL
JZ STRCHRB_FIND1
STRCHRB_1:LODSW
AND AL,AL
JZ STRCHRB_NOTF
CMP AL,BL
JZ STRCHRB_FIND2
AND AH,AH
JZ STRCHRB_NOTF
CMP AH,BL
JZ STRCHRB_FIND1
JMP STRCHRB_1
STRCHRB_NOTF:STC
JMP SHORT STRCHRB_OK
STRCHRB_FIND1:LEA AX,[SI-1]
SUB AX,DX
JMP SHORT STRCHRB_OK
STRCHRB_FIND2:LEA AX,[SI-2]
SUB AX,DX
STRCHRB_OK:POP DS
POP SI
POP DX
POP BX
POPF
POP BP
RET
STRCHRB ENDP
DS:SI,AL作为入口参数，通过堆栈传递
MOV SI,OFFSET STR_LR
PUSH DS
PUSH SI
MOV AH,0
MOV AL,'G'
PUSH AX
CALL STRCHRB
ADD SP,6
CALL DHTOASC
CALL NEWLINE
改写STRCAT
STRCATB PROC
PUSH BP
MOV BP,SP
PUSHF
PUSH AX
PUSH CX
PUSH SI
PUSH DI
PUSH ES
MOV SI,[BP+6]
MOV DI,[BP+4]
CLD
PUSH DS
POP ES
PUSH DI
MOV DI,SI
XOR AL,AL
MOV CX,0FFFFH
REPNZ SCASB
LEA SI,[DI-1]
POP DI
PUSH DI
XOR AL,AL
MOV CX,0FFFFH
REPNZ SCASB
NOT CX
POP DI
XCHG SI,DI
CALL MEMCOPY
STRCATB_OK:POP ES
POP DI
POP SI
POP CX
POP AX
POPF
POP BP
RET
STRCATB ENDP
DS:SI,DS:DI作为入口参数，通过堆栈传递
MOV SI,OFFSET STR_LR
MOV DI,OFFSET FNAME_SRC
ADD DI,2
PUSH SI
PUSH DI
CALL STRCATB
ADD SP,4
MOV SI,OFFSET STR_LR
MOV CX,16
MOV BL,COLOR
MOV DH,ROW + 16
MOV DL,COLUMN
CALL SHOWSTR
题6.13编写一个把字符串2插入到字符串1指定位置的远过程。
MEMCOPY和MEMCOPYB分别完成按照递增和递减方式复制内存
MEMCOPY PROC
PUSHF
PUSH CX
PUSH SI
PUSH DI
CLD
TEST SI,1
JZ MEMCOPY_1
MOVSB
DEC CX
MEMCOPY_1:SHR CX,1
REP MOVSW
JNC MEMCOPY_OK
MOVSB
MEMCOPY_OK:POP DI
POP SI
POP CX
POPF
RET
MEMCOPY ENDP
MEMCOPYB PROC
PUSHF
PUSH CX
PUSH SI
PUSH DI
STD
REP MOVSB
MEMCOPYB_OK:POP DI
POP SI
POP CX
POPF
RET
MEMCOPYB ENDP
STRINSERT PROC FAR
PUSH BP
MOV BP,SP
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
MOV BX,[BP+10]
MOV SI,[BP+8]
MOV DI,[BP+6]
CLD
PUSH DS
POP ES
PUSH DI
MOV DI,SI
XOR AL,AL
MOV CX,0FFFFH
REPNZ SCASB
NOT CX
POP DI
CMP BX,CX
JAE STRINSERT_OK
DEC CX
MOV DX,CX
PUSH DI
XOR AL,AL
MOV CX,0FFFFH
REPNZ SCASB
NOT CX
POP DI
CMP BX,DX
JAE STRINSERT_2
PUSH CX
PUSH SI
PUSH DI
ADD SI,DX
MOV DI,SI
DEC CX
ADD DI,CX
MOV CX,DX
INC CX
SUB CX,BX
CALL MEMCOPYB
POP DI
POP SI
POP CX
STRINSERT_1:DEC CX
ADD SI,BX
XCHG SI,DI
CALL MEMCOPY
JMP STRINSERT_OK
STRINSERT_2:ADD SI,BX
XCHG SI,DI
CALL MEMCOPY
STRINSERT_OK:POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
POP BP
RETF
STRINSERT ENDP
BX,DS:SI,DS:DI作为入口参数，通过堆栈传递
MOV SI,OFFSET STR_LR
MOV DI,OFFSET FNAME_SRC
ADD DI,2
MOV BX,2
PUSH BX
PUSH SI
PUSH DI
CALL FAR PTR STRINSERT
ADD SP,6
MOV SI,OFFSET STR_LR
MOV CX,26
MOV BL,COLOR
MOV DH,ROW + 17
MOV DL,COLUMN
CALL SHOWSTR
题6.14编写一个截取字符串某子串的近过程。
STRSUBS PROC
PUSH BP
MOV BP,SP
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
MOV BX,[BP+8]
MOV SI,[BP+6]
MOV DI,[BP+4]
CLD
PUSH DS
POP ES
PUSH DI
MOV DI,SI
XOR AL,AL
MOV CX,0FFFFH
REPNZ SCASB
NOT CX
POP DI
DEC CX
MOV DX,CX
CMP BX,DX
JAE STRSUBS_OK
SUB DX,BX
MOV AX,[BP+10]
CMP DX,AX
JAE STRSUBS_1
MOV AX,DX
STRSUBS_1:MOV CX,AX
JCXZ STRSUBS_OK
ADD SI,BX
CALL MEMCOPY
ADD DI,CX
MOV BYTE PTR ES:[DI],0
STRSUBS_OK:POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
POP BP
RET
STRSUBS ENDP
AX,BX,DS:SI,DS:DI作为入口参数，通过堆栈传递
MOV SI,OFFSET STR_LR
MOV DI,OFFSET STR_SUB
MOV BX,2
MOV AX,13
PUSH AX
PUSH BX
PUSH SI
PUSH DI
CALL STRSUBS
ADD SP,8
MOV SI,OFFSET STR_SUB
MOV CX,15
MOV BL,COLOR
MOV DH,ROW + 18
MOV DL,COLUMN
CALL SHOWSTR
题6.15编写一个去掉字符串前导空格的近过程。编写一个去掉字符串尾部空格的近过程。编写一个去掉字符串前导空格和尾部空格的近过程。
STRCHR查找AL在STR首次出现的位置，STRCHRNZ查找STR中第一个不等于AL的字符所在的位置
STRCHRNZ PROC
PUSHF
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
MOV DX,SI
MOV BL,AL
CLD
TEST SI,1
JZ STRCHRNZ_1
LODSB
AND AL,AL
JZ STRCHRNZ_NOTF
CMP AL,BL
JNZ STRCHRNZ_FIND1
STRCHRNZ_1:LODSW
AND AL,AL
JZ STRCHRNZ_NOTF
CMP AL,BL
JNZ STRCHRNZ_FIND2
AND AH,AH
JZ STRCHRNZ_NOTF
CMP AH,BL
JNZ STRCHRNZ_FIND1
JMP STRCHRNZ_1
STRCHRNZ_NOTF:STC
JMP SHORT STRCHRNZ_OK
STRCHRNZ_FIND1:LEA AX,[SI-1]
SUB AX,DX
JMP SHORT STRCHRNZ_OK
STRCHRNZ_FIND2:LEA AX,[SI-2]
SUB AX,DX
STRCHRNZ_OK:POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POPF
RET
STRCHRNZ ENDP
STRLTRB PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
CLD
PUSH DS
POP ES
PUSH DI
MOV DI,SI
XOR AL,AL
MOV CX,0FFFFH
REPNZ SCASB
NOT CX
POP DI
MOV AL,20H
CALL STRCHRNZ
JC STRLTRB_1
CMP AX,0
JZ STRLTRB_OK
MOV DI,SI
ADD SI,AX
SUB CX,AX
CALL MEMCOPY
JMP STRLTRB_OK
STRLTRB_1:MOV DI,SI
MOV BYTE PTR ES:[DI],0
STRLTRB_OK:POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
STRLTRB ENDP
DS:SI作为入口参数，通过寄存器传递
MOV SI,OFFSET STR_LB
CALL STRLTRB
MOV SI,OFFSET STR_LB
MOV CX,6
MOV BL,COLOR
MOV DH,ROW + 19
MOV DL,COLUMN
CALL SHOWSTR
STRLTRB去掉字符串前导空格，STRRTRB去掉字符串尾部空格
STRRTRB PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
CLD
PUSH DS
POP ES
PUSH DI
MOV DI,SI
XOR AL,AL
MOV CX,0FFFFH
REPNZ SCASB
NOT CX
POP DI
DEC CX
JCXZ STRRTRB_OK
MOV DI,SI
ADD DI,CX
DEC DI
MOV AL,20H
STD
REPZ SCASB
INC DI
CMP BYTE PTR ES:[DI],20H
JZ STRRTRB_1
INC DI
MOV BYTE PTR ES:[DI],0
JMP STRRTRB_OK
STRRTRB_1:MOV DI,SI
MOV BYTE PTR ES:[DI],0
STRRTRB_OK:POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
STRRTRB ENDP
DS:SI作为入口参数，通过寄存器传递
MOV SI,OFFSET STR_RB
CALL STRRTRB
MOV SI,OFFSET STR_RB
MOV CX,6
MOV BL,COLOR
MOV DH,ROW + 19
MOV DL,COLUMN + 18
CALL SHOWSTR
STRLRTRB分别调用STRLTRB和STRRTRB去除字符串前导和尾部空格
STRLRTRB PROC
CALL STRLTRB
CALL STRRTRB
RET
STRLRTRB ENDP
DS:SI作为入口参数，通过寄存器传递
MOV SI,OFFSET STR_LRB
CALL STRLRTRB
MOV SI,OFFSET STR_LRB
MOV CX,11
MOV BL,COLOR
MOV DH,ROW + 19
MOV DL,COLUMN + 38
CALL SHOWSTR
STRTRB去掉字符串全部空格
STRTRB PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
CLD
PUSH DS
POP ES
MOV DI,SI
TEST SI,1
JZ STRTRB_1
LODSB
AND AL,AL
JZ STRTRB_FN
CMP AL,20H
JZ STRTRB_1
STOSB
STRTRB_1:LODSW
AND AL,AL
JZ STRTRB_FN
CMP AL,20H
JZ STRTRB_2
STOSB
STRTRB_2:AND AH,AH
JZ STRTRB_FN
CMP AH,20H
JZ STRTRB_3
MOV AL,AH
STOSB
STRTRB_3:JMP STRTRB_1
STRTRB_FN:MOV BYTE PTR ES:[DI],0
STRTRB_OK:POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
STRTRB ENDP
DS:SI作为入口参数，通过寄存器传递
MOV SI,OFFSET STR_TRB
CALL STRTRB
MOV SI,OFFSET STR_TRB
MOV CX,8
MOV BL,COLOR
MOV DH,ROW + 19
MOV DL,COLUMN + 53
CALL SHOWSTR
STRTRBC去掉字符串全部空格，与STRTRB不同，增加了入口参数CX 字符串的长度 不包括结束标志0
STRTRBC PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
JCXZ STRTRBC_OK
CLD
PUSH DS
POP ES
MOV DI,SI
STRTRBC_1:XCHG SI,DI
MOV AL,20H
REPZ SCASB
XCHG SI,DI
DEC SI
CMP BYTE PTR [SI],20H
JZ STRTRBC_FN
INC CX
STRTRBC_2:CMP BYTE PTR [SI],20H
JZ STRTRBC_1
MOVSB
LOOP STRTRBC_2
STRTRBC_FN:MOV BYTE PTR ES:[DI],0
STRTRBC_OK:POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
STRTRBC ENDP
DS:SI,CX作为入口参数，通过寄存器传递
MOV SI,OFFSET STR_TRBC
MOV CX,15
CALL STRTRBC
MOV SI,OFFSET STR_TRBC
MOV CX,8
MOV BL,COLOR
MOV DH,ROW + 18
MOV DL,COLUMN + 53
CALL SHOWSTR
STRSTRB改写STRSTR
STRSTRB PROC FAR
PUSH BP
MOV BP,SP
PUSHF
PUSH BX
PUSH CX
PUSH SI
PUSH DI
PUSH DS
PUSH ES
LES BX,[BP+10]
CMP BYTE PTR ES:[BX],0
JNZ STRSTRB_1
MOV DX,[BP+8]
MOV AX,[BP+6]
JMP STRSTRB_OK
STRSTRB_1:CLD
LES DI,[BP+6]
PUSH ES
MOV BX,DI
XOR AX,AX
MOV CX,0FFFFH
REPNZ SCASB
NOT CX
MOV DX,CX
LES DI,[BP+10]
PUSH ES
MOV BP,DI
XOR AX,AX
MOV CX,0FFFFH
REPNZ SCASB
NOT CX
DEC CX
POP DS
POP ES
STRSTRB_2:MOV SI,BP
LODSB
MOV DI,BX
XCHG CX,DX
REPNZ SCASB
MOV BX,DI
JNZ STRSTRB_NOTF
CMP CX,DX
JB STRSTRB_NOTF
STRSTRB_4:XCHG CX,DX
MOV AX,CX
DEC CX
REPZ CMPSB
MOV CX,AX
JNZ STRSTRB_2
STRSTRB_FIND:MOV AX,BX
DEC AX
MOV DX,ES
JMP STRSTRB_OK
STRSTRB_NOTF:MOV DX,0
MOV AX,0
STRSTRB_OK:POP ES
POP DS
POP DI
POP SI
POP CX
POP BX
POPF
POP BP
RETF
STRSTRB ENDP
DS:SI,DS:DI作为入口参数，通过堆栈传递，DX,AX作为出口参数，通过寄存器传递
MOV SI,OFFSET STR_FIND
MOV DI,OFFSET FNAME_SRC
ADD DI,2
PUSH DS
PUSH DI
PUSH DS
PUSH SI
CALL FAR PTR STRSTRB
ADD SP,8
PUSH AX
MOV AX,DX
CALL DHTOASC
CALL NEWLINE
POP AX
CALL DHTOASC
CALL NEWLINE
测试通过的完整程序如下
WINTOP = 0
WINLEFT = 0
WINBOTTOM = 24
WINRIGHT = 79
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ALTF1 = 6800H
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
FNAME_SRC DB 128 DUP (0)
MESS_FNSRC DB 'Please input source filename:','$'
STR_HELLO DB 'HELLO',0
DB 26 DUP (0)
STR_FIND DB 'HELLOTEST.TXTABC',0
DB 15 DUP (0)
STR_CP DB 32 DUP (0)
STR_LR DB 'abcdefg',0
DB 24 DUP (0)
STR_SUB DB 32 DUP (0)
STR_LB DB 20H,20H,'hello',0
DB 24 DUP (0)
STR_RB DB 'abcde',20H,20H,0
DB 24 DUP (0)
STR_LRB DB 20H,20H,'hello world',20H,20H,0
DB 16 DUP (0)
STR_TRB DB 20H,20H,'ab cd ef gh',20H,20H,0
DB 16 DUP (0)
STR_TRBC DB 20H,20H,'hi jk lm no',20H,20H,0
DB 16 DUP (0)
res_dx dw 0
res_cx dw 0
res_bx dw 0
res_ax dw 0
num_dx dw 0
num_cx dw 0
num_bx dw 0
num_ax dw 0
val_dx dw 0
val_cx dw 0
val_bx dw 0
val_ax dw 0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL PRINTFILE
MOV AH,4CH
INT 21H
ISFNM PROC
CMP AL,2BH
JB ISFNM_NOFNM
CMP AL,3BH
JA ISFNM_NODEC1
CLC
JMP ISFNM_OK
ISFNM_NODEC1:CMP AL,41H
JB ISFNM_NOFNM
CMP AL,5FH
JA ISFNM_NODEC2
CLC
JMP ISFNM_OK
ISFNM_NODEC2:CMP AL,61H
JB ISFNM_NOFNM
CMP AL,7AH
JA ISFNM_NOFNM
CLC
JMP ISFNM_OK
ISFNM_NOFNM:STC
ISFNM_OK:RET
ISFNM ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRFN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRFN1:CALL GETCH
CMP AL,CR
JZ GETSTRFN5
CMP AL,BACKSPACE
JNZ GETSTRFN4
CMP BX,0
JZ GETSTRFN2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRFN1
GETSTRFN2:CALL BELL
JMP GETSTRFN1
GETSTRFN4:CMP BX,78
JZ GETSTRFN2
CALL ISFNM
JC GETSTRFN2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRFN1
GETSTRFN5:CMP BX,1
JB GETSTRFN2
MOV AL,0
MOV [BX][DI+2],AL
INC BX
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRFN_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRFN ENDP
HTOASC PROC
AND AL,0FH
ADD AL,30H
CMP AL,39H
JA HTOASC_NODEC
JMP HTOASC_OK
HTOASC_NODEC:ADD AL,7
HTOASC_OK:RET
HTOASC ENDP
HTOASCDA PROC
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
RET
HTOASCDA ENDP
AHTOASC PROC
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL HTOASCDA
XCHG AH,AL
CALL HTOASCDA
RET
AHTOASC ENDP
DAHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DAHTOASC ENDP
DHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH AX
XCHG AH,AL
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DHTOASC ENDP
STRLEN PROC
PUSH AX
PUSH DI
PUSH ES
MOV AX,DS
MOV ES,AX
CLD
XOR AL,AL
MOV CX,0FFFFH
STRLEN_S:SCASB
LOOPNZ STRLEN_S
NOT CX
STRLEN_OK:POP ES
POP DI
POP AX
RET
STRLEN ENDP
STRCHR PROC
PUSH BX
PUSH DX
PUSH SI
MOV DX,SI
CLD
MOV BL,AL
TEST SI,1
JZ STRCHR1
LODSB
CMP AL,BL
JZ STRCHR3
AND AL,AL
JZ STRCHR2
STRCHR1:LODSW
CMP AL,BL
JZ STRCHR4
AND AL,AL
JZ STRCHR2
CMP AH,BL
JZ STRCHR3
AND AH,AH
JZ STRCHR2
JMP STRCHR1
STRCHR2:STC
JMP SHORT STRCHR5
STRCHR3:LEA AX,[SI-1]
SUB AX,DX
JMP SHORT STRCHR5
STRCHR4:LEA AX,[SI-2]
SUB AX,DX
STRCHR5:POP SI
POP DX
POP BX
RET
STRCHR ENDP
STRCAT PROC
PUSH AX
PUSH CX
PUSH SI
PUSH DI
PUSH ES
CLD
PUSH DS
POP ES
PUSH DI
MOV DI,SI
XOR AL,AL
MOV CX,0FFFFH
REPNZ SCASB
LEA SI,[DI-1]
POP DI
MOV CX,0FFFFH
REPNZ SCASB
NOT CX
SUB DI,CX
XCHG SI,DI
TEST SI,1
JZ STRCAT1
MOVSB
DEC CX
STRCAT1:SHR CX,1
REP MOVSW
JNC STRCAT2
MOVSB
STRCAT2:POP ES
POP DI
POP SI
POP CX
POP AX
RET
STRCAT ENDP
PRINTFILE PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DX,OFFSET MESS_FNSRC
CALL DISPMESS
MOV DI,OFFSET FNAME_SRC
CALL GETSTRFN
ADD DI,2
CALL STRLEN
MOV AX,CX
CALL DHTOASC
CALL NEWLINE
MOV SI,DI
MOV AL,'E'
CALL STRCHR
CALL DHTOASC
CALL NEWLINE
MOV SI,OFFSET STR_HELLO
MOV DI,OFFSET FNAME_SRC
ADD DI,2
CALL STRCAT
MOV CX,13
MOV BL,COLOR
MOV DH,ROW + 6
MOV DL,COLUMN
CALL SHOWSTR
MOV SI,OFFSET STR_FIND
MOV DI,OFFSET FNAME_SRC
ADD DI,2
PUSH DS
PUSH DI
PUSH DS
PUSH SI
CALL FAR PTR STRSTR
ADD SP,8
PUSH AX
MOV AX,DX
CALL DHTOASC
CALL NEWLINE
POP AX
CALL DHTOASC
CALL NEWLINE
MOV SI,OFFSET STR_FIND
MOV DI,OFFSET FNAME_SRC
ADD DI,2
PUSH DS
PUSH DI
PUSH DS
PUSH SI
CALL FAR PTR STRSTRB
ADD SP,8
PUSH AX
MOV AX,DX
CALL DHTOASC
CALL NEWLINE
POP AX
CALL DHTOASC
CALL NEWLINE
MOV SI,AX
MOV CX,9
MOV BL,COLOR
MOV DH,ROW + 9
MOV DL,COLUMN
CALL SHOWSTR
MOV AX,OFFSET FNAME_SRC
ADD AX,2
PUSH AX
MOV AX,OFFSET STR_CP
PUSH AX
CALL STRCOPY
ADD SP,4
MOV SI,AX
MOV CX,9
MOV BL,COLOR
MOV DH,ROW + 12
MOV DL,COLUMN
CALL SHOWSTR
MOV SI,OFFSET STR_LR
PUSH DS
PUSH SI
CALL FAR PTR STRLRTOUR
ADD SP,4
MOV SI,OFFSET STR_LR
MOV CX,9
MOV BL,COLOR
MOV DH,ROW + 13
MOV DL,COLUMN
CALL SHOWSTR
MOV SI,OFFSET STR_LR
PUSH DS
PUSH SI
MOV AH,0
MOV AL,'G'
PUSH AX
CALL STRCHRB
ADD SP,6
CALL DHTOASC
CALL NEWLINE
MOV SI,OFFSET STR_LR
MOV DI,OFFSET FNAME_SRC
ADD DI,2
PUSH SI
PUSH DI
CALL STRCATB
ADD SP,4
MOV SI,OFFSET STR_LR
MOV CX,16
MOV BL,COLOR
MOV DH,ROW + 16
MOV DL,COLUMN
CALL SHOWSTR
MOV SI,OFFSET STR_LR
MOV DI,OFFSET FNAME_SRC
ADD DI,2
MOV BX,2
PUSH BX
PUSH SI
PUSH DI
CALL FAR PTR STRINSERT
ADD SP,6
MOV SI,OFFSET STR_LR
MOV CX,26
MOV BL,COLOR
MOV DH,ROW + 17
MOV DL,COLUMN
CALL SHOWSTR
MOV SI,OFFSET STR_LR
MOV DI,OFFSET STR_SUB
MOV BX,2
MOV AX,13
PUSH AX
PUSH BX
PUSH SI
PUSH DI
CALL STRSUBS
ADD SP,8
MOV SI,OFFSET STR_SUB
MOV CX,15
MOV BL,COLOR
MOV DH,ROW + 18
MOV DL,COLUMN
CALL SHOWSTR
MOV SI,OFFSET STR_LB
CALL STRLTRB
MOV SI,OFFSET STR_LB
MOV CX,6
MOV BL,COLOR
MOV DH,ROW + 19
MOV DL,COLUMN
CALL SHOWSTR
MOV SI,OFFSET STR_RB
CALL STRRTRB
MOV SI,OFFSET STR_RB
MOV CX,6
MOV BL,COLOR
MOV DH,ROW + 19
MOV DL,COLUMN + 18
CALL SHOWSTR
MOV SI,OFFSET STR_LRB
CALL STRLRTRB
MOV SI,OFFSET STR_LRB
MOV CX,11
MOV BL,COLOR
MOV DH,ROW + 19
MOV DL,COLUMN + 38
CALL SHOWSTR
MOV SI,OFFSET STR_TRB
CALL STRTRB
MOV SI,OFFSET STR_TRB
MOV CX,8
MOV BL,COLOR
MOV DH,ROW + 19
MOV DL,COLUMN + 53
CALL SHOWSTR
MOV SI,OFFSET STR_TRBC
MOV CX,15
CALL STRTRBC
MOV SI,OFFSET STR_TRBC
MOV CX,8
MOV BL,COLOR
MOV DH,ROW + 18
MOV DL,COLUMN + 53
CALL SHOWSTR
PRINTFILE_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
PRINTFILE ENDP
SHOWSTR PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
MOV AX,0B800H
MOV ES,AX
MOV AL,80
MUL DH
XOR DH,DH
ADD AX,DX
ADD AX,AX
XCHG AX,BX
MOV AH,AL
JCXZ SHOWSTR_OK
SHOWSTR_S:MOV AL,DS:[SI]
INC SI
MOV ES:[BX],AX
INC BX
INC BX
LOOP SHOWSTR_S
SHOWSTR_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
SHOWSTR ENDP
STRSTR PROC FAR
PUSH BP
MOV BP,SP
PUSH BX
PUSH CX
PUSH SI
PUSH DI
PUSH DS
PUSH ES
LES BX,[BP+10]
CMP BYTE PTR ES:[BX],0
JNZ STRSTR1
MOV DX,[BP+8]
MOV AX,[BP+6]
JMP SHORT STRSTR6
STRSTR1:CLD
LES DI,[BP+6]
PUSH ES
MOV BX,DI
XOR AX,AX
MOV CX,0FFFFH
REPNZ SCASB
NOT CX
MOV DX,CX
LES DI,[BP+10]
PUSH ES
MOV BP,DI
XOR AX,AX
MOV CX,0FFFFH
REPNZ SCASB
NOT CX
DEC CX
POP DS
POP ES
STRSTR2:MOV SI,BP
LODSB
MOV DI,BX
XCHG CX,DX
REPNZ SCASB
MOV BX,DI
JNZ STRSTR3
CMP CX,DX
JNB STRSTR4
STRSTR3:XOR BX,BX
MOV ES,BX
MOV BX,1
JMP SHORT STRSTR5
STRSTR4:XCHG CX,DX
MOV AX,CX
DEC CX
REPZ CMPSB
MOV CX,AX
JNZ STRSTR2
STRSTR5:MOV AX,BX
DEC AX
MOV DX,ES
STRSTR6:POP ES
POP DS
POP DI
POP SI
POP CX
POP BX
POP BP
RETF
STRSTR ENDP
MEMCOPY PROC
PUSHF
PUSH CX
PUSH SI
PUSH DI
CLD
TEST SI,1
JZ MEMCOPY_1
MOVSB
DEC CX
MEMCOPY_1:SHR CX,1
REP MOVSW
JNC MEMCOPY_OK
MOVSB
MEMCOPY_OK:POP DI
POP SI
POP CX
POPF
RET
MEMCOPY ENDP
MEMCOPYB PROC
PUSHF
PUSH CX
PUSH SI
PUSH DI
STD
REP MOVSB
MEMCOPYB_OK:POP DI
POP SI
POP CX
POPF
RET
MEMCOPYB ENDP
STRCOPY PROC
PUSH BP
MOV BP,SP
PUSHF
PUSH AX
PUSH CX
PUSH SI
PUSH DI
PUSH ES
MOV SI,[BP+6]
MOV DI,[BP+4]
CLD
PUSH DS
POP ES
PUSH DI
MOV DI,SI
XOR AL,AL
MOV CX,0FFFFH
REPNZ SCASB
NOT CX
POP DI
CALL MEMCOPY
STRCOPY_OK:POP ES
POP DI
POP SI
POP CX
POP AX
POPF
POP BP
RET
STRCOPY ENDP
ISLOWER PROC
CMP AL,'a'
JB ISLOWER_NOLOWER
CMP AL,'z'
JA ISLOWER_NOLOWER
CLC
JMP ISLOWER_OK
ISLOWER_NOLOWER:STC
ISLOWER_OK:RET
ISLOWER ENDP
STRLRTOUR PROC FAR
PUSH BP
MOV BP,SP
PUSHF
PUSH SI
PUSH DS
MOV DS,[BP+8]
MOV SI,[BP+6]
CLD
TEST SI,1
JZ STRLRTOUR_1
LODSB
AND AL,AL
JZ STRLRTOUR_OK
CALL ISLOWER
JC STRLRTOUR_1
SUB AL,20H
MOV DS:[SI-1],AL
STRLRTOUR_1:LODSW
AND AL,AL
JZ STRLRTOUR_OK
CALL ISLOWER
JC STRLRTOUR_2
SUB AL,20H
MOV DS:[SI-2],AL
STRLRTOUR_2:AND AH,AH
JZ STRLRTOUR_OK
MOV AL,AH
CALL ISLOWER
JC STRLRTOUR_3
SUB AL,20H
MOV DS:[SI-1],AL
STRLRTOUR_3:JMP STRLRTOUR_1
STRLRTOUR_OK:POP DS
POP SI
POPF
POP BP
RETF
STRLRTOUR ENDP
STRCHRB PROC
PUSH BP
MOV BP,SP
PUSHF
PUSH BX
PUSH DX
PUSH SI
PUSH DS
MOV DS,[BP+8]
MOV SI,[BP+6]
MOV AX,[BP+4]
MOV DX,SI
MOV BL,AL
CLD
TEST SI,1
JZ STRCHRB_1
LODSB
AND AL,AL
JZ STRCHRB_NOTF
CMP AL,BL
JZ STRCHRB_FIND1
STRCHRB_1:LODSW
AND AL,AL
JZ STRCHRB_NOTF
CMP AL,BL
JZ STRCHRB_FIND2
AND AH,AH
JZ STRCHRB_NOTF
CMP AH,BL
JZ STRCHRB_FIND1
JMP STRCHRB_1
STRCHRB_NOTF:STC
JMP SHORT STRCHRB_OK
STRCHRB_FIND1:LEA AX,[SI-1]
SUB AX,DX
JMP SHORT STRCHRB_OK
STRCHRB_FIND2:LEA AX,[SI-2]
SUB AX,DX
STRCHRB_OK:POP DS
POP SI
POP DX
POP BX
POPF
POP BP
RET
STRCHRB ENDP
STRCATB PROC
PUSH BP
MOV BP,SP
PUSHF
PUSH AX
PUSH CX
PUSH SI
PUSH DI
PUSH ES
MOV SI,[BP+6]
MOV DI,[BP+4]
CLD
PUSH DS
POP ES
PUSH DI
MOV DI,SI
XOR AL,AL
MOV CX,0FFFFH
REPNZ SCASB
LEA SI,[DI-1]
POP DI
PUSH DI
XOR AL,AL
MOV CX,0FFFFH
REPNZ SCASB
NOT CX
POP DI
XCHG SI,DI
CALL MEMCOPY
STRCATB_OK:POP ES
POP DI
POP SI
POP CX
POP AX
POPF
POP BP
RET
STRCATB ENDP
STRINSERT PROC FAR
PUSH BP
MOV BP,SP
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
MOV BX,[BP+10]
MOV SI,[BP+8]
MOV DI,[BP+6]
CLD
PUSH DS
POP ES
PUSH DI
MOV DI,SI
XOR AL,AL
MOV CX,0FFFFH
REPNZ SCASB
NOT CX
POP DI
CMP BX,CX
JAE STRINSERT_OK
DEC CX
MOV DX,CX
PUSH DI
XOR AL,AL
MOV CX,0FFFFH
REPNZ SCASB
NOT CX
POP DI
CMP BX,DX
JAE STRINSERT_2
PUSH CX
PUSH SI
PUSH DI
ADD SI,DX
MOV DI,SI
DEC CX
ADD DI,CX
MOV CX,DX
INC CX
SUB CX,BX
CALL MEMCOPYB
POP DI
POP SI
POP CX
STRINSERT_1:DEC CX
ADD SI,BX
XCHG SI,DI
CALL MEMCOPY
JMP STRINSERT_OK
STRINSERT_2:ADD SI,BX
XCHG SI,DI
CALL MEMCOPY
STRINSERT_OK:POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
POP BP
RETF
STRINSERT ENDP
STRSUBS PROC
PUSH BP
MOV BP,SP
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
MOV BX,[BP+8]
MOV SI,[BP+6]
MOV DI,[BP+4]
CLD
PUSH DS
POP ES
PUSH DI
MOV DI,SI
XOR AL,AL
MOV CX,0FFFFH
REPNZ SCASB
NOT CX
POP DI
DEC CX
MOV DX,CX
CMP BX,DX
JAE STRSUBS_OK
SUB DX,BX
MOV AX,[BP+10]
CMP DX,AX
JAE STRSUBS_1
MOV AX,DX
STRSUBS_1:MOV CX,AX
JCXZ STRSUBS_OK
ADD SI,BX
CALL MEMCOPY
ADD DI,CX
MOV BYTE PTR ES:[DI],0
STRSUBS_OK:POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
POP BP
RET
STRSUBS ENDP
STRCHRNZ PROC
PUSHF
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
MOV DX,SI
MOV BL,AL
CLD
TEST SI,1
JZ STRCHRNZ_1
LODSB
AND AL,AL
JZ STRCHRNZ_NOTF
CMP AL,BL
JNZ STRCHRNZ_FIND1
STRCHRNZ_1:LODSW
AND AL,AL
JZ STRCHRNZ_NOTF
CMP AL,BL
JNZ STRCHRNZ_FIND2
AND AH,AH
JZ STRCHRNZ_NOTF
CMP AH,BL
JNZ STRCHRNZ_FIND1
JMP STRCHRNZ_1
STRCHRNZ_NOTF:STC
JMP SHORT STRCHRNZ_OK
STRCHRNZ_FIND1:LEA AX,[SI-1]
SUB AX,DX
JMP SHORT STRCHRNZ_OK
STRCHRNZ_FIND2:LEA AX,[SI-2]
SUB AX,DX
STRCHRNZ_OK:POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POPF
RET
STRCHRNZ ENDP
STRLTRB PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
CLD
PUSH DS
POP ES
PUSH DI
MOV DI,SI
XOR AL,AL
MOV CX,0FFFFH
REPNZ SCASB
NOT CX
POP DI
MOV AL,20H
CALL STRCHRNZ
JC STRLTRB_1
CMP AX,0
JZ STRLTRB_OK
MOV DI,SI
ADD SI,AX
SUB CX,AX
CALL MEMCOPY
JMP STRLTRB_OK
STRLTRB_1:MOV DI,SI
MOV BYTE PTR ES:[DI],0
STRLTRB_OK:POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
STRLTRB ENDP
STRRTRB PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
CLD
PUSH DS
POP ES
PUSH DI
MOV DI,SI
XOR AL,AL
MOV CX,0FFFFH
REPNZ SCASB
NOT CX
POP DI
DEC CX
JCXZ STRRTRB_OK
MOV DI,SI
ADD DI,CX
DEC DI
MOV AL,20H
STD
REPZ SCASB
INC DI
CMP BYTE PTR ES:[DI],20H
JZ STRRTRB_1
INC DI
MOV BYTE PTR ES:[DI],0
JMP STRRTRB_OK
STRRTRB_1:MOV DI,SI
MOV BYTE PTR ES:[DI],0
STRRTRB_OK:POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
STRRTRB ENDP
STRLRTRB PROC
CALL STRLTRB
CALL STRRTRB
RET
STRLRTRB ENDP
STRTRB PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
CLD
PUSH DS
POP ES
MOV DI,SI
TEST SI,1
JZ STRTRB_1
LODSB
AND AL,AL
JZ STRTRB_FN
CMP AL,20H
JZ STRTRB_1
STOSB
STRTRB_1:LODSW
AND AL,AL
JZ STRTRB_FN
CMP AL,20H
JZ STRTRB_2
STOSB
STRTRB_2:AND AH,AH
JZ STRTRB_FN
CMP AH,20H
JZ STRTRB_3
MOV AL,AH
STOSB
STRTRB_3:JMP STRTRB_1
STRTRB_FN:MOV BYTE PTR ES:[DI],0
STRTRB_OK:POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
STRTRB ENDP
STRTRBC PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
JCXZ STRTRBC_OK
CLD
PUSH DS
POP ES
MOV DI,SI
STRTRBC_1:XCHG SI,DI
MOV AL,20H
REPZ SCASB
XCHG SI,DI
DEC SI
CMP BYTE PTR [SI],20H
JZ STRTRBC_FN
INC CX
STRTRBC_2:CMP BYTE PTR [SI],20H
JZ STRTRBC_1
MOVSB
LOOP STRTRBC_2
STRTRBC_FN:MOV BYTE PTR ES:[DI],0
STRTRBC_OK:POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
STRTRBC ENDP
STRSTRB PROC FAR
PUSH BP
MOV BP,SP
PUSHF
PUSH BX
PUSH CX
PUSH SI
PUSH DI
PUSH DS
PUSH ES
LES BX,[BP+10]
CMP BYTE PTR ES:[BX],0
JNZ STRSTRB_1
MOV DX,[BP+8]
MOV AX,[BP+6]
JMP STRSTRB_OK
STRSTRB_1:CLD
LES DI,[BP+6]
PUSH ES
MOV BX,DI
XOR AX,AX
MOV CX,0FFFFH
REPNZ SCASB
NOT CX
MOV DX,CX
LES DI,[BP+10]
PUSH ES
MOV BP,DI
XOR AX,AX
MOV CX,0FFFFH
REPNZ SCASB
NOT CX
DEC CX
POP DS
POP ES
STRSTRB_2:MOV SI,BP
LODSB
MOV DI,BX
XCHG CX,DX
REPNZ SCASB
MOV BX,DI
JNZ STRSTRB_NOTF
CMP CX,DX
JB STRSTRB_NOTF
STRSTRB_4:XCHG CX,DX
MOV AX,CX
DEC CX
REPZ CMPSB
MOV CX,AX
JNZ STRSTRB_2
STRSTRB_FIND:MOV AX,BX
DEC AX
MOV DX,ES
JMP STRSTRB_OK
STRSTRB_NOTF:MOV DX,0
MOV AX,0
STRSTRB_OK:POP ES
POP DS
POP DI
POP SI
POP CX
POP BX
POPF
POP BP
RETF
STRSTRB ENDP
CSEG ENDS
END START
题6.16利用字符串操作指令写一个清屏的过程。只考虑字符显示方式。
CLEARSCREENB PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
MOV AX,0B800H
MOV ES,AX
MOV DI,0
MOV AH,COLOR
MOV AL,20H
CLD
MOV CX,2000
REP STOSW
CLEARSCREENB_OK:POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
CLEARSCREENB ENDP
测试通过的完整程序如下
WINTOP = 0
WINLEFT = 0
WINBOTTOM = 24
WINRIGHT = 79
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
res_dx dw 0
res_cx dw 0
res_bx dw 0
res_ax dw 0
num_dx dw 0
num_cx dw 0
num_bx dw 0
num_ax dw 0
val_dx dw 0
val_cx dw 0
val_bx dw 0
val_ax dw 0
prev_dx dw 0
prev_cx dw 0
prev_bx dw 0
prev_ax dw 0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL CLEARSCREENB
MOV AH,4CH
INT 21H
CLEARSCREEN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AL,DPAGE
MOV AH,5
INT 10H
MOV CH,WINTOP
MOV CL,WINLEFT
MOV DH,WINBOTTOM
MOV DL,WINRIGHT
MOV BH,COLOR
MOV AL,0
MOV AH,6
INT 10H
MOV BH,DPAGE
MOV DH,WINTOP
MOV DL,WINLEFT
MOV AH,2
INT 10H
CLEARSCREEN_OK:POP DX
POP CX
POP BX
POP AX
RET
CLEARSCREEN ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
CLEARSCREENB PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
MOV AX,0B800H
MOV ES,AX
MOV DI,0
MOV AH,COLOR
MOV AL,20H
CLD
MOV CX,2000
REP STOSW
CLEARSCREENB_OK:POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
CLEARSCREENB ENDP
CSEG ENDS
END START
题6.17十进制数算术运算调整指令有何用途？它们调整的主要依据是什么？
方便进行十进制数的算术运算，通过调整以8421BCD码表示的十进制数，就能得到运算结果，不需要转换成二进制数进行算术运算。
压缩的8421BCD码加法调整指令DAA
AL的低4位在A~F之间，或AF为1，则AL的低4位加6，AF位置1（表示产生进位）
AL的高4位在A~F之间，或CF为1，则AL的高4位加6，CF位置1（表示产生进位）
压缩的8421BCD码减法调整指令DAS
AL的低4位在A~F之间，或AF为1，则AL的低4位减6，AF位置1（表示产生借位）
AL的高4位在A~F之间，或CF为1，则AL的高4位减6，CF位置1（表示产生借位）
非压缩的8421BCD码加法调整指令AAA
AL的低4位在0~9之间，且AF为0，则AL中的高4位为0，CF位为0
AL的低4位在A~F之间，或AF为1，则AL的低4位加6，AL中的高4位为0，AF位置1，CF位置1（表示产生进位）
非压缩的8421BCD码减法调整指令AAS
AL的低4位在0~9之间，且AF为0，则AL中的高4位为0，CF位为0
AL的低4位在A~F之间，或AF为1，则AL的低4位减6，AL中的高4位为0，AF位置1，CF位置1（表示产生借位）
非压缩的8421BCD码乘法调整指令AAM
把AL中的值除以10，商放在AH中，余数放在AL中
非压缩的8421BCD码除法调整指令AAD
AL和AH的高四位应为0
AL=AH*10+(AL)
AH=0
题6.18请编写一个小型的可实现整数四则运算的实用程序。
WINTOP = 0
WINLEFT = 0
WINBOTTOM = 24
WINRIGHT = 79
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ALTF1 = 6800H
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
STR_NUM1 DB 32 DUP (0)
STR_NUM2 DB 32 DUP (0)
STR_RESULT DB 32 DUP (0)
STR_REMAIN DB 32 DUP (0)
STR_CHOICE DB 32 DUP (0)
NUM_BP DW 0
NUM_DI DW 0
NUM_SI DW 0
NUM_DX DW 0
NUM_CX DW 0
NUM_BX DW 0
NUM_AX DW 0
MESS_CHOICE DB 'Please input arithmetic choice[0 ADD,1 SUB,2 MUL,3 DIV]:','$'
MESS_NUM1 DB 'Please input number1:','$'
MESS_NUM2 DB 'Please input number2:','$'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESS_NUM1
CALL DISPMESS
MOV DI,OFFSET STR_NUM1
CALL GETSTRD
MOV DX,OFFSET MESS_NUM2
CALL DISPMESS
MOV DI,OFFSET STR_NUM2
CALL GETSTRD
MOV DX,OFFSET MESS_CHOICE
CALL DISPMESS
MOV DI,OFFSET STR_CHOICE
CALL GETSTRF
MOV SI,OFFSET STR_CHOICE
ADD SI,2
MOV AL,DS:[SI]
CMP AL,'0'
JZ CHOICE_ADD
CMP AL,'1'
JZ CHOICE_SUB
CMP AL,'2'
JZ CHOICE_MUL
CMP AL,'3'
JZ CHOICE_DIV
JMP CHOICE_OK
CHOICE_ADD:CALL ADDITION
JMP CHOICE_OK
CHOICE_SUB:CALL SUBTRACT
JMP CHOICE_OK
CHOICE_MUL:CALL MULTIPLI
JMP CHOICE_OK
CHOICE_DIV:CALL DIVIDE
CHOICE_OK:MOV AH,4CH
INT 21H
ISDEC PROC
CMP AL,'0'
JB ISDEC_NODEC
CMP AL,'9'
JA ISDEC_NODEC
CLC
JMP ISDEC_OK
ISDEC_NODEC:STC
ISDEC_OK:RET
ISDEC ENDP
ISFMT PROC
CMP AL,'0'
JB ISFMT_NOFMT
CMP AL,'3'
JA ISFMT_NOFMT
CLC
JMP ISFMT_OK
ISFMT_NOFMT:STC
ISFMT_OK:RET
ISFMT ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRD PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRD1:CALL GETCH
CMP AL,CR
JZ GETSTRD5
CMP AL,BACKSPACE
JNZ GETSTRD4
CMP BX,0
JZ GETSTRD2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRD1
GETSTRD2:CALL BELL
JMP GETSTRD1
GETSTRD4:CMP BX,10
JZ GETSTRD2
CALL ISDEC
JC GETSTRD2
CMP BX,1
JNZ GETSTRDN
CMP BYTE PTR [DI+2],'0'
JNZ GETSTRDN
JMP GETSTRD2
GETSTRDN:MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRD1
GETSTRD5:CMP BX,1
JB GETSTRD2
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRD_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRD ENDP
GETSTRF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRF1:CALL GETCH
CMP AL,CR
JZ GETSTRF5
CMP AL,BACKSPACE
JNZ GETSTRF4
CMP BX,0
JZ GETSTRF2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRF1
GETSTRF2:CALL BELL
JMP GETSTRF1
GETSTRF4:CMP BX,1
JZ GETSTRF2
CALL ISFMT
JC GETSTRF2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRF1
GETSTRF5:CMP BX,1
JB GETSTRF2
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRF_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRF ENDP
ADDITION PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV CX,WORD PTR STR_NUM1
CMP CX,WORD PTR STR_NUM2
JBE ADDITION_1
MOV CX,WORD PTR STR_NUM2
MOV DX,WORD PTR STR_NUM1
SUB CX,2
SUB DX,2
MOV SI,OFFSET STR_NUM2
MOV DI,OFFSET STR_NUM1
ADD SI,2
ADD DI,2
ADD SI,CX
ADD DI,DX
DEC SI
DEC DI
JMP ADDITION_2
ADDITION_1:MOV DX,WORD PTR STR_NUM2
SUB CX,2
SUB DX,2
MOV SI,OFFSET STR_NUM1
MOV DI,OFFSET STR_NUM2
ADD SI,2
ADD DI,2
ADD SI,CX
ADD DI,DX
DEC SI
DEC DI
ADDITION_2:CLC
PUSHF
MOV BP,0
ADDITION_FORI1:CMP BP,CX
JAE ADDITION_FORI2
MOV AH,0
MOV AL,DS:[SI]
POPF
ADC AL,DS:[DI]
AAA
PUSHF
MOV BYTE PTR DS:STR_RESULT[BP],AL
ADDITION_NEXTI1:INC BP
DEC SI
DEC DI
JMP ADDITION_FORI1
ADDITION_FORI2:CMP BP,DX
JAE ADDITION_FINISHI
MOV AH,0
MOV AL,DS:[DI]
POPF
ADC AL,0
AAA
PUSHF
MOV BYTE PTR DS:STR_RESULT[BP],AL
ADDITION_NEXTI2:INC BP
DEC DI
JMP ADDITION_FORI2
ADDITION_FINISHI:POPF
JNC ADDITION_DISPLAY
MOV AL,1
MOV BYTE PTR DS:STR_RESULT[BP],AL
INC BP
ADDITION_DISPLAY:MOV CX,BP
JCXZ ADDITION_OK
DEC BP
ADDITION_S1:MOV AL,BYTE PTR DS:STR_RESULT[BP]
ADD AL,30H
CALL PUTCH
DEC BP
LOOP ADDITION_S1
ADDITION_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
ADDITION ENDP
CMPSTRNUM PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV CX,WORD PTR STR_NUM1
CMP CX,WORD PTR STR_NUM2
JB CMPSTRNUM_OK
JA CMPSTRNUM_OK
SUB CX,2
MOV SI,OFFSET STR_NUM1
MOV DI,OFFSET STR_NUM2
ADD SI,2
ADD DI,2
CMPSTRNUM_S1:MOV AL,DS:[SI]
MOV AH,DS:[DI]
AND AL,0FH
AND AH,0FH
CMP AL,AH
JB CMPSTRNUM_OK
JA CMPSTRNUM_OK
INC SI
INC DI
LOOP CMPSTRNUM_S1
CMP AX,AX
CMPSTRNUM_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
CMPSTRNUM ENDP
SUBTRACT PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CALL CMPSTRNUM
JB SUBTRACT_B
JA SUBTRACT_A
MOV AL,'0'
CALL PUTCH
JMP SUBTRACT_OK
SUBTRACT_B:MOV AL,'-'
CALL PUTCH
MOV CX,WORD PTR STR_NUM1
MOV DX,WORD PTR STR_NUM2
SUB CX,2
SUB DX,2
MOV SI,OFFSET STR_NUM1
MOV DI,OFFSET STR_NUM2
ADD SI,2
ADD DI,2
ADD SI,CX
ADD DI,DX
DEC SI
DEC DI
JMP SUBTRACT_1
SUBTRACT_A:MOV CX,WORD PTR STR_NUM2
MOV DX,WORD PTR STR_NUM1
SUB CX,2
SUB DX,2
MOV SI,OFFSET STR_NUM2
MOV DI,OFFSET STR_NUM1
ADD SI,2
ADD DI,2
ADD SI,CX
ADD DI,DX
DEC SI
DEC DI
SUBTRACT_1:CLC
PUSHF
MOV BP,0
SUBTRACT_FORI1:CMP BP,CX
JAE SUBTRACT_FORI2
MOV AH,0
MOV AL,DS:[DI]
POPF
SBB AL,DS:[SI]
AAS
PUSHF
MOV BYTE PTR DS:STR_RESULT[BP],AL
SUBTRACT_NEXTI1:INC BP
DEC SI
DEC DI
JMP SUBTRACT_FORI1
SUBTRACT_FORI2:CMP BP,DX
JAE SUBTRACT_FINISHI
MOV AH,0
MOV AL,DS:[DI]
POPF
SBB AL,0
AAS
PUSHF
MOV BYTE PTR DS:STR_RESULT[BP],AL
SUBTRACT_NEXTI2:INC BP
DEC DI
JMP SUBTRACT_FORI2
SUBTRACT_FINISHI:POPF
SUBTRACT_DISPLAY:MOV CX,BP
JCXZ SUBTRACT_OK
DEC BP
SUBTRACT_S1:MOV AL,BYTE PTR DS:STR_RESULT[BP]
AND AL,0FH
CMP AL,0
JNZ SUBTRACT_S2
DEC BP
LOOP SUBTRACT_S1
SUBTRACT_S2:MOV AL,BYTE PTR DS:STR_RESULT[BP]
ADD AL,30H
CALL PUTCH
DEC BP
LOOP SUBTRACT_S2
SUBTRACT_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
SUBTRACT ENDP
ADJUSTRESULT PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV CX,WORD PTR STR_NUM1
MOV DX,WORD PTR STR_NUM2
SUB CX,2
SUB DX,2
ADD CX,DX
ADD BX,DI
MOV DL,BYTE PTR DS:STR_RESULT[BX]
MOV DH,BYTE PTR DS:STR_RESULT[BX+1]
MOV WORD PTR NUM_AX,AX
MOV AH,0
ADD AL,DL
AAA
MOV BYTE PTR DS:STR_RESULT[BX],AL
MOV AH,0
MOV AL,BYTE PTR NUM_AX[1]
ADC AL,DH
AAA
PUSHF
MOV BYTE PTR DS:STR_RESULT[BX+1],AL
ADD BX,2
ADJUSTRESULT_FORI1:CMP BX,CX
JAE ADJUSTRESULT_FINISHI
MOV AH,0
MOV AL,BYTE PTR DS:STR_RESULT[BX]
POPF
ADC AL,0
AAA
PUSHF
MOV BYTE PTR DS:STR_RESULT[BX],AL
ADJUSTRESULT_NEXTI1:INC BX
JMP ADJUSTRESULT_FORI1
ADJUSTRESULT_FINISHI:POPF
ADJUSTRESULT_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
ADJUSTRESULT ENDP
DISPLAYRESULT PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV CX,WORD PTR STR_NUM1
MOV DX,WORD PTR STR_NUM2
SUB CX,2
SUB DX,2
ADD CX,DX
MOV BX,CX
DEC BX
DISPLAYRESULT_S1:MOV AL,BYTE PTR DS:STR_RESULT[BX]
AND AL,0FH
CMP AL,0
JNZ DISPLAYRESULT_S2
DEC BX
LOOP DISPLAYRESULT_S1
DISPLAYRESULT_S2:MOV AL,BYTE PTR DS:STR_RESULT[BX]
ADD AL,30H
CALL PUTCH
DEC BX
LOOP DISPLAYRESULT_S2
DISPLAYRESULT_OK:POP DX
POP CX
POP BX
POP AX
RET
DISPLAYRESULT ENDP
MULTIPLI PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV CX,WORD PTR STR_NUM1
MOV DX,WORD PTR STR_NUM2
SUB CX,2
SUB DX,2
MOV SI,OFFSET STR_NUM1
MOV BP,OFFSET STR_NUM2
ADD SI,2
ADD BP,2
CMP CX,1
JNZ MULTIPLI_N1
CMP BYTE PTR DS:[SI],'0'
JNZ MULTIPLI_N1
MOV AL,'0'
CALL PUTCH
JMP MULTIPLI_OK
MULTIPLI_N1:CMP DX,1
JNZ MULTIPLI_N2
CMP BYTE PTR DS:[BP],'0'
JNZ MULTIPLI_N2
MOV AL,'0'
CALL PUTCH
JMP MULTIPLI_OK
MULTIPLI_N2:ADD SI,CX
ADD BP,DX
DEC SI
DEC BP
MOV WORD PTR NUM_SI,SI
MOV WORD PTR NUM_BP,BP
MOV BX,0
MULTIPLI_FORI1:CMP BX,CX
JAE MULTIPLI_FINISHI
MOV DI,0
MOV BP,WORD PTR NUM_BP
MULTIPLI_FORJ1:CMP DI,DX
JAE MULTIPLI_NEXTI1
MOV AL,BYTE PTR DS:[SI]
MOV AH,BYTE PTR DS:[BP]
AND AL,0FH
AND AH,0FH
MUL AH
AAM
CALL ADJUSTRESULT
MULTIPLI_NEXTJ1:INC DI
DEC BP
JMP MULTIPLI_FORJ1
MULTIPLI_NEXTI1:INC BX
DEC SI
JMP MULTIPLI_FORI1
MULTIPLI_FINISHI:CALL DISPLAYRESULT
MULTIPLI_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
MULTIPLI ENDP
CMPREMAIN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV CX,WORD PTR STR_REMAIN
MOV DX,WORD PTR STR_NUM2
SUB DX,2
CMP CX,DX
JB CMPREMAIN_OK
JA CMPREMAIN_OK
MOV SI,OFFSET STR_REMAIN
MOV DI,OFFSET STR_NUM2
ADD SI,2
ADD DI,2
CMPREMAIN_S1:MOV AL,DS:[SI]
MOV AH,DS:[DI]
AND AL,0FH
AND AH,0FH
CMP AL,AH
JB CMPREMAIN_OK
JA CMPREMAIN_OK
INC SI
INC DI
LOOP CMPREMAIN_S1
CMP AX,AX
CMPREMAIN_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
CMPREMAIN ENDP
ADJUSTREMAIN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV CX,WORD PTR STR_REMAIN
JCXZ ADJUSTREMAIN_OK
MOV SI,OFFSET STR_REMAIN
MOV DI,OFFSET STR_REMAIN
ADD SI,2
ADD DI,2
MOV DX,0
MOV BP,0
ADJUSTREMAIN_FORI1:CMP BP,CX
JAE ADJUSTREMAIN_FINISHI
MOV AL,DS:[SI]
AND AL,0FH
CMP AL,0
JNZ ADJUSTREMAIN_FORI2
ADJUSTREMAIN_NEXTI1:INC BP
INC SI
JMP ADJUSTREMAIN_FORI1
ADJUSTREMAIN_FORI2:CMP BP,CX
JAE ADJUSTREMAIN_FINISHI
MOV AL,DS:[SI]
AND AL,0FH
MOV DS:[DI],AL
INC DI
INC DX
ADJUSTREMAIN_NEXTI2:INC BP
INC SI
JMP ADJUSTREMAIN_FORI2
ADJUSTREMAIN_FINISHI:MOV WORD PTR STR_REMAIN,DX
ADJUSTREMAIN_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
ADJUSTREMAIN ENDP
SUBREMAIN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CALL CMPREMAIN
JB SUBREMAIN_OK
JA SUBREMAIN_A
MOV WORD PTR STR_REMAIN,0
JMP SUBREMAIN_OK
SUBREMAIN_A:MOV DX,WORD PTR STR_REMAIN
MOV CX,WORD PTR STR_NUM2
SUB CX,2
MOV SI,OFFSET STR_NUM2
MOV DI,OFFSET STR_REMAIN
ADD SI,2
ADD DI,2
ADD SI,CX
ADD DI,DX
DEC SI
DEC DI
SUBREMAIN_1:CLC
PUSHF
MOV BP,0
SUBREMAIN_FORI1:CMP BP,CX
JAE SUBREMAIN_FORI2
MOV AH,0
MOV AL,DS:[DI]
POPF
SBB AL,DS:[SI]
AAS
PUSHF
MOV BYTE PTR DS:[DI],AL
SUBREMAIN_NEXTI1:INC BP
DEC SI
DEC DI
JMP SUBREMAIN_FORI1
SUBREMAIN_FORI2:CMP BP,DX
JAE SUBREMAIN_FINISHI
MOV AH,0
MOV AL,DS:[DI]
POPF
SBB AL,0
AAS
PUSHF
MOV BYTE PTR DS:[DI],AL
SUBREMAIN_NEXTI2:INC BP
DEC DI
JMP SUBREMAIN_FORI2
SUBREMAIN_FINISHI:POPF
CALL ADJUSTREMAIN
SUBREMAIN_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
SUBREMAIN ENDP
DIVREMAIN PROC
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CALL CMPREMAIN
JB DIVREMAIN_OK
JA DIVREMAIN_A
MOV AX,1
MOV WORD PTR STR_REMAIN,0
JMP DIVREMAIN_OK
DIVREMAIN_A:MOV AX,0
DIVREMAIN_1:CALL SUBREMAIN
INC AX
CALL CMPREMAIN
JB DIVREMAIN_OK
JMP DIVREMAIN_1
DIVREMAIN_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
RET
DIVREMAIN ENDP
DIVIDE PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV CX,WORD PTR STR_NUM1
MOV DX,WORD PTR STR_NUM2
SUB CX,2
SUB DX,2
MOV SI,OFFSET STR_NUM1
MOV DI,OFFSET STR_NUM2
ADD SI,2
ADD DI,2
CMP DX,1
JNZ DIVIDE_N1
CMP BYTE PTR DS:[DI],'0'
JNZ DIVIDE_N1
JMP DIVIDE_OK
DIVIDE_N1:CMP CX,1
JNZ DIVIDE_N2
CMP BYTE PTR DS:[SI],'0'
JNZ DIVIDE_N2
MOV AL,'0'
CALL PUTCH
MOV AL,','
CALL PUTCH
MOV AL,'0'
CALL PUTCH
JMP DIVIDE_OK
DIVIDE_N2:CALL CMPSTRNUM
JB DIVIDE_B
JA DIVIDE_A
MOV AL,'1'
CALL PUTCH
MOV AL,','
CALL PUTCH
MOV AL,'0'
CALL PUTCH
JMP DIVIDE_OK
DIVIDE_B:MOV AL,'0'
CALL PUTCH
MOV AL,','
CALL PUTCH
MOV CX,WORD PTR STR_NUM1
SUB CX,2
MOV SI,OFFSET STR_NUM1
ADD SI,2
DIVIDE_B_S1:MOV AL,DS:[SI]
CALL PUTCH
INC SI
LOOP DIVIDE_B_S1
JMP DIVIDE_OK
DIVIDE_A:MOV CX,WORD PTR STR_NUM1
SUB CX,2
MOV SI,OFFSET STR_NUM1
ADD SI,2
MOV DI,OFFSET STR_REMAIN
ADD DI,2
MOV BX,0
MOV BP,0
MOV WORD PTR STR_REMAIN,0
DIVIDE_FORI1:CMP BX,CX
JAE DIVIDE_FINISHI
MOV AL,DS:[BX][SI]
MOV DX,BX
MOV BX,WORD PTR STR_REMAIN
AND AL,0FH
MOV DS:[BX][DI],AL
INC WORD PTR STR_REMAIN
MOV BX,DX
CALL ADJUSTREMAIN
CALL CMPREMAIN
JB DIVIDE_FORI1_B
JA DIVIDE_FORI1_A
MOV AL,1
MOV WORD PTR STR_REMAIN,0
MOV BYTE PTR DS:STR_RESULT[BP],AL
INC BP
JMP DIVIDE_NEXTI1
DIVIDE_FORI1_B:MOV AL,0
MOV BYTE PTR DS:STR_RESULT[BP],AL
INC BP
JMP DIVIDE_NEXTI1
DIVIDE_FORI1_A:CALL DIVREMAIN
MOV BYTE PTR DS:STR_RESULT[BP],AL
INC BP
DIVIDE_NEXTI1:INC BX
JMP DIVIDE_FORI1
DIVIDE_FINISHI:MOV CX,BP
MOV BX,0
DIVIDE_DISPLAY_S1:MOV AL,BYTE PTR DS:STR_RESULT[BX]
AND AL,0FH
CMP AL,0
JNZ DIVIDE_DISPLAY_S2
INC BX
LOOP DIVIDE_DISPLAY_S1
DIVIDE_DISPLAY_S2:MOV AL,BYTE PTR DS:STR_RESULT[BX]
ADD AL,30H
CALL PUTCH
INC BX
LOOP DIVIDE_DISPLAY_S2
MOV AL,','
CALL PUTCH
MOV CX,WORD PTR STR_REMAIN
JCXZ DIVIDE_DISPLAY_REMAINZ
MOV SI,OFFSET STR_REMAIN
ADD SI,2
DIVIDE_DISPLAY_REMAINS1:MOV AL,DS:[SI]
AND AL,0FH
CMP AL,0
JNZ DIVIDE_DISPLAY_REMAINS2
INC SI
LOOP DIVIDE_DISPLAY_REMAINS1
DIVIDE_DISPLAY_REMAINS2:MOV AL,DS:[SI]
ADD AL,30H
CALL PUTCH
INC SI
LOOP DIVIDE_DISPLAY_REMAINS2
JMP DIVIDE_OK
DIVIDE_DISPLAY_REMAINZ:MOV AL,'0'
CALL PUTCH
DIVIDE_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
DIVIDE ENDP
CSEG ENDS
END START
题6.19请编写一个类似于DOS内部命令TYPE的小型实用程序。通过命令行选项，可以指示是否进行分屏显示。
方向键DOWN键盘扫描码和ASCII码为5000H
CTRL_F键盘扫描码和ASCII码为2106H
2个命令行参数例子t366.exe d:\test.txt 26和t366.exe d:\test.txt 0
要显示的文件路径 每次屏幕上显示的行数最大值
0表示不分屏
超过24的值，程序改用24
1-24之间的值，程序不作修改
使用BIOS提供的16H中断获取键盘输入，不响应CTRL+F键和方向键DOWN之外的其他键盘输入，也不响应CTRL+C和CTRL+BREAK
按下CTRL+F键，则显示下一屏，按下方向键DOWN，则显示下一行
WINTOP = 0
WINLEFT = 0
WINBOTTOM = 24
WINRIGHT = 79
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ALTF1 = 6800H
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
STR_ARG DB 256 DUP (0)
STR_FNARG DB 64 DUP (0)
STR_LNARG DB 16 DUP (0)
NUM_LNARG DW 0
NUM_BP DW 0
NUM_DI DW 0
NUM_SI DW 0
NUM_DX DW 0
NUM_CX DW 0
NUM_BX DW 0
NUM_AX DW 0
RES_DX DW 0
RES_CX DW 0
RES_BX DW 0
RES_AX DW 0
VAL_DX DW 0
VAL_CX DW 0
VAL_BX DW 0
VAL_AX DW 0
MUL_TABLE DD 1,10,100,1000,10000,100000,1000000,10000000,100000000
FILEBUF_RW DB 512 DUP (0)
HANDLE_FNARG DW 0
MESS_OPENERR DB 'Can not open file',07H,'$'
MESS_READERR DB 'Reading error',07h,'$'
MESS_FILEPTRERR DB 'Can not adjust file pointer',07H,'$'
MESS_GETLNERR DB 'Reading one line error',07h,'$'
MESS_PARAMISS DB 'Required parameter missing',07h,'$'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:CALL CONVERTARG
MOV AX,DSEG
MOV DS,AX
MOV AX,WORD PTR STR_ARG
CMP AX,0
JZ PARAMISS
MOV AX,WORD PTR NUM_LNARG
CMP AX,0
JZ DISPLAYALL
CALL DISPLAYFILE
JMP DISPLAYFINISH
DISPLAYALL:CALL DISPLAYFILEALL
JMP DISPLAYFINISH
PARAMISS:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESS_PARAMISS
CALL DISPMESS
DISPLAYFINISH:MOV AH,4CH
INT 21H
ATOBIN PROC
SUB AL,30H
CMP AL,9
JBE ATOBIN_OK
SUB AL,7
CMP AL,15
JBE ATOBIN_OK
SUB AL,20H
ATOBIN_OK:RET
ATOBIN ENDP
DTOBIN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DI,SI
ADD DI,CX
DEC DI
MOV BP,0
MOV VAL_AX,0
MOV VAL_DX,0
DTOBIN_FORJ:CMP DI,SI
JB DTOBIN_OK
MOV AL,DS:[DI]
CALL ATOBIN
MOV AH,0
MOV BX,AX
MOV AX,0
MOV DX,WORD PTR MUL_TABLE[BP]
MOV CX,WORD PTR MUL_TABLE[BP+2]
CALL MULDW
ADD VAL_AX,AX
ADC VAL_DX,BX
DTOBIN_NEXTJ:DEC DI
INC BP
INC BP
INC BP
INC BP
JMP DTOBIN_FORJ
DTOBIN_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOBIN ENDP
MULDW PROC
MOV NUM_AX,AX
MOV NUM_BX,BX
MOV NUM_CX,CX
MOV NUM_DX,DX
MOV AX,NUM_AX
MOV BX,NUM_CX
MUL BX
MOV RES_DX,DX
MOV RES_CX,AX
MOV AX,NUM_BX
MOV BX,NUM_DX
MUL BX
MOV RES_BX,DX
MOV RES_AX,AX
MOV AX,NUM_AX
MOV BX,NUM_DX
MUL BX
ADD AX,RES_BX
ADC WORD PTR RES_CX,0
ADC WORD PTR RES_DX,0
ADD DX,RES_CX
ADC WORD PTR RES_DX,0
MOV RES_CX,DX
MOV RES_BX,AX
MOV AX,NUM_BX
MOV BX,NUM_CX
MUL BX
ADD AX,RES_BX
ADC WORD PTR RES_CX,0
ADC WORD PTR RES_DX,0
ADD DX,RES_CX
ADC WORD PTR RES_DX,0
MOV RES_CX,DX
MOV RES_BX,AX
MOV DX,RES_DX
MOV CX,RES_CX
MOV BX,RES_BX
MOV AX,RES_AX
RET
MULDW ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
GETCH PROC
MOV AH,0
INT 16H
RET
GETCH ENDP
HTOASC PROC
AND AL,0FH
ADD AL,30H
CMP AL,39H
JA HTOASC_NODEC
JMP HTOASC_OK
HTOASC_NODEC:ADD AL,7
HTOASC_OK:RET
HTOASC ENDP
HTOASCDA PROC
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
RET
HTOASCDA ENDP
AHTOASC PROC
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL HTOASCDA
XCHG AH,AL
CALL HTOASCDA
RET
AHTOASC ENDP
DAHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DAHTOASC ENDP
DHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH AX
XCHG AH,AL
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DHTOASC ENDP
MEMCOPY PROC
PUSHF
PUSH CX
PUSH SI
PUSH DI
CLD
TEST SI,1
JZ MEMCOPY_1
MOVSB
DEC CX
MEMCOPY_1:SHR CX,1
REP MOVSW
JNC MEMCOPY_OK
MOVSB
MEMCOPY_OK:POP DI
POP SI
POP CX
POPF
RET
MEMCOPY ENDP
STRCHRNZ PROC
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
MOV DX,SI
MOV BL,AL
CLD
TEST SI,1
JZ STRCHRNZ_1
LODSB
AND AL,AL
JZ STRCHRNZ_NOTF
CMP AL,BL
JNZ STRCHRNZ_FIND1
STRCHRNZ_1:LODSW
AND AL,AL
JZ STRCHRNZ_NOTF
CMP AL,BL
JNZ STRCHRNZ_FIND2
AND AH,AH
JZ STRCHRNZ_NOTF
CMP AH,BL
JNZ STRCHRNZ_FIND1
JMP STRCHRNZ_1
STRCHRNZ_NOTF:STC
JMP SHORT STRCHRNZ_OK
STRCHRNZ_FIND1:LEA AX,[SI-1]
SUB AX,DX
JMP SHORT STRCHRNZ_OK
STRCHRNZ_FIND2:LEA AX,[SI-2]
SUB AX,DX
STRCHRNZ_OK:POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
RET
STRCHRNZ ENDP
STRCHRZ PROC
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
MOV DX,SI
MOV BL,AL
CLD
TEST SI,1
JZ STRCHRZ_1
LODSB
AND AL,AL
JZ STRCHRZ_NOTF
CMP AL,BL
JZ STRCHRZ_FIND1
STRCHRZ_1:LODSW
AND AL,AL
JZ STRCHRZ_NOTF
CMP AL,BL
JZ STRCHRZ_FIND2
AND AH,AH
JZ STRCHRZ_NOTF
CMP AH,BL
JZ STRCHRZ_FIND1
JMP STRCHRZ_1
STRCHRZ_NOTF:STC
JMP SHORT STRCHRZ_OK
STRCHRZ_FIND1:LEA AX,[SI-1]
SUB AX,DX
JMP SHORT STRCHRZ_OK
STRCHRZ_FIND2:LEA AX,[SI-2]
SUB AX,DX
STRCHRZ_OK:POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
RET
STRCHRZ ENDP
CONVERTARG PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
CLD
MOV SI,80H
LODSB
MOV CL,AL
XOR CH,CH
CMP CX,0
JZ CONVERTARG_OK
MOV AX,DSEG
MOV ES,AX
MOV DI,OFFSET STR_ARG
ADD DI,2
CALL MEMCOPY
MOV AX,DSEG
MOV DS,AX
MOV WORD PTR STR_ARG,CX
ADD DI,CX
MOV BYTE PTR DS:[DI],0
MOV SI,OFFSET STR_ARG
ADD SI,2
MOV AL,20H
CALL STRCHRNZ
ADD SI,AX
MOV AL,20H
CALL STRCHRZ
MOV DI,OFFSET STR_FNARG
ADD DI,2
MOV WORD PTR STR_FNARG,AX
MOV CX,AX
CALL MEMCOPY
ADD DI,CX
MOV BYTE PTR DS:[DI],0
ADD SI,CX
MOV AL,20H
CALL STRCHRNZ
ADD SI,AX
MOV AL,20H
CALL STRCHRZ
JC CONVERTARG_LNARGCOPY
MOV DI,OFFSET STR_LNARG
ADD DI,2
MOV WORD PTR STR_LNARG,AX
MOV CX,AX
CALL MEMCOPY
ADD DI,CX
MOV BYTE PTR DS:[DI],0
JMP CONVERTARG_LNARGTOBIN
CONVERTARG_LNARGCOPY:MOV AX,OFFSET STR_ARG
ADD AX,2
ADD AX,WORD PTR STR_ARG
SUB AX,SI
MOV DI,OFFSET STR_LNARG
ADD DI,2
MOV WORD PTR STR_LNARG,AX
MOV CX,AX
CALL MEMCOPY
ADD DI,CX
MOV BYTE PTR DS:[DI],0
CONVERTARG_LNARGTOBIN:MOV SI,OFFSET STR_LNARG
ADD SI,2
MOV CX,WORD PTR STR_LNARG
CALL DTOBIN
MOV AX,VAL_AX
CMP AX,25
JB CONVERTARG_LNARGB25
MOV AX,24
MOV WORD PTR NUM_LNARG,AX
JMP CONVERTARG_OK
CONVERTARG_LNARGB25:CMP AX,1
JAE CONVERTARG_LNARGAE1
MOV AX,0
MOV WORD PTR NUM_LNARG,AX
JMP CONVERTARG_OK
CONVERTARG_LNARGAE1:MOV WORD PTR NUM_LNARG,AX
CONVERTARG_OK:POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
CONVERTARG ENDP
DISPLAYARG PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
MOV AX,DSEG
MOV DS,AX
MOV ES,AX
CLD
MOV AX,WORD PTR STR_ARG
CALL DHTOASC
CALL NEWLINE
MOV SI,OFFSET STR_ARG
ADD SI,2
MOV BP,0
DISPLAYARG_FORI1:CMP BP,WORD PTR STR_ARG
JAE DISPLAYARG_FINISHI1
LODSB
CALL PUTCH
DISPLAYARG_NEXTI1:INC BP
JMP DISPLAYARG_FORI1
DISPLAYARG_FINISHI1:CALL NEWLINE
MOV AX,WORD PTR STR_FNARG
CALL DHTOASC
CALL NEWLINE
MOV SI,OFFSET STR_FNARG
ADD SI,2
MOV BP,0
DISPLAYFNARG_FORI1:CMP BP,WORD PTR STR_FNARG
JAE DISPLAYFNARG_FINISHI1
LODSB
CALL PUTCH
DISPLAYFNARG_NEXTI1:INC BP
JMP DISPLAYFNARG_FORI1
DISPLAYFNARG_FINISHI1:CALL NEWLINE
MOV AX,WORD PTR STR_LNARG
CALL DHTOASC
CALL NEWLINE
MOV SI,OFFSET STR_LNARG
ADD SI,2
MOV BP,0
DISPLAYLNARG_FORI1:CMP BP,WORD PTR STR_LNARG
JAE DISPLAYLNARG_FINISHI1
LODSB
CALL PUTCH
DISPLAYLNARG_NEXTI1:INC BP
JMP DISPLAYLNARG_FORI1
DISPLAYLNARG_FINISHI1:CALL NEWLINE
MOV AX,WORD PTR NUM_LNARG
CALL DHTOASC
CALL NEWLINE
DISPLAYARG_OK:POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
DISPLAYARG ENDP
GETLNBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV NUM_BX,BX
MOV NUM_DX,DX
MOV DI,DX
MOV WORD PTR [DI],0
ADD DX,2
MOV CX,256
MOV AH,3FH
INT 21H
JC GETLNBUF_READERR
CMP AX,0
JZ GETLNBUF_FINISH
MOV BP,AX
MOV BX,NUM_DX
MOV SI,0
MOV DI,0
GETLNBUF_FORI1:CMP SI,BP
JAE GETLNBUF_FINISHI1
MOV AL,[BX][DI+2]
CMP AL,LF
JZ GETLNBUF_NEXTI2
JMP GETLNBUF_NEXTI1
GETLNBUF_NEXTI2:INC SI
INC DI
JMP GETLNBUF_FINISHI1
GETLNBUF_NEXTI1:INC SI
INC DI
JMP GETLNBUF_FORI1
GETLNBUF_FINISHI1:MOV WORD PTR [BX],SI
CMP SI,BP
JAE GETLNBUF_FINISH
MOV DX,SI
SUB DX,BP
MOV CX,0FFFFH
MOV BX,NUM_BX
MOV AX,4201H
INT 21H
JC GETLNBUF_FILEPTRERR
JMP GETLNBUF_FINISH
GETLNBUF_READERR:MOV DX,OFFSET MESS_READERR
CALL DISPMESS
STC
JMP GETLNBUF_OK
GETLNBUF_FILEPTRERR:MOV DX,OFFSET MESS_FILEPTRERR
CALL DISPMESS
STC
JMP GETLNBUF_OK
GETLNBUF_FINISH:CLC
GETLNBUF_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
GETLNBUF ENDP
DISPLAYLINE PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DI,DX
MOV BP,WORD PTR [DI]
ADD DI,2
MOV SI,0
DISPLAYLINE_FORI1:CMP SI,BP
JAE DISPLAYLINE_OK
MOV AL,[DI]
MOV DL,AL
MOV AH,2
INT 21H
DISPLAYLINE_NEXTI1:INC SI
INC DI
JMP DISPLAYLINE_FORI1
DISPLAYLINE_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DISPLAYLINE ENDP
DISPLAYFILE PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
MOV AX,DSEG
MOV DS,AX
MOV ES,AX
CLD
MOV DX,OFFSET STR_FNARG
ADD DX,2
MOV AX,3D00H
INT 21H
JNC DISPLAYFILE_OPENOKSRC
DISPLAYFILE_OPENERRSRC:MOV DX,OFFSET MESS_OPENERR
CALL DISPMESS
JMP DISPLAYFILE_OK
DISPLAYFILE_OPENOKSRC:MOV HANDLE_FNARG,AX
DISPLAYFILE_RWBUF:MOV BP,0
DISPLAYFILE_FORI1:CMP BP,WORD PTR NUM_LNARG
JAE DISPLAYFILE_FINISHI1
MOV DX,OFFSET FILEBUF_RW
MOV BX,HANDLE_FNARG
CALL GETLNBUF
JC DISPLAYFILE_READERR
MOV AX,WORD PTR FILEBUF_RW
CMP AX,0
JZ DISPLAYFILE_RWFINISH
MOV DX,OFFSET FILEBUF_RW
CALL DISPLAYLINE
DISPLAYFILE_NEXTI1:INC BP
JMP DISPLAYFILE_FORI1
DISPLAYFILE_FINISHI1:CALL GETCH
CMP AX,2106H
JZ DISPLAYFILE_RWBUF
CMP AX,5000H
JZ DISPLAYFILE_DOWN
JMP DISPLAYFILE_FINISHI1
DISPLAYFILE_DOWN:MOV DX,OFFSET FILEBUF_RW
MOV BX,HANDLE_FNARG
CALL GETLNBUF
JC DISPLAYFILE_READERR
MOV AX,WORD PTR FILEBUF_RW
CMP AX,0
JZ DISPLAYFILE_RWFINISH
MOV DX,OFFSET FILEBUF_RW
CALL DISPLAYLINE
DISPLAYFILE_DOWNFINISH:CALL GETCH
CMP AX,2106H
JZ DISPLAYFILE_RWBUF
CMP AX,5000H
JZ DISPLAYFILE_DOWN
JMP DISPLAYFILE_DOWNFINISH
DISPLAYFILE_READERR:MOV DX,OFFSET MESS_GETLNERR
CALL DISPMESS
DISPLAYFILE_RWFINISH:MOV BX,HANDLE_FNARG
MOV AH,3EH
INT 21H
DISPLAYFILE_OK:POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
DISPLAYFILE ENDP
DISPLAYFILEALL PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
MOV AX,DSEG
MOV DS,AX
MOV ES,AX
CLD
MOV DX,OFFSET STR_FNARG
ADD DX,2
MOV AX,3D00H
INT 21H
JNC DISPLAYFILEALL_OPENOKSRC
DISPLAYFILEALL_OPENERRSRC:MOV DX,OFFSET MESS_OPENERR
CALL DISPMESS
JMP DISPLAYFILEALL_OK
DISPLAYFILEALL_OPENOKSRC:MOV HANDLE_FNARG,AX
DISPLAYFILEALL_RWBUF:MOV BP,0
DISPLAYFILEALL_FORI1:CMP BP,25
JAE DISPLAYFILEALL_FINISHI1
MOV DX,OFFSET FILEBUF_RW
MOV BX,HANDLE_FNARG
CALL GETLNBUF
JC DISPLAYFILEALL_READERR
MOV AX,WORD PTR FILEBUF_RW
CMP AX,0
JZ DISPLAYFILEALL_RWFINISH
MOV DX,OFFSET FILEBUF_RW
CALL DISPLAYLINE
DISPLAYFILEALL_NEXTI1:INC BP
JMP DISPLAYFILEALL_FORI1
DISPLAYFILEALL_FINISHI1:JMP DISPLAYFILEALL_RWBUF
DISPLAYFILEALL_READERR:MOV DX,OFFSET MESS_GETLNERR
CALL DISPMESS
DISPLAYFILEALL_RWFINISH:MOV BX,HANDLE_FNARG
MOV AH,3EH
INT 21H
DISPLAYFILEALL_OK:POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
DISPLAYFILEALL ENDP
CSEG ENDS
END START
题6.20请编写一个类似于DOS内部命令COPY的小型实用程序。
2个命令行参数例子t367.exe d:\test.txt d:\testabcd.txt，test.txt复制后的文件名为testabcd.txt
3个命令行参数例子t367.exe d:\test1.txt d:\test2.txt d:\testo.txt test1.txt和test2.txt合并复制后的文件名为testo.txt
子程序COPYFILE二进制复制，COPYFILELN文本文件按行复制 COPYFILERO二个文件合并复制
WINTOP = 0
WINLEFT = 0
WINBOTTOM = 24
WINRIGHT = 79
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ALTF1 = 6800H
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
STR_ARG DB 256 DUP (0)
STR_FNSOC DB 64 DUP (0)
STR_FNSRC DB 64 DUP (0)
STR_FNDST DB 64 DUP (0)
NUM_BP DW 0
NUM_DI DW 0
NUM_SI DW 0
NUM_DX DW 0
NUM_CX DW 0
NUM_BX DW 0
NUM_AX DW 0
FILEBUF_RW DB 512 DUP (0)
HANDLE_FNSOC DW 0
HANDLE_FNSRC DW 0
HANDLE_FNDST DW 0
MESS_OPENERR DB 'Can not open file',07H,'$'
MESS_READERR DB 'Reading error',07h,'$'
MESS_CREAERR DB 'Can not create file',07H,'$'
MESS_WRITERR DB 'Writing error',07H,'$'
MESS_FILEPTRERR DB 'Can not adjust file pointer',07H,'$'
MESS_GETLNERR DB 'Reading one line error',07h,'$'
MESS_APPENDLNERR DB 'Writing one line error',07h,'$'
MESS_PARAMISS DB 'Required parameter missing',07h,'$'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:CALL CONVERTARG
CALL DISPLAYARG
MOV AX,DSEG
MOV DS,AX
MOV AX,WORD PTR STR_ARG
CMP AX,0
JZ PARAMISS
MOV AX,WORD PTR STR_FNSOC
CMP AX,0
JNZ COPYRO
CALL COPYFILE
JMP COPYFINISH
COPYRO:CALL COPYFILERO
JMP COPYFINISH
PARAMISS:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESS_PARAMISS
CALL DISPMESS
COPYFINISH:MOV AH,4CH
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
HTOASC PROC
AND AL,0FH
ADD AL,30H
CMP AL,39H
JA HTOASC_NODEC
JMP HTOASC_OK
HTOASC_NODEC:ADD AL,7
HTOASC_OK:RET
HTOASC ENDP
HTOASCDA PROC
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
RET
HTOASCDA ENDP
AHTOASC PROC
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL HTOASCDA
XCHG AH,AL
CALL HTOASCDA
RET
AHTOASC ENDP
DAHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DAHTOASC ENDP
DHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH AX
XCHG AH,AL
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DHTOASC ENDP
MEMCOPY PROC
PUSHF
PUSH CX
PUSH SI
PUSH DI
CLD
TEST SI,1
JZ MEMCOPY_1
MOVSB
DEC CX
MEMCOPY_1:SHR CX,1
REP MOVSW
JNC MEMCOPY_OK
MOVSB
MEMCOPY_OK:POP DI
POP SI
POP CX
POPF
RET
MEMCOPY ENDP
STRCHRNZ PROC
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
MOV DX,SI
MOV BL,AL
CLD
TEST SI,1
JZ STRCHRNZ_1
LODSB
AND AL,AL
JZ STRCHRNZ_NOTF
CMP AL,BL
JNZ STRCHRNZ_FIND1
STRCHRNZ_1:LODSW
AND AL,AL
JZ STRCHRNZ_NOTF
CMP AL,BL
JNZ STRCHRNZ_FIND2
AND AH,AH
JZ STRCHRNZ_NOTF
CMP AH,BL
JNZ STRCHRNZ_FIND1
JMP STRCHRNZ_1
STRCHRNZ_NOTF:STC
JMP SHORT STRCHRNZ_OK
STRCHRNZ_FIND1:LEA AX,[SI-1]
SUB AX,DX
JMP SHORT STRCHRNZ_OK
STRCHRNZ_FIND2:LEA AX,[SI-2]
SUB AX,DX
STRCHRNZ_OK:POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
RET
STRCHRNZ ENDP
STRCHRZ PROC
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
MOV DX,SI
MOV BL,AL
CLD
TEST SI,1
JZ STRCHRZ_1
LODSB
AND AL,AL
JZ STRCHRZ_NOTF
CMP AL,BL
JZ STRCHRZ_FIND1
STRCHRZ_1:LODSW
AND AL,AL
JZ STRCHRZ_NOTF
CMP AL,BL
JZ STRCHRZ_FIND2
AND AH,AH
JZ STRCHRZ_NOTF
CMP AH,BL
JZ STRCHRZ_FIND1
JMP STRCHRZ_1
STRCHRZ_NOTF:STC
JMP SHORT STRCHRZ_OK
STRCHRZ_FIND1:LEA AX,[SI-1]
SUB AX,DX
JMP SHORT STRCHRZ_OK
STRCHRZ_FIND2:LEA AX,[SI-2]
SUB AX,DX
STRCHRZ_OK:POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
RET
STRCHRZ ENDP
CONVERTARG PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
CLD
MOV SI,80H
LODSB
MOV CL,AL
XOR CH,CH
CMP CX,0
JZ CONVERTARG_OK
MOV AX,DSEG
MOV ES,AX
MOV DI,OFFSET STR_ARG
ADD DI,2
CALL MEMCOPY
MOV AX,DSEG
MOV DS,AX
MOV WORD PTR STR_ARG,CX
ADD DI,CX
MOV BYTE PTR DS:[DI],0
MOV SI,OFFSET STR_ARG
ADD SI,2
MOV AL,20H
CALL STRCHRNZ
ADD SI,AX
MOV AL,20H
CALL STRCHRZ
MOV DI,OFFSET STR_FNSRC
ADD DI,2
MOV WORD PTR STR_FNSRC,AX
MOV CX,AX
CALL MEMCOPY
ADD DI,CX
MOV BYTE PTR DS:[DI],0
ADD SI,CX
MOV AL,20H
CALL STRCHRNZ
ADD SI,AX
MOV AL,20H
CALL STRCHRZ
JC CONVERTARG_FNDSTCOPY
MOV DI,OFFSET STR_FNSOC
ADD DI,2
MOV WORD PTR STR_FNSOC,AX
MOV CX,AX
CALL MEMCOPY
ADD DI,CX
MOV BYTE PTR DS:[DI],0
ADD SI,CX
MOV AL,20H
CALL STRCHRNZ
ADD SI,AX
MOV AX,OFFSET STR_ARG
ADD AX,2
ADD AX,WORD PTR STR_ARG
SUB AX,SI
MOV DI,OFFSET STR_FNDST
ADD DI,2
MOV WORD PTR STR_FNDST,AX
MOV CX,AX
CALL MEMCOPY
ADD DI,CX
MOV BYTE PTR DS:[DI],0
JMP CONVERTARG_OK
CONVERTARG_FNDSTCOPY:MOV AX,OFFSET STR_ARG
ADD AX,2
ADD AX,WORD PTR STR_ARG
SUB AX,SI
MOV DI,OFFSET STR_FNDST
ADD DI,2
MOV WORD PTR STR_FNDST,AX
MOV CX,AX
CALL MEMCOPY
ADD DI,CX
MOV BYTE PTR DS:[DI],0
MOV AX,0
MOV WORD PTR STR_FNSOC,AX
CONVERTARG_OK:POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
CONVERTARG ENDP
DISPLAYARG PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
MOV AX,DSEG
MOV DS,AX
MOV ES,AX
CLD
MOV AX,WORD PTR STR_ARG
CALL DHTOASC
CALL NEWLINE
MOV SI,OFFSET STR_ARG
ADD SI,2
MOV BP,0
DISPLAYARG_FORI1:CMP BP,WORD PTR STR_ARG
JAE DISPLAYARG_FINISHI1
LODSB
CALL PUTCH
DISPLAYARG_NEXTI1:INC BP
JMP DISPLAYARG_FORI1
DISPLAYARG_FINISHI1:CALL NEWLINE
MOV AX,WORD PTR STR_FNSRC
CALL DHTOASC
CALL NEWLINE
MOV SI,OFFSET STR_FNSRC
ADD SI,2
MOV BP,0
DISPLAYFNSRC_FORI1:CMP BP,WORD PTR STR_FNSRC
JAE DISPLAYFNSRC_FINISHI1
LODSB
CALL PUTCH
DISPLAYFNSRC_NEXTI1:INC BP
JMP DISPLAYFNSRC_FORI1
DISPLAYFNSRC_FINISHI1:CALL NEWLINE
MOV AX,WORD PTR STR_FNDST
CALL DHTOASC
CALL NEWLINE
MOV SI,OFFSET STR_FNDST
ADD SI,2
MOV BP,0
DISPLAYFNDST_FORI1:CMP BP,WORD PTR STR_FNDST
JAE DISPLAYFNDST_FINISHI1
LODSB
CALL PUTCH
DISPLAYFNDST_NEXTI1:INC BP
JMP DISPLAYFNDST_FORI1
DISPLAYFNDST_FINISHI1:CALL NEWLINE
MOV AX,WORD PTR STR_FNSOC
CALL DHTOASC
CALL NEWLINE
MOV SI,OFFSET STR_FNSOC
ADD SI,2
MOV BP,0
DISPLAYFNSOC_FORI1:CMP BP,WORD PTR STR_FNSOC
JAE DISPLAYFNSOC_FINISHI1
LODSB
CALL PUTCH
DISPLAYFNSOC_NEXTI1:INC BP
JMP DISPLAYFNSOC_FORI1
DISPLAYFNSOC_FINISHI1:CALL NEWLINE
DISPLAYARG_OK:POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
DISPLAYARG ENDP
COPYFILE PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
MOV AX,DSEG
MOV DS,AX
MOV ES,AX
CLD
MOV DX,OFFSET STR_FNSRC
ADD DX,2
MOV AX,3D00H
INT 21H
JNC COPYFILE_OPENOKSRC
COPYFILE_OPENERRSRC:MOV DX,OFFSET MESS_OPENERR
CALL DISPMESS
JMP COPYFILE_OK
COPYFILE_OPENOKSRC:MOV HANDLE_FNSRC,AX
MOV DX,OFFSET STR_FNDST
ADD DX,2
MOV CX,0
MOV AH,3CH
INT 21H
JNC COPYFILE_CREAOKDST
COPYFILE_CREAERRDST:MOV BX,HANDLE_FNSRC
MOV AH,3EH
INT 21H
MOV DX,OFFSET MESS_CREAERR
CALL DISPMESS
JMP COPYFILE_OK
COPYFILE_CREAOKDST:MOV HANDLE_FNDST,AX
COPYFILE_RWBUF:MOV DX,OFFSET FILEBUF_RW
MOV CX,512
MOV BX,HANDLE_FNSRC
MOV AH,3FH
INT 21H
JC COPYFILE_READERR
CMP AX,0
JZ COPYFILE_RWFINISH
MOV DX,OFFSET FILEBUF_RW
MOV CX,AX
MOV BX,HANDLE_FNDST
MOV AH,40H
INT 21H
JC COPYFILE_WRITERR
JMP COPYFILE_RWBUF
COPYFILE_WRITERR:MOV DX,OFFSET MESS_WRITERR
CALL DISPMESS
JMP COPYFILE_RWFINISH
COPYFILE_READERR:MOV DX,OFFSET MESS_READERR
CALL DISPMESS
COPYFILE_RWFINISH:MOV BX,HANDLE_FNSRC
MOV AH,3EH
INT 21H
MOV BX,HANDLE_FNDST
MOV AH,3EH
INT 21H
COPYFILE_OK:POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
COPYFILE ENDP
GETLNBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV NUM_BX,BX
MOV NUM_DX,DX
MOV DI,DX
MOV WORD PTR [DI],0
ADD DX,2
MOV CX,256
MOV AH,3FH
INT 21H
JC GETLNBUF_READERR
CMP AX,0
JZ GETLNBUF_FINISH
MOV BP,AX
MOV BX,NUM_DX
MOV SI,0
MOV DI,0
GETLNBUF_FORI1:CMP SI,BP
JAE GETLNBUF_FINISHI1
MOV AL,[BX][DI+2]
CMP AL,LF
JZ GETLNBUF_NEXTI2
JMP GETLNBUF_NEXTI1
GETLNBUF_NEXTI2:INC SI
INC DI
JMP GETLNBUF_FINISHI1
GETLNBUF_NEXTI1:INC SI
INC DI
JMP GETLNBUF_FORI1
GETLNBUF_FINISHI1:MOV WORD PTR [BX],SI
CMP SI,BP
JAE GETLNBUF_FINISH
MOV DX,SI
SUB DX,BP
MOV CX,0FFFFH
MOV BX,NUM_BX
MOV AX,4201H
INT 21H
JC GETLNBUF_FILEPTRERR
JMP GETLNBUF_FINISH
GETLNBUF_READERR:MOV DX,OFFSET MESS_READERR
CALL DISPMESS
STC
JMP GETLNBUF_OK
GETLNBUF_FILEPTRERR:MOV DX,OFFSET MESS_FILEPTRERR
CALL DISPMESS
STC
JMP GETLNBUF_OK
GETLNBUF_FINISH:CLC
GETLNBUF_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
GETLNBUF ENDP
APPENDLNBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DI,DX
MOV CX,WORD PTR [DI]
ADD DX,2
MOV AH,40H
INT 21H
JC APPENDLNBUF_WRITERR
JMP APPENDLNBUF_FINISH
APPENDLNBUF_WRITERR:MOV DX,OFFSET MESS_WRITERR
CALL DISPMESS
STC
JMP APPENDLNBUF_OK
APPENDLNBUF_FINISH:CLC
APPENDLNBUF_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
APPENDLNBUF ENDP
COPYFILELN PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
MOV AX,DSEG
MOV DS,AX
MOV ES,AX
CLD
MOV DX,OFFSET STR_FNSRC
ADD DX,2
MOV AX,3D00H
INT 21H
JNC COPYFILELN_OPENOKSRC
COPYFILELN_OPENERRSRC:MOV DX,OFFSET MESS_OPENERR
CALL DISPMESS
JMP COPYFILELN_OK
COPYFILELN_OPENOKSRC:MOV HANDLE_FNSRC,AX
MOV DX,OFFSET STR_FNDST
ADD DX,2
MOV CX,0
MOV AH,3CH
INT 21H
JNC COPYFILELN_CREAOKDST
COPYFILELN_CREAERRDST:MOV BX,HANDLE_FNSRC
MOV AH,3EH
INT 21H
MOV DX,OFFSET MESS_CREAERR
CALL DISPMESS
JMP COPYFILELN_OK
COPYFILELN_CREAOKDST:MOV HANDLE_FNDST,AX
COPYFILELN_RWBUF:MOV DX,OFFSET FILEBUF_RW
MOV BX,HANDLE_FNSRC
CALL GETLNBUF
JC COPYFILELN_READERR
MOV AX,WORD PTR FILEBUF_RW
CMP AX,0
JZ COPYFILELN_RWFINISH
MOV DX,OFFSET FILEBUF_RW
MOV BX,HANDLE_FNDST
CALL APPENDLNBUF
JC COPYFILELN_WRITERR
JMP COPYFILELN_RWBUF
COPYFILELN_WRITERR:MOV DX,OFFSET MESS_APPENDLNERR
CALL DISPMESS
JMP COPYFILELN_RWFINISH
COPYFILELN_READERR:MOV DX,OFFSET MESS_GETLNERR
CALL DISPMESS
COPYFILELN_RWFINISH:MOV BX,HANDLE_FNSRC
MOV AH,3EH
INT 21H
MOV BX,HANDLE_FNDST
MOV AH,3EH
INT 21H
COPYFILELN_OK:POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
COPYFILELN ENDP
COPYFILERO PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
MOV AX,DSEG
MOV DS,AX
MOV ES,AX
CLD
MOV DX,OFFSET STR_FNSRC
ADD DX,2
MOV AX,3D00H
INT 21H
JNC COPYFILERO_OPENOKSRC
COPYFILERO_OPENERRSRC:MOV DX,OFFSET MESS_OPENERR
CALL DISPMESS
JMP COPYFILERO_OK
COPYFILERO_OPENOKSRC:MOV HANDLE_FNSRC,AX
MOV DX,OFFSET STR_FNSOC
ADD DX,2
MOV AX,3D00H
INT 21H
JNC COPYFILERO_OPENOKSOC
COPYFILERO_OPENERRSOC:MOV BX,HANDLE_FNSRC
MOV AH,3EH
INT 21H
MOV DX,OFFSET MESS_OPENERR
CALL DISPMESS
JMP COPYFILERO_OK
COPYFILERO_OPENOKSOC:MOV HANDLE_FNSOC,AX
MOV DX,OFFSET STR_FNDST
ADD DX,2
MOV CX,0
MOV AH,3CH
INT 21H
JNC COPYFILERO_CREAOKDST
COPYFILERO_CREAERRDST:MOV BX,HANDLE_FNSRC
MOV AH,3EH
INT 21H
MOV BX,HANDLE_FNSOC
MOV AH,3EH
INT 21H
MOV DX,OFFSET MESS_CREAERR
CALL DISPMESS
JMP COPYFILERO_OK
COPYFILERO_CREAOKDST:MOV HANDLE_FNDST,AX
COPYFILERO_RWBUFSRC:MOV DX,OFFSET FILEBUF_RW
MOV CX,512
MOV BX,HANDLE_FNSRC
MOV AH,3FH
INT 21H
JC COPYFILERO_READERR
CMP AX,0
JZ COPYFILERO_RWBUFSOC
MOV DX,OFFSET FILEBUF_RW
MOV CX,AX
MOV BX,HANDLE_FNDST
MOV AH,40H
INT 21H
JC COPYFILERO_WRITERR
JMP COPYFILERO_RWBUFSRC
COPYFILERO_RWBUFSOC:MOV DX,OFFSET FILEBUF_RW
MOV CX,512
MOV BX,HANDLE_FNSOC
MOV AH,3FH
INT 21H
JC COPYFILERO_READERR
CMP AX,0
JZ COPYFILERO_RWFINISH
MOV DX,OFFSET FILEBUF_RW
MOV CX,AX
MOV BX,HANDLE_FNDST
MOV AH,40H
INT 21H
JC COPYFILERO_WRITERR
JMP COPYFILERO_RWBUFSOC
COPYFILERO_WRITERR:MOV DX,OFFSET MESS_WRITERR
CALL DISPMESS
JMP COPYFILERO_RWFINISH
COPYFILERO_READERR:MOV DX,OFFSET MESS_READERR
CALL DISPMESS
COPYFILERO_RWFINISH:MOV BX,HANDLE_FNSRC
MOV AH,3EH
INT 21H
MOV BX,HANDLE_FNSOC
MOV AH,3EH
INT 21H
MOV BX,HANDLE_FNDST
MOV AH,3EH
INT 21H
COPYFILERO_OK:POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
COPYFILERO ENDP
CSEG ENDS
END START
题6.21请编写一 个类似于DOS内部命令TYPE的小型实用程序。但不能利用Ctrl+C键等终止程序。
方向键DOWN键盘扫描码和ASCII码为5000H
CTRL_F键盘扫描码和ASCII码为2106H
ESC键盘扫描码和ASCII码为011BH
2个命令行参数例子t371.exe d:\test.txt 26和t371.exe d:\test.txt 0
要显示的文件路径 每次屏幕上显示的行数最大值
0表示不分屏
超过24的值，程序改用24
1-24之间的值，程序不作修改
使用BIOS提供的16H中断获取键盘输入，不响应CTRL+F键、方向键DOWN、ESC键之外的其他键盘输入，
也不响应CTRL+C、CTRL+2、CTRL+BREAK
按下CTRL+F键，则显示下一屏，按下方向键DOWN，则显示下一行，按下ESC键，则显示结束，程序退出
WINTOP = 0
WINLEFT = 0
WINBOTTOM = 24
WINRIGHT = 79
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ALTF1 = 6800H
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
STR_ARG DB 256 DUP (0)
STR_FNARG DB 64 DUP (0)
STR_LNARG DB 16 DUP (0)
NUM_LNARG DW 0
NUM_BP DW 0
NUM_DI DW 0
NUM_SI DW 0
NUM_DX DW 0
NUM_CX DW 0
NUM_BX DW 0
NUM_AX DW 0
RES_DX DW 0
RES_CX DW 0
RES_BX DW 0
RES_AX DW 0
VAL_DX DW 0
VAL_CX DW 0
VAL_BX DW 0
VAL_AX DW 0
MUL_TABLE DD 1,10,100,1000,10000,100000,1000000,10000000,100000000
FILEBUF_RW DB 512 DUP (0)
HANDLE_FNARG DW 0
MESS_OPENERR DB 'Can not open file',07H,'$'
MESS_READERR DB 'Reading error',07h,'$'
MESS_FILEPTRERR DB 'Can not adjust file pointer',07H,'$'
MESS_GETLNERR DB 'Reading one line error',07h,'$'
MESS_PARAMISS DB 'Required parameter missing',07h,'$'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
OLD16H DD ?
OLD1BH DD ?
NEW16H:PUSH BP
MOV BP,SP
PUSH BX
PUSH DS
PUSH CS
POP DS
CMP AH,10H
JZ PKEY
CMP AH,11H
JZ PKEY2
CMP AH,0
JZ PKEY
CMP AH,1
JZ PKEY2
PUSHF
CALL DWORD PTR DS:[0]
PUSHF
POP BX
MOV WORD PTR SS:[BP+6],BX
POP DS
POP BX
POP BP
IRET
PKEY:PUSH AX
PUSHF
CALL DWORD PTR DS:[0]
PUSHF
POP BX
MOV WORD PTR SS:[BP+6],BX
CMP AL,03H
JZ PKEY_NEXT
CMP AX,0300H
JZ PKEY_NEXT
CMP AX,0000H
JZ PKEY_NEXT
ADD SP,2
POP DS
POP BX
POP BP
IRET
PKEY_NEXT:POP AX
JMP PKEY
PKEY2:PUSH AX
PUSHF
CALL DWORD PTR DS:[0]
PUSHF
POP BX
MOV WORD PTR SS:[BP+6],BX
JZ PKEY6
CMP AL,03H
JZ PKEY4
CMP AX,0300H
JZ PKEY4
CMP AX,0000H
JZ PKEY4
JMP PKEY5
PKEY4:XOR AH,AH
PUSHF
CALL DWORD PTR DS:[0]
POP AX
JMP PKEY2
PKEY5:ADD SP,2
POP DS
POP BX
POP BP
IRET
PKEY6:ADD SP,2
POP DS
POP BX
POP BP
IRET
NEW1BH:IRET
START:CALL CONVERTARG
ASSUME DS:CSEG
PUSH CS
POP DS
MOV AX,3516H
INT 21H
MOV WORD PTR OLD16H,BX
MOV WORD PTR OLD16H+2,ES
MOV AX,351BH
INT 21H
MOV WORD PTR OLD1BH,BX
MOV WORD PTR OLD1BH+2,ES
MOV DX,OFFSET NEW16H
MOV AX,2516H
INT 21H
MOV DX,OFFSET NEW1BH
MOV AX,251BH
INT 21H
ASSUME DS:DSEG
MOV AX,DSEG
MOV DS,AX
MOV AX,WORD PTR STR_ARG
CMP AX,0
JZ PARAMISS
MOV AX,WORD PTR NUM_LNARG
CMP AX,0
JZ DISPLAYALL
CALL DISPLAYFILE
JMP DISPLAYFINISH
DISPLAYALL:CALL DISPLAYFILEALL
JMP DISPLAYFINISH
PARAMISS:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESS_PARAMISS
CALL DISPMESS
DISPLAYFINISH:ASSUME DS:CSEG
PUSH CS
POP DS
LDS DX,OLD1BH
MOV AX,251BH
INT 21H
PUSH CS
POP DS
LDS DX,OLD16H
MOV AX,2516H
INT 21H
ASSUME DS:DSEG
MOV AH,4CH
INT 21H
ATOBIN PROC
SUB AL,30H
CMP AL,9
JBE ATOBIN_OK
SUB AL,7
CMP AL,15
JBE ATOBIN_OK
SUB AL,20H
ATOBIN_OK:RET
ATOBIN ENDP
DTOBIN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DI,SI
ADD DI,CX
DEC DI
MOV BP,0
MOV VAL_AX,0
MOV VAL_DX,0
DTOBIN_FORJ:CMP DI,SI
JB DTOBIN_OK
MOV AL,DS:[DI]
CALL ATOBIN
MOV AH,0
MOV BX,AX
MOV AX,0
MOV DX,WORD PTR MUL_TABLE[BP]
MOV CX,WORD PTR MUL_TABLE[BP+2]
CALL MULDW
ADD VAL_AX,AX
ADC VAL_DX,BX
DTOBIN_NEXTJ:DEC DI
INC BP
INC BP
INC BP
INC BP
JMP DTOBIN_FORJ
DTOBIN_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOBIN ENDP
MULDW PROC
MOV NUM_AX,AX
MOV NUM_BX,BX
MOV NUM_CX,CX
MOV NUM_DX,DX
MOV AX,NUM_AX
MOV BX,NUM_CX
MUL BX
MOV RES_DX,DX
MOV RES_CX,AX
MOV AX,NUM_BX
MOV BX,NUM_DX
MUL BX
MOV RES_BX,DX
MOV RES_AX,AX
MOV AX,NUM_AX
MOV BX,NUM_DX
MUL BX
ADD AX,RES_BX
ADC WORD PTR RES_CX,0
ADC WORD PTR RES_DX,0
ADD DX,RES_CX
ADC WORD PTR RES_DX,0
MOV RES_CX,DX
MOV RES_BX,AX
MOV AX,NUM_BX
MOV BX,NUM_CX
MUL BX
ADD AX,RES_BX
ADC WORD PTR RES_CX,0
ADC WORD PTR RES_DX,0
ADD DX,RES_CX
ADC WORD PTR RES_DX,0
MOV RES_CX,DX
MOV RES_BX,AX
MOV DX,RES_DX
MOV CX,RES_CX
MOV BX,RES_BX
MOV AX,RES_AX
RET
MULDW ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
GETCH PROC
MOV AH,0
INT 16H
RET
GETCH ENDP
HTOASC PROC
AND AL,0FH
ADD AL,30H
CMP AL,39H
JA HTOASC_NODEC
JMP HTOASC_OK
HTOASC_NODEC:ADD AL,7
HTOASC_OK:RET
HTOASC ENDP
HTOASCDA PROC
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
RET
HTOASCDA ENDP
AHTOASC PROC
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL HTOASCDA
XCHG AH,AL
CALL HTOASCDA
RET
AHTOASC ENDP
DAHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DAHTOASC ENDP
DHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH AX
XCHG AH,AL
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DHTOASC ENDP
MEMCOPY PROC
PUSHF
PUSH CX
PUSH SI
PUSH DI
CLD
TEST SI,1
JZ MEMCOPY_1
MOVSB
DEC CX
MEMCOPY_1:SHR CX,1
REP MOVSW
JNC MEMCOPY_OK
MOVSB
MEMCOPY_OK:POP DI
POP SI
POP CX
POPF
RET
MEMCOPY ENDP
STRCHRNZ PROC
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
MOV DX,SI
MOV BL,AL
CLD
TEST SI,1
JZ STRCHRNZ_1
LODSB
AND AL,AL
JZ STRCHRNZ_NOTF
CMP AL,BL
JNZ STRCHRNZ_FIND1
STRCHRNZ_1:LODSW
AND AL,AL
JZ STRCHRNZ_NOTF
CMP AL,BL
JNZ STRCHRNZ_FIND2
AND AH,AH
JZ STRCHRNZ_NOTF
CMP AH,BL
JNZ STRCHRNZ_FIND1
JMP STRCHRNZ_1
STRCHRNZ_NOTF:STC
JMP SHORT STRCHRNZ_OK
STRCHRNZ_FIND1:LEA AX,[SI-1]
SUB AX,DX
JMP SHORT STRCHRNZ_OK
STRCHRNZ_FIND2:LEA AX,[SI-2]
SUB AX,DX
STRCHRNZ_OK:POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
RET
STRCHRNZ ENDP
STRCHRZ PROC
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
MOV DX,SI
MOV BL,AL
CLD
TEST SI,1
JZ STRCHRZ_1
LODSB
AND AL,AL
JZ STRCHRZ_NOTF
CMP AL,BL
JZ STRCHRZ_FIND1
STRCHRZ_1:LODSW
AND AL,AL
JZ STRCHRZ_NOTF
CMP AL,BL
JZ STRCHRZ_FIND2
AND AH,AH
JZ STRCHRZ_NOTF
CMP AH,BL
JZ STRCHRZ_FIND1
JMP STRCHRZ_1
STRCHRZ_NOTF:STC
JMP SHORT STRCHRZ_OK
STRCHRZ_FIND1:LEA AX,[SI-1]
SUB AX,DX
JMP SHORT STRCHRZ_OK
STRCHRZ_FIND2:LEA AX,[SI-2]
SUB AX,DX
STRCHRZ_OK:POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
RET
STRCHRZ ENDP
CONVERTARG PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
CLD
MOV SI,80H
LODSB
MOV CL,AL
XOR CH,CH
CMP CX,0
JZ CONVERTARG_OK
MOV AX,DSEG
MOV ES,AX
MOV DI,OFFSET STR_ARG
ADD DI,2
CALL MEMCOPY
MOV AX,DSEG
MOV DS,AX
MOV WORD PTR STR_ARG,CX
ADD DI,CX
MOV BYTE PTR DS:[DI],0
MOV SI,OFFSET STR_ARG
ADD SI,2
MOV AL,20H
CALL STRCHRNZ
ADD SI,AX
MOV AL,20H
CALL STRCHRZ
MOV DI,OFFSET STR_FNARG
ADD DI,2
MOV WORD PTR STR_FNARG,AX
MOV CX,AX
CALL MEMCOPY
ADD DI,CX
MOV BYTE PTR DS:[DI],0
ADD SI,CX
MOV AL,20H
CALL STRCHRNZ
ADD SI,AX
MOV AL,20H
CALL STRCHRZ
JC CONVERTARG_LNARGCOPY
MOV DI,OFFSET STR_LNARG
ADD DI,2
MOV WORD PTR STR_LNARG,AX
MOV CX,AX
CALL MEMCOPY
ADD DI,CX
MOV BYTE PTR DS:[DI],0
JMP CONVERTARG_LNARGTOBIN
CONVERTARG_LNARGCOPY:MOV AX,OFFSET STR_ARG
ADD AX,2
ADD AX,WORD PTR STR_ARG
SUB AX,SI
MOV DI,OFFSET STR_LNARG
ADD DI,2
MOV WORD PTR STR_LNARG,AX
MOV CX,AX
CALL MEMCOPY
ADD DI,CX
MOV BYTE PTR DS:[DI],0
CONVERTARG_LNARGTOBIN:MOV SI,OFFSET STR_LNARG
ADD SI,2
MOV CX,WORD PTR STR_LNARG
CALL DTOBIN
MOV AX,VAL_AX
CMP AX,25
JB CONVERTARG_LNARGB25
MOV AX,24
MOV WORD PTR NUM_LNARG,AX
JMP CONVERTARG_OK
CONVERTARG_LNARGB25:CMP AX,1
JAE CONVERTARG_LNARGAE1
MOV AX,0
MOV WORD PTR NUM_LNARG,AX
JMP CONVERTARG_OK
CONVERTARG_LNARGAE1:MOV WORD PTR NUM_LNARG,AX
CONVERTARG_OK:POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
CONVERTARG ENDP
DISPLAYARG PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
MOV AX,DSEG
MOV DS,AX
MOV ES,AX
CLD
MOV AX,WORD PTR STR_ARG
CALL DHTOASC
CALL NEWLINE
MOV SI,OFFSET STR_ARG
ADD SI,2
MOV BP,0
DISPLAYARG_FORI1:CMP BP,WORD PTR STR_ARG
JAE DISPLAYARG_FINISHI1
LODSB
CALL PUTCH
DISPLAYARG_NEXTI1:INC BP
JMP DISPLAYARG_FORI1
DISPLAYARG_FINISHI1:CALL NEWLINE
MOV AX,WORD PTR STR_FNARG
CALL DHTOASC
CALL NEWLINE
MOV SI,OFFSET STR_FNARG
ADD SI,2
MOV BP,0
DISPLAYFNARG_FORI1:CMP BP,WORD PTR STR_FNARG
JAE DISPLAYFNARG_FINISHI1
LODSB
CALL PUTCH
DISPLAYFNARG_NEXTI1:INC BP
JMP DISPLAYFNARG_FORI1
DISPLAYFNARG_FINISHI1:CALL NEWLINE
MOV AX,WORD PTR STR_LNARG
CALL DHTOASC
CALL NEWLINE
MOV SI,OFFSET STR_LNARG
ADD SI,2
MOV BP,0
DISPLAYLNARG_FORI1:CMP BP,WORD PTR STR_LNARG
JAE DISPLAYLNARG_FINISHI1
LODSB
CALL PUTCH
DISPLAYLNARG_NEXTI1:INC BP
JMP DISPLAYLNARG_FORI1
DISPLAYLNARG_FINISHI1:CALL NEWLINE
MOV AX,WORD PTR NUM_LNARG
CALL DHTOASC
CALL NEWLINE
DISPLAYARG_OK:POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
DISPLAYARG ENDP
GETLNBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV NUM_BX,BX
MOV NUM_DX,DX
MOV DI,DX
MOV WORD PTR [DI],0
ADD DX,2
MOV CX,256
MOV AH,3FH
INT 21H
JC GETLNBUF_READERR
CMP AX,0
JZ GETLNBUF_FINISH
MOV BP,AX
MOV BX,NUM_DX
MOV SI,0
MOV DI,0
GETLNBUF_FORI1:CMP SI,BP
JAE GETLNBUF_FINISHI1
MOV AL,[BX][DI+2]
CMP AL,LF
JZ GETLNBUF_NEXTI2
JMP GETLNBUF_NEXTI1
GETLNBUF_NEXTI2:INC SI
INC DI
JMP GETLNBUF_FINISHI1
GETLNBUF_NEXTI1:INC SI
INC DI
JMP GETLNBUF_FORI1
GETLNBUF_FINISHI1:MOV WORD PTR [BX],SI
CMP SI,BP
JAE GETLNBUF_FINISH
MOV DX,SI
SUB DX,BP
MOV CX,0FFFFH
MOV BX,NUM_BX
MOV AX,4201H
INT 21H
JC GETLNBUF_FILEPTRERR
JMP GETLNBUF_FINISH
GETLNBUF_READERR:MOV DX,OFFSET MESS_READERR
CALL DISPMESS
STC
JMP GETLNBUF_OK
GETLNBUF_FILEPTRERR:MOV DX,OFFSET MESS_FILEPTRERR
CALL DISPMESS
STC
JMP GETLNBUF_OK
GETLNBUF_FINISH:CLC
GETLNBUF_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
GETLNBUF ENDP
DISPLAYLINE PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DI,DX
MOV BP,WORD PTR [DI]
ADD DI,2
MOV SI,0
DISPLAYLINE_FORI1:CMP SI,BP
JAE DISPLAYLINE_OK
MOV AL,[DI]
MOV DL,AL
MOV AH,2
INT 21H
DISPLAYLINE_NEXTI1:INC SI
INC DI
JMP DISPLAYLINE_FORI1
DISPLAYLINE_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DISPLAYLINE ENDP
DISPLAYFILE PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
MOV AX,DSEG
MOV DS,AX
MOV ES,AX
CLD
MOV DX,OFFSET STR_FNARG
ADD DX,2
MOV AX,3D00H
INT 21H
JNC DISPLAYFILE_OPENOKSRC
DISPLAYFILE_OPENERRSRC:MOV DX,OFFSET MESS_OPENERR
CALL DISPMESS
JMP DISPLAYFILE_OK
DISPLAYFILE_OPENOKSRC:MOV HANDLE_FNARG,AX
DISPLAYFILE_RWBUF:MOV BP,0
DISPLAYFILE_FORI1:CMP BP,WORD PTR NUM_LNARG
JAE DISPLAYFILE_FINISHI1
MOV DX,OFFSET FILEBUF_RW
MOV BX,HANDLE_FNARG
CALL GETLNBUF
JC DISPLAYFILE_READERR
MOV AX,WORD PTR FILEBUF_RW
CMP AX,0
JZ DISPLAYFILE_RWFINISH
MOV DX,OFFSET FILEBUF_RW
CALL DISPLAYLINE
DISPLAYFILE_NEXTI1:INC BP
JMP DISPLAYFILE_FORI1
DISPLAYFILE_FINISHI1:CALL GETCH
CMP AX,011BH
JZ DISPLAYFILE_RWFINISH
CMP AX,2106H
JZ DISPLAYFILE_RWBUF
CMP AX,5000H
JZ DISPLAYFILE_DOWN
JMP DISPLAYFILE_FINISHI1
DISPLAYFILE_DOWN:MOV DX,OFFSET FILEBUF_RW
MOV BX,HANDLE_FNARG
CALL GETLNBUF
JC DISPLAYFILE_READERR
MOV AX,WORD PTR FILEBUF_RW
CMP AX,0
JZ DISPLAYFILE_RWFINISH
MOV DX,OFFSET FILEBUF_RW
CALL DISPLAYLINE
DISPLAYFILE_DOWNFINISH:CALL GETCH
CMP AX,011BH
JZ DISPLAYFILE_RWFINISH
CMP AX,2106H
JZ DISPLAYFILE_RWBUF
CMP AX,5000H
JZ DISPLAYFILE_DOWN
JMP DISPLAYFILE_DOWNFINISH
DISPLAYFILE_READERR:MOV DX,OFFSET MESS_GETLNERR
CALL DISPMESS
DISPLAYFILE_RWFINISH:MOV BX,HANDLE_FNARG
MOV AH,3EH
INT 21H
DISPLAYFILE_OK:POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
DISPLAYFILE ENDP
DISPLAYFILEALL PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
MOV AX,DSEG
MOV DS,AX
MOV ES,AX
CLD
MOV DX,OFFSET STR_FNARG
ADD DX,2
MOV AX,3D00H
INT 21H
JNC DISPLAYFILEALL_OPENOKSRC
DISPLAYFILEALL_OPENERRSRC:MOV DX,OFFSET MESS_OPENERR
CALL DISPMESS
JMP DISPLAYFILEALL_OK
DISPLAYFILEALL_OPENOKSRC:MOV HANDLE_FNARG,AX
DISPLAYFILEALL_RWBUF:MOV BP,0
DISPLAYFILEALL_FORI1:CMP BP,25
JAE DISPLAYFILEALL_FINISHI1
MOV DX,OFFSET FILEBUF_RW
MOV BX,HANDLE_FNARG
CALL GETLNBUF
JC DISPLAYFILEALL_READERR
MOV AX,WORD PTR FILEBUF_RW
CMP AX,0
JZ DISPLAYFILEALL_RWFINISH
MOV DX,OFFSET FILEBUF_RW
CALL DISPLAYLINE
DISPLAYFILEALL_NEXTI1:INC BP
JMP DISPLAYFILEALL_FORI1
DISPLAYFILEALL_FINISHI1:JMP DISPLAYFILEALL_RWBUF
DISPLAYFILEALL_READERR:MOV DX,OFFSET MESS_GETLNERR
CALL DISPMESS
DISPLAYFILEALL_RWFINISH:MOV BX,HANDLE_FNARG
MOV AH,3EH
INT 21H
DISPLAYFILEALL_OK:POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
DISPLAYFILEALL ENDP
CSEG ENDS
END START
验证GETCH采用INT 21H的8号键盘输入功能
改为判断AL是否为1BH、06H、50H
调用GETCH，如果AL=0，表示用户曾按过一个扩展键，在下一次调用该功能时返回扩展键的扫描码。
WINTOP = 0
WINLEFT = 0
WINBOTTOM = 24
WINRIGHT = 79
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ALTF1 = 6800H
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
STR_ARG DB 256 DUP (0)
STR_FNARG DB 64 DUP (0)
STR_LNARG DB 16 DUP (0)
NUM_LNARG DW 0
NUM_BP DW 0
NUM_DI DW 0
NUM_SI DW 0
NUM_DX DW 0
NUM_CX DW 0
NUM_BX DW 0
NUM_AX DW 0
RES_DX DW 0
RES_CX DW 0
RES_BX DW 0
RES_AX DW 0
VAL_DX DW 0
VAL_CX DW 0
VAL_BX DW 0
VAL_AX DW 0
MUL_TABLE DD 1,10,100,1000,10000,100000,1000000,10000000,100000000
FILEBUF_RW DB 512 DUP (0)
HANDLE_FNARG DW 0
MESS_OPENERR DB 'Can not open file',07H,'$'
MESS_READERR DB 'Reading error',07h,'$'
MESS_FILEPTRERR DB 'Can not adjust file pointer',07H,'$'
MESS_GETLNERR DB 'Reading one line error',07h,'$'
MESS_PARAMISS DB 'Required parameter missing',07h,'$'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
OLD16H DD ?
OLD1BH DD ?
NEW16H:PUSH BP
MOV BP,SP
PUSH BX
PUSH DS
PUSH CS
POP DS
CMP AH,10H
JZ PKEY
CMP AH,11H
JZ PKEY2
CMP AH,0
JZ PKEY
CMP AH,1
JZ PKEY2
PUSHF
CALL DWORD PTR DS:[0]
PUSHF
POP BX
MOV WORD PTR SS:[BP+6],BX
POP DS
POP BX
POP BP
IRET
PKEY:PUSH AX
PUSHF
CALL DWORD PTR DS:[0]
PUSHF
POP BX
MOV WORD PTR SS:[BP+6],BX
CMP AL,03H
JZ PKEY_NEXT
CMP AX,0300H
JZ PKEY_NEXT
CMP AX,0000H
JZ PKEY_NEXT
ADD SP,2
POP DS
POP BX
POP BP
IRET
PKEY_NEXT:POP AX
JMP PKEY
PKEY2:PUSH AX
PUSHF
CALL DWORD PTR DS:[0]
PUSHF
POP BX
MOV WORD PTR SS:[BP+6],BX
JZ PKEY6
CMP AL,03H
JZ PKEY4
CMP AX,0300H
JZ PKEY4
CMP AX,0000H
JZ PKEY4
JMP PKEY5
PKEY4:XOR AH,AH
PUSHF
CALL DWORD PTR DS:[0]
POP AX
JMP PKEY2
PKEY5:ADD SP,2
POP DS
POP BX
POP BP
IRET
PKEY6:ADD SP,2
POP DS
POP BX
POP BP
IRET
NEW1BH:IRET
START:CALL CONVERTARG
ASSUME DS:CSEG
PUSH CS
POP DS
MOV AX,3516H
INT 21H
MOV WORD PTR OLD16H,BX
MOV WORD PTR OLD16H+2,ES
MOV AX,351BH
INT 21H
MOV WORD PTR OLD1BH,BX
MOV WORD PTR OLD1BH+2,ES
MOV DX,OFFSET NEW16H
MOV AX,2516H
INT 21H
MOV DX,OFFSET NEW1BH
MOV AX,251BH
INT 21H
ASSUME DS:DSEG
MOV AX,DSEG
MOV DS,AX
MOV AX,WORD PTR STR_ARG
CMP AX,0
JZ PARAMISS
MOV AX,WORD PTR NUM_LNARG
CMP AX,0
JZ DISPLAYALL
CALL DISPLAYFILE
JMP DISPLAYFINISH
DISPLAYALL:CALL DISPLAYFILEALL
JMP DISPLAYFINISH
PARAMISS:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESS_PARAMISS
CALL DISPMESS
DISPLAYFINISH:ASSUME DS:CSEG
PUSH CS
POP DS
LDS DX,OLD1BH
MOV AX,251BH
INT 21H
PUSH CS
POP DS
LDS DX,OLD16H
MOV AX,2516H
INT 21H
ASSUME DS:DSEG
MOV AH,4CH
INT 21H
ATOBIN PROC
SUB AL,30H
CMP AL,9
JBE ATOBIN_OK
SUB AL,7
CMP AL,15
JBE ATOBIN_OK
SUB AL,20H
ATOBIN_OK:RET
ATOBIN ENDP
DTOBIN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DI,SI
ADD DI,CX
DEC DI
MOV BP,0
MOV VAL_AX,0
MOV VAL_DX,0
DTOBIN_FORJ:CMP DI,SI
JB DTOBIN_OK
MOV AL,DS:[DI]
CALL ATOBIN
MOV AH,0
MOV BX,AX
MOV AX,0
MOV DX,WORD PTR MUL_TABLE[BP]
MOV CX,WORD PTR MUL_TABLE[BP+2]
CALL MULDW
ADD VAL_AX,AX
ADC VAL_DX,BX
DTOBIN_NEXTJ:DEC DI
INC BP
INC BP
INC BP
INC BP
JMP DTOBIN_FORJ
DTOBIN_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOBIN ENDP
MULDW PROC
MOV NUM_AX,AX
MOV NUM_BX,BX
MOV NUM_CX,CX
MOV NUM_DX,DX
MOV AX,NUM_AX
MOV BX,NUM_CX
MUL BX
MOV RES_DX,DX
MOV RES_CX,AX
MOV AX,NUM_BX
MOV BX,NUM_DX
MUL BX
MOV RES_BX,DX
MOV RES_AX,AX
MOV AX,NUM_AX
MOV BX,NUM_DX
MUL BX
ADD AX,RES_BX
ADC WORD PTR RES_CX,0
ADC WORD PTR RES_DX,0
ADD DX,RES_CX
ADC WORD PTR RES_DX,0
MOV RES_CX,DX
MOV RES_BX,AX
MOV AX,NUM_BX
MOV BX,NUM_CX
MUL BX
ADD AX,RES_BX
ADC WORD PTR RES_CX,0
ADC WORD PTR RES_DX,0
ADD DX,RES_CX
ADC WORD PTR RES_DX,0
MOV RES_CX,DX
MOV RES_BX,AX
MOV DX,RES_DX
MOV CX,RES_CX
MOV BX,RES_BX
MOV AX,RES_AX
RET
MULDW ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
HTOASC PROC
AND AL,0FH
ADD AL,30H
CMP AL,39H
JA HTOASC_NODEC
JMP HTOASC_OK
HTOASC_NODEC:ADD AL,7
HTOASC_OK:RET
HTOASC ENDP
HTOASCDA PROC
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
RET
HTOASCDA ENDP
AHTOASC PROC
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL HTOASCDA
XCHG AH,AL
CALL HTOASCDA
RET
AHTOASC ENDP
DAHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DAHTOASC ENDP
DHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH AX
XCHG AH,AL
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DHTOASC ENDP
MEMCOPY PROC
PUSHF
PUSH CX
PUSH SI
PUSH DI
CLD
TEST SI,1
JZ MEMCOPY_1
MOVSB
DEC CX
MEMCOPY_1:SHR CX,1
REP MOVSW
JNC MEMCOPY_OK
MOVSB
MEMCOPY_OK:POP DI
POP SI
POP CX
POPF
RET
MEMCOPY ENDP
STRCHRNZ PROC
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
MOV DX,SI
MOV BL,AL
CLD
TEST SI,1
JZ STRCHRNZ_1
LODSB
AND AL,AL
JZ STRCHRNZ_NOTF
CMP AL,BL
JNZ STRCHRNZ_FIND1
STRCHRNZ_1:LODSW
AND AL,AL
JZ STRCHRNZ_NOTF
CMP AL,BL
JNZ STRCHRNZ_FIND2
AND AH,AH
JZ STRCHRNZ_NOTF
CMP AH,BL
JNZ STRCHRNZ_FIND1
JMP STRCHRNZ_1
STRCHRNZ_NOTF:STC
JMP SHORT STRCHRNZ_OK
STRCHRNZ_FIND1:LEA AX,[SI-1]
SUB AX,DX
JMP SHORT STRCHRNZ_OK
STRCHRNZ_FIND2:LEA AX,[SI-2]
SUB AX,DX
STRCHRNZ_OK:POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
RET
STRCHRNZ ENDP
STRCHRZ PROC
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
MOV DX,SI
MOV BL,AL
CLD
TEST SI,1
JZ STRCHRZ_1
LODSB
AND AL,AL
JZ STRCHRZ_NOTF
CMP AL,BL
JZ STRCHRZ_FIND1
STRCHRZ_1:LODSW
AND AL,AL
JZ STRCHRZ_NOTF
CMP AL,BL
JZ STRCHRZ_FIND2
AND AH,AH
JZ STRCHRZ_NOTF
CMP AH,BL
JZ STRCHRZ_FIND1
JMP STRCHRZ_1
STRCHRZ_NOTF:STC
JMP SHORT STRCHRZ_OK
STRCHRZ_FIND1:LEA AX,[SI-1]
SUB AX,DX
JMP SHORT STRCHRZ_OK
STRCHRZ_FIND2:LEA AX,[SI-2]
SUB AX,DX
STRCHRZ_OK:POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
RET
STRCHRZ ENDP
CONVERTARG PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
CLD
MOV SI,80H
LODSB
MOV CL,AL
XOR CH,CH
CMP CX,0
JZ CONVERTARG_OK
MOV AX,DSEG
MOV ES,AX
MOV DI,OFFSET STR_ARG
ADD DI,2
CALL MEMCOPY
MOV AX,DSEG
MOV DS,AX
MOV WORD PTR STR_ARG,CX
ADD DI,CX
MOV BYTE PTR DS:[DI],0
MOV SI,OFFSET STR_ARG
ADD SI,2
MOV AL,20H
CALL STRCHRNZ
ADD SI,AX
MOV AL,20H
CALL STRCHRZ
MOV DI,OFFSET STR_FNARG
ADD DI,2
MOV WORD PTR STR_FNARG,AX
MOV CX,AX
CALL MEMCOPY
ADD DI,CX
MOV BYTE PTR DS:[DI],0
ADD SI,CX
MOV AL,20H
CALL STRCHRNZ
ADD SI,AX
MOV AL,20H
CALL STRCHRZ
JC CONVERTARG_LNARGCOPY
MOV DI,OFFSET STR_LNARG
ADD DI,2
MOV WORD PTR STR_LNARG,AX
MOV CX,AX
CALL MEMCOPY
ADD DI,CX
MOV BYTE PTR DS:[DI],0
JMP CONVERTARG_LNARGTOBIN
CONVERTARG_LNARGCOPY:MOV AX,OFFSET STR_ARG
ADD AX,2
ADD AX,WORD PTR STR_ARG
SUB AX,SI
MOV DI,OFFSET STR_LNARG
ADD DI,2
MOV WORD PTR STR_LNARG,AX
MOV CX,AX
CALL MEMCOPY
ADD DI,CX
MOV BYTE PTR DS:[DI],0
CONVERTARG_LNARGTOBIN:MOV SI,OFFSET STR_LNARG
ADD SI,2
MOV CX,WORD PTR STR_LNARG
CALL DTOBIN
MOV AX,VAL_AX
CMP AX,25
JB CONVERTARG_LNARGB25
MOV AX,24
MOV WORD PTR NUM_LNARG,AX
JMP CONVERTARG_OK
CONVERTARG_LNARGB25:CMP AX,1
JAE CONVERTARG_LNARGAE1
MOV AX,0
MOV WORD PTR NUM_LNARG,AX
JMP CONVERTARG_OK
CONVERTARG_LNARGAE1:MOV WORD PTR NUM_LNARG,AX
CONVERTARG_OK:POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
CONVERTARG ENDP
DISPLAYARG PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
MOV AX,DSEG
MOV DS,AX
MOV ES,AX
CLD
MOV AX,WORD PTR STR_ARG
CALL DHTOASC
CALL NEWLINE
MOV SI,OFFSET STR_ARG
ADD SI,2
MOV BP,0
DISPLAYARG_FORI1:CMP BP,WORD PTR STR_ARG
JAE DISPLAYARG_FINISHI1
LODSB
CALL PUTCH
DISPLAYARG_NEXTI1:INC BP
JMP DISPLAYARG_FORI1
DISPLAYARG_FINISHI1:CALL NEWLINE
MOV AX,WORD PTR STR_FNARG
CALL DHTOASC
CALL NEWLINE
MOV SI,OFFSET STR_FNARG
ADD SI,2
MOV BP,0
DISPLAYFNARG_FORI1:CMP BP,WORD PTR STR_FNARG
JAE DISPLAYFNARG_FINISHI1
LODSB
CALL PUTCH
DISPLAYFNARG_NEXTI1:INC BP
JMP DISPLAYFNARG_FORI1
DISPLAYFNARG_FINISHI1:CALL NEWLINE
MOV AX,WORD PTR STR_LNARG
CALL DHTOASC
CALL NEWLINE
MOV SI,OFFSET STR_LNARG
ADD SI,2
MOV BP,0
DISPLAYLNARG_FORI1:CMP BP,WORD PTR STR_LNARG
JAE DISPLAYLNARG_FINISHI1
LODSB
CALL PUTCH
DISPLAYLNARG_NEXTI1:INC BP
JMP DISPLAYLNARG_FORI1
DISPLAYLNARG_FINISHI1:CALL NEWLINE
MOV AX,WORD PTR NUM_LNARG
CALL DHTOASC
CALL NEWLINE
DISPLAYARG_OK:POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
DISPLAYARG ENDP
GETLNBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV NUM_BX,BX
MOV NUM_DX,DX
MOV DI,DX
MOV WORD PTR [DI],0
ADD DX,2
MOV CX,256
MOV AH,3FH
INT 21H
JC GETLNBUF_READERR
CMP AX,0
JZ GETLNBUF_FINISH
MOV BP,AX
MOV BX,NUM_DX
MOV SI,0
MOV DI,0
GETLNBUF_FORI1:CMP SI,BP
JAE GETLNBUF_FINISHI1
MOV AL,[BX][DI+2]
CMP AL,LF
JZ GETLNBUF_NEXTI2
JMP GETLNBUF_NEXTI1
GETLNBUF_NEXTI2:INC SI
INC DI
JMP GETLNBUF_FINISHI1
GETLNBUF_NEXTI1:INC SI
INC DI
JMP GETLNBUF_FORI1
GETLNBUF_FINISHI1:MOV WORD PTR [BX],SI
CMP SI,BP
JAE GETLNBUF_FINISH
MOV DX,SI
SUB DX,BP
MOV CX,0FFFFH
MOV BX,NUM_BX
MOV AX,4201H
INT 21H
JC GETLNBUF_FILEPTRERR
JMP GETLNBUF_FINISH
GETLNBUF_READERR:MOV DX,OFFSET MESS_READERR
CALL DISPMESS
STC
JMP GETLNBUF_OK
GETLNBUF_FILEPTRERR:MOV DX,OFFSET MESS_FILEPTRERR
CALL DISPMESS
STC
JMP GETLNBUF_OK
GETLNBUF_FINISH:CLC
GETLNBUF_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
GETLNBUF ENDP
DISPLAYLINE PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DI,DX
MOV BP,WORD PTR [DI]
ADD DI,2
MOV SI,0
DISPLAYLINE_FORI1:CMP SI,BP
JAE DISPLAYLINE_OK
MOV AL,[DI]
MOV DL,AL
MOV AH,2
INT 21H
DISPLAYLINE_NEXTI1:INC SI
INC DI
JMP DISPLAYLINE_FORI1
DISPLAYLINE_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DISPLAYLINE ENDP
DISPLAYFILE PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
MOV AX,DSEG
MOV DS,AX
MOV ES,AX
CLD
MOV DX,OFFSET STR_FNARG
ADD DX,2
MOV AX,3D00H
INT 21H
JNC DISPLAYFILE_OPENOKSRC
DISPLAYFILE_OPENERRSRC:MOV DX,OFFSET MESS_OPENERR
CALL DISPMESS
JMP DISPLAYFILE_OK
DISPLAYFILE_OPENOKSRC:MOV HANDLE_FNARG,AX
DISPLAYFILE_RWBUF:MOV BP,0
DISPLAYFILE_FORI1:CMP BP,WORD PTR NUM_LNARG
JAE DISPLAYFILE_FINISHI1
MOV DX,OFFSET FILEBUF_RW
MOV BX,HANDLE_FNARG
CALL GETLNBUF
JC DISPLAYFILE_READERR
MOV AX,WORD PTR FILEBUF_RW
CMP AX,0
JZ DISPLAYFILE_RWFINISH
MOV DX,OFFSET FILEBUF_RW
CALL DISPLAYLINE
DISPLAYFILE_NEXTI1:INC BP
JMP DISPLAYFILE_FORI1
DISPLAYFILE_FINISHI1:CALL GETCH
CMP AL,1BH
JZ DISPLAYFILE_RWFINISH
CMP AL,06H
JZ DISPLAYFILE_RWBUF
CMP AL,50H
JZ DISPLAYFILE_DOWN
JMP DISPLAYFILE_FINISHI1
DISPLAYFILE_DOWN:MOV DX,OFFSET FILEBUF_RW
MOV BX,HANDLE_FNARG
CALL GETLNBUF
JC DISPLAYFILE_READERR
MOV AX,WORD PTR FILEBUF_RW
CMP AX,0
JZ DISPLAYFILE_RWFINISH
MOV DX,OFFSET FILEBUF_RW
CALL DISPLAYLINE
DISPLAYFILE_DOWNFINISH:CALL GETCH
CMP AL,1BH
JZ DISPLAYFILE_RWFINISH
CMP AL,06H
JZ DISPLAYFILE_RWBUF
CMP AL,50H
JZ DISPLAYFILE_DOWN
JMP DISPLAYFILE_DOWNFINISH
DISPLAYFILE_READERR:MOV DX,OFFSET MESS_GETLNERR
CALL DISPMESS
DISPLAYFILE_RWFINISH:MOV BX,HANDLE_FNARG
MOV AH,3EH
INT 21H
DISPLAYFILE_OK:POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
DISPLAYFILE ENDP
DISPLAYFILEALL PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
MOV AX,DSEG
MOV DS,AX
MOV ES,AX
CLD
MOV DX,OFFSET STR_FNARG
ADD DX,2
MOV AX,3D00H
INT 21H
JNC DISPLAYFILEALL_OPENOKSRC
DISPLAYFILEALL_OPENERRSRC:MOV DX,OFFSET MESS_OPENERR
CALL DISPMESS
JMP DISPLAYFILEALL_OK
DISPLAYFILEALL_OPENOKSRC:MOV HANDLE_FNARG,AX
DISPLAYFILEALL_RWBUF:MOV BP,0
DISPLAYFILEALL_FORI1:CMP BP,25
JAE DISPLAYFILEALL_FINISHI1
MOV DX,OFFSET FILEBUF_RW
MOV BX,HANDLE_FNARG
CALL GETLNBUF
JC DISPLAYFILEALL_READERR
MOV AX,WORD PTR FILEBUF_RW
CMP AX,0
JZ DISPLAYFILEALL_RWFINISH
MOV DX,OFFSET FILEBUF_RW
CALL DISPLAYLINE
DISPLAYFILEALL_NEXTI1:INC BP
JMP DISPLAYFILEALL_FORI1
DISPLAYFILEALL_FINISHI1:JMP DISPLAYFILEALL_RWBUF
DISPLAYFILEALL_READERR:MOV DX,OFFSET MESS_GETLNERR
CALL DISPMESS
DISPLAYFILEALL_RWFINISH:MOV BX,HANDLE_FNARG
MOV AH,3EH
INT 21H
DISPLAYFILEALL_OK:POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
DISPLAYFILEALL ENDP
CSEG ENDS
END START
题6.22通过编写一个TSR程序的方法，稍稍改变BIOS的键盘中断处理程序，使得DOS平台上的应用程序无法获得大写字母A。
当按A键时，应用程序只能获得小写字母a。
BUFF_HEAD = 1AH
BUFF_TAIL = 1CH
BUFF_START = 1EH
BUFF_END = 3EH
CTRL_F8 = 6500H
COLOR = 07H
DPAGE = 0
ROW = 12
COLUMN = 28
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
CSEG SEGMENT
ASSUME CS:CSEG,DS:CSEG
OLD09H DD ?
NEW09H_BEGIN:PUSH BP
MOV BP,SP
PUSH BX
PUSHF
CALL DWORD PTR CS:[0]
PUSHF
POP BX
MOV WORD PTR SS:[BP+6],BX
STI
PUSH DS
PUSH AX
PUSH BX
MOV AX,0040H
MOV DS,AX
MOV BX,DS:[BUFF_HEAD]
NEW09H_FORI1:CMP BX,DS:[BUFF_TAIL]
JZ NEW09H_OK
MOV AX,DS:[BX]
CMP AX,1E41H
JNZ NEW09H_NEXTI1
MOV AX,1E61H
MOV DS:[BX],AX
NEW09H_NEXTI1:INC BX
INC BX
CMP BX,BUFF_END
JNZ NEW09H_NEXTI1OK
MOV BX,BUFF_START
NEW09H_NEXTI1OK:JMP NEW09H_FORI1
NEW09H_OK:POP BX
POP AX
POP DS
POP BX
POP BP
IRET
START:PUSH CS
POP DS
CALL CLEARBUFKB
MOV AX,3509H
INT 21H
MOV WORD PTR OLD09H,BX
MOV WORD PTR OLD09H+2,ES
MOV DX,OFFSET NEW09H_BEGIN
MOV AX,2509H
INT 21H
MOV DX,OFFSET START
ADD DX,15
MOV CL,4
SHR DX,CL
ADD DX,10H
MOV AL,0
MOV AH,31H
INT 21H
CLEARBUFKB PROC
PUSH AX
CLEARBUFKB_S:MOV AH,1
INT 16H
JZ CLEARBUFKB_OK
MOV AH,0
INT 16H
JMP CLEARBUFKB_S
CLEARBUFKB_OK:POP AX
RET
CLEARBUFKB ENDP
CSEG ENDS
END START
题6.23通过编写一个TSR程序的方法，改变BIOS的键盘I/O程序，使得DOS平台上的应用程序无法获得大写字母。
当按大写字母键时，应用程序只能获得对应的小写字母。
COLOR = 07H
DPAGE = 0
ROW = 12
COLUMN = 28
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
CSEG SEGMENT
ASSUME CS:CSEG,DS:CSEG
OLD16H DD ?
NEW16H_BEGIN:PUSH BP
MOV BP,SP
PUSH BX
PUSH DX
MOV DX,AX
PUSHF
CALL DWORD PTR CS:[0]
PUSHF
POP BX
MOV WORD PTR SS:[BP+6],BX
CMP DH,00H
JZ NEW16H_UPTOLOW
CMP DH,10H
JZ NEW16H_UPTOLOW
CMP DH,01H
JZ NEW16H_UPTOLOW
CMP DH,11H
JZ NEW16H_UPTOLOW
JMP NEW16H_OK
NEW16H_UPTOLOW:CALL ISUPPER
JC NEW16H_OK
ADD AL,20H
NEW16H_OK:POP DX
POP BX
POP BP
IRET
ISUPPER PROC
CMP AL,'A'
JB ISUPPER_NOUPPER
CMP AL,'Z'
JA ISUPPER_NOUPPER
CLC
JMP ISUPPER_OK
ISUPPER_NOUPPER:STC
ISUPPER_OK:RET
ISUPPER ENDP
START:PUSH CS
POP DS
MOV AX,3516H
INT 21H
MOV WORD PTR OLD16H,BX
MOV WORD PTR OLD16H+2,ES
MOV DX,OFFSET NEW16H_BEGIN
MOV AX,2516H
INT 21H
MOV DX,OFFSET START
ADD DX,15
MOV CL,4
SHR DX,CL
ADD DX,10H
MOV AL,0
MOV AH,31H
INT 21H
CSEG ENDS
END START
题6.24通过编写一个TSR程序的方法，改变BIOS的显示I/O程序，使得通过BIOS显示I/O程序实现显示的应用程序无法显示大写字母。
当显示大写字母时，只显示出对应的小写字母。
10H号中断处理程序中13H号功能仍然可以显示大写字母
在新的10H号中断处理程序中调用了原来BIOS的10H号中断处理程序，并且在调用之前判断是否为大写字母。
如果是大写字母，则转换为小写字母。
COLOR = 07H
DPAGE = 0
ROW = 12
COLUMN = 28
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
CSEG SEGMENT
ASSUME CS:CSEG,DS:CSEG
OLD10H DD ?
NEW10H_BEGIN:PUSH BP
MOV BP,SP
PUSH BX
PUSH SI
MOV SI,AX
PUSH DI
PUSHF
POP DI
AND SI,0FF00H
CMP SI,0900H
JZ NEW10H_CHECK
CMP SI,0A00H
JZ NEW10H_CHECK
CMP SI,0E00H
JZ NEW10H_CHECK
JMP NEW10H_NOCHECK
NEW10H_CHECK:CALL ISUPPER
JC NEW10H_NOCHECK
ADD AL,20H
NEW10H_NOCHECK:PUSH DI
POPF
PUSHF
CALL DWORD PTR CS:[0]
PUSHF
POP BX
MOV WORD PTR SS:[BP+6],BX
NEW10H_OK:POP DI
POP SI
POP BX
POP BP
IRET
ISUPPER PROC
CMP AL,'A'
JB ISUPPER_NOUPPER
CMP AL,'Z'
JA ISUPPER_NOUPPER
CLC
JMP ISUPPER_OK
ISUPPER_NOUPPER:STC
ISUPPER_OK:RET
ISUPPER ENDP
START:PUSH CS
POP DS
MOV AX,3510H
INT 21H
MOV WORD PTR OLD10H,BX
MOV WORD PTR OLD10H+2,ES
MOV DX,OFFSET NEW10H_BEGIN
MOV AX,2510H
INT 21H
MOV DX,OFFSET START
ADD DX,15
MOV CL,4
SHR DX,CL
ADD DX,10H
MOV AL,0
MOV AH,31H
INT 21H
CSEG ENDS
END START
题6.25通过编写一个TSR程序的方法，改变BIOS的打印I/O程序，使得小写字母的输出变为大写字母的输出，当打印输出ESC+A时，恢复正常。
ESC键的ASCII码为1BH，大写字母A的ASCII码为41H
COLOR = 07H
DPAGE = 0
ROW = 12
COLUMN = 28
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
CSEG SEGMENT
ASSUME CS:CSEG,DS:CSEG
OLD17H DD ?
PREV_AX DW 0
ESC_UPA DW 0
NEW17H_BEGIN:PUSH BP
MOV BP,SP
PUSH BX
PUSH DI
PUSHF
POP DI
CMP AH,00H
JNZ NEW17H_PRINT
CMP WORD PTR CS:ESC_UPA,0
JNZ NEW17H_PRINT
CMP WORD PTR CS:PREV_AX,001BH
JZ NEW17H_PREVESC
MOV WORD PTR CS:PREV_AX,AX
JMP NEW17H_LTOU
NEW17H_PREVESC:CMP AX,0041H
JZ NEW17H_UPA
MOV WORD PTR CS:PREV_AX,AX
JMP NEW17H_LTOU
NEW17H_UPA:MOV WORD PTR CS:ESC_UPA,1
JMP NEW17H_PRINT
NEW17H_LTOU:CALL ISLOWER
JC NEW17H_PRINT
SUB AL,20H
NEW17H_PRINT:PUSH DI
POPF
PUSHF
CALL DWORD PTR CS:[0]
PUSHF
POP BX
MOV WORD PTR SS:[BP+6],BX
NEW17H_OK:POP DI
POP BX
POP BP
IRET
ISLOWER PROC
CMP AL,'a'
JB ISLOWER_NOLOWER
CMP AL,'z'
JA ISLOWER_NOLOWER
CLC
JMP ISLOWER_OK
ISLOWER_NOLOWER:STC
ISLOWER_OK:RET
ISLOWER ENDP
START:PUSH CS
POP DS
MOV WORD PTR CS:PREV_AX,0
MOV WORD PTR CS:ESC_UPA,0
MOV AX,3517H
INT 21H
MOV WORD PTR OLD17H,BX
MOV WORD PTR OLD17H+2,ES
MOV DX,OFFSET NEW17H_BEGIN
MOV AX,2517H
INT 21H
MOV DX,OFFSET START
ADD DX,15
MOV CL,4
SHR DX,CL
ADD DX,10H
MOV AL,0
MOV AH,31H
INT 21H
CSEG ENDS
END START
题6.26通过编写一个 TSR程序的方法，使得屏幕上不出现小写字母。所有欲显示的小写字母均被替换成对应的大写字母。只考虑字符显示方式。
COUNT_VAL= 18
COLOR = 07H
DPAGE = 0
ROW = 12
COLUMN = 28
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
CSEG SEGMENT
ASSUME CS:CSEG,DS:CSEG
OLD1CH DD ?
COUNT DW COUNT_VAL
NEW1CH_BEGIN:PUSH BP
MOV BP,SP
PUSH BX
PUSH DI
PUSHF
POP DI
CMP WORD PTR CS:COUNT,0
JZ NEW1CH_CONVERT
DEC WORD PTR CS:COUNT
JMP NEW1CH_FINISH
NEW1CH_CONVERT:MOV WORD PTR CS:COUNT,COUNT_VAL
STI
CALL CONVERTSCREEN
NEW1CH_FINISH:PUSH DI
POPF
PUSHF
CALL DWORD PTR CS:[0]
PUSHF
POP BX
MOV WORD PTR SS:[BP+6],BX
NEW1CH_OK:POP DI
POP BX
POP BP
IRET
CONVERTSCREEN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
MOV AH,0FH
INT 10H
MOV CL,AH
MOV CH,25
MOV DI,CX
MOV AH,3
INT 10H
MOV CX,DI
MOV BP,DX
MOV DH,0
CONVERTSCREEN_FORI1:CMP DH,CH
JAE CONVERTSCREEN_FINISHI1
MOV DL,0
CONVERTSCREEN_FORJ1:CMP DL,CL
JAE CONVERTSCREEN_NEXTI1
MOV AH,2
INT 10H
MOV AH,8
INT 10H
CALL ISLOWER
JC CONVERTSCREEN_NEXTJ1
SUB AL,20H
MOV CX,1
MOV AH,0AH
INT 10H
MOV CX,DI
CONVERTSCREEN_NEXTJ1:INC DL
JMP CONVERTSCREEN_FORJ1
CONVERTSCREEN_NEXTI1:INC DH
JMP CONVERTSCREEN_FORI1
CONVERTSCREEN_FINISHI1:MOV DX,BP
MOV AH,2
INT 10H
CONVERTSCREEN_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
CONVERTSCREEN ENDP
ISLOWER PROC
CMP AL,'a'
JB ISLOWER_NOLOWER
CMP AL,'z'
JA ISLOWER_NOLOWER
CLC
JMP ISLOWER_OK
ISLOWER_NOLOWER:STC
ISLOWER_OK:RET
ISLOWER ENDP
START:PUSH CS
POP DS
MOV WORD PTR CS:COUNT,COUNT_VAL
MOV AX,351CH
INT 21H
MOV WORD PTR OLD1CH,BX
MOV WORD PTR OLD1CH+2,ES
MOV DX,OFFSET NEW1CH_BEGIN
MOV AX,251CH
INT 21H
MOV DX,OFFSET START
ADD DX,15
MOV CL,4
SHR DX,CL
ADD DX,10H
MOV AL,0
MOV AH,31H
INT 21H
CSEG ENDS
END START
题6.27通过编写一个TSR程序的方法，当按下Ctrl+F1键时，把屏幕上的显示信息保存到文件SCREEN中。
CTRL-F1键的扫描码和ASCII码为5E00H
BUFF_HEAD = 1AH
BUFF_TAIL = 1CH
BUFF_START = 1EH
BUFF_END = 3EH
CTRL_F1 = 5E00H
COLOR = 07H
DPAGE = 0
ROW = 12
COLUMN = 28
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
CSEG SEGMENT
ASSUME CS:CSEG,DS:CSEG
OLD09H DD ?
NUM_BX DW 0
HANDLE_SCREEN DW 0
STR_SCREEN DB 'SCREEN',0,0
SCREEN_LNBUF DB 128 DUP (0)
NEW09H_BEGIN:PUSH BP
MOV BP,SP
PUSH BX
PUSHF
CALL DWORD PTR CS:[0]
PUSHF
POP BX
MOV WORD PTR SS:[BP+6],BX
STI
PUSH DS
PUSH AX
PUSH BX
MOV AX,0040H
MOV DS,AX
MOV BX,DS:[BUFF_HEAD]
NEW09H_FORI1:CMP BX,DS:[BUFF_TAIL]
JZ NEW09H_OK
MOV AX,DS:[BX]
CMP AX,CTRL_F1
JNZ NEW09H_NEXTI1
CALL WRITESCREEN
JMP NEW09H_OK
NEW09H_NEXTI1:INC BX
INC BX
CMP BX,BUFF_END
JNZ NEW09H_NEXTI1OK
MOV BX,BUFF_START
NEW09H_NEXTI1OK:JMP NEW09H_FORI1
NEW09H_OK:POP BX
POP AX
POP DS
POP BX
POP BP
IRET
WRITESCREEN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
PUSH CS
POP DS
MOV DX,OFFSET STR_SCREEN
MOV CX,0
MOV AH,3CH
INT 21H
JNC WRITESCREEN_CREAOK
WRITESCREEN_CREAERR:JMP WRITESCREEN_OK
WRITESCREEN_CREAOK:MOV HANDLE_SCREEN,AX
MOV AH,0FH
INT 10H
MOV WORD PTR CS:NUM_BX,BX
MOV CL,AH
MOV CH,25
MOV DI,CX
MOV AH,3
INT 10H
MOV CX,DI
MOV BP,DX
MOV DH,0
WRITESCREEN_FORI1:CMP DH,CH
JAE WRITESCREEN_FINISHI1
MOV SI,OFFSET SCREEN_LNBUF
MOV DL,0
WRITESCREEN_FORJ1:CMP DL,CL
JAE WRITESCREEN_FINISHJ1
MOV AH,2
INT 10H
MOV AH,8
INT 10H
CALL ALTOASC
MOV DS:[SI],AL
INC SI
WRITESCREEN_NEXTJ1:INC DL
JMP WRITESCREEN_FORJ1
WRITESCREEN_FINISHJ1:MOV BYTE PTR DS:[SI],CR
INC SI
MOV BYTE PTR DS:[SI],LF
INC SI
MOV SI,DX
ADD DL,2
MOV CL,DL
MOV CH,0
MOV DX,OFFSET SCREEN_LNBUF
MOV BX,HANDLE_SCREEN
MOV AH,40H
INT 21H
JC WRITESCREEN_FINISHI1
MOV BX,WORD PTR CS:NUM_BX
MOV CX,DI
MOV DX,SI
WRITESCREEN_NEXTI1:INC DH
JMP WRITESCREEN_FORI1
WRITESCREEN_FINISHI1:MOV BX,WORD PTR CS:NUM_BX
MOV DX,BP
MOV AH,2
INT 10H
MOV BX,HANDLE_SCREEN
MOV AH,3EH
INT 21H
WRITESCREEN_OK:POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
WRITESCREEN ENDP
ALTOASC PROC
CMP AL,20H
JB ALTOASC1
CMP AL,7EH
JA ALTOASC1
JMP ALTOASC_OK
ALTOASC1:MOV AL,'.'
ALTOASC_OK:RET
ALTOASC ENDP
START:PUSH CS
POP DS
MOV AX,3509H
INT 21H
MOV WORD PTR OLD09H,BX
MOV WORD PTR OLD09H+2,ES
MOV DX,OFFSET NEW09H_BEGIN
MOV AX,2509H
INT 21H
MOV DX,OFFSET START
ADD DX,15
MOV CL,4
SHR DX,CL
ADD DX,10H
MOV AL,0
MOV AH,31H
INT 21H
CSEG ENDS
END START
题6.28通过编写一个TSR程序的方法，使得系统报时。
COUNT_VAL= 18
COLOR = 07H
DPAGE = 0
ROW = 12
COLUMN = 28
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
CSEG SEGMENT
ASSUME CS:CSEG,DS:CSEG
OLD1CH DD ?
CURSOR DW ?
COUNT DW COUNT_VAL
DATETIME_BUF DB 19 DUP (?)
NEW1CH_BEGIN:PUSH BP
MOV BP,SP
PUSH BX
PUSH DI
PUSHF
POP DI
CMP WORD PTR CS:COUNT,0
JZ NEW1CH_CONVERT
DEC WORD PTR CS:COUNT
JMP NEW1CH_FINISH
NEW1CH_CONVERT:MOV WORD PTR CS:COUNT,COUNT_VAL
STI
CALL CONVERTDATETIME
NEW1CH_FINISH:PUSH DI
POPF
PUSHF
CALL DWORD PTR CS:[0]
PUSHF
POP BX
MOV WORD PTR SS:[BP+6],BX
NEW1CH_OK:POP DI
POP BX
POP BP
IRET
CONVERTDATETIME PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
PUSH CS
POP DS
PUSH CS
POP ES
MOV SI,offset DATETIME_BUF
CALL GETDATETIME
MOV AH,0FH
INT 10H
MOV AH,3
INT 10H
MOV WORD PTR CS:CURSOR,DX
MOV BP,offset DATETIME_BUF
MOV DH,ROW
MOV DL,COLUMN
MOV BL,COLOR
MOV CX,19
MOV AL,0
MOV AH,13H
INT 10H
MOV DX,WORD PTR CS:CURSOR
MOV AH,2
INT 10H
MOV AL,BELLCH
MOV AH,0EH
INT 10H
CONVERTDATETIME_OK:POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
CONVERTDATETIME ENDP
GETDATETIME PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV AH,4
INT 1AH
MOV AL,CH
CALL TTASC
MOV BYTE PTR DS:[SI],AH
MOV BYTE PTR DS:[SI+1],AL
MOV AL,CL
CALL TTASC
MOV BYTE PTR DS:[SI+2],AH
MOV BYTE PTR DS:[SI+3],AL
MOV BYTE PTR DS:[SI+4],'-'
MOV AL,DH
CALL TTASC
MOV BYTE PTR DS:[SI+5],AH
MOV BYTE PTR DS:[SI+6],AL
MOV BYTE PTR DS:[SI+7],'-'
MOV AL,DL
CALL TTASC
MOV BYTE PTR DS:[SI+8],AH
MOV BYTE PTR DS:[SI+9],AL
MOV BYTE PTR DS:[SI+10],20H
MOV AH,2
INT 1AH
MOV AL,CH
CALL TTASC
MOV BYTE PTR DS:[SI+11],AH
MOV BYTE PTR DS:[SI+12],AL
MOV BYTE PTR DS:[SI+13],':'
MOV AL,CL
CALL TTASC
MOV BYTE PTR DS:[SI+14],AH
MOV BYTE PTR DS:[SI+15],AL
MOV BYTE PTR DS:[SI+16],':'
MOV AL,DH
CALL TTASC
MOV BYTE PTR DS:[SI+17],AH
MOV BYTE PTR DS:[SI+18],AL
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
GETDATETIME ENDP
TTASC PROC
MOV AH,AL
AND AL,0FH
SHR AH,1
SHR AH,1
SHR AH,1
SHR AH,1
ADD AX,3030H
RET
TTASC ENDP
START:PUSH CS
POP DS
MOV WORD PTR CS:COUNT,COUNT_VAL
MOV AX,351CH
INT 21H
MOV WORD PTR OLD1CH,BX
MOV WORD PTR OLD1CH+2,ES
MOV DX,OFFSET NEW1CH_BEGIN
MOV AX,251CH
INT 21H
MOV DX,OFFSET START
ADD DX,15
MOV CL,4
SHR DX,CL
ADD DX,10H
MOV AL,0
MOV AH,31H
INT 21H
CSEG ENDS
END START
第7章高级汇编语言技术
尽管汇编语言作为低级语言不可能象高级语言那样具有丰富的数据类型和方便灵活的表达方式，但汇编语言仍力求提供这方面的功能。
本章介绍汇编语言的一些高级技术：结构、宏和条件语句，利用它们可编写出更具适应性的汇编语言源程序。
7.1结构和记录
为了使程序员能更方便、更有效地对数据进行组织和描述，宏汇编语言除了提供定义简单数据变量的伪指令（如DB和DW等）外，
还提供了用于说明复杂数据类型的伪指令，利用这些伪指令能够说明复杂的数据类型，从而定义复杂的数据变量。
本节描述结构和记录并说明如何使用它们。
7.1.1结构
1.结构类型的说明
在描述结构型数据或使用结构型变量之前，需要说明结构类型。
用伪指令STRUC和ENDS把一系列数据定义语句括起来就说明了一个结构类型，一般格式如下：
结构名 STRUC
数据定义语句序列
结构名 ENDS
例如，下列语句说明了一个名为PERSON的结构类型：
PERSON STRUC
ID DW ?
SCORE DB 0
PNAME DB 'ABCDEFGH'
PERSON ENDS
组成结构的变量称为结构的字段，相应的变量名称为字段名。
一个结构中可以含有任意数目的字段，并且各字段可以有不同的长度（基本单位是字节），还可以独立地存取。
结构中的字段也可以没有字段名。结构中的字段名代表了从结构的开始到相应字段的偏移。
在上面定义的结构PERSON中，字段ID、SCORE和FNAME分别有偏移值0、2和3。
在说明结构类型时，可以给字段赋初值，也可以不赋初值。
在上面定义的结构PERSON中，给字段SCORE赋缺省初值0，没有给字段ID赋初值。
如果字段是一个字符串，那么要确保其初值有足够的长度以适应可能最长的字符串。
再如，下列语句说明了一个名为MESST的结构类型：
MESST STRUC
MBUFF DB 100 DUP (?)
CRLF DB 0DH,0AH
ENDMARK DB 24H
MESST ENDS
结构MESST中的字段MBUFF和CRLF均含有多个值，字段MBUFF、CRLF和ENDMARK分别有偏移值0、100和102。
在说明结构类型时，结构名必须是唯一的，各字段名也应该是唯一的。
注意，在说明结构类型时不进行任何存储分配，只有在定义结构变量时才进行存储分配。这与高级语言中的数据类型定义相似。
还请注意，标记一个结构类型结束的伪指令与标记一个段结束的伪指令有相同的助记符ENDS，汇编程序通过上下文理解ENDS的含义，
所以要确保每一SEGMENT伪指令和每一STRUC伪指令有各自对应的ENDS伪指令。
2.结构变量的定义
在说明了结构类型后，就可定义相应的结构变量。结构变量定义的一般格式如下：
[变量名] 结构名 <[字段值表]>
其中，变量名就是当前定义的结构变量的名称，结构变量名也可以省略，如果省略，那么就不能直接通过符号名访问该结构变量。
结构名是在说明结构类型时所用的名字。字段值表用来给结构变量的各字段赋初始值，
其中各字段值的排列顺序及类型应与结构定义时的各字段相一致，中间以逗号分隔。
如果某个字段采用在说明结构时所给定的缺省初值，那么可简单地用逗号表示；
如果结构变量的所有字段均如此，那么可省去字段值表，但仍必须保留一对尖括号。
例如，设已说明了上述结构PERSON，那么可定义如下结构变量：
STUDENT1 PERSON <103,88,'WANG'>
STUDENT2 PERSON <104,,'LIMING'>
STUDENT PERSON <>
PERSON 99 DUP (<>)
注意，对宏汇编程序MASM而言，如果某个字段有多值，那么在定义结构变量时，就不能给该字段重赋初值。
如上面说明的结构MESST，不能给其MBUFF字段和CRLF字段重赋初值。下面定义结构变量的语句是正确的：
MESS1 MESST <>
MESS2 MESST <,,0>
3.结构变量及其字段的访问
通过结构变量名可直接存取结构变量。若要存取结构变量中的某一字段，则可采用如下形式：
结构变量名.结构字段名
在上述形式中，结构变量名与结构字段名之间用点号分隔，并且结构字段名所代表的字段必须是对应结构所具有的字段。
这种形式表示的变量的地址偏移值是结构变量地址（起始地址）的偏移值与相应字段偏移值之和。
下面的程序片段说明了对结构字段的访问：
......
DATE STRUC
YEAR DW ?
MONTH DB ?
DAY DB ?
DATE ENDS
......
YESTERDAY DATE <1995,7,17>
TODAY DATE <1995,7,18>
TOMORROW DATE <1995,7,19>
......
MOV AL,YESTERDAY.DAY
MOV AH,TODAY.MONTH
MOV TOMORROW.YEAR,DX
......
上述形式所对应的寻址方式是直接寻址。另一种存取结构变量中某一字段的方法是把结构变量地址的偏移先存入某个基址或变址寄存器，
然后用“[寄存器名]”代替结构变量名。这种方法所对应的寻址方式是相对基址或变址寻址。例如：
......
MOV BX,OFFSET YESTERDAY
MOV AL,[BX].MONTH
......
例1：数据文件SCORE.DAT中依次存放着30个学生的成绩记录，文件（成绩）记录具有如下字段：
学号 整数 2字节
姓名 字符串 8字节
语文成绩 整数 1字节
数学成绩 整数 1字节
外语成绩 整数 1字节
写一个程序计算三门课程的总分，把学号和总分依次写到文件SCORE.SUM中。
SCORE.SUM文件的记录有两个字段，第一个字段是学号，第二个字段是总分（用2字节表示）。
实现流程是：（1）打开文件SCORE.DAT；（2）循环处理每个学生的成绩，把学号和总分依次存入预定义的缓冲区（称为总分表）中；
（3）关闭文件SCORE.DAT；（4）建立文件SCORE.SUM；（5）把缓冲区中的内容写入文件SCORE.SUM；（6）关闭文件SCORE.SUM。
为了突出结构的应用，下面列出的程序没有考虑磁盘文件读写出错等情况。
；程序名：T7-1.ASM
；功能：（略）
COUNT = 30
SCORE STRUC
NO DW ?
SNAME DB 8 DUP (20H)
CHN DB 0
MATH DB 0
ENG DB 0
SCORE ENDS
ITEM STRUC
NOS DW 0
SUM DW 0
ITEM ENDS
DSEG SEGMENT
BUFFER SCORE <>
STABLE ITEM COUNT DUP (<>)
FNAME1 DB 'SCORE.DAT',0
FNAME2 DB 'SCORE.SUM',0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET FNAME1
MOV AX,3D00H
INT 21H
MOV BX,AX
MOV DI,COUNT
MOV SI,OFFSET STABLE
READ:MOV DX,OFFSET BUFFER
MOV CX,TYPE SCORE
MOV AH,3FH
INT 21H
MOV AL,BUFFER.CHN
XOR AH,AH
ADD AL,BUFFER.MATH
ADC AH,0
ADD AL,BUFFER.ENG
ADC AH,0
MOV [SI].SUM,AX
MOV AX,BUFFER.NO
MOV [SI].NOS,AX
ADD SI,TYPE ITEM
DEC DI
JNZ READ
MOV AH,3EH
INT 21H
MOV DX,OFFSET FNAME2
MOV CX,0
MOV AH,3CH
INT 21H
MOV BX,AX
MOV DX,OFFSET STABLE
MOV CX,(TYPE ITEM)*COUNT
MOV AH,40H
INT 21H
MOV AH,3EH
INT 21H
MOV AX,4C00H
INT 21H
CSEG ENDS
END START
测试通过的完整程序如下
COLOR = 07H
DPAGE = 0
ROW = 12
COLUMN = 28
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SCORE STRUC
NO DW ?
SNAME DB 8 DUP (20H)
CHN DB 0
MATH DB 0
ENG DB 0
SCORE ENDS
ITEM STRUC
NOS DW 0
SUM DW 0
ITEM ENDS
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
STR_SCOREDAT DB 'SCORE.DAT',0
STR_SCORESUM DB 'SCORE.SUM',0
HANDLE_SCOREDAT DW 0
HANDLE_SCORESUM DW 0
BUFFER SCORE <>
STABLE ITEM 30 DUP (<>)
BUFFER_SCOREDAT SCORE <1001,,101,101,101>
SCORE <1002,,102,102,102>
SCORE <1003,,103,103,103>
SCORE <1004,,104,104,104>
SCORE <1005,,105,105,105>
SCORE <1006,,106,106,106>
SCORE <1007,,107,107,107>
SCORE <1008,,108,108,108>
SCORE <1009,,109,109,109>
SCORE <1010,,110,110,110>
SCORE <1011,,111,111,111>
SCORE <1012,,112,112,112>
SCORE <1013,,113,113,113>
SCORE <1014,,114,114,114>
SCORE <1015,,115,115,115>
SCORE <1016,,116,116,116>
SCORE <1017,,117,117,117>
SCORE <1018,,118,118,118>
SCORE <1019,,119,119,119>
SCORE <1020,,120,120,120>
SCORE <1021,,121,121,121>
SCORE <1022,,122,122,122>
SCORE <1023,,123,123,123>
SCORE <1024,,124,124,124>
SCORE <1025,,125,125,125>
SCORE <1026,,126,126,126>
SCORE <1027,,127,127,127>
SCORE <1028,,128,128,128>
SCORE <1029,,129,129,129>
SCORE <1030,,130,130,130>
MESS_OPENERR DB 'Can not open file',07H,'$'
MESS_READERR DB 'Reading error',07h,'$'
MESS_CREAERR DB 'Can not create file',07H,'$'
MESS_WRITERR DB 'Writing error',07H,'$'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL WRITESCOREDAT
CALL WRITESCORESUM
MOV AH,4CH
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
HTOASC PROC
AND AL,0FH
ADD AL,30H
CMP AL,39H
JA HTOASC_NODEC
JMP HTOASC_OK
HTOASC_NODEC:ADD AL,7
HTOASC_OK:RET
HTOASC ENDP
AHTOASC PROC
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL HTOASC
XCHG AH,AL
CALL HTOASC
RET
AHTOASC ENDP
DAHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DAHTOASC ENDP
DHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH AX
XCHG AH,AL
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DHTOASC ENDP
WRITESCOREDAT PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET STR_SCOREDAT
MOV CX,0
MOV AH,3CH
INT 21H
JNC WRITESCOREDAT_CREAOK
WRITESCOREDAT_CREAERR:MOV DX,OFFSET MESS_CREAERR
CALL DISPMESS
JMP WRITESCOREDAT_OK
WRITESCOREDAT_CREAOK:MOV HANDLE_SCOREDAT,AX
MOV CX,(TYPE SCORE) * 30
MOV DX,OFFSET BUFFER_SCOREDAT
MOV BX,HANDLE_SCOREDAT
MOV AH,40H
INT 21H
JC WRITESCOREDAT_WRITERR
JMP WRITESCOREDAT_FINISH
WRITESCOREDAT_WRITERR:MOV DX,OFFSET MESS_WRITERR
CALL DISPMESS
WRITESCOREDAT_FINISH:MOV BX,HANDLE_SCOREDAT
MOV AH,3EH
INT 21H
WRITESCOREDAT_OK:POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
WRITESCOREDAT ENDP
WRITESCORESUM PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET STR_SCOREDAT
MOV AX,3D00H
INT 21H
JNC WRITESCORESUM_OPENOK
WRITESCORESUM_OPENERR:MOV DX,OFFSET MESS_OPENERR
CALL DISPMESS
JMP WRITESCORESUM_OK
WRITESCORESUM_OPENOK:MOV HANDLE_SCOREDAT,AX
MOV DX,OFFSET STR_SCORESUM
MOV CX,0
MOV AH,3CH
INT 21H
JNC WRITESCORESUM_CREAOK
WRITESCORESUM_CREAERR:MOV BX,HANDLE_SCOREDAT
MOV AH,3EH
INT 21H
MOV DX,OFFSET MESS_CREAERR
CALL DISPMESS
JMP WRITESCORESUM_OK
WRITESCORESUM_CREAOK:MOV HANDLE_SCORESUM,AX
MOV SI,OFFSET STABLE
WRITESCORESUM_READBUF:MOV DX,OFFSET BUFFER
MOV CX,TYPE SCORE
MOV BX,HANDLE_SCOREDAT
MOV AH,3FH
INT 21H
JC WRITESCORESUM_READERR
CMP AX,0
JZ WRITESCORESUM_READFINISH
MOV AL,BUFFER.CHN
XOR AH,AH
ADD AL,BUFFER.MATH
ADC AH,0
ADD AL,BUFFER.ENG
ADC AH,0
MOV [SI].SUM,AX
CALL DHTOASC
MOV AL,20H
CALL PUTCH
MOV AX,BUFFER.NO
MOV [SI].NOS,AX
CALL DHTOASC
CALL NEWLINE
ADD SI,TYPE ITEM
JMP WRITESCORESUM_READBUF
WRITESCORESUM_READFINISH:MOV CX,(TYPE ITEM) * 30
MOV DX,OFFSET STABLE
MOV BX,HANDLE_SCORESUM
MOV AH,40H
INT 21H
JC WRITESCORESUM_WRITERR
JMP WRITESCORESUM_FINISH
WRITESCORESUM_READERR:MOV DX,OFFSET MESS_READERR
CALL DISPMESS
JMP WRITESCORESUM_FINISH
WRITESCORESUM_WRITERR:MOV DX,OFFSET MESS_WRITERR
CALL DISPMESS
WRITESCORESUM_FINISH:MOV BX,HANDLE_SCOREDAT
MOV AH,3EH
INT 21H
MOV BX,HANDLE_SCORESUM
MOV AH,3EH
INT 21H
WRITESCORESUM_OK:POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
WRITESCORESUM ENDP
CSEG ENDS
END START
在程序T7-1.ASM中，我们定义两个结构SCORE和ITEM，用来描述文件记录的字段组成。
利用SCORE定义了存放一个原始成绩记录的缓冲区，这样可方便地引用各字段。
还利用ITEM定义了一张总分表，然后借助指向总分表当前项的指针方便地访问当前项的学号和总分字段。
此外，程序T7-1.ASM还使用了TYPE得到结构的字节数。
例2：写一个求字符串长度的子程序。子程序的调用说明如下：
；子程序名：STRLEN
；功能：测字符串长度
；入口参数：字符串首地址的段值和偏移在堆栈顶
；出口参数：AX=字符串长度
；说明：（1）字符串以0结尾；字符串长度不包括结尾标志。
；（2）本过程是一个远过程。
为了方便地表达堆栈参数，先定义如下结构：
PARM STRUC
BPREG DW ?
RETADR DD ?
STROFF DW ?
STRSEG DW ?
PARM ENDS
只定义上述结构PARM类型，但不定义结构变量。当子程序为了利用寄存器BP访问堆栈中的参数，而把寄存器BP压入堆栈后，
可以认为一个这样的结构变量出现在当时的堆栈顶端。然后使寄存器BP指向此结构变量，于是就能方便地表达要存取的位于堆栈中的参数。
子程序源代码如下：
STRLEN PROC FAR
PUSH BP
MOV BP,SP
PUSH DS
PUSH SI
MOV DS,[BP].STRSEG
MOV SI,[BP].STROFF
XOR AL,AL
STRLEN1:CMP BYTE PTR [SI],AL
JZ STRLEN2
INC SI
JMP STRLEN1
STRLEN2:MOV AX,SI
SUB AX,[BP].STROFF
POP SI
POP DS
POP BP
RETF
STRLEN ENDP
测试通过的完整程序如下
WINTOP = 0
WINLEFT = 0
WINBOTTOM = 24
WINRIGHT = 79
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ALTF1 = 6800H
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
PARM STRUC
BPREG DW ?
RETADR DD ?
STROFF DW ?
STRSEG DW ?
PARM ENDS
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
FNAME_SRC DB 128 DUP (0)
MESS_FNSRC DB 'Please input source filename:','$'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESS_FNSRC
CALL DISPMESS
MOV DI,OFFSET FNAME_SRC
CALL GETSTRFN
MOV DI,OFFSET FNAME_SRC
ADD DI,2
CALL STRLENA
CALL DHTOASC
CALL NEWLINE
MOV DI,OFFSET FNAME_SRC
ADD DI,2
CALL STRLENB
CALL DHTOASC
CALL NEWLINE
MOV SI,OFFSET FNAME_SRC
ADD SI,2
PUSH DS
PUSH SI
CALL STRLENC
ADD SP,4
CALL DHTOASC
CALL NEWLINE
MOV SI,OFFSET FNAME_SRC
ADD SI,2
PUSH DS
PUSH SI
CALL FAR PTR STRLENCF
ADD SP,4
CALL DHTOASC
CALL NEWLINE
MOV SI,OFFSET FNAME_SRC
ADD SI,2
CALL STRLEND
CALL DHTOASC
CALL NEWLINE
MOV AH,4CH
INT 21H
ISFNM PROC
CMP AL,2BH
JB ISFNM_NOFNM
CMP AL,3BH
JA ISFNM_NODEC1
CLC
JMP ISFNM_OK
ISFNM_NODEC1:CMP AL,41H
JB ISFNM_NOFNM
CMP AL,5FH
JA ISFNM_NODEC2
CLC
JMP ISFNM_OK
ISFNM_NODEC2:CMP AL,61H
JB ISFNM_NOFNM
CMP AL,7AH
JA ISFNM_NOFNM
CLC
JMP ISFNM_OK
ISFNM_NOFNM:STC
ISFNM_OK:RET
ISFNM ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRFN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRFN1:CALL GETCH
CMP AL,CR
JZ GETSTRFN5
CMP AL,BACKSPACE
JNZ GETSTRFN4
CMP BX,0
JZ GETSTRFN2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRFN1
GETSTRFN2:CALL BELL
JMP GETSTRFN1
GETSTRFN4:CMP BX,78
JZ GETSTRFN2
CALL ISFNM
JC GETSTRFN2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRFN1
GETSTRFN5:CMP BX,1
JB GETSTRFN2
MOV AL,0
MOV [BX][DI+2],AL
INC BX
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRFN_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRFN ENDP
HTOASC PROC
AND AL,0FH
ADD AL,30H
CMP AL,39H
JA HTOASC_NODEC
JMP HTOASC_OK
HTOASC_NODEC:ADD AL,7
HTOASC_OK:RET
HTOASC ENDP
AHTOASC PROC
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL HTOASC
XCHG AH,AL
CALL HTOASC
RET
AHTOASC ENDP
DAHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DAHTOASC ENDP
DHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH AX
XCHG AH,AL
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DHTOASC ENDP
STRLENA PROC
PUSHF
PUSH CX
PUSH DI
PUSH ES
MOV AX,DS
MOV ES,AX
CLD
XOR AL,AL
MOV CX,0FFFFH
STRLENA_S:SCASB
LOOPNZ STRLENA_S
NOT CX
MOV AX,CX
DEC AX
STRLENA_OK:POP ES
POP DI
POP CX
POPF
RET
STRLENA ENDP
STRLENB PROC
PUSHF
PUSH CX
PUSH DI
PUSH ES
MOV AX,DS
MOV ES,AX
CLD
XOR AL,AL
MOV CX,0FFFFH
REPNZ SCASB
NOT CX
MOV AX,CX
DEC AX
STRLENB_OK:POP ES
POP DI
POP CX
POPF
RET
STRLENB ENDP
STRLENC PROC
PUSH BP
MOV BP,SP
PUSH DS
PUSH SI
MOV DS,[BP+6]
MOV SI,[BP+4]
MOV AL,0
STRLENC_S:CMP AL,[SI]
JZ STRLENC_FINDZ
INC SI
JMP STRLENC_S
STRLENC_FINDZ:MOV AX,SI
SUB AX,[BP+4]
STRLENC_OK:POP SI
POP DS
POP BP
RET
STRLENC ENDP
STRLENCF PROC FAR
PUSH BP
MOV BP,SP
PUSH DS
PUSH SI
MOV DS,[BP].STRSEG
MOV SI,[BP].STROFF
XOR AL,AL
STRLENCF_S:CMP BYTE PTR [SI],AL
JZ STRLENCF_FINDZ
INC SI
JMP STRLENCF_S
STRLENCF_FINDZ:MOV AX,SI
SUB AX,[BP].STROFF
STRLENCF_OK:POP SI
POP DS
POP BP
RETF
STRLENCF ENDP
STRLEND PROC
PUSHF
PUSH CX
PUSH DX
PUSH SI
MOV DX,SI
CLD
TEST SI,1
JZ STRLEND_1
LODSB
AND AL,AL
JZ STRLEND_FINDZ1
STRLEND_1:LODSW
AND AL,AL
JZ STRLEND_FINDZ2
AND AH,AH
JZ STRLEND_FINDZ1
JMP STRLEND_1
STRLEND_FINDZ1:LEA AX,[SI-1]
SUB AX,DX
JMP STRLEND_OK
STRLEND_FINDZ2:LEA AX,[SI-2]
SUB AX,DX
STRLEND_OK:POP SI
POP DX
POP CX
POPF
RET
STRLEND ENDP
CSEG ENDS
END START
该子程序与4.2.3节中的例5功能相同，实现算法也相同，所不同的是该子程序是远过程。
请比较利用结构类型和结构字段前后代码的易读性和可修改性。
结构变量名.结构字段名
[寄存器名].结构字段名
这2种形式表示的变量的地址偏移值是结构变量地址（起始地址）的偏移值与结构字段偏移值之和。
结构字段名表示相应结构字段在结构变量中的相应偏移，这样可以通过结构字段名直接访问堆栈中的参数，代码更容易阅读和修改。
7.1.2记录
记录类型为按二进制位存取数据或信息提供了方便。
1.记录类型的说明
在描述记录型数据或使用记录型变量之前，需要说明记录类型。
伪指令RECORD用于说明记录类型，一般格式如下：
记录名 RECORD 字段 [,字段...]
记录名标识说明的记录类型，字段表示构成记录的字段的名字、宽度和缺省初值。
每一字段的格式如下：
字段名:宽度[=表达式]
字段名是记录中字段的名字。宽度表示相应的字段所占的位数，宽度必须是常数，宽度最大为16位。
表达式的值将作为相应字段的缺省初值，如果缺省初值相对于它的宽度太大，则汇编时将产生错误提示信息。
如果某个字段没有缺省初值，那么缺省初值被置为0。
一个记录可以含有多个字段，字段间用逗号分隔。但在一般情况下各字段的宽度之和不超过16。例如：
COLOR RECORD BLINK:1,BACK:3,INTENSE:1,FORE:3
上述记录类型COLOR含四个字段（BLINK、BACK、INTENSE和FORE），各字段均没有赋缺省初值，它们的宽度分别是1、3、1和3。
这四个字段所占总宽度正好是8位，所以也称为字节记录类型。这四个字段的具体意义请参见图5.14。
注意，在说明记录类型时，不实际分配存储单元。
如果一个记录中所有说明字段的总宽度大于8，那么汇编程序会给对应的记录变量分配两字节，否则仅给对应的记录变量分配一字节。
第一个字段放在记录左边的较高有效位，随后说明的字段放在右边的一些后续位上，
如果说明的字段总宽度不正好是8位或16位，那么向右对齐，记录高端未说明的位置为0。例如：
ABCD RECORD AA:5=12,BB:3=6,CC:4=3
上述记录类型ABCD含三个字段，这三个字段所占各位如图7.1所示。
0000*****###----
        AA   BB  CC
如果一个记录中说明的字段总宽度是7位，那么汇编程序会给对应的记录变量分配一字节。对应的记录变量可以赋值给8位的寄存器，如AL。
如果一个记录中说明的字段总宽度是12位，那么汇编程序会给对应的记录变量分配两字节。对应的记录变量可以赋值给16位的寄存器，如AX。
2.记录变量的定义
记录变量是其位分成一或多个字段的字节或字变量。定义记录变量的一般格式如下：
[变量名] 记录名 <[字段值表]>
其中，变量名就是当前定义的记录变量的名称，记录变量名可以省略，如果省略，那么就不能直接通过符号名访问该记录变量。
记录名是在说明记录类型时所用的名字。字段值表用来给记录变量的各字段赋初始值，
各字段值的排列顺序及大小应与记录说明时的各字段相一致，中间以逗号分隔。
如果某个字段采用在说明记录时所给定的缺省初值，那么可简单地用逗号表示；
如果记录变量的所有字段均如此，那么可省去字段值表，但仍必须保留一对尖括号。
例如：设已定义了上述记录类型COLOR，那么可定义如下记录变量：
WARNING COLOR <1,0,1,4> 该字节的值是8CH
COLOR <,3,,110B> 该字节的值是36H
COLORLST COLOR 32 DUP (<>) 32个字节
注意，如果字段值太大，则有汇编错误提示信息。
3.记录专用操作符
操作符WIDTH和MASK仅与记录一起使用，得到已说明记录的不同方面的常数值。
（1）操作符WIDTH
操作符WIDTH返回记录或记录中字段的以位为单位的宽度。一般格式如下：
WIDTH 记录名
或者WIDTH 记录字段名
设记录COLOR如上面的说明，那么：
SUB AL,WIDTH COLOR 等同于 SUB AL,8
MOV DH,WIDTH BACK 等同于 MOV DH,3
ADD BH,WIDTH INTENSE 等同于 ADD BH,1
（2）操作符MASK
一般格式如下：
MASK 记录名
或者MASK 记录字段名
操作符MASK返回1个8位或16位二进制数，这个二进制数中相应于指定字段的各位为1，其余各位为0。
如果记录是字节记录类型，那么就是一个8位二进制数，如果记录是字记录类型，那么就是一个16位二进制数。
设记录COLOR和ABCD如上面的说明，那么：
MOV AL,MASK BLINK 等同于 MOV AL,10000000B
OR AH,MASK FORE 等同于 OR AH,00000111B
AND DX,MASK ABCD 等同于 AND DX,0FFFH
（3）记录字段
记录字段名作为一个特殊的操作符，它不带操作数，直接返回该字段移到所在记录的最右端所需移动的位数。
设记录COLOR如上面的说明，那么：
MOV CL,BLINK 等同于 MOV CL,7
MOV CL,INTENSE 等同于 MOV CL,3
4.记录及其字段的访问
由于8086/8088没有位操作指令，记录类型和记录操作符能够也只能够提供访问记录中字段的便利。
下面的程序片段说明如何访问记录及其字段：
......
COLORT RECORD BLINK:1,BACK:3,INTENSE:1,FORE:3
ATTR COLORT <0,0,1,7>
......
CALL DISPLAYCHAR
......
DISPLAYCHAR PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
MOV AX,DSEG
MOV DS,AX
MOV SI,0
MOV BP,1 SHL WIDTH BACK
DISPLAYCHAR_FORI1:CMP SI,BP
JAE DISPLAYCHAR_OK
CALL GETCH
MOV BH,0
MOV BL,ATTR
MOV CX,1
MOV AL,'A'
MOV AH,09H
INT 10H
MOV AL,ATTR
MOV AH,AL
AND AL,NOT MASK BACK
MOV CL,BACK
SHR AH,CL
INC AH
SHL AH,CL
AND AH,MASK BACK
OR AH,AL
MOV ATTR,AH
DISPLAYCHAR_NEXTI1:INC SI
JMP DISPLAYCHAR_FORI1
DISPLAYCHAR_OK:POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
DISPLAYCHAR ENDP
......
测试通过的完整程序如下
WINTOP = 0
WINLEFT = 0
WINBOTTOM = 24
WINRIGHT = 79
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ALTF1 = 6800H
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
PARM STRUC
BPREG DW ?
RETADR DD ?
STROFF DW ?
STRSEG DW ?
PARM ENDS
COLORT RECORD BLINK:1,BACK:3,INTENSE:1,FORE:3
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
FNAME_SRC DB 128 DUP (0)
MESS_FNSRC DB 'Please input source filename:','$'
ATTR COLORT <0,0,1,7>
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESS_FNSRC
CALL DISPMESS
MOV DI,OFFSET FNAME_SRC
CALL GETSTRFN
MOV DI,OFFSET FNAME_SRC
ADD DI,2
CALL STRLENA
CALL DHTOASC
CALL NEWLINE
MOV DI,OFFSET FNAME_SRC
ADD DI,2
CALL STRLENB
CALL DHTOASC
CALL NEWLINE
MOV SI,OFFSET FNAME_SRC
ADD SI,2
PUSH DS
PUSH SI
CALL STRLENC
ADD SP,4
CALL DHTOASC
CALL NEWLINE
MOV SI,OFFSET FNAME_SRC
ADD SI,2
PUSH DS
PUSH SI
CALL FAR PTR STRLENCF
ADD SP,4
CALL DHTOASC
CALL NEWLINE
MOV SI,OFFSET FNAME_SRC
ADD SI,2
CALL STRLEND
CALL DHTOASC
CALL NEWLINE
CALL DISPLAYCHAR
MOV AH,4CH
INT 21H
ISFNM PROC
CMP AL,2BH
JB ISFNM_NOFNM
CMP AL,3BH
JA ISFNM_NODEC1
CLC
JMP ISFNM_OK
ISFNM_NODEC1:CMP AL,41H
JB ISFNM_NOFNM
CMP AL,5FH
JA ISFNM_NODEC2
CLC
JMP ISFNM_OK
ISFNM_NODEC2:CMP AL,61H
JB ISFNM_NOFNM
CMP AL,7AH
JA ISFNM_NOFNM
CLC
JMP ISFNM_OK
ISFNM_NOFNM:STC
ISFNM_OK:RET
ISFNM ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRFN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRFN1:CALL GETCH
CMP AL,CR
JZ GETSTRFN5
CMP AL,BACKSPACE
JNZ GETSTRFN4
CMP BX,0
JZ GETSTRFN2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRFN1
GETSTRFN2:CALL BELL
JMP GETSTRFN1
GETSTRFN4:CMP BX,78
JZ GETSTRFN2
CALL ISFNM
JC GETSTRFN2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRFN1
GETSTRFN5:CMP BX,1
JB GETSTRFN2
MOV AL,0
MOV [BX][DI+2],AL
INC BX
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRFN_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRFN ENDP
HTOASC PROC
AND AL,0FH
ADD AL,30H
CMP AL,39H
JA HTOASC_NODEC
JMP HTOASC_OK
HTOASC_NODEC:ADD AL,7
HTOASC_OK:RET
HTOASC ENDP
AHTOASC PROC
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL HTOASC
XCHG AH,AL
CALL HTOASC
RET
AHTOASC ENDP
DAHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DAHTOASC ENDP
DHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH AX
XCHG AH,AL
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DHTOASC ENDP
STRLENA PROC
PUSHF
PUSH CX
PUSH DI
PUSH ES
MOV AX,DS
MOV ES,AX
CLD
XOR AL,AL
MOV CX,0FFFFH
STRLENA_S:SCASB
LOOPNZ STRLENA_S
NOT CX
MOV AX,CX
DEC AX
STRLENA_OK:POP ES
POP DI
POP CX
POPF
RET
STRLENA ENDP
STRLENB PROC
PUSHF
PUSH CX
PUSH DI
PUSH ES
MOV AX,DS
MOV ES,AX
CLD
XOR AL,AL
MOV CX,0FFFFH
REPNZ SCASB
NOT CX
MOV AX,CX
DEC AX
STRLENB_OK:POP ES
POP DI
POP CX
POPF
RET
STRLENB ENDP
STRLENC PROC
PUSH BP
MOV BP,SP
PUSH DS
PUSH SI
MOV DS,[BP+6]
MOV SI,[BP+4]
MOV AL,0
STRLENC_S:CMP AL,[SI]
JZ STRLENC_FINDZ
INC SI
JMP STRLENC_S
STRLENC_FINDZ:MOV AX,SI
SUB AX,[BP+4]
STRLENC_OK:POP SI
POP DS
POP BP
RET
STRLENC ENDP
STRLENCF PROC FAR
PUSH BP
MOV BP,SP
PUSH DS
PUSH SI
MOV DS,[BP].STRSEG
MOV SI,[BP].STROFF
XOR AL,AL
STRLENCF_S:CMP BYTE PTR [SI],AL
JZ STRLENCF_FINDZ
INC SI
JMP STRLENCF_S
STRLENCF_FINDZ:MOV AX,SI
SUB AX,[BP].STROFF
STRLENCF_OK:POP SI
POP DS
POP BP
RETF
STRLENCF ENDP
STRLEND PROC
PUSHF
PUSH CX
PUSH DX
PUSH SI
MOV DX,SI
CLD
TEST SI,1
JZ STRLEND_1
LODSB
AND AL,AL
JZ STRLEND_FINDZ1
STRLEND_1:LODSW
AND AL,AL
JZ STRLEND_FINDZ2
AND AH,AH
JZ STRLEND_FINDZ1
JMP STRLEND_1
STRLEND_FINDZ1:LEA AX,[SI-1]
SUB AX,DX
JMP STRLEND_OK
STRLEND_FINDZ2:LEA AX,[SI-2]
SUB AX,DX
STRLEND_OK:POP SI
POP DX
POP CX
POPF
RET
STRLEND ENDP
DISPLAYCHAR PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
MOV AX,DSEG
MOV DS,AX
MOV SI,0
MOV BP,1 SHL WIDTH BACK
DISPLAYCHAR_FORI1:CMP SI,BP
JAE DISPLAYCHAR_OK
CALL GETCH
MOV BH,0
MOV BL,ATTR
MOV CX,1
MOV AL,'A'
MOV AH,09H
INT 10H
MOV AL,ATTR
MOV AH,AL
AND AL,NOT MASK BACK
MOV CL,BACK
SHR AH,CL
INC AH
SHL AH,CL
AND AH,MASK BACK
OR AH,AL
MOV ATTR,AH
DISPLAYCHAR_NEXTI1:INC SI
JMP DISPLAYCHAR_FORI1
DISPLAYCHAR_OK:POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
DISPLAYCHAR ENDP
CSEG ENDS
END START
该程序片段在当前光标位置处循环显示各种不同背景的显示效果，按一次键，则换一种背景色。
7.2宏
宏是宏汇编语言的主要特征之一。在汇编语言源程序中，若某程序片段需要多次使用，为了避免重复书写，那么可把它定义为一条宏指令。
在写源程序时，程序员用宏指令来表示程序片段；在汇编时，汇编程序用对应的程序片段代替宏指令。
7.2.1宏指令的定义和使用
宏指令在使用之前要先定义。宏定义的一般格式如下：
宏指令名 MACRO [形式参数表]
......
ENDM
其中，MACRO和ENDM是一对伪指令，在宏定义中，它们必须成对出现，表示宏定义的开始和宏定义的结束。
MACRO和ENDM之间的内容称为宏定义体，可以是由指令、伪指令和宏指令构成的程序片段。
宏指令名由用户指定，适用一般标号命名规则。可选的形式参数表可由若干参数组成，各形式参数间用逗号分隔。
例如：我们把将AL寄存器内的低4位转换为对应十六进制数ASCII码的程序片段定义为一个宏：
HTOASC MACRO
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
ENDM
再如，我们把通过DOS的系统功能调用从键盘读一个字符的程序片段定义为一个宏：
GETCH MACRO
MOV AH,8
INT 21H
ENDM
在定义宏指令后，就可使用宏指令来表示对应的程序片段，这称为宏调用。宏调用的一般格式如下：
宏指令名 [实参数表]
其中，实参数表中的实参数应该与宏定义时的形式参数表中的形式参数相对应。
例如，下面的程序片段调用了刚定义的两个宏：
......
GETCH
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
HTOASC
XCHG AH,AL
HTOASC
......
在对源程序汇编时，汇编程序把源程序中的宏指令替换成对应的宏定义体，这称为宏展开或宏扩展。
上述程序片段在汇编时得到的指令如下：
......
MOV AH,8
INT 21H
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
XCHG AH,AL
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
......
注意，宏展开所得指令的行首标有符号"1"，以示区别。
7.2.2宏指令的用途
1.缩短源代码
若在源程序中要多次使用到某个程序片段，那么就可以把此程序片段定义为一条宏指令。
此后，在需要这个程序片段之处安排一条对应的宏指令就行了，由汇编程序在汇编时产生对应的代码。
这不仅能有效地缩短源代码，而且能减少编辑汇编语言源程序过程中的错误。
例如，我们把使光标另起一行的程序片段写成如下的一个宏：
CRLF MACRO
MOV BH,0
MOV AH,0EH
MOV AL,0DH
INT 10H
MOV AL,0AH
INT 10H
ENDM
2.扩充指令集
CPU的指令集是确定的，但利用宏能在汇编语言中在形式上对指令集进行扩充。扩充后的指令集是机器指令集与宏指令集的并集。
这不仅能方便源程序的编写，而且便于阅读理解源程序。在写子程序和中断处理程序时，为了保护现场常常需要把8个通用寄存器全部压入堆栈，
但8086/8088指令集中没有把8个通用寄存器全部压栈的指令。
为此，我们可定义一条宏指令PUSHA，由它实现把8个通用寄存器全部压入堆栈的功能：
PUSHA MACRO
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SP
PUSH BP
PUSH SI
PUSH DI
ENDM
在定义了上述宏指令PUSHA后，每当需要把8个通用寄存器全部压栈时，就可以使用PUSHA指令了。
与宏指令PUSHA相对应，我们还可定义宏指令POPA实现把由PUSHA压栈的8个通用寄存器依次退栈的功能。
POPA MACRO
POP DI
POP SI
POP BP
POP SP
POP DX
POP CX
POP BX
POP AX
ENDM
3.改变某些指令助记符的意义
宏指令名可以与指令助记符或伪操作名相同，在这种情况下，宏指令的优先级最高，而同名的指令或伪操作就失效了。
利用宏指令的这一特点，可以改变指令助记符的意义。
例如，在定义如下宏指令后，助记符LODSB所表示指令的意义就变化了：
LODSB MACRO
MOV AH,[SI]
INC SI
ENDM
汇编程序TASM在遇到上述宏定义时，会发出一条警告信息；而汇编程序MASM则不给出任何警告信息。
7.2.3宏指令中参数的使用
宏指令可以不带参数，如上面定义的宏指令GETCH和PUSHA等。但往往带参数的宏指令更具灵活性。下面介绍宏指令中参数的使用。
1.宏指令的参数很灵活
（1）宏指令的参数可以是常数、寄存器和存储单元，还可以是表达式。
例1：在逻辑左移指令SHL的基础上定义一条宏指令SHLN，它能实现指定次数的左移。
SHLN MACRO REG,NUM
PUSH CX
MOV CL,NUM
SHL REG,CL
POP CX
ENDM
此后，可有如下格式的各种宏调用：
SHLN BL,5
SHLN SI,9
SHLN AX,CL
在汇编时，宏指令"SHLN BL,5"扩展成如下的代码：
PUSH CX
MOV CL,5
SHL BL,CL
POP CX
（2）宏指令的参数可以是操作码。
例2：下面的宏指令MANDM有三个参数，第一个参数OPR作为操作符使用在宏体的指令中：
MANDM MACRO OPR,X,Y
MOV AX,X
OPR AX,Y
MOV X,AX
ENDM
调用宏MANDM及其宏扩展如下所示：
MANDM MOV [BX],[SI]
宏扩展
MOV AX,[BX]
MOV AX,[SI]
MOV [BX],AX
调用宏MANDM及其宏扩展如下所示：
MANDM ADD [BX],ES:[1234H]
宏扩展
MOV AX,[BX]
ADD AX,ES:[1234H]
MOV [BX],AX
2.宏调用参数个数可以与定义时不一致
一般说来，宏调用时使用的实参个数应该与宏定义时的形参个数一致，但汇编程序并不要求它们必须相等。
若实参个数多于形参个数，那么多余的实参被忽略；若实参的个数少于形参的个数，那么多余的形参用“空”代替。
另外必须注意，宏展开后即实参取代形参后，所得的语句必须是有效的，否则汇编程序将会指示出错。
设已定义了上述的宏MANDM。宏调用"MANDM SUB,VAR1,VAR2,VAR3"展开后的语句如下：
MOV AX,VAR1
SUB AX,VAR2
MOV VAR1,AX
显然，多余的实参VAR3被忽略。宏调用"MANDM MOV,VAR1"展开后的语句如下：
MOV AX,VAR1
MOV AX,
MOV VAR1,AX
汇编程序将指示语句"MOV AX,"有错。另外，如果没有定义VAR1或VAR2，那么汇编程序也会给出相应的出错提示信息。
7.2.4特殊的宏运算符
为了方便宏的定义和调用，汇编程序还支持如表7.1所示的特殊运算符，它们适用于宏的定义或调用中，还适用于重复块。
表7.1特殊的宏运算符
运算符   使用格式  定义
&           &参数      强迫替换运算符
<>        <字符串> 字符串原样传递运算符
!             !字符        文字字符运算符
%           %表达式  表达式运算符
;;            ;;注释       宏注释
1.强迫替换运算符&
在宏定义中，若参数在其它字符的紧前或紧后，或者参数出现在带引号的字符串中时，就必须使用该运算符，以区分参数。
例1：在下面定义的宏指令JUMP中，参数CON作为操作码的部分，请注意分隔符"&"的使用。
JUMP MACRO CON,LAB
J&CON LAB
ENDM
调用宏JUMP及其宏扩展如下所示：
JUMP NZ,HERE
JNZ HERE
JUMP Z,THERE
JZ THERE
例2：下面定义的宏MSGGEN中，两个参数合并成标号，一个参数用在字符串中。
MSGGEN MACRO LAB,NUM,XYZ
LAB&NUM DB 'HELLO MR.&XYZ',0DH,0AH,24H
ENDM
调用宏MSGGEN及其宏扩展如下所示：
MSGGEN MSG,1,TAYLOR
宏扩展
MSG1 DB 'HELLO MR.TAYLOR',0DH,0AH,24H
2.字符串原样传递运算符<>
字符串原样传递运算符是一对尖括号，在宏调用、重复块和条件汇编中，由它括起的内容作为一个字符串。
在宏调用时，若实参包含逗号或空格等间隔符，则必须使用该运算符，以保证实参的完整。
若实参是某个有特殊意义的字符，为了使它只表示字符本身，也可使用该运算符，把它括起来。
例3：定义如下的宏：
DFMESS MACRO MESS
DB '&MESS',0DH,0AH,0 
ENDM
定义的字符串以0结尾
调用宏DFMESS及宏扩展如下所示：
DFMESS <This is a example>
DB 'This is a example',0DH,0AH,0
如果不使用该运算符，则情况如下所示：
DFMESS This is a example
DB 'This',0DH,0AH,0
3.文字字符运算符!
该运算符使其后的一个字符只作为一般字符。在宏调用时，如果实参中含有一些特殊字符，
为了使这些特殊字符作为一般字符来处理，那么就必须在其前冠上该运算符。
例4：利用上述宏DFMESS定义字符串"Can not enter >99"。由于字符串含有特殊符号">"，为避免它与上述字符串原样传递运算符相混，
则必须在其前冠该运算符。相应的宏调用及宏扩展如下所示：
DFMESS <Can not enter !>99>
DB 'Can not enter >99',0DH,0AH,0
4.表达式运算符%
在宏调用时，使用该运算符能把其后表达式的结果作为实参替换，而非表达式自身。
例5：调用上述宏DFMESS，宏调用和宏扩展如下所示：
使用表达式运算符%
DFMESS %(12+3-4)
DB '11',0DH,0AH,0
未使用表达式运算符%
DFMESS 12+3-4
DB '12+3-4',0DH,0AH,0
5.宏注释
在宏定义中，如果注释以两个分号引导，那么宏扩展时该注释不出现。
7.2.5宏与子程序的区别
采用宏和子程序这两种方法均能达到简化源程序的目的。但是，这两者之间存在质的不同。
我们从宏调用与子程序调用之间的差异来说明这两者的区别。
（1）宏调用是通过宏指令名进行的，在汇编时，由汇编程序把宏展开，有多少次宏调用，就有相应次的宏扩展，因此并不简化目标程序。
子程序调用是在程序执行期间执行CALL指令进行的，子程序的代码只在目标程序中出现一次，所以目标程序也得到相应的简化。
（2）宏调用时的参数由汇编程序通过实参替换形参的方式实现传递，所以参数很灵活。
子程序调用时的参数须通过寄存器、堆栈或约定的内存单元传递。
（3）宏调用是在汇编时完成，所以不需要额外的时间开销。子程序调用和子程序返回均需要时间，且还涉及堆栈。
总之，当程序片段不长，速度是主要矛盾时，通常采用宏指令的方法简化源程序；
当程序片段较长，额外操作所附加的时间就不明显，而节约存储空间是主要矛盾时，通常采用子程序的方法简化源程序和目标程序。
7.2.6与宏有关的伪指令
1.局部变量说明伪指令LOCAL
在宏定义体中可使用标号。例如：
HTOASC MACRO
AND AL,0FH
CMP AL,9
JBE ISDECM
ADD AL,7
ISDECM:ADD AL,30H
ENDM
如果在程序中多次调用上述宏HTOASC，汇编时将出现标号重复定义错误。
原因是每次展开宏HTOASC都得到一个标号ISDECM。为此，汇编程序提供伪指令LOCAL，供程序员说明宏的局部标号。
伪指令LOCAL的一般格式如下：
LOCAL 标号表
标号表由标号构成，标号间用逗号分隔。汇编程序在每次展开宏时，总把由LOCAL伪指令说明的标号用唯一的符号（??0000至??FFFF）代替，
从而避免标号重定义错误。
为了允许程序多次调用宏HTOASC，应利用LOCAL说明标号ISDECM，如下：
HTOASC MACRO
LOCAL ISDECM
AND AL,0FH
CMP AL,9
JBE ISDECM
ADD AL,7
ISDECM:ADD AL,30H
ENDM
如果在程序中有如下宏调用：
......
HTOASC
......
HTOASC
......
那么，在汇编时就得到如下宏扩展：
......
AND AL,0FH
CMP AL,9
JBE ??0000
ADD AL,7
??0000:ADD AL,30H
......
AND AL,0FH
CMP AL,9
JBE ??0001
ADD AL,7
??0001:ADD AL,30H
......
必须注意，LOCAL伪指令用在宏定义体内，而且它必须是宏定义伪指令MACRO后的第一条语句，
在MACRO和LOCAL俩指令之间还不允许有注释和分号标志。
2.清除宏定义的伪指令PURGE
伪指令PURGE的作用是告诉汇编程序取消某些宏。其一般格式如下：
PURGE 宏名表
宏名表由宏名构成，宏名之间用逗号分隔。汇编程序在遇到PURGE伪指令后，就取消由宏名表所列出的宏定义，此后不再扩展这些宏。
如果利用宏定义的方法改变了某些指令助记符的意义，那么在用PURGE伪指令取消有关宏后，就恢复了有关指令助记符的原始意义。
例如：我们先定义如下宏：
LODSB MACRO
MOV AH,[SI]
INC SI
ENDM
程序中使用如下指令：
......
LODSB
......
PURGE LODSB
......
LODSB
那么，在汇编时就得如下实际代码：
......
MOV AH,[SI]
INC SI
......
LODSB
3.中止宏扩展的伪指令EXITM
伪指令EXITM通知汇编程序结束当前宏调用的扩展。一般格式如下：
EXITM
当遇到伪指令EXITM时，汇编程序立即退出宏，在宏中剩下的语句不被扩展。如果在一嵌套的宏内遇到伪指令EXITM，则退出到外层宏。
伪指令EXITM通常与条件伪指令一起使用，以便在规定的条件下跳过宏内的最后的语句。
7.2.7宏定义的嵌套
宏定义的嵌套有两种情况：宏定义体中含宏调用；宏定义体中含宏定义。下面分别举例说明。
1.宏定义体中调用宏
宏汇编语言允许在宏定义体中使用宏调用，其限制条件仍是：必须先定义后调用。
如下，宏WHTOASC的定义体内就调用了宏HTOASC（见7.2.1）：
HTOASC MACRO
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
ENDM
WHTOASC MACRO
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
HTOASC
XCHG AH,AL
HTOASC
ENDM
如果在程序中调用了上述宏，那么在汇编时可得如下的宏展开：
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
XCHG AH,AL
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
注意，指令前的符号表示该指令是宏展开的结果。
2.宏定义体中定义宏指令
宏定义体中还可含有宏定义，但只有在调用了外层的宏后，才能调用内层的宏。原因是只有在调用了外层的宏后，内层的宏定义才有效。
下面的宏DEFMAC含有一个宏定义，并且外层宏的参数MACNAME是内层的宏指令名：
DEFMAC MACRO MACNAME,OPERATOR
MACNAME MACRO X,Y,Z
PUSH AX
MOV AX,X
OPERATOR AX,Y
MOV Z,AX
POP AX
ENDM
ENDM
下面的三次宏调用就生成三条宏指令ADDITION、SUBTRACT和LOGOR：
DEFMAC ADDITION,ADD
DEFMAC SUBTRACT,SUB
DEFMAC LOGOR,OR
此后，就可调用这三个宏了。如下的宏调用：
ADDITION VAR1,VAR2,RESULT
可得以下宏扩展：
PUSH AX
MOV AX,VAR1
ADD AX,VAR2
MOV RESULT,AX
POP AX
7.3重复汇编
有时程序中会连续地重复完全相同或几乎相同的一组语句，当出现这种情况时，可考虑用重复伪指令定义的重复块，以简化源程序。
重复块是允许建立重复语句块的宏的一种特殊形式。它们与宏的不同之处在于它们没有被命名，并因而不能被调用。
但象宏一样，它们可以有参数，且在汇编过程中参数可被实自变量代替；宏运算符、用伪指令LOCAL说明的符号等可用在重复块中；
重复块总是由伪指令ENDM结束。
本节介绍由伪指令REPT、IRP和IRPC定义的三种重复块，它们之间的不同点在于如何规定重复的次数。
7.3.1伪指令REPT
伪指令REPT用于创建重复块，重复块的重复次数由一数值表达式给定。一般格式如下：
REPT 表达式
需重复的语句组
ENDM
宏汇编程序将把“需重复的语句组”连续地重复汇编由表达式值所决定的次数。表达式必须可求出数值常数（16位的无符号数）。
任何有效的汇编程序语句均可以安排在“需重复的语句组”中。
例如：下面的语句实现把字符A到Z的ASCII码填入数组TABLE中：
CHAR = 'A'
TABLE LABEL BYTE
REPT 26
DB CHAR
CHAR = CHAR + 1
ENDM
实际的汇编结果与对如下指令的汇编结果相同：
TABLE LABEL BYTE
DB 'A'
DB 'A'+1
DB 'A'+2
......
DB 'A'+24
DB 'A'+25
7.3.2伪指令IRP
伪指令IRP用于创建重复块，重复次数和每次重复时使用的实参由实参数列表决定。一般格式如下：
IRP 形式参数,<实参1,实参2,......,实参n>
需重复的语句组
ENDM
实参的个数规定了重复的次数。宏汇编程序将把“需要重复的语句组”连续地重复汇编规定的次数，
并在每次重复时依次用相应位置的实参数代替“需重复语句组”中的形式参数。
实参数列表应放在一对尖括号内，若有多个实参数，则各实参数间用逗号分隔。
例如：下面的重复块实现把0~9的平方值存入数组QUART中：
QUART LABEL BYTE
IRP X,<0,1,2,3,4,5,6,7,8,9>
DB X*X
ENDM
再如：下面的重复块实现把若干寄存器值压入堆栈：
IRP REG,<AX,BX,CX,DX>
PUSH REG
ENDM
实际的汇编结果与对如下指令的汇编结果相同：
PUSH AX
PUSH BX
PUSH CX
PUSH DX
7.3.3伪指令IRPC
伪指令IRPC与伪指令IRP相似，但实参数列表是一个字符串，一般格式如下：
IRPC 形式参数,字符串
需重复的语句组
ENDM
字符串的长度规定了重复的次数。宏汇编程序将把“需要重复的语句组”连续地重复汇编规定的次数，
并在每次重复时依次用“字符串”中的一个字符作为实参数代替“需重复语句组”中的形式参数。
如果字符串含有空格、逗号等分隔符，那么字符串需用一对尖括号括起来。
例如：下面的重复块也实现把从2开始的10个偶数存入字节数组TABLE中：
TABLE LABEL BYTE
IRPC X,0123456789
DW (X + 1) * 2
ENDM
再如，下面的重复块实现把AX、BX、CX和DX四个寄存器依次压入堆栈：
IRPC REG,ABCD
PUSH REG&X
ENDM
注意，上述重复块中使用了分隔宏参数的强迫替换运算符“&”。
7.4条件汇编
条件汇编语句提供根据某种条件决定是否汇编某段源程序的功能。在源程序中使用条件汇编语句的主要目的是：
（1）通过在汇编前或汇编时改变某种条件，从而方便地产生功能不同的程序；
（2）增强宏定义能力，使得宏的适用范围更广；
（3）改善汇编效率。
尽管条件汇编语句在形式上与高级语言中的条件语句相似，但本质上却是完全不同的。
条件汇编语句是说明性语句，是由伪指令构成，它的功能由汇编程序实现；一般高级语言的条件语句是执行语句，它的功能由目标程序实现。
7.4.1条件汇编伪指令
条件汇编语句的一般格式如下：
IFxxxx 条件表达式
语句组1
[ELSE
语句组2]
ENDIF
IFxxxx是条件伪指令助记符的一般形式，其中xxxx表示构成条件伪指令助记符的其他字符。完整的条件伪指令助记符如下：
IF IFE IFDEF IFNDEF IF1 IF2
IFB IFNB IFIDN IFDIF
一定要在条件语句的最后安排伪指令ENDIF。条件表达式用于表示条件，不同的条件汇编指令，条件表达式的形式也有所不同。
语句组可含有任意正确的语句，包括其他的条件语句。伪指令ELSE及语句组2是可选的。
条件汇编语句的一般意义为：如果条件伪指令要求的条件满足，那么汇编语句组1，否则不汇编语句组1；
在含有ELSE伪指令的情况下，如果条件不满足，则汇编语句组2。
由于在上述形式中的语句组1或语句组2可再含有条件汇编语句，所以就可能形成条件汇编语句的嵌套。
汇编语言允许的嵌套层数足以满足一般应用需要。一个嵌套的ELSE伪指令总是与最近但又没有ELSE的IFxxxx伪指令相配。
1.伪指令IF和IFE
伪指令IF的一般格式如下：
IF 表达式
如果表达式的值不等于0，则条件满足，即条件为真。表达式不能包含向前引用，其结果应为一常数值。
伪指令IFE的一般格式如下：
IFE 表达式
如果表达式的值等于0，则条件满足，即条件为真。表达式不能包含向前引用，其结果应为一常数值。
IFE伪指令的条件与IF伪指令的条件相反。
例1：在下面的条件语句中，如果MFLAG值不为0，即条件满足，那么就汇编语句组1，否则汇编语句组2：
IF MFLAG
MOV AH,0
INT 16H
ELSE MOV AH,1
INT 21H
ENDIF
为了便于表示条件，条件表达式有时是关系表达式或逻辑表达式。
例2：在下面的条件语句中，条件表达式是一个关系表达式，根据关系表达式的求值方法，
如果PORT值为0，则该关系表达式的值为1，不为0，所以条件满足：
IF PORT EQ 0
PORTADDR = 3F8H
IVECTN = 0BH
IMASKV = 11110111B
ENDIF
例3：如下定义的宏SHIFTL使用了重复块和结束宏扩展伪指令EXITM：
SHIFTL MACRO OP,N
COUNT = 0
REPT N
SHL OP,1
COUNT = COUNT + 1
IF COUNT GE N
EXITM
ENDIF
ENDM
INC OP
ENDM
调用该宏和扩展的情况如下：
SHIFTL AX,1
SHL AX,1
INC AX
SHIFTL BX,3
SHL BX,1
SHL BX,1
SHL BX,1
INC BX
请注意伪指令EXITM的作用，它只中止一层扩展或重复。
2.伪指令IFDEF和IFNDEF
伪指令IFDEF的一般格式如下：
IFDEF 符号
如果符号已定义或被说明成外部符号，则条件满足，即条件为真。
伪指令IFNDEF的一般格式如下：
IFNDEF 符号
如果符号未定义或未被说明成外部符号，则条件满足，即条件为真。
伪指令IFDEF的条件与伪指令IFNDEF的条件相反。
例如：在下面的条件语句中，如果已先定义符号MLARGE，则条件满足，那么过程AXINC被定义为远过程，否则过程AXINC被定义成近过程：
IFDEF MLARGE
AXINC PROC FAR
INC AX
RETF
AXINC ENDP
ELSE
AXINC PROC NEAR
INC AX
RET
AXINC ENDP
ENDIF
符号可以在源程序中定义，也可以在汇编命令行中定义。如何在汇编命令行中定义符号，请参见有关汇编器使用手册。
3.伪指令IF1和IF2
伪指令IF1的格式如下：
IF1
若是第一趟扫描则条件为真。
伪指令IF2的格式如下：
IF2
若是第二趟扫描则条件为真。
7.4.2条件汇编与宏结合
1.宏中使用条件汇编
条件汇编与宏相结合，能大大扩大宏的使用范围。
例如：如下定义的宏ADDNUM有两个参数，在对宏调用扩展时，能根据不同的参数扩展成不同的指令：
ADDNUM MACRO REG,NUM
IF (NUM GT 2) OR (NUM LE 0)
ADD REG,NUM
ELSE
INC REG
IF NUM EQ 2
INC REG
ENDIF
ENDIF
ENDM
宏调用举例和相应的扩展情况如下：
ADDNUM AX,4
ADD AX,4
ADDNUM AX,2
INC AX
INC AX
ADDNUM AX,1
INC AX
ADDNUM AX,0
ADD AX,0
汇编语言还提供了专门用于测试宏参数的条件汇编伪指令，下面就介绍这些伪指令。
1.伪指令IFB和IFNB
伪指令IFB一般使用在宏定义内，格式如下：
IFB <参数>
如果在宏调用时没有使用实参来代替该形参，那么条件满足。注意，参数应该用尖扩号括起。
伪指令IFNB一般使用在宏定义内，格式如下：
IFNB <参数>
如果在宏调用时使用实参来代替该形参，那么条件满足。注意，参数应该用尖扩号括起。
伪指令IFNB的条件与伪指令IFB的条件相反。
例如：如下定义的宏PRINT，若指定显示信息时，则显示之，否则显示缺省信息：
PRINT MACRO MSG
IFB <MSG>
MOV SI,OFFSET DEFAULTMSG
ELSE
MOV SI,OFFSET MSG
ENDIF
CALL SHOWSTR
ENDM
2.伪指令IFIDN和IFDIF
伪指令IFIDN一般使用在宏定义内，格式如下：
IFIDN <参数1>,<参数2>
IFIDNI <参数1>,<参数2>
如果字符串参数1与字符串参数2相等，则条件满足。参数1或参数2可能是宏定义中的形参，如果是形参，比较之前先由相应的实参所代替。
字符串是按字符逐个比较的，格式一对大小写有区别，格式二忽略大小写区别。注意，参数应用尖括号括起。
伪指令IFDIF一般使用在宏定义内，格式如下：
IFDIF <参数1>,<参数2>
IFDIFI <参数1>,<参数2>
如果字符串参数1与字符串参数2不等，则条件满足。其他说明同上。
例如：如下定义的宏RDWR的第二个参数就决定了读写方式：
RDWR MACRO BUFF,RWMODE
LEA DX,BUFF
IFIDNI <RWMODE>,<READ>
CALL READFN
ENDIF
IFIDNI <RWMODE>,<WRITE>
CALL WRITEFN
ENDIF
ENDM
宏调用举例和相应的扩展如下：
RDWR MESS,WRITE
LEA DX,MESS
CALL WRITEFN
RDWR MESS,READ
LEA DX,MESS
CALL READFN
例如：如下定义的宏GETCH就有加强的功能：
GETCH MACRO CHAR
MOV AH,8
INT 21H
IFNB <CHAR>
IFDIFI <CHAR>,<AL>
MOV CHAR,AL
ENDIF
ENDIF
ENDM
7.5源程序的结合
为了便于编辑源程序和对程序进行修改或维护，汇编程序允许把源程序存放在多个文本文件中，在汇编时结合到一起，同时参加汇编。
本节介绍源程序的结合方法和应用。
7.5.1源程序的结合
存放在若干文本文件中的源程序的结合是利用伪指令INCLUDE完成的。它的一般格式如下：
INCLUDE 文件名
伪指令INCLUDE指示汇编程序将指定的文本文件从本行起加入汇编，直到该文本文件的最后一行汇编完后，继续汇编随后的语句。
文件名可带有盘符和路径，采用DOS有关规则表示。若文件名没有盘符或路径，则首先在由汇编命令行参数/I所指定的目录中寻找该文件，
然后再在当前目录中寻找该文件。对于MASM而言，最后还会在由环境变量INCLUDE所指定的目录中寻找该文件。
对于TASM而言，若文件名没有扩展名，则假设扩展名为ASM。
下列程序的功能是：接受一个字符串，然后按小写和大写形式重新显示字符串。整个源程序存放在三个文本文件中。
；程序名：T7-2.ASM
；功能：（略）
INCLUDE DATA.ASM
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESS_STR
MOV AH,9
INT 21H
MOV AH,10
MOV DX,OFFSET BUFFER
INT 21H
CALL NEWLINE
MOV BL,BUFFER+1
XOR BH,BH
MOV BYTE PTR BUFFER[BX+2],0
MOV SI,OFFSET BUFFER + 2
CALL STRLWR
MOV SI,OFFSET BUFFER + 2
CALL DISPMSG
CALL NEWLINE
MOV SI,OFFSET BUFFER + 2
CALL STRUPR
MOV SI,OFFSET BUFFER + 2
CALL DISPMSG
CALL NEWLINE
MOV AH,4CH
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
DISPMSG PROC
PUSHF
PUSH AX
PUSH SI
CLD
DISPMSG_S:LODSB
OR AL,AL
JZ DISPMSG_OK
MOV DL,AL
MOV AH,2
INT 21H
JMP DISPMSG_S
DISPMSG_OK:POP SI
POP AX
POPF
RET
DISPMSG ENDP
INCLUDE STRING.ASM
CSEG ENDS
END START
文本文件DATA.ASM含有数据部分，其内容如下所示：
；文件名：DATA.ASM
；内容：程序T7-2.ASM的一部分
DSEG SEGMENT
BUFFER DB 128,0,128 DUP (0)
MESS_STR DB 'Please input:$'
DSEG ENDS
文本文件STRING.ASM含有两个子程序STRLWR和STRUPR，它们分别实现把字符串转换成小写和大写，其内容如下所示：
；文件名：STRING.ASM
；内容：程序T7-2.ASM的一部分
STRLWR PROC
PUSHF
PUSH AX
PUSH SI
CLD
STRLWR_S:LODSB
AND AL,AL
JZ STRLWR_OK
CMP AL,'A'
JB STRLWR_NEXT
CMP AL,'Z'
JA STRLWR_NEXT
ADD AL,20H
MOV DS:[SI-1],AL
STRLWR_NEXT:JMP STRLWR_S
STRLWR_OK:POP SI
POP AX
POPF
RET
STRLWR ENDP
STRUPR PROC
PUSHF
PUSH AX
PUSH SI
CLD
STRUPR_S:LODSB
AND AL,AL
JZ STRUPR_OK
CMP AL,'a'
JB STRUPR_NEXT
CMP AL,'z'
JA STRUPR_NEXT
SUB AL,20H
MOV DS:[SI-1],AL
STRUPR_NEXT:JMP STRUPR_S
STRUPR_OK:POP SI
POP AX
POPF
RET
STRUPR ENDP
汇总成一个文件，测试通过的完整程序如下
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ALTF1 = 6800H
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
BUFFER DB 128,0,128 DUP (0)
MESS_STR DB 'Please input:$'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESS_STR
MOV AH,9
INT 21H
MOV AH,10
MOV DX,OFFSET BUFFER
INT 21H
CALL NEWLINE
MOV BL,BUFFER+1
XOR BH,BH
MOV BYTE PTR BUFFER[BX+2],0
MOV SI,OFFSET BUFFER + 2
CALL STRLWR
MOV SI,OFFSET BUFFER + 2
CALL DISPMSG
CALL NEWLINE
MOV SI,OFFSET BUFFER + 2
CALL STRUPR
MOV SI,OFFSET BUFFER + 2
CALL DISPMSG
CALL NEWLINE
MOV AH,4CH
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
DISPMSG PROC
PUSHF
PUSH AX
PUSH SI
CLD
DISPMSG_S:LODSB
OR AL,AL
JZ DISPMSG_OK
MOV DL,AL
MOV AH,2
INT 21H
JMP DISPMSG_S
DISPMSG_OK:POP SI
POP AX
POPF
RET
DISPMSG ENDP
STRLWR PROC
PUSHF
PUSH AX
PUSH SI
CLD
STRLWR_S:LODSB
AND AL,AL
JZ STRLWR_OK
CMP AL,'A'
JB STRLWR_NEXT
CMP AL,'Z'
JA STRLWR_NEXT
ADD AL,20H
MOV DS:[SI-1],AL
STRLWR_NEXT:JMP STRLWR_S
STRLWR_OK:POP SI
POP AX
POPF
RET
STRLWR ENDP
STRUPR PROC
PUSHF
PUSH AX
PUSH SI
CLD
STRUPR_S:LODSB
AND AL,AL
JZ STRUPR_OK
CMP AL,'a'
JB STRUPR_NEXT
CMP AL,'z'
JA STRUPR_NEXT
SUB AL,20H
MOV DS:[SI-1],AL
STRUPR_NEXT:JMP STRUPR_S
STRUPR_OK:POP SI
POP AX
POPF
RET
STRUPR ENDP
CSEG ENDS
END START
拆分成三个文件，测试通过的完整程序如下
DATA.ASM
DSEG SEGMENT
BUFFER DB 128,0,128 DUP (0)
MESS_STR DB 'Please input:$'
DSEG ENDS
STRING.ASM
STRLWR PROC
PUSHF
PUSH AX
PUSH SI
CLD
STRLWR_S:LODSB
AND AL,AL
JZ STRLWR_OK
CMP AL,'A'
JB STRLWR_NEXT
CMP AL,'Z'
JA STRLWR_NEXT
ADD AL,20H
MOV DS:[SI-1],AL
STRLWR_NEXT:JMP STRLWR_S
STRLWR_OK:POP SI
POP AX
POPF
RET
STRLWR ENDP
STRUPR PROC
PUSHF
PUSH AX
PUSH SI
CLD
STRUPR_S:LODSB
AND AL,AL
JZ STRUPR_OK
CMP AL,'a'
JB STRUPR_NEXT
CMP AL,'z'
JA STRUPR_NEXT
SUB AL,20H
MOV DS:[SI-1],AL
STRUPR_NEXT:JMP STRUPR_S
STRUPR_OK:POP SI
POP AX
POPF
RET
STRUPR ENDP
t387.asm
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ALTF1 = 6800H
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
INCLUDE DATA.ASM
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESS_STR
MOV AH,9
INT 21H
MOV AH,10
MOV DX,OFFSET BUFFER
INT 21H
CALL NEWLINE
MOV BL,BUFFER+1
XOR BH,BH
MOV BYTE PTR BUFFER[BX+2],0
MOV SI,OFFSET BUFFER + 2
CALL STRLWR
MOV SI,OFFSET BUFFER + 2
CALL DISPMSG
CALL NEWLINE
MOV SI,OFFSET BUFFER + 2
CALL STRUPR
MOV SI,OFFSET BUFFER + 2
CALL DISPMSG
CALL NEWLINE
MOV AH,4CH
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
DISPMSG PROC
PUSHF
PUSH AX
PUSH SI
CLD
DISPMSG_S:LODSB
OR AL,AL
JZ DISPMSG_OK
MOV DL,AL
MOV AH,2
INT 21H
JMP DISPMSG_S
DISPMSG_OK:POP SI
POP AX
POPF
RET
DISPMSG ENDP
INCLUDE STRING.ASM
CSEG ENDS
END START
7.5.2宏库的使用
通常程序员会把一组有价值和经常使用的宏定义集中存放在一个文本文件中，这样的文本文件称为宏库。
有了宏库后，只要在源程序首安排结合宏库的伪指令INCLUDE，便能方便地调用宏库中的宏。
这样做不仅节省编辑源程序的时间，而且能够减少错误。
例如：设已建立宏库DOSBIO.MAC，其内容如下：
GETSTR MACRO MBUFF
MOV DX,OFFSET MBUFF
MOV AH,10
INT 21H
ENDM
DISPSTR MACRO MBUFF
MOV DX,OFFSET MBUFF
MOV AH,9
INT 21H
ENDM
GETCH MACRO CHAR
MOV AH,8
INT 21H
IFNB <CHAR>
IFDIFI <CHAR>,<AL>
MOV CHAR,AL
ENDIF
ENDIF
ENDM
ECHOCH MACRO CHAR
IFNB <CHAR>
IFDIFI <CHAR>,<DL>
MOV DL,CHAR
ENDIF
ENDIF
MOV AH,2
INT 21H
ENDM
现在利用上述宏库DOSBIO.MAC改写程序T7-2.ASM如下：
；程序名：T7-3.ASM
；功能：（略）
INCLUDE DOSBIO.MAC
INCLUDE DATA.ASM
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
DISPSTR <MESS_STR>
GETSTR <BUFFER>
CALL NEWLINE
MOV BL,BUFFER+1
XOR BH,BH
MOV BYTE PTR BUFFER[BX+2],0
MOV SI,OFFSET BUFFER + 2
CALL STRLWR
MOV SI,OFFSET BUFFER + 2
CALL DISPMSG
CALL NEWLINE
MOV SI,OFFSET BUFFER + 2
CALL STRUPR
MOV SI,OFFSET BUFFER + 2
CALL DISPMSG
CALL NEWLINE
MOV AH,4CH
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
ECHOCH 0DH
ECHOCH 0AH
POP DX
POP AX
RET
NEWLINE ENDP
DISPMSG PROC
PUSHF
PUSH AX
PUSH DX
PUSH SI
CLD
DISPMSG_S:LODSB
OR AL,AL
JZ DISPMSG_OK
ECHOCH AL
JMP DISPMSG_S
DISPMSG_OK:POP SI
POP DX
POP AX
POPF
RET
DISPMSG ENDP
INCLUDE STRING.ASM
CSEG ENDS
END START
t387.asm和宏库汇总成一个文件，测试通过的完整程序如下
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ALTF1 = 6800H
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
GETSTR MACRO MBUFF
MOV DX,OFFSET MBUFF
MOV AH,10
INT 21H
ENDM
DISPSTR MACRO MBUFF
MOV DX,OFFSET MBUFF
MOV AH,9
INT 21H
ENDM
GETCH MACRO CHAR
MOV AH,8
INT 21H
IFNB <CHAR>
IFDIFI <CHAR>,<AL>
MOV CHAR,AL
ENDIF
ENDIF
ENDM
ECHOCH MACRO CHAR
IFNB <CHAR>
IFDIFI <CHAR>,<DL>
MOV DL,CHAR
ENDIF
ENDIF
MOV AH,2
INT 21H
ENDM
INCLUDE DATA.ASM
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
DISPSTR <MESS_STR>
GETSTR <BUFFER>
CALL NEWLINE
MOV BL,BUFFER+1
XOR BH,BH
MOV BYTE PTR BUFFER[BX+2],0
MOV SI,OFFSET BUFFER + 2
CALL STRLWR
MOV SI,OFFSET BUFFER + 2
CALL DISPMSG
CALL NEWLINE
MOV SI,OFFSET BUFFER + 2
CALL STRUPR
MOV SI,OFFSET BUFFER + 2
CALL DISPMSG
CALL NEWLINE
MOV AH,4CH
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
ECHOCH 0DH
ECHOCH 0AH
POP DX
POP AX
RET
NEWLINE ENDP
DISPMSG PROC
PUSHF
PUSH AX
PUSH SI
CLD
DISPMSG_S:LODSB
OR AL,AL
JZ DISPMSG_OK
ECHOCH AL
JMP DISPMSG_S
DISPMSG_OK:POP SI
POP AX
POPF
RET
DISPMSG ENDP
INCLUDE STRING.ASM
CSEG ENDS
END START
t388.asm和宏库拆分成两个文件，测试通过的完整程序如下
DOSBIO.MAC
GETSTR MACRO MBUFF
MOV DX,OFFSET MBUFF
MOV AH,10
INT 21H
ENDM
DISPSTR MACRO MBUFF
MOV DX,OFFSET MBUFF
MOV AH,9
INT 21H
ENDM
GETCH MACRO CHAR
MOV AH,8
INT 21H
IFNB <CHAR>
IFDIFI <CHAR>,<AL>
MOV CHAR,AL
ENDIF
ENDIF
ENDM
ECHOCH MACRO CHAR
IFNB <CHAR>
IFDIFI <CHAR>,<DL>
MOV DL,CHAR
ENDIF
ENDIF
MOV AH,2
INT 21H
ENDM
t388.asm
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ALTF1 = 6800H
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
INCLUDE DOSBIO.MAC
INCLUDE DATA.ASM
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
DISPSTR <MESS_STR>
GETSTR <BUFFER>
CALL NEWLINE
MOV BL,BUFFER+1
XOR BH,BH
MOV BYTE PTR BUFFER[BX+2],0
MOV SI,OFFSET BUFFER + 2
CALL STRLWR
MOV SI,OFFSET BUFFER + 2
CALL DISPMSG
CALL NEWLINE
MOV SI,OFFSET BUFFER + 2
CALL STRUPR
MOV SI,OFFSET BUFFER + 2
CALL DISPMSG
CALL NEWLINE
MOV AH,4CH
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
ECHOCH 0DH
ECHOCH 0AH
POP DX
POP AX
RET
NEWLINE ENDP
DISPMSG PROC
PUSHF
PUSH AX
PUSH DX
PUSH SI
CLD
DISPMSG_S:LODSB
OR AL,AL
JZ DISPMSG_OK
ECHOCH AL
JMP DISPMSG_S
DISPMSG_OK:POP SI
POP DX
POP AX
POPF
RET
DISPMSG ENDP
INCLUDE STRING.ASM
CSEG ENDS
END START
对上述程序有如下两点补充说明：
（1）由于MASM采用两遍扫描，并且只在第一遍扫描时登记宏定义，
所以可使用如下条件汇编伪指令，通知汇编程序在第一遍扫描时加入宏库，而在第二遍扫描时，不加入宏库：
IF1
INCLUDE DOSBIO.MAC
ENDIF
这样既加快了第二遍扫描的速度，又能避免在汇编列表清单中含有宏定义部分。
但必须注意，如果结合的不是宏库，则不能只在第一遍扫描时结合，而在第二遍扫描时不结合。
（2）宏库中可含有多个宏定义，一个程序不一定调用宏库中定义的全部宏。
例如，上述程序结合了宏库DOSBIO.MAC，但没有调用其中的宏GETCH。
对于不使用的宏，可以用伪指令PURGE清除。清除操作如下所示：
INCLUDE DOSBIO.MAC
PURGE GETCH
注意，上述清除操作对宏库没有影响。
汇编程序MASM对源程序文件执行两遍扫描
第一遍扫描：
(1) 语法检查。
(2) 确定每一条指令的段内偏移地址，并记录源程序定义的符号的偏移地址，形成一张"符号表"。
进行语法检查时，首先读入一条指令，查找"伪指令表"，检查该指令是不是伪指令，如是伪指令，执行该伪指令规定的操作。
若该语句不是伪指令，查找"机器指令表"，检查该指令是不是机器指令。
若读入的语句既不是伪指令、也不是机器指令，表明源程序出现了语法错误，在屏幕上显示出错位置及错误原因。
汇编程序MASM使用"地址计数器"来确定每一条指令的段内偏移地址。
开始汇编时，或在每一个"段"(SEGMENT)开始时，地址计数器的值初始化为0。
每处理一条指令，地址计数器的值就增加一个值，该值等于该指令对应的机器指令的长度。
如果所处理的语句是伪指令DB、DW、DD、DT，则地址计数器增加的值等于这些伪指令定义的存储区长度。
如果所处理的语句定义了符号，则把该符号名、属性、对应的地址计数值写入"符号表"。
过程的属性有FAR、NEAR，变量的属性有Byte、Word、DWord。
第二遍扫描：
根据"符号表"、"机器指令表"、"伪指令表"，把汇编语言指令翻译为机器指令，完成汇编任务。
在第二遍扫描时，如有"表达式"，如：
MOV AX,3 * 2
DB 4+5
则MASM将计算表达式的值。
7.6习题
题7.1结构类型和记录类型有什么用途？
利用结构类型能够说明复杂的数据类型，从而定义复杂的数据变量。
利用结构类型和结构字段，代码更容易阅读和修改。比如，可以通过结构字段名直接访问堆栈中的参数。
利用记录类型和记录操作符为按二进制位存取数据或信息提供了方便。
题7.2如下结构类型中各字段的相对偏移是多少？
PERSON STRUC
ID DB 8 DUP (?)
PCODE DW 0
ADDRESS DB 20 DUP (?)
PERSON ENDS
在上面定义的结构PERSON中，字段ID、PCODE和ADDRESS分别有偏移值0、8和10。
题7.3如何访问结构变量中的字段？请举例说明。
通过结构变量名可直接存取结构变量。若要存取结构变量中的某一字段，则可采用如下形式：
结构变量名.结构字段名
结构变量名与结构字段名之间用点号分隔，并且结构字段名所代表的字段必须是对应结构所具有的字段。
结构字段的地址偏移值是结构变量的地址偏移值与相应结构字段在结构变量中的相应偏移之和。
[寄存器名].结构字段名
把结构变量的地址偏移值先存入某个基址或变址寄存器，然后用"[寄存器名]"代替结构变量名。
结构字段的地址偏移值是寄存器的值与相应结构字段在结构变量中的相应偏移之和。
下面的程序片段说明了对结构字段的访问：
......
DATE STRUC
YEAR DW ?
MONTH DB ?
DAY DB ?
DATE ENDS
......
YESTERDAY DATE <1995,7,17>
TODAY DATE <1995,7,18>
TOMORROW DATE <1995,7,19>
......
MOV AL,YESTERDAY.DAY
MOV AH,TODAY.MONTH
MOV TOMORROW.YEAR,DX
......
......
MOV BX,OFFSET YESTERDAY
MOV AL,[BX].MONTH
......
题7.4如何访问记录变量中的字段？请举例说明。
一个记录可以含有多个字段，字段间用逗号分隔。一般情况下各字段的宽度之和不超过16。在说明记录类型时，不实际分配存储单元。
如果一个记录中所有说明字段的总宽度大于8，那么汇编程序会给对应的记录变量分配两字节，否则仅给对应的记录变量分配一字节。
记录变量是把二进制位分成一个或多个字段的字节或字变量。
操作符WIDTH返回记录或记录中字段的以位为单位的宽度。
操作符MASK返回1个8位或16位二进制数，这个二进制数中相应于指定字段的各位为1，其余各位为0。
如果记录是字节记录类型，那么就是一个8位二进制数，如果记录是字记录类型，那么就是一个16位二进制数。
记录字段名作为一个特殊的操作符，它不带操作数，直接返回该字段移到所在记录的最右端所需移动的位数。
由于CPU没有提供位操作指令，记录类型和记录操作符只能够提供访问记录中字段的便利。
下面的程序片段说明如何访问记录及其字段：
......
COLORT RECORD BLINK:1,BACK:3,INTENSE:1,FORE:3
ATTR COLORT <0,0,1,7>
......
CALL DISPLAYCHAR
......
DISPLAYCHAR PROC
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
MOV AX,DSEG
MOV DS,AX
MOV SI,0
MOV BP,1 SHL WIDTH BACK
DISPLAYCHAR_FORI1:CMP SI,BP
JAE DISPLAYCHAR_OK
CALL GETCH
MOV BH,0
MOV BL,ATTR
MOV CX,1
MOV AL,'A'
MOV AH,09H
INT 10H
MOV AL,ATTR
MOV AH,AL
AND AL,NOT MASK BACK
MOV CL,BACK
SHR AH,CL
INC AH
SHL AH,CL
AND AH,MASK BACK
OR AH,AL
MOV ATTR,AH
DISPLAYCHAR_NEXTI1:INC SI
JMP DISPLAYCHAR_FORI1
DISPLAYCHAR_OK:POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
RET
DISPLAYCHAR ENDP
......
该程序片段在当前光标位置处循环显示字符'A'，按一次键，则换一种背景色。
题7.5完善7.1.1节中的例1，使其能够按成绩排序，并在屏幕上显示输出。
COLOR = 07H
DPAGE = 0
ROW = 12
COLUMN = 28
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SCORE STRUC
NO DW ?
SNAME DB 8 DUP (20H)
CHN DB 0
MATH DB 0
ENG DB 0
SCORE ENDS
ITEM STRUC
NOS DW 0
SUM DW 0
ITEM ENDS
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
STR_SCOREDAT DB 'SCORE.DAT',0
STR_SCORESUM DB 'SCORE.SUM',0
HANDLE_SCOREDAT DW 0
HANDLE_SCORESUM DW 0
NUM_SI DW 0
NUM_DI DW 0
BUFFER SCORE <>
STABLE ITEM 30 DUP (<>)
BUFFER_SCOREDAT SCORE <1001,,101,101,101>
SCORE <1002,,102,102,102>
SCORE <1003,,103,103,103>
SCORE <1004,,104,104,104>
SCORE <1005,,105,105,105>
SCORE <1006,,106,106,106>
SCORE <1007,,107,107,107>
SCORE <1008,,108,108,108>
SCORE <1009,,109,109,109>
SCORE <1010,,110,110,110>
SCORE <1011,,111,111,111>
SCORE <1012,,112,112,112>
SCORE <1013,,113,113,113>
SCORE <1014,,114,114,114>
SCORE <1015,,115,115,115>
SCORE <1016,,116,116,116>
SCORE <1017,,117,117,117>
SCORE <1018,,118,118,118>
SCORE <1019,,119,119,119>
SCORE <1020,,120,120,120>
SCORE <1021,,121,121,121>
SCORE <1022,,122,122,122>
SCORE <1023,,123,123,123>
SCORE <1024,,124,124,124>
SCORE <1025,,125,125,125>
SCORE <1026,,126,126,126>
SCORE <1027,,127,127,127>
SCORE <1028,,128,128,128>
SCORE <1029,,129,129,129>
SCORE <1030,,130,130,130>
MESS_OPENERR DB 'Can not open file',07H,'$'
MESS_READERR DB 'Reading error',07h,'$'
MESS_CREAERR DB 'Can not create file',07H,'$'
MESS_WRITERR DB 'Writing error',07H,'$'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL WRITESCOREDAT
CALL WRITESCORESUM
MOV AH,4CH
INT 21H
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
HTOASC PROC
AND AL,0FH
ADD AL,30H
CMP AL,39H
JA HTOASC_NODEC
JMP HTOASC_OK
HTOASC_NODEC:ADD AL,7
HTOASC_OK:RET
HTOASC ENDP
AHTOASC PROC
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL HTOASC
XCHG AH,AL
CALL HTOASC
RET
AHTOASC ENDP
DAHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DAHTOASC ENDP
DHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH AX
XCHG AH,AL
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DHTOASC ENDP
WRITESCOREDAT PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET STR_SCOREDAT
MOV CX,0
MOV AH,3CH
INT 21H
JNC WRITESCOREDAT_CREAOK
WRITESCOREDAT_CREAERR:MOV DX,OFFSET MESS_CREAERR
CALL DISPMESS
JMP WRITESCOREDAT_OK
WRITESCOREDAT_CREAOK:MOV HANDLE_SCOREDAT,AX
MOV CX,(TYPE SCORE) * 30
MOV DX,OFFSET BUFFER_SCOREDAT
MOV BX,HANDLE_SCOREDAT
MOV AH,40H
INT 21H
JC WRITESCOREDAT_WRITERR
JMP WRITESCOREDAT_FINISH
WRITESCOREDAT_WRITERR:MOV DX,OFFSET MESS_WRITERR
CALL DISPMESS
WRITESCOREDAT_FINISH:MOV BX,HANDLE_SCOREDAT
MOV AH,3EH
INT 21H
WRITESCOREDAT_OK:POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
WRITESCOREDAT ENDP
WRITESCORESUM PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET STR_SCOREDAT
MOV AX,3D00H
INT 21H
JNC WRITESCORESUM_OPENOK
WRITESCORESUM_OPENERR:MOV DX,OFFSET MESS_OPENERR
CALL DISPMESS
JMP WRITESCORESUM_OK
WRITESCORESUM_OPENOK:MOV HANDLE_SCOREDAT,AX
MOV DX,OFFSET STR_SCORESUM
MOV CX,0
MOV AH,3CH
INT 21H
JNC WRITESCORESUM_CREAOK
WRITESCORESUM_CREAERR:MOV BX,HANDLE_SCOREDAT
MOV AH,3EH
INT 21H
MOV DX,OFFSET MESS_CREAERR
CALL DISPMESS
JMP WRITESCORESUM_OK
WRITESCORESUM_CREAOK:MOV HANDLE_SCORESUM,AX
MOV SI,OFFSET STABLE
WRITESCORESUM_READBUF:MOV DX,OFFSET BUFFER
MOV CX,TYPE SCORE
MOV BX,HANDLE_SCOREDAT
MOV AH,3FH
INT 21H
JC WRITESCORESUM_READERR
CMP AX,0
JZ WRITESCORESUM_READFINISH
MOV AL,BUFFER.CHN
XOR AH,AH
ADD AL,BUFFER.MATH
ADC AH,0
ADD AL,BUFFER.ENG
ADC AH,0
MOV [SI].SUM,AX
MOV AX,BUFFER.NO
MOV [SI].NOS,AX
ADD SI,TYPE ITEM
JMP WRITESCORESUM_READBUF
WRITESCORESUM_READFINISH:MOV BX,OFFSET STABLE
MOV CX,30
CALL SORTARRAYITEMDN
CALL DISPLAYSUMTABLE
MOV CX,(TYPE ITEM) * 30
MOV DX,OFFSET STABLE
MOV BX,HANDLE_SCORESUM
MOV AH,40H
INT 21H
JC WRITESCORESUM_WRITERR
JMP WRITESCORESUM_FINISH
WRITESCORESUM_READERR:MOV DX,OFFSET MESS_READERR
CALL DISPMESS
JMP WRITESCORESUM_FINISH
WRITESCORESUM_WRITERR:MOV DX,OFFSET MESS_WRITERR
CALL DISPMESS
WRITESCORESUM_FINISH:MOV BX,HANDLE_SCOREDAT
MOV AH,3EH
INT 21H
MOV BX,HANDLE_SCORESUM
MOV AH,3EH
INT 21H
WRITESCORESUM_OK:POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
WRITESCORESUM ENDP
SORTARRAYITEMUP PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
MOV AX,DSEG
MOV DS,AX
CMP CX,2
JB SORTARRAYITEMUP_OK
MOV AX,CX
SUB AX,2
ADD AX,AX
ADD AX,AX
ADD AX,BX
MOV WORD PTR NUM_SI,AX
MOV AX,CX
DEC AX
ADD AX,AX
ADD AX,AX
ADD AX,BX
MOV WORD PTR NUM_DI,AX
MOV SI,BX
SORTARRAYITEMUP_FORI1:CMP SI,WORD PTR NUM_SI
JA SORTARRAYITEMUP_OK
MOV AX,[SI].SUM
MOV DX,[SI].NOS
MOV DI,SI
ADD DI,4
SORTARRAYITEMUP_FORJ1:CMP DI,WORD PTR NUM_DI
JA SORTARRAYITEMUP_FINISHJ1
CMP AX,[DI].SUM
JBE SORTARRAYITEMUP_NEXTJ1
XCHG AX,[DI].SUM
XCHG DX,[DI].NOS
SORTARRAYITEMUP_NEXTJ1:ADD DI,4
JMP SORTARRAYITEMUP_FORJ1
SORTARRAYITEMUP_FINISHJ1:MOV [SI].SUM,AX
MOV [SI].NOS,DX
SORTARRAYITEMUP_NEXTI1:ADD SI,4
JMP SORTARRAYITEMUP_FORI1
SORTARRAYITEMUP_OK:POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
SORTARRAYITEMUP ENDP
SORTARRAYITEMDN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
MOV AX,DSEG
MOV DS,AX
CMP CX,2
JB SORTARRAYITEMDN_OK
MOV AX,CX
SUB AX,2
ADD AX,AX
ADD AX,AX
ADD AX,BX
MOV WORD PTR NUM_SI,AX
MOV AX,CX
DEC AX
ADD AX,AX
ADD AX,AX
ADD AX,BX
MOV WORD PTR NUM_DI,AX
MOV SI,BX
SORTARRAYITEMDN_FORI1:CMP SI,WORD PTR NUM_SI
JA SORTARRAYITEMDN_OK
MOV AX,[SI].SUM
MOV DX,[SI].NOS
MOV DI,SI
ADD DI,4
SORTARRAYITEMDN_FORJ1:CMP DI,WORD PTR NUM_DI
JA SORTARRAYITEMDN_FINISHJ1
CMP AX,[DI].SUM
JAE SORTARRAYITEMDN_NEXTJ1
XCHG AX,[DI].SUM
XCHG DX,[DI].NOS
SORTARRAYITEMDN_NEXTJ1:ADD DI,4
JMP SORTARRAYITEMDN_FORJ1
SORTARRAYITEMDN_FINISHJ1:MOV [SI].SUM,AX
MOV [SI].NOS,DX
SORTARRAYITEMDN_NEXTI1:ADD SI,4
JMP SORTARRAYITEMDN_FORI1
SORTARRAYITEMDN_OK:POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
SORTARRAYITEMDN ENDP
DISPLAYSUMTABLE PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
MOV AX,DSEG
MOV DS,AX
MOV SI,OFFSET STABLE
MOV BP,0
MOV CX,30
DISPLAYSUMTABLE_FORI1:CMP BP,CX
JAE DISPLAYSUMTABLE_OK
MOV AX,[SI].NOS
MOV DX,0
CALL DTOASC
MOV AL,20H
CALL PUTCH
MOV AX,[SI].SUM
MOV DX,0
CALL DTOASC
MOV AL,20H
CALL PUTCH
MOV AX,[SI+4].NOS
MOV DX,0
CALL DTOASC
MOV AL,20H
CALL PUTCH
MOV AX,[SI+4].SUM
MOV DX,0
CALL DTOASC
MOV AL,20H
CALL PUTCH
MOV AX,[SI+8].NOS
MOV DX,0
CALL DTOASC
MOV AL,20H
CALL PUTCH
MOV AX,[SI+8].SUM
MOV DX,0
CALL DTOASC
CALL NEWLINE
DISPLAYSUMTABLE_NEXTI1:INC BP
INC BP
INC BP
ADD SI,4
ADD SI,4
ADD SI,4
JMP DISPLAYSUMTABLE_FORI1
DISPLAYSUMTABLE_OK:POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DISPLAYSUMTABLE ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
DTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CMP DX,0
JNZ DTOASC1
CMP AX,0
JNZ DTOASC1
MOV AL,'0'
CALL PUTCH
JMP DTOASC_OK
DTOASC1:mov bp,0
divide_dtoasc:cmp dx,0
jz finish_s_dtoasc1
divide_s_dtoasc:mov cx,10
call divdw
inc bp
push cx
jmp divide_dtoasc
finish_s_dtoasc1:cmp ax,0
jz finish_dtoasc
jmp divide_s_dtoasc
finish_dtoasc:mov cx,bp
jcxz DTOASC_OK
string_dtoasc:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string_dtoasc
DTOASC_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOASC ENDP
CSEG ENDS
END START
题7.6比较宏与子程序，它们有何异同？它们的本质区别是什么？
宏调用与子程序调用之间的不同
（1）宏调用是通过宏指令名进行的，在汇编时，由汇编程序把宏展开，有多少次宏调用，就有相应次的宏扩展，因此并不简化目标程序。
子程序调用是在程序执行期间执行CALL指令进行的，子程序的代码只在目标程序中出现一次，所以目标程序也得到相应的简化。
（2）宏调用时的参数由汇编程序通过实参替换形参的方式实现传递，所以参数很灵活。
子程序调用时的参数须通过寄存器、堆栈或约定的内存单元传递。
（3）宏调用是在汇编时完成，所以不需要额外的时间开销。子程序调用和子程序返回均需要时间，且还涉及堆栈。
宏调用与子程序调用之间的本质区别
宏调用是在汇编时由汇编程序完成的，子程序调用是在程序执行期间执行CALL指令进行的。
宏和子程序都能简化源程序。当程序片段不长，速度是主要矛盾时，通常采用宏指令的方法简化源程序；
当程序片段较长，节约存储空间是主要矛盾时，通常采用子程序的方法简化源程序和目标程序。
题7.7简述宏指令的用途？就每种用途，分别举例说明。
宏指令的用途
1.缩短源代码
若在源程序中要多次使用到某个程序片段，那么就可以把此程序片段定义为一条宏指令。
此后，在需要这个程序片段之处安排一条对应的宏指令就行了，由汇编程序在汇编时产生对应的代码。
这不仅能有效地缩短源代码，而且能减少编辑汇编语言源程序过程中的错误。
例如，我们把使光标另起一行的程序片段写成如下的一个宏：
NEWLINE MACRO
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
ENDM
2.扩充指令集
CPU的指令集是确定的，但利用宏能在汇编语言中在形式上对指令集进行扩充。扩充后的指令集是机器指令集与宏指令集的并集。
这不仅能方便源程序的编写，而且便于阅读理解源程序。
例如，我们可定义一条宏指令PUSHA，由它实现把8个通用寄存器全部压入堆栈的功能。
我们还可定义宏指令POPA实现把由PUSHA压栈的8个通用寄存器依次退栈的功能。
PUSHA MACRO
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SP
PUSH BP
PUSH SI
PUSH DI
ENDM
POPA MACRO
POP DI
POP SI
POP BP
POP SP
POP DX
POP CX
POP BX
POP AX
ENDM
3.改变某些指令助记符的意义
宏指令名可以与指令助记符或伪操作名相同，在这种情况下，宏指令的优先级最高，而同名的指令或伪操作就失效了。
利用宏指令的这一特点，可以改变指令助记符的意义。
例如，在定义如下宏指令后，助记符LODSB所表示指令的意义就变化了：
LODSB MACRO
MOV AH,[SI]
INC SI
ENDM
题7.8宏汇编语言有哪三种类型的语句？它们各有何特征？
一种是机器指令语句，汇编程序在对机器指令语句进行汇编时，把机器指令语句翻译成与其对应的机器指令。
一种是伪指令语句，伪指令语句没有与其对应的机器指令，只是指示汇编程序如何汇编源程序，包括符号的定义、变量的定义、段的定义等。
一种是宏指令语句，利用宏定义伪指令，可以把一个需要多次使用的程序片段定义为一宏指令。
在写源程序时，程序员用宏指令来表示程序片段；在汇编时，汇编程序用对应的程序片段代替宏指令。
题7.9宏指令中的参数有何用途？宏调用如何传递参数？如何使得宏参数是字符串或标号的一部分？
宏指令可以不带参数，带参数的宏指令更具灵活性。
宏指令在使用之前要先定义。宏定义的一般格式如下：
宏指令名 MACRO [形式参数,形式参数,......,形式参数]
......
由指令、伪指令和宏指令构成的程序片段
......
ENDM
使用宏指令来表示对应的程序片段，称为宏调用。宏调用的一般格式如下：
宏指令名 [实参数,实参数,......,实参数]
其中，实参数应该与宏定义时的形式参数相对应。
宏指令的参数可以是常数、寄存器和存储单元，可以是表达式，也可以是操作码。
例如：在逻辑左移指令SHL的基础上定义一条宏指令SHLN，它能实现指定次数的左移。
SHLN MACRO REG,NUM
PUSH CX
MOV CL,NUM
SHL REG,CL
POP CX
ENDM
此后，可有如下格式的各种宏调用：
SHLN BL,5
SHLN SI,9
SHLN AX,CL
例如：下面的宏指令MANDM有三个参数，第一个参数OPR作为操作符使用在宏体的指令中
MANDM MACRO OPR,X,Y
MOV AX,X
OPR AX,Y
MOV X,AX
ENDM
调用宏MANDM及其宏扩展如下所示：
MANDM MOV [BX],[SI]
宏扩展
MOV AX,[BX]
MOV AX,[SI]
MOV [BX],AX
调用宏MANDM及其宏扩展如下所示：
MANDM ADD [BX],ES:[1234H]
宏扩展
MOV AX,[BX]
ADD AX,ES:[1234H]
MOV [BX],AX
宏调用的实参个数可以与宏定义时的形参个数不一致。
若实参个数多于形参个数，那么多余的实参被忽略；若实参的个数少于形参的个数，那么多余的形参用“空”代替。
调用宏MANDM及其宏扩展如下所示：
MANDM SUB,VAR1,VAR2,VAR3
宏扩展
MOV AX,VAR1
SUB AX,VAR2
MOV VAR1,AX
显然，多余的实参VAR3被忽略。
调用宏MANDM及其宏扩展如下所示：
MANDM MOV,VAR1
宏扩展
MOV AX,VAR1
MOV AX,
MOV VAR1,AX
汇编程序将指示语句"MOV AX,"有错。
使用强迫替换运算符&、字符串原样传递运算符<>、文字字符运算符!，可以使得宏参数是字符串或标号的一部分。
为了方便宏的定义和调用，汇编程序还支持特殊的宏运算符。
强迫替换运算符&
在宏定义中，若参数刚好在其它字符的前面或后面，或者参数出现在带引号的字符串中时，就必须使用该运算符，以区分参数。
例如：在下面定义的宏指令JUMP中，参数CON作为操作码的部分。
JUMP MACRO CON,LAB
J&CON LAB
ENDM
调用宏JUMP及其宏扩展如下所示：
JUMP NZ,HERE
宏扩展
JNZ HERE
调用宏JUMP及其宏扩展如下所示：
JUMP Z,THERE
宏扩展
JZ THERE
例如：下面定义的宏MSGGEN中，两个参数合并成标号，一个参数用在字符串中。
MSGGEN MACRO LAB,NUM,XYZ
LAB&NUM DB 'HELLO MR.&XYZ',0DH,0AH,24H
ENDM
调用宏MSGGEN及其宏扩展如下所示：
MSGGEN MSG,1,TAYLOR
宏扩展
MSG1 DB 'HELLO MR.TAYLOR',0DH,0AH,24H
字符串原样传递运算符<>
字符串原样传递运算符是一对尖括号，由它括起的内容作为一个字符串。
在宏调用时，若实参包含逗号或空格等间隔符，则必须使用该运算符，以保证实参的完整。
若实参是某个有特殊意义的字符，为了使它只表示字符本身，也可使用该运算符，把它括起来。
例如：定义如下的宏：
DFMESS MACRO MESS
DB '&MESS',0DH,0AH,0 
ENDM
定义的字符串以0结尾
调用宏DFMESS及宏扩展如下所示：
DFMESS <This is a example>
DB 'This is a example',0DH,0AH,0
如果不使用该运算符，则情况如下所示：
DFMESS This is a example
DB 'This',0DH,0AH,0
文字字符运算符!
该运算符使其后的一个字符只作为一般字符。在宏调用时，如果实参中含有一些特殊字符，
为了使这些特殊字符作为一般字符来处理，那么就必须在其前冠上该运算符。
例如：利用上述宏DFMESS定义字符串"Can not enter >99"。由于字符串含有特殊符号">"，为避免它与上述字符串原样传递运算符相混，
则必须在其前冠该运算符。相应的宏调用及宏扩展如下所示：
DFMESS <Can not enter !>99>
DB 'Can not enter >99',0DH,0AH,0
表达式运算符%
在宏调用时，使用该运算符能把其后表达式的结果作为实参替换，而非表达式自身。
例如：调用上述宏DFMESS，宏调用和宏扩展如下所示
使用表达式运算符%
DFMESS %(12+3-4)
DB '11',0DH,0AH,0
未使用表达式运算符%
DFMESS 12+3-4
DB '12+3-4',0DH,0AH,0
宏注释
在宏定义中，如果注释以两个分号引导，那么宏扩展时该注释不出现。
题7.10编写一个可把所有段寄存器和通用寄存器压入堆栈的宏。
不考虑CS、IP、SS、SP
段寄存器、通用寄存器、标志寄存器入栈的宏
PUSHALL MACRO
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
ENDM
段寄存器、通用寄存器、标志寄存器出栈的宏
POPALL MACRO
POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
ENDM
题7.11编写一个利用BIOS显示I/O程序实现回车换行的宏。
NEWLINE MACRO
PUSH AX
PUSH BX
MOV AH,0FH
INT 10H
MOV AL,0DH
MOV AH,0EH
INT 10H
MOV AL,0AH
MOV AH,0EH
INT 10H
POP BX
POP AX
ENDM
题7.12请编写一个定义堆栈段的宏。
DEFSSEG MACRO SEGNAME,NUM
SEGNAME SEGMENT PARA STACK
DW NUM DUP (?)
SEGNAME ENDS
ENDM
题7.13请编写一个在堆栈中定义若干局部变量的宏。可通过基于BP寄存器的相对寻址访问这些局部变量。
DEFSVAR MACRO SVAL
MOV AX,BP
IRP X,SVAL
SUB SP,2
SUB BP,2
MOV WORD PTR [BP] ,X
ENDM
MOV BP,AX
ENDM
DEFSVAR宏的参数为相应局部变量的值，使用IRP进行重复汇编
DEFSVAR <!<1111H,2222H,3333H!>>
题7.14请编写一个撤消堆栈中局部变量的宏。该宏与习题7.13所定义的宏相对应。
POPSVAR MACRO SREG
IRP X,SREG
POP X
ENDM
ENDM
POPSVAR宏的参数为相应局部变量的寄存器，使用IRP进行重复汇编
POPSVAR <!<AX,AX,AX!>>
测试通过的完整程序如下
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ALTF1 = 6800H
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
PUSHALL MACRO
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
ENDM
POPALL MACRO
POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
ENDM
NEWLINE MACRO
PUSH AX
PUSH BX
MOV AH,0FH
INT 10H
MOV AL,0DH
MOV AH,0EH
INT 10H
MOV AL,0AH
MOV AH,0EH
INT 10H
POP BX
POP AX
ENDM
DEFSSEG MACRO SEGNAME,NUM
SEGNAME SEGMENT PARA STACK
DW NUM DUP (?)
SEGNAME ENDS
ENDM
DEFSVAR MACRO SVAL
MOV AX,BP
IRP X,SVAL
SUB SP,2
SUB BP,2
MOV WORD PTR [BP] ,X
ENDM
MOV BP,AX
ENDM
POPSVAR MACRO SREG
IRP X,SREG
POP X
ENDM
ENDM
DEFSSEG SSEG,256
CSEG SEGMENT
ASSUME CS:CSEG
START:CALL PRINTSVAR
MOV AH,4CH
INT 21H
PRINTSVAR PROC
PUSHALL
PUSH BP
MOV BP,SP
DEFSVAR <!<1111H,2222H,3333H!>>
POPSVAR <!<AX,AX,AX!>>
NEWLINE
MOV SP,BP
POP BP
POPALL
RET
PRINTSVAR ENDP 
CSEG ENDS
END START
题7.15编写一个把1位十六进制数字ASCII码符转换为对应二进制数的宏。
ATOBIN MACRO
LOCAL ATOBIN_OK
SUB AL,30H
CMP AL,9
JBE ATOBIN_OK
SUB AL,7
CMP AL,15
JBE ATOBIN_OK
SUB AL,20H
ATOBIN_OK:
ENDM
ATOBIN宏没有参数，AL必须是'0'-'9','A'-'F','a'-'f'这样的十六进制ASCII码字符
MOV AL,'3'
MOV AH,0
ATOBIN
题7.16请编写一个清除键盘缓冲区的宏。
CLEARBUFKB MACRO
LOCAL CLEARBUFKB_S,CLEARBUFKB_OK
PUSH AX
CLEARBUFKB_S:MOV AH,1
INT 16H
JZ CLEARBUFKB_OK
MOV AH,0
INT 16H
JMP CLEARBUFKB_S
CLEARBUFKB_OK:POP AX
ENDM
CLEARBUFKB宏没有参数
题7.17什么是宏定义的嵌套？请举例说明。
宏定义的嵌套有两种情况：宏定义体中含宏调用；宏定义体中含宏定义。
宏定义体中调用宏，必须先定义后调用。
例如，宏WHTOASC的定义体内就调用了宏HTOASC
HTOASC MACRO
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
ENDM
WHTOASC MACRO
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
HTOASC
XCHG AH,AL
HTOASC
ENDM
宏定义体中可含有宏定义，但只有在调用了外层的宏后，内层的宏定义才有效。
例如，宏DEFMAC含有一个宏定义，并且外层宏的参数MACNAME是内层的宏指令名
DEFMAC MACRO MACNAME,OPERATOR
MACNAME MACRO X,Y,Z
PUSH AX
MOV AX,X
OPERATOR AX,Y
MOV Z,AX
POP AX
ENDM
ENDM
生成宏指令ADDITION
DEFMAC ADDITION,ADD
调用宏ADDITION
ADDITION VAR1,VAR2,RESULT
题7.18宏定义的嵌套有何用途？请举例说明。
宏定义的嵌套有两种情况：宏定义体中含宏调用；宏定义体中含宏定义。
宏定义的嵌套、重复汇编相结合可以进一步简化源程序，增强宏定义能力。
例如，宏WHTOASC的定义体内就调用了宏HTOASC
HTOASC MACRO
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
ENDM
WHTOASC MACRO
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
HTOASC
XCHG AH,AL
HTOASC
ENDM
例如，宏DEFSVAR的定义体内就调用了重复汇编
DEFSVAR MACRO SVAL
MOV AX,BP
IRP X,SVAL
SUB SP,2
SUB BP,2
MOV WORD PTR [BP] ,X
ENDM
MOV BP,AX
ENDM
例如，宏POPSVAR的定义体内就调用了重复汇编
POPSVAR MACRO SREG
IRP X,SREG
POP X
ENDM
ENDM
调用宏DEFSVAR和POPSVAR
PUSH BP
MOV BP,SP
DEFSVAR <!<1111H,2222H,3333H!>>
POPSVAR <!<AX,AX,AX!>>
......
MOV SP,BP
POP BP
......
题7.19请编写一个用2位十六进制数显示AL内容的宏。该宏调用已定义的宏HTOASC和宏ECHO。
宏HTOASC把1位十六进制数转换成对应的ASCII码，宏ECHO显示字符。
HTOASC MACRO
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
ENDM
WHTOASC MACRO
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
HTOASC
XCHG AH,AL
HTOASC
ENDM
ECHOCH MACRO CHAR
PUSH AX
PUSH DX
IFNB <CHAR>
IFDIFI <CHAR>,<DL>
MOV DL,CHAR
ENDIF
ENDIF
MOV AH,2
INT 21H
POP DX
POP AX
ENDM
DWHTOASC MACRO
PUSH AX
PUSH DX
WHTOASC
ECHOCH AH
ECHOCH AL
POP DX
POP AX
ENDM
调用宏DWHTOASC
MOV AL,'3'
MOV AH,0
ATOBIN
DWHTOASC
测试通过的完整程序如下
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ALTF1 = 6800H
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
PUSHALL MACRO
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
ENDM
POPALL MACRO
POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
ENDM
NEWLINE MACRO
PUSH AX
PUSH BX
MOV AH,0FH
INT 10H
MOV AL,0DH
MOV AH,0EH
INT 10H
MOV AL,0AH
MOV AH,0EH
INT 10H
POP BX
POP AX
ENDM
DEFSSEG MACRO SEGNAME,NUM
SEGNAME SEGMENT PARA STACK
DW NUM DUP (?)
SEGNAME ENDS
ENDM
DEFSVAR MACRO SVAL
MOV AX,BP
IRP X,SVAL
SUB SP,2
SUB BP,2
MOV WORD PTR [BP] ,X
ENDM
MOV BP,AX
ENDM
POPSVAR MACRO SREG
IRP X,SREG
POP X
ENDM
ENDM
ATOBIN MACRO
LOCAL ATOBIN_OK
SUB AL,30H
CMP AL,9
JBE ATOBIN_OK
SUB AL,7
CMP AL,15
JBE ATOBIN_OK
SUB AL,20H
ATOBIN_OK:
ENDM
CLEARBUFKB MACRO
LOCAL CLEARBUFKB_S,CLEARBUFKB_OK
PUSH AX
CLEARBUFKB_S:MOV AH,1
INT 16H
JZ CLEARBUFKB_OK
MOV AH,0
INT 16H
JMP CLEARBUFKB_S
CLEARBUFKB_OK:POP AX
ENDM
HTOASC MACRO
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
ENDM
WHTOASC MACRO
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
HTOASC
XCHG AH,AL
HTOASC
ENDM
ECHOCH MACRO CHAR
PUSH AX
PUSH DX
IFNB <CHAR>
IFDIFI <CHAR>,<DL>
MOV DL,CHAR
ENDIF
ENDIF
MOV AH,2
INT 21H
POP DX
POP AX
ENDM
DWHTOASC MACRO
PUSH AX
PUSH DX
WHTOASC
ECHOCH AH
ECHOCH AL
POP DX
POP AX
ENDM
DEFSSEG SSEG,256
CSEG SEGMENT
ASSUME CS:CSEG
START:CALL PRINTSVAR
MOV AH,4CH
INT 21H
PRINTSVAR PROC
PUSHALL
PUSH BP
MOV BP,SP
DEFSVAR <!<1111H,2222H,3333H!>>
POPSVAR <!<AX,AX,AX!>>
MOV AL,'3'
MOV AH,0
ATOBIN
DWHTOASC
CLEARBUFKB
NEWLINE
MOV SP,BP
POP BP
POPALL
RET
PRINTSVAR ENDP 
CSEG ENDS
END START
题7.20请编写一个可定义各种移位宏指令的宏。所定义的宏指令所移位的次数不限于1或者CL，而可以是常数或者其他8位寄存器。
DEFSHIFT MACRO SHIFTNAME,OPERATOR
SHIFTNAME MACRO OPRD,NUM
PUSH CX
IFNB <NUM>
IFDIFI <NUM>,<CL>
MOV CL,NUM
ENDIF
ENDIF
OPERATOR OPRD,NUM
POP CX
ENDM
ENDM
调用宏DEFSHIFT
DEFSHIFT SHLN,SHL
调用宏SHLN
SHLN AX,2
题7.21请利用重复汇编的方法定义一个缓冲区。缓冲区有100双字构成，每个双字的高字部分的初值依次是2，4，6，…，200，
低字部分的初值总是0。
DEFBUF MACRO BUFNAME,NUM
HIGHVAL = 2
BUFNAME LABEL DWORD
REPT NUM
DW 0
DW HIGHVAL
HIGHVAL = HIGHVAL + 2
ENDM
ENDM
调用宏DEFBUF
DSEG SEGMENT
......
DEFBUF PRINT_BUF,128
......
DSEG ENDS
......
ASSUME CS:CSEG,DS:DSEG
......
MOV AX,DSEG
MOV DS,AX
MOV BX,OFFSET PRINT_BUF
......
题7.22请利用重复汇编的方法实现把通用寄存器和段寄存器依次推入堆栈实现保护。
PUSHSEG MACRO SEGNAME
IRP X,SEGNAME
PUSH X
ENDM
ENDM
POPSEG MACRO SEGNAME
IRP X,SEGNAME
POP X
ENDM
ENDM
调用宏PUSHSEG和POPSEG
PUSHSEG <!<AX,BX,CX,DX,SI,DI,BP,DS,ES!>>
POPSEG <!<ES,DS,BP,DI,SI,DX,CX,BX,AX!>>
题7.23设程序中有8个标号，分别为NEXT1，NEXT2，…，NEXT8。
请利用重复汇编的方法定义由上述8个标号构成的散转表，每项由段值和偏移构成。
DEFLABTAB MACRO TABNAME,LABNAME
TABNAME LABEL DWORD
IRP X,LABNAME
DW OFFSET X
DW SEG X
ENDM
ENDM
调用宏DEFLABTAB
DSEG SEGMENT
......
DEFLABTAB NEXT_TAB,<!<NEXT1,NEXT2,NEXT3,NEXT4,NEXT5,NEXT6,NEXT7,NEXT8!>>
......
DSEG ENDS
......
ASSUME CS:CSEG,DS:DSEG
......
MOV AX,DSEG
MOV DS,AX
MOV BX,OFFSET NEXT_TAB
......
题7.24请利用重复汇编的另一种方法实现习题7.23之要求。
DEFLABNUMTAB MACRO TABNAME,NUM,LABX,LABY,LABZ
COUNTVAL = 0
TABNAME LABEL DWORD
REPT NUM
IF COUNTVAL EQ 0
DW OFFSET LABX
DW SEG LABX
ENDIF
IF COUNTVAL EQ 1
DW OFFSET LABY
DW SEG LABY
ENDIF
IF COUNTVAL EQ 2
DW OFFSET LABZ
DW SEG LABZ
ENDIF
COUNTVAL = COUNTVAL + 1
ENDM
ENDM
调用宏DEFLABNUMTAB
DSEG SEGMENT
......
DEFLABNUMTAB NEXT_TAB1,3,NEXT1,NEXT2,NEXT3
DEFLABNUMTAB NEXT_TAB2,3,NEXT4,NEXT5,NEXT6
DEFLABNUMTAB NEXT_TAB3,2,NEXT7,NEXT8
......
DSEG ENDS
......
ASSUME CS:CSEG,DS:DSEG
......
MOV AX,DSEG
MOV DS,AX
MOV BX,OFFSET NEXT_TAB1
......
题7.25把习题题7.13和习题7.14所要求定义的宏结合成一个宏。
PUPOSVAR MACRO OPRM,SOPRD
IFIDNI <OPRM>,<PUSH>
MOV AX,BP
IRP X,SOPRD
SUB SP,2
SUB BP,2
MOV WORD PTR [BP] ,X
ENDM
MOV BP,AX
ENDIF
IFIDNI <OPRM>,<POP>
IRP X,SOPRD
POP X
ENDM
ENDIF
ENDM
调用宏PUPOSVAR
PUPOSVAR PUSH,<!<1111H,2222H,3333H!>>
PUPOSVAR POP,<!<AX,AX,AX!>>
题7.26条件汇编有何用途？请举例说明。
条件汇编允许根据某种条件决定是否汇编某段源程序。通过在汇编前或汇编时改变某种条件，可以产生功能不同的程序，改善汇编效率。
条件汇编使得宏定义能力增强，宏的适用范围更广。条件汇编语句是说明性语句，由伪指令构成，它的功能由汇编程序实现。
条件汇编语句的一般格式如下：
IFxxxx 条件表达式
语句组1
[ELSE
语句组2]
ENDIF
IFxxxx是条件伪指令助记符的一般形式，其中xxxx表示构成条件伪指令助记符的其他字符。
条件汇编语句的一般意义为：如果条件伪指令要求的条件满足，那么汇编语句组1，否则不汇编语句组1；
在含有ELSE伪指令的情况下，如果条件不满足，则汇编语句组2。
伪指令IF的一般格式如下：
IF 表达式
如果表达式的值不等于0，则条件满足，即条件为真。表达式不能包含向前引用，其结果应为一常数值。
伪指令IFE的一般格式如下：
IFE 表达式
如果表达式的值等于0，则条件满足，即条件为真。表达式不能包含向前引用，其结果应为一常数值。
例如：如果MFLAG值不为0，就汇编语句组1，否则汇编语句组2
IF MFLAG
MOV AH,0
INT 16H
ELSE MOV AH,1
INT 21H
ENDIF
条件表达式有时是关系表达式或逻辑表达式。
例如：如果PORT值为0，就汇编语句组1
IF PORT EQ 0
PORTADDR = 3F8H
IVECTN = 0BH
IMASKV = 11110111B
ENDIF
伪指令IFDEF的一般格式如下：
IFDEF 符号
如果符号已定义或被说明成外部符号，则条件满足，即条件为真。
伪指令IFNDEF的一般格式如下：
IFNDEF 符号
如果符号未定义或未被说明成外部符号，则条件满足，即条件为真。
例如：如果已先定义符号MLARGE，则条件满足，那么过程AXINC被定义为远过程，否则过程AXINC被定义成近过程：
IFDEF MLARGE
AXINC PROC FAR
INC AX
RETF
AXINC ENDP
ELSE
AXINC PROC NEAR
INC AX
RET
AXINC ENDP
ENDIF
伪指令IF1的格式如下：
IF1
若是第一趟扫描则条件为真。
伪指令IF2的格式如下：
IF2
若是第二趟扫描则条件为真。
伪指令IFB一般使用在宏定义内，格式如下：
IFB <参数>
如果在宏调用时没有使用实参来代替该形参，那么条件满足。注意，参数应该用尖扩号括起。
伪指令IFNB一般使用在宏定义内，格式如下：
IFNB <参数>
如果在宏调用时使用实参来代替该形参，那么条件满足。注意，参数应该用尖扩号括起。
例如：宏PRINT，若指定显示信息时，则显示之，否则显示缺省信息：
PRINT MACRO MSG
IFB <MSG>
MOV SI,OFFSET DEFAULTMSG
ELSE
MOV SI,OFFSET MSG
ENDIF
CALL SHOWSTR
ENDM
伪指令IFIDN一般使用在宏定义内，格式如下：
IFIDN <参数1>,<参数2>
IFIDNI <参数1>,<参数2>
如果字符串参数1与字符串参数2相等，则条件满足。参数1或参数2可能是宏定义中的形参，如果是形参，比较之前先由相应的实参所代替。
字符串是按字符逐个比较的，格式一对大小写有区别，格式二忽略大小写区别。注意，参数应用尖括号括起。
伪指令IFDIF一般使用在宏定义内，格式如下：
IFDIF <参数1>,<参数2>
IFDIFI <参数1>,<参数2>
如果字符串参数1与字符串参数2不等，则条件满足。其他说明同上。
例如：宏RDWR的第二个参数就决定了读写方式：
RDWR MACRO BUFF,RWMODE
LEA DX,BUFF
IFIDNI <RWMODE>,<READ>
CALL READFN
ENDIF
IFIDNI <RWMODE>,<WRITE>
CALL WRITEFN
ENDIF
ENDM
题7.27请编写一个可实现把操作数1和操作数2相加之和送操作数1的宏。操作数1及操作数2可能都是存储器单元，也可能都是寄存器。
所定义的宏应能区分这些情况，并分别对待。
ADDREMEMO MACRO MODE1,OPRD1,OPRD2
IFIDNI <MODE1>,<REG>
ADD OPRD1,OPRD2
ENDIF
IFIDNI <MODE1>,<MEM>
PUSH AX
MOV AX,OPRD1
ADD AX,OPRD2
MOV OPRD1,AX
POP AX
ENDIF
ENDM
......
DSEG SEGMENT
......
NUM_AX DW 1111H
NUM_BX DW 2222H
......
DSEG ENDS
......
ASSUME CS:CSEG,DS:DSEG
......
MOV AX,DSEG
MOV DS,AX
......
ADDREMEMO MEM,<WORD PTR NUM_AX>,<WORD PTR NUM_BX>
ADDREMEMO REG,BX,<WORD PTR NUM_BX>
......
题7.28请编写一个可实现把操作数1和操作数2相乘之积送操作数3的宏。该宏必须通用、灵活和高效。
MULREME MACRO OPRD1,OPRD2,OPRD3
IFNB <OPRD3>
PUSH AX
PUSH DX
IFDIFI <OPRD1>,<AX>
MOV AX,OPRD1
ENDIF
MUL OPRD2
MOV OPRD3,AX
MOV OPRD3+2,DX
POP DX
POP AX
ENDIF
IFB <OPRD3>
IFDIFI <OPRD1>,<AX>
MOV AX,OPRD1
ENDIF
MUL OPRD2
ENDIF
ENDM
......
DSEG SEGMENT
......
NUM_AX DW 1111H
NUM_BX DW 2222H
NUM_CX DW 0
NUM_DX DW 0
......
DSEG ENDS
......
ASSUME CS:CSEG,DS:DSEG
......
MOV AX,DSEG
MOV DS,AX
......
MULREME <WORD PTR NUM_AX>,<WORD PTR NUM_BX>,<WORD PTR NUM_CX>
MULREME <WORD PTR NUM_AX>,<WORD PTR NUM_BX>
......
题7.29请编写一个能够根据某个符号值采用不同方法显示字符的宏。
ECHOCH MACRO CHAR
PUSH AX
PUSH DX
IFNB <CHAR>
IFDIFI <CHAR>,<DL>
MOV DL,CHAR
ENDIF
ENDIF
MOV AH,2
INT 21H
POP DX
POP AX
ENDM
PUTCH MACRO CHAR
PUSH AX
PUSH BX
PUSH AX
MOV AH,0FH
INT 10H
POP AX
IFNB <CHAR>
IFDIFI <CHAR>,<AL>
MOV AL,CHAR
ENDIF
ENDIF
MOV AH,0EH
INT 10H
POP BX
POP AX
ENDM
SHOWCH MACRO MODE,CHAR
IFIDNI <MODE>,<DOS>
ECHOCH CHAR
ENDIF
IFIDNI <MODE>,<BIOS>
PUTCH CHAR
ENDIF
ENDM
......
MOV AL,'A'
SHOWCH DOS,AL
MOV BL,'B'
SHOWCH BIOS,BL
......
测试通过的完整程序如下
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ALTF1 = 6800H
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
PUSHALL MACRO
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
ENDM
POPALL MACRO
POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
ENDM
NEWLINE MACRO
PUSH AX
PUSH BX
MOV AH,0FH
INT 10H
MOV AL,0DH
MOV AH,0EH
INT 10H
MOV AL,0AH
MOV AH,0EH
INT 10H
POP BX
POP AX
ENDM
DEFSSEG MACRO SEGNAME,NUM
SEGNAME SEGMENT PARA STACK
DW NUM DUP (?)
SEGNAME ENDS
ENDM
DEFSVAR MACRO SVAL
MOV AX,BP
IRP X,SVAL
SUB SP,2
SUB BP,2
MOV WORD PTR [BP] ,X
ENDM
MOV BP,AX
ENDM
POPSVAR MACRO SREG
IRP X,SREG
POP X
ENDM
ENDM
ATOBIN MACRO
LOCAL ATOBIN_OK
SUB AL,30H
CMP AL,9
JBE ATOBIN_OK
SUB AL,7
CMP AL,15
JBE ATOBIN_OK
SUB AL,20H
ATOBIN_OK:
ENDM
CLEARBUFKB MACRO
LOCAL CLEARBUFKB_S,CLEARBUFKB_OK
PUSH AX
CLEARBUFKB_S:MOV AH,1
INT 16H
JZ CLEARBUFKB_OK
MOV AH,0
INT 16H
JMP CLEARBUFKB_S
CLEARBUFKB_OK:POP AX
ENDM
HTOASC MACRO
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
ENDM
WHTOASC MACRO
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
HTOASC
XCHG AH,AL
HTOASC
ENDM
ECHOCH MACRO CHAR
PUSH AX
PUSH DX
IFNB <CHAR>
IFDIFI <CHAR>,<DL>
MOV DL,CHAR
ENDIF
ENDIF
MOV AH,2
INT 21H
POP DX
POP AX
ENDM
DWHTOASC MACRO
PUSH AX
PUSH DX
WHTOASC
ECHOCH AH
ECHOCH AL
POP DX
POP AX
ENDM
DEFSHIFT MACRO SHIFTNAME,OPERATOR
SHIFTNAME MACRO OPRD,NUM
PUSH CX
IFNB <NUM>
IFDIFI <NUM>,<CL>
MOV CL,NUM
ENDIF
ENDIF
OPERATOR OPRD,CL
POP CX
ENDM
ENDM
DEFBUF MACRO BUFNAME,NUM
HIGHVAL = 2
BUFNAME LABEL DWORD
REPT NUM
DW 0
DW HIGHVAL
HIGHVAL = HIGHVAL + 2
ENDM
ENDM
PUSHSEG MACRO SEGNAME
IRP X,SEGNAME
PUSH X
ENDM
ENDM
POPSEG MACRO SEGNAME
IRP X,SEGNAME
POP X
ENDM
ENDM
DEFLABTAB MACRO TABNAME,LABNAME
TABNAME LABEL DWORD
IRP X,LABNAME
DW OFFSET X
DW SEG X
ENDM
ENDM
DEFLABNUMTAB MACRO TABNAME,NUM,LABX,LABY,LABZ
COUNTVAL = 0
TABNAME LABEL DWORD
REPT NUM
IF COUNTVAL EQ 0
DW OFFSET LABX
DW SEG LABX
ENDIF
IF COUNTVAL EQ 1
DW OFFSET LABY
DW SEG LABY
ENDIF
IF COUNTVAL EQ 2
DW OFFSET LABZ
DW SEG LABZ
ENDIF
COUNTVAL = COUNTVAL + 1
ENDM
ENDM
PUPOSVAR MACRO OPRM,SOPRD
IFIDNI <OPRM>,<PUSH>
MOV AX,BP
IRP X,SOPRD
SUB SP,2
SUB BP,2
MOV WORD PTR [BP] ,X
ENDM
MOV BP,AX
ENDIF
IFIDNI <OPRM>,<POP>
IRP X,SOPRD
POP X
ENDM
ENDIF
ENDM
ADDREMEMO MACRO MODE1,OPRD1,OPRD2
IFIDNI <MODE1>,<REG>
ADD OPRD1,OPRD2
ENDIF
IFIDNI <MODE1>,<MEM>
PUSH AX
MOV AX,OPRD1
ADD AX,OPRD2
MOV OPRD1,AX
POP AX
ENDIF
ENDM
MULREME MACRO OPRD1,OPRD2,OPRD3
IFNB <OPRD3>
PUSH AX
PUSH DX
IFDIFI <OPRD1>,<AX>
MOV AX,OPRD1
ENDIF
MUL OPRD2
MOV OPRD3,AX
MOV OPRD3+2,DX
POP DX
POP AX
ENDIF
IFB <OPRD3>
IFDIFI <OPRD1>,<AX>
MOV AX,OPRD1
ENDIF
MUL OPRD2
ENDIF
ENDM
ECHOCH MACRO CHAR
PUSH AX
PUSH DX
IFNB <CHAR>
IFDIFI <CHAR>,<DL>
MOV DL,CHAR
ENDIF
ENDIF
MOV AH,2
INT 21H
POP DX
POP AX
ENDM
PUTCH MACRO CHAR
PUSH AX
PUSH BX
PUSH AX
MOV AH,0FH
INT 10H
POP AX
IFNB <CHAR>
IFDIFI <CHAR>,<AL>
MOV AL,CHAR
ENDIF
ENDIF
MOV AH,0EH
INT 10H
POP BX
POP AX
ENDM
SHOWCH MACRO MODE,CHAR
IFIDNI <MODE>,<DOS>
ECHOCH CHAR
ENDIF
IFIDNI <MODE>,<BIOS>
PUTCH CHAR
ENDIF
ENDM
DEFSSEG SSEG,256
DEFSHIFT SHLN,SHL
DSEG SEGMENT
DEFBUF PRINT_BUF,128
DEFLABNUMTAB PRINT_TAB,3,PRINTSVAR_1,PRINTSVAR_2,PRINTSVAR_OK
NUM_AX DW 1111H
NUM_BX DW 2222H
NUM_CX DW 0
NUM_DX DW 0
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:CALL PRINTSVAR
MOV AH,4CH
INT 21H
PRINTSVAR PROC
PUSHALL
PUSH BP
MOV BP,SP
PRINTSVAR_1:DEFSVAR <!<1111H,2222H,3333H!>>
POPSVAR <!<AX,AX,AX!>>
PRINTSVAR_2:PUSHSEG <!<AX,BX,CX!>>
POPSEG <!<CX,BX,AX!>>
PUPOSVAR PUSH,<!<1111H,2222H,3333H!>>
PUPOSVAR POP,<!<AX,AX,AX!>>
MOV AX,DSEG
MOV DS,AX
MOV BX,OFFSET PRINT_BUF
MOV BX,OFFSET PRINT_TAB
ADDREMEMO MEM,<WORD PTR NUM_AX>,<WORD PTR NUM_BX>
MULREME <WORD PTR NUM_AX>,<WORD PTR NUM_BX>,<WORD PTR NUM_CX>
MOV AL,'A'
SHOWCH DOS,AL
MOV BL,'B'
SHOWCH BIOS,BL
MOV AL,'3'
MOV AH,0
ATOBIN
SHLN AX,3
DWHTOASC
CLEARBUFKB
NEWLINE
MOV SP,BP
POP BP
PRINTSVAR_OK:POPALL
RET
PRINTSVAR ENDP 
CSEG ENDS
END START
题7.30请编写一个定义若干符号常量的源程序级文本文件。该文件内使用条件伪指令和特定标识符号，以便于被INCLUDE伪命令包含。
把前面习题编写的宏全部放到文件t391.asm中，把常量定义、数据段定义放在文件t392.asm中。
在文件t390.asm的开头使用条件汇编，只在第一遍扫描时添加INCLUDE t391.asm。
t390.asm
IF1
INCLUDE t391.asm
ENDIF
INCLUDE t392.asm
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:CALL PRINTSVAR
MOV AH,4CH
INT 21H
PRINTSVAR PROC
PUSHALL
PUSH BP
MOV BP,SP
PRINTSVAR_1:DEFSVAR <!<1111H,2222H,3333H!>>
POPSVAR <!<AX,AX,AX!>>
PRINTSVAR_2:PUSHSEG <!<AX,BX,CX!>>
POPSEG <!<CX,BX,AX!>>
PUPOSVAR PUSH,<!<1111H,2222H,3333H!>>
PUPOSVAR POP,<!<AX,AX,AX!>>
MOV AX,DSEG
MOV DS,AX
MOV BX,OFFSET PRINT_BUF
MOV BX,OFFSET PRINT_TAB
ADDREMEMO MEM,<WORD PTR NUM_AX>,<WORD PTR NUM_BX>
MULREME <WORD PTR NUM_AX>,<WORD PTR NUM_BX>,<WORD PTR NUM_CX>
MOV AL,'A'
SHOWCH DOS,AL
MOV BL,'B'
SHOWCH BIOS,BL
MOV AL,'3'
MOV AH,0
ATOBIN
SHLN AX,3
DWHTOASC
CLEARBUFKB
NEWLINE
MOV SP,BP
POP BP
PRINTSVAR_OK:POPALL
RET
PRINTSVAR ENDP 
CSEG ENDS
END START
t391.asm
PUSHALL MACRO
PUSHF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
ENDM
POPALL MACRO
POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
POPF
ENDM
NEWLINE MACRO
PUSH AX
PUSH BX
MOV AH,0FH
INT 10H
MOV AL,0DH
MOV AH,0EH
INT 10H
MOV AL,0AH
MOV AH,0EH
INT 10H
POP BX
POP AX
ENDM
DEFSSEG MACRO SEGNAME,NUM
SEGNAME SEGMENT PARA STACK
DW NUM DUP (?)
SEGNAME ENDS
ENDM
DEFSVAR MACRO SVAL
MOV AX,BP
IRP X,SVAL
SUB SP,2
SUB BP,2
MOV WORD PTR [BP] ,X
ENDM
MOV BP,AX
ENDM
POPSVAR MACRO SREG
IRP X,SREG
POP X
ENDM
ENDM
ATOBIN MACRO
LOCAL ATOBIN_OK
SUB AL,30H
CMP AL,9
JBE ATOBIN_OK
SUB AL,7
CMP AL,15
JBE ATOBIN_OK
SUB AL,20H
ATOBIN_OK:
ENDM
CLEARBUFKB MACRO
LOCAL CLEARBUFKB_S,CLEARBUFKB_OK
PUSH AX
CLEARBUFKB_S:MOV AH,1
INT 16H
JZ CLEARBUFKB_OK
MOV AH,0
INT 16H
JMP CLEARBUFKB_S
CLEARBUFKB_OK:POP AX
ENDM
HTOASC MACRO
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
ENDM
WHTOASC MACRO
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
HTOASC
XCHG AH,AL
HTOASC
ENDM
ECHOCH MACRO CHAR
PUSH AX
PUSH DX
IFNB <CHAR>
IFDIFI <CHAR>,<DL>
MOV DL,CHAR
ENDIF
ENDIF
MOV AH,2
INT 21H
POP DX
POP AX
ENDM
DWHTOASC MACRO
PUSH AX
PUSH DX
WHTOASC
ECHOCH AH
ECHOCH AL
POP DX
POP AX
ENDM
DEFSHIFT MACRO SHIFTNAME,OPERATOR
SHIFTNAME MACRO OPRD,NUM
PUSH CX
IFNB <NUM>
IFDIFI <NUM>,<CL>
MOV CL,NUM
ENDIF
ENDIF
OPERATOR OPRD,CL
POP CX
ENDM
ENDM
DEFBUF MACRO BUFNAME,NUM
HIGHVAL = 2
BUFNAME LABEL DWORD
REPT NUM
DW 0
DW HIGHVAL
HIGHVAL = HIGHVAL + 2
ENDM
ENDM
PUSHSEG MACRO SEGNAME
IRP X,SEGNAME
PUSH X
ENDM
ENDM
POPSEG MACRO SEGNAME
IRP X,SEGNAME
POP X
ENDM
ENDM
DEFLABTAB MACRO TABNAME,LABNAME
TABNAME LABEL DWORD
IRP X,LABNAME
DW OFFSET X
DW SEG X
ENDM
ENDM
DEFLABNUMTAB MACRO TABNAME,NUM,LABX,LABY,LABZ
COUNTVAL = 0
TABNAME LABEL DWORD
REPT NUM
IF COUNTVAL EQ 0
DW OFFSET LABX
DW SEG LABX
ENDIF
IF COUNTVAL EQ 1
DW OFFSET LABY
DW SEG LABY
ENDIF
IF COUNTVAL EQ 2
DW OFFSET LABZ
DW SEG LABZ
ENDIF
COUNTVAL = COUNTVAL + 1
ENDM
ENDM
PUPOSVAR MACRO OPRM,SOPRD
IFIDNI <OPRM>,<PUSH>
MOV AX,BP
IRP X,SOPRD
SUB SP,2
SUB BP,2
MOV WORD PTR [BP] ,X
ENDM
MOV BP,AX
ENDIF
IFIDNI <OPRM>,<POP>
IRP X,SOPRD
POP X
ENDM
ENDIF
ENDM
ADDREMEMO MACRO MODE1,OPRD1,OPRD2
IFIDNI <MODE1>,<REG>
ADD OPRD1,OPRD2
ENDIF
IFIDNI <MODE1>,<MEM>
PUSH AX
MOV AX,OPRD1
ADD AX,OPRD2
MOV OPRD1,AX
POP AX
ENDIF
ENDM
MULREME MACRO OPRD1,OPRD2,OPRD3
IFNB <OPRD3>
PUSH AX
PUSH DX
IFDIFI <OPRD1>,<AX>
MOV AX,OPRD1
ENDIF
MUL OPRD2
MOV OPRD3,AX
MOV OPRD3+2,DX
POP DX
POP AX
ENDIF
IFB <OPRD3>
IFDIFI <OPRD1>,<AX>
MOV AX,OPRD1
ENDIF
MUL OPRD2
ENDIF
ENDM
PUTCH MACRO CHAR
PUSH AX
PUSH BX
PUSH AX
MOV AH,0FH
INT 10H
POP AX
IFNB <CHAR>
IFDIFI <CHAR>,<AL>
MOV AL,CHAR
ENDIF
ENDIF
MOV AH,0EH
INT 10H
POP BX
POP AX
ENDM
SHOWCH MACRO MODE,CHAR
IFIDNI <MODE>,<DOS>
ECHOCH CHAR
ENDIF
IFIDNI <MODE>,<BIOS>
PUTCH CHAR
ENDIF
ENDM
t392.asm
COLOR = 07H
DPAGE = 0
ROW = 5
COLUMN = 10
ALTF1 = 6800H
ESCKEY = 1BH
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
DEFSSEG SSEG,256
DEFSHIFT SHLN,SHL
DSEG SEGMENT
DEFBUF PRINT_BUF,128
DEFLABNUMTAB PRINT_TAB,3,PRINTSVAR_1,PRINTSVAR_2,PRINTSVAR_OK
NUM_AX DW 1111H
NUM_BX DW 2222H
NUM_CX DW 0
NUM_DX DW 0
DSEG ENDS
题7.31什么是宏库？有何用途？如何方便地利用它。
汇编程序允许把源程序存放在多个文本文件中，在汇编时结合到一起，同时参加汇编。
利用伪指令INCLUDE可以完成多个文本文件的结合。它的一般格式如下：
INCLUDE 文件名
伪指令INCLUDE指示汇编程序将指定的文本文件从本行起加入汇编，直到该文本文件的最后一行汇编完后，继续汇编随后的语句。
通常把一组有价值和经常使用的宏定义集中存放在一个文本文件中，这样的文本文件称为宏库。
使用宏库，方便源程序的修改和维护，减少源程序的错误。
在源程序的开始位置添加结合宏库的伪指令INCLUDE，就能方便地调用宏库中的宏。
汇编程序MASM对源程序文件执行两遍扫描，并且只在第一遍扫描时登记宏定义，
所以可使用IF1条件汇编伪指令，通知汇编程序在第一遍扫描时加入宏库，而在第二遍扫描时，不加入宏库。
这样既加快了第二遍扫描的速度，又能避免在汇编列表清单中含有宏定义部分。
如果结合的不是宏库，则不能只在第一遍扫描时结合，而在第二遍扫描时不结合。
宏库中可含有多个宏定义，一个程序不一定调用宏库中定义的全部宏。
对于不使用的宏，可以用伪指令PURGE清除，清除操作对宏库没有影响。
第8章模块化程序设计技术
把一个程序分成具有多个明确任务的程序模块，分别编写、调试后再把它们连接在一起，形成一个完整的程序，
这样的程序设计方法称为模块化程序设计。
模块化程序设计有如下优点：
（1）单个的程序模块易于编写、调试及修改；
（2）若干程序员可以并行工作，工作进度可加快；
（3）若干反复使用和验证过的程序模块可被利用；
（4）程序的易读性好；
（5）程序的修改可局部化。
模块化程序设计的主要步骤是：
（1）正确地描述整个程序需要完成什么样的工作；
（2）把完整的任务划分成多个具有明确功能的程序模块，并明确各模块之间的相互关系；
（3）根据各模块的具体功能和地位，选择合适的程序设计语言，编写程序并初步调试；
（4）把各模块分别编译或汇编成目标模块，并连接到一起，经过调试形成一个完整的程序；
（5）整理文档资料。
虽然模块化程序设计的关键是模块的划分，但本章只介绍如何利用汇编语言编写符合要求的程序模块。
8.1段的完整定义
一个复杂的程序通常有若干模块组成。源模块可用汇编语言编写，也可用高级语言编写。
每个源模块被单独汇编或编译成目标（OBJ）模块，最后由连接程序（LINKER）把各目标模块连接成一个完整的可执行的程序。
由于8086/8088采用分段的形式访问内存，所以一个模块往往又含有多个段。
一个程序的若干模块之间存在的联系必定体现在模块间的段与段的联系上。
连接程序如何把若干模块的多个段恰当地组合到一起呢？如何沟通有关段之间的联系呢？
实际上，汇编语言中的段定义伪指令等指示汇编程序把合适的连接信息写入到目标模块中，连接程序再根据目标模块中的连接信息进行连接操作。
在新版的汇编语言中，有两种方法定义段：完整的段定义和简化的段定义。本节介绍段的完整定义。
8.1.1完整的段定义
完整的段定义提供了彻底控制段的机制，该机制可使得各模块的各个段严格按要求组合和衔接。
1.一般格式
完整段定义的一般格式如下：
段名 SEGMENT [定位类型][组合类型]['类别']
......
语句
......
段名 ENDS
段开始语句SEGMENT中的可选项"定位类型"、"组合类型"和"'类别'"通知汇编程序和连接程序如何建立和组合段。
应当按顺序说明这些可选项，但不需要给出所有可选项，如果不给出某个可选项，那么汇编程序使用该可选项的缺省值。
在前面各章节所列程序中的段虽然均采用完整的定义，却都没有给出这些可选项。
段名可以是唯一的，也可以与程序中其他的段名相同。
在同一模块中，如果已用相同的段名定义过段，那么当前这个段就被视为前一个同名段的继续，即同一个段。
对一个模块中的同名段而言，后续同名段的定义伪指令SEGMENT中的可选项取值应该与前一个同名段相同，
或者不再给定可选项值而默认与前一个同名段相同。
例1：如下程序T8-1.ASM中含有两个名为DSEG的段和两个名为CSEG的段
；程序名：T8-1.ASM
：功能：（略）
DSEG SEGMENT
MESS DB 'HEL'
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESS
MOV AH,9
INT 21H
CSEG ENDS
DSEG SEGMENT
DB 'LO',0DH,0AH,'$'
DSEG ENDS
CSEG SEGMENT
MOV AX,4C00H
INT 21H
CSEG ENDS
END START
由于后一同名段被视为前一同名段的继续，所以汇编后只有DSEG和CSEG两个段，类似于程序T3-1.ASM的汇编结果。
下面介绍段定义伪指令中可选项的作用和所取值的意义。
2.定位类型
定位类型表示出当前段对起始地址的要求，从而指示连接程序如何衔接相邻两段。可选择的定位类型及所表示的起始地址列于表8.1。
表8.1定位类型
定位类型|起始地址（二进制表示）|含义
BYTE      XXXXXXXXXXXXXXXXXXXX  使用下一个可用字节地址
WORD   XXXXXXXXXXXXXXXXXXX0  使用下一个可用字地址
DWORD XXXXXXXXXXXXXXXXXX00  使用下一个可用双字地址
PARA     XXXXXXXXXXXXXXXX0000   使用下一个可用节地址
PAGE     XXXXXXXXXXXX00000000    使用下一个可用页地址
一般情况下（80386以下）缺省的定位类型是PARA，即段起始地址位于可用的第一个节（每节为16个字节）的边界处。
定位类型BYTE使得当前段紧接前一段，前后两段间没有空闲单元，所以是最节约的定位类型。
定位类型WORD使得段从偶地址开始，不仅较为节约，而且有利于把数据单元定位在偶地址。
定位类型DWORD常用于80386的32位段。一页等于256字节，所以定位类型PAGE可能导致最大的段间隔。
例2：如下程序T8-2.ASM的两个段的定位类型均是PARA：
；程序名：T8-2.ASM
；功能：（略）
DSEG SEGMENT PARA COMMON
MESS DB 'HELLO',0DH,0AH,'$'
DSEG ENDS
CSEG SEGMENT PARA PUBLIC
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESS
MOV AH,9
INT 21H
MOV AX,4C00H
INT 21H
CSEG ENDS
END START
最后的可执行程序中两个段的衔接情况图8.1（a）所示。如果把段CSEG的定位类型改为WORD，衔接情况如图8.1（b）所示。
如果把段CSEG的定位类型改为BYTE，衔接情况如图8.1（c）所示。
3.组合类型
不同模块的同名段的组合，为更有效更便利地使用存储器提供了方便。组合类型就是用于通知连接程序，
如何把不同模块内段名相同的段组合到一起。
有如下组合类型：
（1）PUBLIC
组合类型PUBLIC表示当前段与其它模块中组合类型为PUBLIC的同名段组合成一个段。
组合的先后顺序取决于启动LINK程序时目标模块名排列的次序。由于组合后受同一个段地址控制，所以组合时后续段的起始地址都作相应调整。
但组合时仍遵照定位类型进行衔接，即同名段间可能有间隔。
（2）COMMON
组合类型COMMON表示当前段与其它模块中的同名段重叠，即起始地址相同。最终段的长度等于它们中最长的段的长度。
由于段覆盖，所以前一同名段中的初始化数据可能被后续同名段中的初始化数据所覆盖。
（3）STACK
组合类型STACK表示当前段是堆栈段，组合情况与PUBLIC相同。
（4）MEMORY
组合类型MEMORY与组合类型PUBLIC相同，为兼容而设。
（5）AT 表达式
它表示当前段应按绝对地址定位，其段地址即为表达式之值。一般AT段不包含代码和初始化数据，
它仅用于表示已在内存中的代码或数据的地址样板，如显示缓冲区或其它由硬件定义的绝对存储单元。LINK程序不对AT段生成任何代码或数据。
（6）PRIVATE
组合类型PRIVATE表示不与其它段组合。宏汇编程序MASM不识别此关键字。
若段定义伪指令SEGMENT语句中没有给出组合类型，就表示不与其它段组合。
；程序名：T8-2.ASM
；功能：（略）
DSEG SEGMENT PARA COMMON
MESS DB 'HELLO',0DH,0AH,'$'
DSEG ENDS
CSEG SEGMENT PARA PUBLIC
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESS
MOV AH,9
INT 21H
MOV AX,4C00H
INT 21H
CSEG ENDS
END START
例3：某个程序的第一个源程序模块是例2所给出的T8-2.ASM，第二个源程序模块如下所示：
；程序（模块）名：T8-3.ASM
；功能：（略）
DSEG SEGMENT PARA COMMON
DB 'OK'
DSEG ENDS
CSEG SEGMENT PARA PUBLIC
MOV AH,4CH
INT 21H
CSEG ENDS
END
先把这两个源程序模块分别汇编，最后用LINK程序连接，命令行如下：
LINK T8-2 + T8-3
模块2中的DSEG段和模块1中的DSEG段重叠，模块2中的CSEG段和模块1中的CSEG段合并成一个段。
最后得到的可执行程序的内容如下所示：
0000：0000 4F4B4C4C4F0D0A24 两个段重叠后的结果OKLLO..$
0000：0008 0000000000000000   CSEG的定位类型是PARA导致的间隔
0001：0000 MOV AX,26E2            模块T8-2中的CSEG段
0001：0003 MOV DS,AX
0001：0005 MOV DX,0000
0001：0008 MOV AH,09
0001：000A INT 21
0001：000C MOV AX,4C00
0001：000F INT 21
0001：0011 000000000000000000000000000000 衔接间隔
0001：0020 MOV AH,4C               模块T8-3中的CSEG段
0001：0022 INT 21
4.类别
类别用于表示段的分类。LINK程序总是使类别相同的段相邻。实际上只有类别相同的同名段才根据组合类型进行组合。
类别是一个由程序员指定的字符串，必须用单引号括起。如果一个段没有给出类别，那么这个段的类别就为空。
例3中两个模块的四个段均没有给出类别，它们的类别均为空。
例4：设某个程序的模块1如下所示：
DSEG SEGMENT PARA PUBLIC 'DATA'
MESS DB 'HELLO',0DH,0AH,'$'
DSEG ENDS
CSEG SEGMENT PARA PUBLIC 'CODE'
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESS
MOV AH,9
INT 21H
MOV AX,4C00H
INT 21H
CSEG ENDS
END START
再设该程序的模块2如下所示：
DSEG SEGMENT PARA PUBLIC 'XYZ'
DB 'OK'
DSEG ENDS
ASEG SEGMENT PARA PUBLIC 'CODE'
MOV AH,4CH
INT 21H
ASEG ENDS
END
再设该程序的模块3如下所示：
ESEG SEGMENT PARA PUBLIC 'DATA'
DB 'WORLD'
ESEG ENDS
END
用如下命令连接它们的目标模块：
LINK MODULE1 + MODULE2 + MODULE3
在得到的可执行程序中，各段的排列次序是：模块1的DSEG、模块3的ESEG、模块1的CSEG、模块2的ASEG、模块2的DSEG。
8.1.2关于堆栈段的说明
一个完整的汇编语言源程序一般应该含有一个堆栈段，只有COM型程序例外。
当把某个段的组合类型指定为STACK时，这个段就被指定为堆栈段了。
也就是说，组合类型STACK不仅是某种组合类型，而且能够表示当前段是堆栈段。
当然，如果在程序的其他模块中也有组合类型为STACK的同名段，那么连接时将以接续的方式组合到一起，这样会构成一个存储空间更大的堆栈。
例5：为程序T8-1.ASM增加一个大小为1024字节的堆栈段。
；程序名：T8-1A.ASM
；功能：（略）
SSEG SEGMENT PARA STACK
DW 512 DUP (?)
SSEG ENDS
DSEG SEGMENT PARA COMMON
MESS DB 'HELLO',0DH,0AH,'$'
DSEG ENDS
CSEG SEGMENT PARA PUBLIC
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESS
MOV AH,9
INT 21H
MOV AX,4C00H
INT 21H
CSEG ENDS
END START
LINK程序会把组合类型为STACK的段的有关信息写入可执行程序文件中。于是在执行该程序时，
操作系统的装入程序就能根据这些信息自动设置寄存器SS和SP，从而构成物理堆栈。
设置的SS值是组合类型为STACK的段的段值，设置的SP值是堆栈段的大小，即SS:SP指向堆栈尾。
如果在说明堆栈段时不指明组合类型STACK，虽然在主观上想让它用作堆栈段，但没有得到汇编程序和连接程序的承认，
所以必须在代码段中安排传送指令来设置寄存器SS和SP。
例如：设源程序中有如下准备用于堆栈的段：
SSEG SEGMENT PARA
DW 512 DUP (?)
STACKTOP LABEL WORD
SSEG ENDS
那么在代码段中可用如下指令设置堆栈：
CLI
MOV AX,SSEG
MOV SS,AX
MOV SP,OFFSET STACKTOP
STI
由于硬件中断和程序使用同一个堆栈，所以在切换堆栈时要关中断。
允许一个汇编语言源程序不含有堆栈段。如果LINK程序没有发现堆栈段，那么它会发出警告信息，
并把第一个段的段值作为堆栈的段值，堆栈空间设定为64KB。
我们在先前章节中给出的程序几乎都没有说明堆栈段，所以这些程序都使用这个缺省的堆栈段。
如果认为这个缺省的堆栈段是可行的话，那么在程序中可不必说明堆栈段，也不必理会LINK程序给出的警告信息。
无论在程序中是否说明堆栈段，只要需要，都可通过重置寄存器SS和SP来切换堆栈，从而建立合适的新堆栈。
8.1.3段组的说明和使用
先看下面的程序T8-4.ASM。它含有两个数据段和一个代码段。为了说明问题，把数据段和代码段都作了简化。
；程序名：T8-4.ASM
；功能：（略）
DSEG1 SEGMENT PARA PUBLIC
VAR1 DB ?
DSEG1 ENDS
DSEG2 SEGMENT PARA PUBLIC
VAR2 DB ?
DSEG2 ENDS
CSEG SEGMENT PARA PUBLIC
ASSUME CS:CSEG,DS:DSEG1
START:MOV AX,DSEG1
MOV DS,AX
MOV BL,VAR1
ASSUME DS:DSEG2
MOV AX,DSEG2
MOV DS,AX
MOV VAR2,BL
MOV AH,4CH
INT 21H
CSEG ENDS
END START
在上述程序T8-4中，为了访问变量VAR1，设置了数据段寄存器DS，为了访问变量VAR2而重置了DS。
如果要频繁地交叉访问段DSEG1和段DSEG2中的数据，那么不仅很麻烦，而且程序也会变得冗长。
改进的方法是使附加段寄存器ES对应段DSEG2，并把DSEG2段的段值置入ES，通过段超越前缀“ES:”来实现对段DSEG2中数据的访问。
但改进的方法仍会使目标代码有冗余。
好的方法是把DSEG1和DSEG2段作为一个段来处理。段组就是为实现此目的服务的。
若程序员要在源代码的各独立段中安排几种数据类型，且要在执行时能通过一个独立的、公用的段寄存器访问它们，就可使用段组。
伪指令GROUP用于把源程序模块中若干不同名的段集合成一个组，并赋予一个组名。它的一般格式如下：
组名 GROUP 段名[,段名......]
其中，段名与段名间用逗号间隔，段名也可用由表达式"SEG 变量"或者表达式"SEG 标号"代替。
例6：利用段组，改写程序T8-4.ASM。改写的程序如下：
；程序名：T8-4G.ASM
：功能：（略）
DS1S2 GROUP DSEG1,DSEG2
DSEG1 SEGMENT PARA PUBLIC
VAR1 DB ?
DSEG1 ENDS
DSEG2 SEGMENT PARA PUBLIC
VAR2 DB ?
DSEG2 ENDS
CSEG SEGMENT PARA PUBLIC
ASSUME CS:CSEG,DS:DS1S2
START:MOV AX,DS1S2
MOV DS,AX
MOV BL,VAR1
MOV VAR2,BL
MOV AH,4CH
INT 21H
CSEG ENDS
END START
组名表示组，也代表组的起始地址。组名的使用与段名的使用类似。
上述程序中的指令"MOV AX,DS1S2"是把组DS1S2的起始地址的段值送AX寄存器。
段组名也可用在ASSUME语句中，表示使某个段寄存器与某个组相对应。
在定义段组后，段组内各段所定义的所有标号和变量除与定义它们的段起始点相关外还与组的起始点相关。
如果在ASSUME伪指令中使段寄存器与段组对应，那么有关标号或变量的地址就相对于段组起点计算。
如果在ASSUME伪指令中使段寄存器与组内某个段对应，那么有关标号或变量就相对于该段的起点计算。
所以在使用段组后，程序员要谨慎地使用ASSUME伪指令，并保证具体置入段寄存器的值与之相适应。
数据段放在代码段前面
DS1S2 GROUP DSEG1,DSEG2
DSEG1 SEGMENT PARA PUBLIC
VAR1 DB 11H
DSEG1 ENDS
DSEG2 SEGMENT PARA PUBLIC
VAR2 DB 22H
DSEG2 ENDS
CSEG SEGMENT PARA PUBLIC
ASSUME CS:CSEG,DS:DS1S2
START:MOV AX,DS1S2
MOV DS,AX
MOV BL,VAR1
MOV VAR2,BL
ASSUME DS:DSEG2
MOV AX,DSEG2
MOV DS,AX
MOV VAR2,BL
MOV AH,4CH
INT 21H
CSEG ENDS
END START
数据段放在代码段后面
DS1S2 GROUP DSEG1,DSEG2
CSEG SEGMENT PARA PUBLIC
ASSUME CS:CSEG,DS:DS1S2
START:MOV AX,DS1S2
MOV DS,AX
MOV BL,VAR1
MOV VAR2,BL
ASSUME DS:DSEG2
MOV AX,DSEG2
MOV DS,AX
MOV VAR2,BL
MOV AH,4CH
INT 21H
CSEG ENDS
DSEG1 SEGMENT PARA PUBLIC
VAR1 DB 11H
DSEG1 ENDS
DSEG2 SEGMENT PARA PUBLIC
VAR2 DB 22H
DSEG2 ENDS
END START
例7：如下程序T8-5.ASM说明了如何把变量作为组的成员访问和把变量仅作为段内的成员访问。
；程序名：T8-5.ASM
；功能：（略）
DGROUP GROUP CSEG,DSEG
CSEG SEGMENT
ASSUME DS:DGROUP
START:MOV AX,DGROUP
MOV DS,AX
MOV BL,VAR1
MOV VAR2,BL
ASSUME DS:DSEG
MOV AX,DSEG
MOV DS,AX
MOV BH,VAR1
MOV VAR2,BH
MOV AH,4CH
INT 21H
CSEG ENDS
DSEG SEGMENT
VAR1 DB 'A'
VAR2 DB 'B'
DSEG ENDS
END START
连接后所得的可执行程序T8-5装入内存时的映象如下（设开始段值为26E2H）：
26E2 : 0000 MOV AX,26E2 CSEG段
26E2 : 0003 MOV DS,AX
26E2 : 0005 MOV BL,[0020]
26E2 : 0009 MOV [0021],BL
26E2 : 000D MOV AX,26E4
26E2 : 0010  MOV DS,AX
26E2 : 0012  MOV BH,[0000]
26E2 : 0016  MOV [0001],BH
26E2 : 001A MOV AH,4C
26E2 : 001C INT 21
26E2 : 001D 000000 段之间隔
26E2：0020 4142 DSEG段（即26E4：0）
如果要用运算符OFFSET得到在段组内某个段中定义的标号或变量相对于段组起始点的偏移，那么必须在标号或变量前再加上"组名:"。
例如，MOV DX,OFFSET DGROUP:VAR1，否则，只能得到相对于所在段起始点的偏移。
段组并不直接影响连接时段的次序，组内各段不必连续，不属于这组的某个段可以夹在组内的两个段之间。
由于要通过一个段寄存器访回组内各段，所以连接后组内所有段仍必须保证在64KB以内。
在纯汇编语言程序中，尽管程序员可以按自己的愿望使用段组，但使用段组并没有太多的必要。
8.2段的简化定义
完整的段定义使得程序员可以完全控制段，但较为复杂。新版汇编语言提供了段的简化定义方法，从而使程序员能方便地定义段。
无论是编写独立的汇编语言程序，还是编写供高级语言程序调用的函数，简化的段定义伪指令使程序设计更容易。本节介绍段的简化定义。
8.2.1存储模型说明伪指令
在程序中使用段简化定义伪指令之前，必须先使用存储模型说明伪指令描述程序采用的存储模型。存储模型说明伪指令的简单格式如下
.MODEL 存储模型
注意该伪指令以符号"."引导。例如，为了说明采用SMALL存储模型，只要在源程序首使用如下伪指令
.MODEL SMALL
存储模型决定子程序调用、指令转移和数据访问的缺省属性（NEAR或FAR）。
常用的存储模型有：
Small
single data segment and single code segment 
Medium
multiple code segments and single data segment
Compact
single code segment and multiple data segments 
Large
multiple code segments and multiple data segments 
Huge
multiple code segments and multiple data segments
individual data items may be larger than a single segment,
but the implementation of huge data items must be coded by the programmer. 
huge model is essentially the same as large model.
（1）SMALL
全部数据限制在一个64KB段内（数据段、堆栈段、附加段），全部代码也限制在另一个64KB段内。这是独立的汇编语言程序最常用的模型。
在这种存储模型下，数据段寄存器可保持不变，所有转移均可认为是段内转移。
（2）MEDIUM
全部数据限制在一个64KB段内，全部代码可大于64KB。代码大于64KB时，有多个代码段。
在这种存储模型下，数据段寄存器可保持不变，但代码段会出现段间转移的情形。
（3）COMPACT
全部代码限制在一个64KB段内，全部数据可大于64KB。数据大于64KB时，有多个数据段。单个数据项不能大于64KB。
（4）LARGE
全部代码可大于64KB，全部数据可大于64KB。
代码大于64KB时，有多个代码段。数据大于64KB时，有多个数据段。单个数据项不能大于64KB。
（5）HUGE
全部代码可大于64KB，全部数据可大于64KB。
代码大于64KB时，有多个代码段。数据大于64KB时，有多个数据段。单个数据项可以大于64KB。
独立的汇编语言程序可选用任一种存储模型，对大多数完全用汇编语言编写的程序来说，小（SMALL）模型就足够了。
8.2.2简化的段定义伪指令
1.简化的段定义伪指令
简化的段定义伪指令均以符号"."引导。下面介绍常用的简化段定义伪指令：
（1）定义代码段的伪指令
定义代码段的伪指令如下，它表示一个代码段的开始：
.CODE [段名]
段名为可选项，如不给出段名，则采用默认段名。
如果有多个代码段，则应为每个代码段指定段名。
例1：写一个使系统喇叭发出“嘟”一声的程序。
；程序名：T8-6.ASM
；功能：（略）
.MODEL SMALL
.CODE
START:MOV DL,7
MOV AH,2
INT 21H
MOV AX,4C00H
INT 21H
END START
上述程序就一个代码段，没有数据段和堆栈段。伪指令.CODE说明代码段的开始，伪指令END说明整个程序所有段的结束。
简化的段定义伪指令说明一个段的开始，同时也表示上一个段的结束。
（2）定义堆栈段的伪指令
定义堆栈段的伪指令一般格式如下，它表示一个堆栈段的开始：
.STACK [大小]
可选的"大小"说明堆栈的字节数，若没有指定堆栈大小，则采用缺省值1024。
如下的伪指令就表示定义一个2KB的堆栈。
.STACK 2048
通常只有在编写纯粹的汇编语言程序时才需要定义堆栈。
（3）定义数据段的伪指令
定义数据段的伪指令如下，它表示数据段的开始：
.DATA
例如：如下伪指令定义了一个数据段：
.DATA
VAR3 DB 5
IARRAY DW 50 DUP (0)
MESS DB 'HELLO',0DH,0AH,'$'
例2：利用简化的段定义伪指令改写8.1.2节的程序T8-1A.ASM。
；程序名：T8-1B.ASM
；功能：（略）
.MODEL SMALL
.STACK 1024
.DATA
MESS DB 'HELLO',0DH,0AH,'$'
.CODE
START:MOV AX,DGROUP
MOV DS,AX
MOV DX,OFFSET MESS
MOV AH,9
INT 21H
MOV AX,4C00H
INT 21H
END START
在一个源程序模块中可定义多个由伪指令.DATA开始的数据段，这如同在一个源程序模块中定义多个同名的数据段。
此外，还有伪指令.DATA?和伪指令.CONST，它们分别用于说明未初始化数据段的开始和常数数据段的开始。
在编写纯粹的汇编语言程序时，一般不使用这两条伪指令，因为在由伪指令.DATA说明的数据段中也可以定义未初始化的数据和常数数据。
除非为了遵守高级语言的约定，可能使用这两条伪指令。
宏汇编程序自动把可能存在的由.DATA说明的数据段、由.CONST说明的常数数据段、
由.DATA?说明的未初始化数据段和由.STACK说明的堆栈段集合成一个段组DGROUP。
那么如何定义一个不属于这个段组的独立数据段呢？如何定义一个较大的数据段呢？这可利用伪指令.FARDATA来实现。
（4）定义远程（独立）数据段的伪指令
定义独立数据段伪指令的一般格式如下，它表示一个独立数据段的开始：
.FARDATA [名字]
"名字"是可选的，如果使用，则就成为该数据段的段名。
例如：如下伪指令定义了一个独立的数据段：
.FARDATA
NEWPTR DD 0
BUFF DB 1024 DUP (?)
此外，还有伪指令.FARDATA?用于说明未初始化的独立数据段。
在编写纯粹汇编语言程序时，无需使用伪指令.FARDATA?，因为在由伪指令.FARDATA说明的独立数据段中也可定义未初始化数据。
2.缺省段名
在使用简化的段定义伪指令说明各段后，程序员一般不需要知道这些段的段名和它们的定位类型、组合类型等。
但如果想把简化的段定义伪指令与标准的段定义伪指令混合使用，那么就需要知道这些内容了。
表8.2列出了在小（SMALL）内存模型情况下，各段的段名等信息。
表8.2小型模式下的段名和类型
伪指令          段名             定位类型           组合类型       类别               组名
.CODE          _TEXT          WORD             PUBLIC          'CODE'
.FARDATA   FAR_DATA  PARA               PRIVATE        'FAR_DATA'
.FARDATA? FAR_BSS      PARA               PRIVATE        'FAR_BSS'
.DATA         _DATA         WORD             PUBLIC          'DATA'           DGROUP
.CONST       CONST        WQRD             PUBLIC          'CONST'        DGROUP
.DATA?       _BSS             WORD             PUBLIC          'BSS'              DGROUP
.STACK       STACK          PARA               STACK           'STACK'         DGROUP
如果在中型、大型或巨型模式下，由伪指令.CODE说明的代码段的段名在字符串"_TEXT"之前还会加上模块名（源文件名）。
例如，设模块名为ABC，则代码段名就成为ABC_TEXT。因此，如果使用中大型内存模式，那么模块源文件名不要以数字开头。
如果在使用伪指令.FARDATA说明一个独立的数据段时加了名字，那么此名字就成为该独立数据段的段名。
8.2.3存储模型说明伪指令的隐含动作
1.隐含的段组和段设定
存储模型说明伪指令.MODEL除了说明程序采用的存储模型外，还起着相当于如下语句的作用：
DGROUP GROUP _DATA,CONST,_BSS,STACK
ASSUME CS:_TEXT,DS:DGROUP,SS:DGROUP
它指示汇编程序把可能有的段_DATA、段CONST、段_BSS和段STACK集合成一个名为DGROUP的段组，
同时指示汇编程序把数据段寄存器DS和堆栈段寄存器SS与段组DGROUP对应，使代码段寄存器CS与代码段对应。
注意，在中型、大型模式下，代码段的段名不再是_TEXT。
由于伪指令.MODEL的上述隐含动作，所以在使用伪指令.MODEL后，可以直接引用段组DGROUP，
而且多数情况下也可以不使用伪指令ASSUME，上面的程序T8-1B.ASM就是一例。
但在少数情况下，程序仍需要安排ASSUME语句来指示段寄存器与段的对应关系。
例如：下列代码设置DS，使它依次对应.DATA段、.CODE段、.FARDATA段，最后又对应.DATA段：
......
.DATA
......
.FARDATA
......
.CODE
MOV AX,@DATA
MOV DS,AX
ASSUME DS:@DATA
......
MOV AX,@CODE
MOV DS,AX
ASSUME DS:@CODE
......
MOV AX,@FARDATA
MOV DS,AX
ASSUME DS:@FARDATA
......
MOV AX,@DATA
MOV DS,AX
ASSUME DS:@DATA
......
2.有关的预定义符
在上述程序片段中使用的符号@CODE等是汇编程序提供的若干预定义符。它们类似于用伪指令EQU所定义的符号。
与简化的段定义伪指令相关的一些预定义符号有：
（1）符号@CODE表示代码段的段名。
（2）符号@DATA表示由.DATA段和.STACK段等集合而成段组的组名。
（3）符号@FARDATA表示独立数据段的段名。
8.3模块间的通信
一个程序的若干模块在功能上是有联系的，不仅程序的运行次序可能要从一个模块转到另一个模块，
而且程序处理数据和变量也会涉及不同的模块。
如何实现这种联系呢？具体地说，模块甲如何调用模块乙内的过程？模块乙如何访问模块甲内的数据？本节介绍这方面的内容。
8.3.1伪指令PUBLIC和伪指令EXTRN
由于各模块被单独汇编，所以，如果模块甲要按符号名调用或访问在其他模块内定义的某个过程或变量，
那么，模块甲必须告诉汇编程序此指定符号名（标识符）在别的模块内定义，
否则，在汇编模块甲时，汇编程序会给出"符号未定义"这类汇编出错信息。
另一方面，如果在模块乙内定义的过程或变量准备供其他模块调用或访问，那么，模块乙也必须通知汇编程序，
否则，汇编程序不会把相应的标识符保存到目标程序中去，最终导致连接失败。
伪指令EXTRN和伪指令PUBLIC就是分别用于通知汇编程序上述两种信息。
1.伪指令PUBLIC
伪指令PUBLIC用于声明在当前模块内定义的某些标识符是公共标识符，即可供其他模块使用的标识符。它的一般格式如下所示：
PUBLIC 标识符[,标识符......]
上述语句中位于助记符PUBLIC之后的"标识符"就是要声明的公共标识符。一条PUBLIC语句可声明多个这样的标识符，标识符间用逗号分隔。
一个源程序模块内可使用多条PUBLIC语句。数据变量名和程序标号（包括过程名）均可声明为公用标识符。
例1：如下源程序模块中声明VAR1、VAR2和DELAY为可供其它模块使用的公共标识符：
.MODEL SMALL
PUBLIC VAR1,VAR2
PUBLIC DELAY
.DATA
VAR1 DW ?
VAR2 DB ?
VAR3 DB 5 DUP (0)
.CODE
DELAY PROC
LAB1:RET
DELAY ENDP
END
由于没有声明VAR3和LAB1为公共标识符，所以其它模块不能使用这两个标识符。
2.伪指令EXTRN
伪指令EXTRN用于声明当前模块使用的哪些标识符在其他模块内定义。它的一般格式如下所示：
EXTRN 标识符:类型[,标识符:类型......]
上述语句中位于助记符EXTRN后的每一项"标识符:类型"声明一个在其他模块内定义的标识符。
汇编程序为了产生合适的代码或保留恰当的存储单元，要求在声明标识符的同时指出其类型属性，"标识符"和"类型"之间用冒号分隔。
类型可以是NEAR、FAR或者BYTE、WORD、DWORD等标识符类型属性。
一条EXTRN语句可声明多个这样的标识符，每项之间用逗号分隔。一个源程序模块内可使用多条EXTRN语句。
例2：下面的语句声明VAR1、VAR2和DELAY为在其它模块定义的标识符
EXTRN DELAY:NEAR
EXTRN VAR1:WORD,VAR2:BYTE
注意：把EXTRN伪指令安排在段的里面与段的外面是有区别的。
如果EXTRN伪指令出现在某个段内，表示所声明的标识符虽在其它模块内，但却在同一个段内。
如果EXTRN伪指令田现在段外，那么表示不知道所声明的标识符在哪一个段内被定义。
3.声明一致性
各模块内的PUBLIC语句和EXTRN语句必须互相呼应，互相一致。
凡是由PUBLIC语句声明的标识符，应该是其它模块的EXTRN语句中用到的标识符；
反之，凡是由EXTRN语句声明的标识符必须在将要连接在一起的其它模块的PUBLIC语句中找到，而且所指明的类型必须一致。
如果不遵守这些原则，就不能正确连接成功。
8.3.2模块间的转移
模块间的转移是指从一个模块的某个代码段转移到另一个模块的某个代码段。
这种转移通常是以过程调用及返回的形式出现，例如：模块甲调用定义在模块乙内的某个过程，但有时这种转移也直接采用转移指令的形式。
若两个模块的涉及转移的代码段在连接后不能组合为一个代码段，那么发生在这两个代码段之间的转移必须是段间转移，
所以模块间的转移就成为远调用或远转移；否则模块间的转移可以是近调用或近转移，当然仍采用远调用或远转移也完全是可以的。
由于近调用或近转移的效率比远调用或远转移的效率高，所以一般总是乐意采用近调用或近转移。
但是，这并非总做得到，因为分布在不同源程序模块中的两个代码段在连接时能被组合为一个段是有条件的，
那就是它们的段名及其类别必须相同，而且段组合类型也应为PUBLIC。
在实际编程时，不同的模块往往由不同的人员完成，所以很难做到段同名。
为了避免考虑不同模块中的代码是否能组合成一个段，反而常常采用远调用或远转移。
例3：演示程序T8-7.ASM有如下三个模块组成，主模块中代码段的段名是CSEG，而两个从模块中代码段的段名是TEXT
；程序名：T8-7.ASM
；功能：演示模块间的转移
EXTRN SUB1:FAR
CSEG SEGMENT PARA PUBLIC 'CODE'
ASSUME CS:CSEG
START:CALL FAR PTR SUB1
MOV AX,4C00H
INT 21H
CSEG ENDS
END START
；模块名：T8-7MA.ASM
；功能：作为程序T8-7的一个模块
PUBLIC SUB1
EXTRN SUB2:NEAR
TEXT SEGMENT PARA PUBLIC 'CODE'
ASSUME CS:TEXT
SUB1 PROC FAR
MOV DL,'*'
MOV AH,2
INT 21H
CALL SUB2
RETF
SUB1 ENDP
TEXT ENDS
END
；模块名：T8-7MB.ASM
：功能：作为程序T8-7的一个模块
PUBLIC SUB2
TEXT SEGMENT PARA PUBLIC 'CODE'
ASSUME CS:TEXT
SUB2 PROC NEAR
MOV DL,'+'
MOV AH,2
INT 21H
RET
SUB2 ENDP
TEXT ENDS
END
由于模块T8-7MA中的代码段与主模块T8-7中的代码段不同名，所以连接时不能组合成一个段，
因此过程SUB2被定义成远过程，在主模块T8-7中也相应地声明为FAR类型。
由于，模块T8-7MA和模块T8-7MB中的两个代码段的段名和段类别相同，而且组合类型为PUBLIC，所以，在连接时它们能被组合成一个段。
再由于，只有过程SUB1调用过程SUB2，即只有段内调用，因此过程SUB2才被定义为近过程，在模块T8-7MA中也相应地声明为NEAR类型。
可用如下命令把它们的三个目标模块连接到一起：
LINK T8-7 + T8-7MA + T8-7MB
如果主模块也要调用过程SUB2，那么应该把SUB2也定义为远过程。
采用简化的段定义可避免考虑段名是否相同，把有关的问题留给汇编程序解决。
例4：利用简化的段定义改写程序T8-7.ASM的三个模块。
；程序名：T8-7A.ASM
；功能：（略）
EXTRN SUB1:NEAR
.MODEL SMALL
.CODE
START:CALL SUB1
MOV AX,4C00H
INT 21H
END START
；程序名：T8-7AMA.ASM
PUBLIC SUB1
EXTRN SUB2:NEAR
.MODEL SMALL
.CODE
SUB1 PROC
MOV DL,'*'
MOV AH,2
INT 21H
CALL SUB2
RET
SUB1 ENDP
END
；模块名：T8-7AMB.ASM
PUBLIC SUB2
.MODEL SMALL
.CODE
SUB2 PROC
MOV DL,'+'
MOV AH,2
INT 21H
RET
SUB2 ENDP
END
由于三个模块均是SMALL模型，所以连接后的代码在一个段内，因此SUB1和SUB2均被作为近过程对待。
8.3.3模块间的信息传递
模块间的信息传递主要表现为模块间过程调用时的参数传递。在第4章介绍的过程调用参数传递原则和方法依然有效。
少量参数可利用寄存器传递或利用堆栈传递，大量参数可先组织在一个缓冲区中，然后利用寄存器或堆栈传递相应的指针。
如果要利用约定的存储单元传递参数，情形稍稍复杂些，需要把它们声明为公共标识符。
例5：写一个显示DOS版本号的程序。
MOV AH,30H
INT 21H                                                                  
AL    major version number
AH    minor version number
为了展示模块间信息的传递，我们把程序分成两个模块。主模块有一个数据段和一个代码段，从模块只含有两个子程序。源程序如下所示：
；程序名：T8-8.ASM
；功能：演示模块间的利用寄存器和约定存储单元传递信息
DSEG SEGMENT PUBLIC 'DATA'
MESS DB 'DOS Version is'
MESS1 DB ?
DB '.'
MESS2 DB 2 DUP (?)
DB 0DH,0AH,'$'
VERM DB 0
VERN DB 0
DSEG ENDS
PUBLIC VERM,VERN
EXTRN GETVER:FAR,TODASC:FAR
CSEG SEGMENT PUBLIC 'CODE'
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL FAR PTR GETVER
MOV AL,VERM
MOV BX,1
MOV SI,OFFSET MESS1
CALL FAR PTR TODASC
MOV AL,VERN
MOV BX,2
MOV SI,OFFSET MESS2
CALL FAR PTR TODASC
MOV DX,OFFSET MESS
MOV AH,9
INT 21H
MOV AX,4C00H
INT 21H
CSEG ENDS
END START
；模块名：T8-8MA.ASM
；功能：作为程序T8-8.ASM的模块
PUBLIC GETVER,TODASC
EXTRN VERM:BYTE,VERN:BYTE
FUNC SEGMENT PUBLIC 'CODE'
ASSUME CS:FUNC
GETVER PROC FAR
MOV AH,30H
INT 21H
MOV VERM,AL
MOV VERN,AH
RETF
GETVER ENDP
TODASC PROC FAR
MOV CL,10
TOASC1:XOR AH,AH
DIV CL
ADD AH,30H
MOV [SI+BX-1],AH
DEC BX
JNZ TOASC1
RETF
TODASC ENDP
FUNC ENDS
END
使用段简化定义
；程序名：T8-8A.ASM
；功能：演示模块间的利用寄存器和约定存储单元传递信息
PUBLIC VERM,VERN
EXTRN GETVER:NEAR,TODASC:NEAR
.MODEL SMALL
.DATA
MESS DB 'DOS Version is'
MESS1 DB ?
DB '.'
MESS2 DB 2 DUP (?)
DB 0DH,0AH,'$'
VERM DB 0
VERN DB 0
.CODE
START:MOV AX,DGROUP
MOV DS,AX
CALL GETVER
MOV AL,VERM
MOV BX,1
MOV SI,OFFSET MESS1
CALL TODASC
MOV AL,VERN
MOV BX,2
MOV SI,OFFSET MESS2
CALL TODASC
MOV DX,OFFSET MESS
MOV AH,9
INT 21H
MOV AX,4C00H
INT 21H
END START
；模块名：T8-8AMA.ASM
；功能：作为程序T8-8A.ASM的模块
PUBLIC GETVER,TODASC
EXTRN VERM:BYTE,VERN:BYTE
.MODEL SMALL
.CODE
GETVER PROC NEAR
MOV AH,30H
INT 21H
MOV VERM,AL
MOV VERN,AH
RET
GETVER ENDP
TODASC PROC NEAR
MOV CL,10
TOASC1:XOR AH,AH
DIV CL
ADD AH,30H
MOV [SI+BX-1],AH
DEC BX
JNZ TOASC1
RET
TODASC ENDP
END
子程序GETVER把DOS的版本号直接填入在主模块中约定的单元VERM和VERN中。
子程序TODASC的入口参数由寄存器传递，转换得到的十进制数ASCII码串直接写到主模块的指定缓冲区中。
这两个子程序均被定义为远过程。
正确设置数据段或附加段寄存器是模块间正确传递信息的保证。在访问定义在其他模块的变量前，必须保证已设置好相应的段寄存器。
例如：在调用GETVER之前必须正确设置数据段寄有器DS，因为子程序GETVER在访问约定的变量时，认为数据段寄存器已设置好。
如有必要还可动态地改变段寄存器内容。
模块间传递信息的另一个方法是利用段覆盖，这个方法只适用于模块间传递信息。
具体方法是：在两个模块中都定义一个同名同类别数据段，规定段组合类型是COMMON；
把要传递的数据（变量）安排在这两个数据段的相同位置上。由于这两个在不同模块中的数据段同名同类别，且组合类型是COMMON，
所以连接时它们就发生重叠。
例6：写一个显示当前系统日期的程序。
MOV AH,2AH
INT 21H
CX    year (1980 to 2099)
DH    month (1 to 12)
DL    day (1 to 31)
AL    day of the week (0=Sun, 1=Mon,...6=Sat)
MOV AH,2CH
CH    hour (0 to 23)
CL    minutes (0 to 59)
DH    seconds (0 to 59)
DL    hundredths of a second (0 to 99) 百分之一秒
当前日期的获取是调用21H号中断处理程序的2AH号功能完成的
当前时间的获取是调用21H号中断处理程序的2CH号功能完成的。
为了简单化，显示的日期只含月和日。主模块有一个代码段和一个数据段，从模块也有一个代码段和数据段。源程序如下：
；程序名：T8-9.ASM
：功能：演示利用段覆盖方法在模块间传递信息
EXTRN GETDATE:FAR
DSEG SEGMENT COMMON 'DATA'
MESS DB 'Current date is '
MESSY DB 4 DUP (?)
DB '-'
MESS1 DB 2 DUP (?)
DB '-'
MESS2 DB 2 DUP (?)
DB 0DH,0AH,24H
DSEG ENDS
CSEG SEGMENT PUBLIC 'CODE'
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL FAR PTR GETDATE
MOV DX,OFFSET MESS
MOV AH,9
INT 21H
MOV AX,4C00H
INT 21H
CSEG ENDS
END START
；模块名：T8-9MA.ASM
；功能：作为T8-9.ASM的一部分
PUBLIC GETDATE
DSEG SEGMENT COMMON 'DATA'
MESS DB 'Current date is '
MESSY DB 4 DUP (?)
DB '-'
MESS1 DB 2 DUP (?)
DB '-'
MESS2 DB 2 DUP (?)
DB 0DH,0AH,24H
YEAR DW ?
MONTH DB ?
DAY DB ?
DSEG ENDS
CSEG SEGMENT BYTE PUBLIC 'CODE'
ASSUME CS:CSEG,DS:DSEG
GETDATE PROC FAR
MOV AH,2AH
INT 21H
MOV YEAR,CX
MOV MONTH,DH
MOV DAY,DL
MOV AX,YEAR
XCHG AH,AL
MOV BX,2
MOV SI,OFFSET MESSY
CALL TODASC
MOV AX,YEAR
MOV BX,2
MOV SI,OFFSET MESSY + 2
CALL TODASC
MOV AL,MONTH
MOV BX,2
MOV SI,OFFSET MESS1
CALL TODASC
MOV AL,DAY
MOV BX,2
MOV SI,OFFSET MESS2
CALL TODASC
RETF
GETDATE ENDP
TODASC PROC NEAR
MOV CL,10
TOASC1:XOR AH,AH
DIV CL
ADD AH,30H
MOV [SI+BX-1],AH
DEC BX
JNZ TOASC1
RET
TODASC ENDP
CSEG ENDS
END
按照年-月-日显示系统日期
；程序名：T8-9A.ASM
：功能：演示利用段覆盖方法在模块间传递信息
EXTRN GETDATE:FAR
DSEG SEGMENT COMMON 'DATA'
MESS DB 'Current date is '
MESSY DB 4 DUP (?)
DB '-'
MESS1 DB 2 DUP (?)
DB '-'
MESS2 DB 2 DUP (?)
DB 0DH,0AH,24H
DSEG ENDS
CSEG SEGMENT PUBLIC 'CODE'
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL FAR PTR GETDATE
MOV DX,OFFSET MESS
MOV AH,9
INT 21H
MOV AX,4C00H
INT 21H
CSEG ENDS
END START
；模块名：T8-9AMA.ASM
；功能：作为T8-9A.ASM的一部分
PUBLIC GETDATE
DSEG SEGMENT COMMON 'DATA'
MESS DB 'Current date is '
MESSY DB 4 DUP (?)
DB '-'
MESS1 DB 2 DUP (?)
DB '-'
MESS2 DB 2 DUP (?)
DB 0DH,0AH,24H
YEAR DW ?
MONTH DB ?
DAY DB ?
DSEG ENDS
CSEG SEGMENT BYTE PUBLIC 'CODE'
ASSUME CS:CSEG,DS:DSEG
GETDATE PROC FAR
MOV AH,2AH
INT 21H
MOV YEAR,CX
MOV MONTH,DH
MOV DAY,DL
MOV AX,YEAR
MOV DX,0
MOV BX,4
MOV SI,OFFSET MESSY
CALL TODASC
MOV AL,MONTH
MOV AH,0
MOV DX,0
MOV BX,2
MOV SI,OFFSET MESS1
CALL TODASC
MOV AL,DAY
MOV AH,0
MOV DX,0
MOV BX,2
MOV SI,OFFSET MESS2
CALL TODASC
RETF
GETDATE ENDP
DIVDW PROC NEAR
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
TODASC PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
CMP DX,0
JNZ TODASC1
CMP AX,0
JNZ TODASC1
CMP BX,0
JZ TODASC_OK
TODASC_S1:MOV BYTE PTR [SI+BX-1],'0'
DEC BX
JNZ TODASC_S1
JMP TODASC_OK
TODASC1:CMP BX,0
JZ TODASC_OK
divide_TODASC:cmp dx,0
jz finish_s_TODASC1
divide_s_TODASC:mov cx,10
call divdw
add cx,30h
MOV BYTE PTR [SI+BX-1],CL
DEC BX
jmp divide_TODASC
finish_s_TODASC1:cmp ax,0
jz finish_TODASC
jmp divide_s_TODASC
finish_TODASC:CMP BX,0
JZ TODASC_OK
TODASC_S2:MOV BYTE PTR [SI+BX-1],'0'
DEC BX
JNZ TODASC_S2
TODASC_OK:POP DX
POP CX
POP BX
POP AX
RET
TODASC ENDP
CSEG ENDS
END
使用段简化定义
；程序名：T8-9B.ASM
EXTRN GETDATE:FAR
PUBLIC YEAR,MONTH,DAY
.MODEL SMALL
.DATA
MESS DB 'Current date is '
MESSY DB 4 DUP (?)
DB '-'
MESS1 DB 2 DUP (?)
DB '-'
MESS2 DB 2 DUP (?)
DB 0DH,0AH,24H
YEAR DW ?
MONTH DB ?
DAY DB ?
.CODE
START:MOV AX,DGROUP
MOV DS,AX
CALL FAR PTR GETDATE
MOV AX,YEAR
MOV DX,0
MOV BX,4
MOV SI,OFFSET MESSY
CALL TODASC
MOV AL,MONTH
MOV AH,0
MOV DX,0
MOV BX,2
MOV SI,OFFSET MESS1
CALL TODASC
MOV AL,DAY
MOV AH,0
MOV DX,0
MOV BX,2
MOV SI,OFFSET MESS2
CALL TODASC
MOV DX,OFFSET MESS
MOV AH,9
INT 21H
MOV AX,4C00H
INT 21H
DIVDW PROC NEAR
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
TODASC PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
CMP DX,0
JNZ TODASC1
CMP AX,0
JNZ TODASC1
CMP BX,0
JZ TODASC_OK
TODASC_S1:MOV BYTE PTR [SI+BX-1],'0'
DEC BX
JNZ TODASC_S1
JMP TODASC_OK
TODASC1:CMP BX,0
JZ TODASC_OK
divide_TODASC:cmp dx,0
jz finish_s_TODASC1
divide_s_TODASC:mov cx,10
call divdw
add cx,30h
MOV BYTE PTR [SI+BX-1],CL
DEC BX
jmp divide_TODASC
finish_s_TODASC1:cmp ax,0
jz finish_TODASC
jmp divide_s_TODASC
finish_TODASC:CMP BX,0
JZ TODASC_OK
TODASC_S2:MOV BYTE PTR [SI+BX-1],'0'
DEC BX
JNZ TODASC_S2
TODASC_OK:POP DX
POP CX
POP BX
POP AX
RET
TODASC ENDP
END START
；模块名：T8-9BMA.ASM
；功能：作为T8-9B.ASM的一部分
EXTRN YEAR:WORD,MONTH:BYTE,DAY:BYTE
PUBLIC GETDATE
.MODEL SMALL
.CODE
GETDATE PROC FAR
MOV AH,2AH
INT 21H
MOV YEAR,CX
MOV MONTH,DH
MOV DAY,DL
RETF
GETDATE ENDP
END
模块T8-9MA中的数据段比模块T8-9.ASM中的数据段多了若干变量，在段覆盖时，以最长的段为段的最后实际长度。
但必须注意，要传递的数据变量必须安排在相同的位置。由于模块T8-9MA中含有要访问的数据段，
所以过程GETDATE能够随便地访问想要访问的对象。
8.4子程序库
子程序库能帮助程序员快速地编写出正确的程序，本节介绍如何建立子程序库和利用子程序库。
8.4.1子程序库
把频繁使用的一组子程序的源代码集中存放在某个文件中，再通过INCLUDE伪指令把它与完成某个任务的源程序相结合，
这样就能方便地利用这些子程序，而无需重新编写或编辑它们。这种方法能提高编写程序的效率，但有以下不足：
其一，当前源程序中的标号或变量名等可能与被结合的子程序文件中的标号等发生冲突（即符号重新定义）;
其二，由于是源程序结合，所以每次汇编都包括对子程序文件的汇编，增加了汇编时间。
采用模块化程序设计方法，把包含常用子程序的源程序文件改写成一个源程序模块，然后单独汇编它，于是就可形成一个常用子程序目标文件。
完成某个具体任务的程序只要把所需调用子程序声明为在其他模块内定义，那么就能通过汇编，
最后再与这个常用子程序目标文件相连接就能得到可执行程序。这个方法能克服上述源程序结合方法的不足，从而进一步提高编写程序的效率。
由于被连接的每一目标文件的全部代码都会成为最终可执行程序的一部分，所以这个方法也有一个缺点：
当前未使用到的但却属于常用子程序目标文件的子程序都会出现在最终的可执行程序中。库能克服这个缺点。
子程序库是子程序模块的集合。库文件中存放着子程序的名称，子程序的目标代码，以及连接过程所必需的重定位信息。
当目标文件与库相连接时，LINK程序只把目标文件所需要的子程序从库中找出来，并嵌入到最终的可执行程序中去，
而不是把库内的全部子程序统统嵌入到可执行程序。所以，库与目标文件不同，子程序库能克服子程序目标文件的缺点。
8.4.2建立子程序库
为了给调用者提供方便，库中的子程序应该提供统一的调用方法，所以需要遵守如下约定：
（1）参数传递方法保持统一。
（2）过程类型保持相同，即都为远过程或都为近过程。
请特别注意，如果过程类型选择NEAR，那么必须保证在连接时调用者所在段能与子程序所在段组合成一个段，
为此，调用者所在段的段名和类别应该与子程序所在段的段名和类别相同，且组合类型同为PUBLIC。
（3）采用一致的寄存器保护措施和可能需要的堆栈平衡措施。
（4）子程序名称规范。
建立子程序库的一般步骤如下：
（1）确定库所含子程序的范围，即库准备包含哪些子程序。
（2）确定参数传递方法。
（3）确定子程序类型，还确定子程序所在段的段名、定位类型、组合类型和类别。
（4）确定寄存器保护措施等其他内容。
（5）利用专门的库管理工具程序，把经过调试的子程序目标模块逐一加入到库中。
下面我们来建立一个子程序库，它包含若干数制转换子程序目标模块。
为了方便地使库中各子程序目标模块所在的段相同，在编写各子程序模块源程序时，采用简化的段定义，并把存储模型定为SMALL；
但子程序类型规定为FAR，即均为远过程，于是，调用模块只要把欲调用的子程序声明为在其它模块内定义，且类型为FAR即可，
而无需考虑是否能与被调用的子程序模块组合成同一个段。此外，还作如下约定：采用寄存器传递出入口参数；
各子程序除了可能破坏AX、BX、CX和DX四个寄存器的内容外，保护其他寄存器的内容。
例1：编写一个把二进制数转换为对应十进制数ASCII码串的子程序，并把它添加到名为BDHL.LIB的库中。
源程序如下所示：
；源文件名：T8L1.ASM
；功能：（略）
PUBLIC BDASCS
.MODEL SMALL
.CODE
BDASCS PROC FAR
PUSH SI
MOV SI,DX
MOV CX,5
MOV BX,10
BDASCS_S1:XOR DX,DX
DIV BX
ADD DL,30H
MOV BYTE PTR [SI+4],DL
DEC SI
LOOP BDASCS_S1
POP SI
RETF
BDASCS ENDP
END
设源程序存放在文件T8L1.ASM中，可利用如下命令汇编成目标模块且添加到库BDHL.LIB中去：
MASM T8L1.ASM
LIB BDHL.LIB + T8L1.OBJ
例2：编写一个把二进制数转换为对应十六进制数ASCII码串的子程序，并把它添加到名为BDHL.LIB的库中。
源程序如下所示：
；源文件名：T8L2.ASM
；功能：（略）
PUBLIC BHASCS
.MODEL SMALL
.CODE
HTOASC PROC NEAR
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
RET
HTOASC ENDP
BHASCS PROC FAR
PUSHF
PUSH DI
PUSH ES
CLD
PUSH DS
POP ES
MOV DI,DX
MOV CX,0404H
BHASCS_S1:ROL AX,CL
MOV DX,AX
CALL HTOASC
STOSB
MOV AX,DX
DEC CH
JNZ BHASCS_S1
POP ES
POP DI
POPF
RETF
BHASCS ENDP
END
子程序BHASCS调用HTOASC实现把一位十六进制数转换为对应ASCII码，但由于没有把标识符HTOASC声明为公共标识符，
所以它不能供其它程序调用。由于子程序HTOASC与子程序BHASCS在同一个模块，且只供BHASCS调用，所以采用类型NEAR。
子程序HTOASC的代码始终伴随着子程序BHASCS，当某个程序需要连入子程序BHASCS时，子程序HTOASC也被连入。
设源程序存放在文件T8L2.ASM中，可利用如下命令把它汇编成目标模块且添加到库中去：
MASM T8L2.ASM
LIB BDHL.LIB + T8L2.OBJ
8.4.3使用举例
下面我们举例说明如何利用子程序库。
添加模块到库中
LIB YourLib.LIB + YourMod.OBJ ；
如果模块已存在于库中，将其替换为新的模块 
LIB YourLib.LIB -+ NewMod.OBJ ；
从库中移除模块
LIB YourLib.LIB - YourMod;
例3：写一个显示16H号中断向量的程序。
使用简单的段定义方式，存储模型定为SMALL。实现算法是：取有关中断向量；再调用已建立的库BDHL.LIB中的子程序BHASCS，
把向量值转换为对应十六进制数的ASCII码串；最后显示ASCII码串。源程序如下所示：
；程序名：T8-10.ASM
；功能：（略）
.MODEL SMALL
.STACK 1024
.DATA
MESS LABEL BYTE
MESS1 DB 4 DUP (0)
DB ':'
MESS2 DB 4 DUP (0)
DB 0DH,0AH,24H
.CODE
EXTRN BHASCS:FAR
START:MOV AX,@DATA
MOV DS,AX
MOV AX,3516H
INT 21H
PUSH BX
MOV AX,ES
MOV DX,OFFSET MESS1
CALL FAR PTR BHASCS
POP AX
MOV DX,OFFSET MESS2
CALL FAR PTR BHASCS
MOV DX,OFFSET MESS
MOV AH,9
INT 21H
MOV AX,4C00H
INT 21H
END START
例4：写一个显示系统常规内存量的程序。
0040:0013   2个字节 Total memory in K-bytes (same as obtained via INT 12H)
系统常规内存量存放在内存单元0040:0013H的字单元中，以KB为单位。
实现算法是：先从0040:0013H单元中取得内存量；再调用库BDHL.LIB中的子程序BDASCS，
把以二进制数形式表示的内存量转换为对应十进制数的ASCII码串；最后显示之。程序采用完整的段定义方式。源程序如下所示：
；程序名：T8-11.ASM
：功能：（略）
EXTRN BDASCS:FAR
SSEG SEGMENT STACK 'STACK'
DB 400H DUP (0)
SSEG ENDS
CSEG SEGMENT PUBLIC
MESS DB 'Total = '
MESS1 DB 5 DUP (0)
DB 'KB',0DH,0AH,24H
ASSUME CS:CSEG,DS:CSEG
START:PUSH CS
POP DS
MOV AX,0040H
MOV ES,AX
MOV AX,ES:[0013H]
MOV DX,OFFSET MESS1
CALL FAR PTR BDASCS
MOV DX,OFFSET MESS
MOV AH,9
INT 21H
MOV AX,4C00H
INT 21H
CSEG ENDS
END START
8.5编写供Turbo C调用的函数
将C语言和汇编语言混合使用的传统方式是，先用C语言和汇编语言编写出独立的模块，然后编译C语言模块并汇编汇编语言模块，
最后再将得到的目标模块连接到一起。普通情况下，这种汇编语言模块由若干被频繁调用而左右程序运行效率的子程序所组成。
在C语言中，习惯上把子程序称为函数，所以，我们说这种汇编语言模块由若干汇编函数组成。
为了使C模块能够调用到汇编模块中的函数，在编写汇编模块时，必须注意两个方面的内容。
第一，汇编模块必须能够恰当地与C模块连接到一起，并且其中的汇编函数名等要符合C语言的约定；
第二，汇编函数必须能恰当地处理C风格的函数调用，包括访问传递过来的参数、返回值及遵守C函数所要求的寄存器保护规则。
8.5.1汇编格式的编译结果
为了能够编写出可供Turbo C调用的函数，应了解Turbo C模块与汇编模块的接口机制，而从以汇编形式给出的编译结果中可方便地了解这种机制。
设有如下C程序：
int Sum(int, int, int);
int xxx = 5;
int yyy;
main()
{
    yyy = Sum(1, xxx, 3);
    printf("%d\n", yyy);
}
int Sum(int i, int j, int m)
{
    return (i + j + m);
}
用下面的命令要求Turbo C按SMALL模式编译TC8.C，并以汇编格式输出编译结果：
TCC -ms -S TC8.C
以汇编格式输出的编译结果保存在文件TC8.ASM中，尽管该文件比较冗长，但阅读和理解它对编写供Turbo C调用的汇编函数是有帮助的，
而且对学习C语言也是有益的。TC8.ASM的主要内容如下所示（已删去空段和注释等次要内容）：
_TEXT	segment	byte public 'CODE'
DGROUP	group	_DATA,_BSS
	assume	cs:_TEXT,ds:DGROUP,ss:DGROUP
_TEXT	ends
_DATA	segment word public 'DATA'
_xxx	label	word
	dw	5
_DATA	ends
_TEXT	segment	byte public 'CODE'
_main	proc	near
	mov	ax,3
	push	ax
	push	word ptr DGROUP:_xxx
	mov	ax,1
	push	ax
	call	near ptr _Sum
	add	sp,6
	mov	word ptr DGROUP:_yyy,ax
	push	word ptr DGROUP:_yyy
	mov	ax,offset DGROUP:s@
	push	ax
	call	near ptr _printf
	pop	cx
	pop	cx
@1:	ret	
_main	endp
_Sum	proc	near
	push	bp
	mov	bp,sp
	mov	ax,word ptr [bp+4]
	add	ax,word ptr [bp+6]
	add	ax,word ptr [bp+8]
	jmp	short @2
@2:	pop	bp
	ret	
_Sum	endp
_TEXT	ends
_BSS	segment word public 'BSS'
_yyy	label	word
	db	2 dup (?)
_BSS	ends
_DATA	segment word public 'DATA'
s@	label	byte
	db	37
	db	100
	db	10
	db	0
_DATA	ends
_TEXT	segment	byte public 'CODE'
	extrn	_printf:near
_TEXT	ends
	public	_yyy
	public	_xxx
	public	_main
	public	_Sum
	end
从上面以汇编格式给出的编译结果中，可以看到函数Sum除包含一条多余的跳转指令外，已足够精练。
但为了方便地说明如何编写供Turbo C调用的函数，我们仍然假设希望把上述C函数Sum改写成汇编函数。相应地，C程序TC8.C改写如下：
extern Sum(int, int, int);
int xxx = 5;
int yyy;
main ()
{
    yyy = Sum(1, xxx, 3);
    printf("%d\n", yyy);
}
以汇编格式输出编译结果，其中的主要内容如下所示（已删去空段和注释等次要内容）
_TEXT	segment	byte public 'CODE'
DGROUP	group	_DATA,_BSS
	assume	cs:_TEXT,ds:DGROUP,ss:DGROUP
_TEXT	ends
_DATA	segment word public 'DATA'
_xxx	label	word
	dw	5
_DATA	ends
_TEXT	segment	byte public 'CODE'
_main	proc	near
	mov	ax,3
	push	ax
	push	word ptr DGROUP:_xxx
	mov	ax,1
	push	ax
	call	near ptr _Sum
	add	sp,6
	mov	word ptr DGROUP:_yyy,ax
	push	word ptr DGROUP:_yyy
	mov	ax,offset DGROUP:s@
	push	ax
	call	near ptr _printf
	pop	cx
	pop	cx
@1:
	ret	
_main	endp
_TEXT	ends
_BSS	segment word public 'BSS'
_yyy	label	word
	db	2 dup (?)
_BSS	ends
_DATA	segment word public 'DATA'
s@	label	byte
	db	37
	db	100
	db	10
	db	0
_DATA	ends
_TEXT	segment	byte public 'CODE'
	extrn	_printf:near
	extrn	_Sum:near
_TEXT	ends
	public	_yyy
	public	_xxx
	public	_main
	end
程序CA8.C与TC8.C的区别是不再定义函数Sum，而声明它在其他模块内定义。下面就介绍如何编写包含函数Sum的汇编模块。
8.5.2汇编模块应该遵守的约定
1.关于内存模式和段的约定
为了使得汇编模块能够恰当地与Turbo C模块连接到一起，汇编模块必须采用与Turbo C模块一致的内存模式，
同时必须遵守与Turbo C兼容的段命名约定。
如果采用完整的段定义形式，那么汇编模块中所需段的定义应该按照TC8.ASM中相应段的定义形式来编写。这似乎有点麻烦。
幸运的是，利用简化的段定义方式，能轻松地实现内存模式的一致和兼容的段命名。
因为采用简化的段定义方式后，汇编程序就自动完成这方面的全部工作。根据表8.1所列内容，
只要用伪指令.MODEL SMALL说明内存模式为SMALL，然后用伪指令.CODE定义的代码段以及用伪指令.DATA定义的数据段等
均与TC8.ASM中相应段的定义一致。换句话说，在汇编模块中安排伪指令".MODEL SMALL"，
那么汇编后所得到的目标模块就能够与Turbo C按SMALL模式编译后所得的目标模块有效地连接。
事实上，不仅仅在SMALL模式下如此，在其他内存模式下也如此。
伪指令.MODEL通知汇编程序，用简化的段定义伪指令创建的段与选定的内存模式兼容，并控制用PROC伪指令创建的过程的隐含类型。
另一方面，由伪指令.MODEL定义的内存模式与具有同样类型的Turbo C模式是相互兼容的。
所以，简化的段定义伪指令.CODE、.DATA、.DATA?、.FARDATA、.FARDATA?及.CONST等产生的段与Turbo C相应的段兼容。
2.关于函数名的约定
一般情况下，Turbo C希望所有的外部标号均以下划线“”开头。Turbo C自动地给函数名及全局变量名（包括外部变量名）加上下划线，
在上述TC8.ASM中可清楚地看到这一点。所以，如果汇编模块中定义的函数准备提供给Turbo C调用，那么函数名必须以下划线开头。
顺便指出，如果汇编模块中定义的变量也准备供Turbo C访问，那么也需以下划线开头。
通常情况下，在处理符号名时，汇编程序对字母的大小写并不敏感，所以不区别对待大写字母和小写字母，而皆以大写字母对待。
因为C语言区别对待大小写字母，所以在编写准备与C模块相连接的汇编模块时，应该注意符号名的大小写，以便保持一致。
而且，要通知汇编程序对大小写区别对待，至少对于C模块和汇编模块所共享的那些符号而言应该如此。
汇编程序的命令行可选项/Cp和/Cx可以做到这一点。
汇编程序的命令行可选项/Cp使得汇编对所有符号均按大小写区别对待。
汇编程序的命令行可选项/Cx使得汇编只对公共标识符和外部标识符等按大小写区别对待。
/Cp
Preserves case of all user identifiers.
/Cx
Preserves case in public and extern symbols.
至此，我们可编写出如下格式的汇编模块：
.MODEL SMALL
.CODE
PUBLIC _Sum
_Sum PROC
......
......
_Sum ENDP
END
8.5.3参数传递和寄存器保护
下面介绍用汇编语言编写的函数如何与Turbo C交流信息，这包括三个方面的内容：
获取由调用者提供的入口参数、把可能的处理结果值返回给调用者以及寄存器的保护。
换一个角度看，这三个方面的内容也就是Turbo C调用函数的一般方法。
1.获取入口参数
我们在4.2.3节中介绍了如何利用堆栈传递参数及访问堆栈中的参数。
在知道了参数类型（占用堆栈空间的字节数）和次序后，就能够通过BP寄存器方便地访问堆栈中的参数。
Turbo C通过堆栈将参数传递给函数。调用函数之前，Turbo C先将要传给函数的参数压入堆栈，
最先压入最右边的参数，最后压入最左边的参数。
在TC8.C中的C语句"yyy=Sum(1,xxx,3);"被编译成如下汇编指令：
	mov	ax,3
	push	ax
	push	word ptr DGROUP:_xxx
	mov	ax,1
	push	ax
	call	near ptr _Sum
	add	sp,6
	mov	word ptr DGROUP:_yyy,ax
从中可清楚地看到，先压入最右边的参数3，再压入变量xxx的值，最后压入最左边的参数1。
从函数返回时，先前压入堆栈的参数仍然保留在堆栈中，但这些参数已没有任何用途。
所以，在每次调用函数之后，Turbo C立即调整堆栈指针，使之指向压入参数前所指的位置，这样就放弃了堆栈中的参数。
在上面的例子中，3个双字节的参数共占6个字节的堆栈空间，所以在调用Sum之后，add	sp,6指令将堆栈指针加6以删除这些参数。
这里很重要的一点就是，堆栈中的参数由调用者负责删除。
那么，如何访问堆栈中的参数呢？先来看看TC8.C中的函数Sum是如何访问堆栈中的参数的：
_Sum	proc	near
	push	bp
	mov	bp,sp
	mov	ax,word ptr [bp+4]
	add	ax,word ptr [bp+6]
	add	ax,word ptr [bp+8]
	jmp	short @2
@2:	pop	bp
	ret	
_Sum	endp
在执行完上面的call near ptr _Sum指令后，堆栈顶如图8.2（a）所示，在把参数依次压入堆栈后进行函数调用时，返回地址也被压入堆栈。
为了通过BP寄存器访问堆栈中的参数，先保护BP寄存器。在执行完上面的push bp和mov bp,sp指令后，堆栈顶如图8.2（b）所示。
直接用汇编语言编写的函数Sum当然也能够按此方法访问堆栈中的参数。
但并非所有情形都如此简单。首先，相对于BP以常偏移量访问参数的做法并不理想，
这不仅仅因为不易于阅读和理解，而且容易搞错偏移量，特别是如果增加要传递的参数，那么偏移量又得重新调整。
更为严重的是：如果采用远调用，那么保存的返回地址要占用4个字节的堆栈空间；
此外，压入堆栈的参数所占用堆栈空间的字节数与参数类型有关，例如：如果参数是一个长整数或长指针，则将占用4字节的堆栈空间。
为此，TASM还提供了一条伪指令ARG来帮助程序员处理好访问堆栈中参数的问题。
2.返回值
象普通C函数一样，供Turbo C调用的汇编函数也可利用寄存器返回值。
通常情况下，8或16位的值通过AX寄存器返回，32位的值通过DX:AX寄存器对返回，其中高16位在DX寄存器中。
所以，可通过AX返回短指针，通过DX:AX返回长指针。
在上述TC8.ASM中，可清楚地看到函数Sum的返回值由寄存器AX传递出来。
现在，我们可编写出如下的含有函数Sum的汇编模块：
；模块名：A8.ASM
；内容：含一个供CA8.C调用的函数Sum
.MODEL SMALL
.CODE
PUBLIC _Sum
PARM1 EQU [BP+4]
PARM2 EQU [BP+6]
PARM3 EQU [BP+8]
_Sum PROC
PUSH BP
MOV BP,SP
MOV AX,PARM1
ADD AX,PARM2
ADD AX,PARM3
POP BP
RET
_Sum ENDP
END
通过下面的命令能够完成对CA8.C的编译、对A8.ASM的汇编，最后再连接到一起：
TCC -ms -c CA8.C
MASM /c /Cp A8.ASM
LINK c0s.obj + CA8.obj + A8.OBJ
Run file : CA8.exe
Libraries : CS.lib
上述最后连接命令中的c0s.obj和CS.lib分别是Turbo C的SMALL模式下的启动代码目标模块文件和函数库文件。
必须注意，上面的汇编模块A8.OBJ只能与按SMALL模式编译的C模块CA8.obj相连接。
使用DEBUG查看生成的可执行程序
-u cs:01fa
MOV AX,0003
PUSH AX
PUSH [0194]
MOV AX,0001
PUSH AX
CALL 021E
ADD SP,+06
MOV [0424],AX
PUSH [0424]
MOV AX,0196
PUSH AX
CALL 0397
POP CX
POP CX
RET
-u cs:021e
PUSH BP
MOV BP,SP
MOV AX,[BP+04]
ADD AX,[BP+06]
ADD AX,[BP+08]
POP BP
RET
3.保护寄存器
Turbo C要求供它调用的汇编语言函数必须保护好寄存器BP、SP、CS、DS和SS的内容。
尽管在汇编语言函数中可以改变这些寄存器的内容，但当返回时，它们的值必须与调用前相同。
可以随意地改变寄存器AX、BX、CX、DX和ES及标志寄存器的内容。寄存器SI和DI是特殊情况，因为Turbo C将其用作寄存器变量。
如果在调用汇编语言函数的C模块中启动了寄存器变量，那么在汇编语言函数中就必须保护寄存器SI和DI；
但若没有启动寄存器变量，就不必保护这两个寄存器。一个稳妥的做法是，象保护寄存器BP它们那样，总是保护寄存器SI和DI。
汇编语言函数一般不会修改CS、SS，一般通过PUSH、POP维护SP，通常保护BP、DS、ES、SI、DI。
8.5.4举例
例1：写一个求若干16位有符号数之和的汇编语言函数。它有两个入口参数，其一是数组的元素个数，其二是指向数组的指针。
它的返回值是一个32位有符号数。在C模块中说明的原型格式是：
extern long niadd(int *,int);
适用于SMALL模式编译的C模块相连的汇编模块如下所示：
；模块名：A86.ASM
；功能：（略）
. MODEL SMALL
PARM STRUC
REGBP DW ?
RETADDR DW ?
POINTER DW ?
COUNT DW ?
PARM ENDS
. CODE
PUBLIC _niadd
_niadd PROC NEAR
PUSH BP
MOV BP,SP
PUSH SI
PUSH DI
CLD
MOV SI,[BP].POINTER
MOV CX.[BP].COUNT
XOR BX,BX
MOV DI,BX
niadd_S1:LODSW
CWD
ADD BX,AX
ADC DI,DX
LOOP niadd_S1
MOV DX,DI
MOV AX,BX
POP DI
POP SI
POP BP
RET
_niadd ENDP
END
源程序中说明了一个结构数据类型，它能够反映在保护寄存器BP之后堆栈顶的内容，但并没有真正地分配结构变量，
在获取入口参数时，可以设想在堆栈顶分配了这样的一个结构变量，这样可方便表达堆栈中的参数。
另外，作为入口参数给出的缓冲区首地址只含有偏移，而没有段值，这是因为这个函数只准备提供给按SMALL模式编译的C模块调用，
所以认为在调用该函数之前数据段寄存器已设置好，而无需由函数再设置。
调用上述函数的一个Turbo C程序如下所示：
extern long niadd(int *, int);
int buffer[6] = {12345, 10000, -20000, 23456, -2345, -56};
main()
{
    long x;
    x = niadd(buffer, 6);
    printf("x=%ld\n", x);
}
以汇编格式输出编译结果，其中的主要内容如下所示（已删去空段和注释等次要内容）
_TEXT	segment	byte public 'CODE'
DGROUP	group	_DATA,_BSS
	assume	cs:_TEXT,ds:DGROUP,ss:DGROUP
_TEXT	ends
_DATA	segment word public 'DATA'
_buffer	label	word
	dw	12345
	dw	10000
	dw	-20000
	dw	23456
	dw	-2345
	dw	-56
_DATA	ends
_TEXT	segment	byte public 'CODE'
_main	proc	near
	push	bp
	mov	bp,sp
	sub	sp,4
	mov	ax,6
	push	ax
	mov	ax,offset DGROUP:_buffer
	push	ax
	call	near ptr _niadd
	pop	cx
	pop	cx
	mov	word ptr [bp-2],dx
	mov	word ptr [bp-4],ax
	push	word ptr [bp-2]
	push	word ptr [bp-4]
	mov	ax,offset DGROUP:s@
	push	ax
	call	near ptr _printf
	add	sp,6
@1:
	mov	sp,bp
	pop	bp
	ret	
_main	endp
_TEXT	ends
_DATA	segment word public 'DATA'
s@	label	byte
	db	120
	db	61
	db	37
	db	108
	db	100
	db	10
	db	0
_DATA	ends
_TEXT	segment	byte public 'CODE'
	extrn	_printf:near
	extrn	_niadd:near
_TEXT	ends
	public	_buffer
	public	_main
	end
通过下面的命令能够完成对t428.c的编译、对t429.ASM的汇编，最后再连接到一起：
TCC -ms -c t428.C
MASM /Zm /c /Cp t429.ASM
LINK c0s.obj + t428.obj + t429.OBJ
Run file : t428.exe
Libraries : CS.lib
上述最后连接命令中的c0s.obj和CS.lib分别是Turbo C的SMALL模式下的启动代码目标模块文件和函数库文件。
必须注意，上面的汇编模块t429.OBJ只能与按SMALL模式编译的C模块t428.obj相连接。
执行结果
x=23400
使用DEBUG查看生成的可执行程序
-u cs:01fa
PUSH BP
MOV BP,SP
SUB SP,+04
MOV AX,0006
PUSH AX
MOV AX,0194
PUSH AX
CALL 0228
POP CX
POP CX
MOV [BP-02],DX
MOV [BP-04],AX
PUSH [BP-02]
PUSH [BP-04]
MOV AX,01A0
PUSH AX
CALL 03B3
ADD SP,+06
MOV SP,BP
POP BP
RET
-u cs:0228
PUSH BP
MOV BP,SP
PUSH SI
PUSH DI
CLD
MOV SI,[BP+04]
MOV CX,[BP+06]
XOR BX,BX
MOV DI,BX
LODSW
CWD
ADD BX,AX
ADC DI,DX
LOOP 0238
MOV DX,DI
MOV AX,BX
POP DI
POP SI
POP BP
RET
例2：改写上面的A86.ASM，使其具有良好的通用性，并把所得模块添加到相应的Turbo C函数库中去。
汇编模块A86.ASM中的函数niadd只能供以SMALL模式编译的C模块调用，其原因除了伪指令.MODEL说明采用SMALL模式外，
更主要的还在于只考虑了近调用和短指针，例如：在LARGE模式下，C模块将以远调用方式调用函数niadd，并且传递给函数的指针也是长指针。
改写后的模块如下所示：
；程序名：A86A.ASM
；功能：（略）
.MODEL SMALL
.CODE
PUBLIC _niadd
PARM STRUC
REGBP DW ?
IF @CODESIZE EQ 0
RETADDR DW ?
ELSE
RETADDR DD ?
ENDIF
IF @DATASIZE EQ 0
POINTER DW ?
ELSE
POINTER DD ?
ENDIF
COUNT DW ?
PARM ENDS
IF @CODESIZE EQ 0
_niadd PROC
ELSE
_niadd PROC FAR
ENDIF
PUSH BP
MOV BP,SP
PUSH SI
PUSH DI
CLD
IF @DATASIZE EQ 0
MOV SI,[BP].POINTER
ELSE
PUSH DS
LDS SI,[BP].POINTER
ENDIF
MOV CX,[BP].COUNT
XOR BX,BX
MOV DI,BX
niadd_S1:LODSW
CWD
ADD BX,AX
ADC DI,DX
LOOP niadd_S1
MOV DX,DI
MOV AX,BX
IF @DATASIZE NE 0
POP DS
ENDIF
POP DI
POP SI
POP BP
IF @CODESIZE EQ 0
RET
ELSE
RETF
ENDIF
_niadd ENDP
END
上述汇编模块中使用了预定义符号@CODESIZE和@DATASIZE，它们的值决定了条件汇编语句中的条件是否满足。
masm /Zm /c /Cx d:\t430.asm
link c0s.obj + t428.obj + t430.obj
Run file : t430.exe
Libraries : CS.lib
上述最后连接命令中的c0s.obj和CS.lib分别是Turbo C的SMALL模式下的启动代码目标模块文件和函数库文件。
必须注意，上面的汇编模块t430.OBJ只能与按SMALL模式编译的C模块t428.obj相连接。
执行结果
x=23400
使用DEBUG查看生成的可执行程序
-u cs:01fa
PUSH BP
MOV BP,SP
SUB SP,+04
MOV AX,0006
PUSH AX
MOV AX,0194
PUSH AX
CALL 0228
POP CX
POP CX
MOV [BP-02],DX
MOV [BP-04],AX
PUSH [BP-02]
PUSH [BP-04]
MOV AX,01A0
PUSH AX
CALL 03B3
ADD SP,+06
MOV SP,BP
POP BP
RET
-u cs:0228
PUSH BP
MOV BP,SP
PUSH SI
PUSH DI
CLD
MOV SI,[BP+04]
MOV CX,[BP+06]
XOR BX,BX
MOV DI,BX
LODSW
CWD
ADD BX,AX
ADC DI,DX
LOOP 0238
MOV DX,DI
MOV AX,BX
POP DI
POP SI
POP BP
RET
Small
single data segment and single code segment 
Medium
multiple code segments and single data segment
Compact
single code segment and multiple data segments 
Large
multiple code segments and multiple data segments 
Huge
multiple code segments and multiple data segments
individual data items may be larger than a single segment,
but the implementation of huge data items must be coded by the programmer. 
huge model is essentially the same as large model.
当利用.MODEL伪指令把内存模式设定为SMALL或COMPACT时，预定义符号@CODESIZE的值为0。
当利用.MODEL伪指令把内存模式设定为MEDIUM、LARGE或HUGE时，预定义符号@CODESIZE的值为1。
当利用.MODEL伪指令把内存模式设定为SMALL或MEDIUM时，预定义符号@DATASIZE的值为0。
当利用.MODEL伪指令把内存模式设定为COMPACT或LARGE时，@DATASIZE的值为1。
当利用.MODEL伪指令把内存模式设定为HUGE时，@DATASIZE的值为2。
另外，在使用.MODEL伪指令设定内存模式后，缺省的过程类型会根据内存模式的不同而改变，在中、大或巨模式下，缺省过程类型是FAR，
而不再一直是NEAR。
汇编程序模块A86A.ASM考虑了各种内存模式的情况，所以较为通用。如果要使它与按某种模式编译的C模块相连接，
那么只要把由伪指令.MODEL指定的内存模式修改为这种希望的内存模式，再重新汇编即可。
同样在重新汇编后，也就可把它添加到相应模式的库函数中。
利用库管理工具TLIB，可以直接把汇编后所得的目标模块添加到Turbo C的相应函数库中去。
如指定的内存模式为SMALL，那么可通过如下命令把目标模块添加到SMALL模式的库CS.LIB中：
MASM /Zm /c /Cx A86A.ASM
TLIB CS.LIB + A86A.OBJ
如果欲把它添加到LARGE模式的库CL.LIB中，则可先把伪指令.MODEL指定的模式修改为LARGE，然后重新汇编它，最后发出如下命令：
TLIB CL.LIB + A86A.OBJ
8.6习题
题8.1在完整的段定义语句中，有三个可选项：定位类型、组合类型和类别。请简述它们的意义和作用。
一个程序通常有若干个模块。一个模块通常有若干个段。
汇编语言中的段定义伪指令等指示汇编程序把合适的连接信息写入到目标模块中，连接程序再根据目标模块中的连接信息进行连接操作。
完整的段定义提供了彻底控制段的机制，该机制可使得各模块的各个段严格按要求组合和衔接。
完整段定义的一般格式如下：
段名 SEGMENT [定位类型][组合类型]['类别']
......
语句
......
段名 ENDS
可选项"定位类型"、"组合类型"和"'类别'"通知汇编程序和连接程序如何建立和组合段。
在同一模块中，如果已用相同的段名定义过段，那么当前这个段就被视为前一个同名段的继续，即同一个段。
定位类型
定位类型表示当前段对起始地址的要求，从而指示连接程序如何衔接相邻两段。
一般情况下（80386以下）缺省的定位类型是PARA，即段起始地址位于可用的第一个节（每节为16个字节）的边界处。
定位类型BYTE使得当前段紧接前一段，前后两段间没有空闲单元，所以是最节约的定位类型。
定位类型WORD使得段从偶地址开始，不仅较为节约，而且有利于把数据单元定位在偶地址。
定位类型DWORD常用于80386的32位段。一页等于256字节，所以定位类型PAGE可能导致最大的段间隔。
组合类型通知连接程序，如何把不同模块内段名相同的段组合到一起。
有如下组合类型：
（1）PUBLIC
组合类型PUBLIC表示当前段与其它模块中组合类型为PUBLIC的同名段组合成一个段。
组合的先后顺序取决于启动LINK程序时目标模块名排列的次序。组合时仍遵照定位类型进行衔接，即同名段间可能有间隔。
（2）COMMON
组合类型COMMON表示当前段与其它模块中的同名段重叠，即起始地址相同。最终段的长度等于它们中最长的段的长度。
（3）STACK
组合类型STACK表示当前段是堆栈段，将与其它模块中组合类型为STACK的堆栈段在连接时以接续的方式组合成一个存储空间更大的堆栈。
（4）MEMORY
组合类型MEMORY与组合类型PUBLIC相同，为兼容而设。
（5）AT 表达式
它表示当前段应按绝对地址定位，其段地址即为表达式之值。AT段一般用于表示已在内存中的代码或数据，
如显示缓冲区或其它由硬件定义的绝对存储单元。LINK程序不对AT段生成任何代码或数据。
（6）PRIVATE
组合类型PRIVATE表示不与其它段组合。宏汇编程序MASM不识别此关键字。
若段定义伪指令SEGMENT语句中没有给出组合类型，就表示不与其它段组合。
类别
类别表示当前段的分类。LINK程序总是使类别相同的段相邻。实际上只有类别相同的同名段才根据组合类型进行组合。
题8.2请编写简单的测试程序进一步理解上述可选项的意义。
；程序名：T8-2.ASM
；功能：（略）
DSEG SEGMENT PARA COMMON
MESS DB 'HELLO',0DH,0AH,'$'
DSEG ENDS
CSEG SEGMENT PARA PUBLIC
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESS
MOV AH,9
INT 21H
MOV AX,4C00H
INT 21H
CSEG ENDS
END START
；程序（模块）名：T8-3.ASM
；功能：（略）
DSEG SEGMENT PARA COMMON
DB 'OK'
DSEG ENDS
CSEG SEGMENT PARA PUBLIC
MOV AH,4CH
INT 21H
CSEG ENDS
END
把这两个源程序模块分别汇编，再用LINK程序连接，命令行如下：
LINK T8-2 + T8-3
模块2中的DSEG段和模块1中的DSEG段重叠，模块2中的CSEG段和模块1中的CSEG段合并成一个段。
最后得到的可执行程序的内容如下所示：
0000：0000 4F4B4C4C4F0D0A24 两个段重叠后的结果OKLLO..$
0000：0008 0000000000000000   CSEG的定位类型是PARA导致的间隔
0001：0000 MOV AX,26E2            模块T8-2中的CSEG段
0001：0003 MOV DS,AX
0001：0005 MOV DX,0000
0001：0008 MOV AH,09
0001：000A INT 21
0001：000C MOV AX,4C00
0001：000F INT 21
0001：0011 000000000000000000000000000000 衔接间隔
0001：0020 MOV AH,4C               模块T8-3中的CSEG段
0001：0022 INT 21
某个程序的模块1如下所示：
DSEG SEGMENT PARA PUBLIC 'DATA'
MESS DB 'HELLO',0DH,0AH,'$'
DSEG ENDS
CSEG SEGMENT PARA PUBLIC 'CODE'
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESS
MOV AH,9
INT 21H
MOV AX,4C00H
INT 21H
CSEG ENDS
END START
该程序的模块2如下所示：
DSEG SEGMENT PARA PUBLIC 'XYZ'
DB 'OK'
DSEG ENDS
ASEG SEGMENT PARA PUBLIC 'CODE'
MOV AH,4CH
INT 21H
ASEG ENDS
END
该程序的模块3如下所示：
ESEG SEGMENT PARA PUBLIC 'DATA'
DB 'WORLD'
ESEG ENDS
END
把这三个源程序模块分别汇编，再用如下命令连接它们的目标模块：
LINK MODULE1 + MODULE2 + MODULE3
在得到的可执行程序中，各段的排列次序是：模块1的DSEG、模块3的ESEG、模块1的CSEG、模块2的ASEG、模块2的DSEG。
题8.3请编写一个代码、数据和堆栈同段的演示程序。
一个完整的汇编语言源程序一般含有一个堆栈段，当把某个段的组合类型指定为STACK时，这个段就被指定为堆栈段了。
MASM允许一个汇编语言源程序不含有堆栈段。如果LINK程序没有发现堆栈段，那么它会发出警告信息，
并把第一个段的段值作为堆栈的段值，堆栈空间设定为64KB。
CSEG SEGMENT
ASSUME CS:CSEG,DS:CSEG
START:PUSH CS
POP DS
MOV BL,VAR1
MOV VAR2,BL
MOV AH,4CH
INT 21H
VAR1 DB 'A'
VAR2 DB 'B'
CSEG ENDS
END START
题8.4请举例说明段组的使用方法。
伪指令GROUP把源程序模块中若干不同名的段集合成一个组，并赋予一个组名。它的一般格式如下：
组名 GROUP 段名[,段名......]
其中，段名与段名间用逗号间隔，段名也可用由表达式"SEG 变量"或者表达式"SEG 标号"代替。
组名表示组，也代表组的起始地址。组名的使用与段名的使用类似。
段组名也可用在ASSUME语句中，表示使某个段寄存器与某个组相对应。
在定义段组后，段组内各段所定义的所有标号和变量除与定义它们的段起始点相关外还与组的起始点相关。
如果在ASSUME伪指令中使段寄存器与段组对应，那么有关标号或变量的地址就相对于段组起点计算。
如果在ASSUME伪指令中使段寄存器与组内某个段对应，那么有关标号或变量就相对于该段的起点计算。
数据段放在代码段前面
DS1S2 GROUP DSEG1,DSEG2
DSEG1 SEGMENT PARA PUBLIC
VAR1 DB 11H
DSEG1 ENDS
DSEG2 SEGMENT PARA PUBLIC
VAR2 DB 22H
DSEG2 ENDS
CSEG SEGMENT PARA PUBLIC
ASSUME CS:CSEG,DS:DS1S2
START:MOV AX,DS1S2
MOV DS,AX
MOV BL,VAR1
MOV VAR2,BL
ASSUME DS:DSEG2
MOV AX,DSEG2
MOV DS,AX
MOV VAR2,BL
MOV AH,4CH
INT 21H
CSEG ENDS
END START
数据段放在代码段后面
DS1S2 GROUP DSEG1,DSEG2
CSEG SEGMENT PARA PUBLIC
ASSUME CS:CSEG,DS:DS1S2
START:MOV AX,DS1S2
MOV DS,AX
MOV BL,VAR1
MOV VAR2,BL
ASSUME DS:DSEG2
MOV AX,DSEG2
MOV DS,AX
MOV VAR2,BL
MOV AH,4CH
INT 21H
CSEG ENDS
DSEG1 SEGMENT PARA PUBLIC
VAR1 DB 11H
DSEG1 ENDS
DSEG2 SEGMENT PARA PUBLIC
VAR2 DB 22H
DSEG2 ENDS
END START
把变量作为组的成员访问和把变量仅作为段内的成员访问。
DGROUP GROUP CSEG,DSEG
CSEG SEGMENT
ASSUME DS:DGROUP
START:MOV AX,DGROUP
MOV DS,AX
MOV BL,VAR1
MOV VAR2,BL
ASSUME DS:DSEG
MOV AX,DSEG
MOV DS,AX
MOV BH,VAR1
MOV VAR2,BH
MOV AH,4CH
INT 21H
CSEG ENDS
DSEG SEGMENT
VAR1 DB 'A'
VAR2 DB 'B'
DSEG ENDS
END START
连接后所得的可执行程序装入内存时的映象如下（设开始段值为26E2H）：
26E2 : 0000 MOV AX,26E2 CSEG段
26E2 : 0003 MOV DS,AX
26E2 : 0005 MOV BL,[0020]
26E2 : 0009 MOV [0021],BL
26E2 : 000D MOV AX,26E4
26E2 : 0010  MOV DS,AX
26E2 : 0012  MOV BH,[0000]
26E2 : 0016  MOV [0001],BH
26E2 : 001A MOV AH,4C
26E2 : 001C INT 21
26E2 : 001D 000000 段之间隔
26E2：0020 4142 DSEG段（即26E4：0）
如果要用运算符OFFSET得到在段组内某个段中定义的标号或变量相对于段组起始点的偏移，那么必须在标号或变量前再加上"组名:"。
例如，MOV DX,OFFSET DGROUP:VAR1，否则，只能得到相对于所在段起始点的偏移。
题8.5简化的段定义有何特点？请举例说明。
在程序中使用段简化定义伪指令之前，必须先使用存储模型说明伪指令描述程序采用的存储模型。存储模型说明伪指令的简单格式如下
.MODEL 存储模型
注意该伪指令以符号"."引导。例如，为了说明采用SMALL存储模型，只要在源程序首使用如下伪指令
.MODEL SMALL
存储模型决定子程序调用、指令转移和数据访问的缺省属性（NEAR或FAR）。
常用的存储模型有：
（1）SMALL
全部数据限制在一个64KB段内，全部代码也限制在另一个64KB段内。这是独立的汇编语言程序最常用的模型。
（2）MEDIUM
全部数据限制在一个64KB段内，全部代码可大于64KB。代码大于64KB时，有多个代码段。
（3）COMPACT
全部代码限制在一个64KB段内，全部数据可大于64KB。数据大于64KB时，有多个数据段。单个数据项不能大于64KB。
（4）LARGE
全部代码可大于64KB，全部数据可大于64KB。代码大于64KB时，有多个代码段。数据大于64KB时，有多个数据段。单个数据项不能大于64KB。
（5）HUGE
全部代码可大于64KB，全部数据可大于64KB。代码大于64KB时，有多个代码段。数据大于64KB时，有多个数据段。单个数据项可以大于64KB。
简化的段定义伪指令均以符号"."引导。下面介绍常用的简化段定义伪指令：
（1）定义代码段的伪指令
定义代码段的伪指令如下，它表示一个代码段的开始：
.CODE [段名]
段名为可选项，如不给出段名，则采用默认段名。
如果有多个代码段，则应为每个代码段指定段名。
例如：一个使系统喇叭发出“嘟”一声的程序。
；程序名：T8-6.ASM
；功能：（略）
.MODEL SMALL
.CODE
START:MOV DL,7
MOV AH,2
INT 21H
MOV AX,4C00H
INT 21H
END START
伪指令.CODE说明代码段的开始，伪指令END说明整个程序所有段的结束。
简化的段定义伪指令说明一个段的开始，同时也表示上一个段的结束。
（2）定义堆栈段的伪指令
定义堆栈段的伪指令一般格式如下，它表示一个堆栈段的开始：
.STACK [大小]
可选的"大小"说明堆栈的字节数，若没有指定堆栈大小，则采用缺省值1024。
如下的伪指令就表示定义一个2KB的堆栈。
.STACK 2048
（3）定义数据段的伪指令
定义数据段的伪指令如下，它表示数据段的开始：
.DATA
例如：如下伪指令定义了一个数据段：
.DATA
VAR3 DB 5
IARRAY DW 50 DUP (0)
MESS DB 'HELLO',0DH,0AH,'$'
例如：利用简化的段定义伪指令改写8.1.2节的程序T8-1A.ASM。
；程序名：T8-1B.ASM
；功能：（略）
.MODEL SMALL
.STACK 1024
.DATA
MESS DB 'HELLO',0DH,0AH,'$'
.CODE
START:MOV AX,DGROUP
MOV DS,AX
MOV DX,OFFSET MESS
MOV AH,9
INT 21H
MOV AX,4C00H
INT 21H
END START
在一个源程序模块中可定义多个由伪指令.DATA开始的数据段，这如同在一个源程序模块中定义多个同名的数据段。
宏汇编程序自动把可能存在的由.DATA说明的数据段、由.CONST说明的常数数据段、
由.DATA?说明的未初始化数据段和由.STACK说明的堆栈段集合成一个段组DGROUP。
（4）定义远程（独立）数据段的伪指令
定义独立数据段伪指令的一般格式如下，它表示一个独立数据段的开始：
.FARDATA [名字]
"名字"是可选的，如果使用，则就成为该数据段的段名。
例如：如下伪指令定义了一个独立的数据段：
.FARDATA
NEWPTR DD 0
BUFF DB 1024 DUP (?)
表8.2列出了在SMALL存储模型下，各段的段名等信息。
伪指令          段名             定位类型           组合类型       类别               组名
.CODE          _TEXT          WORD             PUBLIC          'CODE'
.FARDATA   FAR_DATA  PARA               PRIVATE        'FAR_DATA'
.FARDATA? FAR_BSS      PARA               PRIVATE        'FAR_BSS'
.DATA         _DATA         WORD             PUBLIC          'DATA'           DGROUP
.CONST       CONST        WQRD             PUBLIC          'CONST'        DGROUP
.DATA?       _BSS             WORD             PUBLIC          'BSS'              DGROUP
.STACK       STACK          PARA               STACK           'STACK'         DGROUP
如果在中型、大型或巨型模式下，由伪指令.CODE说明的代码段的段名在字符串"_TEXT"之前还会加上模块名（源文件名）。
例如，设模块名为ABC，则代码段名就成为ABC_TEXT。因此，如果使用中大型内存模式，那么模块源文件名不要以数字开头。
如果在使用伪指令.FARDATA说明一个独立的数据段时加了名字，那么此名字就成为该独立数据段的段名。
存储模型说明伪指令.MODEL除了说明程序采用的存储模型外，还起着相当于如下语句的作用：
DGROUP GROUP _DATA,CONST,_BSS,STACK
ASSUME CS:_TEXT,DS:DGROUP,SS:DGROUP
它指示汇编程序把可能有的段_DATA、段CONST、段_BSS和段STACK集合成一个名为DGROUP的段组，
同时指示汇编程序把数据段寄存器DS和堆栈段寄存器SS与段组DGROUP对应，使代码段寄存器CS与代码段对应。
注意，在中型、大型模式下，代码段的段名不再是_TEXT。
由于伪指令.MODEL的上述隐含动作，所以在使用伪指令.MODEL后，可以直接引用段组DGROUP，
而且多数情况下也可以不使用伪指令ASSUME，上面的程序T8-1B.ASM就是一例。
但在少数情况下，程序仍需要安排ASSUME语句来指示段寄存器与段的对应关系。
例如：下列代码设置DS，使它依次对应.DATA段、.CODE段、.FARDATA段，最后又对应.DATA段：
......
.DATA
......
.FARDATA
......
.CODE
MOV AX,@DATA
MOV DS,AX
ASSUME DS:@DATA
......
MOV AX,@CODE
MOV DS,AX
ASSUME DS:@CODE
......
MOV AX,@FARDATA
MOV DS,AX
ASSUME DS:@FARDATA
......
MOV AX,@DATA
MOV DS,AX
ASSUME DS:@DATA
......
在上述程序片段中使用的符号@CODE等是汇编程序提供的若干预定义符。它们类似于用伪指令EQU所定义的符号。
与简化的段定义伪指令相关的一些预定义符号有：
（1）符号@CODE表示代码段的段名。
（2）符号@DATA表示由.DATA段和.STACK段等集合而成段组的组名。
（3）符号@FARDATA表示独立数据段的段名。
题8.6请简述汇编语言程序设计时，模块间的通信方法。
一个程序通常有若干个模块，各个模块在功能上是有联系的。比如，模块甲调用模块乙内的过程，模块乙访问模块甲内的数据。
由于各模块被单独汇编，所以，如果模块甲要按符号名调用或访问在其他模块内定义的某个过程或变量，
那么，模块甲必须告诉汇编程序此指定符号名（标识符）在别的模块内定义，
否则，在汇编模块甲时，汇编程序会给出"符号未定义"这类汇编出错信息。
另一方面，如果在模块乙内定义的过程或变量准备供其他模块调用或访问，那么，模块乙也必须通知汇编程序，
否则，汇编程序不会把相应的标识符保存到目标程序中去，最终导致连接失败。
伪指令EXTRN和伪指令PUBLIC就是分别用于通知汇编程序上述两种信息。
伪指令PUBLIC用于声明在当前模块内定义的某些标识符是公共标识符，即可供其他模块使用的标识符。它的一般格式如下所示：
PUBLIC 标识符[,标识符......]
上述语句中位于助记符PUBLIC之后的"标识符"就是要声明的公共标识符。一条PUBLIC语句可声明多个这样的标识符，标识符间用逗号分隔。
一个源程序模块内可使用多条PUBLIC语句。数据变量名和程序标号（包括过程名）均可声明为公用标识符。
例如：声明VAR1、VAR2和DELAY为可供其它模块使用的公共标识符
.MODEL SMALL
PUBLIC VAR1,VAR2
PUBLIC DELAY
.DATA
VAR1 DW ?
VAR2 DB ?
VAR3 DB 5 DUP (0)
.CODE
DELAY PROC
LAB1:RET
DELAY ENDP
END
由于没有声明VAR3和LAB1为公共标识符，所以其它模块不能使用这两个标识符。
伪指令EXTRN用于声明当前模块使用的哪些标识符在其他模块内定义。它的一般格式如下所示：
EXTRN 标识符:类型[,标识符:类型......]
上述语句中位于助记符EXTRN后的每一项"标识符:类型"声明一个在其他模块内定义的标识符。
汇编程序为了产生合适的代码或保留恰当的存储单元，要求在声明标识符的同时指出其类型属性，"标识符"和"类型"之间用冒号分隔。
类型可以是NEAR、FAR或者BYTE、WORD、DWORD等标识符类型属性。
一条EXTRN语句可声明多个这样的标识符，每项之间用逗号分隔。一个源程序模块内可使用多条EXTRN语句。
例如：声明VAR1、VAR2和DELAY为在其它模块定义的标识符
EXTRN DELAY:NEAR
EXTRN VAR1:WORD,VAR2:BYTE
注意：把EXTRN伪指令安排在段的里面与段的外面是有区别的。
如果EXTRN伪指令出现在某个段内，表示所声明的标识符虽在其它模块内，但却在同一个段内。
如果EXTRN伪指令田现在段外，那么表示不知道所声明的标识符在哪一个段内被定义。
各模块内的PUBLIC语句和EXTRN语句必须互相呼应，互相一致。
凡是由PUBLIC语句声明的标识符，应该是其它模块的EXTRN语句中用到的标识符；
反之，凡是由EXTRN语句声明的标识符必须在将要连接在一起的其它模块的PUBLIC语句中找到，而且所指明的类型必须一致。
如果不遵守这些原则，就不能正确连接成功。
不同模块间过程调用时的参数传递有多种方法，少量参数可利用寄存器传递或利用堆栈传递，
大量参数可先组织在一个缓冲区中，然后利用寄存器或堆栈传递相应的指针。
如果要利用约定的存储单元传递参数，情形稍稍复杂些，需要把它们声明为公共标识符。
例如：一个显示DOS版本号的程序。
程序分成两个模块，主模块有一个数据段和一个代码段，从模块只含有两个子程序。
；程序名：T8-8.ASM
；功能：演示模块间的利用寄存器和约定存储单元传递信息
DSEG SEGMENT PUBLIC 'DATA'
MESS DB 'DOS Version is'
MESS1 DB ?
DB '.'
MESS2 DB 2 DUP (?)
DB 0DH,0AH,'$'
VERM DB 0
VERN DB 0
DSEG ENDS
PUBLIC VERM,VERN
EXTRN GETVER:FAR,TODASC:FAR
CSEG SEGMENT PUBLIC 'CODE'
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL FAR PTR GETVER
MOV AL,VERM
MOV BX,1
MOV SI,OFFSET MESS1
CALL FAR PTR TODASC
MOV AL,VERN
MOV BX,2
MOV SI,OFFSET MESS2
CALL FAR PTR TODASC
MOV DX,OFFSET MESS
MOV AH,9
INT 21H
MOV AX,4C00H
INT 21H
CSEG ENDS
END START
；模块名：T8-8MA.ASM
；功能：作为程序T8-8.ASM的模块
PUBLIC GETVER,TODASC
EXTRN VERM:BYTE,VERN:BYTE
FUNC SEGMENT PUBLIC 'CODE'
ASSUME CS:FUNC
GETVER PROC FAR
MOV AH,30H
INT 21H
MOV VERM,AL
MOV VERN,AH
RETF
GETVER ENDP
TODASC PROC FAR
MOV CL,10
TOASC1:XOR AH,AH
DIV CL
ADD AH,30H
MOV [SI+BX-1],AH
DEC BX
JNZ TOASC1
RETF
TODASC ENDP
FUNC ENDS
END
子程序GETVER把DOS的版本号直接填入在主模块中约定的单元VERM和VERN中。
子程序TODASC的入口参数由寄存器传递，转换得到的十进制数ASCII码串直接写到主模块的指定缓冲区中。
这两个子程序均被定义为远过程。在访问定义在其他模块的变量前，必须保证已设置好相应的段寄存器。
模块间传递信息的另一个方法是利用段覆盖，这个方法只适用于模块间传递信息。
具体方法是：在两个模块中都定义一个同名同类别数据段，规定段组合类型是COMMON；
把要传递的数据（变量）安排在这两个数据段的相同位置上。由于这两个在不同模块中的数据段同名同类别，且组合类型是COMMON，
所以连接时它们就发生重叠。
例如：一个按照年-月-日显示当前系统日期的程序。
程序分成两个模块，主模块有一个代码段和一个数据段，从模块也有一个代码段和数据段。
；程序名：T8-9A.ASM
：功能：演示利用段覆盖方法在模块间传递信息
EXTRN GETDATE:FAR
DSEG SEGMENT COMMON 'DATA'
MESS DB 'Current date is '
MESSY DB 4 DUP (?)
DB '-'
MESS1 DB 2 DUP (?)
DB '-'
MESS2 DB 2 DUP (?)
DB 0DH,0AH,24H
DSEG ENDS
CSEG SEGMENT PUBLIC 'CODE'
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL FAR PTR GETDATE
MOV DX,OFFSET MESS
MOV AH,9
INT 21H
MOV AX,4C00H
INT 21H
CSEG ENDS
END START
；模块名：T8-9AMA.ASM
；功能：作为T8-9A.ASM的一部分
PUBLIC GETDATE
DSEG SEGMENT COMMON 'DATA'
MESS DB 'Current date is '
MESSY DB 4 DUP (?)
DB '-'
MESS1 DB 2 DUP (?)
DB '-'
MESS2 DB 2 DUP (?)
DB 0DH,0AH,24H
YEAR DW ?
MONTH DB ?
DAY DB ?
DSEG ENDS
CSEG SEGMENT BYTE PUBLIC 'CODE'
ASSUME CS:CSEG,DS:DSEG
GETDATE PROC FAR
MOV AH,2AH
INT 21H
MOV YEAR,CX
MOV MONTH,DH
MOV DAY,DL
MOV AX,YEAR
MOV DX,0
MOV BX,4
MOV SI,OFFSET MESSY
CALL TODASC
MOV AL,MONTH
MOV AH,0
MOV DX,0
MOV BX,2
MOV SI,OFFSET MESS1
CALL TODASC
MOV AL,DAY
MOV AH,0
MOV DX,0
MOV BX,2
MOV SI,OFFSET MESS2
CALL TODASC
RETF
GETDATE ENDP
DIVDW PROC NEAR
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
TODASC PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
CMP DX,0
JNZ TODASC1
CMP AX,0
JNZ TODASC1
CMP BX,0
JZ TODASC_OK
TODASC_S1:MOV BYTE PTR [SI+BX-1],'0'
DEC BX
JNZ TODASC_S1
JMP TODASC_OK
TODASC1:CMP BX,0
JZ TODASC_OK
divide_TODASC:cmp dx,0
jz finish_s_TODASC1
divide_s_TODASC:mov cx,10
call divdw
add cx,30h
MOV BYTE PTR [SI+BX-1],CL
DEC BX
jmp divide_TODASC
finish_s_TODASC1:cmp ax,0
jz finish_TODASC
jmp divide_s_TODASC
finish_TODASC:CMP BX,0
JZ TODASC_OK
TODASC_S2:MOV BYTE PTR [SI+BX-1],'0'
DEC BX
JNZ TODASC_S2
TODASC_OK:POP DX
POP CX
POP BX
POP AX
RET
TODASC ENDP
CSEG ENDS
END
模块T8-9MA中的数据段比模块T8-9.ASM中的数据段多了若干变量，在段覆盖时，以最长的段为段的最后实际长度。
但必须注意，要传递的数据变量必须安排在相同的位置。由于模块T8-9MA中含有要访问的数据段，
所以过程GETDATE能够随便地访问想要访问的对象。
题8.7如何实现模块之间的转移？请举例说明。
模块甲调用定义在模块乙内的某个过程，通常是以过程调用及返回的形式出现，但有时这种转移也直接采用转移指令的形式。
若两个模块涉及转移的代码段在连接后不能组合为一个代码段，那么应该使用远调用或远转移，否则可以使用近调用或近转移。
例如：有如下三个模块，主模块中代码段的段名是CSEG，两个从模块中代码段的段名是TEXT
；程序名：T8-7.ASM
；功能：演示模块间的转移
EXTRN SUB1:FAR
CSEG SEGMENT PARA PUBLIC 'CODE'
ASSUME CS:CSEG
START:CALL FAR PTR SUB1
MOV AX,4C00H
INT 21H
CSEG ENDS
END START
；模块名：T8-7MA.ASM
；功能：作为程序T8-7的一个模块
PUBLIC SUB1
EXTRN SUB2:NEAR
TEXT SEGMENT PARA PUBLIC 'CODE'
ASSUME CS:TEXT
SUB1 PROC FAR
MOV DL,'*'
MOV AH,2
INT 21H
CALL SUB2
RETF
SUB1 ENDP
TEXT ENDS
END
；模块名：T8-7MB.ASM
：功能：作为程序T8-7的一个模块
PUBLIC SUB2
TEXT SEGMENT PARA PUBLIC 'CODE'
ASSUME CS:TEXT
SUB2 PROC NEAR
MOV DL,'+'
MOV AH,2
INT 21H
RET
SUB2 ENDP
TEXT ENDS
END
由于主模块中代码段的段名和从模块中代码段的段名不同，所以连接时不能组合成一个段，
因此过程SUB2被定义成远过程，在主模块中也相应地声明为FAR类型。
由于，两个从模块中代码段的段名和段的类别相同，而且组合类型为PUBLIC，所以，在连接时它们能被组合成一个段。
再由于，只有过程SUB1调用过程SUB2，即只有段内调用，因此过程SUB2被定义为近过程，在对应模块中也声明为NEAR类型。
可用如下命令把它们的三个目标模块连接到一起：
LINK T8-7 + T8-7MA + T8-7MB
如果主模块也要调用过程SUB2，那么应该把SUB2也定义为远过程。
题8.8何为子程序库？请简述子程序库的作用。
把常用子程序的源代码按照模块化程序设计方法，分成不同的子程序模块。
然后汇编这些子程序模块的源程序文件，得到子程序模块目标文件。
子程序库是子程序模块的集合。库文件中存放着子程序的名称，子程序的目标代码，以及连接过程所必需的重定位信息。
完成某个具体任务的程序只要把所需调用子程序声明为在其他模块内定义，那么就能通过汇编，生成目标文件。
当目标文件与库相连接时，LINK程序只把目标文件所需要的子程序从库中找出来，并嵌入到最终的可执行程序中去，
而不是把库内的全部子程序统统嵌入到可执行程序。
题8.9如何建立子程序库？
为了给调用者提供方便，库中的子程序应该提供统一的调用方法，所以需要遵守如下约定：
（1）参数传递方法保持统一。
（2）过程类型保持相同，即都为远过程或都为近过程。
请特别注意，如果过程类型选择NEAR，那么必须保证在连接时调用者所在段能与子程序所在段组合成一个段，
为此，调用者所在段的段名和类别应该与子程序所在段的段名和类别相同，且组合类型同为PUBLIC。
（3）采用一致的寄存器保护措施和可能需要的堆栈平衡措施。
（4）子程序名称规范。
建立子程序库的一般步骤如下：
（1）确定库所含子程序的范围，即库准备包含哪些子程序。
（2）确定参数传递方法。
（3）确定子程序类型，还确定子程序所在段的段名、定位类型、组合类型和类别。
（4）确定寄存器保护措施等其他内容。
（5）利用专门的库管理工具程序，把经过调试的子程序目标模块逐一加入到库中。
下面我们来建立一个子程序库，它包含若干数制转换子程序目标模块。
为了方便地使库中各子程序目标模块所在的段相同，在编写各子程序模块源程序时，采用简化的段定义，并把存储模型定为SMALL；
但子程序类型规定为FAR，即均为远过程，于是，调用模块只要把欲调用的子程序声明为在其它模块内定义，且类型为FAR即可，
而无需考虑是否能与被调用的子程序模块组合成同一个段。此外，还作如下约定：采用寄存器传递出入口参数；
各子程序除了可能破坏AX、BX、CX和DX四个寄存器的内容外，保护其他寄存器的内容。
例如：编写一个把二进制数转换为对应十进制数ASCII码串的子程序，并把它添加到名为BDHL.LIB的库中。
；源文件名：T8L1.ASM
；功能：（略）
PUBLIC BDASCS
.MODEL SMALL
.CODE
BDASCS PROC FAR
PUSH SI
MOV SI,DX
MOV CX,5
MOV BX,10
BDASCS_S1:XOR DX,DX
DIV BX
ADD DL,30H
MOV BYTE PTR [SI+4],DL
DEC SI
LOOP BDASCS_S1
POP SI
RETF
BDASCS ENDP
END
设源程序存放在文件T8L1.ASM中，可利用如下命令汇编成目标模块且添加到库BDHL.LIB中去：
MASM T8L1.ASM
LIB BDHL.LIB + T8L1.OBJ
例如：编写一个把二进制数转换为对应十六进制数ASCII码串的子程序，并把它添加到名为BDHL.LIB的库中。
；源文件名：T8L2.ASM
；功能：（略）
PUBLIC BHASCS
.MODEL SMALL
.CODE
HTOASC PROC NEAR
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
RET
HTOASC ENDP
BHASCS PROC FAR
PUSHF
PUSH DI
PUSH ES
CLD
PUSH DS
POP ES
MOV DI,DX
MOV CX,0404H
BHASCS_S1:ROL AX,CL
MOV DX,AX
CALL HTOASC
STOSB
MOV AX,DX
DEC CH
JNZ BHASCS_S1
POP ES
POP DI
POPF
RETF
BHASCS ENDP
END
子程序BHASCS调用HTOASC实现把一位十六进制数转换为对应ASCII码，但由于没有把标识符HTOASC声明为公共标识符，
所以它不能供其它程序调用。由于子程序HTOASC与子程序BHASCS在同一个模块，且只供BHASCS调用，所以采用类型NEAR。
子程序HTOASC的代码始终伴随着子程序BHASCS，当某个程序需要连入子程序BHASCS时，子程序HTOASC也被连入。
设源程序存放在文件T8L2.ASM中，可利用如下命令把它汇编成目标模块且添加到库中去：
MASM T8L2.ASM
LIB BDHL.LIB + T8L2.OBJ
8.4.3使用举例
下面我们举例说明如何利用子程序库。
添加模块到库中
LIB YourLib.LIB + YourMod.OBJ ；
如果模块已存在于库中，将其替换为新的模块 
LIB YourLib.LIB -+ NewMod.OBJ ；
从库中移除模块
LIB YourLib.LIB - YourMod;
例如：一个显示16H号中断向量的程序。
使用简单的段定义方式，存储模型定为SMALL。实现算法是：取有关中断向量；再调用已建立的库BDHL.LIB中的子程序BHASCS，
把向量值转换为对应十六进制数的ASCII码串；最后显示ASCII码串。
；程序名：T8-10.ASM
；功能：（略）
.MODEL SMALL
.STACK 1024
.DATA
MESS LABEL BYTE
MESS1 DB 4 DUP (0)
DB ':'
MESS2 DB 4 DUP (0)
DB 0DH,0AH,24H
.CODE
EXTRN BHASCS:FAR
START:MOV AX,@DATA
MOV DS,AX
MOV AX,3516H
INT 21H
PUSH BX
MOV AX,ES
MOV DX,OFFSET MESS1
CALL FAR PTR BHASCS
POP AX
MOV DX,OFFSET MESS2
CALL FAR PTR BHASCS
MOV DX,OFFSET MESS
MOV AH,9
INT 21H
MOV AX,4C00H
INT 21H
END START
例如：一个显示系统常规内存量的程序。
0040:0013   2个字节 Total memory in K-bytes (same as obtained via INT 12H)
系统常规内存量存放在内存单元0040:0013H的字单元中，以KB为单位。
实现算法是：先从0040:0013H单元中取得内存量；再调用库BDHL.LIB中的子程序BDASCS，
把以二进制数形式表示的内存量转换为对应十进制数的ASCII码串；最后显示之。程序采用完整的段定义方式。
；程序名：T8-11.ASM
：功能：（略）
EXTRN BDASCS:FAR
SSEG SEGMENT STACK 'STACK'
DB 400H DUP (0)
SSEG ENDS
CSEG SEGMENT PUBLIC
MESS DB 'Total = '
MESS1 DB 5 DUP (0)
DB 'KB',0DH,0AH,24H
ASSUME CS:CSEG,DS:CSEG
START:PUSH CS
POP DS
MOV AX,0040H
MOV ES,AX
MOV AX,ES:[0013H]
MOV DX,OFFSET MESS1
CALL FAR PTR BDASCS
MOV DX,OFFSET MESS
MOV AH,9
INT 21H
MOV AX,4C00H
INT 21H
CSEG ENDS
END START
题8.10请谈谈连接程序的功能。
汇编语言中的段定义伪指令等指示汇编程序把合适的连接信息写入到目标文件中，
连接程序再根据目标文件中的连接信息，将目标文件以及静态库文件等组合起来得到一个可执行程序。
当目标文件与静态库相连接时，连接程序只把目标文件所需要的子程序从静态库中找出来，并嵌入到最终的可执行程序中去。
连接程序按照命令行参数从左到右的顺序来扫描目标文件、静态库，因此目标文件以及静态库出现的顺序十分重要。
为了能够编写出可供Turbo C调用的函数，应了解Turbo C模块与汇编模块的接口机制，而从以汇编形式给出的编译结果中可方便地了解这种机制。
设有如下C程序：
int Sum(int, int, int);
int xxx = 5;
int yyy;
main()
{
    yyy = Sum(1, xxx, 3);
    printf("%d\n", yyy);
}
int Sum(int i, int j, int m)
{
    return (i + j + m);
}
用下面的命令要求Turbo C按SMALL模式编译TC8.C，并以汇编格式输出编译结果：
TCC -ms -S TC8.C
以汇编格式输出的编译结果保存在文件TC8.ASM中，尽管该文件比较冗长，但阅读和理解它对编写供Turbo C调用的汇编函数是有帮助的，
而且对学习C语言也是有益的。TC8.ASM的主要内容如下所示（已删去空段和注释等次要内容）：
_TEXT	segment	byte public 'CODE'
DGROUP	group	_DATA,_BSS
	assume	cs:_TEXT,ds:DGROUP,ss:DGROUP
_TEXT	ends
_DATA	segment word public 'DATA'
_xxx	label	word
	dw	5
_DATA	ends
_TEXT	segment	byte public 'CODE'
_main	proc	near
	mov	ax,3
	push	ax
	push	word ptr DGROUP:_xxx
	mov	ax,1
	push	ax
	call	near ptr _Sum
	add	sp,6
	mov	word ptr DGROUP:_yyy,ax
	push	word ptr DGROUP:_yyy
	mov	ax,offset DGROUP:s@
	push	ax
	call	near ptr _printf
	pop	cx
	pop	cx
@1:	ret	
_main	endp
_Sum	proc	near
	push	bp
	mov	bp,sp
	mov	ax,word ptr [bp+4]
	add	ax,word ptr [bp+6]
	add	ax,word ptr [bp+8]
	jmp	short @2
@2:	pop	bp
	ret	
_Sum	endp
_TEXT	ends
_BSS	segment word public 'BSS'
_yyy	label	word
	db	2 dup (?)
_BSS	ends
_DATA	segment word public 'DATA'
s@	label	byte
	db	37
	db	100
	db	10
	db	0
_DATA	ends
_TEXT	segment	byte public 'CODE'
	extrn	_printf:near
_TEXT	ends
	public	_yyy
	public	_xxx
	public	_main
	public	_Sum
	end
从上面以汇编格式给出的编译结果中，可以看到函数Sum除包含一条多余的跳转指令外，已足够精练。
但为了方便地说明如何编写供Turbo C调用的函数，我们仍然假设希望把上述C函数Sum改写成汇编函数。相应地，C程序TC8.C改写如下：
extern Sum(int, int, int);
int xxx = 5;
int yyy;
main ()
{
    yyy = Sum(1, xxx, 3);
    printf("%d\n", yyy);
}
以汇编格式输出编译结果，其中的主要内容如下所示（已删去空段和注释等次要内容）
_TEXT	segment	byte public 'CODE'
DGROUP	group	_DATA,_BSS
	assume	cs:_TEXT,ds:DGROUP,ss:DGROUP
_TEXT	ends
_DATA	segment word public 'DATA'
_xxx	label	word
	dw	5
_DATA	ends
_TEXT	segment	byte public 'CODE'
_main	proc	near
	mov	ax,3
	push	ax
	push	word ptr DGROUP:_xxx
	mov	ax,1
	push	ax
	call	near ptr _Sum
	add	sp,6
	mov	word ptr DGROUP:_yyy,ax
	push	word ptr DGROUP:_yyy
	mov	ax,offset DGROUP:s@
	push	ax
	call	near ptr _printf
	pop	cx
	pop	cx
@1:
	ret	
_main	endp
_TEXT	ends
_BSS	segment word public 'BSS'
_yyy	label	word
	db	2 dup (?)
_BSS	ends
_DATA	segment word public 'DATA'
s@	label	byte
	db	37
	db	100
	db	10
	db	0
_DATA	ends
_TEXT	segment	byte public 'CODE'
	extrn	_printf:near
	extrn	_Sum:near
_TEXT	ends
	public	_yyy
	public	_xxx
	public	_main
	end
程序CA8.C与TC8.C的区别是不再定义函数Sum，而声明它在其他模块内定义。下面就介绍如何编写包含函数Sum的汇编模块。
.MODEL SMALL
.CODE
PUBLIC _Sum
_Sum PROC
......
......
_Sum ENDP
END
；模块名：A8.ASM
；内容：含一个供CA8.C调用的函数Sum
.MODEL SMALL
.CODE
PUBLIC _Sum
PARM1 EQU [BP+4]
PARM2 EQU [BP+6]
PARM3 EQU [BP+8]
_Sum PROC
PUSH BP
MOV BP,SP
MOV AX,PARM1
ADD AX,PARM2
ADD AX,PARM3
POP BP
RET
_Sum ENDP
END
通过下面的命令能够完成对CA8.C的编译、对A8.ASM的汇编，最后再连接到一起：
TCC -ms -c CA8.C
MASM /Zm /c /Cx A8.ASM
LINK c0s.obj + CA8.obj + A8.OBJ
Run file : CA8.exe
Libraries : CS.lib
上述最后连接命令中的c0s.obj和CS.lib分别是Turbo C的SMALL模式下的启动代码目标模块文件和函数库文件。
必须注意，上面的汇编模块A8.OBJ只能与按SMALL模式编译的C模块CA8.obj相连接。
例如：一个求若干16位有符号数之和的汇编语言函数。它有两个入口参数，其一是数组的元素个数，其二是指向数组的指针。
它的返回值是一个32位有符号数。在C模块中说明的原型格式是：
extern long niadd(int *,int);
适用于SMALL模式编译的C模块相连的汇编模块如下所示：
；模块名：A86.ASM
；功能：（略）
. MODEL SMALL
PARM STRUC
REGBP DW ?
RETADDR DW ?
POINTER DW ?
COUNT DW ?
PARM ENDS
. CODE
PUBLIC _niadd
_niadd PROC NEAR
PUSH BP
MOV BP,SP
PUSH SI
PUSH DI
CLD
MOV SI,[BP].POINTER
MOV CX.[BP].COUNT
XOR BX,BX
MOV DI,BX
niadd_S1:LODSW
CWD
ADD BX,AX
ADC DI,DX
LOOP niadd_S1
MOV DX,DI
MOV AX,BX
POP DI
POP SI
POP BP
RET
_niadd ENDP
END
调用上述函数的一个Turbo C程序如下所示：
extern long niadd(int *, int);
int buffer[6] = {12345, 10000, -20000, 23456, -2345, -56};
main()
{
    long x;
    x = niadd(buffer, 6);
    printf("x=%ld\n", x);
}
以汇编格式输出编译结果，其中的主要内容如下所示（已删去空段和注释等次要内容）
_TEXT	segment	byte public 'CODE'
DGROUP	group	_DATA,_BSS
	assume	cs:_TEXT,ds:DGROUP,ss:DGROUP
_TEXT	ends
_DATA	segment word public 'DATA'
_buffer	label	word
	dw	12345
	dw	10000
	dw	-20000
	dw	23456
	dw	-2345
	dw	-56
_DATA	ends
_TEXT	segment	byte public 'CODE'
_main	proc	near
	push	bp
	mov	bp,sp
	sub	sp,4
	mov	ax,6
	push	ax
	mov	ax,offset DGROUP:_buffer
	push	ax
	call	near ptr _niadd
	pop	cx
	pop	cx
	mov	word ptr [bp-2],dx
	mov	word ptr [bp-4],ax
	push	word ptr [bp-2]
	push	word ptr [bp-4]
	mov	ax,offset DGROUP:s@
	push	ax
	call	near ptr _printf
	add	sp,6
@1:
	mov	sp,bp
	pop	bp
	ret	
_main	endp
_TEXT	ends
_DATA	segment word public 'DATA'
s@	label	byte
	db	120
	db	61
	db	37
	db	108
	db	100
	db	10
	db	0
_DATA	ends
_TEXT	segment	byte public 'CODE'
	extrn	_printf:near
	extrn	_niadd:near
_TEXT	ends
	public	_buffer
	public	_main
	end
通过下面的命令能够完成对t428.c的编译、对t429.ASM的汇编，最后再连接到一起：
TCC -ms -c t428.C
MASM /Zm /c /Cx t429.ASM
LINK c0s.obj + t428.obj + t429.OBJ
Run file : t428.exe
Libraries : CS.lib
上述最后连接命令中的c0s.obj和CS.lib分别是Turbo C的SMALL模式下的启动代码目标模块文件和函数库文件。
必须注意，上面的汇编模块t429.OBJ只能与按SMALL模式编译的C模块t428.obj相连接。
执行结果
x=23400
题8.11请用BC或TC编写一个显示内存单元内容的小型实用程序。显示过程用汇编语言编写。
t434.c
extern DisMem();
main()
{
    DisMem();
}
t433.asm
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
.MODEL SMALL
.DATA
DIS_BUF DB 128 DUP (0)
GET_BUF DB 16 DUP (0)
ARRAY_SEG DW 0
ARRAY_OFF DW 0
ARRAY_LEN DW 0
DIS_LEN DW 0
MESS_SEG DB 'SEGMENT:$'
MESS_OFF DB 'OFFSET:$'
MESS_LEN DB 'LENGTH:$'
MUL_TABLE DW 1,10,100,1000,10000
SHL_TABLE DB 0,4,8,12
RES_AX DW 0
NUM_DX DW 0
NUM_CX DW 0
NUM_BX DW 0
NUM_AX DW 0
.CODE
PUBLIC _DisMem
_DisMem PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
MOV AX,DGROUP
MOV DS,AX
MOV DX,OFFSET DGROUP:MESS_SEG
CALL DISPMESS
MOV DI,OFFSET DGROUP:GET_BUF
CALL GETSTRH
MOV SI,OFFSET DGROUP:GET_BUF
ADD SI,2
MOV CX,WORD PTR DGROUP:GET_BUF
SUB CX,2
CALL HTOBIN
MOV AX,WORD PTR DGROUP:RES_AX
MOV WORD PTR DGROUP:ARRAY_SEG,AX
MOV DX,OFFSET DGROUP:MESS_OFF
CALL DISPMESS
MOV DI,OFFSET DGROUP:GET_BUF
CALL GETSTRH
MOV SI,OFFSET DGROUP:GET_BUF
ADD SI,2
MOV CX,WORD PTR DGROUP:GET_BUF
SUB CX,2
CALL HTOBIN
MOV AX,WORD PTR DGROUP:RES_AX
MOV WORD PTR DGROUP:ARRAY_OFF,AX
MOV DX,OFFSET DGROUP:MESS_LEN
CALL DISPMESS
MOV DI,OFFSET DGROUP:GET_BUF
CALL GETSTRD
MOV SI,OFFSET DGROUP:GET_BUF
ADD SI,2
MOV CX,WORD PTR DGROUP:GET_BUF
SUB CX,2
CALL DTOBIN
MOV AX,WORD PTR DGROUP:RES_AX
MOV WORD PTR DGROUP:ARRAY_LEN,AX
MOV AX,DGROUP:ARRAY_SEG
MOV ES,AX
MOV AX,DGROUP:ARRAY_OFF
MOV DI,AX
MOV CX,DGROUP:ARRAY_LEN
CALL DISARRAY
POP ES
POP DS
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
_DisMem ENDP
ISHEX PROC
CMP AL,'0'
JB ISHEX_NOHEX
CMP AL,'9'
JA ISHEX_NODEC1
CLC
JMP ISHEX_OK
ISHEX_NODEC1:CMP AL,'A'
JB ISHEX_NOHEX
CMP AL,'F'
JA ISHEX_NODEC2
CLC
JMP ISHEX_OK
ISHEX_NODEC2:CMP AL,'a'
JB ISHEX_NOHEX
CMP AL,'f'
JA ISHEX_NOHEX
CLC
JMP ISHEX_OK
ISHEX_NOHEX:STC
ISHEX_OK:RET
ISHEX ENDP
ISDEC PROC
CMP AL,'0'
JB ISDEC_NODEC
CMP AL,'9'
JA ISDEC_NODEC
CLC
JMP ISDEC_OK
ISDEC_NODEC:STC
ISDEC_OK:RET
ISDEC ENDP
ATOBIN PROC
SUB AL,30H
CMP AL,9
JBE ATOBIN_OK
SUB AL,7
CMP AL,15
JBE ATOBIN_OK
SUB AL,20H
ATOBIN_OK:RET
ATOBIN ENDP
HTOBIN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV DI,SI
ADD DI,CX
DEC DI
MOV BX,0
MOV DGROUP:RES_AX,0
XOR DX,DX
HTOBIN_FORJ:CMP DI,SI
JB HTOBIN_FINISHJ
MOV AL,DS:[DI]
CALL ATOBIN
MOV AH,0
MOV CL,DGROUP:SHL_TABLE[BX]
SHL AX,CL
ADD DX,AX
HTOBIN_NEXTJ:DEC DI
INC BX
JMP HTOBIN_FORJ
HTOBIN_FINISHJ:MOV DGROUP:RES_AX,DX
HTOBIN_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
HTOBIN ENDP
DTOBIN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV DI,SI
ADD DI,CX
DEC DI
MOV BX,0
MOV DGROUP:RES_AX,0
DTOBIN_FORJ:CMP DI,SI
JB DTOBIN_OK
MOV AL,DS:[DI]
CALL ATOBIN
MOV AH,0
MOV CX,DGROUP:MUL_TABLE[BX]
MUL CX
ADD DGROUP:RES_AX,AX
DTOBIN_NEXTJ:DEC DI
INC BX
INC BX
JMP DTOBIN_FORJ
DTOBIN_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOBIN ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRH PROC
PUSH AX
PUSH BX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRH1:CALL GETCH
CMP AL,CR
JZ GETSTRH5
CMP AL,BACKSPACE
JNZ GETSTRH4
CMP BX,0
JZ GETSTRH2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRH1
GETSTRH2:CALL BELL
JMP GETSTRH1
GETSTRH4:CMP BX,4
JZ GETSTRH2
CALL ISHEX
JC GETSTRH2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRH1
GETSTRH5:CMP BX,0
JZ GETSTRH2
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRH_OK:
POP DI
POP BX
POP AX
RET
GETSTRH ENDP
GETSTRD PROC
PUSH AX
PUSH BX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRD1:CALL GETCH
CMP AL,CR
JZ GETSTRD5
CMP AL,BACKSPACE
JNZ GETSTRD4
CMP BX,0
JZ GETSTRD2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRD1
GETSTRD2:CALL BELL
JMP GETSTRD1
GETSTRD4:CMP BX,4
JZ GETSTRD2
CALL ISDEC
JC GETSTRD2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRD1
GETSTRD5:CMP BX,0
JZ GETSTRD2
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRD_OK:
POP DI
POP BX
POP AX
RET
GETSTRD ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
HTOASC PROC
AND AL,0FH
ADD AL,30H
CMP AL,39H
JA HTOASC_NODEC
JMP HTOASC_OK
HTOASC_NODEC:ADD AL,7
HTOASC_OK:RET
HTOASC ENDP
ALTOASC PROC
CMP AL,20H
JB ALTOASC1
CMP AL,7EH
JA ALTOASC1
JMP ALTOASC_OK
ALTOASC1:MOV AL,'.'
ALTOASC_OK:RET
ALTOASC ENDP
AHTOASC PROC
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL HTOASC
XCHG AH,AL
CALL HTOASC
RET
AHTOASC ENDP
DHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH AX
XCHG AH,AL
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DHTOASC ENDP
DAHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DAHTOASC ENDP
DISARRAY PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH ES
PUSH BP
CMP CX,1
JB DISARRAY_OK
CMP CX,8000H
JA DISARRAY_OK
MOV SI,CX
MOV BP,0FFFFH
XOR DX,DX
MOV AX,ES
MOV CX,16
MUL CX
ADD AX,DI
ADC DX,0
CMP DX,000FH
JA DISARRAY_OK
MOV DGROUP:NUM_DX,DX
MOV DGROUP:NUM_AX,AX
MOV DX,000FH
MOV AX,0FFFFH
SUB AX,DGROUP:NUM_AX
SBB DX,DGROUP:NUM_DX
ADD AX,1
ADC DX,0
CMP DX,0
JNZ DISARRAY2
MOV BP,AX
DISARRAY2:XOR DX,DX
MOV AX,0FFFFH
SUB AX,DI
ADD AX,1
ADC DX,0
CMP DX,0
JZ DISARRAY5
MOV AX,0FFFFH
DISARRAY5:CMP AX,BP
JBE DISARRAY3
MOV AX,BP
DISARRAY3:CMP AX,SI
JAE DISARRAY1
MOV SI,AX
DISARRAY1:MOV AX,SI
XOR DX,DX
MOV CX,16
CALL DIVDW
MOV DGROUP:NUM_AX,AX
MOV DGROUP:NUM_CX,CX
MOV CX,SI
MOV BX,DI
MOV BP,0
MOV SI,0
DISARRAY_FORI1:CMP BP,CX
JAE DISARRAY_OK
CMP SI,DGROUP:NUM_AX
JZ DISARRAYZ
JA DISARRAY_OK
MOV DGROUP:NUM_BX,SI
MOV DGROUP:DIS_LEN,0
MOV AX,ES
CALL DHTOBUF
MOV SI,DGROUP:DIS_LEN
MOV BYTE PTR DIS_BUF[SI],':'
INC SI
MOV BYTE PTR DIS_BUF[SI],20H
INC SI
MOV DGROUP:DIS_LEN,SI
MOV AX,BX
CALL DHTOBUF
MOV SI,DGROUP:NUM_BX
MOV DI,0
DISARRAY_FORJ1:CMP DI,16
JAE DISARRAY_FINISHJ1
MOV AL,ES:[BX]
CALL DAHTOBUF
CALL ALTOASC
MOV DGROUP:DIS_BUF[DI+62],AL
DISARRAY_NEXTJ1:INC DI
INC BP
INC BX
JMP DISARRAY_FORJ1
DISARRAY_FINISHJ1:MOV SI,DGROUP:DIS_LEN
MOV BYTE PTR DGROUP:DIS_BUF[SI],20H
INC SI
MOV BYTE PTR DGROUP:DIS_BUF[SI],20H
INC SI
ADD SI,16
MOV BYTE PTR DGROUP:DIS_BUF[SI],0DH
INC SI
MOV BYTE PTR DGROUP:DIS_BUF[SI],0AH
INC SI
MOV DGROUP:DIS_LEN,SI
MOV DGROUP:NUM_DX,CX
MOV CX,SI
MOV SI,DGROUP:NUM_BX
MOV DGROUP:NUM_BX,BX
MOV BX,0
DISARRAY_S1:MOV DL,DGROUP:DIS_BUF[BX]
MOV AH,2
INT 21H
INC BX
LOOP DISARRAY_S1
JMP DISARRAY_NEXTI2
DISARRAYZ:MOV AX,DGROUP:NUM_CX
CMP AX,1
JB DISARRAY_NEXTI1
MOV DGROUP:NUM_BX,SI
MOV DGROUP:DIS_LEN,0
MOV AX,ES
CALL DHTOBUF
MOV SI,DGROUP:DIS_LEN
MOV BYTE PTR DGROUP:DIS_BUF[SI],':'
INC SI
MOV BYTE PTR DGROUP:DIS_BUF[SI],20H
INC SI
MOV DGROUP:DIS_LEN,SI
MOV AX,BX
CALL DHTOBUF
MOV SI,DGROUP:NUM_BX
MOV DI,0
DISARRAY_FORJ2:CMP DI,DGROUP:NUM_CX
JAE DISARRAY_FINISHJ2
MOV AL,ES:[BX]
CALL DAHTOBUF
CALL ALTOASC
MOV DGROUP:DIS_BUF[DI+62],AL
DISARRAY_NEXTJ2:INC DI
INC BP
INC BX
JMP DISARRAY_FORJ2
DISARRAY_FINISHJ2:MOV SI,DGROUP:DIS_LEN
DISARRAY_FORJ3:CMP DI,16
JAE DISARRAY_FINISHJ3
MOV BYTE PTR DGROUP:DIS_BUF[SI],20H
INC SI
MOV BYTE PTR DGROUP:DIS_BUF[SI],20H
INC SI
MOV BYTE PTR DGROUP:DIS_BUF[SI],20H
INC SI
MOV BYTE PTR DGROUP:DIS_BUF[DI+62],20H
DISARRAY_NEXTJ3:INC DI
JMP DISARRAY_FORJ3
DISARRAY_FINISHJ3:
MOV BYTE PTR DGROUP:DIS_BUF[SI],20H
INC SI
MOV BYTE PTR DGROUP:DIS_BUF[SI],20H
INC SI
ADD SI,16
MOV BYTE PTR DGROUP:DIS_BUF[SI],0DH
INC SI
MOV BYTE PTR DGROUP:DIS_BUF[SI],0AH
INC SI
MOV DGROUP:DIS_LEN,SI
MOV DGROUP:NUM_DX,CX
MOV CX,SI
MOV SI,DGROUP:NUM_BX
MOV DGROUP:NUM_BX,BX
MOV BX,0
DISARRAY_S2:MOV DL,DGROUP:DIS_BUF[BX]
MOV AH,2
INT 21H
INC BX
LOOP DISARRAY_S2
DISARRAY_NEXTI2:MOV BX,DGROUP:NUM_BX
MOV CX,DGROUP:NUM_DX
DISARRAY_NEXTI1:INC SI
JMP DISARRAY_FORI1
DISARRAY_OK:POP BP
POP ES
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DISARRAY ENDP
DHTOBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV SI,WORD PTR DGROUP:DIS_LEN
PUSH AX
XCHG AH,AL
CALL AHTOASC
MOV BYTE PTR DGROUP:DIS_BUF[SI],AH
INC SI
MOV BYTE PTR DGROUP:DIS_BUF[SI],AL
INC SI
POP AX
CALL AHTOASC
MOV BYTE PTR DGROUP:DIS_BUF[SI],AH
INC SI
MOV BYTE PTR DGROUP:DIS_BUF[SI],AL
INC SI
MOV BYTE PTR DGROUP:DIS_BUF[SI],20H
INC SI
MOV WORD PTR DGROUP:DIS_LEN,SI
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DHTOBUF ENDP
DAHTOBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV SI,WORD PTR DGROUP:DIS_LEN
CALL AHTOASC
MOV BYTE PTR DGROUP:DIS_BUF[SI],AH
INC SI
MOV BYTE PTR DGROUP:DIS_BUF[SI],AL
INC SI
MOV BYTE PTR DGROUP:DIS_BUF[SI],20H
INC SI
MOV WORD PTR DGROUP:DIS_LEN,SI
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DAHTOBUF ENDP
END
t434.c以汇编格式输出编译结果，其中的主要内容如下所示（已删去空段和注释等次要内容）
_TEXT	segment	byte public 'CODE'
DGROUP	group	_DATA,_BSS
	assume	cs:_TEXT,ds:DGROUP,ss:DGROUP
_TEXT	ends
_TEXT	segment	byte public 'CODE'
_main	proc	near
	call	near ptr _DisMem
@1:
	ret	
_main	endp
_TEXT	ends
_TEXT	segment	byte public 'CODE'
	extrn	_DisMem:near
_TEXT	ends
	public	_main
	end
通过下面的命令能够完成对CA8.C的编译、对A8.ASM的汇编，最后再连接到一起：
TCC -ms -c t434.c
MASM /Zm /c /Cx t433.asm
LINK c0s.obj + t434.obj + t433.obj
Run file : t434.exe
Libraries : CS.lib
上述最后连接命令中的c0s.obj和CS.lib分别是Turbo C的SMALL模式下的启动代码目标模块文件和函数库文件。
必须注意，上面的汇编模块A8.OBJ只能与按SMALL模式编译的C模块CA8.obj相连接。
使用DEBUG查看生成的可执行程序
-u cs:01fa
CALL 01FE
RET
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
PUSH DS
PUSH ES
MOV AX,0CFC
MOV DS,AX
MOV DX,022C
CALL 0355
MOV DI,0214
CALL 0369
MOV SI,0214
ADD SI,+02
......
题8.12请编写一个求三角函数值的小型实用程序。利用BC或TC的库函数获得三角函数值。
#include <stdio.h>
#include <stdlib.h>

int main()
{
    double xxx;
    double yyy;
    double zzz;
    double aaa;
    xxx = 3.14159265;
    yyy = (xxx / 180);
    scanf("%lf",&zzz);
    zzz *= yyy;
    aaa = sin(zzz);
    printf("sin = %f\n", aaa);
    aaa = cos(zzz);
    printf("cos = %f\n", aaa);
    aaa = tan(zzz);
    printf("tan = %f\n", aaa);
    return 0;
}
第三部分上机实验部分
第12章实验指导
上机实际操作是学习汇编语言程序设计的重要步骤。由于汇编语言固有的特点，调试汇编语言程序要比调试高级语言程序困难得多。
本章介绍的实验指导内容基于DOS平台，如果使用的是Windows平台，那么可转换到MS-DOS程序方式，即建立DOS平台。
12.1实验的一般步骤
通常程序设计的开始工作是对需求进行分析，根据要求和规模等因素划分模块，设计各功能模块的实现算法。
在完成这些工作之后，进行编程和调试。就汇编语言程序设计或者汇编语言和高级语言的混合编程而言，
需求分析、模块划分和算法设计等工作与高级语言程序设计是相似的。从根据数据结构和算法进行编码到形成可试用程序的过程如图12.1所示。
这个过程主要由编辑、汇编、连接和调试四个步骤构成。
通常，编辑、汇编、连接和调试这四步不在一个集成环境的支持下进行，而是分步独立进行。
第一步是编辑源程序。利用文本编辑工具（如EDIT）编辑源程序，生成一个汇编语言源程序的纯文本文件。
通常汇编语言源程序文件的扩展名是ASM。
汇编语言源程序一行安排一条语句，不采用类似C或者PASCAL等高级语言源程序那样的分层次缩进格式。
如下是汇编语言源程序的一般格式。请注意上下行之间的指令助记符及第一个操作数首字符的对齐，利用制表符能较好地实现对齐格式。
；源程序名：HELLO.ASM
；功能：显示一个字符串
DSEG SEGMENT
MESSAGE DB 'How do you do.',0DH,0AH,24H
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV DX,OFFSET MESSAGE
MOV AH,9
INT 21H
MOV AH,4CH
INT 21H
CSEG ENDS
END START
第二步是汇编源程序。利用汇编器（如MASM或者TASM）汇编源程序生成目标代码文件。通常目标代码文件的扩展名是OBJ。
汇编器还可以生成列表文件和交叉参考文件。汇编器相当于高级语言程序设计中的编译器。
汇编器按汇编语言的语法检查源程序，如果源程序中有语法错误的行，那么汇编器就不生成目标代码文件。
这种情况下，必须回到第一步，重新编辑源程序，修改语法错误的行。
当发现源程序中的某些行含可疑成分或不确定因素时，汇编器会给出警告信息，但仍按缺省处理办法生成目标代码文件。
这种情况下，可以重新编辑源程序，消除可疑成分或不确定因素。
第三步是连接目标程序。利用连接器（如LINK或者TLINK）连接目标代码文件和库函数代码生成可执行程序文件。
通常DOS平台上的可执行程序文件的扩展名是EXE。一般单个模块的连接不会发生连接错误，总可以顺利地生成可执行程序文件。
当多个模块连接，或者与库中的函数连接时，如果在目标代码文件或者库中找不到所需的连接信息，连接器就会发出错误提示信息，
而不生成可执行程序文件。这就需要修改源程序，使得汇编器生成的目标代码文件含有连接器需要的信息。
这样的修改主要是对伪指令和汇编语言操作符的修改，或者是对名字符号的修改。
如果出现这种情况，那么就要回到第一步编辑源程序，还要重新进行第二步汇编源程序。
第四步是调试可执行程序。程序的动态调试是在形成可执行程序文件后，针对可执行程序进行的。
DEBUG是简单而有效的动态调试工具，Turbo Debug是功能较强的调试工具。
利用调试工具动态地调试程序，找出程序中的BUG。如果发现程序中有BUG，那么必须回到第一步，重新开始。
当然，如果问题是算法不正确造成的，那么还得修正算法。
上述四个步骤不包括函数库的建立和管理。
12.2汇编器和连接器的使用
在DOS平台上使用得较普遍的汇编器是MASM和TASM，连接器是LINK和TLINK。
MASM和LINK由Microsoft公司出品，TASM和TLINK由Borland公司出品。
12.2.1MASM的使用
下面介绍的宏汇编器MASM5.0版本使用比较普遍。命令格式如下：
MASM [/options] [source(.asm)],[out(.obj)],[list(.Ist)],[cref(.crf)][;]
可选的命令动作选项由符号“/”引导。利用命令“MASM /HELP”可获得所有命令动作选项及其说明信息。
source(.asm)指定源程序，缺省的扩展名是ASM。
out(.obj)指定输出的目标代码文件。缺省的文件名同源程序文件名，缺省的扩展名是OBJ。
list(.lst)指定输出的列表文件，缺省的扩展名是LST。缺省情况是不生成列表文件。
cref(.crf)指定输出的交叉参考文件，缺省的扩展名是CRF。缺省情况是不生成交叉参考文件。
命令行最后的分号表示其后的缺省项，按缺省设置处理。
例如：利用MASM汇编12.1节的源程序HELLO.ASM，生成的目标代码存放在文件TEST.OBJ中，操作命令如下：
C>MASM Microsoft (R) Macro Assembler Version 5.00
Copyright (C) Microsoft Corp 1981-1985,1987.All rights reserved.
Source filename[.ASM]:HELLO.ASM
Object filename[HELLO.OBJ]:TEST.OBJ
Source listing[NUL.LST]:
Cross-reference[NUL.CRF]:
如果有警告提示信息或者错误提示信息，那么屏幕上就会出现对应的提示信息行，而且最后的警告和错误统计结果就不等于0。
当有错误提示信息时，不生成目标代码文件。
再如，也可以用如下命令汇编源程序HELLO.ASM，目标代码文件存放在HELLO.OBJ文件中
C>MASM HELLO.ASM
Microsoft (R) Macro Assembler Version 5.00
Copyright (C) Microsoft Corp 1981-1985,1987.All rights reserved.
Object filename[HELLO.OBJ]:
按回车键，同意目标代码文件名
Source listing[NUL.LST]:;
按分号键，其后的缺省项，按缺省设置处理，不生成列表文件不生成交叉参考文件
如下操作更简单，指定源程序文件HELLO.ASM，生成的目标文件以HELLO.OBJ命名，不生成列表文件和交叉参考文件
C>MASM HELLO ;
命令行尾的分号表示其他参数按缺省设置处理，也即目标文件名同源文件名（扩展名为OBJ），不生成列表文件和交叉参考文件。
12.2.2LINK的使用
下面介绍的连接器LINK3.0版本较低。命令格式如下：
LINK [/options] [source(.obj)......],[out(.exe)],[mapfile(.map)],[library(.lib)......J[;]
可选的命令动作选项由符号“/”引导。利用命令“LINK /HELP”可获得有关命令动作选项及其说明信息。
source(.obj)指定目标代码文件，缺省的扩展名是OBJ。可以有多个目标程序代码文件，文件标识间用加号间隔或者用空格间隔。
out(.exe)指定输出的可执行程序文件，缺省的文件名同第一个目标代码模块的文件名。缺省的扩展名是EXE。
mapfile(.map)指定输出的定位图文件，缺省的扩展名是MAP。缺省情况下不生成定位图文件。
library(.lib)指定连接时使用的库文件，缺省的扩展名是LIB。可以有多个库，库文件标识间用加号间隔或者用空格间隔。
缺省情况下不使用库。命令行最后的分号表示其后的缺省项，按缺省设置处理。
例如：利用LINK汇编独立的目标代码模块HELLO.OBJ，生成的可执行程序存放在文件TEST.EXE中，操作命令如下：
C>LINK
Microsoft (R) 8086 Object Linker Version 3.05
Copyright (C) Microsoft Corp 1983,1984,1985.All rights reserved.
Object Modules[.OBJ]:HELLO.OBJ
Run File[HELLO.EXE]:TEST.EXE
List File[NUL.MAP]:
Libraries[.LIB]:
Warning:no stack segment
上面最后一行的信息是LINK给出的警告信息，表示没有堆栈段。该警告信息不影响可执行程序文件的生成，生成的可执行程序使用缺省的堆栈。
一般情况下，普通的上机实验程序可不安排堆栈段，可以使用缺省的堆栈。
缺省的堆栈在哪里？利用动态调试工具便能清楚地看到缺省堆栈的位置。
再如，可用如下的连接命令连接独立的目标代码模块HELLO.OBJ，生成可执行程序HELLO.EXE：
C>LINK HELLO.OBJ
Microsoft (R) 8086 Object Linker Version 3.05
Copyright (C) Microsoft Corp 1983,1984,1985.All rights reserved.
Run File[HELLO.EXE]:;
按分号键，其后的缺省项，按缺省设置处理，生成可执行文件HELLO.EXE，不生成定位图文件，不使用库
如下命令实现同样的功能，但更加简便：
C>LINK HELLO ;
连接器LINK能够方便地实现多个模块的连接，也能实现目标模块与库函数的连接，最终生成可执行程序。多个模块中应有一个是主模块。
如下命令把两个目标代码模块TEST1.OBJ和TEST2.OBJ连接，生成的可执行程序存放在文件TEST.EXE中
C>LINK TEST1.OBJ + TEST2.OBJ,TEST.EXE ;
如下命令把主目标代码模块ABC.OBJ与库DEF.LIB内的函数(过程)连接，生成的可执行程序文件存放在文件ABC.EXE中
C>LINK ABC.OBJ,,,DEF.LIB
如下命令把主目标代码模块TEST1.OBJ、TEST2.OBJ与库DEF.LIB内的函数(过程)连接，生成的可执行程序文件存放在文件ABC.EXE中，
生成定位图文件GHI.MAP
C>LINK TEST1.OBJ + TEST2.OBJ,ABC.EXE,GHI.MAP,DEF.LIB
12.2.3TASM的使用
下面介绍的汇编器TASM是Borland C++的一部分。命令格式如下：
TASM [options]source[,object][,listing][,xref]
该命令格式与上述MASM的格式类似。如果简单地键入命令TASM，那么就可得到TASM的关于可选项和参数的说明信息。
source指定源程序文件，缺省的扩展名是ASM。命令行应该有该参数。
object指定生成目标文件的标识，可以缺省。缺省时，文件名同源程序文件名，扩展名是OBJ。
listing指定生成列表文件的标识，可以缺省。缺省时，一般表示不生成列表文件。
但如果使用/l选项或者/la选项，那么生成列表文件，列表文件的文件名同源程序文件名。列表文件的缺省扩展名是LST。
xref指定生成交叉参考文件的标识，可以缺省。缺省时，表示不生成交叉参考文件。生成的交叉参考文件的缺省扩展名是XRF。
例如：如下命令汇编HELLO.ASM，生成目标代码文件HELLO.OBJ：
C>TASM HELLO.ASM
Turbo Assembler Version 3.1 Copyright (c) 1988,1992 Borland International
Assembling file : HELLO.ASM
Error messages : None
Warning messages : None
Passes : 1
Remaining memory：437k
再如，如下命令汇编HELLO.ASM，生成对应的目标文件TEST.OBJ和列表文件ABC.LST：
C>TASM HELLO.ASM,TEST.OBJ,ABC.LST
Turbo Assembler Version 3.1 Copyright (c) 1988,1992 Borland International
Assembling file : HELLO.ASM to TEST.OBJ
Error messages : None
Warning messages : None
Remaining memory : 432k
如下命令汇编HELLO.ASM，生成目标代码文件HELLO.OBJ，还生成对应的列表文件HELLO.LST：
C>TASM /l HELLO
12.2.4TLINK的使用
下面介绍的连接器TLINK也是Borland C++的一部分，它的使用方法与LINK类似，但由于命令选项较多，所以功能比LINK要强。命令格式如下：
TLINK objfiles[,exefile][,mapfile][,libfiles]
如果简单地键入命令TLINK，那么就可得到TLINK的关于可选项和参数的说明信息。
objfiles指定欲连接的目标代码文件，缺省的扩展名是OBJ。如要连接多个目标代码文件，那么文件标识间用加号间隔或者用空格间隔。
exefile指定输出的可执行程序文件，缺省的文件名同第一个目标代码模块的文件名。缺省的扩展名一般是EXE。
mapfile指定输出的定位图文件，缺省的扩展名是MAP。缺省情况下生成定位图文件，文件名与可执行程序文件名相同。
libfiles指定连接时使用的库文件，缺省的扩展名是LIB。可以有多个库，库文件标识间用加号间隔或者用空格间隔。缺省情况下不使用库。
例如：如下命令连接单个目标代码模块HELLO.OBJ，生成可执行程序HELLO.EXE：
C>TLINK HELLO.OBJ
Turbo Link Version 7.00 Copyright (c) 1987,1994 Borland International
Warning : No stack
再如，如下命令连接目标代码模块TEST1、TEST2、TEST3，生成可执行程序文件TEST.EXE
C>TLINK TEST1.OBJ + TEST2.OBJ + TEST3.OBJ,TEST.EXE
如下命令连接目标代码模块ABC和库DEF中的相应过程，生成可执行程序ABC.EXE：
C>TLINK ABC.OBJ,,,DEF.LIB
TLINK支持32位目标代码的连接。如果被连接的目标代码模块含32位项，那么就必须按32位方式连接。这可通过使用选项/3表示。
例如：如下命令按32位方式连接目标代码模块TEST
C>TLINK /3 TEST.OBJ
第10章的若干实例就要使用32位方式连接。
12.3调试器DEBUG的使用
每个版本的DOS都带有动态调试器DEBUG。原因是DEBUG不仅是动态调试器，也是二进制文件编辑器，还是简单的系统维护工具。
DEBUG能提供一个动态调试程序的环境，程序员利用这个环境，可方便地调试目标代码程序。
本节先介绍DEBUG命令的使用，举例说明如何利用DEBUG调试程序。
为了方便地区分键盘输入和DEBUG显示输出，我们用黑体表示键盘输入。
12.3.1启动和退出DEBUG
DEBUG作为DOS的一个外部命令，必须与DOS版本相符。
1.启动DEBUG
DEBUG的启动与其它外部命令程序一样简单，在DOS系统提示符下发出DEBUG命令即可。一般格式如下：
DEBUG [文件标识符[参数表]]
其中，可选的文件标识符指定要调试的程序，参数表给出被调试程序所要用的命令行参数。
文件标识符必须指定一个文件，也只能指定一个文件。DEBUG根据文件标识符中的后缀是.EXE还是.COM判定被调试程序的类型。
其他类型的文件被认为是数据文件。如果缺省文件标识符，那么认为暂时没有指定被调试对象。
DEBUG在启动成功后，将给出DEBUG的提示符，即连接符“-”。通常只要有DOS就能找到版本相符的DEBUG，DEBUG就能启动成功。
例如，发出如下命令：
C>DEBUG
虽然，没有指定被调试程序，但DEBUG仍在可用内存区建立一个程序段前缀，做好准备工作，显示其提示符。
这时用户可发出DEBUG提供的各命令。各段寄存器的初值是相同的，等于PSP的段值，该值与可用内存区位置有关。
段内偏移0至FFH的区域作为PSP，指令指针IP的值定为100H，这种安排与调试.COM类型的可执行文件相同。
例如，发出如下命令：
C>DEBUG HELLO.EXE
假设指定的被调试程序是前两节介绍的程序HELLO.ASM所生成的目标程序。
如果找不到指定的命令文件，那么DEBUG将显示提示信息“File not found”，但仍给出DEBUG提示符，结果就象没有指定被调试程序那样。
如果找到HELLO.EXE，那么DEBUG就象DOS命令解释器COMMAND装载.EXE类型命令文件那样，为HELLO.EXE建立程序段前缀，
装载HELLO.EXE，装载过程包括可能需要的重定位，作好运行HELLO.EXE的所有准备工作，显示其提示符。
DS和ES都等于PSP段值。CS等于代码段段值，IP等于启动地址的偏移。SS等于堆栈段段值，SP等于堆栈顶偏移。
BX:CX为实际装载长度（字节数）。
2.退出DEBUG
为了退出DEBUG，只需在DEBUG提示符下发出退出命令Q即可。退出命令的使用格式如下：
Q
在发出Q命令后，DEBUG就终止，控制将转回到DOS。请注意，Q命令不保存正在被调试的文件，
为保存被调试的内容必须使用其他的DEBUG命令。
12.3.2命令一览
1.命令一览表
DEBUG的主要命令列于表12.1。
表12.1DEBUG命令一览表
命令格式                     功能说明
A [地址]                      汇编
C [范围] 地址              内存区域比较
D [范围]                      显示内存单元内容
E 地址 [字节值表]        修改内存单元内容
F 范围 字节值表          填充内存区域
G [=起始地址][断点地址表] 断点执行
H 数值 数值                十六进制数加减
I 端口地址                   从端口输入
L [地址[驱动器号 扇区号 扇区数]] 从磁盘读
M 范围 地址                内存区域传送
N 文件标识符[文件标识符...] 指定文件
O 端口 字节值             向端口输出
P [=地址][数值]           执行过程
Q                                退出DEBUG
R [寄存器名]               显示和修改寄存器内容
S 范围 字节值表         在内存区域搜索
T [=地址][数值]          跟踪执行
U [范围]                     反汇编
W [地址[驱动器号 扇区号 扇区数]] 向磁盘写
2.通用说明
（1）DEBUG接受和显示的数都用16进制表示。
（2）命令都是一个字母，命令参数随命令而异。
（3）命令和参数可以用大写或小写字母或混合方式输入。
（4）命令和参数间，可以用定界符分隔（空格、制表符、逗号等）。但是，定界符只是在两个相邻接的16进制数之间是必需的。
因此下面的命令是等效的：
D CS:100 110
D CS:100,110
D,CS:100,110
（5）在提示符出现时，可键入DEBUG命令，只有在按回车键后，命令才开始执行。
（6）若DEBUG检查出一个命令的语法错误，则DEBUG将用“Error”指出。例如：
D CS:100 CS:110
                   Error
（7）在输入DEBUG的命令行时，可以用常用的编辑键。
（8）可以用Ctrl+Break键或Ctrl+C键来打断一个命令的执行，返回到DEBUG的提示符。
（9）若一个命令产生相当多的输出行时，为了能看清屏幕上的显示内容，可按Ctrl+S键，暂停显示。
3.命令参数的说明
除了退出命令Q外，其它DEBUG命令都可带有参数。主要参数的表示方法如下说明：
（1）地址，地址参数通常表示一个内存区域（或缓冲区）的开始地址，它由段值和偏移两部分组成。
段值可用一个段寄存器表示，也可用4位16进制数表示。偏移用4位16进制数表示。段值和偏移间必须有冒号作为分隔。
段值部分是可省的，在段值缺省的情况下，除了A,G,L,T,U和W命令隐含使用CS寄存器之值外，其他命令隐含使用DS寄存器之值。
（2）端口地址，端口地址使用于输入输出命令，端口地址是一个两位16进制数。
（3）范围，范围用于指定内存区域（缓冲区），由两种表示方式：第一种是用起始地址和结束地址表示，第二种是用起始地址和长度表示。
长度必须以字母L引导。范围最大是64K，即0至0FFFFH。例如：
CS:100 110
CS:100 L10
但下面的地址是无效的：
CS:100 CS:110
               Error
（4）数值，数值参数一般表示命令重复的次数，最多可以是4位16进制数。
（5）字节值，字节值参数表示输出到端口的值，最多可以是2位16进制数。
（6）字节值表，字节值表参数表示要替换或查找的若干个以字节为单位的值。各值间由空格等间隔符分隔。
字节值表可以含字符串，字符串必须用引号括起。
（7）驱动器号，驱动器号参数表示要读写扇区所在的驱动器。0代表A驱动器，1代表B驱动器，2代表C驱动器，3代表D驱动器。
（8）扇区号，扇区号表示DOS逻辑扇区号，最多可以是3位16进制数。
12.3.3利用DEBUG调试程序
我们举例说明如何利用DEBUG调试程序，同时说明DEBUG常用命令的使用。
下面分析执行程序HELLO。先装载HELLO.EXE：
C>DEBUG HELLO.EXE
设DEBUG装载HELLO.EXE成功。现在可发出DEBUG的各种命令。
利用R命令可显示8086/8088各寄存器的内容和下一条将要执行的指令。现在看看程序在装入后，执行前各寄存器的内容：
-R
AX=0000 BX=0000 CX=0030 DX=0000 SP=0000 BP=0000 SI=0000 DI=0000
DS=1086 ES=1086 SS=1096 CS=1098 IP=0000 NV UP EI PL NZ NA PO NC
1098:0000 B89610 MOV AX,1096
各段寄存器的内容与存储器的实际使用情形有关。
不带任何参数的R命令，DEBUG按如上格式显示各寄存器内容。
每一个标志的状态分别用两个字母表示，表示8个标志的状态的符号列于表12.2。
DEBUG采用显示标志状态符号的方法反映标志值。
表12.2标志状态的符号表示
标志名称 溢出 方向 中断 符号 零  辅助进位 奇偶 进位
               OF    DF   IF     SF    ZF  AF   PF    CF
置位状态 OV   DN  EI     NG  ZR  AC   PE    CY
复位状态 NV   UP  DI     PL   NZ  NA  PO   NC
利用反汇编命令U可把内存单元的内容作为机器指令，用助记符的形式显示出来。
反汇编命令U显示的信息包括内存单元的地址、机器指令码和对应汇编格式指令。现在看看将要执行的代码：
-U
1098：0000 B89610 MOV AX,1096
1098：0003 8ED8     MOV DS,AX
1098：0005 BA0000 MOV DX,0000
1098：0008 B409      MOV AH,09
1098：000A CD21     INT 21
1098：000C B44C     MOV AH,4C
1098：000E CD21     INT 21
1098：0010 8B4502  MOV AX,[DI+02]
1098：0013 48          DEC AX
1098：0014 3B4606  CMP AX,[BP+06]
1098：0017 7703      JA 001C
1098：0019 E92E01  JMP 014A
1098：001C 897EFE  MOV [BP-02],DI
1098：001F 8BDF     MOV BX,DI
没有指定范围的反汇编命令U，从当时CS:IP所指处开始，或者紧接着上次反汇编结束地址处开始反汇编，长度约为32字节。
对照源程序HELLO.ASM，程序代码到偏移000FH为止。
所列出的从偏移0010H到0020H的指令似乎无意义，这是因为没有对应程序，但DEBUG仍将其视为指令反汇编。
反汇编命令所指定的地址是很重要的，一般应在一条有效指令的开始处：
-U 0 L5
1098:0000 B89610 MOVAX,1096
1098:0003 8ED8     MOV DS,AX
-U 1 L5
1098:0001 96 XCHG SI,AX
1098:0002 108ED8BA ADC [BP+BAD8],CL
偏移0000H处的指令"MOV AX,1096"对应源程序中标号START行的语句"MOV AX,DSEG"，由此可确定数据段DSEG的实际段值是1096H。
利用显示内存单元命令D可显示最低端1M范围内的任一内存单元的内容。现在可看一下数据段的内容（段值须根据实际装入的地址而定）：
-D 1096:0000 L30
1096:0000 48 6F 77 20 64 6F 20 79-6F 75 20 64 6F 2E 0D 0A How do you do...
1096:0010 24 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 $...............
1096:0020 B8 96 10 8E D8 BA 00 00-B4 09 CD 21 B4 4C CD 21 ......!.L.!
如上格式的信息中，左边是所显示内存单元的地址，中间部分是字节值，右边是字节值作为ASCII码所对应的符号，
对于非ASCII码，或者非显示符号，用点或者空格表示。
程序HELLO的数据段占32字节。如上列出的48字节中，前32字节是数据段的内容，后16字节实际上是代码段的内容。
段1096H的偏移0020H，相当于段1098H的偏移0000H。由于D命令要求列出48字节的内容，所以DEBUG还是把其视为数据显示。
利用跟踪执行命令T可跟踪执行一条或多条指令。现在我们跟踪执行HELLO：
-T
AX=1096 BX=0000 CX=0030 DX=0000 SP=0000 BP=0000 SI=0000 DI=0000
DS=1086 ES=1086 SS=1096 CS=1098 IP=0003 NV UP EI PL NZ NA PO NC
1098:0003 8ED8 MOV DS,AX
-T =0003 2
AX=1096 BX=0000 CX=0030 DX=0000 SP=0000 BP=0000 SI=0000 DI=0000
DS=1096 ES=1086 SS=1096 CS=1098 IP=0005 NV UP EI PL NZ NA PO NC
1098:0005 BA0000 MOV DX,0000
AX=1096 BX=0000 CX=0030 DX=0000 SP=0000 BP=0000 SI=0000 DI=0000
DS=1096 ES=1086 SS=1096 CS=1098 IP=0008 NV UP EI PL NZ NA PO NC
1098:0008 B409 MOV AH,09
跟踪执行命令T可指定起始执行地址，地址参数以等号引导，如地址参数中无段值，那么就以CS为段值。
必须注意，起始地址处必须是可执行指令。如果无起始地址，那么跟踪执行从CS:IP所指处开始。
如果不指定跟踪执行指令的条数，那么就跟踪执行一条指令。
-T 2
AX=0996 BX=0000 CX=0030 DX=0000 SP=0000 BP=0000 SI=0000 DI=0000
DS=1096 ES=1086 SS=1096 CS=1098 IP=000A NV UP EI PL NZ NA PO NC
1098:000A CD21 INT 21
AX=0996 BX=0000 CX=0030 DX=0000 SP=FFFA BP=0000 SI=0000 DI=0000
DS=1096 ES=1086 SS=1096 CS=02A6 IP=04A0 NV UP DI PL NZ NA PO NC
02A6:04A0 80FC72 CMP AH,72
从上可见，T命令跟踪进入了DOS功能调用程序。请注意，一般情况下不要进入DOS功能调用程序和BIOS程序。
利用执行过程命令P可步进执行一条或多条指令。现在我们从偏移0005H处重新开始执行（段值须根据实际装入地址而定）：
-P =1098:0005
AX=0996 BX=0000 CX=0030 DX=0000 SP=FFFA BP=0000 SI=0000 DI=0000
DS=1096 ES=1086 SS=1096 CS=1098 IP=0008 NV UP DI PL NZ NA PO NC
1098:0008 B409 MOV AH,09
-P 2
AX=0996 BX=0000 CX=0030 DX=0000 SP=FFFA BP=0000 SI=0000 DI=0000
DS=1096 ES=1086 SS=1096 CS=1098 IP=000A NV UP DI PL NZ NA PO NC
1098:000A CD21 INT 21
How do you do.
AX=0924 BX=0000 CX=0030 DX=0000 SP=FFFA BP=0000 SI=0000 DI=0000
DS=1096 ES=1086 SS=1096 CS=1098 IP=000C NV UP DI PL NZ NA PO NC
1098:000C B44C MOV AH,4C
请注意在执行DOS功能调用后所显示的信息“How do you do.”。
从上可见P命令和T命令的区别，P命令不会由于过程调用或软中断调用而跟踪进入被调用程序。
实际上P命令是步进跟踪，所以也能一次执行完LOOP指令，或者一次执行完重复的串操作指令。但P命令不适用于执行ROM中的程序。
利用执行命令G可以设置断点，执行被调试程序。现在我们执行完被调试程序：
-G
Program terminated normally
没有指定开始地址的G命令从当前CS:IP处开始执行，直到遇断点或程序正常终止而结束。
如上的G命令没有指定开始地址，也没有指定断点，所以从偏移000CH处开始执行，直到程序正常终止。
HELLO调用DOS的4CH号功能终止，所以DEBUG显示提示信息“Program terminated normally”而报告被调试程序执行完。
HELLO的执行与装载时的初值无关。我们重新执行已被装载的程序HELLO：
-G =0000 000C
How do you do.
AX=0924 BX=0000 CX=0030 DX=0000 SP=0000 BP=0000 SI=0000 DI=0000
DS=1096 ES=1086 SS=1096 CS=1098 IP=000C NV UP EI PL NZ NA PO NC
1098:000C B44C MOV AH,4C
如果地址参数无段值，那么就缺省认为是当前代码段，即由CS而定。由等号引导的开始地址处必须是有效的指令，断点处必须是有效的指令。
断点不能设置在ROM中。
利用修改内存单元命令E可方便地修改任一RAM单元的内容。现在我们把HELLO程序数据段中的信息“How do you do.”修改为"How are you."：
-E 1096:0000 "How are you."
重新执行，看看显示的是什么信息：
-G =0000 000c
How are you.o.
AX=0924 BX=0000 CX=0030 DX=0000 SP=0000 BP=0000 SI=0000 DI=0000
DS=1096 ES=1086 SS=1096 CS=1098 IP=000C NV UP EI PL NZ NA PO NC
1098:000C B44C MOV AH,4C
所显示的信息尾部有符号“o”，这是9H号DOS功能调用显示字符串信息以符号"$"结尾的缘故。再看数据段内的实际信息：
-D 0000 L20
1096:0000 48 6F 77 20 61 72 65 20-79 6F 75 2E 6F 2E 0D 0A How are you.o...
1096:0010 24 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 $...............
如果D命令的范围参数中没有段值，那么默认为段值在DS寄存器内。由于没有重新装载，所以DS已含段值1096H，而不是装载后的初值1086H。
现在修改数据段内的字符串信息的结尾，其中ODH和0AH是控制符回车和换行：
-E 000C 0D 0A '$'
-D 0000 000F
1096:0000 48 6F 77 20 61 72 65 20-79 6F 75 2E 0D 0A 24 0A How are you...$.
R命令不仅能显示各寄存器内容，还可修改各通用寄存器和段寄存器内容，还包括指令指针IP和标志寄存器。
现在修改指令指针寄存器IP，使其指向启动地址处：
-R IP
IP 000C
:0000
现在再看看各寄存器内容：
-R
AX=0924 BX=0000 CX=0030 DX=0000 SP=0000 BP=0000 SI=0000 DI=0000
DS=1096 ES=1086 SS=1096 CS=1098 IP=0000 NV UP EI PL NZ NA PO NC
1098:0000 B89610 MOV AX,1096
再执行，断点设在偏移000CH处：
G 000C 0010
How are you.
AX=0924 BX=0000 CX=0030 DX=0000 SP=0000 BP=0000 SI=0000 DI=0000
DS=1096 ES=1086 SS=1096 CS=1098 IP=000C NV UP EI PL NZ NA PO NC
1098:000C B44C MOV AH,4C
尽管设置了两个断点，但由于先遇到断点000CH，所以就停在该处。
利用R命令还可设置有关标志：
-R F
NV UP EI PL NZ NA PO NC - ZR CY
再看看ZF和CF是否确已改变：
R F
NV UP EI PL ZR NA PO CY - 按回车键
现在退出DEBUG：
-Q
利用R命令可修改各寄存器之内容，利用E命令可修改内存单元的内容。DEBUG还提供汇编命令A，直接修改内存中的代码。
下面利用A命令改变了偏移0005H处的指令“MOV DX,0000”为“MOV DX,0007”，这样在执行时，显示的提示信息仅是“you do.”：
C>DEBUG HELLO.EXE
-A 0005
1098:0005 MOV DX,0007
1098:0008 按回车键
现在看看代码是否确已被修改：
-U 0003 000A
1098:0003 8ED8 MOV DS,AX
1098:0005 BA0700 MOV DX,0007
1098:0008 B409 MOV AH,09
1098:000A CD21 INT 21
执行它：
-G
you do.
Program terminated normally
-Q
12.4Turbo Debugger的使用
Turbo Debugger是一个比较先进的源代码级调试器，它可以调试多种语言编写成的程序。
Turbo Debugger的重叠式窗口、下拉式和弹出式菜单以及鼠标器支持等，为用户提供了一个快速、方便和交互式的环境。
此外，联机帮助还可以在操作的每个阶段提供相关的帮助。以下我们把Turbo Debugger简称为TD。
尽管TD能够支持源代码级的程序调试，但我们在本节简单介绍如何利用TD调试汇编语言程序，也即机器指令级调试。
TD的详细使用细节，可通过联机帮助获得。
12.4.1启动和退出TD
TD需要DOS3.1或更高版本的DOS操作系统支持。如果使用TD进行源代码级的调试，那么必须事先把源文件编译连接成带有全部调试信息的
可执行程序文件，而且同时存在源程序文件。
1.启动TD
TD的启动与其他外部命令程序一样简单，在DOS系统提示符下发出TD命令即可。
一般格式如下：
TD [可选项][文件标识符[参数表]]
TD的可选项以符号“-”引导，利用命令“TD -?”可获得关于可选项的使用说明信息。TD命令使用的可选项会被保存到配置文件
可选的文件标识符指定要调试的程序，可不使用扩展名。参数表给出被调试程序所要用的命令行参数。
如下命令启动TD，并装载被调试程序HELLO：
C>TD HELLO
设仅有可执行程序，那么TD就直接给出布置如图12.2所示的机器指令级调试界面。可能会叠加一个报告无符号表的对话框，
按Esc键就能关闭该对话框。
主菜单条内包含有Run和Breakpoints等菜单项。按热键F10可激活主菜单条，然后按左右箭头键选择菜单项，
按回车键可下拉出对应的子菜单窗口。在出现子菜单窗口后，按上下箭头键和回车键选择某个动作。
我们采用“xxxlyyy”表示xxx下拉菜单中的yyy项。
操作提示区域给出当前可使用的主要热键及其功能，随着活动区域的变化和功能切换键Ctrl或Alt的按下，
该操作提示区域内的提示信息发生相应变换。
在代码显示区域，以行为单位显示汇编格式表示的机器指令和十六进制数形式表示的机器码，每一行首标出地址。
在数据显示区域，通常以十六进制数形式和对应ASCII码符号形式显示某内存区域的内容。
在堆栈显示区域，以十六进制数形式显示堆栈段内某区域的内容。在寄存器值显示区域，通常以4位十六进制数形式显示8个通用寄存器之内容。
在标志值显示区域，显示各常用标志之值。
在这5个显示区域中，光条或光标出现的区域称为焦点区域。而且仅有一个焦点区域。
利用Tab键、Shift+Tab键或者Shift+箭头键可方便地切换焦点区域。通常按方向箭头键可移动焦点区域中的光条或光标。
利用鼠标不仅能够方便地指定焦点区域，而且还能方便地指定光条或光标的位置。
2.退出TD
当需要退出TD时，通常只要按组合键Alt+X就行。如果有一个对话框处于活动状态，那么应该先按Esc键关闭对话框。
此外，也可以选择File|Quit菜单动作退出TD，返回操作系统。
12.4.2利用TD调试汇编程序
在TD的控制下，可以采用多种方法跟踪程序的执行，随时查看内存单元、堆栈和各寄存器之内容，根据需要修改寄存器、内存单元或堆栈的内容。
由于TD支持源代码级调试，所以当欲输入的十六进制数以字母开头时，必须表示成以0开头，有时还要加后缀字母H。
1.查看和修改寄存器内容
从寄存器值显示区域可看到各通用寄存器和段寄存器的当前内容，包括指令指针IP之内容。现在把焦点区域定到寄存器值显示区域，
那么在寄存器值显示区域就出现一个光条，指示某个寄存器，使用上下箭头键可移动该光条。
按Alt+F10可激活一个弹出式的操作菜单，利用其中的Registers 32-bit项可进行16位通用寄存器和32位通用寄存器的切换，
在80386及以上的系统中，指定32位通用寄存器可方便地查看和修改这些32位寄存器的内容。
按下Ctrl键，屏幕底部的操作提示区域就出现适用于寄存器值显示区域的有关组合键及其动作功能。
按组合键Ctrl+R就可实现16位通用寄存器和32位通用寄存器的切换。修改寄存器的内容是方便的。设焦点区域是寄存器值显示区域。
按组合键Ctrl+Z就可方便地把光条所在寄存器的内容清0；按组合键Ctrl+I使光条所在寄存器的内容递增1；
按组合键Ctrl+D使光条所在寄存器的内容递减1。按组合键Ctrl+C键将弹出输入新值的对话框，输入的值就直接作为光条所在寄存器的新内容。
此外，按字符或数值键，也直接弹出输入新值的对话框。
2.查看和修改常用标志状态
从标志值显示区域可看到常用标志的当前状态。标志用一个字符表示，标志的当前状态用数值1或0表示。
现在把焦点区域定到标志值显示区域，那么在标志值显示区域就出现一个光条，指示某个标志，使用上下箭头键可移动该光条。
按下组合键Ctrl+T，可翻转光条所在标志的状态。
3.查看和修改数据区内容
从数据显示区域可看到部分内存区域的当前内容。通常用十六进制数和对应ASCII码字符两种形式显示内存区域的内容，
并在每一行首给出由段值和偏移构成的内存单元地址，当段值与某个段寄存器的内容相等时，段值部分用段寄存器表示。
当焦点区域定到数据显示区域时，按组合键Ctrl+D会弹出一个用于指定显示格式的菜单，可从中选择需要的内存区域数据显示格式。
现在把焦点区域定到数据显示区域，那么在数据显示区域就出现一个光标，指示某个内存单元，使用方向箭头键可移动该光标。
通过上下翻页键和上下箭头键可调整所显示的内存区域，这种调整只是段内偏移的调整。可直接指定需要显示的内存区域首地址。
按组合键Ctrl+G，那么就会弹出一个用于输入定位地址的对话框。输入的内存区域首地址可包含段值部分，可以用段寄存器代表段值部分。
如果地址表示成段值和偏移，那么段值和偏移需用冒号间隔。
可以在当前数据区域内查找指定的字节值表。设焦点区域是数据显示区域。那么按组合键Ctrl+S会弹出一个用于输入欲查找字节值表的对话框。
修改内存单元的内容是方便的。设焦点区域是数据显示区域。按组合键Ctrl+C会弹出输入数值的对话框。
直接按字符或数字键，也会弹出输入数值的对话框。输入的有效数值将作为当前光标所对应存储单元的内容。
如果输入多个数值，那么它们就依次作为当前光标所对应存储单元开始的若干存储单元的内容。
如果欲修改的内存单元不在当前显示范围内，那么可先改变显示范围。
当焦点区域是数据显示区域时，按组合键AIt+F10会弹出一个适用于数据显示区域的操作菜单，选择其中的相应项，也可实现上述有关功能。
4.查看和修改堆栈内容
尽管堆栈也是内存区域，但它又不同于普通数据区，所以TD还专门提供堆栈显示区域来显示当前堆栈的内容。
从堆栈显示区域可看到堆栈顶的部分内容。现在把焦点区域定到堆栈显示区域，那么在堆栈显示区域就出现一个光条，指示某个内存单元，
使用上下箭头键可移动该光条。通过上下翻页键和上下箭头键可调整所显示的堆栈范围。可以直接指定堆栈范围。
按组合键Ctrl+G，那么就会弹出一个用于输入定位地址的对话框。输入的内存区域首地址可包含段值部分。
修改堆栈的内容是方便的。设焦点区域是堆栈显示区域。按组合键Ctrl+C会弹出输入数值的对话框。
直接按字符或数字键，也会弹出输入数值的对话框。输入的有效数值将作为当前光标所对应堆栈单元的内容。
如果欲修改的堆栈单元不在当前显示范围内，那么可先改变显示范围。
5.查看和修改代码区内容
在代码显示区域，可看到部分内存单元的内容作为机器指令反汇编的结果。每一行首由段值和偏移表示的地址，
当段值与某个段寄存器内的内容相等时，段值部分用段寄存器表示。
现在把焦点区域定到代码显示区域，那么在代码显示区域就出现一个光条，指示某条指令，使用上下箭头键可移动该光标。
通过上下翻页键和上下箭头键可调整所显示的代码区域，这种调整只是段内偏移的调整。可直接指定需要查看的代码区域首地址。
按组合键Ctrl+G，那么就会弹出一个用于输入定位地址的对话框。输入的代码区域首地址可包含段值部分，可以用段寄存器代表段值部分。
如果地址表示成段值和偏移，那么段值和偏移需用冒号间隔。
可以在当前代码区域内查找指定的指令。设焦点区域是代码显示区域。那么按组合键Ctrl+S会弹出一个用于输入欲查找指令或者字节值表的
对话框。可方便地修改代码区域内的指令。设焦点区域是代码显示区域。直接按字符或数字键，就会弹出一个用于输入汇编格式指令的对话框，
输入的指令被存放当前光条所指示地址开始的存储单元中。可连续输入多条汇编格式指令，它们被依次存放。
设焦点区域是代码显示区域。按组合键Alt+F10会弹出一个适用于代码显示区域的操作菜单。
其中的Assemble项就用于汇编指令。另外，I/O项可用于I/O端口操作。
6.执行
按F9执行被调试程序。激活主菜单中的Run下拉菜单，选择Run项，执行被调试程序。在代码显示区域，有一个箭头符号指示当前指令位置，
有时可能当前指令位置不在代码显示区域所显示的范围内。被调试程序从当前指令位置处开始执行，
直到下列事件之一发生为止：程序结束；遇到断点；按组合键Ctrl+Break中止执行。
当出现某些意想不到的情形，程序似乎失去控制时，可试着按组合键Ctrl+Break，使TD重新获得控制。
只要一按Ctrl+Break键，它就立即起作用，因此程序有可能被中断在预想不到的代码位置上。
Ctrl+Break在下面两种情况下无法发挥作用：被调试程序已陷入禁止中断的循环中；由于执行了错误代码系统已崩溃。
按组合键Ctrl+F2键，可重新装载被调试程序。按组合键AIt+F5键，可观察程序执行结果，再按任一键返回到调试界面。
7.单步跟踪执行
TD提供三个单步跟踪执行热键：F7、F8和Alt+F7。在汇编级调试时，按这三个热键之一通常都跟踪执行一指令。
但遇下列指令时，这三个热键有差异。当执行的指令是过程调用指令CALL时，按F7或Alt+F7会跟踪进入过程，而按F8则直接执行完对应过程。
类似地，当遇中断调用指令INT、循环指令LOOP和串操作指令时，按F8就执行完对应指令。按AIt+F7可跟踪进入中断处理程序。
在单步跟踪执行结束时，寄存器值显示区域和标志值显示区域就立即反映出寄存器内容变化情况，堆栈显示区域和数据显示区域也有相应改变。
在代码显示区域，当前指令位置也就相应调整，有时代码显示区域所显示的范围也发生相应变化。
8.执行到指定位置
如果想要从当前指令位置处开始，执行到某条指令时止，可利用F4键实现。先使代码显示区域成为焦点区域，那么在代码显示区域就出现一光条；
然后利用上下箭头键或上下翻页键把光条定到希望停止执行的指令上；最后按F4键。如果没有遇到断点，而且执行经过指定的指令，
那么执行就会在指定指令处停止。此外，当代码显示区域是焦点区域时，按组合键AIt+F9可直接指定执行停止位置。
通常被调试从当前指令位置处开始执行，直到指定位置处为为止。但遇到断点或者不经过指定位置是例外。
9.设置断点
当代码显示区域是焦点区域时，可很方便地设置断点。利用上下箭头键或上下翻页键把光条定到希望设置断点的指令上，
然后按F2键就可在该处设置断点。设置断点的指令上出现一红色光条。按组合键Alt+F2键会弹出一个用于输入断点位置的对话框。
如果光条所在指令处已设置了断点，那么按F2键就取消该处的断点。选择主菜单Breakpoints中的Deleteall项，可删除全部已设置的断点。
在设置断点后运行被调试程序，那么当执行到断点处时，就停止执行。寄存器值显示区域、标志值显示区域和其他区域都会及时反映有关变化。
第二部分提高部分
第9章80386 程序设计基础
80386是x86微处理器家族发展中的里程碑，它不仅兼容先前的8086/8088和80286等微处理器，
而且也为后来的80486、Pentium和PentiumPro等微处理器奠定了基础。
80386支持实方式和保护方式两种运行模式。在实方式下，80386相当于一可进行32位处理的快速8086，
原先为8086/8088设计的程序几乎都可适用于80386。当开机或者经硬件RESET线重新初始化时，80386处于实方式下。
本章介绍80386寄存器、寻址方式和指令集，这些内容是进行80386程序设计的基础，对实方式和保护方式都有效。
9.1 80386寄存器
80386寄存器的宽度大多是32位，可分为如下几组：通用寄存器、段寄存器、指令指针及标志寄存器、系统地址寄存器、控制寄存器、
调试寄存器和测试寄存器。应用程序主要使用前三组寄存器，只有系统程序才会使用各种寄存器。
这些寄存器是x86系列微处理器先前成员（8086/8088、80186和80286）寄存器的超集，所以80386包含了先前微处理器的全部16位寄存器。
8086/8088没有系统地址寄存器和控制寄存器等寄存器。
EAX AX AH AL
EBX BX BH BL
ECX CX CH CL
EDX DX DH DL
ESI SI
EDI DI
EBP BP
ESP SP
EFLAGS FLAGS
EIP IP
CS DS ES SS FS GS
9.1.1 通用寄存器
80386有8个32位通用寄存器，这8个寄存器分别定名为EAX、EBX、ECX、EDX、EBP、ESP、ESI和EDI。
它们是原先的16位通用寄存器的扩展，请参见图9.1。这些通用寄存器的低16位可以作为16位的寄存器独立存取，
并把它们分别定名为AX、BX、CX、DX、BP、SP、SI和DI，它们也就是x86系列微处理器先前成员的8个16位通用寄存器。
在存取这些16位的寄存器时，相应的32位通用寄存器的高16位不受影响。与先前的微处理器一样，
AX、BX、CX和DX这4个16位的数据寄存器的高8位和低8位可以被独立存取，分别命名为AH、AL、BH、BL、CH、CL、DH和DL。
在存取这些8位寄存器时，相应的16位寄存器的其它位不受影响，相应的通用寄存器的其它位也不受影响。由此可见，
80386在扩展先前微处理器寄存器组时，为执行8086和80286等微处理器代码提供了兼容的寄存器组。
这些32位通用寄存器不仅可以传送数据、暂存数据、保存算术或逻辑运算的结果，而且还可以在基址和变址寻址时，存放地址。例如：
MOV EAX,12345678H
MOV [EBX],EAX
ADD EAX,[EBX+ESI+1]
MOV AL,[ECX+EDI+1234]
SUB CX,[EAX-12]
在先前的微处理器中，只有BX、BP、SI和DI可以在基址和变址寻址时存放地址，而现在80386的8个32位通用寄存器都可以作为指针寄存器使用，
所以说这些32位通用寄存器更具有通用性。
9.1.2 段寄存器
80386有6个16位段寄存器，分别定名为CS、DS、ES、SS、FS和GS。
在实方式下，代码段寄存器CS、数据段寄存器DS、附加段寄存器ES、堆栈段寄存器SS的功能与先前微处理器中对应段寄存器的功能相同。
FS和GS是80386新增加的段寄存器。因此80386上运行的程序可同时访问多达6个段。
在实方式下，内存单元的逻辑地址仍是"段值:偏移"形式。为了访问一个给定内存段中的数据，可直接把相应的段值装入某个段寄存器中。例如：
MOV AX,SEG BUFFER
MOV FS,AX
MOV AX,FS:[BX]
在保护方式下，情况要复杂得多，装入段寄存器的不再是段值，而是称为选择子的某个值。有关内容在第10章介绍。
9.1.3指令指针和标志寄存器
80386的指令指针和标志寄存器分别是先前微处理器的指令指针IP和标志寄存器FLAG的32位扩展。
1.指令指针寄存器
80386的指令指针寄存器扩展到32位，记为EIP。EIP的低16位是16位的指令指针IP，它与先前微处理器中的IP相同。
IP寄存器提供了用于执行8086和80286代码的指令指针。由于实方式下段的最大范围是64K，所以EIP中的高16位必须是0，
仍相当于只有低16位的IP起作用。
2.标志寄存器
80386的标志寄存器也扩展到32位，记为EFLAGS，如图9.2所示。与8086/8088的16位标志寄存器相比，增加了4个控制标志，
其他标志位的位置和意义均与8086/8088相同。下面简单介绍这4个控制标志，它们在实方式下不发挥作用。
（1）IO特权标志IOPL（I/O Privilege Level）
IO特权标志有2位宽，也称为IO特权级字段。IOPL字段指定了要求执行I/O指令的特权级。
如果当前的特权级别在数值上小于或等于IOPL，那么I/O指令可执行，否则，发生一个保护异常。在80286的16位标志寄存器中已含有该标志。
（2）嵌套任务标志NT（Nested Task）
嵌套任务标志控制中断返回指令IRET的执行。如果NT=0，用堆栈中保存的值恢复EFLAGS、CS和EIP，执行常规的从中断返回的动作。
如果NT=1，通过任务转换实现中断返回。在80286的16位标志寄存器中，已含有该标志。
（3）重启动标志RF（Restart Flag）
重启动标志控制是否接受调试故障。RF=0接受，RF=1忽略。在成功地完成每一条指令后，处理器把RF清0。
而当接收到一个非调试故障时，处理器把RF置1。
（4）虚拟8086方式标志VM（Virtual 8086 Mode）
如果该标志置为1，处理器将在虚拟的8086方式下工作，如果清0，处理器工作在一般的保护方式下。
31          18 17   16  15  14  13 12   11   10  9  8    7   6   5  4   3  2   1  0
                   VM  RF  0   NT  IOPL    OF  DF IF TF  SF ZF  0 AF 0  PF     CF
9.2 80386存储器寻址
80386支持先前微处理器的各种寻址方式。在立即寻址方式和寄存器寻址方式中，操作数可达32位宽。
在存储器（内存）寻址方式中，不仅操作数可达32位，而且寻址范围和方式更加灵活。本节介绍80386存储器寻址方式。
9.2.1存储器寻址基本概念
80386继续采用分段的方法管理主存储器。存储器的逻辑地址由段基地址（段起始地址）和段内偏移两部分表示，
存储单元的地址由段基地址加上段内偏移所得。段寄存器指示段基地址，各种寻址方式决定段内偏移。
在实方式下，段基地址仍然是16的倍数，段的最大长度仍然是64K。段寄存器内所含的仍然是段基地址对应的段值，
存储单元的物理地址仍然是段寄存器内的段值乘上16加上段内偏移。所以，尽管80386有32根地址线，可直接寻址物理地址空间达到4G字节，
但在实方式下仍然与8086/8088相似。
在保护方式下，段基地址可以长32位，无须是16的倍数，段的最大长度可达4G。
段寄存器内所含的是指示段基地址的选择子，存储单元的地址是段基地址加上段内偏移。
但不再是段寄存器之值乘16加上偏移，这与8086/8088完全不同。
段寄存器指示段基地址。在实方式下，段寄存器含段值，直接指示段基地址；在保护方式下，段寄存器含选择子，间接指示段基地址。
每次对存储器的访问或是隐含地、或是显式地、或是默认地指定了某个段寄存器。
由于80386有6个段寄存器，所以在某一时刻程序可访问6个段，而不再是先前的4个段。
由段寄存器CS所指定的段称为当前代码段。80386在取指令时，自动引用代码段寄存器CS。80386的指令指针寄存器是EIP。
通常可以认为CS和EIP指示下一条要执行的指令。在实方式下，由于段的最大长度不超过64K，所以EIP的高16位为0，相当于IP。
由段寄存器SS所指定的段称为当前堆栈段。80386在访问堆栈时，总是引用堆栈段寄存器SS。
在实方式下，80386把ESP的低16位SP作为指向栈顶的指针，可以认为堆栈顶由SS和SP指定。
在保护方式下，32位堆栈段的堆栈指针是ESP，16位堆栈段的堆栈指针是SP。如果要访问存储在堆栈中的数据，也可以通过引用SS段寄存器进行。
DS寄存器是主要的数据段寄存器，对于访问除堆栈外的数据段它是一个默认的段寄存器。
在以BP或EBP或ESP作为基址寄存器访问堆栈时，默认的段寄存器是SS。某些字符串操作指令总是使用ES段寄存器作为目标操作数的段寄存器。
此外，尽管CS、SS、ES、FS和GS都可作为访问数据时引用的段寄存器，但必须显式地在指令中指定，它们也即成为段超越前缀，
这使得指令在长度和执行时间上的开销稍大一些。
例如：
MOV EAX,[SI] 
默认段寄存器DS
MOV [BP+2],EAX
默认段寄存器SS
MOV AL,FS:[BX]
显式指定段寄存器FS
MOV GS:[BP],DX
显式指定段寄存器GS
一般说来，使DS含有最经常访问的数据段的段值，而用ES、FS和GS含有那些不经常使用的数据段的段值。
当然，32位数据仍按“高高低低”原则存取。指令“MOV EAX,[1234H]”的传送示意如图9.3所示。
[1234H]存储5A684CE3H
EAX高16位 5A68H
EAX低16位 4CE3H
AX 4CE3H AH 4CH AL E3H
9.2.2灵活的存储器寻址方式
各种存储器寻址方式表示的是有效地址，也即段内偏移。在实方式下，段内偏移不能超过64K；在保护万式下，段内偏移可以超过64K。
80386既支持各种先前16位偏移的寻址方式，又增加了灵活的32位偏移的寻址方式。
80386支持先前微处理器所支持的各种存储器寻址方式。先前微处理器的存储器寻址方式可分为五种，其中相对基址加变址寻址方式最复杂。
相对基址加变址寻址方式中的16位有效地址（偏移）由三部分相加构成：一个基址寄存器（只能是BX或BP寄存器）、
一个变址寄存器（只能是SI或DI寄存器）和一个常数偏移量（最大16位）。在这三部分中如果没有常数偏移量，那么就成为基址加变址寻址；
如果没有基址寄存器或者变址寄存器，那么就成为寄存器相对寻址；如果只有基址寄存器或者只有变址寄存器，没有相对偏移量，
那么就成为寄存器间接寻址；如果既没有基址寄存器也没有变址寄存器，只剩下常数偏移量，那么就成为直接寻址。
80386支持上述各种16位偏移的存储器寻址方式。
80386还支持32位偏移的存储器寻址方式。80386允许内存地址的偏移可以由三部分内容相加构成：
一个32位基址寄存器，一个可乘上比例因子1、2、4或8的32位变址寄存器，及一个8位或32位的常数偏移量。
并且这三部分可省去任意的两部分。例如：
MOV AL,ES:[5678H]
显式指定段寄存器ES
MOV CX,[EBX]
MOV EDX,[EBX+EDI+1234H]
MOV AX,[EBX+ESI*4]
MOV ESI,[EBX*8+100H]
MOV BH,ES:[EBX+EDI*8+6]
显式指定段寄存器ES
如果含变址寄存器，那么变址寄存器中的值先按给定的比例因子放大，再加上偏移。
在这些寻址方式中，8个32位通用寄存器都可作为基址寄存器使用，除了ESP寄存器外，其他7个通用寄存器都可作为变址寄存器使用。例如：
MOV AL,[ECX]
MOV BX,[EAX-4]
MOV [EDX+EDI],CX
MOV [EBX+EAX*2],DH
MOV ESI,[EAX+ECX*8+1234H]
在所有寻址方式中，对数据的访问所默认引用的段寄存器取决于所选择的基址寄存器。
如果基址寄存器是ESP或者EBP，那么默认的段寄存器从通常的DS改为SS。
对于别的基址寄存器的选择，包括没有基址寄存器的情况，DS仍然是默认的段寄存器。
如9.2.1节中所述，访问由非默认的段寄存器指定的某个段的数据，要使用一额外的指令字节来指定所要的段寄存器。
当EBP作为变址寄存器使用（ESP不能作为变址寄存器使用）时，不影响默认段寄存器的选择。
默认段寄存器的选择只受所选的基址寄存器所影响。例如：
MOV AL,[EBX+EBP*2]           默认的段寄存器是DS
MOV AL,[EBX+EBP]               默认的段寄存器是DS
MOV AL,[EBP+EBX]               默认的段寄存器是SS
MOV AL,GS:[EBP*2]               显式指定段寄存器GS
MOV EAX,[ESP]                      默认的段寄存器是SS
MOV AL,CS:[ESP+2]              显式指定段寄存器CS
MOV [ESP+EBP*2],ECX         默认的段寄存器是SS
MOV AL,DS:[ESP+EDI+12]   显式指定段寄存器DS
80386支持的32位偏移的存储器寻址方式可归纳如下：
基址 +   变址 * 倍数     + 常数偏移
无          无      1 2 4 8      无、8位、32位
EAX       EAX
EBX       EBX
ECX       ECX
EDX       EDX
EBP        EBP
ESP        
ESI         ESI
EDI        EDI
要特别说明的是，在实方式下，也可使用上述32位偏移的存储器寻址方式，但所得偏移不应超过0FFFFH，
而且操作数的最高字节单元的地址偏移也不能超过0FFFFH。原因是实方式下段的长度是64K。
但有一种特殊情况，可使得段超过64K，在这种特殊情况下，就要使用32位的偏移来访问超过偏移64K部分的存储单元。
如果某一存储器操作数的地址是该操作数尺寸（长度）的倍数，那么称该操作数是对齐的。
当段基地址是16的倍数时，存储器操作数是否对齐就取决于偏移。
例如：如果一个字的偏移量是2的倍数，那么该字为对齐的；再如：一个双字的偏移量是4的倍数，那么该双字是对齐的。
在80386中，如果存储器操作数是对齐的，那么访问它就比较快。当然，不对齐的操作数也能访问，但所费时间可能多一点点。
程序员应该尽量使操作数对齐，以提高访问存储器操作数的速度。
9.2.3支持各种数据结构
80386支持的“基地址+变址+位移量”寻址方式能进一步满足高级语言支持的数据结构的需要。
标量变量、记录、数组、记录的数组和数组的记录等数据结构可方便地利用80386的这种寻址方式实现。
对FORTRAN而言，这些数据结构可作为Static存储来分配。对Pascal或者C而言，
这些数据结构可以动态地分配在一个程序的堆栈Stack或者堆Heap中。
基地址和变址寄存器为寻址方式提供两个动态的成分，而位移量提供静态的成分。
用在一数据段中的一个常数位移量可以简单地寻址静态分配的数据。用一相对于ESP或者EBP寄存器的常数位移量可以寻址分配在堆栈中的数据。
表9.1给出了高级语言的需要和80386支持的寻址方式之间的关系。
表9.1数据结构和80386寻址方式
存储类型      结构类型      地址方式分类                例子
静态             标量             位移                              DS:[1000]
                    数组             变址+位移                     DS:[ESI*4+1004]
                    记录              位移
                    记录的数组   变址+位移
                    数组的记录   变址+位移
堆栈             标量              基地址+位移
                    数组              基地址+变址+位移
                    记录              基地址+位移
                    记录的数组    基地址+变址+位移
                    数组的记录    基地址+变址+位移      SS:[ESP+EDI*2+100]
堆                标量               基地址
                    数组               基地址+变址
                    记录               基地址+位移
                    记录的数组     基地址+变址+位移
                    数组的记录     基地址+变址+位移
为了简化寄存器的分配，可以用8个通用寄存器中的一个作为基地址寄存器，以及用除ESP外的一个作为变址寄存器。
变址寄存器的值可以直接地被使用（比例因子为1），或者按2、4或8的倍率用于16位、32位、64位变量变址，
而不需要计算位移的指令或使用一额外的寄存器。
9.3 80386指令集
80386的指令集包含了8086/8088、80186和80286指令集。
可分为如下大类：数据传送指令、算术运算指令、逻辑运算和移位指令、控制转移指令、串操作指令、高级语言支持指令、条件字节设置指令、
位操作指令、处理器控制指令和保护方式指令。高级语言支持指令始于80186。保护方式指令始于80286。
条件字节设置指令和位操作指令等是80386新增的。
80386是32位处理器，80386指令的操作数长度可以是8位、16位或者32位。80386认为，32位操作数是对16位操作数的扩展。
80386既支持16位的存储器操作数有效地址，又支持32位的存储器操作数有效地址。
80386认为，32位存储器操作数有效地址是对16位存储器操作数有效地址的扩展。
所以，80386支持的32位操作数的指令往往就是对相应支持16位操作数指令的扩展；
80386的32位存储器操作数有效地址寻址方式往往就是对16位存储器操作数有效地址寻址方式的扩展。
本节在第2章介绍的8086/8088指令集基础上介绍80386指令集，有关保护方式的指令在第10.8节中介绍。
9.3.1数据传送指令
数据传送指令实现在寄存器、内存单元或I/O端口之间传送数据和地址。
80386的数据传送指令仍分成四种：通用数据传送指令、累加器专用传送指令、地址传送指令和标志传送指令。
1.通用传送指令组
80386的通用传送指令组含有如下十条指令：
数值传送指令MOV、符号扩展指令MOVSX、零扩展指令MOVZX、交换指令XCHG、
进栈指令PUSH、PUSHA、PUSHAD、退栈指令POP、POPA和POPAD。
（1）数值传送指令MOV
数值传送指令MOV的格式、功能和使用注意点都与8086/8088的MOV指令相同。
传送的数据可以是8位、16位或32位。例如：
MOV EAX,12345678H
MOV ESI,EDI
MOV [BX+SI+1],EBX
MOV CL,[EAX+EBX+3]
MOV FS,AX
MOV ES:[ECX+EDX*4],DX
MOV GS:WORD PTR [1234H],4321H
（2）符号扩展指令MOVSX和零扩展指令MOVZX（始于80386）
符号扩展指令的格式如下：
MOVSX DST,SRC
该指令的功能是把源操作数SRC的内容送到目的操作数DST，目的操作数空出的位用源操作数的符号位填补。
零扩展指令的格式如下：
MOVZX DST,SRC
该指令的功能是把源操作数SRC的内容送到目的操作数DST，目的操作数空出的位用零填补。
符号扩展指令和零扩展指令中的目的操作数DST必须是16位或32位寄存器，源操作数SRC可以是8位或16位寄存器，
也可以是8位或16位存储器操作数。如果源操作数和目的操作数都是字，那么就相当于MOV指令。
这两条指令不影响各标志。
例如：
MOV DL,92H
MOVSX AX,DL
92H扩展成FF92H送AX
MOVSX EBX,DL
92H扩展成FFFFFF92H送EBX
MOVZX CX,DL
92H扩展成0092H送CX
MOVZX ESI,DL
92H扩展成00000092H送ESI
MOV WORD PTR [BX],1234H
MOVSX ESI,WORD PTR [BX]
1234H扩展成00001234H送ESI
MOVZX EDI,WORD PTR [BX]
1234H扩展成00001234H送EDI
符号扩展指令MOVSX和零扩展指令MOVZX是80386新增的指令。
使用MOVSX可以对有符号数进行扩展，显然MOVSX指令要比CBW指令和CWD指令的功能强。使用MOVZX可以方便地对无符号数进行扩展。
（3）交换指令XCHG
交换指令XCHG的格式、功能和使用注意点都与8086/8088的XCHG指令相同。交换的数据可以是8位、16位或32位。例如：
XCHG ESI,EDI
XCHG [EBX+ESI*2+1],BX
XCHG CL,[EAX+EBX+3]
（4）进栈指令PUSH
进栈指令PUSH的格式没变，但功能增强了。从80186开始，压入堆栈的操作数还可以是立即数。
从80386开始操作数长度还可以达32位，当然如果操作数长度是32位，那么堆栈指针减4。
例如：
PUSH EAX
PUSH DWORD PTR [BX]
PUSH DWORD PTR [EAX]
PUSH FS
PUSH 1234H
16位立即数
PUSH 12345678H
32位立即数
在调用通过堆栈传递入口参数的子程序时，把立即数直接压入堆栈的操作能方便地把常量作为参数传递给子程序。例如：
PUSH 0F000H
压入立即数
PUSH 0
压入立即数
CALL ECHOBD
调用子程序
ADD SP,4
有一点要注意：当用PUSH指令把堆栈指针SP或ESP压入堆栈时，80386/80286的处理方式不同于8086/8088。
8086/8088是将SP减2后的值进栈，而80386/80286是将进栈操作前的SP（或ESP）值进栈。
也就是说，8086/8088先把SP减2，再赋值，80386/80286先赋值给[SP-2]，再把SP减2
push ax的执行，由以下两步完成。
（1）SP=SP-2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶；
（2）将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。
pop ax的执行过程和push ax刚好相反，由以下两步完成。
（1）将SS:SP指向的内存单元处的数据送入ax中；
（2）SP=SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。
（5）出栈指令POP
出栈指令POP的格式、功能和使用注意点都没变，除允许弹出32位操作数外。例如：
POP EAX
POP WORD PTR [ECX]
POP DWORD PTR [BX]
（6）16位通用寄存器全进栈指令PUSHA和全出栈指令POPA（始于80186）
PUSHA指令和POPA指令提供了压入或弹出8个16位通用寄存器的有效手段，它们的一般格式如下：
PUSHA
POPA
PUSHA指令将所有8个通用寄存器（16位）内容压入堆栈，其顺序是：AX、CX、DX、BX、SP、BP、SI、DI，
然后堆栈指针寄存器SP之值减16，所以SP进栈的内容是PUSHA执行之前的值。
POPA指令从堆栈弹出内容以PUSHA相反的顺序送到这些通用寄存器，从而恢复PUSHA之前的寄存器内容。
但堆栈指针寄存器ESP之值不是由堆栈弹出，而是通过增加16来恢复。
这两条指令不影响标志。这两条指令都没有显式的操作数。
在中断处理程序和子程序中，利用这两条指令能快速地进行现场保护和恢复。例如：
SUBX PROC
PUSHA
......
POPA
RET
SUBX ENDP
尽管PUSHA指令比8个独立的PUSH指令快，但它比3或4个独立的PUSH指令要慢，同时还将使SP减16，所以，如果只需要保存部分寄存器，
那么仍以使用PUSH指令为妥。对POPA和POP指令而言也是如此。
（7）32位通用寄存器全进栈指令PUSHAD和全出栈指令POPAD（始于80386）
PUSHAD指令和POPAD指令提供了压入或弹出8个32位通用寄存器的有效手段，它们的一般格式如下：
PUSHAD
POPAD
PUSHAD指令将所有8个通用寄存器（32位）内容压入堆栈，其顺序是：EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI，
然后堆栈指针寄存器ESP之值减32，所以ESP进栈的内容是PUSHAD执行之前的值。
POPAD指令从堆栈弹出内容以PUSHAD相反的顺序送到这些通用寄存器，从而恢复PUSHAD之前的寄存器内容。
但堆栈指针寄存器SP之值不是由堆栈弹出，而是通过增加32来恢复。
这两条指令不影响各标志。这两条指令都没有显式的操作数。这两条指令是PUSHA和POPA指令的扩展。
2.地址传送指令组
（1）装入有效地址指令LEA
装入有效地址指令的格式和功能没变。源操作数仍然必须是存储器操作数，目的操作数是16位或者32位通用寄存器。
当目的操作数是16位通用寄存器时，那么只装入有效地址的低16位。这符合实方式下的实际应用需要。
例如：
MOV EBX,12345678H
置EBX之值
MOV ECX,87654321H
置ECX之值
LEA ESI,[EBX+ECX+1234H]
执行后ESI=99999999H+1234H=9999ABCDH
LEA DX,[EBX+ECX+1234H]
执行后DX=0ABCDH
LEA EDI,[BX-3]
执行后EDI=00005675H
利用该指令还可以进行简单的算术运算，例如：
LEA ECX,[EAX+EDX*2+1234H]
ECX=EAX+EDX*2+1234H
LEA EDX,[EBX*8]
EDX=EBX*8
（2）装入指针指令组
装入指针指令组有5条指令，它们的格式如下：
LDS REG,OPRD
LES REG,OPRD
LFS REG,OPRD 始于80386
LGS REG,OPRD 始于80386
LSS REG,OPRD 始于80386
这些指令的功能将源操作数OPRD所指内存单元的4个或6个相继字节单元的内容送到指令助记符给定的段寄存器和目的操作数REG中。
目的操作数必须是16位或32位（始于80386）通用寄存器，源操作数是存储器操作数。
如果目的操作数是16位通用寄存器，那么源操作数OPRD含32位指针。
如果目的操作数是32位通用寄存器，那么源操作数OPRD含48位指针，这适合于使用32位偏移的场合，可用于一次装载48位全指针。
这些指令不影响各标志。
DB    1个字节
DW   2个字节
DD    4个字节
DF     6个字节
DQ    8个字节
DT     10个字节
用LDS、LES、LFS和LGS指令装入完整的指针是很方便的。例如：
STRING DB 'HELLO'
DPSTR DD STRING 高16位 段值 低16位 偏移
FPSTR DF STRING  高16位 段值 低32位 偏移
WPSTR DW STRING
DW SEG STRING
LFS DI,DPSTR
LGS ESI,FPSTR
LES DI,DWORD PTR WPSTR
用LSS指令装载堆栈指针是简单安全的方法，例如：
LSS SP,SSPTR
SSPTR是含有堆栈指针的双字
它确保在一条指令中使SS和SP都被重置。
3.标志传送指令组
80386的标志传送指令组含有如下6条指令：LAHF、SAHF、PUSHF、PUSHFD、POPF和POPFD。
指令LAHF、SAHF、PUSHF和POPF指令格式和功能等均与8086/8088相同。
LAHF 把标志寄存器的低8位传送到寄存器AH
SAHF 把寄存器AH送至标志寄存器低8位
PUSHF 把标志寄存器的内容压入堆栈
POPF 把栈顶的一个字弹出到标志寄存器
32位标志寄存器进栈和出栈指令的格式如下，它们始于80386：
PUSHFD
POPFD
PUSHFD指令将整个标志寄存器的内容压入堆栈；
POPFD指令将栈顶的一个双字弹出到32位的标志寄存器中。这两条指令是PUSHF和POPF指令的扩展。
PUSHFD指令不影响各标志；POPFD指令将影响各标志。
4.累加器专用传送指令组
80386累加器专用指令组含有如下指令：IN、OUT和XLAT。
IN 累加器,端口地址 从一个输入端口读取一个字节或一个字，传送至AL（若是一个字节）或AX（若是一个字）。
IN AL,PORT
IN AX,PORT            AH PORT+1 AL PORT
IN AL,DX
IN AX,DX                AH DX+1 AL DX
前两种格式是直接端口寻址，端口地址PORT是一个8位的立即数，后两种是间接端口寻址，端口地址在寄存器DX中。
OUT 端口地址,累加器 将AL中的一个字节，或在AX中的一个字，输出到指定端口。
OUT PORT,AL
OUT PORT,AX      PORT+1 AH PORT AL
OUT DX,AL
OUT DX,AX          DX+1 AH DX AL
前两种格式是直接端口寻址，端口地址PORT是一个8位的立即数，后两种是间接端口寻址，端口地址在寄存器DX中。
XLAT 把寄存器BX的内容作为表（每项一字节）的首地址，把寄存器AL的值作为下标，取出表项内容再送AL寄存器。
使用此指令前，应先把表的首地址送BX寄存器。表最大为256项。
输入指令IN的格式和功能与8086/8088相同，但可以通过累加器EAX输入一个双字。例如：
IN EAX,DX
从DX规定的端口输入一个双字
IN EAX,20H
从20H口输入一个双字
输出指令OUT的格式和功能与8086/8088相同，但可以通过累加器EAX输出一个双字。例如：
OUT DX,EAX
输出一个双字到DX规定的端口
OUT 20H,EAX
输出一个双字到20H端口
表转换指令XLAT的格式和功能与8086/8088相同。但从80386开始存放基值的寄存器可以是EBX。
也就是说，扩展的XLAT指令以EBX为存放基值的寄存器，非扩展的XLAT指令以BX为存放基值的寄存器。
9.3.2算术运算指令
80386算术运算指令的操作数可以扩展到32位，此外与8086/8088相比还增强了有符号数乘法指令的功能。
1.加法和减法指令组
NEG OPRD 对操作数取补，就是用零减去操作数OPRD，再把结果送回OPRD，也即：OPRD=0-OPRD
加法和减法指令组含有如下8条指令：ADD、ADC、INC、SUB、SBB、DEC、CMP和NEG。
除了这些指令的操作数可以扩展到32位外，其他均与8086/8088相同。例如：
ADD EAX,ESI
ADC EAX,DWORD PTR [BX]
INC EBX
SUB ESI,4
SBB DWORD PTR [EDI],EDX
DEC EDI
CMP EAX,EDX
NEG ECX
2.乘法和除法指令组
乘法和除法指令组含有4条指令：MUL、DIV、IMUL和IDIV。
（1）无符号数乘法和除法指令
无符号数乘法和除法指令的格式没变。指令中只给出一个操作数，自动根据给出的操作数确定另一个操作数。
当指令中给出的源操作数为字节或字时，它们与8086/8088的情形相同。
在源操作数为双字的情况下，乘法指令MUL默认的另一个操作数是EAX，其功能是把EAX内容乘上源操作数内容所得积送入EDX:EAX中，
若结果的高32位（在EDX中）为0，那么标志CF和OF被清0，否则被置1；
除法指令DIV默认的被除数是EDX:EAX，其功能是把指令中给出的操作数作为除数，所得的商送EAX，余数送EDX。
例如：
MUL DWORD PTR [BX+3]
DIV EBX
（2）有符号数乘法和除法指令
原有的有符号数乘法指令IMUL和除法指令IDIV继续保持，但操作数可扩展到32位。当操作数为32位时的情形与无符号数乘法、除法指令相同。
从80186开始，还提供了新形式的有符号数乘法指令。一般格式如下：
IMUL DST,SRC
IMUL DST,SRC1,SRC2
上述第一种格式是将目的操作数DST与源操作数SRC相乘，结果送到目的操作数DST中；第二种格式是将SRC1与SRC2相乘，
结果送目的操作数DST中。
其中，目的操作数只能是16位通用寄存器或32位通用寄存器；第一种格式中的源操作数SRC的长度必须与目的操作数的长度相同（8位立即数除外），
可以是通用寄存器、存储单元或立即数;第二种格式中的源操作数SRC1只能是通用寄存器或存储单元，并且长度必须与目的操作数的长度相同，
源操作数SRC2只能是立即数。例如：
IMUL EAX,10
IMUL AX,BX,12
IMUL DX,[SI],-2
IMUL EAX,DWORD PTR [EBX+ESI*2+3456H],5
实际上，第一种格式是第二种格式的特殊情形。例如：
IMUL AX,7
IMUL AX,AX,7
对于这两种新增的乘法指令，由于存放积的目的操作数的长度与被乘数（或乘数）的长度相同，因此积有可能溢出。
如果积溢出，那么高位部分将被丢掉，而置标志CF和OF为1来表示溢出；否则清标志CF和OF。
所以，在这样的乘法指令后可安排检测OF的条件转移指令，用于处理积溢出的情况。
由于存放积的目的操作数的长度与乘数的长度相同，而有符号数或无符号数的乘积的低位部分是相同的。
所以，这种新形式的乘法指令对无符号数和有符号数的处理是相同的。这也是只用一条IMUL指令就可以代表新形式乘法指令的原因。
在80186和80286中，没有32位通用寄存器可使用，此外第一种格式中的源操作数只能是立即数。
3.符号扩展指令组
80386的符号扩展指令组有如下4条指令：CBW、CWD、CWDE和CDQ。
符号扩展指令CBW和CWD的功能均无变化。
CBW 把寄存器AL中的符号扩展到寄存器AH。即若AL的最高有效位为0，则AH=0；若AL的最高有效位为1，则AH=0FFH。
CWD 把寄存器AX中的符号扩展到寄存器DX。即若AX的最高有效位为0，则DX=0；若AX的最高有效位为1，则DX=0FFFFH。
符号扩展指令CWDE和CDQ是80386新增的指令。它们的格式如下：
CWDE
CDQ
指令CWDE将16位寄存器AX的符号位扩展到32位寄存器EAX的高16位中。该指令是指令CBW的扩展。
指令CDQ将寄存器EAX的符号位扩展到EDX的所有位。该指令是指令CWD的扩展。
这些指令均不影响各标志。
4.十进制调整指令组
十进制调整指令组含有如下6条指令：DAA、DAS、AAA、AAS、AAM和AAD。这些指令的功能与8086/8088相同，均无变化。
9.3.3逻辑运算和移位指令
80386的逻辑运算和移位指令包括逻辑运算指令、一般移位指令、循环移位指令和双精度移位指令。
1.逻辑运算指令组
逻辑运算指令组含有如下5条指令：NOT、AND、OR、XOR和TEST。
除了这些指令的操作数可以扩展到32位外，其他均与8086/8088相同。例如：
NOT EAX
AND EDX,0FF00FF00H
XOR EAX,EAX
OR ESI,[BX]
TEST EAX,ES:[1234H]
2.一般移位指令组
一般移位指令组含有如下3条指令：SAL/SHL、SAR和SHR。算术左移指令SAL和逻辑左移指令SHL是相同的。
SAL OPRD,m   把操作数OPRD左移m位，每移动一位，右边用0补足一位，移出的最高位进入标志位CF
SHL OPRD,m  把操作数OPRD左移m位，每移动一位，右边用0补足一位，移出的最高位进入标志位CF
SAR OPRD,m  把操作数OPRD右移m位，每移动一位，左边的符号位保持不变，移出的最低位进入标志位CF
SHR OPRD,m  把操作数OPRD右移m位，每移动一位，左边用0补足，移出的最低位进入标志位CF
ROL OPRD,m  把操作数OPRD左循环移m位，每移位一次，操作数左移，其最高位移入最低位，同时最高位也移入进位标志CF
ROR OPRD,m  把操作数OPRD右循环移m位，每移位一次，操作数右移，其最低位移入最高位，同时最低位也移入进位标志CF
RCL OPRD,m  把操作数OPRD左循环移m位，每移位一次，操作数左移，其最高位移入进位标志CF，进位标志CF移入最低位
RCR OPRD,m  把操作数OPRD右循环移m位，每移位一次，操作数右移，其最低位移入进位标志CF，进位标志CF移入最高位
从80386开始，操作数可扩展到32位。尽管这些指令的格式没变，但移位位数的表达增强了。
从80186开始，移位指令中的移位位数不仅可以是1或者CL，也可以是一个8位立即数。例如：
SHL AL,4
SHR EAX,12
SAR WORD PTR [SI],3
从80386开始，实际移位位数等于指令中指定的移位位数的低5位，所以移位位数的变化范围是0至31。
CF总是保留着目的操作数最后被移出去的位的值。但对逻辑左移指令SHL而言，当移位位数大于等于被移位的操作数长度时，CF被置0。
在移位位数仅是1的情况下，当移位前后的目的操作数的符号位相同时，那么溢出标志位OF被置0。
这些移位指令还会影响标志ZF、SF和PF，但对标志AF无定义。
如下的程序片段实现把DX的内容乘16再加上AX的内容，结果保存在DL:AX中，设它们为无符号数：
PUSH DX
SHL DX,4
ADD AX,DX
POP DX
PUSHF
SHR DX,12
POPF
ADC DL,0
如下的指令片段利用算术右移指令SAR实现除数为2的n（设为5）次方的除法，
JGE 标号 （SF异或OF）=0  大于等于转移
OR指令执行以后，标志CF=0，标志OF=0，标志PF、ZF、SF反映运算结果，标志AF未定义。
为了保证所得的商与利用IDIV指令后所得的商相同，在被除数是负数的情况下，先把负数加2的n次方-1：
OR EAX,EAX
JGE NOADJ
LEA EAX,[EAX+31]
NOADJ:SAR EAX,5
任何一个整数n，都可以表示成n=k*q+r，其中0<=r<q
这里的r就是n除以q的余数，k就是n除以q的商
例如-9=(-2)*5+1，则-9除以5的余数为1，商为-2
EAX -1234 = FFFF FB2E 算术右移5位 FFFF FFD9 = -39
-1234 / 32 商 -39 余数 14
FFDA->0025 +1 = 38->商为-38
FFEE->0011 + 1 = 18->余数为-18 
FFD9H + 31 相当于向上取整 使得商为FFDA
3.循环移位指令组
循环移位指令组含有如下4条指令：ROL、ROR、RCL和RCR。
从80386开始，操作数可扩展到32位。与一般移位指令一样，从80186开始，循环移位指令中的移位位数也可以是一个8位的立即数。
例如：
ROL AH,4
ROR ESI,12
RCL AX,3
RCR ECX,4
从80386开始，对循环指令ROL和ROR而言，实际移位的位数将根据被移位的操作数的长度取8、16或32位的模；
对带进位的循环移位指令RCL和RCR而言，移位位数先取指令中规定的移位位数的低5位，再根据被移位的操作数的长度取9、17或32位的模。
循环移位指令影响CF和OF。CF总是保留着操作数最后被移出去的位的值。
在移位位数仅是1的情况下，当移位前后的目的操作数的符号位相同时，那么OF被置0。
例：设要将寄存器AX的每一位依次重复一次，所得32位数保存在寄存器EAX中。
如下程序片段实现这一要求：
MOV CX,16
MOV BX,AX
NEXT:SHR AX,1
RCR EDX,1
SHR BX,1
RCR EDX,1
LOOP NEXT
MOV EAX,EDX
4.双精度移位指令组（始于80386）
始于80386的双精度移位指令组含有两条指令：SHLD和SHRD。
双精度移位指令的一般格式如下：
SHLD OPRD1,OPRD2,m
SHRD OPRD1,OPRD2,m
其中，操作数OPRD1可以是16位通用寄存器、16位存储单元、32位通用寄存器或者32位存储单元；
操作数OPRD2的长度必须与操作数OPRD1的长度一致，并且只能是16位通用寄存器或者32位通用寄存器；
m是移位位数，或者为8位立即数，或者为CL。
双精度左移指令SHLD的功能是把操作数OPRD1左移指定的m位，空出的位用操作数OPRD2高端的m位填补，
（类似基于OPRD1:OPRD2的左移），但操作数OPRD2的内容不变，最后移出的位保留在进位标志CF中。
如果只移一位，当进位标志和最后的符号位不一致时，置溢出标志OF，否则清OF。
例如：
MOV AX,8321H
MOV DX,5678H
SHLD AX,DX,1
AX=0642H,DX=5678H,CF=1,OF=1
SHLD AX,DX,2
AX=1909H,DX=5678H,CF=0,OF=0
双精度右移指令SHRD的功能是把操作数OPRD1右移指定的m位，空出的位用操作数OPRD2低端的m位填补，
（类似基于OPRD1:OPRD2的右移），但操作数OPRD2的内容不变，最后移出的位保留在进位标志CF中。
当移位位数为1时，OF标志受影响。符号位移位前后不一致时，置溢出标志OF，否则清OF。
例如：
MOV EAX,01234867H
MOV EDX,5ABCDEF9H
SHRD EAX,EDX,4
EAX=90123486H,CF=0,OF=1
SHRD EAX,EDX,8
EAX=F9901234H,CF=1,OF=0
双精度移位指令还影响标志ZF、SF和PF，对AF无定义。
双精度移位指令的实际移位的位数取指令中规定的移位位数m的32位的低5位，所以移位位数的变化范围是0~31。
如果移位的位数是0，那么双精度移位指令就相当于空操作指令NOP。如果移位位数超过被移位操作数OPRD1的长度，
那么操作数OPRD1和各标志均无定义。
如下一条指令可实现把EAX中的32位数，保存到寄存器对DX:AX中：
SHLD EDX,EAX,16
9.3.4控制转移指令
控制转移指令可分为如下四组：转移指令、循环指令、过程调用和返回指令、中断调用和中断返回指令。
这些控制转移指令的非扩展形式的功能保持与8086/8088相同。
由于保护方式下80386的段长可超过64K，所以，这些控制转移指令扩展后涉及的段内偏移可达32位。
在采用32位表示段内偏移时，段间转移的目的地址采用48位全指针形式表示。
但在实方式下，最大的段长仍是64K，因此，即使段内偏移用32位表示，实际的偏移值也禁止超过64K。
1.转移指令组
（1）无条件转移指令
无条件转移指令JMP在分为段内直接、段内间接、段间直接和段间间接四类的同时，还具有扩展形式。
扩展的无条件转移指令的转移目的地址偏移采用32位表示，段间转移目的地址采用48位全指针形式表示。
在实方式下，无条件转移指令JMP的功能几乎没有提高。尽管80386的无条件转移指令允许把32位的段内偏移送到EIP，
但在实方式下段最大64K，段内偏移不能超过64K，所以不需要使用32位的段内偏移。例如：
JMP EAX 有效，但实方式下EAX不能超过64K
在保护方式下，段内无条件转移指令的转移方法未变，但段间无条件转移指令的执行细节较复杂，请参见10.6节。
（2）条件转移指令
80386的条件转移指令（除JCXZ和JECXZ指令外）允许用多字节来表示转移目的地偏移与当前偏移之间的差，
所以转移范围可超出-128~+127。例如：
JNZ OK
......
;超过127字节
OK:......
这一点比8086/8088的条件转移指令的功能强，它使得程序员可不必考虑条件转移的范围。
但在向前引用标号时，如果程序员能够预计到所引用的标号在127的范围之内，
那么，在标号前加上汇编语言操作符SHORT可使汇编程序产生只有一字节地址差的条件转移指令。例如：
CMP EDX,ECX
JBE SHORT OK
XCHG EDX,ECX
OK:
在80386中，当寄存器CX的值为0时，转移的指令JCXZ可以被扩展到JECXZ，例如：
JECXZ OK
它表示当32位寄存器ECX为0时，转移到标号OK处。
但必须注意，指令JCXZ和JECXZ与其他条件转移指令不同，仍只能用一字节表示地址差值，所以转移范围仍是-128~+127。
2.循环指令组
循环指令组含有如下三条指令：LOOP、LOOPZ/LOOPE和LOOPNZ/LOOPNE。
这三条循环指令的非扩展形式保持原功能。它们的扩展形式使用ECX作为计数器，即从CX扩展到ECX。
汇编程序TASM支持使用助记符LOOPD、LOOPDZ/LOOPDE和LOOPDNZ/LOOPDNE，以便明确说明使用ECX作为计数器；
同样，可使用助记符LOOPW、LOOPWZ/LOOPWE和LOOPWNZ/LOOPWNE，以便明确说明使用CX作为计数器。
这三条循环指令的转移范围仍是-128~+127。
如下过程SORT实现了“冒泡”法排序。
；过程名称：SORT
；功能：将缓冲区中的双字有符号数使用冒泡算法进行排序
；人口参数：ESI=缓冲区首地址偏移，ECX=缓冲区中待排序数据的个数（≥2）
；出口参数：缓冲区中已排序好的数据
SORT PROC
DEC ECX
OUTLOOP:MOV EDX,0
INNERLOOP:CMP EDX,ECX
JAE SHORT BOTTOM
MOV EAX,[ESI+EDX*4+4]
CMP [ESI+EDX*4],EAX
JGE SHORT NOSWAP
XCHG [ESI+EDX*4],EAX
MOV [ESI+EDX*4+4],EAX
NOSWAP:INC EDX
JMP INNERLOOP
BOTTOM:LOOP OUTLOOP
RET
SORT ENDP
3.过程调用和返回指令组
过程调用指令CALL在分为段内直接、段内间接、段间直接和段间间接四类的同时，还具有扩展形式。
扩展的调用指令的转移目的地址偏移采用32位表示。对于扩展的段间调用指令，转移目的地址采用48位全指针形式表示，
而且在把返回地址的CS压入堆栈时扩展成高16位为0的双字，这样会压入堆栈2个双字。
过程返回指令RET在分为段内返回和段间返回的同时，还分别具有扩展形式。扩展的过程返回指令要从堆栈弹出双字作为返回地址的偏移。
如果是扩展的段间返回指令，执行时要从堆栈弹出包含48位返回地址全指针的2个双字。
在实方式下主要使用过程调用指令CALL和过程返回指令RET的非扩展形式，它们与8086/8088的CALL指令和RET指令相同。
在保护方式下，段内过程调用指令和返回指令的转移方法未变，但段间过程调用和返回指令的执行细节较复杂，请参见10.6节。
0的阶乘就是1,这是根据正整数的阶乘运算关系扩展而来的.
正整数n的阶乘就是从1×2×……×n这n个数相乘，但是这个定义对0就无效了。
从正整数的阶乘能看出来,(n+1)!÷n!=n+1，所以n!=(n+1)!÷(n+1)。
把这个式子扩展到0上,就得到0!=1!÷1=1÷1=1，就是这样扩展定义的。
0!=1!=1
下列过程FACT的功能是计算n!（n的阶乘），它通过调用递归过程_FACT实现其功能。
；过程名称：FACT
；功能：计算n!
；人口参数：EAX=n
；出口参数：EAX=n!
；说明：如果溢出，那么EAX=-1
FACT PROC
PUSH BX
PUSH ECX
MOV BL,0
MOV ECX,EAX
CMP ECX,0
JL SHORT FACT1
CALL _FACT
CMP BL,1
JNZ SHORT FACT2
FACT1:MOV EAX,-1
FACT2:POP ECX
POP BX
RET
FACT ENDP
_FACT PROC
CMP ECX,0
JZ SHORT _FACT2
PUSH ECX
DEC ECX
CALL _FACT
POP ECX
IMUL EAX,ECX
JNO SHORT _FACT1
MOV BL,1
_FACT1:RET
_FACT2:MOV EAX,1
RET
_FACT ENDP
在4.5节已有一个计算n!的递归过程，请把这里的递归过程与之作比较。
子程序名：FACT
功能：计算n！
入口参数：（AX）=n
出口参数：（AX）=n！
说明：（1）采用递归算法实现求阶乘；
（2）n不能超过8。
FACT PROC
PUSH DX
MOV DX,AX
CMP AX,0
JZ DONE
DEC AX
CALL FACT
MUL DX
POP DX
RET
DONE:MOV AX,1
POP DX
RET
FACT ENDP
该子程序限制入口参数n大小的主要原因，是只采用16位表示阶乘值。
4.中断调用和中断返回指令组
在实方式下，中断调用指令INT的功能与8086/8088的INT指令相同。
在保护方式下，中断调用指令INT把扩展的标志寄存器EFLAG、CS和EIP压入堆栈，也即压入堆栈3个双字，
在压入CS时也扩展到32位，高16位为0。具体执行细节较复杂，在10.7节中说明。
中断返回指令IRET有非扩展和扩展两种形式。在实方式下，总是使用其非扩展形式，其功能与8086/8088的IRET指令相同。
在保护方式下，应该使用其扩展形式，以与保护方式下的中断调用指令相对应。具体执行细节较复杂，在10.7节中说明。
在实方式下，溢出中断调用指令INTO的功能与8086/8088相同。在保护方式下，该指令的执行细节较复杂，请参见10.7节。
9.3.5串操作指令
从80386开始，串操作的基本单位在字节和字的基础上增加了双字。
从80186开始，在8086/8088的5条基本串操作指令的基础上，增加了串输入操作指令INS和串输出操作指令OUTS。
1.基本串操作指令
字节装入指令LODSB把寄存器SI所指向的一个字节数据装入到累加器AL中，然后根据方向标志DF复位或置位使SI之值增1或减1。
字装入指令LODSW把寄存器SI所指向的一个字数据装入到累加器AX中，然后根据方向标志DF复位或置位使SI之值增2或减2。
字节存储指令STOSB把累加器AL的内容送到寄存器DI所指向的存储单元中，然后根据方向标志DF复位或置位使DI之值增1或减1。
字装入指令STOSW把累加器AX的内容送到寄存器DI所指向的存储单元中，然后根据方向标志DF复位或置位使DI之值增2或减2。
字节传送指令MOVSB把寄存器SI所指向的一个字节数据传送到由寄存器DI所指向的存储单元中，
然后根据方向标志DF复位或置位使SI和DI之值分别增1或减1。
字传送指令MOVSW把寄存器SI所指向的一个字数据传送到由寄存器DI所指向的存储单元中，
然后根据方向标志DF复位或置位使SI和DI之值分别增2或减2。
字节扫描指令SCASB把累加器AL的内容与由寄存器DI所指向一个字节数据采用相减方式比较，
相减结果反映到各有关标志位（AF，CF，OF，PF，SF和ZF），但不影响两个操作数，
然后根据方向标志DF复位或置位使DI之值增1或减1。
字扫描指令SCASW把累加器AX的内容与由寄存器DI所指向的一个字数据比较，结果影响标志，然后DI之值增2或减2。
字节比较指令CMPSB把寄存器SI所指向的一个字节数据与由寄存器DI所指向一个字节数据采用相减方式比较，
相减结果反映到各有关标志位（AF，CF，OF，PF，SF和ZF），但不影响两个操作数，
然后根据方向标志DF复位或置位使SI和DI之值分别增1或减1。
字比较指令CMPSW把寄存器SI所指向的一个字数据与由寄存器DI所指向的一个字数据比较，结果影响标志，然后按调整值2调整SI和DI之值。
对应于字节和字为元素的基本串操作指令没变化。对应于双字为元素的基本串操作指令格式如下：
LODSD：串装入指令
STOSD：串存储指令
MOVSD；串传送指令
SCANSD；串扫描指令
CMPSD；串比较指令
其中，LODSD、STOSD和SCANSD指令使用累加器EAX；在DF=0时，每次执行串操作后相应指针加4，在DF=1时，每次串操作后相应指针减4。
这些以双字为元素的基本串操作指令的功能和使用方法与以字节或字为元素的基本串操作指令一样。
它们分别是对应以字为元素的串操作指令的扩展。
在不使用32位指针的情况下，串操作中的源指针是DS:SI，目的指针是ES:DI；
在使用32位指针（地址扩展）的情况下，源指针是DS:ESI，目的指针是ES:EDI。
此外，可以通过段超越前缀的方法改变源串采用的段寄存器，但不能改变目的串的段寄存器。在实方式下，通常使用16位指针。
下面介绍一个简单的位串传送过程SBITBLT。该过程能够把长度为32的倍数的位串传送到指定存储单元开始的缓冲区中，
源串可以从双字中的任意位开始，但目标串必须对齐字节的边界（因为要传送的位串长度为32的倍数）。图9.4是源位串和目标位串的示意图。
；过程名称：SBITBLT
；功能：简单位串传送
；人口参数：DS:ESI=源位串开始单元地址偏移
;                    ES:EDI=目标串开始单元地址偏移
;                    EBX=要传送的位串长度（以双字为单位）
；                 ECX=要传送的位串在源串的第一个双字中的位偏移量
；出口参数：无
；说明：（1）位串长度必须是双字的倍数
；（2）目标位串必须从目标单元的第一个字节的边界处开始
SBITBLT PROC
CLD
MOV EDX,DWORD PTR [ESI]
ADD ESI,4
BITLOOP:LODSD
SHRD EDX,EAX,CL
XCHG EAX,EDX
STOSD
DEC EBX
JNZ BITLOOP
RET
SBITBLT ENDP
双精度左移指令SHLD的功能是把操作数OPRD1左移指定的m位，空出的位用操作数OPRD2高端的m位填补，
（类似基于OPRD1:OPRD2的左移），但操作数OPRD2的内容不变，最后移出的位保留在进位标志CF中。
双精度右移指令SHRD的功能是把操作数OPRD1右移指定的m位，空出的位用操作数OPRD2低端的m位填补，
（类似基于OPRD1:OPRD2的右移），但操作数OPRD2的内容不变，最后移出的位保留在进位标志CF中。
2.重复前缀
重复前缀REP、REPZ/REPE和REPNZ/REPNE，在仍采用16位地址偏移指针的情况下以CX作为重复计数器，
在采用32位地址偏移的扩展情况下以ECX作为重复计数器。由于在实方式下通常采用16位指针，所以一般仍以CX作为计数器。
例如：在80386实方式下执行的如下程序片段将把长度为（CX）字节的数据块从由DS:SI所指向的源区传到由ES:DI所指向的目的区：
实方式下，长度为（CX）字节，此时ECX高16位为0
ROR ECX,2
REP MOVSD
ROL ECX,1
AND CX,0001H
REP MOVSW
ROL ECX,1
AND CX,0001H
REP MOVSB
ROL OPRD,m  把操作数OPRD左循环移m位，每移位一次，操作数左移，其最高位移入最低位，同时最高位也移入进位标志CF
ROR OPRD,m  把操作数OPRD右循环移m位，每移位一次，操作数右移，其最低位移入最高位，同时最低位也移入进位标志CF
3.串输入指令
串输入指令的格式如下：
INSB   输入字节（Byte）
INSW  输入字（Word）
INSD   输入双字（Dword）始于80386
串输入指令从由DX给出端口地址的端口读入一字符，并送入由ES:DI（或EDI）所指的目的串中，
同时根据方向标志DF和字符类型调整DI（或EDI）。
INSB指令对应的字符类型是字节，INSW指令对应的字符类型是字，INSD指令对应的字符类型是双字。
根据输入字符的上述类型，当DF=0时，对目的指针的调整值依次分别是1、2、4；当DF=1时，对目的指针的调整值依次分别是-1、-2、-4。
在汇编语言中，三条串输入指令的格式可统一为如下一种格式：
INS DSTS,DX
汇编程序根据目的串DSTS类型决定使用字节输入指令、字输入指令或双字输入指令。
也即，如果类型为字节，则采用INSB指令；如果类型为字，则采用INSW指令；如果类型是双字，则采用INSD指令。
请注意，目的串DSTS并不影响实际使用指针ES:DI（或EDI）及其值，所以在使用上述格式的串输入指令时，
仍必须先给ES:DI（或EDI）赋合适的值。
串输入指令不影响标志。
在串输入指令前，可使用重复前缀REP，以便连续输入，但必须注意端口的数据准备情况。
4.串输出指令
串输出指令的格式如下
OUTSB   输出字节（Byte）
OUTSW  输出字（Word）
OUTSD   输出双字（Dword）始于80386
串输出指令把由DS:SI（或ESI）所指的源串中的一个字符，输出到由DX给出的端口，同时根据方向标志DF和字符类型调整SI（或ESI）。
OUTSB指令对应的字符类型是字节，OUTSW指令对应的字符类型是字，OUTSD指令对应的字符类型是双字。
根据输入字符的上述类型，当DF=0时，对源指针的调整值依次分别是1、2、4；当DF=1时，对源指针的调整值依次分别是-1、-2、-4。
在汇编语言中，三条串输出指令的格式可统一为如下一种格式：
OUTS DX,SRCS
汇编程序根据源串SRCS类型决定使用字节输出指令、字输出指令或双字输出指令。
也即，如果类型为字节，则采用OUTSB指令；如果类型为字，则采用OUTSW指令；如果类型是双字，则采用OUTSD指令。
请注意，指令中给出的源串并不影响实际使用指针DS:SI（或ESI）及其值，所以在使用上述格式的串输出指令时，仍必须先给DS:SI（或ESI）
赋合适的值。
串输出指令不影响标志。在串输出指令前，可使用重复前缀REP，以便连续输出，但必须注意端口的数据接收处理情况。
9.3.6高级语言支持指令
高级语言支持指令始于80186，它们用于简化支持高级语言的某些特征。共有3条这样的指令，它们是：BOUND、ENTER和LEAVE。
1.建立与释放堆栈框架指令
在C和PASCAL等高级语言中，函数或过程不仅通过堆栈传递入口参数，而且它们的局部变量也被安排在堆栈中，
为了方便地获取入口参数和准确地存取局部变量，就要建立合适的堆栈框架。
对照比较如下的C函数和对应的汇编语言过程，就可看到堆栈框架的建立和使用情况。
为了说明情况而设计的一个简单的C函数sum如下：
sum(int x,int y)
{
int sum;
sum = x+y;
return (sum);
}
对应上面函数sum的汇编语言过程如下：
sum proc near
push bp
mov bp,sp
sub sp,2
mov ax,word ptr [bp+4]
add ax,word ptr [bp+6]
mov word ptr [bp-2],ax
mov ax,word ptr [bp-2]
mov sp,bp
pop bp
ret
sum endp
如果利用始于80186的建立和释放堆栈框架指令ENTER和LEAVE，那么上面的汇编语言过程可优化如下：
sum proc near
enter 2,0
mov ax,word ptr [bp+4]
add ax,word ptr [bp+6]
mov word ptr [bp-2],ax
mov ax,word ptr [bp-2]
leave
ret
sum endp
（1）建立堆栈框架指令ENTER
建立堆栈框架指令ENTER的一般格式如下：
ENTER CNT1,CNT2
其中，操作数CNT1是16位立即数，表示框架的大小，也即子程序需要安排在堆栈中的局部变量所需的字节数；
操作数CNT2是8位立即数，表示子程序嵌套级别，也即需要从外层框架复制到当前框架的指针数。
ENTER 指令有非扩展和扩展两种形式。汇编程序TASM支持使用助记符ENTERW和ENTERD，以便明确说明使用该指令的非扩展形式和扩展形式。
在实方式下，通常使用非扩展形式。
操作数CNT2为0时，非扩展形式的ENTER指令建立堆栈框架时所完成的操作如
①BP进栈，即保存原堆栈框架指针
②BP<=SP
③SP=SP-16位立即数（CNT1）
例如：如下指令建立BP指示的堆栈框架，堆栈顶有4字节的局部变量：
ENTER 4,0
在80386的实方式下，使用该指令的扩展形式，也可建立由EBP指示的堆栈框架。上述操作步骤改变为：
①EBP进栈，即保存原堆栈框架指针
②EBP<=ESP
③SP<=SP-16位立即数（CNT1）
只调整SP的原因是实方式下不使用ESP作为堆栈指针。在80386的保护方式下使用该指令的扩展形式，那么BP和SP寄存器分别扩展为EBP和ESP。
ENTER指令不影响标志。
（2）释放堆栈框架指令LEAVE
释放堆栈框架指令LEAVE的一般格式如下：
LEAVE
指令LEAVE的功能与指令ENTER相反，释放当前子程序（过程）在堆栈中的局部变量，使BP和SP恢复成最近一次的ENTER指令被执行前的值，
具体操作如下：
①SP<=BP
②BP退栈
LEAVE指令也有非扩展和扩展两种形式。汇编程序TASM支持使用助记符LEAVEW和LEAVED，以便明确说明使用该指令的非扩展形式和扩展形式。
在80386的实方式下，使用该指令的扩展形式，那么上述操作步骤改变为：
①SP=BP
②EBP退栈
在80386的保护方式下使用该指令的扩展形式，那么BP和SP寄存器分别扩展为EBP和ESP。
LEAVE指令不影响标志。
注意，指令LEAVE只负责释放堆栈框架，不实现返回，所以在过程中LEAVE指令后还应安排相应的RET指令。
下面的过程利用指令ENTER和LEAVE建立和释放堆栈框架。该过程利用迭代算法计算n!，出入口参数与在9.3.4节中介绍的过程FACT相同，
请作比较。
FACT PROC
ENTER 4,0
CMP EAX,0
JL FACT_LOZ
JE FACT_EQZ
PUSH ECX
MOV ECX,EAX
MOV EAX,1
FACT1:IMUL EAX,ECX
JNO FACT2
JMP FACT_OF
FACT2:DEC ECX
JNZ FACT1
POP ECX
JMP FACT_OK
FACT_OF:POP ECX
MOV EAX,-1
JMP FACT_OK
FACT_EQZ:MOV EAX,1
JMP FACT_OK
FACT_LOZ:MOV EAX,-1
FACT_OK:LEAVE
RET
FACT ENDP
递归计算n!（n的阶乘）
；过程名称：FACT
；功能：计算n!
；人口参数：EAX=n
；出口参数：EAX=n!
；说明：如果溢出，那么EAX=-1
FACT PROC
PUSH BX
PUSH ECX
MOV BL,0
MOV ECX,EAX
CMP ECX,0
JL SHORT FACT1
CALL _FACT
CMP BL,1
JNZ SHORT FACT2
FACT1:MOV EAX,-1
FACT2:POP ECX
POP BX
RET
FACT ENDP
_FACT PROC
CMP ECX,0
JZ SHORT _FACT2
PUSH ECX
DEC ECX
CALL _FACT
POP ECX
IMUL EAX,ECX
JNO SHORT _FACT1
MOV BL,1
_FACT1:RET
_FACT2:MOV EAX,1
RET
_FACT ENDP
2.检查数组下标界限指令BOUND
检查数组下标界限指令BOUND的一般格式如下：
BOUND OPRD1,OPRD2
在80386之前，用于给出待检查数组下标的操作数OPRD1是16位寄存器，用于给出数组下标上下界限的操作数OPRD2是32位存储器操作数，
其中低字含起始下标，高字含结尾下标；从80386开始，OPRD1还可以是32位寄存器，此时OPRD2只能是64位存储器操作数，
其中低双字含起始下标，高双字含结尾下标。
该指令检查由OPRD1给出的有符号数是否在由操作数OPRD2给出的数组界限之内。
如果被检查的下标不在数组允许的范围之内，那么产生类型号为5的异常（中断）。
指令BOUND不影响标志。
例如：
NUM = 100
ARRAY DB NUM DUP (0)
STV DW 0
EDV DW NUM-1
......
BOUND SI,DWORD PTR STV
MOV AL,ARRAY[SI]
......
9.3.7条件字节设置指令
从80386开始新增加了一组条件字节设置指令。这些指令根据一些标志位设置某个字节的内容为1或0。
条件字节设置指令的一般格式如下：
SETcc OPRD
其中，cc是指令助记符的一部分，用于表示条件，这些条件与条件转移指令中的条件相同；
操作数OPRD只能是8位寄存器或者存储单元，用于存放测试的结果。
这些指令的功能是测试指令中规定的条件，若条件为“真”，那么将目的操作数OPRD置成1，否则置成0。
标志名称 溢出 方向 中断 符号 零  辅助进位 奇偶 进位
               OF    DF   IF     SF    ZF  AF   PF    CF
置位状态 OV   DN  EI     NG  ZR  AC   PE    CY
复位状态 NV   UP  DI     PL   NZ  NA  PO   NC
表9.2条件字节设置指令
指令格式         功能说明                                                               测试条件
SETZ OPRD    等于0或者相等时，置OPRD为1                            ZF=1
SETE OPRD
SETNZ OPRD 不等于0或者不相等时，置OPRD为1                     ZF=0
SETNE OPRD
SETS OPRD    为负置OPRD为1                                                   SF=1
SETNS OPRD 不为负置OPRD为1                                                SF=0
SETO OPRD   溢出置OPRD为1                                                   OF=1
SETNO OPRD 不溢出置OPRD为1                                               OF=0
SETP OPRD    偶置OPRD为1                                                      PF=1
SETPE OPRD
SETNP OPRD 奇置OPRD为1                                                      PF=0
SETPO OPRD
SETB OPRD    小于、不大于等于、CF为1置OPRD为1                CF=1
SETNAE OPRD
SETC OPRD
SETNB OPRD 不小于、大于等于、CF为0置OPRD为1                CF=0
SETAE OPRD
SETNC OPRD
SETBE OPRD 小于等于、不大于置OPRD为1                              (CF或ZF)=1
SETNA OPRD
SETNBE OPRD 不小于等于、大于置OPRD为1                           (CF或ZF)=0
SETA OPRD
SETL OPRD   小于、不大于等于置OPRD为1                              (SF异或OF)=1
SETNGE OPRD
SETNL OPRD 不小于、大于等于置OPRD为1                             (SF异或OF)=0
SETGE OPRD
SETLE OPRD  小于等于、不大于置OPRD为1                            ((SF异或OF)或ZF)=1
SETNG OPRD
SETNLE OPRD 不小于等于、大于置OPRD为1                          ((SF异或OF)或ZF)=0
SETG OPRD
例如：
SETO AL
当标志OF=1时，把AL置1，否则AL清0
SETNC CH
当标志CF=0时，把CH置1，否则CH清0
条件字节设置指令与条件转移指令一样，并且测试条件的方法也相同，只是在条件满足时，设置某个字节而已。
这些条件字节设置指令共有16条，列于表9.2，为了便于记忆和使用，有些指令有多个助记符。
这些条件字节设置指令也可像条件转移指令那样分为三类。
这些条件字节设置指令不影响各标志。
例如：如下程序片段测试含于寄存器EAX中的八位16进制数是否有一位为0（BH=0表示没有一位是0）：
MOV BH,0
MOV CX,8
NEXT:TEST AL,0FH
SETZ BL
OR BH,BL
ROR EAX,4
LOOP NEXT
例如：如下程序片段统计DS:SI所指向的单字节数据缓冲区中正数和负数的个数（设缓冲区以0结尾）：
CLD
XOR DX,DX
NEXT:LODSB
CMP AL,0
JZ SHORT OVER
SETG BL
SETL BH
ADD DL,BL
ADD DH,BH
JMP NEXT
OVER:
......
9.3.8位操作指令
从80386开始增加了位操作指令。这些位操作指令可以直接对一个二进制位进行测试、设置和扫描等操作。
利用这些指令可以更有效地进行位操作。位操作指令可分为位扫描指令组和位测试及设置指令组。
1.位测试及设置指令组
位测试和设置指令组含有如下4条指令：位测试（Bit Test）指令BT、位测试并取反（Bit Test and Complement）指令BTC、
位测试并复位（Bit Test and Reset）指令BTR和位测试并置位（Bit Test and Set）指令BTS。
这4条位测试和设置指令的格式如下：
BT OPRD1,OPRD2
BTC OPRD1,OPRD2
BTR OPRD1,OPRD2
BTS OPRD1,OPRD2
其中，操作数OPRD1可以是16位或32位通用寄存器和16位或32位存储单元，用于指定要测试的内容；
操作数OPRD2必须是8位立即数或者与操作数OPRD1长度相等的通用寄存器，用于指定要测试的位。
设操作数OPRD2除以操作数OPRD1的长度后所得商是disp，所得余数是offset。那么这些指令要测试的位是根据如下方法确定的：
如果操作数OPRD1是寄存器，offset是寄存器操作数OPRD1中要测试位的位号；
如果操作数OPRD1是存储单元，存储器操作数OPRD1的偏移与disp相加之和是实际测试存储单元的偏移，offset是该存储单元中要测试位的位号。
操作数OPRD2取符号整数值，所以当OPRD2为16位时，可访问（-32K）至（32K-1）范围内的位串，
当OPRD2是32位时，可访问（-2G）至（2G-1）范围内的位串。
位测试指令BT的功能是把被测试位的值送标志位CF。
位测试并取反指令BTC的功能是把被测试位的值送标志CF，并且把被测试位取反。
位测试并复位指令BTR的功能是把被测试位的值送标志CF，并且把被测试位复位，也即清0。
位测试并置位指令BTS的功能是把被测试位的值送标志CF，并且把被测试位置位，也即置1。
其它标志ZF、SF、OF、AF和PF无定义。
EAX
位号31      位号0
BX
位号15      位号0
例如：
MOV BX,4567H
MOV ECX,3
BT BX,CX
CF=0，BX=4567H
BTC BX,3
CF=0，BX=456FH
BTR BX,CX
CF=1，BX=4567H
BTS EBX,ECX
CF=0，BX=456FH
假设数据段有如下变量：
IMAGEW DW 1234H,5678H
IMAGED DD 12345678H
符号扩展指令
MOVSX DST,SRC 把源操作数SRC的内容送到目的操作数DST，目的操作数空出的位用源操作数的符号位填补。
零扩展指令
MOVZX DST,SRC 把源操作数SRC的内容送到目的操作数DST，目的操作数空出的位用零填补。
符号扩展指令和零扩展指令中的目的操作数DST必须是16位或32位寄存器，源操作数SRC可以是8位或16位寄存器，
也可以是8位或16位存储器操作数。如果源操作数和目的操作数都是字，那么就相当于MOV指令。
代码段有如下指令（设已置妥DS）：
BT IMAGEW,4
CF=1，[IMAGEW]=1234H
MOV CX,22
BTC IMAGEW,CX
CF=1，[IMAGEW+2]=5638H
BTR IMAGED,6
CF=1，[IMAGED]=12345638H
MOVZX EAX,CX
EAX=22
BTS IMAGED,EAX
CF=0，[IMAGED]=12745678H
要特别指出，在这些位测试指令中，如果用于指定测试位号的操作数OPRD2是立即数，那么其值不应超过被测试操作数OPRD1的长度，
否则将产生未定义的位偏移量。这个规则允许规定在一个寄存器内的任何位移量，
而且将存储器位串中的立即数位移量限制在规定存储单元字或双字之内。
但汇编程序可以支持对于内存位串的更大的立即数位偏移量，汇编程序可将该立即数位移量的低5位（对于32位操作数）或
低4位（对于16位操作数）作为机器指令中的操作数OPRD2，将该立即数位移量的相应高位右移后加到内存位串开始单元的偏移上，
作为机器指令中的操作数OPRD1。
例如：如下程序片段把寄存器AL的位0、2、4、6依次重复一次，所得的8位数保存在寄存器AL中
MOV DL,0
MOV CX,4
MOV BX,0
NEXT:BT AX,BX
SETC AH
OR DL,AH
ROR DL,1
OR DL,AH
ROR DL,1
INC BX
INC BX
LOOP NEXT
MOV AL,DL
2.位扫描指令组
位扫描指令组含有如下2条指令：顺向位扫描（Bit Scan Forward）指令BSF和逆向位扫描（Bit Scan Reverse）指令BSR。
这两条位扫描指令的格式如下：
BSF OPRD1,OPRD2
BSR OPRD1,OPRD2
其中，操作数OPRD1和OPRD2可以是16或32位通用寄存器和16位或32位存储单元；但操作数OPRD1和OPRD2的位数（长度）必须相等。
顺向位扫描指令BSF的功能是从右向左（位0~位15或位31）扫描字或者双字操作数OPRD2中第一个含“1”的位，
并把扫描到的第一个含“1”的位的位号送操作数OPRD1。
逆向位扫描指令BSR的功能是从左向右（位15或位31~位0）扫描字或者双字操作数OPRD2中第一个含“1”的位，
并把扫描到的第一个含“1”的位的位号送操作数OPRD1。
如果字或双字操作数OPRD2等于0，那么零标志ZF被置1，操作数OPRD1的值不确定；否则零标志ZF被清0。
其它标志CF、SF、OF、AF和PF无定义。
例如：
MOV EBX,12345678H
BSR EAX,EBX
EAX=1CH,ZF=0
BSF DX,AX
DX=2,ZF=0
BSF CX,DX
CX=1,ZF=0
例如：如下程序片段处理AX中的16位，仅保留可能有的最右和最左各一位为“1”的位：
XOR DX,DX
BSF CX,AX
JZ SHORT DONE
BTS DX,CX
BSR CX,AX
JZ SHORT DONE
BTS DX,CX
DONE:MOV AX,DX
9.3.9处理器控制指令
处理器控制指令用于设置标志、空操作和与外部事件同步等。这里介绍的处理器控制指令都始于8086/8088。
CLC 使进位标志为0
STC 使进位标志为1
CMC 使进位标志取反，如CF为1，则使CF为0；如CF为0，则CF为1
CLD 使方向标志DF为0
STD 使方向标志DF为1
CLI 使中断允许标志IF为0，不响应来自外部装置的可屏蔽中断，对不可屏蔽中断和内部中断没有影响
STI 使中断允许标志IF为1，可以响应来自外部装置的可屏蔽中断
1.设置标志指令组
设置进位标志CF的指令CLC、STC和CMC保持与原先相同。
设置方向标志DF的指令CLD和STD保持与原先相同。
设置中断允许标志IF的指令CLI和STI的功能在实方式下保持与原先相同。在保护方式下它们是I/O敏感指令，请参见10.9节。
2.空操作指令
空操作指令NOP的一般格式如下：
NOP
空操作指令的功能是什么都不做。该指令就一个字节的操作码。利用该指令可“填补程序中的空白区”，使代码保持连续。
3.外同步指令和前缀
（1）等待指令WAIT
等待指令WAIT的一般格式如下：
WAIT
该指令的功能是等待直到BUSY引脚为高。BUSY由数值协处理器控制，所以该指令的功能是等待数值协处理器，以便与它同步。
该指令也能够检查数值协处理器是否故障，请参见10.7.2节。
（2）封锁前缀LOCK
封锁前缀LOCK可以锁定其后指令的目的操作数确定的存储单元，这是通过使LOCK信号在指令执行期间一直保持有效而实现的。
在多处理器环境中，使用这种方法可以保证指令执行时独占共享内存。
NEG OPRD 对操作数取补，就是用零减去操作数OPRD，再把结果送回OPRD，也即：OPRD=0-OPRD
只有下列指令才能用封锁前缀LOCK，并且目的操作数是存储器操作数：
XCHG
ADD，ADC，INC，SUB，SBB，DEC，NEG
OR，AND，XOR，NOT
BT，BTS，BTR，BTC
例如：
LOCK BTC [EBX],EAX
LOCK XCHG [BX],AX
BT OPRD1,OPRD2
BTC OPRD1,OPRD2
BTR OPRD1,OPRD2
BTS OPRD1,OPRD2
其中，操作数OPRD1可以是16位或32位通用寄存器和16位或32位存储单元，用于指定要测试的内容；
操作数OPRD2必须是8位立即数或者与操作数OPRD1长度相等的通用寄存器，用于指定要测试的位。
9.4实方式下的程序设计
在实方式下，80386相当于一个可进行32位处理的快速8086。为80386编写的程序可利用32位的通用寄存器，可使用新增的指令，
可采用扩展的寻址方式。段的最大长度是64K，但不像真正的8086，当所存取的存储单元的地址偏移超过0FFFFH时，
不会引起模64K的地址反绕，而是导致段越界异常。
所以，在实方式下运行的程序访问的存储单元的地址偏移不能超过0FFFFH，转移的目的地址偏移也不能超过0FFFFH。
9.4.1说明
1.说明处理器类型的伪指令
在缺省情况下，MASM和TASM仅识别8086/8088的指令。
为了让MASM或TASM识别由80186、80286和80386等新增的指令或功能增强的指令，须告诉汇编程序处理器的类型。
汇编语言提供了如下说明处理器类型的伪指令，这些伪指令均以句点引导：
.8086  只支持对8086指令的汇编
.186    支持对80186指令的汇编
.286    支持对非特权80286指令的汇编
.286C  支持对非特权80286指令的汇编
.286P  支持对80286所有指令的汇编
.386    支持对80386非特权指令的汇编
.386C  支持对80386非特权指令的汇编
.386P  支持对80386所有指令的汇编
汇编程序在遇到说明处理器类型的伪指令后，就识别并汇编相应的指令。
在一个源程序中，可根据需要安排多条说明处理器类型的伪指令，以便更改对处理器类型的说明。
对TASM而言，这些伪指令可以安排在源程序中的任何位置。但对MASM而言，上述说明处理器类型的伪指令必须安排在段外。
只有在使用说明处理器类型是80386的伪指令后，汇编程序才识别表示32位寄存器的符号和表示始于80386的指令的助记符。
如果执行目标程序的CPU是8088或8086，那么就不能指示汇编程序按其他处理器类型（80186、80286和80386等）来汇编源程序；
类似地，如果执行目标程序的CPU是80286，那么就不能指示汇编程序按80386处理器来汇编源程序。
2.关于段属性类型的说明
在实方式下，80386保持与原先的8086/8088兼容，所以段的最大长度仍是64K，这样的段称为16位段。
但在保护方式下，段长度可达4G，这样的段称为32位段。为了兼容，在保护方式下，也可使用16位段。
在8.1.1节中介绍了段的定义，段定义语句带有可选的定位类型、组合类型和类别。
此外，还有可选的段属性类型说明，用于指示是16位段，还是32位段。完整段定义的一般格式如下：
段名 SEGMENT [定位类型][组合类型]['类别'][属性类型]
属性类型说明符号是"USE16"和"USE32"。USE16表示16位段，USE32表示32位段。
在使用".386"等伪指令指示处理器类型80386后，缺省的属性类型是USE32；如果没有指示处理器类型80386，那么缺省的属性类型是USE16。
例如：如下语句说明一个32位段：
CSEG SEGMENT PARA USE32
......
CSEG ENDS
例如：如下语句说明一个16位段：
CSEG SEGMEN PARA USE16
......
CSEG ENDS
注意，在实方式下运行的程序，只能使用16位段；此外，总是使用16位段的堆栈，也总是使用SP作为堆栈指针。
3.操作数和地址长度前缀
尽管在实方式下只能使用16位段，但可使用32位操作数，也可使用以32位形式表示的存储单元地址，
这是利用操作数长度前缀66H和存储器地址长度前缀67H来表示的。
在16位代码段中，正常操作数的长度是16位或8位。在指令前加上操作数长度前缀66H后，操作数长度就成为32位或8位，
也即原来表示16位操作数的代码成为表示32位操作数的代码。一般情况下，不在源程序中直接使用操作数长度前缀，而是直接使用32位操作数，
操作数长度前缀由汇编程序在汇编时自动加上。
请注意比较如下在16位代码段中的汇编格式指令和对应的机器码（注释部分）：
.386
TEST16 SEGMENT PARA USE16
......
MOV EAX,EBX  对应的机器指令 66H,8BH,C3H
MOV AX,BX     对应的机器指令         8BH,C3H
MOV AL,BL      对应的机器指令         8AH,C3H
......
TEST16 ENDS
32位代码段的情况刚好相反。在32位代码段中，正常操作数长度是32位或8位。
在指令前加上操作数长度前缀66H后，操作数长度就成为16位或8位。
不在32位代码的源程序中直接使用操作数长度前缀66H表示使用16位操作数，而是直接使用16位操作数，
操作数长度前缀由汇编程序在汇编时自动加上。
请注意比较如下在32位代码段中的汇编格式指令和对应的机器码（注释部分）：
.386
TEST32 SEGMENT PARA USE32
......
MOV EAX,EBX   对应的机器指令        8BH,C3H
MOV AX,BX      对应的机器指令 66H,8BH,C3H
......
TEST32 ENDS
通过存储器地址长度前缀67H区分32位存储器地址和16位存储器地址的方法与上述通过
操作数长度前缀66H区分32位操作数和16位操作数的方法类似。在源程序中可根据需要使用32位地址，或者16位地址。
汇编程序在汇编源程序时，对于16位的代码段，在使用32位存储器地址的指令前加上前缀67H；对于32位代码段，
在使用16位存储器地址的指令前加上前缀67H。
在一条指令前可能既有操作数长度前缀66H，又有存储器地址长度前缀67H。
PUSHAD指令将所有8个通用寄存器（32位）内容压入堆栈，其顺序是：EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI，
然后堆栈指针寄存器ESP之值减32，所以ESP进栈的内容是PUSHAD执行之前的值。
POPAD指令从堆栈弹出内容以PUSHAD相反的顺序送到这些通用寄存器，从而恢复PUSHAD之前的寄存器内容。
但堆栈指针寄存器SP之值不是由堆栈弹出，而是通过增加32来恢复。
BSF OPRD1,OPRD2
BSR OPRD1,OPRD2
BSF的功能是从右向左（位0~位15或位31）扫描字或者双字操作数OPRD2中第一个含“1”的位，
并把扫描到的第一个含“1”的位的位号送操作数OPRD1。
BSR的功能是从左向右（位15或位31~位0）扫描字或者双字操作数OPRD2中第一个含“1”的位，
并把扫描到的第一个含“1”的位的位号送操作数OPRD1。
如果字或双字操作数OPRD2等于0，那么零标志ZF被置1，操作数OPRD1的值不确定；否则零标志ZF被清0。
9.4.2实例
下面举两个例子，介绍如何编写在80386实方式下运行的程序，侧重于80386指令的应用，而不是算法的优化。
例1：写一个程序，以十进制、十六进制和二进制数三种形式显示双字存储单元F000:1234H的内容。
如下程序实现上述功能，并且在以三种形式显示时，都滤去了前导的0。
；程序名：T9-1.ASM
；功能：（略）
.386
CSEG SEGMENT USE16
ASSUME CS:CSEG
START:MOV AX,0F000H
MOV FS,AX
MOV EAX,FS:[1234H]
CALL TODEC
CALL NEWLINE
CALL TOHEX
MOV AL,'H'
CALL ECHO
CALL NEWLINE
MOV EAX,FS:[1234H]
CALL TOBIN
MOV AL,'B'
CALL ECHO
CALL NEWLINE
MOV AH,4CH
INT 21H
TODEC PROC NEAR
PUSHAD
MOV EBX,10
XOR CX,CX
DEC1:XOR EDX,EDX
DIV EBX
PUSH DX
INC CX
OR EAX,EAX
JNZ DEC1
DEC2:POP AX
CALL TOASC
CALL ECHO
LOOP DEC2
POPAD
RET
TODEC ENDP
TOBIN PROC NEAR
PUSH EAX
PUSH ECX
PUSH EDX
BSR EDX,EAX
JNZ BIN1
XOR DX,DX
BIN1:MOV CL,31
SUB CL,DL
SHL EAX,CL
MOV CX,DX
INC CX
MOV EDX,EAX
BIN2:ROL EDX,1
MOV AL,'0'
ADC AL,0
CALL ECHO
LOOP BIN2
POP EDX
POP ECX
POP EAX
RET
TOBIN ENDP
TOHEX PROC NEAR
ENTER 8,0
MOVZX EBP,BP
MOV ECX,8
MOV EDX,EAX
HEX1:MOV AL,DL
AND AL,0FH
MOV [EBP-8+ECX-1],AL
ROR EDX,4
LOOP HEX1
MOV CX,8
XOR EBX,EBX
HEX2:CMP BYTE PTR [EBP-8+EBX],0
JNZ HEX3
INC EBX
LOOP HEX2
DEC EBX
MOV CX,1
HEX3: MOV AL,[EBP-8+EBX]
INC EBX
CALL TOASC
CALL ECHO
LOOP HEX3
LEAVE
RET
TOHEX ENDP
TOASC PROC NEAR
AND AL,0FH
ADD AL,'0'
CMP AL,'9'
SETA DL
MOVZX DX,DL
IMUL DX,7
ADD AL,DL
TOASC1:RET
TOASC ENDP
NEWLINE PROC NEAR
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
ECHO PROC NEAR
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
ECHO ENDP
CSEG ENDS
END START
测试通过的完整程序如下
.386
CSEG SEGMENT USE16
ASSUME CS:CSEG
START:MOV AX,0F000H
MOV FS,AX
MOV EAX,FS:[1234H]
CALL TODEC
CALL NEWLINE
CALL TOHEX
MOV AL,'H'
CALL ECHOCH
CALL NEWLINE
MOV EAX,FS:[1234H]
CALL TOBIN
MOV AL,'B'
CALL ECHOCH
CALL NEWLINE
MOV AH,4CH
INT 21H
TODEC PROC NEAR
PUSHAD
MOV EBX,10
XOR CX,CX
DEC1:XOR EDX,EDX
DIV EBX
PUSH DX
INC CX
OR EAX,EAX
JNZ DEC1
DEC2:POP AX
CALL TOASC
CALL ECHOCH
LOOP DEC2
POPAD
RET
TODEC ENDP
TOBIN PROC NEAR
PUSH EAX
PUSH ECX
PUSH EDX
BSR EDX,EAX
JNZ BIN1
XOR DX,DX
BIN1:MOV CL,31
SUB CL,DL
SHL EAX,CL
MOV CX,DX
INC CX
MOV EDX,EAX
BIN2:ROL EDX,1
MOV AL,'0'
ADC AL,0
CALL ECHOCH
LOOP BIN2
POP EDX
POP ECX
POP EAX
RET
TOBIN ENDP
TOHEX PROC NEAR
ENTER 8,0
MOVZX EBP,BP
MOV ECX,8
MOV EDX,EAX
HEX1:MOV AL,DL
AND AL,0FH
MOV [EBP+ECX-9],AL
ROR EDX,4
LOOP HEX1
MOV CX,8
XOR EBX,EBX
HEX2:CMP BYTE PTR [EBP+EBX-8],0
JNZ HEX3
INC EBX
LOOP HEX2
DEC EBX
MOV CX,1
HEX3: MOV AL,[EBP+EBX-8]
INC EBX
CALL TOASC
CALL ECHOCH
LOOP HEX3
LEAVE
RET
TOHEX ENDP
TOASC PROC NEAR
AND AL,0FH
ADD AL,'0'
CMP AL,'9'
SETA DL
MOVZX DX,DL
IMUL DX,7
ADD AL,DL
TOASC1:RET
TOASC ENDP
NEWLINE PROC NEAR
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
ECHOCH PROC NEAR
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
ECHOCH ENDP
CSEG ENDS
END START
例2：写一个程序，把以十进制数、十六进制数或二进制数形式输入的两个无符号整数相乘，用十进制数显示乘积。
如下程序实现上述功能，输入的两个整数最大以32位表示，超过认为溢出。当输入的数无效时，显示符号”x”，允许重新输入。
十六进制数以符号H结尾，二进制数以符号B结尾，十进制数也可以符号D结尾。
输入字符串（0AH号功能调用）
会把当前输入的内容回显在标准输出设备上
功能：从标准输入上读一个字符串。通常情况下，标准输入就是键盘。
入口参数：DS:DX=缓冲区首地址。
出口参数：接收到的输入字符串在缓冲区中。
说明：（1）缓冲区第一字节置为缓冲区最大容量，可认为是入口参数；
缓冲区第二字节存放实际读入的字符数（不包括回车符），可认为是出口参数的一部分；第三字节开始存放接受的字符串。
（2）字符串以回车键结束，回车符是接受到的字符串的最后一个字符。也就是0DH 回车，不包含0AH 换行
（3）如果输入的字符数超过缓冲区所能容纳的最大字符数，则随后的输入字符被丢弃并且响铃，直到遇回车键为止。
（4）如果在输入时按Ctrl+C或Ctrl+Break键，则结束程序。
；程序名：T9-2.ASM
；功能：（略）
.386
CSEG SEGMENT USE16
ASSUME CS:CSEG
LTODEC PROC NEAR
XOR CX,CX
LTODEC1:MOV EBX,10
CALL DIVX
PUSH BX
INC CX
MOV EBX,EDX
OR EBX,EAX
JNZ LTODEC1
LTODEC2:POP AX
AND AL,0FH
ADD AL,'0'
CALL ECHO
LOOP LTODEC2
RET
LTODEC ENDP
DIVX PROC NEAR
PUSH ECX
PUSH ESI
MOV CX,64
XOR ESI,ESI
DIVX1:SHL EAX,1
RCL EDX,1
RCL ESI,1
JC SHORT DIVX2
CMP ESI,EBX
JB SHORT DIVX3
DIVX2:SUB ESI,EBX
BTS AX,0
DIVX3:LOOP DIVX1
MOV EBX,ESI
POP ESI
POP ECX
RET
DIVX ENDP
GETVAL PROC NEAR
ENTER 36,0
PUSH ECX
PUSH EDX
PUSH DS
PUSH ES
MOV AX,SS
MOV DS,AX
MOV ES,AX
LEA EDX,[BP-36]
MOV BYTE PTR [EDX],34
MOV AH,10
INT 21H
CALL NEWLINE
INC EDX
MOV CL,[EDX]
XOR CH,CH
MOVZX ECX,CX
INC ECX
GETVAL1:DEC ECX
INC EDX
CMP BYTE PTR [EDX],20H
JZ GETVAL1
MOV BL,0
JECXZ GETVAL5
GETVAL2:CMP BYTE PTR [EDX+ECX-1],20H
LOOPZ GETVAL2
SETNZ AL
ADD CL,AL
JECXZ GETVAL5
MOV BL,-1
MOV AL,[EDX+ECX-1]
CMP AL,'0'
JB SHORT GETVAL5
CMP AL,'9'
JA SHORT GETVAL3
GETVAL2A:CALL DSTOV
JMP SHORT GETVAL5
GETVAL3:BTR AX,5
CMP AL,'D'
JNZ GETVAL3A
DEC ECX
JMP GETVAL2A
GETVAL3A:CMP AL,'H'
JNZ GETVAL4
DEC ECX
CALL HSTOV
JMP SHORT GETVAL5
GETVAL4:CMP AL,'B'
JNZ SHORT GETVAL5
DEC ECX
CALL BSTOV
GETVAL5:POP ES
POP DS
POP EDX
POP ECX
LEAVE
RET
GETVAL ENDP
DSTOV PROC NEAR
PUSH ESI
MOV ESI,EDX
MOV BL,0
JCXZ DSTOV3
MOV BL,-1
XOR EAX,EAX
MOV EDX,10
PUSH EDX
DSTOV1:MOV DL,[ESI]
INC ESI
CMP DL,'0'
JB SHORT DSTOV2
CMP DL,'9'
JA SHORT DSTOV2
AND DL,0FH
PUSH EDX
MUL DWORD PTR [ESP+4]
OR DL,DL
POP EDX
JNZ SHORT DSTOV2
ADD EAX,EDX
JC DSTOV2
LOOP DSTOV1
MOV BL,1
DSTOV2:POP EDX
DSTOV3:POP ESI
RET
DSTOV ENDP
HSTOV PROC NEAR
PUSH ESI
MOV BL,0
JCXZ HSTOV4
MOV BL,-1
XOR EAX,EAX
XOR ESI,ESI
HSTOV1:MOV AL,[EDX]
INC EDX
BTS AX,5
CMP AL,'0'
JB SHORT HSTOV2
CMP AL,'9'
JA SHORT HSTOV2
AND AL,0FH
JMP SHORT HSTOV3
HSTOV2:CMP AL,'a'
JB SHORT HSTOV4
CMP AL,'f'
JA SHORT HSTOV4
SUB AL,'a'-10
HSTOV3:TEST ESI,0F0000000H
JNZ SHORT HSTOV4
SHL ESI,4
ADD ESI,EAX
LOOP HSTOV1
MOV BL,1
HSTOV4:MOV EAX,ESI
POP ESI
RET
HSTOV ENDP
BSTOV PROC NEAR
PUSH ESI
MOV BL,0
JCXZ BSTOV2
MOV BL,-1
XOR EAX,EAX
XOR ESI,ESI
XCHG EDX,ESI
BSTOV1:MOV AL,[ESI]
INC ESI
CMP AL,'0'
JB SHORT BSTOV2
CMP AL,'1'
JA SHORT BSTOV2
AND AL,0FH
BT EDX,31
JC SHORT BSTOV2
SHL EDX,1
ADD EDX,EAX
LOOP BSTOV1
MOV BL,1
BSTOV2:MOV EAX,EDX
POP ESI
RET
BSTOV ENDP
TOASC PROC NEAR
AND AL,0FH
ADD AL,'0'
CMP AL,'9'
SETA DL
MOVZX DX,DL
IMUL DX,7
ADD AL,DL
TOASC1:RET
TOASC ENDP
NEWLINE PROC NEAR
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
ECHOCH PROC NEAR
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
ECHOCH ENDP
CSEG ENDS
CSEG SEGMENT USE16
ASSUME CS:CSEG
START:MOV CX,2
@@1:MOV AL,':'
CALL ECHOCH
CALL GETVAL
CMP BL,0
JZ OVER
CMP BL,1
JZ SHORT @@2
MOV AL,'x'
CALL ECHOCH
CALL NEWLINE
JMP @@1
@@2:PUSH EAX
LOOP @@1
MOV AL,'='
CALL ECHOCH
POP EAX
POP EDX
MUL EDX
CALL LTODEC
CALL NEWLINE
CALL NEWLINE
JMP START
OVER:MOV AH,4CH
INT 21H
CSEG ENDS
END START
测试通过的完整程序如下
.386
CSEG SEGMENT USE16
ASSUME CS:CSEG
LTODEC PROC NEAR
XOR CX,CX
LTODEC1:MOV EBX,10
CALL DIVX
PUSH BX
INC CX
MOV EBX,EDX
OR EBX,EAX
JNZ LTODEC1
LTODEC2:POP AX
AND AL,0FH
ADD AL,'0'
CALL ECHOCH
LOOP LTODEC2
RET
LTODEC ENDP
DIVX PROC NEAR
PUSH ECX
PUSH ESI
MOV CX,64
XOR ESI,ESI
DIVX1:SHL EAX,1
RCL EDX,1
RCL ESI,1
JC SHORT DIVX2
CMP ESI,EBX
JB SHORT DIVX3
DIVX2:SUB ESI,EBX
BTS AX,0
DIVX3:LOOP DIVX1
MOV EBX,ESI
POP ESI
POP ECX
RET
DIVX ENDP
GETVAL PROC NEAR
ENTER 36,0
PUSH ECX
PUSH EDX
PUSH DS
PUSH ES
MOV AX,SS
MOV DS,AX
MOV ES,AX
LEA EDX,[BP-36]
MOV BYTE PTR [EDX],34
MOV AH,10
INT 21H
CALL NEWLINE
INC EDX
MOV CL,[EDX]
XOR CH,CH
MOVZX ECX,CX
INC ECX
GETVAL1:DEC ECX
INC EDX
CMP BYTE PTR [EDX],20H
JZ GETVAL1
MOV BL,0
JECXZ GETVAL5
GETVAL2:CMP BYTE PTR [EDX+ECX-1],20H
LOOPZ GETVAL2
SETNZ AL
ADD CL,AL
JECXZ GETVAL5
MOV BL,-1
MOV AL,[EDX+ECX-1]
CMP AL,'0'
JB SHORT GETVAL5
CMP AL,'9'
JA SHORT GETVAL3
GETVAL2A:CALL DSTOV
JMP SHORT GETVAL5
GETVAL3:BTR AX,5
CMP AL,'D'
JNZ GETVAL3A
DEC ECX
JMP GETVAL2A
GETVAL3A:CMP AL,'H'
JNZ GETVAL4
DEC ECX
CALL HSTOV
JMP SHORT GETVAL5
GETVAL4:CMP AL,'B'
JNZ SHORT GETVAL5
DEC ECX
CALL BSTOV
GETVAL5:POP ES
POP DS
POP EDX
POP ECX
LEAVE
RET
GETVAL ENDP
DSTOV PROC NEAR
PUSH ESI
MOV ESI,EDX
MOV BL,0
JCXZ DSTOV3
MOV BL,-1
XOR EAX,EAX
MOV EDX,10
PUSH EDX
DSTOV1:MOV DL,[ESI]
INC ESI
CMP DL,'0'
JB SHORT DSTOV2
CMP DL,'9'
JA SHORT DSTOV2
AND DL,0FH
PUSH EDX
MUL DWORD PTR [ESP+4]
OR DL,DL
POP EDX
JNZ SHORT DSTOV2
ADD EAX,EDX
JC DSTOV2
LOOP DSTOV1
MOV BL,1
DSTOV2:POP EDX
DSTOV3:POP ESI
RET
DSTOV ENDP
HSTOV PROC NEAR
PUSH ESI
MOV BL,0
JCXZ HSTOV4
MOV BL,-1
XOR EAX,EAX
XOR ESI,ESI
HSTOV1:MOV AL,[EDX]
INC EDX
BTS AX,5
CMP AL,'0'
JB SHORT HSTOV2
CMP AL,'9'
JA SHORT HSTOV2
AND AL,0FH
JMP SHORT HSTOV3
HSTOV2:CMP AL,'a'
JB SHORT HSTOV4
CMP AL,'f'
JA SHORT HSTOV4
SUB AL,'a'-10
HSTOV3:TEST ESI,0F0000000H
JNZ SHORT HSTOV4
SHL ESI,4
ADD ESI,EAX
LOOP HSTOV1
MOV BL,1
HSTOV4:MOV EAX,ESI
POP ESI
RET
HSTOV ENDP
BSTOV PROC NEAR
PUSH ESI
MOV BL,0
JCXZ BSTOV2
MOV BL,-1
XOR EAX,EAX
XOR ESI,ESI
XCHG EDX,ESI
BSTOV1:MOV AL,[ESI]
INC ESI
CMP AL,'0'
JB SHORT BSTOV2
CMP AL,'1'
JA SHORT BSTOV2
AND AL,0FH
BT EDX,31
JC SHORT BSTOV2
SHL EDX,1
ADD EDX,EAX
LOOP BSTOV1
MOV BL,1
BSTOV2:MOV EAX,EDX
POP ESI
RET
BSTOV ENDP
TOASC PROC NEAR
AND AL,0FH
ADD AL,'0'
CMP AL,'9'
SETA DL
MOVZX DX,DL
IMUL DX,7
ADD AL,DL
TOASC1:RET
TOASC ENDP
NEWLINE PROC NEAR
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
ECHOCH PROC NEAR
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
ECHOCH ENDP
CSEG ENDS
CSEG SEGMENT USE16
ASSUME CS:CSEG
START:MOV CX,2
@@1:MOV AL,':'
CALL ECHOCH
CALL GETVAL
CMP BL,0
JZ OVER
CMP BL,1
JZ SHORT @@2
MOV AL,'x'
CALL ECHOCH
CALL NEWLINE
JMP @@1
@@2:PUSH EAX
LOOP @@1
MOV AL,'='
CALL ECHOCH
POP EAX
POP EDX
MUL EDX
CALL LTODEC
CALL NEWLINE
CALL NEWLINE
JMP START
OVER:MOV AH,4CH
INT 21H
CSEG ENDS
END START
数值传送指令MOV、符号扩展指令MOVSX、零扩展指令MOVZX、交换指令XCHG、
进栈指令PUSH、PUSHA、PUSHAD、退栈指令POP、POPA和POPAD。
数值传送指令MOV的格式、功能和使用注意点都与8086/8088的MOV指令相同，传送的数据可以是8位、16位或32位。
符号扩展指令的格式如下：
MOVSX DST,SRC
该指令的功能是把源操作数SRC的内容送到目的操作数DST，目的操作数空出的位用源操作数的符号位填补。
零扩展指令的格式如下：
MOVZX DST,SRC
该指令的功能是把源操作数SRC的内容送到目的操作数DST，目的操作数空出的位用零填补。
符号扩展指令和零扩展指令中的目的操作数DST必须是16位或32位寄存器，源操作数SRC可以是8位或16位寄存器、8位或16位存储器操作数。
交换指令XCHG的格式、功能和使用注意点都与8086/8088的XCHG指令相同，交换的数据可以是8位、16位或32位。
进栈指令PUSH的格式没变，但功能增强了。从80186开始，压入堆栈的操作数还可以是立即数。
从80386开始操作数长度还可以达32位，当然如果操作数长度是32位，那么堆栈指针减4。
当用PUSH指令把堆栈指针SP或ESP压入堆栈时，80386/80286的处理方式不同于8086/8088。
8086/8088是将SP减2后的值进栈，而80386/80286是将进栈操作前的SP（或ESP）值进栈。
也就是说，8086/8088先把SP减2，再赋值，80386/80286先赋值给[SP-2]，再把SP减2
出栈指令POP的格式、功能和使用注意点都没变，除允许弹出32位操作数外。
PUSHA指令和POPA指令提供了压入或弹出8个16位通用寄存器的有效手段，它们的一般格式如下：
PUSHA
POPA
PUSHA指令将所有8个通用寄存器（16位）内容压入堆栈，其顺序是：AX、CX、DX、BX、SP、BP、SI、DI，
然后堆栈指针寄存器SP之值减16，所以SP进栈的内容是PUSHA执行之前的值。
POPA指令从堆栈弹出内容以PUSHA相反的顺序送到这些通用寄存器，从而恢复PUSHA之前的寄存器内容。
但堆栈指针寄存器ESP之值不是由堆栈弹出，而是通过增加16来恢复。
这两条指令不影响标志。这两条指令都没有显式的操作数。
PUSHAD指令和POPAD指令提供了压入或弹出8个32位通用寄存器的有效手段，它们的一般格式如下：
PUSHAD
POPAD
PUSHAD指令将所有8个通用寄存器（32位）内容压入堆栈，其顺序是：EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI，
然后堆栈指针寄存器ESP之值减32，所以ESP进栈的内容是PUSHAD执行之前的值。
POPAD指令从堆栈弹出内容以PUSHAD相反的顺序送到这些通用寄存器，从而恢复PUSHAD之前的寄存器内容。
但堆栈指针寄存器SP之值不是由堆栈弹出，而是通过增加32来恢复。
这两条指令不影响各标志。这两条指令都没有显式的操作数。这两条指令是PUSHA和POPA指令的扩展。
装入有效地址指令LEA的格式和功能没变。源操作数仍然必须是存储器操作数，目的操作数是16位或者32位通用寄存器。
当目的操作数是16位通用寄存器时，那么只装入有效地址的低16位。这符合实方式下的实际应用需要。
利用该指令还可以进行简单的算术运算，例如：
LEA EAX,[EAX+EAX*8]
装入指针指令组有5条指令，它们的格式如下：
LDS REG,OPRD
LES REG,OPRD
LFS REG,OPRD 始于80386
LGS REG,OPRD 始于80386
LSS REG,OPRD 始于80386
这些指令的功能将源操作数OPRD所指内存单元的4个或6个相继字节单元的内容送到指令助记符给定的段寄存器和目的操作数REG中。
目的操作数必须是16位或32位（始于80386）通用寄存器，源操作数是存储器操作数。
如果目的操作数是16位通用寄存器，那么源操作数OPRD含32位指针。
如果目的操作数是32位通用寄存器，那么源操作数OPRD含48位指针，这适合于使用32位偏移的场合，可用于一次装载48位全指针。
这些指令不影响各标志。
80386的标志传送指令组含有如下6条指令：LAHF、SAHF、PUSHF、PUSHFD、POPF和POPFD。
指令LAHF、SAHF、PUSHF和POPF指令格式和功能等均与8086/8088相同。
LAHF 把标志寄存器的低8位传送到寄存器AH
SAHF 把寄存器AH送至标志寄存器低8位
PUSHF 把标志寄存器的内容压入堆栈
POPF 把栈顶的一个字弹出到标志寄存器
32位标志寄存器进栈和出栈指令的格式如下，它们始于80386：
PUSHFD
POPFD
PUSHFD指令将整个标志寄存器的内容压入堆栈；
POPFD指令将栈顶的一个双字弹出到32位的标志寄存器中。这两条指令是PUSHF和POPF指令的扩展。
PUSHFD指令不影响各标志；POPFD指令将影响各标志。
80386累加器专用指令组含有如下指令：IN、OUT和XLAT。
IN 累加器,端口地址 从一个输入端口读取一个字节、一个字、一个双字，传送至AL（一个字节）、AX（一个字）、EAX（一个双字）。
OUT 端口地址,累加器 将AL中的一个字节、AX中的一个字、EAX中的一个双字，输出到指定端口。
XLAT 把寄存器BX、EBX的内容作为表（每项一字节）的首地址，把寄存器AL的值作为下标，取出表项内容再送AL寄存器。
使用此指令前，应先把表的首地址送BX、EBX寄存器。表最大为256项。
80386算术运算指令的操作数可以扩展到32位，此外与8086/8088相比还增强了有符号数乘法指令的功能。
加法和减法指令组含有如下8条指令：ADD、ADC、INC、SUB、SBB、DEC、CMP和NEG。
除了这些指令的操作数可以扩展到32位外，其他均与8086/8088相同。
乘法和除法指令组含有4条指令：MUL、DIV、IMUL和IDIV。
无符号数乘法和除法指令的格式没变。指令中只给出一个操作数，自动根据给出的操作数确定另一个操作数。
当指令中给出的源操作数为字节或字时，它们与8086/8088的情形相同。
在源操作数为双字的情况下，乘法指令MUL默认的另一个操作数是EAX，其功能是把EAX内容乘上源操作数内容所得积送入EDX:EAX中，
若结果的高32位（在EDX中）为0，那么标志CF和OF被清0，否则被置1；
除法指令DIV默认的被除数是EDX:EAX，其功能是把指令中给出的操作数作为除数，所得的商送EAX，余数送EDX。
原有的有符号数乘法指令IMUL和除法指令IDIV继续保持，但操作数可扩展到32位。当操作数为32位时的情形与无符号数乘法、除法指令相同。
从80186开始，还提供了新形式的有符号数乘法指令。一般格式如下：
IMUL DST,SRC
IMUL DST,SRC1,SRC2
第一种格式是将目的操作数DST与源操作数SRC相乘，结果送到目的操作数DST中；
第二种格式是将SRC1与SRC2相乘，结果送目的操作数DST中。
其中，目的操作数只能是16位通用寄存器或32位通用寄存器；
第一种格式中的源操作数SRC的长度必须与目的操作数的长度相同（8位立即数除外），可以是通用寄存器、存储单元或立即数;
第二种格式中的源操作数SRC1只能是通用寄存器或存储单元，并且长度必须与目的操作数的长度相同，源操作数SRC2只能是立即数。
对于这两种新增的乘法指令，由于存放积的目的操作数的长度与被乘数（或乘数）的长度相同，因此积有可能溢出。
如果积溢出，那么高位部分将被丢掉，而置标志CF和OF为1来表示溢出；否则清标志CF和OF。
CBW 把寄存器AL中的符号扩展到寄存器AH。即若AL的最高有效位为0，则AH=0；若AL的最高有效位为1，则AH=0FFH。
CWD 把寄存器AX中的符号扩展到寄存器DX。即若AX的最高有效位为0，则DX=0；若AX的最高有效位为1，则DX=0FFFFH。
指令CWDE将16位寄存器AX的符号位扩展到32位寄存器EAX的高16位中。该指令是指令CBW的扩展。
指令CDQ将寄存器EAX的符号位扩展到EDX的所有位。该指令是指令CWD的扩展。
十进制调整指令组含有如下6条指令：DAA、DAS、AAA、AAS、AAM和AAD。这些指令的功能与8086/8088相同，均无变化。
逻辑运算指令组含有如下5条指令：NOT、AND、OR、XOR和TEST。
除了这些指令的操作数可以扩展到32位外，其他均与8086/8088相同。
一般移位指令组含有如下3条指令：SAL/SHL、SAR和SHR。算术左移指令SAL和逻辑左移指令SHL是相同的。
SAL OPRD,m   把操作数OPRD左移m位，每移动一位，右边用0补足一位，移出的最高位进入标志位CF
SHL OPRD,m  把操作数OPRD左移m位，每移动一位，右边用0补足一位，移出的最高位进入标志位CF
SAR OPRD,m  把操作数OPRD右移m位，每移动一位，左边的符号位保持不变，移出的最低位进入标志位CF
SHR OPRD,m  把操作数OPRD右移m位，每移动一位，左边用0补足，移出的最低位进入标志位CF
ROL OPRD,m  把操作数OPRD左循环移m位，每移位一次，操作数左移，其最高位移入最低位，同时最高位也移入进位标志CF
ROR OPRD,m  把操作数OPRD右循环移m位，每移位一次，操作数右移，其最低位移入最高位，同时最低位也移入进位标志CF
RCL OPRD,m  把操作数OPRD左循环移m位，每移位一次，操作数左移，其最高位移入进位标志CF，进位标志CF移入最低位
RCR OPRD,m  把操作数OPRD右循环移m位，每移位一次，操作数右移，其最低位移入进位标志CF，进位标志CF移入最高位
从80386开始，操作数可扩展到32位。尽管这些指令的格式没变，但移位位数的表达增强了。
从80186开始，移位指令中的移位位数不仅可以是1或者CL，也可以是一个8位立即数。
从80386开始，实际移位位数等于指令中指定的移位位数的低5位，所以移位位数的变化范围是0至31。
CF总是保留着目的操作数最后被移出去的位的值。但对逻辑左移指令SHL而言，当移位位数大于等于被移位的操作数长度时，CF被置0。
在移位位数仅是1的情况下，当移位前后的目的操作数的符号位相同时，那么溢出标志位OF被置0。
这些移位指令还会影响标志ZF、SF和PF，但对标志AF无定义。
循环移位指令组含有如下4条指令：ROL、ROR、RCL和RCR。
从80386开始，操作数可扩展到32位。与一般移位指令一样，从80186开始，循环移位指令中的移位位数也可以是一个8位的立即数。
从80386开始，对循环指令ROL和ROR而言，实际移位的位数将根据被移位的操作数的长度取8、16或32位的模；
对带进位的循环移位指令RCL和RCR而言，移位位数先取指令中规定的移位位数的低5位，再根据被移位的操作数的长度取9、17或32位的模。
循环移位指令影响CF和OF。CF总是保留着操作数最后被移出去的位的值。
在移位位数仅是1的情况下，当移位前后的目的操作数的符号位相同时，那么OF被置0。
始于80386的双精度移位指令组含有两条指令：SHLD和SHRD。
双精度移位指令的一般格式如下：
SHLD OPRD1,OPRD2,m
SHRD OPRD1,OPRD2,m
其中，操作数OPRD1可以是16位通用寄存器、16位存储单元、32位通用寄存器或者32位存储单元；
操作数OPRD2的长度必须与操作数OPRD1的长度一致，并且只能是16位通用寄存器或者32位通用寄存器；
m是移位位数，或者为8位立即数，或者为CL。
双精度左移指令SHLD的功能是把操作数OPRD1左移指定的m位，空出的位用操作数OPRD2高端的m位填补，
（类似基于OPRD1:OPRD2的左移），但操作数OPRD2的内容不变，最后移出的位保留在进位标志CF中。
如果只移一位，当进位标志和最后的符号位不一致时，置溢出标志OF，否则清OF。
双精度右移指令SHRD的功能是把操作数OPRD1右移指定的m位，空出的位用操作数OPRD2低端的m位填补，
（类似基于OPRD1:OPRD2的右移），但操作数OPRD2的内容不变，最后移出的位保留在进位标志CF中。
当移位位数为1时，OF标志受影响。符号位移位前后不一致时，置溢出标志OF，否则清OF。
双精度移位指令还影响标志ZF、SF和PF，对AF无定义。
双精度移位指令的实际移位的位数取指令中规定的移位位数m的32位的低5位，所以移位位数的变化范围是0~31。
如果移位的位数是0，那么双精度移位指令就相当于空操作指令NOP。如果移位位数超过被移位操作数OPRD1的长度，
那么操作数OPRD1和各标志均无定义。
控制转移指令可分为如下四组：转移指令、循环指令、过程调用和返回指令、中断调用和中断返回指令。
这些控制转移指令的非扩展形式的功能保持与8086/8088相同。
由于保护方式下80386的段长可超过64K，所以，这些控制转移指令扩展后涉及的段内偏移可达32位。
在采用32位表示段内偏移时，段间转移的目的地址采用48位全指针形式表示。
但在实方式下，最大的段长仍是64K，因此，即使段内偏移用32位表示，实际的偏移值也禁止超过64K。
无条件转移指令JMP在分为段内直接、段内间接、段间直接和段间间接四类的同时，还具有扩展形式。
扩展的无条件转移指令的转移目的地址偏移采用32位表示，段间转移目的地址采用48位全指针形式表示。
在实方式下，无条件转移指令JMP的功能几乎没有提高。尽管80386的无条件转移指令允许把32位的段内偏移送到EIP，
但在实方式下段最大64K，段内偏移不能超过64K，所以不需要使用32位的段内偏移。
80386的条件转移指令（除JCXZ和JECXZ指令外）允许用多字节来表示转移目的地偏移与当前偏移之间的差，
所以转移范围可超出-128~+127。
这一点比8086/8088的条件转移指令的功能强，它使得程序员可不必考虑条件转移的范围。
但在向前引用标号时，如果程序员能够预计到所引用的标号在127的范围之内，
那么，在标号前加上汇编语言操作符SHORT可使汇编程序产生只有一字节地址差的条件转移指令。
在80386中，当寄存器CX的值为0时，转移的指令JCXZ可以被扩展到JECXZ，
它表示当32位寄存器ECX为0时，转移到标号OK处。
但必须注意，指令JCXZ和JECXZ与其他条件转移指令不同，仍只能用一字节表示地址差值，所以转移范围仍是-128~+127。
循环指令组含有如下三条指令：LOOP、LOOPZ/LOOPE和LOOPNZ/LOOPNE。
这三条循环指令的非扩展形式保持原功能。它们的扩展形式使用ECX作为计数器，即从CX扩展到ECX。
汇编程序TASM支持使用助记符LOOPD、LOOPDZ/LOOPDE和LOOPDNZ/LOOPDNE，以便明确说明使用ECX作为计数器；
同样，可使用助记符LOOPW、LOOPWZ/LOOPWE和LOOPWNZ/LOOPWNE，以便明确说明使用CX作为计数器。
这三条循环指令的转移范围仍是-128~+127。
过程调用指令CALL在分为段内直接、段内间接、段间直接和段间间接四类的同时，还具有扩展形式。
扩展的调用指令的转移目的地址偏移采用32位表示。对于扩展的段间调用指令，转移目的地址采用48位全指针形式表示，
而且在把返回地址的CS压入堆栈时扩展成高16位为0的双字，这样会压入堆栈2个双字。
过程返回指令RET在分为段内返回和段间返回的同时，还分别具有扩展形式。扩展的过程返回指令要从堆栈弹出双字作为返回地址的偏移。
如果是扩展的段间返回指令，执行时要从堆栈弹出包含48位返回地址全指针的2个双字。
在实方式下主要使用过程调用指令CALL和过程返回指令RET的非扩展形式，它们与8086/8088的CALL指令和RET指令相同。
在保护方式下，段内过程调用指令和返回指令的转移方法未变，但段间过程调用和返回指令的执行细节较复杂，请参见10.6节。
在实方式下，中断调用指令INT的功能与8086/8088的INT指令相同。
在保护方式下，中断调用指令INT把扩展的标志寄存器EFLAG、CS和EIP压入堆栈，也即压入堆栈3个双字，
在压入CS时也扩展到32位，高16位为0。具体执行细节较复杂，在10.7节中说明。
中断返回指令IRET有非扩展和扩展两种形式。在实方式下，总是使用其非扩展形式，其功能与8086/8088的IRET指令相同。
在保护方式下，应该使用其扩展形式，以与保护方式下的中断调用指令相对应。具体执行细节较复杂，在10.7节中说明。
在实方式下，溢出中断调用指令INTO的功能与8086/8088相同。在保护方式下，该指令的执行细节较复杂，请参见10.7节。
从80386开始，串操作的基本单位在字节和字的基础上增加了双字。
从80186开始，在8086/8088的5条基本串操作指令的基础上，增加了串输入操作指令INS和串输出操作指令OUTS。
字节装入指令LODSB把寄存器SI所指向的一个字节数据装入到累加器AL中，然后根据方向标志DF复位或置位使SI之值增1或减1。
字装入指令LODSW把寄存器SI所指向的一个字数据装入到累加器AX中，然后根据方向标志DF复位或置位使SI之值增2或减2。
字节存储指令STOSB把累加器AL的内容送到寄存器DI所指向的存储单元中，然后根据方向标志DF复位或置位使DI之值增1或减1。
字装入指令STOSW把累加器AX的内容送到寄存器DI所指向的存储单元中，然后根据方向标志DF复位或置位使DI之值增2或减2。
字节传送指令MOVSB把寄存器SI所指向的一个字节数据传送到由寄存器DI所指向的存储单元中，
然后根据方向标志DF复位或置位使SI和DI之值分别增1或减1。
字传送指令MOVSW把寄存器SI所指向的一个字数据传送到由寄存器DI所指向的存储单元中，
然后根据方向标志DF复位或置位使SI和DI之值分别增2或减2。
字节扫描指令SCASB把累加器AL的内容与由寄存器DI所指向一个字节数据采用相减方式比较，
相减结果反映到各有关标志位（AF，CF，OF，PF，SF和ZF），但不影响两个操作数，
然后根据方向标志DF复位或置位使DI之值增1或减1。
字扫描指令SCASW把累加器AX的内容与由寄存器DI所指向的一个字数据比较，结果影响标志，然后DI之值增2或减2。
字节比较指令CMPSB把寄存器SI所指向的一个字节数据与由寄存器DI所指向一个字节数据采用相减方式比较，
相减结果反映到各有关标志位（AF，CF，OF，PF，SF和ZF），但不影响两个操作数，
然后根据方向标志DF复位或置位使SI和DI之值分别增1或减1。
字比较指令CMPSW把寄存器SI所指向的一个字数据与由寄存器DI所指向的一个字数据比较，结果影响标志，然后按调整值2调整SI和DI之值。
对应于字节和字为元素的基本串操作指令没变化。对应于双字为元素的基本串操作指令格式如下：
LODSD：串装入指令
STOSD：串存储指令
MOVSD；串传送指令
SCANSD；串扫描指令
CMPSD；串比较指令
其中，LODSD、STOSD和SCANSD指令使用累加器EAX；在DF=0时，每次执行串操作后相应指针加4，在DF=1时，每次串操作后相应指针减4。
这些以双字为元素的基本串操作指令的功能和使用方法与以字节或字为元素的基本串操作指令一样。
它们分别是对应以字为元素的串操作指令的扩展。
在不使用32位指针的情况下，串操作中的源指针是DS:SI，目的指针是ES:DI；
在使用32位指针（地址扩展）的情况下，源指针是DS:ESI，目的指针是ES:EDI。
双精度左移指令SHLD的功能是把操作数OPRD1左移指定的m位，空出的位用操作数OPRD2高端的m位填补，
（类似基于OPRD1:OPRD2的左移），但操作数OPRD2的内容不变，最后移出的位保留在进位标志CF中。
双精度右移指令SHRD的功能是把操作数OPRD1右移指定的m位，空出的位用操作数OPRD2低端的m位填补，
（类似基于OPRD1:OPRD2的右移），但操作数OPRD2的内容不变，最后移出的位保留在进位标志CF中。
重复前缀REP、REPZ/REPE和REPNZ/REPNE，在仍采用16位地址偏移指针的情况下以CX作为重复计数器，
在采用32位地址偏移的扩展情况下以ECX作为重复计数器。由于在实方式下通常采用16位指针，所以一般仍以CX作为计数器。
ROL OPRD,m  把操作数OPRD左循环移m位，每移位一次，操作数左移，其最高位移入最低位，同时最高位也移入进位标志CF
ROR OPRD,m  把操作数OPRD右循环移m位，每移位一次，操作数右移，其最低位移入最高位，同时最低位也移入进位标志CF
串输入指令的格式如下：
INSB   输入字节（Byte）
INSW  输入字（Word）
INSD   输入双字（Dword）始于80386
串输入指令从由DX给出端口地址的端口读入一字符，并送入由ES:DI（或EDI）所指的目的串中，
同时根据方向标志DF和字符类型调整DI（或EDI）。
INSB指令对应的字符类型是字节，INSW指令对应的字符类型是字，INSD指令对应的字符类型是双字。
根据输入字符的上述类型，当DF=0时，对目的指针的调整值依次分别是1、2、4；当DF=1时，对目的指针的调整值依次分别是-1、-2、-4。
在汇编语言中，三条串输入指令的格式可统一为如下一种格式：
INS DSTS,DX
汇编程序根据目的串DSTS类型决定使用字节输入指令、字输入指令或双字输入指令。
也即，如果类型为字节，则采用INSB指令；如果类型为字，则采用INSW指令；如果类型是双字，则采用INSD指令。
请注意，目的串DSTS并不影响实际使用指针ES:DI（或EDI）及其值，所以在使用上述格式的串输入指令时，
仍必须先给ES:DI（或EDI）赋合适的值。
串输入指令不影响标志。
在串输入指令前，可使用重复前缀REP，以便连续输入，但必须注意端口的数据准备情况。
串输出指令的格式如下
OUTSB   输出字节（Byte）
OUTSW  输出字（Word）
OUTSD   输出双字（Dword）始于80386
串输出指令把由DS:SI（或ESI）所指的源串中的一个字符，输出到由DX给出的端口，同时根据方向标志DF和字符类型调整SI（或ESI）。
OUTSB指令对应的字符类型是字节，OUTSW指令对应的字符类型是字，OUTSD指令对应的字符类型是双字。
根据输入字符的上述类型，当DF=0时，对源指针的调整值依次分别是1、2、4；当DF=1时，对源指针的调整值依次分别是-1、-2、-4。
在汇编语言中，三条串输出指令的格式可统一为如下一种格式：
OUTS DX,SRCS
汇编程序根据源串SRCS类型决定使用字节输出指令、字输出指令或双字输出指令。
也即，如果类型为字节，则采用OUTSB指令；如果类型为字，则采用OUTSW指令；如果类型是双字，则采用OUTSD指令。
请注意，指令中给出的源串并不影响实际使用指针DS:SI（或ESI）及其值，所以在使用上述格式的串输出指令时，仍必须先给DS:SI（或ESI）
赋合适的值。
串输出指令不影响标志。在串输出指令前，可使用重复前缀REP，以便连续输出，但必须注意端口的数据接收处理情况。
高级语言支持指令始于80186，它们用于简化支持高级语言的某些特征。共有3条这样的指令，它们是：BOUND、ENTER和LEAVE。
1.建立与释放堆栈框架指令
在C和PASCAL等高级语言中，函数或过程不仅通过堆栈传递入口参数，而且它们的局部变量也被安排在堆栈中，
为了方便地获取入口参数和准确地存取局部变量，就要建立合适的堆栈框架。
建立堆栈框架指令ENTER的一般格式如下：
ENTER CNT1,CNT2
其中，操作数CNT1是16位立即数，表示框架的大小，也即子程序需要安排在堆栈中的局部变量所需的字节数；
操作数CNT2是8位立即数，表示子程序嵌套级别，也即需要从外层框架复制到当前框架的指针数。
ENTER 指令有非扩展和扩展两种形式。汇编程序TASM支持使用助记符ENTERW和ENTERD，以便明确说明使用该指令的非扩展形式和扩展形式。
在实方式下，通常使用非扩展形式。
操作数CNT2为0时，非扩展形式的ENTER指令建立堆栈框架时所完成的操作如
①BP进栈，即保存原堆栈框架指针
②BP<=SP
③SP=SP-16位立即数（CNT1）
在80386的实方式下，使用该指令的扩展形式，也可建立由EBP指示的堆栈框架。上述操作步骤改变为：
①EBP进栈，即保存原堆栈框架指针
②EBP<=ESP
③SP<=SP-16位立即数（CNT1）
只调整SP的原因是实方式下不使用ESP作为堆栈指针。在80386的保护方式下使用该指令的扩展形式，那么BP和SP寄存器分别扩展为EBP和ESP。
ENTER指令不影响标志。
释放堆栈框架指令LEAVE的一般格式如下：
LEAVE
指令LEAVE的功能与指令ENTER相反，释放当前子程序（过程）在堆栈中的局部变量，使BP和SP恢复成最近一次的ENTER指令被执行前的值，
具体操作如下：
①SP<=BP
②BP退栈
LEAVE指令也有非扩展和扩展两种形式。汇编程序TASM支持使用助记符LEAVEW和LEAVED，以便明确说明使用该指令的非扩展形式和扩展形式。
在80386的实方式下，使用该指令的扩展形式，那么上述操作步骤改变为：
①SP=BP
②EBP退栈
在80386的保护方式下使用该指令的扩展形式，那么BP和SP寄存器分别扩展为EBP和ESP。
LEAVE指令不影响标志。
注意，指令LEAVE只负责释放堆栈框架，不实现返回，所以在过程中LEAVE指令后还应安排相应的RET指令。
检查数组下标界限指令BOUND的一般格式如下：
BOUND OPRD1,OPRD2
在80386之前，用于给出待检查数组下标的操作数OPRD1是16位寄存器，用于给出数组下标上下界限的操作数OPRD2是32位存储器操作数，
其中低字含起始下标，高字含结尾下标；从80386开始，OPRD1还可以是32位寄存器，此时OPRD2只能是64位存储器操作数，
其中低双字含起始下标，高双字含结尾下标。
该指令检查由OPRD1给出的有符号数是否在由操作数OPRD2给出的数组界限之内。
如果被检查的下标不在数组允许的范围之内，那么产生类型号为5的异常（中断）。
指令BOUND不影响标志。
条件字节设置指令的一般格式如下：
SETcc OPRD
其中，cc是指令助记符的一部分，用于表示条件，这些条件与条件转移指令中的条件相同；
操作数OPRD只能是8位寄存器或者存储单元，用于存放测试的结果。
这些指令的功能是测试指令中规定的条件，若条件为“真”，那么将目的操作数OPRD置成1，否则置成0。
标志名称 溢出 方向 中断 符号 零  辅助进位 奇偶 进位
               OF    DF   IF     SF    ZF  AF   PF    CF
置位状态 OV   DN  EI     NG  ZR  AC   PE    CY
复位状态 NV   UP  DI     PL   NZ  NA  PO   NC
表9.2条件字节设置指令
指令格式         功能说明                                                               测试条件
SETZ OPRD    等于0或者相等时，置OPRD为1                            ZF=1
SETE OPRD
SETNZ OPRD 不等于0或者不相等时，置OPRD为1                     ZF=0
SETNE OPRD
SETS OPRD    为负置OPRD为1                                                   SF=1
SETNS OPRD 不为负置OPRD为1                                                SF=0
SETO OPRD   溢出置OPRD为1                                                   OF=1
SETNO OPRD 不溢出置OPRD为1                                               OF=0
SETP OPRD    偶置OPRD为1                                                      PF=1
SETPE OPRD
SETNP OPRD 奇置OPRD为1                                                      PF=0
SETPO OPRD
SETB OPRD    小于、不大于等于、CF为1置OPRD为1                CF=1
SETNAE OPRD
SETC OPRD
SETNB OPRD 不小于、大于等于、CF为0置OPRD为1                CF=0
SETAE OPRD
SETNC OPRD
SETBE OPRD 小于等于、不大于置OPRD为1                              (CF或ZF)=1
SETNA OPRD
SETNBE OPRD 不小于等于、大于置OPRD为1                           (CF或ZF)=0
SETA OPRD
SETL OPRD   小于、不大于等于置OPRD为1                              (SF异或OF)=1
SETNGE OPRD
SETNL OPRD 不小于、大于等于置OPRD为1                             (SF异或OF)=0
SETGE OPRD
SETLE OPRD  小于等于、不大于置OPRD为1                            ((SF异或OF)或ZF)=1
SETNG OPRD
SETNLE OPRD 不小于等于、大于置OPRD为1                          ((SF异或OF)或ZF)=0
SETG OPRD
条件字节设置指令与条件转移指令一样，并且测试条件的方法也相同，只是在条件满足时，设置某个字节而已。
位测试和设置指令组含有如下4条指令：位测试（Bit Test）指令BT、位测试并取反（Bit Test and Complement）指令BTC、
位测试并复位（Bit Test and Reset）指令BTR和位测试并置位（Bit Test and Set）指令BTS。
这4条位测试和设置指令的格式如下：
BT OPRD1,OPRD2
BTC OPRD1,OPRD2
BTR OPRD1,OPRD2
BTS OPRD1,OPRD2
其中，操作数OPRD1可以是16位或32位通用寄存器和16位或32位存储单元，用于指定要测试的内容；
操作数OPRD2必须是8位立即数或者与操作数OPRD1长度相等的通用寄存器，用于指定要测试的位。
设操作数OPRD2除以操作数OPRD1的长度后所得商是disp，所得余数是offset。那么这些指令要测试的位是根据如下方法确定的：
如果操作数OPRD1是寄存器，offset是寄存器操作数OPRD1中要测试位的位号；
如果操作数OPRD1是存储单元，存储器操作数OPRD1的偏移与disp相加之和是实际测试存储单元的偏移，offset是该存储单元中要测试位的位号。
操作数OPRD2取符号整数值，所以当OPRD2为16位时，可访问（-32K）至（32K-1）范围内的位串，
当OPRD2是32位时，可访问（-2G）至（2G-1）范围内的位串。
位测试指令BT的功能是把被测试位的值送标志位CF。
位测试并取反指令BTC的功能是把被测试位的值送标志CF，并且把被测试位取反。
位测试并复位指令BTR的功能是把被测试位的值送标志CF，并且把被测试位复位，也即清0。
位测试并置位指令BTS的功能是把被测试位的值送标志CF，并且把被测试位置位，也即置1。
其它标志ZF、SF、OF、AF和PF无定义。
EAX
位号31      位号0
BX
位号15      位号0
符号扩展指令
MOVSX DST,SRC 把源操作数SRC的内容送到目的操作数DST，目的操作数空出的位用源操作数的符号位填补。
零扩展指令
MOVZX DST,SRC 把源操作数SRC的内容送到目的操作数DST，目的操作数空出的位用零填补。
符号扩展指令和零扩展指令中的目的操作数DST必须是16位或32位寄存器，源操作数SRC可以是8位或16位寄存器，
也可以是8位或16位存储器操作数。如果源操作数和目的操作数都是字，那么就相当于MOV指令。
位扫描指令组含有如下2条指令：顺向位扫描（Bit Scan Forward）指令BSF和逆向位扫描（Bit Scan Reverse）指令BSR。
这两条位扫描指令的格式如下：
BSF OPRD1,OPRD2
BSR OPRD1,OPRD2
其中，操作数OPRD1和OPRD2可以是16或32位通用寄存器和16位或32位存储单元；但操作数OPRD1和OPRD2的位数（长度）必须相等。
顺向位扫描指令BSF的功能是从右向左（位0~位15或位31）扫描字或者双字操作数OPRD2中第一个含“1”的位，
并把扫描到的第一个含“1”的位的位号送操作数OPRD1。
逆向位扫描指令BSR的功能是从左向右（位15或位31~位0）扫描字或者双字操作数OPRD2中第一个含“1”的位，
并把扫描到的第一个含“1”的位的位号送操作数OPRD1。
如果字或双字操作数OPRD2等于0，那么零标志ZF被置1，操作数OPRD1的值不确定；否则零标志ZF被清0。
其它标志CF、SF、OF、AF和PF无定义。
CLC 使进位标志为0
STC 使进位标志为1
CMC 使进位标志取反，如CF为1，则使CF为0；如CF为0，则CF为1
CLD 使方向标志DF为0
STD 使方向标志DF为1
CLI 使中断允许标志IF为0，不响应来自外部装置的可屏蔽中断，对不可屏蔽中断和内部中断没有影响
STI 使中断允许标志IF为1，可以响应来自外部装置的可屏蔽中断
设置进位标志CF的指令CLC、STC和CMC保持与原先相同。
设置方向标志DF的指令CLD和STD保持与原先相同。
设置中断允许标志IF的指令CLI和STI的功能在实方式下保持与原先相同。在保护方式下它们是I/O敏感指令，请参见10.9节。
空操作指令NOP的一般格式如下：
NOP
空操作指令的功能是什么都不做。该指令就一个字节的操作码。利用该指令可“填补程序中的空白区”，使代码保持连续。
等待指令WAIT的一般格式如下：
WAIT
该指令的功能是等待直到BUSY引脚为高。BUSY由数值协处理器控制，所以该指令的功能是等待数值协处理器，以便与它同步。
该指令也能够检查数值协处理器是否故障，请参见10.7.2节。
封锁前缀LOCK可以锁定其后指令的目的操作数确定的存储单元，这是通过使LOCK信号在指令执行期间一直保持有效而实现的。
在多处理器环境中，使用这种方法可以保证指令执行时独占共享内存。
NEG OPRD 对操作数取补，就是用零减去操作数OPRD，再把结果送回OPRD，也即：OPRD=0-OPRD
只有下列指令才能用封锁前缀LOCK，并且目的操作数是存储器操作数：
XCHG
ADD，ADC，INC，SUB，SBB，DEC，NEG
OR，AND，XOR，NOT
BT，BTS，BTR，BTC
9.5习题
题9.1 与8086/8088比较，实方式下的80386功能在哪些方面大有提高？
在实方式下，80386相当于可进行32位处理的快速8086。
80386有8个32位通用寄存器，这8个寄存器分别为EAX、EBX、ECX、EDX、EBP、ESP、ESI和EDI。
这些通用寄存器的低16位可以作为16位的寄存器独立存取，就是8086/8088的AX、BX、CX、DX、BP、SP、SI和DI。
AX、BX、CX和DX这4个16位的数据寄存器的高8位和低8位可以被独立存取，就是8086/8088的AH、AL、BH、BL、CH、CL、DH和DL。
这些32位通用寄存器不仅可以传送数据、暂存数据、保存算术或逻辑运算的结果，还可以在基址和变址寻址时存放地址。
在8086/8088中，只有BX、BP、SI和DI可以在基址和变址寻址时存放地址。
80386有6个16位段寄存器，分别定名为CS、DS、ES、SS、FS和GS。
在实方式下，代码段寄存器CS、数据段寄存器DS、附加段寄存器ES、堆栈段寄存器SS的功能与8086/8088中对应段寄存器的功能相同。
FS和GS是80386新增加的段寄存器。因此80386上运行的程序可同时访问多达6个段。
80386的指令指针寄存器扩展到32位，记为EIP。EIP的低16位是16位的指令指针IP，它与8086/8088中的IP相同。
80386的标志寄存器也扩展到32位，记为EFLAGS。与8086/8088的16位标志寄存器相比，增加了4个控制标志，
80386支持8086/8088的各种寻址方式。在立即寻址方式和寄存器寻址方式中，操作数可达32位宽。
在存储器寻址方式中，不仅操作数可达32位，而且寻址范围和方式更加灵活。
80386允许内存地址的偏移可以由三部分内容相加构成：
一个32位基址寄存器，一个可乘上比例因子1、2、4或8的32位变址寄存器，及一个8位或32位的常数偏移量。
并且这三部分可省去任意的两部分。如果含变址寄存器，那么变址寄存器中的值先按给定的比例因子放大，再加上偏移。
在这些寻址方式中，8个32位通用寄存器都可作为基址寄存器使用，除了ESP寄存器外，其他7个通用寄存器都可作为变址寄存器使用。
在所有寻址方式中，对数据的访问所默认引用的段寄存器取决于所选择的基址寄存器。
如果基址寄存器是ESP或者EBP，那么默认的段寄存器从通常的DS改为SS。
对于别的基址寄存器的选择，包括没有基址寄存器的情况，DS仍然是默认的段寄存器。
在实方式下，也可使用上述32位偏移的存储器寻址方式，但所得偏移不应超过0FFFFH，
80386的指令集包含了8086/8088、80186和80286指令集。
可分为如下大类：数据传送指令、算术运算指令、逻辑运算和移位指令、控制转移指令、串操作指令、高级语言支持指令、条件字节设置指令、
位操作指令、处理器控制指令和保护方式指令。高级语言支持指令始于80186。保护方式指令始于80286。
条件字节设置指令和位操作指令等是80386新增的。
80386是32位处理器，80386指令的操作数长度可以是8位、16位或者32位。80386认为，32位操作数是对16位操作数的扩展。
80386既支持16位的存储器操作数有效地址，又支持32位的存储器操作数有效地址。
80386认为，32位存储器操作数有效地址是对16位存储器操作数有效地址的扩展。
所以，80386支持的32位操作数的指令往往就是对相应支持16位操作数指令的扩展；
80386的32位存储器操作数有效地址寻址方式往往就是对16位存储器操作数有效地址寻址方式的扩展。
题9.2 80386的32位通用寄存器与16位通用寄存器之间的关系如何？
EAX AX AH AL
EBX BX BH BL
ECX CX CH CL
EDX DX DH DL
ESI SI
EDI DI
EBP BP
ESP SP
EFLAGS FLAGS
EIP IP
CS DS ES SS FS GS
80386有8个32位通用寄存器，这8个寄存器分别为EAX、EBX、ECX、EDX、EBP、ESP、ESI和EDI。它们是原先的16位通用寄存器的扩展。
这些通用寄存器的低16位可以作为16位的寄存器独立存取，它们分别为AX、BX、CX、DX、BP、SP、SI和DI。
在存取这些16位的寄存器时，相应的32位通用寄存器的高16位不受影响。
AX、BX、CX和DX这4个16位的寄存器的高8位和低8位可以被独立存取，分别为AH、AL、BH、BL、CH、CL、DH和DL。
在存取这些8位寄存器时，相应的16位寄存器的其它位不受影响，相应的通用寄存器的其它位也不受影响。
80386有6个16位段寄存器，分别定名为CS、DS、ES、SS、FS和GS。FS和GS是80386新增加的段寄存器。
80386的指令指针寄存器扩展到32位，记为EIP。EIP的低16位是16位的指令指针IP。
80386的标志寄存器也扩展到32位，记为EFLAGS。与8086/8088的16位标志寄存器相比，增加了4个控制标志，
其他标志位的位置和意义均与8086/8088相同。
题9.3请列出80386的段寄存器。实方式下的80386同时可对多少个段进行操作？
80386有6个16位段寄存器，分别定名为CS、DS、ES、SS、FS和GS。
在实方式下，代码段寄存器CS、数据段寄存器DS、附加段寄存器ES、堆栈段寄存器SS的功能与8086/8088中对应段寄存器的功能相同。
FS和GS是80386新增加的段寄存器。因此80386上运行的程序可同时访问多达6个段。
在实方式下，内存单元的逻辑地址仍是"段值:偏移"形式。为了访问一个给定内存段中的数据，可直接把相应的段值装入某个段寄存器中。
在保护方式下，情况要复杂得多，装入段寄存器的不再是段值，而是称为选择子的某个值。
题9.480386可寻址的物理地址空间有多大？实方式下每个段可多大？如何得到存储器32位物理地址。
80386支持8086/8088的各种寻址方式。在立即寻址方式和寄存器寻址方式中，操作数可达32位宽。
在存储器寻址方式中，不仅操作数可达32位，而且寻址范围和方式更加灵活。
80386继续采用分段的方法管理主存储器。存储器的逻辑地址由段基地址（段起始地址）和段内偏移两部分表示，
存储单元的地址由段基地址加上段内偏移所得。段寄存器指示段基地址，各种寻址方式决定段内偏移。
在实方式下，段基地址仍然是16的倍数，段的最大长度仍然是64K。段寄存器内所含的仍然是段基地址对应的段值，
存储单元的物理地址仍然是段寄存器内的段值乘上16加上段内偏移。所以，尽管80386有32根地址线，可直接寻址物理地址空间达到4G字节，
但在实方式下仍然与8086/8088相似。
在保护方式下，段基地址可以长32位，无须是16的倍数，段的最大长度可达4G。
段寄存器内所含的是指示段基地址的选择子，存储单元的地址是段基地址加上段内偏移。
但不再是段寄存器之值乘16加上偏移，这与8086/8088完全不同。
段寄存器指示段基地址。在实方式下，段寄存器含段值，直接指示段基地址；在保护方式下，段寄存器含选择子，间接指示段基地址。
题9.580386的寻址方式有何扩展？
80386在取指令时，自动引用代码段寄存器CS。80386的指令指针寄存器是EIP。
在实方式下，由于段的最大长度不超过64K，所以EIP的高16位为0，相当于IP。
由段寄存器SS所指定的段称为当前堆栈段。80386在访问堆栈时，总是引用堆栈段寄存器SS。
在实方式下，80386把ESP的低16位SP作为指向栈顶的指针，可以认为堆栈顶由SS和SP指定。
在保护方式下，32位堆栈段的堆栈指针是ESP，16位堆栈段的堆栈指针是SP。
在实方式下，段内偏移不能超过64K；在保护万式下，段内偏移可以超过64K。
80386既支持8086/8088的16位偏移的寻址方式，又增加了灵活的32位偏移的寻址方式。
80386允许内存地址的偏移可以由三部分内容相加构成：
基址 +   变址 * 倍数     + 常数偏移
                      1 2 4 8      8位、32位
一个32位基址寄存器，一个可乘上比例因子1、2、4或8的32位变址寄存器，及一个8位或32位的常数偏移量。
并且这三部分可省去任意的两部分。例如：
MOV AL,ES:[5678H]
显式指定段寄存器ES
MOV CX,[EBX]
MOV EDX,[EBX+EDI+1234H]
MOV AX,[EBX+ESI*4]
MOV ESI,[EBX*8+100H]
MOV BH,ES:[EBX+EDI*8+6]
显式指定段寄存器ES
如果含变址寄存器，那么变址寄存器中的值先按给定的比例因子放大，再加上偏移。
在这些寻址方式中，8个32位通用寄存器都可作为基址寄存器使用，除了ESP寄存器外，其他7个通用寄存器都可作为变址寄存器使用。例如：
MOV AL,[ECX]
MOV BX,[EAX-4]
MOV [EDX+EDI],CX
MOV [EBX+EAX*2],DH
MOV ESI,[EAX+ECX*8+1234H]
在所有寻址方式中，对数据的访问所默认引用的段寄存器取决于所选择的基址寄存器。
如果基址寄存器是ESP或者EBP，那么默认的段寄存器从通常的DS改为SS。
对于别的基址寄存器的选择，包括没有基址寄存器的情况，DS仍然是默认的段寄存器。
访问由非默认的段寄存器指定的某个段的数据，要使用一额外的指令字节来指定所要的段寄存器。
当EBP作为变址寄存器使用（ESP不能作为变址寄存器使用）时，不影响默认段寄存器的选择。
默认段寄存器的选择只受所选的基址寄存器所影响。例如：
MOV AL,[EBX+EBP*2]           默认的段寄存器是DS
MOV AL,[EBX+EBP]               默认的段寄存器是DS
MOV AL,[EBP+EBX]               默认的段寄存器是SS
MOV AL,GS:[EBP*2]               显式指定段寄存器GS
MOV EAX,[ESP]                      默认的段寄存器是SS
MOV AL,CS:[ESP+2]              显式指定段寄存器CS
MOV [ESP+EBP*2],ECX         默认的段寄存器是SS
MOV AL,DS:[ESP+EDI+12]   显式指定段寄存器DS
要特别说明的是，在实方式下，也可使用上述32位偏移的存储器寻址方式，但所得偏移不应超过0FFFFH，
而且操作数的最高字节单元的地址偏移也不能超过0FFFFH。原因是实方式下段的长度是64K。
题9.6请给出表9.1所列各种情形的使用例子。
基地址和变址寄存器为寻址方式提供两个动态的成分，而位移量提供静态的成分。
位移                              MOV AL,ES:[5678H]
变址                              MOV AL,GS:[EBP*2] 
变址+位移                    MOV ESI,[EBX*8+100H]
基地址                          MOV CX,[EBX]  MOV AL,[ECX]
基地址+位移                MOV BX,[EAX-4]
基地址+变址+位移      MOV BH,ES:[EBX+EDI*8+6]  MOV EDX,[EBX+EDI+1234H] MOV ESI,[EAX+ECX*8+1234H]
基地址+变址                MOV AX,[EBX+ESI*4] MOV [EDX+EDI],CX  MOV [EBX+EAX*2],DH
题9.7设寄存器EAX含有一个不太大的无符号数，请给出两种用一条指令实现把EAX内容乘9的方法。
.386
CSEG SEGMENT USE16
ASSUME CS:CSEG
START:MOV EAX,3
LEA EAX,[EAX+EAX*8]
MOV EAX,3
IMUL EAX,9
MOV AH,4CH
INT 21H
CSEG ENDS
END START
题9.8写一个程序测试一下，在实方式下如果偏移超过64K会得到什么结果？
.386
CSEG SEGMENT USE16
ASSUME CS:CSEG
START:MOV EAX,10000H
MOV EBX,[EAX]
MOV AH,4CH
INT 21H
CSEG ENDS
END START
偏移超过64K，产生错误，在XP系统的command环境中执行，command直接退出
在实方式下，80386相当于一个可进行32位处理的快速8086。为80386编写的程序可利用32位的通用寄存器，可使用新增的指令，
可采用扩展的寻址方式。段的最大长度是64K，但不像真正的8086，当所存取的存储单元的地址偏移超过0FFFFH时，
不会引起模64K的地址反绕，而是导致段越界异常。
所以，在实方式下运行的程序访问的存储单元的地址偏移不能超过0FFFFH，转移的目的地址偏移也不能超过0FFFFH。
题9.9写一个程序用十六进制数形式在屏幕上显示从10000H处开始的32个双字的值。
.386
CSEG SEGMENT USE16
ASSUME CS:CSEG
START:MOV AX,1000H
MOV FS,AX
MOV ECX,32
MOV EBX,0
@@1:MOV EAX,FS:[EBX]
CALL TOHEX
MOV AL,'H'
CALL ECHOCH
MOV AL,20H
CALL ECHOCH
ADD EBX,4
LOOP @@1
CALL NEWLINE
MOV AH,4CH
INT 21H
TOHEX PROC NEAR
PUSHAD
ENTER 8,0
MOVZX EBP,BP
MOV ECX,8
MOV EDX,EAX
HEX1:MOV AL,DL
AND AL,0FH
MOV [EBP+ECX-9],AL
ROR EDX,4
LOOP HEX1
MOV CX,8
XOR EBX,EBX
HEX3: MOV AL,[EBP+EBX-8]
INC EBX
CALL TOASC
CALL ECHOCH
LOOP HEX3
LEAVE
POPAD
RET
TOHEX ENDP
TOASC PROC NEAR
AND AL,0FH
ADD AL,'0'
CMP AL,'9'
SETA DL
MOVZX DX,DL
IMUL DX,7
ADD AL,DL
TOASC1:RET
TOASC ENDP
NEWLINE PROC NEAR
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
ECHOCH PROC NEAR
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
ECHOCH ENDP
CSEG ENDS
END START
手动输入段值、偏移、个数
.386
DSEG SEGMENT  USE16
MESS_SEG DB 'SEGMENT:$'
MESS_OFF DB 'OFFSET:$'
MESS_LEN DB 'LENGTH:$'
MESS_TAB DW MESS_SEG,MESS_OFF,MESS_LEN
DSEG ENDS
CSEG SEGMENT USE16
ASSUME CS:CSEG
LTODEC PROC NEAR
PUSHAD
XOR CX,CX
LTODEC1:MOV EBX,10
CALL DIVX
PUSH BX
INC CX
MOV EBX,EDX
OR EBX,EAX
JNZ LTODEC1
LTODEC2:POP AX
AND AL,0FH
ADD AL,'0'
CALL ECHOCH
LOOP LTODEC2
POPAD
RET
LTODEC ENDP
DIVX PROC NEAR
PUSH ECX
PUSH ESI
MOV CX,64
XOR ESI,ESI
DIVX1:SHL EAX,1
RCL EDX,1
RCL ESI,1
JC SHORT DIVX2
CMP ESI,EBX
JB SHORT DIVX3
DIVX2:SUB ESI,EBX
BTS AX,0
DIVX3:LOOP DIVX1
MOV EBX,ESI
POP ESI
POP ECX
RET
DIVX ENDP
GETVAL PROC NEAR
ENTER 36,0
PUSH ECX
PUSH EDX
PUSH DS
PUSH ES
MOV AX,SS
MOV DS,AX
MOV ES,AX
LEA EDX,[BP-36]
MOV BYTE PTR [EDX],34
MOV AH,10
INT 21H
CALL NEWLINE
INC EDX
MOV CL,[EDX]
XOR CH,CH
MOVZX ECX,CX
INC ECX
GETVAL1:DEC ECX
INC EDX
CMP BYTE PTR [EDX],20H
JZ GETVAL1
MOV BL,0
JECXZ GETVAL5
GETVAL2:CMP BYTE PTR [EDX+ECX-1],20H
LOOPZ GETVAL2
SETNZ AL
ADD CL,AL
JECXZ GETVAL5
MOV BL,-1
MOV AL,[EDX+ECX-1]
CMP AL,'0'
JB SHORT GETVAL5
CMP AL,'9'
JA SHORT GETVAL3
GETVAL2A:CALL DSTOV
JMP SHORT GETVAL5
GETVAL3:BTR AX,5
CMP AL,'D'
JNZ GETVAL3A
DEC ECX
JMP GETVAL2A
GETVAL3A:CMP AL,'H'
JNZ GETVAL4
DEC ECX
CALL HSTOV
JMP SHORT GETVAL5
GETVAL4:CMP AL,'B'
JNZ SHORT GETVAL5
DEC ECX
CALL BSTOV
GETVAL5:POP ES
POP DS
POP EDX
POP ECX
LEAVE
RET
GETVAL ENDP
DSTOV PROC NEAR
PUSH ESI
MOV ESI,EDX
MOV BL,0
JCXZ DSTOV3
MOV BL,-1
XOR EAX,EAX
MOV EDX,10
PUSH EDX
DSTOV1:MOV DL,[ESI]
INC ESI
CMP DL,'0'
JB SHORT DSTOV2
CMP DL,'9'
JA SHORT DSTOV2
AND DL,0FH
PUSH EDX
MUL DWORD PTR [ESP+4]
OR DL,DL
POP EDX
JNZ SHORT DSTOV2
ADD EAX,EDX
JC DSTOV2
LOOP DSTOV1
MOV BL,1
DSTOV2:POP EDX
DSTOV3:POP ESI
RET
DSTOV ENDP
HSTOV PROC NEAR
PUSH ESI
MOV BL,0
JCXZ HSTOV4
MOV BL,-1
XOR EAX,EAX
XOR ESI,ESI
HSTOV1:MOV AL,[EDX]
INC EDX
BTS AX,5
CMP AL,'0'
JB SHORT HSTOV2
CMP AL,'9'
JA SHORT HSTOV2
AND AL,0FH
JMP SHORT HSTOV3
HSTOV2:CMP AL,'a'
JB SHORT HSTOV4
CMP AL,'f'
JA SHORT HSTOV4
SUB AL,'a'-10
HSTOV3:TEST ESI,0F0000000H
JNZ SHORT HSTOV4
SHL ESI,4
ADD ESI,EAX
LOOP HSTOV1
MOV BL,1
HSTOV4:MOV EAX,ESI
POP ESI
RET
HSTOV ENDP
BSTOV PROC NEAR
PUSH ESI
MOV BL,0
JCXZ BSTOV2
MOV BL,-1
XOR EAX,EAX
XOR ESI,ESI
XCHG EDX,ESI
BSTOV1:MOV AL,[ESI]
INC ESI
CMP AL,'0'
JB SHORT BSTOV2
CMP AL,'1'
JA SHORT BSTOV2
AND AL,0FH
BT EDX,31
JC SHORT BSTOV2
SHL EDX,1
ADD EDX,EAX
LOOP BSTOV1
MOV BL,1
BSTOV2:MOV EAX,EDX
POP ESI
RET
BSTOV ENDP
TOHEX PROC NEAR
PUSHAD
ENTER 8,0
MOVZX EBP,BP
MOV ECX,8
MOV EDX,EAX
HEX1:MOV AL,DL
AND AL,0FH
MOV [EBP+ECX-9],AL
ROR EDX,4
LOOP HEX1
MOV CX,8
XOR EBX,EBX
HEX3: MOV AL,[EBP+EBX-8]
INC EBX
CALL TOASC
CALL ECHOCH
LOOP HEX3
LEAVE
POPAD
RET
TOHEX ENDP
TOASC PROC NEAR
PUSH EDX
AND AL,0FH
ADD AL,'0'
CMP AL,'9'
SETA DL
MOVZX DX,DL
IMUL DX,7
ADD AL,DL
TOASC1:POP EDX
RET
TOASC ENDP
NEWLINE PROC NEAR
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
ECHOCH PROC NEAR
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
ECHOCH ENDP
CSEG ENDS
CSEG SEGMENT USE16
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV CX,3
MOV ESI,0
@@1:MOV DX,MESS_TAB[ESI*2]
MOV AH,9
INT 21H
CALL GETVAL
CMP BL,0
JZ OVER
CMP BL,1
JZ SHORT @@2
MOV AL,'x'
CALL ECHOCH
CALL NEWLINE
JMP @@1
@@2:PUSH EAX
INC ESI
LOOP @@1
CALL NEWLINE
POP ECX
POP EBX
POP EAX
MOV FS,AX
@@3:MOV EAX,FS:[EBX]
CALL TOHEX
MOV AL,'H'
CALL ECHOCH
MOV AL,20H
CALL ECHOCH
ADD EBX,4
LOOP @@3
CALL NEWLINE
OVER:MOV AH,4CH
INT 21H
CSEG ENDS
END START
题9.10如何通知汇编程序识别80386指令？
为了让MASM或TASM识别由80186、80286和80386等新增的指令或功能增强的指令，须告诉汇编程序处理器的类型。
汇编语言提供了如下说明处理器类型的伪指令，这些伪指令均以句点引导：
.8086  只支持对8086指令的汇编
.186    支持对80186指令的汇编
.286    支持对非特权80286指令的汇编
.286C  支持对非特权80286指令的汇编
.286P  支持对80286所有指令的汇编
.386    支持对80386非特权指令的汇编
.386C  支持对80386非特权指令的汇编
.386P  支持对80386所有指令的汇编
汇编程序在遇到说明处理器类型的伪指令后，就识别并汇编相应的指令。
在一个源程序中，可根据需要安排多条说明处理器类型的伪指令，以便更改对处理器类型的说明。
对TASM而言，这些伪指令可以安排在源程序中的任何位置。但对MASM而言，上述说明处理器类型的伪指令必须安排在段外。
只有在使用说明处理器类型是80386的伪指令后，汇编程序才识别表示32位寄存器的符号和表示始于80386的指令的助记符。
题9.11如何通知汇编程序形成16位段和32位段？
在实方式下，80386保持与原先的8086/8088兼容，所以段的最大长度仍是64K，这样的段称为16位段。
但在保护方式下，段长度可达4G，这样的段称为32位段。为了兼容，在保护方式下，也可使用16位段。
段定义语句带有可选的定位类型、组合类型、类别、属性类型，其中，属性类型用于指示是16位段，还是32位段。
完整段定义的一般格式如下：
段名 SEGMENT [定位类型][组合类型]['类别'][属性类型]
属性类型说明符号是"USE16"和"USE32"。USE16表示16位段，USE32表示32位段。
在使用".386"等伪指令指示处理器类型80386后，缺省的属性类型是USE32；如果没有指示处理器类型80386，那么缺省的属性类型是USE16。
题9.12什么是操作数长度前缀和地址长度前缀？在什么情况下要使用这两个前缀？请举例说明之。
尽管在实方式下只能使用16位段，但可使用32位操作数，也可使用以32位形式表示的存储单元地址，
这是利用操作数长度前缀66H和存储器地址长度前缀67H来表示的。
在16位代码段中，正常操作数的长度是16位或8位。在指令前加上操作数长度前缀66H后，操作数长度就成为32位或8位，
也即原来表示16位操作数的代码成为表示32位操作数的代码。一般情况下，不在源程序中直接使用操作数长度前缀，而是直接使用32位操作数，
操作数长度前缀由汇编程序在汇编时自动加上。
请注意比较如下在16位代码段中的汇编格式指令和对应的机器码（注释部分）：
.386
TEST16 SEGMENT PARA USE16
......
MOV EAX,EBX  对应的机器指令 66H,8BH,C3H
MOV AX,BX     对应的机器指令         8BH,C3H
MOV AL,BL      对应的机器指令         8AH,C3H
......
TEST16 ENDS
32位代码段的情况刚好相反。在32位代码段中，正常操作数长度是32位或8位。
在指令前加上操作数长度前缀66H后，操作数长度就成为16位或8位。
不在32位代码的源程序中直接使用操作数长度前缀66H表示使用16位操作数，而是直接使用16位操作数，
操作数长度前缀由汇编程序在汇编时自动加上。
请注意比较如下在32位代码段中的汇编格式指令和对应的机器码（注释部分）：
.386
TEST32 SEGMENT PARA USE32
......
MOV EAX,EBX   对应的机器指令        8BH,C3H
MOV AX,BX      对应的机器指令 66H,8BH,C3H
......
TEST32 ENDS
通过存储器地址长度前缀67H区分32位存储器地址和16位存储器地址的方法与上述通过
操作数长度前缀66H区分32位操作数和16位操作数的方法类似。在源程序中可根据需要使用32位地址，或者16位地址。
汇编程序在汇编源程序时，对于16位的代码段，在使用32位存储器地址的指令前加上前缀67H；对于32位代码段，
在使用16位存储器地址的指令前加上前缀67H。
在一条指令前可能既有操作数长度前缀66H，又有存储器地址长度前缀67H。
题9.13指令NOP有何用途？请举例说明。
空操作指令NOP的一般格式如下：
NOP
空操作指令的功能是什么都不做。该指令就一个字节的操作码。利用该指令可“填补程序中的空白区”，使代码保持连续。
该程序在运行中将s处的一条指令复制到s0处。
assume cs:codesg
codesg segment
s:mov ax,bx
mov si,offset s
mov di,offset s0
mov ax,cs:[si]
mov cs:[di],ax
s0:nop
nop
mov ax,4c00h
int 21h
codesg ends
end s
题9.14设AL是有符号数，请用两种方法把AL扩展到EAX。设AL含有无符号数，请用两种方法把AL扩展到EAX。
符号扩展指令 MOVSX DST,SRC 把源操作数SRC的内容送到目的操作数DST，目的操作数空出的位用源操作数的符号位填补。
零扩展指令 MOVZX DST,SRC 把源操作数SRC的内容送到目的操作数DST，目的操作数空出的位用零填补。
符号扩展指令和零扩展指令中的目的操作数DST必须是16位或32位寄存器，源操作数SRC可以是8位或16位寄存器、8位或16位存储器操作数。
CBW 把寄存器AL中的符号扩展到寄存器AH。即若AL的最高有效位为0，则AH=0；若AL的最高有效位为1，则AH=0FFH。
CWD 把寄存器AX中的符号扩展到寄存器DX。即若AX的最高有效位为0，则DX=0；若AX的最高有效位为1，则DX=0FFFFH。
CWDE将16位寄存器AX的符号位扩展到32位寄存器EAX的高16位中。该指令是指令CBW的扩展。
CDQ将寄存器EAX的符号位扩展到EDX的所有位。该指令是指令CWD的扩展。
利用MOVSX、CBW和CWDE可以把有符号数扩展到EAX，利用MOVZX、SHL EAX,24和ROL EAX,8可以把无符号数AL扩展到EAX
.386
CSEG SEGMENT USE16
ASSUME CS:CSEG
START:MOV AL,-3
MOVSX EAX,AL
CALL TOHEX
MOV AL,'H'
CALL ECHOCH
MOV AL,20H
CALL ECHOCH
MOV AL,3
CBW
CWDE
CALL TOHEX
MOV AL,'H'
CALL ECHOCH
MOV AL,20H
CALL ECHOCH
MOV AL,-9
CBW
CWDE
CALL TOHEX
MOV AL,'H'
CALL ECHOCH
MOV AL,20H
CALL ECHOCH
MOV AL,-3
MOVZX EAX,AL
CALL TOHEX
MOV AL,'H'
CALL ECHOCH
MOV AL,20H
CALL ECHOCH
MOV AL,-6
CBW
CWDE
CALL TOHEX
MOV AL,'H'
CALL ECHOCH
MOV AL,20H
CALL ECHOCH
MOV AL,-9
SHL EAX,24
ROL EAX,8
CALL TOHEX
MOV AL,'H'
CALL ECHOCH
MOV AL,20H
CALL ECHOCH
CALL NEWLINE
MOV AH,4CH
INT 21H
TOHEX PROC NEAR
PUSHAD
ENTER 8,0
MOVZX EBP,BP
MOV ECX,8
MOV EDX,EAX
HEX1:MOV AL,DL
AND AL,0FH
MOV [EBP+ECX-9],AL
ROR EDX,4
LOOP HEX1
MOV CX,8
XOR EBX,EBX
HEX3: MOV AL,[EBP+EBX-8]
INC EBX
CALL TOASC
CALL ECHOCH
LOOP HEX3
LEAVE
POPAD
RET
TOHEX ENDP
TOASC PROC NEAR
AND AL,0FH
ADD AL,'0'
CMP AL,'9'
SETA DL
MOVZX DX,DL
IMUL DX,7
ADD AL,DL
TOASC1:RET
TOASC ENDP
NEWLINE PROC NEAR
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
ECHOCH PROC NEAR
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
ECHOCH ENDP
CSEG ENDS
END START
题9.15请比较如下指令：
符号扩展指令 MOVSX DST,SRC 把源操作数SRC的内容送到目的操作数DST，目的操作数空出的位用源操作数的符号位填补。
零扩展指令 MOVZX DST,SRC 把源操作数SRC的内容送到目的操作数DST，目的操作数空出的位用零填补。
符号扩展指令和零扩展指令中的目的操作数DST必须是16位或32位寄存器，源操作数SRC可以是8位或16位寄存器、8位或16位存储器操作数。
CBW 把寄存器AL中的符号扩展到寄存器AH。即若AL的最高有效位为0，则AH=0；若AL的最高有效位为1，则AH=0FFH。
CWD 把寄存器AX中的符号扩展到寄存器DX。即若AX的最高有效位为0，则DX=0；若AX的最高有效位为1，则DX=0FFFFH。
CWDE将16位寄存器AX的符号位扩展到32位寄存器EAX的高16位中。该指令是指令CBW的扩展。
CDQ将寄存器EAX的符号位扩展到EDX的所有位。该指令是指令CWD的扩展。
（1）MOVSX EAX,AX XOR EDX,EDX
（2）CWDE                CDQ
MOVSX EAX,AX和CWDE都把AX的符号位扩展到EAX，XOR EDX,EDX把EDX清零，CDQ把将EAX的符号位扩展到EDX
题9.16从80186开始，PUSH指令的操作数可以是立即数。什么情况下这很有用？请举例说明。
从80186开始，压入堆栈的操作数可以是立即数。从80386开始，操作数长度可以达32位，如果操作数长度是32位，那么堆栈指针减4。
例如：
PUSH EAX
PUSH DWORD PTR [BX]
PUSH DWORD PTR [EAX]
PUSH FS
PUSH 1234H
16位立即数
PUSH 12345678H
32位立即数
在调用通过堆栈传递入口参数的子程序时，把立即数直接压入堆栈的操作能方便地把常量作为参数传递给子程序。例如：
PUSH 0F000H
压入立即数
PUSH 0
压入立即数
CALL ECHOBD
调用子程序
ADD SP,4
有一点要注意：当用PUSH指令把堆栈指针SP或ESP压入堆栈时，80386/80286的处理方式不同于8086/8088。
8086/8088是将SP减2后的值进栈，而80386/80286是将进栈操作前的SP（或ESP）值进栈。
PUSHA指令将所有8个通用寄存器（16位）内容压入堆栈，其顺序是：AX、CX、DX、BX、SP、BP、SI、DI，
然后堆栈指针寄存器SP之值减16，所以SP进栈的内容是PUSHA执行之前的值。
POPA指令从堆栈弹出内容以PUSHA相反的顺序送到这些通用寄存器，从而恢复PUSHA之前的寄存器内容。
但堆栈指针寄存器ESP之值不是由堆栈弹出，而是通过增加16来恢复。
PUSHAD指令将所有8个通用寄存器（32位）内容压入堆栈，其顺序是：EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI，
然后堆栈指针寄存器ESP之值减32，所以ESP进栈的内容是PUSHAD执行之前的值。
POPAD指令从堆栈弹出内容以PUSHAD相反的顺序送到这些通用寄存器，从而恢复PUSHAD之前的寄存器内容。
但堆栈指针寄存器SP之值不是由堆栈弹出，而是通过增加32来恢复。
题9.17请比较指令PUSHAD与如下程序片段的异同：
PUSH EAX
PUSH ECX
PUSH EDX
PUSH EBX
PUSH ESP
PUSH EBP
PUSH ESI
PUSH EDI
相同点：都按照顺序EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI把8个通用寄存器压入堆栈
不同点：PUSHAD把8个通用寄存器压入堆栈后，ESP之值减32，ESP进栈的内容是PUSHAD执行之前的值。
单独的PUSH每次把寄存器压入堆栈后，ESP之值减4，ESP进栈的内容是PUSH ESP执行之前的值。
LAHF 把标志寄存器的低8位传送到寄存器AH
SAHF 把寄存器AH送至标志寄存器低8位
PUSHF 把标志寄存器的内容压入堆栈
POPF 把栈顶的一个字弹出到标志寄存器
PUSHFD指令将32位标志寄存器的内容压入堆栈
POPFD指令将栈顶的一个双字弹出到32位标志寄存器
扩展的段内调用指令，转移目的地址偏移采用32位表示，1个双字
扩展的段间调用指令，转移目的地址采用48位全指针形式表示，2个双字，CS压入堆栈时扩展成高16位为0的双字
IRETD 分别弹出EIP、CS、EFLAGS 寄存器
题9.18如下指令片段的功能是什么？
PUSHFD
PUSH 0
PUSH CS
PUSH DWORD PTR 1234H
IRETD
跳转到CS:[1234H]处
.386
CSEG SEGMENT USE16
ASSUME CS:CSEG
START:MOV AX,OFFSET OVER
MOVZX EAX,AX
PUSHFD
PUSH 0
PUSH CS
PUSH EAX
IRETD
NOP
NOP
OVER:MOV AH,4CH
INT 21H
CSEG ENDS
END START
题9.19如何用一条指令重新设置80386的堆栈指针。
LSS REG,OPRD 始于80386
将源操作数OPRD所指内存单元的4个或6个相继字节单元的内容送到指令助记符给定的段寄存器和目的操作数REG中。
目的操作数必须是16位或32位（始于80386）通用寄存器，源操作数是存储器操作数。
如果目的操作数是16位通用寄存器，那么源操作数OPRD含32位指针。
如果目的操作数是32位通用寄存器，那么源操作数OPRD含48位指针。
用LSS指令装载堆栈指针是简单安全的方法，例如：
LSS SP,SSPTR
SSPTR是含有堆栈指针的双字
它确保在一条指令中使SS和SP都被重置。
题9.20请编写一个既适合于8086/8088又适合于80386的宏，该宏可实现两个32位存储器操作数相加，结果存入第三个32位存储器操作数。
.386
DSEG SEGMENT  USE16
NUM_1 DD 12
NUM_2 DD 21
NUM_3 DD 0
DSEG ENDS
ADDOPRD MACRO MODE1,OPRD1,OPRD2,OPRD3
IFIDNI <MODE1>,<8086>
PUSH AX
PUSH DX
MOV AX,WORD PTR OPRD1
MOV DX,WORD PTR OPRD1+2
ADD AX,WORD PTR OPRD2
ADC DX,WORD PTR OPRD2+2
MOV WORD PTR OPRD3,AX
MOV WORD PTR OPRD3+2,DX
POP DX
POP AX
ENDIF
IFIDNI <MODE1>,<80386>
PUSH EAX
MOV EAX,DWORD PTR OPRD1
ADD EAX,DWORD PTR OPRD2
MOV DWORD PTR OPRD3,EAX
POP EAX
ENDIF
ENDM
CSEG SEGMENT USE16
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
ADDOPRD 80386,NUM_1,NUM_2,NUM_3
MOV AH,4CH
INT 21H
CSEG ENDS
END START
题9.21请编写一个既适合于8086/8088又适合于80386的宏，该宏求存放在DX:AX中的32位数的补码。
.386
COMPLEDXAX MACRO MODE1
LOCAL COMPLEDXAX_OK
IFIDNI <MODE1>,<8086>
TEST DH,80H
JZ COMPLEDXAX_OK
NOT DX
NOT AX
ADD AX,1
ADC DX,0
ENDIF
IFIDNI <MODE1>,<80386>
BT DX,15
JNC COMPLEDXAX_OK
NOT DX
NOT AX
ADD AX,1
ADC DX,0
ENDIF
COMPLEDXAX_OK:
ENDM
CSEG SEGMENT USE16
ASSUME CS:CSEG
START:MOV AL,-3
CBW
CWD
COMPLEDXAX 80386
MOV AL,-3
MOV AH,0
CWD
COMPLEDXAX 80386
MOV AH,4CH
INT 21H
CSEG ENDS
END START
SAL OPRD,m   把操作数OPRD左移m位，每移动一位，右边用0补足一位，移出的最高位进入标志位CF
SHL OPRD,m  把操作数OPRD左移m位，每移动一位，右边用0补足一位，移出的最高位进入标志位CF
SAR OPRD,m  把操作数OPRD右移m位，每移动一位，左边的符号位保持不变，移出的最低位进入标志位CF
SHR OPRD,m  把操作数OPRD右移m位，每移动一位，左边用0补足，移出的最低位进入标志位CF
ROL OPRD,m  把操作数OPRD左循环移m位，每移位一次，操作数左移，其最高位移入最低位，同时最高位也移入进位标志CF
ROR OPRD,m  把操作数OPRD右循环移m位，每移位一次，操作数右移，其最低位移入最高位，同时最低位也移入进位标志CF
RCL OPRD,m  把操作数OPRD左循环移m位，每移位一次，操作数左移，其最高位移入进位标志CF，进位标志CF移入最低位
RCR OPRD,m  把操作数OPRD右循环移m位，每移位一次，操作数右移，其最低位移入进位标志CF，进位标志CF移入最高位
SHLD OPRD1,OPRD2,m 把操作数OPRD1左移指定的m位，空出的位用OPRD2高端的m位填补，OPRD2的内容不变，最后移出的位保留在CF中。
SHRD OPRD1,OPRD2,m 把操作数OPRD1右移指定的m位，空出的位用OPRD2低端的m位填补，OPRD2的内容不变，最后移出的位保留在CF中。
OPRD1可以是16位、32位通用寄存器和存储单元，操作数OPRD2只能是16位、32位通用寄存器，OPRD1和OPRD2的长度必须一致
题9.22请编写一个既适合于8086/8088又适合于80386的宏，调用该宏可分别再定义实现由常数指定移位位数的各种移位指令。
.386
DEFSHIFT MACRO SHIFTNAME,OPERATOR
SHIFTNAME MACRO MODE1,OPRD1,NUM,OPRD2
IFB <OPRD2>
IFIDNI <MODE1>,<8086>
PUSH CX
IFNB <NUM>
IFDIFI <NUM>,<CL>
MOV CL,NUM
ENDIF
ENDIF
OPERATOR OPRD1,CL
POP CX
ENDIF
IFIDNI <MODE1>,<80386>
OPERATOR OPRD1,NUM
ENDIF
ELSE
OPERATOR OPRD1,OPRD2,NUM
ENDIF
ENDM
ENDM
DEFSHIFT SHLN,SHL
CSEG SEGMENT USE16
ASSUME CS:CSEG
START:MOV AL,-3
CBW
SHLN 80386,AX,3
MOV AL,-3
MOV AH,0
SHLN 8086,AX,3
MOV AH,4CH
INT 21H
CSEG ENDS
END START
题9.2380386条件转移指令的转移范围可有多大？
80386的无条件转移指令允许把32位的段内偏移送到EIP，但在实方式下段最大64K，段内偏移不能超过64K，所以不需要使用32位的段内偏移。
80386的条件转移指令（除JCXZ和JECXZ指令外）允许用多字节来表示转移目的地偏移与当前偏移之间的差，
所以转移范围可超出-128~+127。在标号前加上汇编语言操作符SHORT可使汇编程序产生只有一字节地址差的条件转移指令。
在80386中，指令JCXZ和JECXZ与其他条件转移指令不同，仍只能用一字节表示地址差值，所以转移范围仍是-128~+127。
LOOP、LOOPZ/LOOPE和LOOPNZ/LOOPNE，这三条循环指令的非扩展形式保持原功能。
它们的扩展形式使用ECX作为计数器，即从CX扩展到ECX。这三条循环指令的转移范围仍是-128~+127。
题9.24请编写一个适用于80386的较优化的数据块移动过程。
LODSD    串装入指令
STOSD    串存储指令
MOVSD  串传送指令
SCANSD 串扫描指令
CMPSD   串比较指令
LODSD、STOSD和SCANSD指令使用累加器EAX；在DF=0时，每次执行串操作后相应指针加4，在DF=1时，每次串操作后相应指针减4。
这些以双字为元素的基本串操作指令的功能和使用方法与以字节或字为元素的基本串操作指令一样。
它们分别是对应以字为元素的串操作指令的扩展。
在不使用32位指针的情况下，串操作中的源指针是DS:SI，目的指针是ES:DI；
在使用32位指针（地址扩展）的情况下，源指针是DS:ESI，目的指针是ES:EDI。
重复前缀REP、REPZ/REPE和REPNZ/REPNE，在实方式下仍以CX作为计数器。
.386
DSEG SEGMENT  USE16
STR_1 DB 'ABCDEFG','$'
STR_2 DB 'OPQRSTU','$'
DSEG ENDS
CSEG SEGMENT USE16
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV ES,AX
MOV DX,OFFSET STR_2
MOV AH,9
INT 21H
MOV SI,OFFSET STR_1+2
MOV DI,OFFSET STR_2+2
MOV CX,3
CALL MEMCOPY
CALL NEWLINE
MOV DX,OFFSET STR_2
MOV AH,9
INT 21H
MOV AH,4CH
INT 21H
MEMCOPY PROC NEAR
PUSHF
PUSH ECX
PUSH ESI
PUSH EDI
CLD
TEST SI,1
JZ MEMCOPY_1
MOVSB
DEC CX
MEMCOPY_1:MOVZX ECX,CX
ROR ECX,2
REP MOVSD
ROL ECX,1
AND CX,0001H
REP MOVSW
ROL ECX,1
AND CX,0001H
REP MOVSB
MEMCOPY_OK:POP EDI
POP ESI
POP ECX
POPF
RET
MEMCOPY ENDP
NEWLINE PROC NEAR
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
CSEG ENDS
END START
ENTER CNT1,CNT2
操作数CNT1是16位立即数，安排在堆栈中的局部变量所需的字节数；
操作数CNT2是8位立即数，需要从外层框架复制到当前框架的指针数。
操作数CNT2为0时，具体操作如下：
①BP进栈，即保存原堆栈框架指针 PUSH BP
②BP<=SP                                     MOV BP,SP
③SP=SP-16位立即数（CNT1）    SP=SP-CNT1
LEAVE
释放堆栈框架，具体操作如下：
①SP<=BP       MOV SP,BP
②BP退栈         POP BP
题9.25请画出指令“ENTER 8,0”执行前后的堆栈变化示意图。
PUSH BP         压入堆栈2个字节
MOV BP,SP
SP=SP-8         局部变量8个字节
BOUND OPRD1,OPRD2
在80386之前，用于给出待检查数组下标的操作数OPRD1是16位寄存器，用于给出数组下标上下界限的操作数OPRD2是32位存储器操作数，
其中低字含起始下标，高字含结尾下标；
从80386开始，OPRD1还可以是32位寄存器，此时OPRD2只能是64位存储器操作数，其中低双字含起始下标，高双字含结尾下标。
该指令检查由OPRD1给出的有符号数是否在由操作数OPRD2给出的数组界限之内。
如果被检查的下标不在数组允许的范围之内，那么产生类型号为5的异常（中断）。
题9.26请写一个程序测试BOUND指令的功能。
.386
DSEG SEGMENT  USE16
NUM_1 DW 0
NUM_2 DW 127
DSEG ENDS
CSEG SEGMENT USE16
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV AX,127
BOUND AX,DWORD PTR NUM_1
MOV AX,128
BOUND AX,DWORD PTR NUM_1
MOV AH,4CH
INT 21H
CSEG ENDS
END START
题9.27请举例说明条件字节设置指令的用途。
SETcc OPRD
cc是指令助记符的一部分，用于表示条件，这些条件与条件转移指令中的条件相同；
操作数OPRD只能是8位寄存器或者存储单元，用于存放测试的结果。
这些指令的功能是测试指令中规定的条件，若条件为“真”，那么将目的操作数OPRD置成1，否则置成0。
例如：
SETO AL
当标志OF=1时，把AL置1，否则AL清0
SETNC CH
当标志CF=0时，把CH置1，否则CH清0
例如：如下程序片段测试含于寄存器EAX中的八位16进制数是否有一位为0（BH=0表示没有一位是0）
MOV BH,0
MOV CX,8
NEXT:TEST AL,0FH
SETZ BL
OR BH,BL
ROR EAX,4
LOOP NEXT
例如：如下程序片段统计DS:SI所指向的单字节数据缓冲区中正数和负数的个数（设缓冲区以0结尾）
CLD
XOR DX,DX
NEXT:LODSB
CMP AL,0
JZ SHORT OVER
SETG BL
SETL BH
ADD DL,BL
ADD DH,BH
JMP NEXT
OVER:
......
题9.28 80386的位操作指令说明了什么？
位测试（Bit Test）指令BT、位测试并取反（Bit Test and Complement）指令BTC、
位测试并复位（Bit Test and Reset）指令BTR和位测试并置位（Bit Test and Set）指令BTS。
这4条位测试和设置指令的格式如下：
BT OPRD1,OPRD2
BTC OPRD1,OPRD2
BTR OPRD1,OPRD2
BTS OPRD1,OPRD2
操作数OPRD1可以是16位、32位通用寄存器和存储单元，用于指定要测试的内容；
操作数OPRD2必须是8位立即数或者与操作数OPRD1长度相等的通用寄存器，用于指定要测试的位。
操作数OPRD2除以操作数OPRD1的长度后所得商是disp，所得余数是offset。
如果操作数OPRD1是寄存器，offset是寄存器操作数OPRD1中要测试位的位号；
如果操作数OPRD1是存储单元，存储器操作数OPRD1的偏移与disp相加之和是实际测试存储单元的偏移，offset是该存储单元中要测试位的位号。
位测试指令BT的功能是把被测试位的值送标志位CF。
位测试并取反指令BTC的功能是把被测试位的值送标志CF，并且把被测试位取反。
位测试并复位指令BTR的功能是把被测试位的值送标志CF，并且把被测试位复位，也即清0。
位测试并置位指令BTS的功能是把被测试位的值送标志CF，并且把被测试位置位，也即置1。
EAX
位号31      位号0
BX
位号15      位号0
顺向位扫描（Bit Scan Forward）指令BSF和逆向位扫描（Bit Scan Reverse）指令BSR。
这两条位扫描指令的格式如下：
BSF OPRD1,OPRD2
BSR OPRD1,OPRD2
操作数OPRD1和OPRD2可以是16位、32位通用寄存器和存储单元；操作数OPRD1和OPRD2的位数（长度）必须相等。
顺向位扫描指令BSF的功能是从右向左（位0~位15或位31）扫描字或者双字操作数OPRD2中第一个含“1”的位，
并把扫描到的第一个含“1”的位的位号送操作数OPRD1。
逆向位扫描指令BSR的功能是从左向右（位15或位31~位0）扫描字或者双字操作数OPRD2中第一个含“1”的位，
并把扫描到的第一个含“1”的位的位号送操作数OPRD1。
如果字或双字操作数OPRD2等于0，那么标志ZF被置1，操作数OPRD1的值不确定；否则标志ZF被清0。
题9.29请利用SETO指令，改写9.3.6中的子程序FACT。
.386
CSEG SEGMENT USE16
ASSUME CS:CSEG
START:MOV EAX,12
CALL FACT
CALL TOHEX
MOV AL,'H'
CALL ECHOCH
CALL NEWLINE
MOV AH,4CH
INT 21H
FACT PROC NEAR
PUSH EBX
CMP EAX,0
JL FACT_LOZ
JE FACT_EQZ
PUSH ECX
MOV ECX,EAX
MOV EAX,1
FACT1:IMUL EAX,ECX
SETO BL
BT BX,0
JNC FACT2
JMP FACT_OF
FACT2:DEC ECX
JNZ FACT1
POP ECX
JMP FACT_OK
FACT_OF:POP ECX
MOV EAX,-1
JMP FACT_OK
FACT_EQZ:MOV EAX,1
JMP FACT_OK
FACT_LOZ:MOV EAX,-1
FACT_OK:POP EBX
RET
FACT ENDP
TOHEX PROC NEAR
PUSHAD
ENTER 8,0
MOVZX EBP,BP
MOV ECX,8
MOV EDX,EAX
HEX1:MOV AL,DL
AND AL,0FH
MOV [EBP+ECX-9],AL
ROR EDX,4
LOOP HEX1
MOV CX,8
XOR EBX,EBX
HEX3: MOV AL,[EBP+EBX-8]
INC EBX
CALL TOASC
CALL ECHOCH
LOOP HEX3
LEAVE
POPAD
RET
TOHEX ENDP
TOASC PROC NEAR
AND AL,0FH
ADD AL,'0'
CMP AL,'9'
SETA DL
MOVZX DX,DL
IMUL DX,7
ADD AL,DL
TOASC1:RET
TOASC ENDP
NEWLINE PROC NEAR
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
ECHOCH PROC NEAR
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
ECHOCH ENDP
CSEG ENDS
END START
题9.30请优化本章中的排序过程SORT。
.386
DSEG SEGMENT  USE16
NUM_1 DD 1
NUM_2 DD 2
NUM_3 DD 3
NUM_4 DD 4
NUM_5 DD 5
NUM_6 DD 6
NUM_7 DD 7
NUM_8 DD 8
DSEG ENDS
CSEG SEGMENT USE16
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV SI,OFFSET NUM_1
MOV CX,8
MOVZX ESI,SI
MOVZX ECX,CX
CALL SORT
MOV AH,4CH
INT 21H
SORT PROC NEAR
PUSHAD
DEC ECX
OUTLOOP:MOV EDX,0
MOV EAX,[ESI+ECX*4]
INNERLOOP:CMP EDX,ECX
JAE SHORT BOTTOM
CMP [ESI+EDX*4],EAX
JGE SHORT NOSWAP
XCHG [ESI+EDX*4],EAX
NOSWAP:INC EDX
JMP INNERLOOP
BOTTOM:MOV [ESI+ECX*4],EAX
LOOP OUTLOOP
POPAD
RET
SORT ENDP
CSEG ENDS
END START
题9.31请用80386指令改写先前各章的相应习题。
添加.386，每个段的定义增加USE16，之后就能使用80386支持的32位寄存器、各种存储器寻址方式、扩展的指令、新增的指令。
.386
DSEG SEGMENT  USE16
......
DSEG ENDS
CSEG SEGMENT USE16
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
......
MOV AH,4CH
INT 21H
......
CSEG ENDS
END START
masm /Zm /c /Cx 文件名
tasm 文件名
link 文件名
tlink /3 文件名
第10章保护方式下的80386及其编程
80386有两种工作方式：实方式和保护方式。本章介绍保护方式下的80386及相关的程序设计内容。
第9章介绍的80386寄存器、寻址方式和指令等基本概念，除特别说明外在保护方式下仍然保持。
在以80386为处理器的硬件平台和DOS为操作系统的软件平台上，可以调试运行本章列出的实例。
请用TASM或者MASM汇编这些实例，用TLINK连接（部分实例需要带32位连接选项“/3”）。
在调试运行这些实例时，不要安装使用扩展内存的驱动程序，以避免发生冲突。
10.1保护方式简述
尽管实方式下的80386的功能要大大超过其先前处理器（8086/8088、80186、80286）的功能，但只有在保护方式下，80386才能真正发挥作用。
在保护方式下，全部32条地址线有效，可寻址高达4G字节的物理地址空间；扩充的存储器分段管理机制和可选的存储器分页管理机制，
不仅为存储器共享和保护提供了硬件支持，而且为实现虚拟存储器提供了硬件支持；
支持多任务，能够快速地进行任务切换和保护任务环境；
4个特权级和完善的特权检查机制，既能实现资源共享又能保证代码及数据的安全和保密、及任务的隔离；
支持虚拟8086方式，便于执行8086程序。
10.1.1存储管理机制
为了对存储器中的程序及数据实现保护和共享提供硬件支持，为了对实现虚拟存储器提供硬件支持，
在保护方式下，80386不仅采用扩充的存储器分段管理机制，而且还提供可选的存储器分页管理机制。
这些存储管理机制由80386的存储器管理部件MMU实现。
1.背景
80386有32根地址线，在保护方式下，它们都能发挥作用，所以可寻址的物理地址空间高达4G字节。
在以80386及其以上处理器为CPU的PC兼容机系统中，把地址在1M以下的内存称为常规内存，把地址在1M以上的内存称为扩展内存。
80386还要对实现虚拟存储器提供支持。虽然与8086可寻址的1M字节物理地址空间相比，80386可寻址的物理地址空间可谓很大，
但实际的微机系统不可能安装如此大的物理内存。所以，为了运行大型程序和真正实现多任务，必须采用虚拟存储器。
虚拟存储器是一种软硬件结合的技术，用于提供比在计算机系统中实际可以使用的物理主存储器大得多的存储器空间。
这样，程序员在编写程序时，不用考虑计算机中物理存储器的实际容量。
80386还要对存放在存储器中的代码及数据的共享和保护提供支持。
任务甲和任务乙并存，任务甲和任务乙必须隔离，以免相互影响。但它们又可能要共享部分代码和数据。
所以，80386既要支持任务隔离，又要支持可共享代码和数据的共享，还要支持特权保护。
2.地址空间和地址转换
保护方式下的虚拟存储器由大小可变的存储块构成，这样的存储块称为段。
80386采用称为描述符的数据来描述段的位置、大小和使用情况。
虚拟存储器的地址（逻辑地址）由指示描述符的选择子和段内偏移两部分构成，这样的地址集合称为虚拟地址空间。
80386支持的虚拟地址空间可达64T字节(最多16K个段，一个段最大4GB)。
程序员编写程序时使用的存储地址空间是虚拟地址空间，所以，他们可认为有足够大的存储空间可供使用。
显然，只有在物理存储器中的程序才能运行，只有在物理存储器中的数据才能访问。
因此，虚拟地址空间必须映射到物理地址空间，二维的虚拟地址必须转换成一维的物理地址。
由于物理地址空间远小于虚拟地址空间，所以只有虚拟地址空间中的部分可以映射到物理地址空间。
由于物理存储器的大小要远小于物理地址空间，所以只有上述部分中的部分才能真正映射到物理存储器。
每一个任务有一个虚拟地址空间。为了避免多个并行任务的多个虚拟地址空间直接映射到同一个物理地址空间，
采用线性地址空间隔离虚拟地址空间和物理地址空间。线性地址空间由一维的线性地址构成，线性地址空间和物理地址空间对等。
线性地址32位长，线性地址空间容量为4G字节。
80386分两步实现虚拟地址空间到物理地址空间的映射，也就是分两步实现虚拟地址到物理地址的转换，但第二步是可选的。
图10.1是地址映射转换的示意。
15      0   31      0                               31      0    ->分页管理机制 ->31      0
 选择子 :   偏移量 ->分段管理机制  ->线性地址                           ->物理地址
通过描述符表和描述符，分段管理机制实现虚拟地址空间到线性地址空间的映射，实现把二维的虚拟地址转换为一维的线性地址。
这一步总是存在的。
分页管理机制把线性地址空间和物理地址空间分别划分为大小相同的块，这样的块称之为页。
通过在线性地址空间的页与物理地址空间的页之间建立的映射表，分页管理机制实现线性地址空间到物理地址空间的映射，
实现线性地址到物理地址的转换。分页管理机制是可选的，在不采用分页管理机制时，线性地址空间就直接等同于物理地址空间，
线性地址就直接等于物理地址。
分段管理机制所使用的可变大小的块，使分段管理机制比较适宜处理复杂系统的逻辑分段。
存储块的大小可以根据适当的逻辑含义进行定义，而不用考虑固定大小的页所强加的人为限制。
每个段可作为独立的单位处理，以简化段的保护及共享。
分页机制使用的固定大小的块最适合于管理物理存储器，无论是管理内存还是外存都同样有效。分页管理机制能够有效地支持实现虚拟存储器。
10.1.2保护机制
为了支持多任务，对各任务实施保护是必需的。从80286开始，处理器就具备了保护机制。
保护机制能有效地实现不同任务之间的保护和同一任务内的保护。
1.不同任务之间的保护
保护的一个重要方面是应用程序之间的保护。通过把每个任务放置在不同的虚拟地址空间的方法来实现任务与任务的隔离，
达到应用程序之间保护的目的。虚拟地址到物理地址的映射函数在每个任务中进行定义，随着任务切换，映射函数也切换。
任务A的虚拟地址空间映射到物理地址空间的某个区域，而任务B的虚拟地址空间映射到物理地址空间的另外区域，彼此独立，互不相干。
因此，两个不同的任务，尽管虚拟存储单元地址相同，但实际的物理存储单元地址可以不同。
2.同一任务内的保护
在一个任务之内，定义有四种执行特权级别，用于限制对任务中的段进行访问。
按照包含在段中的数据的重要性和代码的可信任程度，给段指定特权级别。
把最高的特权级别分配给最重要的数据段和最可信任的代码段。具有最高特权级别的数据，只能由最可信任的代码访问。
给不重要的数据段和一般代码段分配较低的特权级别。具有最低特权级别的数据，可被具有任何特权级别的代码访问。
特权级别用数字0~3表示，数字0表示最高特权级别，而数字3表示最低特权级别。数字较大的级别具有较低的特权。
为了避免模糊和混淆，在比较特权级别时，不使用“大于”或“小于”这样的术语，
而使用“里面”或“内层”这样的术语表示较高特权级，级别的数字较小；
使用“外面”或“外层”这样的术语表示较低特权级别，级别的数字较大。
0级为最内层的特权级别，3级为最外层的特权级别，按这样的表示方法，四种特权级的层次关系如图10.2所示。
特权级0 Code K Data K
特权级1 Code OS Data OS
特权级2
特权级3 Code AP1 Data AP1 Code AP2 Data AP2
每个存储器段都与一个特权级别相联系。特权级别限制是指，只有足够级别的程序，才可对相应的段进行访问。
在任何时候，一个任务总是在4个特权级之一下运行，任务在特定时刻的特权级称为当前特权级（Current Privilege Level），标记为CPL。
每当一个程序试图访问一个段时，就把CPL与要访问的段的特权级进行比较，以决定是否允许这一访问。
对给定CPL执行的程序，允许访问同一级别或外层级别的数据段。
如图10.2所示，Code K可访问同级的数据段Data K，也可访问外层的Data OS、Data AP1及Data AP2等。
如试图访问内层级别的数据段则是非法的，并引起异常。
如图10.2所示，Code OS可访问同级的Data OS，也可访问外层的Data AP1和Data AP2等，但不能访问内层的Data K。
虽然应用程序都在最外层，但由于各个不同的应用程序存储在不同的虚拟地址空间中，所以各应用程序被隔离保护。
如图10.2所示，最外层的Code AP1只能访问Data AP1，不可能访问同级的另一个应用程序的Data AP2；
同样，Code AP2只能访问Data AP2，不可能访问Data AP1。
这实际上是组合保护。应用程序1和操作系统构成任务A，应用程序2和操作系统构成任务B。
操作系统被任务A和任务B共享，在任务A和任务B的两个不同的虚拟地址空间中，操作系统占用虚拟地址空间相同的部分。
特权级的典型用法是，把操作系统的核心放在0级，操作系统的其余部分放在1级，而应用程序放在3级，留下2级供中间软件使用。
对特权级进行这样的安排，使得在0级的操作系统核心有权访问任务中的所有存储段；在1级的操作系统其余部分有权访问除0级外的所有存储段；
而在3级的应用程序只能访问程序本身的存储段，这些存储段也是在3级。
10.2分段管理机制
本节介绍保护方式下的段定义以及由段选择子和段内偏移构成的二维虚拟地址如何被转换为一维线性地址。
10.2.1段定义和虚拟地址到线性地址转换
段是实现虚拟地址到线性地址转换机制的基础。在保护方式下，每个段由如下三个参数进行定义：
段基地址（BaseAddress）、段界限（Limit）和段属性（Attributes）。
段基地址规定线性地址空间中段的开始地址。在80386保护方式下，段基地址长32位。因为基地址长度与寻址地址的长度相同，
所以任何一个段都可以从32位线性地址空间中的任何一个字节开始，而不像实方式下规定段的边界必须被16整除。
段界限规定段的大小。在80386保护方式下，段界限用20位表示，而且段界限可以是以字节为单位或以4K字节为单位。
段属性中有一位对此进行定义，把该位称为粒度位(granularity)，用符号G标记。
G=0表示段界限以字节为单位，于是20位的界限可表示的范围是1字节至1M字节，增量为1字节；
G=1表示段界限以4K字节为单位，于是20位的界限可表示的范围是4K字节至4G字节，增量为4K字节。
当段界限以4K字节为单位时，实际的段界限LIMIT可通过下面的公式从20位段界限Limit 计算出来：
LIMIT=Limit*4K+0FFFH
=（limit<<12）+0FFFH
所以，当粒度位为1时，段的界限实际上就扩展成为32位。由此可见，在80386保护方式下，段的长度可大大超过64K字节。
基地址和界限定义了段所映射的线性地址的范围。
基地址Base是线性地址对应于段内偏移为0的虚拟地址，段内偏移为x的虚拟地址对应Base+x的线性地址。
段内从偏移0到Limit范围内的虚拟地址对应于从Base到Base+Limit范围内的线性地址。
图10.3表示一个段如何从虚拟地址空间定位到线性地址空间。
图中BaseA等代表段基地址，LimitA等代表段界限。另外，段C接在段A之后，也即BaseC=BaseA+LimitA。
例如：设段A的基地址等于00012345H，段界限等于5678H，并且段界限以字节为单位（G=0），
那么段A对应线性地址空间中从00012345H~000179BDH的区域。
如果段界限以4K字节为单位（G=1），那么段A对应线性地址空间中从00012345H~0568B344H
（=00012345H+5678000H+0FFFH=0568A345H+0FFFH=0568B344H）的区域。
通过增加段界限，可以使段的容量得到扩展。这对于那些要在内存中扩展容量的普通数据段很有效，但对堆栈段情况就不是这样。
因为堆栈底在高地址端，随着压栈操作，堆栈向低地址方向扩展。为了适应普通数据段和堆栈数据段在两个相反方向上的扩展，
数据段的段属性中安排一扩展方向位，标记为ED。ED=0表示向高扩展，ED=1表示向低扩展。
数据段的扩展方向和段界限一起决定了数据段内偏移的有效范围。如图10.4所示。
当段最大为1M字节时，在自然的向高扩展段内，从0~Limit的偏移是合法有效的偏移，而从Limit+1~1M-1的偏移是非法无效的偏移；
在向低扩展段内，情形刚好相反，从0~Limit的偏移是非法无效的偏移，而从Limit+1~1M-1的偏移是合法有效的偏移，
注意边界值Limit对应地址的有效性。当段最大为4G字节时，情形类似。
注意，只有在数据段的段属性中才有扩展方向属性位ED，也就是说只有数据段（堆栈段作为特殊的数据段）才有向高扩展和向低扩展之分，
其它段都是自然的向高扩展。在每次把虚拟地址转换为线性地址的过程中，要对偏移进行检查。如果偏移不在有效的范围内，那么就引起异常。
段属性规定段的主要特性。例如上面已提到的段粒度G就是段属性的一部分。
在对段进行各种访问时，将对访问是否合法进行检查，主要依据是段属性。
例如：如果向一个只读段进行写入操作，那么不仅不写入，而且会引起异常。
在下面会详细说明各段属性位的定义和作用。
10.2.2存储段描述符
用于表示上述定义段的三个参数的数据称为描述符。每个描述符长8个字节。在保护方式下，每一个段都有一个相应的描述符来描述。
按描述符所描述的对象来划分，描述符可分为如下三类：存储段描述符、系统段描述符、门描述符（控制描述符）。
下面先介绍存储段描述符。
1.存储段描述符
存储段是存放可由程序直接进行访问的代码和数据的段。存储段描述符描述存储段，所以存储段描述符也被称为代码和数据段描述符。
存储段描述符的格式如图10.5所示。
m+7      m+6   m+5      m+4   m+3   m+2      m+1   m
31   24                           23                   0            15      0
Base       Attributes       Segment Base             Segment Limit
7   6   5   4   3   2   1   0   7   6   5   4   3   2   1   0
G   D  0   A     Limit         P    DPL   D  TYPE
               V   19         16                  T
               L                                       
图中上面一排是对描述符8个字节的使用的说明，最低地址字节（假设地址为m）在最右边，其余字节依次向左，直到最高字节，地址为m+7；
下一排是对属性域各位的说明。
从图10.5可知，长32位的段基地址（段开始地址）被安排在描述符的两个域中，
其位0~位23安排在描述符内的第2~第4字节中，其位24~位31被安排在描述符内的第7字节中。
长20位的段界限也被安排在描述符的两个域中，其位0~位15被安排在描述符内的第0~第1字节中，
其位16~位19被安排在描述符内的第6字节的低4位中。
使用两个域存放段基地址和存放段界限的原因与80286有关。
在80286保护方式下，段基地址只有24位长，而段界限只有16位长。
80286存储段描述符尽管也是8字节长，但实际只使用低6字节，而高2字节必须置为0。
80386存储段描述符这样的安排，可使得80286的存储段描述符的格式在80386下继续有效。
80386描述符中的段属性也被安排在两个域中。下面对其定义及意义作说明。
（1）P位称为存在（Present）位。
P=1表示描述符对地址转换是有效的，或者表示该描述符所描述的段存在；P=0表示描述符对地址转换无效，并且使用该描述符会引起异常。
（2）DPL表示描述符特权级（Descriptor Privilege Level），共2位。
它规定了所描述段的特权级，用于特权检查，以决定对该段能否进行访问。
（3）DT位说明描述符的类型。
对于存储段描述符而言，DT=1，以区别于系统段描述符和门描述符（DT=0）。
（4）TYPE说明存储段描述符所描述的存储段的具体属性。
其中的位0指示描述符是否被访问（Accessed），用符号A标记。A=0表示尚未被访问，A=1表示段已被访问。
当把描述符的相应选择子装入到段寄存器时，80386把该位置为1，表明描述符已被访问。
操作系统可测试访问位，以确定描述符是否被访问过。
其中的位3指示所描述的段是代码段还是数据段，用符号E标记。
E=0表示段是不可执行段，也就是数据段，相应的描述符也就是数据段（包括堆栈段）描述符。
E=1表示段是可执行段，也就是代码段，相应的描述符也就是代码段描述符。
在数据段描述符中（E=0的情况），TYPE中的位1指示所描述的数据段是否可写，用W标记。
W=0表示对应的数据段不可写，只能读，W=1表示对应的数据段可写。
TYPE中的位2就是ED位，指示所描述的数据段的扩展方向。
ED=0表示数据段向高扩展，也即段内偏移必须小于等于段界限。ED=1表示数据段向低扩展，也即段内偏移必须大于段界限。
在代码段描述符中（E=1的情况），TYPE中的位1指示所描述的代码段是否可读，用符号R标记。
R=0表示对应的代码段不可读，只能执行，R=1表示对应的代码段可读可执行。
TYPE中的位2指示所描述的代码段是否是一致码段，用C代表。
C=0表示对应的代码段不是一致码段（普通代码段），C=1表示对应的代码段是一致码段。
存储段描述符中的TYPE所说明的存储段的属性可归纳为表10.1。
表10.1存储段描述符类型
类型      说明                     类型      说明
0   只读                              8   只执行
1   只读 已访问                   9   只执行 已访问
2   读/写                             A   执行/读
3   读/写 已访问                 B    执行/读 已访问
4   只读 向低扩展               C   只执行、一致码段
5   只读 向低扩展 已访问    D  只执行、一致码段、已访问
6   读/写 向低扩展              E   执行/读 一致码段
7   读/写 向低扩展 已访问   F   执行/读 一致码段 已访问
在80286的存储段描述符中，位于描述符内第m+5字节的段属性各位的意义与上述说明相同，
确切地说是80386为了与80286兼容而保持了原有定义。
下面说明的属性位是80386在80286基础上的扩充的属性位。
（5）G位就是段界限粒度（Granularity）位。
G=0表示界限粒度为字节，G=1表示界限粒度是4K字节。注意，界限粒度只对段界限有效，对段基地址无效，段基地址总是以字节为单位。
（6）D位是一个很特殊的位。
在描述可执行段、向低扩展数据段或者由SS寄存器寻址的段（通常就是堆栈段）的三种描述符中的意义各不相同。
在描述可执行段的描述符中，D位决定了指令使用的地址及操作数所默认的大小。
D=1表示默认情况下指令使用32位地址及32位或8位操作数，这样的代码段也称为32位代码段；
D=0表示默认情况下使用16位地址及16位或8位的操作数，这样的代码段也称为16位代码段，它与80286兼容。
就象在第9章中所述，可使用地址大小前缀和操作数大小前缀分别改变默认的地址或操作数的大小。
在向低扩展数据段的描述符中，D位决定段的上部边界。
D=1表示段的上部界限为4G；D=0表示段的上部界限为64K，这是为了与80286兼容。
在描述由SS寄存器寻址的段描述符中，D位决定隐式的堆栈访问指令（如PUSH和POP指令）使用何种堆栈指针寄存器。
D=1表示使用32位堆栈指针寄存器ESP；D=0表示使用16位堆栈指针寄存器SP，这与80286兼容。
（7）AVL位是软件可利用位。
80386对该位的使用未做规定，Intel公司也保证今后开发生产的处理器只要与80386兼容，就不会对该位的使用做任何定义或规定。
此外，描述符内第六字节中的位5须置成0，可理解成是为以后的处理器保留的。
2.存储段描述符的结构类型表示
根据如图10.5给出的存储段描述符的结构，可定义如下的描述符结构类型：
DESCRIPTOR STRUC
LIMITL  DW 0
BASEL   DW 0
BASEM DB 0
ATTRIBUTES DW 0
BASEH  DB 0
DESCRIPTOR ENDS
利用结构类型DESCRIPTOR能方便地在程序中说明存储段描述符。
存储段描述符的格式如图10.5所示。
m+7      m+6   m+5      m+4   m+3   m+2      m+1   m
31   24                           23                   0            15      0
Base       Attributes       Segment Base             Segment Limit
7   6   5   4   3   2   1   0   7   6   5   4   3   2   1   0
G   D  0   A     Limit         P    DPL   D  TYPE
               V   19         16                  T
               L                                       
存储段描述符中的TYPE所说明的存储段的属性可归纳为表10.1。
表10.1存储段描述符类型
类型      说明                     类型      说明
0   只读                              8   只执行
1   只读 已访问                   9   只执行 已访问
2   读/写                             A   执行/读
3   读/写 已访问                 B    执行/读 已访问
4   只读 向低扩展               C   只执行、一致码段
5   只读 向低扩展 已访问    D  只执行、一致码段、已访问
6   读/写 向低扩展              E   执行/读 一致码段
7   读/写 向低扩展 已访问   F   执行/读 一致码段 已访问
DESCRIPTOR STRUC
LIMITL  DW 0
BASEL   DW 0
BASEM DB 0
ATTRIBUTES DW 0
BASEH  DB 0
DESCRIPTOR ENDS
G=0表示界限粒度为字节，G=1表示界限粒度是4K字节
在描述可执行段的描述符中，D位决定了指令使用的地址及操作数所默认的大小。
D=1表示默认情况下指令使用32位地址及32位或8位操作数，这样的代码段也称为32位代码段；
D=0表示默认情况下使用16位地址及16位或8位的操作数，这样的代码段也称为16位代码段，它与80286兼容。
在向低扩展数据段的描述符中，D位决定段的上部边界。
D=1表示段的上部界限为4G；D=0表示段的上部界限为64K，这是为了与80286兼容。
在描述由SS寄存器寻址的段描述符中，D位决定隐式的堆栈访问指令使用何种堆栈指针寄存器。
D=1表示使用32位堆栈指针寄存器ESP；D=0表示使用16位堆栈指针寄存器SP，这与80286兼容。
P位称为存在（Present）位。
P=1表示描述符对地址转换是有效的，或者表示该描述符所描述的段存在；P=0表示描述符对地址转换无效，并且使用该描述符会引起异常。
DPL表示描述符特权级（Descriptor Privilege Level），共2位。
它规定了所描述段的特权级，用于特权检查，以决定对该段能否进行访问。
DT位说明描述符的类型。
对于存储段描述符而言，DT=1，以区别于系统段描述符和门描述符（DT=0）。
例如：如下描述符DATAS描述一个可读写的有效（已存在）的数据段，基地址是100000H，以字节为单位的界限是0FFFFH，
描述符特权级DPL=3。
DATAS DESCRIPTOR <0FFFFH,0,10H,0F2H,0>
再如：如下描述符CODEA描述一个只可执行的有效的32位代码段，基地址是12345678H，
以4K字节为单位的界限值是10H（以字节为单位的界限是10FFFH），描述符特权级DPL=0。
CODEA DESCRIPTOR <10H,5678H,34H,0C098H,12H>
10.2.3全局和局部描述符表
一个任务会涉及多个段，每个段需要一个描述符来描述，为了便于组织管理，80386把描述符组织成线性表。
由描述符组成的线性表称为描述符表。
在80386中有三种类型的描述符表：全局描述符表GDT（Global Descriptor Table）、局部描述符表LDT（Local Descriptor Table）和
中断描述符表IDT（Interrupt Descriptor Table）。
在整个系统中，全局描述符表GDT和中断描述符表IDT只有一张，局部描述符表可以有若干张，每个任务可以有一张。
DESCRIPTOR <LIMITL  DW,BASEL   DW,BASEM DB,ATTRIBUTES DW,BASEH  DB>
ATTRIBUTES GD00   LIMITH   P DPL DT   TYPE
例如：下列描述符表有6个描述符构成：
DESCTAB LABEL BYTE
DESC1 DESCRIPTOR <1234H,5678H,34H,92H,0>
DESC2 DESCRIPTOR <1234H,5678H,34H,93H,0>
DESC3 DESCRIPTOR <5678H,1234H,56H,98H,0>
DESC4 DESCRIPTOR <5678H,1234H,56H,99H,0>
DESC5 DESCRIPTOR <0FFFFH,0,10H,16H,0>
DESC6 DESCRIPTOR <0FFFFH,0,10H,90H,0>
每个描述符表本身形成一个特殊的数据段。这样的特殊数据段最多可以含有8K（8096）个描述符。(64K字节/8=8K个)
在10.7.3节中介绍中断描述符表IDT。
每个任务的局部描述符表LDT含有该任务自己的代码段、数据段和堆栈段的描述符，也包含该任务所使用的一些门描述符，
如任务门和调用门描述符等。随着任务的切换，系统当前的局部描述符表LDT也随之切换。
全局描述符表GDT含有每一个任务都可能或可以访问的段的描述符，通常包含描述操作系统所使用的代码段、数据段和堆栈段的描述符，
也包含多种特殊数据段描述符，如各个用于描述任务LDT的特殊数据段等。在任务切换时，并不切换GDT。
通过LDT可以使各任务私有的各个段与其他任务相隔离，从而达到受保护的目的。
通过GDT可以使各任务都需要使用的段能够被共享。
图10.6给出了任务A和任务B所涉及的有关段既隔离受保护，又合用共享的情况。
通过任务A的局部描述符表LdtA和任务B的局部描述符表LdtB，
把任务A所私有的代码段CodeA及数据段DataA与任务B所私有的代码段CodeB和数据段DataB及DataB2隔离，
但任务A和任务B通过全局描述符表GDT共享代码段CodeK及CodeOS和数据段DataK及DataOS。
一个任务可使用的整个虚拟地址空间分为相等的两半，一半空间的描述符在全局描述符表中，另一半空间的描述符在局部描述符表中。
由于全局和局部描述符表都可以包含多达8096个描述符，而每个描述符所描述的段最大可达4G字节，因此最大的虚拟地址空间可为：
4GB*8096*2=64MMB=64T（字节）
10.2.4段选择子
在实方式下，逻辑地址空间中存储单元的地址有段值和段内偏移两部分组成。
在保护方式下，虚拟地址空间（相当于逻辑地址空间）中存储单元的地址有段选择子和段内偏移两部分组成。
与实方式相比，段选择子替代了段值。段选择子长16位，其格式如图10.7所示。
15               3   2   1   0
 描述符索引     TI   RPL
从图中可见，段选择子的高13位是描述符索引（Index），2^13（2的13次方）=8K。所谓描述符索引是指描述符在描述符表中的序号。
段选择子的第2位是引用描述符表指示位，标记为TI（Table Indicator），
TI=0指示从全局描述符表GDT中读取描述符；TI=1指示从局部描述符表LDT中读取描述符。
选择子确定描述符，描述符确定段基地址，段基地址与偏移之和就是线性地址。
所以，虚拟地址空间中的由段选择子和偏移两部分构成的二维虚拟地址，就是这样确定了线性地址空间中的一维线性地址。
选择子的最低两位是请求特权级RPL（Requested Privilege Level），用于特权检查。
例如：假设某个选择子的内容是0030H。根据图10.7所示选择子的格式可知：
Index=6，TI=0，RRP=0，所以它指定全局描述符表中的第Index=6个描述符，请求特权级是0。
再如，假设某个选择子的Index=4，TI=1，RPL=3，那么该选择子的内容是0027H。
由于选择子中的描述符索引字段用13位表示，所以可区分8096个描述符。
这也就是描述符表最多含有8096个描述符的原因。由于每个描述符长8字节，按照图10.7所示选择子格式，
屏蔽选择子低3位后所得的值就是选择子所指定的描述符在描述符表中的偏移，这可认为是安排选择子高13位为描述符索引的原因。
有一个特殊的选择子称为空（Null）选择子，它的Index=0，TI=0，而RPL字段可以为任意值。
空选择子有特定的用途，当用空选择子进行存储器访问时会引起异常。
空选择子是特别定义的，它不对应于全局描述符表GDT中的第0个描述符，因此GDT中的第0个描述符总不会被处理器访问，一般把它置成全0。
但当TI=1时，Index为0的选择子不是空选择子，它指定了当前任务局部描述符表LDT中的第0个描述符。
DESCRIPTOR <LIMITL  DW,BASEL   DW,BASEM DB,ATTRIBUTES DW,BASEH  DB>
ATTRIBUTES GD00   LIMITH   P DPL DT   TYPE
位15-位3         位2   位1-位0
 描述符索引     TI     RPL
空选择子是特别定义的，一般把它置成全0。
TI=0指示从全局描述符表GDT中读取描述符；TI=1指示从局部描述符表LDT中读取描述符。
一般从GDT读取描述符 TI=0 RPL=00H
一般从LDT读取描述符 TI=1 RPL=11H
实模式下，GD00=0000=0
保护模式下，GD00=1100=C
G=0表示界限粒度为字节，G=1表示界限粒度是4K字节
在描述可执行段的描述符中，D位决定了指令使用的地址及操作数所默认的大小。
D=1表示默认情况下指令使用32位地址及32位或8位操作数，这样的代码段也称为32位代码段；
D=0表示默认情况下使用16位地址及16位或8位的操作数，这样的代码段也称为16位代码段，它与80286兼容。
在向低扩展数据段的描述符中，D位决定段的上部边界。
D=1表示段的上部界限为4G；D=0表示段的上部界限为64K，这是为了与80286兼容。
在描述由SS寄存器寻址的段描述符中，D位决定隐式的堆栈访问指令使用何种堆栈指针寄存器。
D=1表示使用32位堆栈指针寄存器ESP；D=0表示使用16位堆栈指针寄存器SP，这与80286兼容。
应用程序存储段 P DPL DT 一般为1111 = F
操作系统存储段 P DPL DT 一般为1001 = 9
P位称为存在（Present）位。
P=1表示描述符对地址转换是有效的，或者表示该描述符所描述的段存在；P=0表示描述符对地址转换无效，并且使用该描述符会引起异常。
DPL表示描述符特权级（Descriptor Privilege Level），共2位。
它规定了所描述段的特权级，用于特权检查，以决定对该段能否进行访问。
DT位说明描述符的类型。
对于存储段描述符而言，DT=1，以区别于系统段描述符和门描述符（DT=0）。
TYPE 0 ED  W A  数据段 堆栈段
         1 C    R  A   代码段
位0指示描述符是否被访问（Accessed），用符号A标记。A=0表示尚未被访问，A=1表示段已被访问。
位3指示所描述的段是代码段还是数据段，用符号E标记。
E=0表示段是不可执行段，也就是数据段，相应的描述符也就是数据段（包括堆栈段）描述符。
E=1表示段是可执行段，也就是代码段，相应的描述符也就是代码段描述符。
在数据段描述符中（E=0的情况），TYPE中的位1指示所描述的数据段是否可写，用W标记。
W=0表示对应的数据段不可写，只能读，W=1表示对应的数据段可写。
TYPE中的位2就是ED位，指示所描述的数据段的扩展方向。
ED=0表示数据段向高扩展，也即段内偏移必须小于等于段界限。ED=1表示数据段向低扩展，也即段内偏移必须大于段界限。
在代码段描述符中（E=1的情况），TYPE中的位1指示所描述的代码段是否可读，用符号R标记。
R=0表示对应的代码段不可读，只能执行，R=1表示对应的代码段可读可执行。
TYPE中的位2指示所描述的代码段是否是一致码段，用C代表。
C=0表示对应的代码段不是一致码段（普通代码段），C=1表示对应的代码段是一致码段。
10.2.5段描述符高速缓冲寄存器
在实方式下，段寄存器含有段值，为访问存储器形成物理地址时，处理器引用相应的某个段寄存器得段值。
在保护方式下，段寄存器含有段选择子，如上所述，为访问存储器形成线性地址时，处理器要使用选择子所指定的描述符中的基地址等信息。
为了避免在每次存储器访问时，都要访问描述符表而获得对应段描述符，从80286开始每个段寄存器都配有一个高速缓冲寄存器，
称之为段描述符高速缓冲寄存器或称为描述符投影寄存器，对程序员而言它是不可见的。
每当把一个选择子装入到某个段寄存器时，处理器自动从描述符表中取出相应的描述符，把描述符中的信息保存到对应的高速缓冲寄存器中。
此后在对该段访问时，处理器都使用对应高速缓冲寄存器中的描述符信息，而不用再从描述符表中取描述符。
各段描述符高速缓冲寄存器之内容如表10.2所列。
其中，32位段基地址直接取自描述符，32位段界限取自描述符中的段界限，并转换成字节为单位。
其它十个特性根据描述符中的属性而定，“Y”表示“是”，“N”表示“否”，
“r”表示必须可读，“w”表示必须可写，“p”表示必须存在，“d”表示根据描述符中属性而定。
表10.2段描述符高速缓冲寄存器之内容
段寄存器      段基地址      段界限         存在性 特权级 已存取 粒度 扩展方向 可读性 可写性 可执行 堆栈大小 一致特权
CS               32位基地址  32位段界限  p          d         d          d     d             d          N        Y                        d
SS               32位基地址  32位段界限  p           d         d         d     d             r          w          N         d
DS               32位基地址  32位段界限  p          d          d        d     d              d          d         N
ES                32位基地址  32位段界限  p          d         d         d     d              d         d          N
FS                32位基地址  32位段界限  p          d          d        d     d             d          d          N
GS               32位基地址  32位段界限  p          d          d        d     d             d          d          N
段描述符高速缓冲寄存器在处理器内，所以可对其进行快速访问。绝大多数情况下，对存储器的访问是在对应选择子装入到段寄存器之后进行的，
所以，使用段描述符高速缓冲寄存器可以得到很好的执行性能。
把选择子装入段寄存器和通过段描述符高速缓冲寄存器实现由虚拟地址到线性地址的转换情形如图10.8所示。
当不采用分页管理机制时，线性地址就是物理地址。
选择子
位15-位3         位2   位1-位0
 描述符索引     TI     RPL
TI=0指示从全局描述符表GDT中读取描述符；TI=1指示从局部描述符表LDT中读取描述符。
一般从GDT读取描述符 TI=0 RPL=00H
一般从LDT读取描述符 TI=1 RPL=11H
设虚拟地址是10:12345678H，由选择子10H所指定的GDT中的存储段描述符所含的基地址是87654321H，
那么该虚拟地址转换出的线性地址是99999999H。如不采用分页管理机制，那么物理地址就是99999999H。
段描述符高速缓冲寄存器之内保存的描述符信息将一直保持到重新把选择子装载到段寄存器时再更新。
程序员尽管不可见段描述符高速缓冲寄存器，但必须注意到它的存在和它的上述更新时机。
例如，在改变了描述符表中的某个当前段的描述符后，也要更新对应的段描述符高速缓冲寄存器的内容，这可通过重新装载段寄存器实现。
10.3 80386控制寄存器和系统地址寄存器
80386的控制寄存器和系统地址寄存器如图10.9所示，它们用于控制工作方式，控制分段管理机制及分页管理机制的实施。
10.3.1控制寄存器
从图10.9可见，80386有四个32位的控制寄存器，分别命名为CR0、CR1、CR2和CR3。
但CR1被保留，供今后开发的处理器使用，在80386中不能使用CR1，否则将引起无效指令操作异常。
CR0包含指示处理器工作方式的控制位，包含启用和禁用分页管理机制的控制位，包含控制浮点协处理器操作的控制位。
CR2及CR3由分页管理机制使用。CR0中的位5~位30及CR3中的位0至位11是保留位，这些位不能是随意值，必须为0。
控制寄存器CR0的低16位等同于80286的机器状态字MSW。
       31                                            16 15        11                 4   3   2    1     0
CR0 PG 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 ET TS EM MP PE
CR1 保留
CR2 页故障线性地址
CR3 页目录表物理页码                                      0 0 0 0 0 0 0 0 0 0 0 0
1.保护控制位
控制寄存器CR0中的位0用PE标记，位31用PG标记，这两个位控制分段和分页管理机制的操作，所以把它们称为保护控制位。
PE控制分段管理机制。PE=0，处理器运行于实方式；PE=1，处理器运行于保护方式。
PG控制分页管理机制。PG=0，禁用分页管理机制，此时分段管理机制产生的线性地址直接作为物理地址使用；
PG=1，启用分页管理机制，此时线性地址经过分页管理机制转换成物理地址。请参见图10.1。关于分页管理机制的具体介绍在10.9节中进行。
表10.3列出了通过使用PE和PG位选择的处理器工作方式。由于只有在保护方式下才可启用分页机制，
所以尽管两个位分别为0和1，共可以有四种组合，但只有三种组合方式有效。
PE=0且PG=1是无效的组合，因此，用PG位为1且PE位为0的值装入CR0寄存器将引起通用保护异常。
表10.3PG/PE位与处理器执行方式
PG         PE         处理器工作方式
0            0           实方式
0            1           保护方式，禁用分页机制
1            0            非法组合
1            1            保护方式，启用分页机制
2.协处理器控制位
控制寄存器CR0中的位1~位4分别标记为MP（算术存在位）、EM（模拟位）、TS（任务切换位）和ET（扩展类型位），
它们控制浮点协处理器的操作。
当处理器复位时，ET位被初始化，以指示系统中数字协处理器的类型。
如果系统中存在80387协处理器，那么ET位被置1；如果系统中存在80287协处理器或者不存在协处理器，那么ET位被清0。
EM位控制浮点指令的执行是用软件模拟，还是由硬件执行。EM=0时，硬件控制浮点指令传送到协处理器；EM=1时，浮点指令由软件模拟。
TS位用于加快任务的切换，通过在必要时才进行协处理器切换的方法实现这一目的。
每当进行任务切换时，处理器把TS置1。TS=1时，浮点指令将产生设备不可使用（DNA）异常。
MP位控制WAIT指令在TS=1时，是否产生DNA异常。MP=1和TS=1时，WAIT产生异常；MP=0时，WAIT指令忽略TS条件。
3.CR2和CR3控制寄存器
CR2和CR3由分页管理机制使用。
CR2用于发生页异常时报告出错信息。当发生页异常时，处理器把引起页异常的线性地址保存于CR2中。
操作系统中的页异常处理程序可以检查CR2的内容，从而查出线性空间中的哪一页引起本次异常。
CR3用于保存页目录表的起始物理地址。由于目录是页对齐的，所以仅高20位有效，低12位保留未用。
向CR3中装入新的值时，低12位必须为0；但从CR3中取值时，低12位被忽略。每当用MOV指令重置CR3值时，会导致分页高速缓冲区内容无效。
在实方式下也可设置CR3，以便进行分页机制的初始化。在任务切换时，CR3要被改变，但是如果新任务中CR3的值与原任务中CR3的值相同，
那么处理器不刷新分页高速缓冲寄存器，以便当任务共享页表时有较快的执行速度。
10.3.2系统地址寄存器
全局描述符表GDT、局部描述符表LDT和中断描述符表IDT等是保护方式下非常重要的特殊段，它们包含有对段机制所用的重要表格。
为了方便快速地定位这些段，处理器采用一些特殊的寄存器保存这些段的基地址和界限。我们把这些特殊的寄存器称为系统地址寄存器。
1.全局描述符表寄存器GDTR
          31              0 15       0
GDTR  Base             Limit
IDTR    Base             Limit
          15      0 31         0 31         0 11         0
LDTR 选择子   Base            Limit     Attributes
TR     选择子    Base           Limit      Attributes
如图10.9所示，GDTR长48位，其中高32位含基地址，低16位含界限。
由于GDT不能由GDT本身之内的描述符进行描述定义，所以处理器采用GDTR为GDT这一特殊的系统段提供一个伪描述符。
GDTR给定了GDT，如图10.10所示。
GDTR中的段界限以字节为单位。由于段选择子中只有13位作为描述符索引，而每个描述符长8个字节，所以用16位表示GDT的界限足够。
通常，对于含有N个描述符的描述符表的段界限应设置为8*N-1。
利用结构类型可定义伪描述符如下：
PDESC STRUC
LIMIT DW 0
BASE DD 0
PDESC ENDS
2.局部描述符表寄存器LDTR
局部描述符表寄存器LDTR规定当前任务使用的局部描述符表LDT。
如图10.9所示，LDTR类似于段寄存器，由程序员可见的一个16位的寄存器和程序员不可见的高速缓冲寄存器组成。
实际上，每个任务的局部描述符表LDT作为系统的一个特殊段，由一个描述符描述，而用于描述LDT的描述符存放在GDT中。
在初始化或任务切换过程中，把指示描述对应任务LDT的描述符的选择子装入LDTR，处理器根据装入LDTR可见部分的选择子，
从GDT中取出对应的描述符，并把LDT的基地址和界限等信息保存到LDTR的不可见的高速缓冲寄存器中。
随后对LDT的访问，就可根据保存在高速缓冲寄存器中的有关信息进行合法性检查。
LDTR寄存器包含当前任务的LDT的选择子。所以，装入到LDTR的选择子必须确定一个位于GDT的类型为LDT的系统段描述符，
也即选择子中的TI位必须是0，而且描述符中的类型字段所表示的类型必须是LDT。
可以用一个空选择子装入LDTR，这表示当前任务没有LDT。
在这种情况下，所有装入到段寄存器的选择子都必须指示GDT中的描述符，也即当前任务涉及的段均由GDT中的描述符来描述。
如果再把一个TI为1的选择子装入到段寄存器，将引起异常。
3.中断描述符表寄存器IDTR
中断描述符表寄存器IDTR指向中断描述符表IDT。如图10.9所示，IDTR长48位，
其中32位的基地址规定IDT的基地址，16位的界限规定IDT的段界限。
由于80386只支持256个中断/异常，所以IDT表最大长度是2K，以字节为单位的段界限为7FFH。
IDTR指示IDT表的方式与GDTR指示GDT表的方式相同。
4.任务状态段寄存器TR
任务状态段寄存器TR包含指示描述当前任务的任务状态段的描述符选择子，从而规定了当前任务的状态段。
任务状态段的格式在10.5.2节说明。如图10.9所示，TR也有程序员可见和不见两部分。
当把任务状态段的选择子装入到TR可见部分时，处理器自动把选择子所索引的描述符中的段基地址等信息保存到不可见的高速缓冲寄存器中。
在此之后，对当前任务状态段的访问可快速方便地进行。
装入到TR的选择子不能为空，必须索引位于GDT中的描述符，且描述符的类型必须是TSS。
DESCRIPTOR <LIMITL  DW,BASEL   DW,BASEM DB,ATTRIBUTES DW,BASEH  DB>
ATTRIBUTES GD00   LIMITH   P DPL DT   TYPE
位15-位3         位2   位1-位0
 描述符索引     TI     RPL
空选择子是特别定义的，一般把它置成全0。
空选择子装入LDTR，表示当前任务没有LDT。
在这种情况下，所有装入到段寄存器的选择子都必须指示GDT中的描述符，也即当前任务涉及的段均由GDT中的描述符来描述。
如果再把一个TI为1的选择子装入到段寄存器，将引起异常。
TI=0指示从全局描述符表GDT中读取描述符；TI=1指示从局部描述符表LDT中读取描述符。
一般从GDT读取描述符 TI=0 RPL=00H
一般从LDT读取描述符 TI=1 RPL=11H
实模式下，GD00=0000=0
保护模式下，GD00=1100=C
G=0表示界限粒度为字节，G=1表示界限粒度是4K字节
在描述可执行段的描述符中，D位决定了指令使用的地址及操作数所默认的大小。
D=1表示默认情况下指令使用32位地址及32位或8位操作数，这样的代码段也称为32位代码段；
D=0表示默认情况下使用16位地址及16位或8位的操作数，这样的代码段也称为16位代码段，它与80286兼容。
在向低扩展数据段的描述符中，D位决定段的上部边界。
D=1表示段的上部界限为4G；D=0表示段的上部界限为64K，这是为了与80286兼容。
在描述由SS寄存器寻址的段描述符中，D位决定隐式的堆栈访问指令使用何种堆栈指针寄存器。
D=1表示使用32位堆栈指针寄存器ESP；D=0表示使用16位堆栈指针寄存器SP，这与80286兼容。
应用程序存储段 P DPL DT 一般为1111 = F
操作系统存储段 P DPL DT 一般为1001 = 9
P位称为存在（Present）位。
P=1表示描述符对地址转换是有效的，或者表示该描述符所描述的段存在；P=0表示描述符对地址转换无效，并且使用该描述符会引起异常。
DPL表示描述符特权级（Descriptor Privilege Level），共2位。
它规定了所描述段的特权级，用于特权检查，以决定对该段能否进行访问。
DT位说明描述符的类型。
对于存储段描述符而言，DT=1，以区别于系统段描述符和门描述符（DT=0）。
TYPE 0 ED  W A  数据段 堆栈段
         1 C    R  A   代码段
位0指示描述符是否被访问（Accessed），用符号A标记。A=0表示尚未被访问，A=1表示段已被访问。
位3指示所描述的段是代码段还是数据段，用符号E标记。
E=0表示段是不可执行段，也就是数据段，相应的描述符也就是数据段（包括堆栈段）描述符。
E=1表示段是可执行段，也就是代码段，相应的描述符也就是代码段描述符。
在数据段描述符中（E=0的情况），TYPE中的位1指示所描述的数据段是否可写，用W标记。
W=0表示对应的数据段不可写，只能读，W=1表示对应的数据段可写。
TYPE中的位2就是ED位，指示所描述的数据段的扩展方向。
ED=0表示数据段向高扩展，也即段内偏移必须小于等于段界限。ED=1表示数据段向低扩展，也即段内偏移必须大于段界限。
在代码段描述符中（E=1的情况），TYPE中的位1指示所描述的代码段是否可读，用符号R标记。
R=0表示对应的代码段不可读，只能执行，R=1表示对应的代码段可读可执行。
TYPE中的位2指示所描述的代码段是否是一致码段，用C代表。
C=0表示对应的代码段不是一致码段（普通代码段），C=1表示对应的代码段是一致码段。
       31                                            16 15        11                 4   3   2    1     0
CR0 PG 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 ET TS EM MP PE
CR1 保留
CR2 页故障线性地址
CR3 页目录表物理页码                                      0 0 0 0 0 0 0 0 0 0 0 0
PG         PE         处理器工作方式
0            0           实方式
0            1           保护方式，禁用分页机制
1            0            非法组合
1            1            保护方式，启用分页机制
          31              0 15       0
GDTR  Base             Limit
IDTR    Base             Limit
          15      0 31         0 31         0 11         0
LDTR 选择子   Base            Limit     Attributes
TR     选择子    Base           Limit      Attributes
PDESC STRUC
LIMIT DW 0
BASE DD 0
PDESC ENDS
10.4实方式与保护方式切换实例
本节介绍两个实现实方式与保护方式切换的实例，通过它们说明如何实现实方式与保护方式的切换，也说明保护方式下的80386及其编程。
10.4.1演示实方式和保护方式切换的实例（实例一）
实例一的逻辑功能是，以十六进制数的形式显示从内存地址110000H开始的256个字节的值。
本实例指定该内存区域的目的仅仅是想说明切换到保护方式的必要性，因为在实方式下不能访问该指定内存区域，
只有在保护方式下才能访问到该指定区域。
本实例的具体实现步骤是：
（1）作切换到保护方式的准备；
（2）切换到保护方式；
（3）把指定内存区域的内容传送到位于常规内存的缓冲区中；
（4）切换回实方式；
（5）显示缓冲区内容。
JMP FAR PTR 标号对应的机器指令为
EA 16位偏移 16位段值
DESCRIPTOR <LIMITL  DW,BASEL   DW,BASEM DB,ATTRIBUTES DW,BASEH  DB>
PDESC <LIMIT DW,BASE DD>
1.实例一源程序
实例一的源程序如下所示：
；程序名：T10-1.ASM
：功能：演示实方式和保护方式切换
JUMP MACRO selector,offsetv
DB 0EAH
DW offsetv
DW selector
ENDM
ECHOCH MACRO ascii
MOV AH,2
MOV DL,ascii
INT 21H
ENDM
DESCRIPTOR STRUC
LIMITL DW 0
BASEL DW 0
BASEM DB 0
ATTRIBUTES DW 0
BASEH DB 0
DESCRIPTOR ENDS
PDESC STRUC
LIMIT DW 0
BASE DD 0
PDESC ENDS
ATDW = 92H
ATCE = 98H
.386P
DSEG SEGMENT USE16
GDT LABEL BYTE
DUMMY DESCRIPTOR <>
CODE DESCRIPTOR <0FFFFH,,,ATCE,>
CODE_SEL = CODE - GDT
DATAS DESCRIPTOR <0FFFFH,0H,11H,ATDW,0>
DATAS_SEL = DATAS - GDT
DATAD DESCRIPTOR <0FFFFH,,,ATDW,>
DATAD_SEL = DATAD - GDT
GDTLEN = $ - GDT
VGDTR PDESC <GDTLEN - 1,>
BUFFERLEN = 256
BUFFER DB BUFFERLEN DUP (0)
DSEG ENDS
CSEG SEGMENT USE16
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV BX,16
MUL BX
ADD AX,OFFSET GDT
ADC DX,0
MOV WORD PTR VGDTR.BASE,AX
MOV WORD PTR VGDTR.BASE+2,DX
MOV AX,CS
MUL BX
MOV CODE.BASEL,AX
MOV CODE.BASEM,DL
MOV CODE.BASEH,DH
MOV AX,DS
MUL BX
ADD AX,OFFSET BUFFER
ADC DX,0
MOV DATAD.BASEL,AX
MOV DATAD.BASEM,DL
MOV DATAD.BASEH,DH
LGDT QWORD PTR VGDTR
CLI
CALL ENABLEA20
MOV EAX,CR0
OR EAX,1
MOV CR0,EAX
JUMP <CODE_SEL>,<OFFSET VIRTUAL>
VIRTUAL:MOV AX,DATAS_SEL
MOV DS,AX
MOV AX,DATAD_SEL
MOV ES,AX
CLD
XOR SI,SI
XOR DI,DI
MOV CX,BUFFERLEN / 4
REPZ MOVSD
MOV EAX,CR0
AND EAX,0FFFFFFFEH
MOV CR0,EAX
JUMP <SEG REAL>,<OFFSET REAL>
REAL:CALL DISABLEA20
STI
MOV AX,DSEG
MOV DS,AX
MOV SI,OFFSET BUFFER
CLD
MOV BP,BUFFERLEN / 16
NEXTLINE:MOV CX,16
NEXTCH:LODSB
PUSH AX
SHR AL,4
CALL TOASCII
ECHOCH AL
POP AX
CALL TOASCII
ECHOCH AL
ECHOCH 20H
LOOP NEXTCH
ECHOCH 0DH
ECHOCH 0AH
DEC BP
JNZ NEXTLINE
MOV AX,4C00H
INT 21H
TOASCII PROC
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
RET
TOASCII ENDP
ENABLEA20 PROC
PUSH AX
IN AL,92H
OR AL,2
OUT 92H,AL
POP AX
RET
ENABLEA20 ENDP
DISABLEA20 PROC
PUSH AX
IN AL,92H
AND AL,0FDH
OUT 92H,AL
POP AX
RET
DISABLEA20 ENDP
CSEG ENDS
END START
在DOSBOX下测试通过
测试通过的完整程序如下
JUMP MACRO selector,offsetv
DB 0EAH
DW offsetv
DW selector
ENDM
ECHOCH MACRO ascii
MOV AH,2
MOV DL,ascii
INT 21H
ENDM
DESCRIPTOR STRUC
LIMITL DW 0
BASEL DW 0
BASEM DB 0
ATTRIBUTES DW 0
BASEH DB 0
DESCRIPTOR ENDS
PDESC STRUC
LIMIT DW 0
BASE DD 0
PDESC ENDS
ATDW = 92H
ATCE = 98H
.386P
DSEG SEGMENT USE16
GDT LABEL BYTE
DUMMY DESCRIPTOR <>
CODE DESCRIPTOR <0FFFFH,,,ATCE,>
CODE_SEL = CODE - GDT
DATAS DESCRIPTOR <0FFFFH,0H,11H,ATDW,0>
DATAS_SEL = DATAS - GDT
DATAD DESCRIPTOR <0FFFFH,,,ATDW,>
DATAD_SEL = DATAD - GDT
GDTLEN = $ - GDT
VGDTR PDESC <GDTLEN - 1,>
BUFFERLEN = 256
BUFFER DB BUFFERLEN DUP (0)
DSEG ENDS
CSEG SEGMENT USE16
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV BX,16
MUL BX
ADD AX,OFFSET GDT
ADC DX,0
MOV WORD PTR VGDTR.BASE,AX
MOV WORD PTR VGDTR.BASE+2,DX
MOV AX,CS
MUL BX
MOV CODE.BASEL,AX
MOV CODE.BASEM,DL
MOV CODE.BASEH,DH
MOV AX,DS
MUL BX
ADD AX,OFFSET BUFFER
ADC DX,0
MOV DATAD.BASEL,AX
MOV DATAD.BASEM,DL
MOV DATAD.BASEH,DH
LGDT QWORD PTR VGDTR
CLI
CALL ENABLEA20
MOV EAX,CR0
OR EAX,1
MOV CR0,EAX
JUMP <CODE_SEL>,<OFFSET VIRTUAL>
VIRTUAL:MOV AX,DATAS_SEL
MOV DS,AX
MOV AX,DATAD_SEL
MOV ES,AX
CLD
XOR SI,SI
XOR DI,DI
MOV CX,BUFFERLEN / 4
REPZ MOVSD
MOV EAX,CR0
AND EAX,0FFFFFFFEH
MOV CR0,EAX
JUMP <SEG REAL>,<OFFSET REAL>
REAL:CALL DISABLEA20
STI
MOV AX,DSEG
MOV DS,AX
MOV SI,OFFSET BUFFER
CLD
MOV BP,BUFFERLEN / 16
NEXTLINE:MOV CX,16
NEXTCH:LODSB
PUSH AX
SHR AL,4
CALL TOASCII
ECHOCH AL
POP AX
CALL TOASCII
ECHOCH AL
ECHOCH 20H
LOOP NEXTCH
ECHOCH 0DH
ECHOCH 0AH
DEC BP
JNZ NEXTLINE
MOV AX,4C00H
INT 21H
TOASCII PROC
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
RET
TOASCII ENDP
ENABLEA20 PROC
PUSH AX
IN AL,92H
OR AL,2
OUT 92H,AL
POP AX
RET
ENABLEA20 ENDP
DISABLEA20 PROC
PUSH AX
IN AL,92H
AND AL,0FDH
OUT 92H,AL
POP AX
RET
DISABLEA20 ENDP
CSEG ENDS
END START
2.关于实现步骤的注释
在源程序中首定义了两条宏指令，一条是段间直接转移宏指令，另一条是显示字符宏指令。
此外还定义了描述符和伪描述符的结构类型。下面对各实现步骤作些说明。
（1）切换到保护方式的准备工作
在从实方式切换到保护方式之前，必须作必要的准备。准备工作的内容根据实际应用而定。
最起码的准备工作是建立合适的全局描述符表，并使GDTR指向该GDT。
因为在切换到保护方式之时，至少要把代码段的选择子装载到CS，所以GDT中至少要含有代码段的描述符。
从本实例源程序可见，全局描述符表GDT仅有四个描述符：第一个是空描述符；第二个是代码段描述符；第三和第四个是数据段描述符。
本实例各描述符中的段界限是在定义时预置的，并且除伪描述符VGDTR中的界限按GDT的实际长度设置外，
各使用的存储段描述符的界限都规定为0FFFFH。
另外，描述符中的段属性也根据所描述段的类型被预置，98H表示存在的只可执行代码段，92H表示存在的可读写数据段。
从属性值可知，这三个存储段都是16位段。
由于在切换到保护方式后，就要引用GDT，所以在切换到保护方式前须装载GDTR。
本实例使用如下指令装载GDTR：
LGDT QWORD PTR VGDTR
该指令的功能是把存储器中的伪描述符VGDTR装入到全局描述符表寄存器GDTR。
伪描述符VGDTR的结构如前述结构类型PDESC所示，低字是以字节为单位的界限，高双字是基地址。在10.8节中对LGDT指令作详细说明。
（2）由实方式切换到保护方式
在做好准备后，从实方式切换到保护方式并不繁难。原则上只要把控制寄存器CR0中的PE位置1就可。本实例采用如下三条指令设置PE位：
MOV EAX,CR0  把CR0复制到EAX
OR EAX,1          把对应的PE位置1
MOV CR0,EAX  把EAX复制到CR0 使CR0的PE位为1
实际情况要比这复杂些。在执行上面的三条指令后，处理器转入保护方式，但CS中的内容还是实方式下代码段的段值，
而不是保护方式下代码段的选择子，所以在取指令之前得把代码段选择子装入CS。
为此，紧接着这三条指令，安排一条如下所示的段间转移指令：
JUMP <CODE_SEL>,<OFFSET VIRTUAL>
这条段间转移指令在实方式下被预取，在保护方式下被执行。
利用这条段间转移指令可把保护方式下代码段的选择子装入CS，同时也刷新指令预取队列。从此真正进入保护方式。
（3）由保护方式切换到实方式
在80386上，从保护方式切换到实方式的过程类似于从实方式切换到保护方式。原则上只要把控制寄存器CR0中的PE位清0就可。
实际上，在此之后也要安排一条段间转移指令，一方面清指令预取队列，另一方面把实方式下代码段的段值送CS。
这条段间转移指令在保护方式下被预取，在实方式下被执行。
（4）传送
传送是在保护方式下进行的。首先，把源数据段和目标数据段描述符的选择子装入DS和ES寄存器，这两个描述符已在实方式下设置好，
把选择子装入段寄存器就意味着把包括段基地址在内的段信息装入段描述符高速缓冲寄存器。
然后，设置指针寄存器SI和DI的初值，也设置计数器CX初值。
根据预置的段属性，在保护方式下，代码段也仅是16位段，串操作指令只使用16位的SI、DI和CX等寄存器。
最后利用串操作指令实施传送。
（5）显示缓冲区内容
由于缓冲区在常规内存中，所以在实方式下根据要求按十六进制显示其内容是容易的。
3.内存映象
源程序中没有把GDT单独作为一个段对待，但在进入保护方式后，它是一个独立的段。从对代码段和源数据段描述符所赋的基地址和界限可见，
代码段和数据段有部分覆盖。尽管这样做不利于代码和数据的安全，但如果需要，这样做是可行的。本实例运行时的内存映象如图10.11所示。
4.特别说明
作为第一个实方式和保护方式切换的例子，本实例作了大量的简单化处理。
通常由实方式切换到保护方式的准备工作还应包含建立中断描述符表。但本实例没有建立中断描述符表。
为此，要求整个过程在关中断的情况下进行，要求不使用软中断指令，假设不发生任何异常。否则会导致系统崩溃。
本实例没有使用局部描述符表，所以在进入保护方式后没有设置局部描述符表寄存器LDTR。
为此，在保护方式下使用的段选择子都指定GDT中的描述符。
本实例没有定义保护方式下的堆栈段，GDT中没有堆栈段描述符，在保护方式下没有设置SS，所以在保护方式下没有涉及堆栈操作的指令。
本实例各描述符特权级DPL和各选择子请求特权级RPL均是0，在保护方式下执行时的当前特权级CPL也是0。
本实例没有采用分页管理机制，也即CR0中的PG位为0，线性地址就是存储单元的物理地址。
5.打开和关闭地址线A20
PC及其兼容机的第20根地址线较特殊，计算机系统中一般安排一个“门”控制该地址线是否有效。
为了访问地址在1M以上的存储单元，应先打开控制地址线A20的“门”。
这种设置与实方式下只使用最低端的1M字节存储空间有关，与处理器是否工作在实方式和保护方式无关。
即使在关闭地址线A20时，也可进入保护方式。
FFFF:FFFF = FFFF0 + FFFF = 10FFEFh
100000h 以上的内存被称为 extend memory，100000h ~ 10FFEFh 这片内存区域在 DOS 下被称为 High Memory（高端内存）。
由于 8086/8088 只有 20 条 address bus，地址 10FFEF 的高 4 位会被抛弃，实际上送上 address bus 的只有 0FFEFh 值，
所以访问 FFFF:FFFF 地址结果只能访问到 1M 以内的地址。这就是 访问 1M 以上地址都会回绕到 1M 内的模值。
由于 80286 具有 24 条 address bus，对于 FFFF:FFFF 地址的访问，会正确得到访问。
访问高端内存时，80286 在 real mode 下和 8086/8088 的行为不一致！
为了使 80286 和 8086/8088 在 real mode 下的行为一致，当 80286 运行在 real mode 时，将 A20 地址线（第 21 条 address bus）置为 0 ，
这样使得 80286 在 real mode 下第 21 条 address line 无效，从而人为保持一致。
 AND Gate（与门电路） 的 IN 输入端中一端接 A20 line 上，另一端接在 keyboard control 8042 上，
而 AND gate 的 OUT 输出端接在 A20 line 上。只有两个 IN 端都为 1 时，OUT 端才为 1
Keyboard Controller 8042 增加了一组命令去控制 A20 Gate 的开/关，
给 8042 发送命令 0xDF 置 A20 gate 有效，给 8042 送命令 0xDD 置 A20 gate 无效。
使用8042控制A20运行太慢了，所以又出现了Fast A20，Fast A20使用92h端口控制A20。
读A20状态
mov dx, 92h
in al, dx
如果al的bit 1为1表示a20打开，否则为0
打开A20
mov dx, 92h
mov al, 02h
out dx, al
92h的bit 0是给机器发复位信号的，所以在向92h写数据时，不要让bit 0为1，否则机器会重新启动。
如何打开和关闭地址线A20与计算机系统的具体设置有关。如下的两个过程，在一般的PC兼容机上都是可行的。
ENABLEA20 PROC
PUSH AX
IN AL,92H
OR AL,2
OUT 92H,AL
POP AX
RET
ENABLEA20 ENDP
DISABLEA20 PROC
PUSH AX
IN AL,92H
AND AL,0FDH
OUT 92H,AL
POP AX
RET
DISABLEA20 ENDP
10.4.2演示32位代码段和16位代码段切换的实例（实例二）
实例二的逻辑功能是，以十六进制数和ASCII字符两种形式显示从内存地址0FFFF0H开始的16个字节的内容。
从功能上看本实例类似于实例一，但在实现方法上却有了改变，它更能反映出实方式和保护方式切换的情况。
具体实现步骤是：
（1）作切换到保护方式的准备；
（2）切换到保护方式的一个32位代码段；
（3）把指定内存区域的内容以字节为单位，转换成对应十六进制数的ASCII码，并直接填入显示缓冲区实现显示；
（4）再变换到保护方式下的一个16位代码段；
（5）把指定内存区域的内容直接作为ASCII码填入显示缓冲区实现显示；
（6）切换回实方式。
1.实例二源程序
实例二的源程序如下所示：
；程序名：T10-2.ASM
；功能：演示实方式和保护方式切换
；说明：该程序使用TASM汇编
JUMP16 MACRO selector,offsetv
DB 0EAH
DW offsetv
DW selector
ENDM
JUMP32 MACRO selector,offsetv
DB 0EAH
DW offsetv
DW 0
DW selector
ENDM
DESCRIPTOR STRUC
LIMITL DW 0
BASEL DW 0
BASEM DB 0
ATTRIBUTES DW 0
BASEH DB 0
DESCRIPTOR ENDS
PDESC STRUC
LIMIT DW 0
BASE DD 0
PDESC ENDS
ATDR = 90H
ATDW = 92H
ATDWA = 93H
ATCE = 98H
ATCE32 = 4098H
DATALEN = 16
.386P
DSEG SEGMENT USE16
GDT LABEL BYTE
DUMMY DESCRIPTOR <>
CODE32_SEL = 08H
CODE32 DESCRIPTOR <CODE32LEN-1,,,ATCE32,>
CODE16_SEL = 10H
CODE16 DESCRIPTOR <0FFFFH,,,ATCE,>
DATAS_SEL = 18H
DATAS DESCRIPTOR <DATALEN-1,0FFF0H,0FH,ATDR,0>
DATAD_SEL = 20H
DATAD DESCRIPTOR <DATALEN * 8 -1,80A0H,0BH,ATDW,0>
STACKS_SEL = 28H
STACKS DESCRIPTOR <0FFFFH,,,ATDWA,>
NORMAL_SEL = 30H
NORMAL DESCRIPTOR <0FFFFH,0,0,ATDW,0>
GDTLEN = $ - GDT
VGDTR PDESC <GDTLEN-1,>
VARSS DW ?
DSEG ENDS
CSEG1 SEGMENT USE16 'REAL'
ASSUME CS:CSEG1,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV BX,16
MUL BX
ADD AX,OFFSET GDT
ADC DX,0
MOV WORD PTR VGDTR.BASE,AX
MOV WORD PTR VGDTR.BASE+2,DX
MOV AX,CSEG2
MUL BX
MOV CODE32.BASEL,AX
MOV CODE32.BASEM,DL
MOV CODE32.BASEH,DH
MOV AX,CSEG3
MUL BX
MOV CODE16.BASEL,AX
MOV CODE16.BASEM,DL
MOV CODE16.BASEH,DH
MOV AX,SS
MUL BX
MOV STACKS.BASEL,AX
MOV STACKS.BASEM,DL
MOV STACKS.BASEH,DH
MOV VARSS,SS
LGDT QWORD PTR VGDTR
CLI
CALL ENABLEA20
MOV EAX,CR0
OR EAX,1
MOV CR0,EAX
JUMP16 <CODE32_SEL>,<OFFSET SPM32>
TOREAL:MOV AX,DSEG
MOV DS,AX
MOV SS,VARSS
CALL DISABLEA20
STI
MOV AH,4CH
INT 21H
ENABLEA20 PROC
PUSH AX
IN AL,92H
OR AL,2
OUT 92H,AL
POP AX
RET
ENABLEA20 ENDP
DISABLEA20 PROC
PUSH AX
IN AL,92H
AND AL,0FDH
OUT 92H,AL
POP AX
RET
DISABLEA20 ENDP
CSEG1 ENDS
CSEG2 SEGMENT USE32 'PM32'
ASSUME CS:CSEG2
SPM32:MOV AX,STACKS_SEL
MOV SS,AX
MOV AX,DATAS_SEL
MOV DS,AX
MOV AX,DATAD_SEL
MOV ES,AX
XOR ESI,ESI
XOR EDI,EDI
MOV ECX,DATALEN
CLD
NEXT:LODSB
PUSH AX
CALL TOASCII
MOV AH,7
SHL EAX,16
POP AX
SHR AL,4
CALL TOASCII
MOV AH,7
STOSD
MOV AL,20H
STOSW
LOOP NEXT
JUMP32 <CODE16_SEL>,<OFFSET SPM16>
TOASCII PROC
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
RET
TOASCII ENDP
CODE32LEN = $
CSEG2 ENDS
CSEG3 SEGMENT USE16 'PM16'
ASSUME CS:CSEG3
SPM16:XOR SI,SI
MOV DI,DATALEN * 3 *2
MOV AH,7
MOV CX,DATALEN
CLD
AGAIN:LODSB
STOSW
LOOP AGAIN
MOV AX,NORMAL_SEL
MOV DS,AX
MOV ES,AX
MOV EAX,CR0
AND EAX,0FFFFFFFEH
MOV CR0,EAX
JMP FAR PTR TOREAL
CSEG3 ENDS
END START
在DOSBOX下测试通过
测试通过的完整程序如下
JUMP16 MACRO selector,offsetv
DB 0EAH
DW offsetv
DW selector
ENDM
JUMP32 MACRO selector,offsetv
DB 0EAH
DW offsetv
DW 0
DW selector
ENDM
DESCRIPTOR STRUC
LIMITL DW 0
BASEL DW 0
BASEM DB 0
ATTRIBUTES DW 0
BASEH DB 0
DESCRIPTOR ENDS
PDESC STRUC
LIMIT DW 0
BASE DD 0
PDESC ENDS
ATDR = 90H
ATDW = 92H
ATDWA = 93H
ATCE = 98H
ATCE32 = 4098H
DATALEN = 16
.386P
DSEG SEGMENT USE16
GDT LABEL BYTE
DUMMY DESCRIPTOR <>
CODE32_SEL = 08H
CODE32 DESCRIPTOR <CODE32LEN-1,,,ATCE32,>
CODE16_SEL = 10H
CODE16 DESCRIPTOR <0FFFFH,,,ATCE,>
DATAS_SEL = 18H
DATAS DESCRIPTOR <DATALEN-1,0FFF0H,0FH,ATDR,0>
DATAD_SEL = 20H
DATAD DESCRIPTOR <DATALEN * 8 -1,80A0H,0BH,ATDW,0>
STACKS_SEL = 28H
STACKS DESCRIPTOR <0FFFFH,,,ATDWA,>
NORMAL_SEL = 30H
NORMAL DESCRIPTOR <0FFFFH,0,0,ATDW,0>
GDTLEN = $ - GDT
VGDTR PDESC <GDTLEN-1,>
VARSS DW ?
DSEG ENDS
CSEG1 SEGMENT USE16 'REAL'
ASSUME CS:CSEG1,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV BX,16
MUL BX
ADD AX,OFFSET GDT
ADC DX,0
MOV WORD PTR VGDTR.BASE,AX
MOV WORD PTR VGDTR.BASE+2,DX
MOV AX,CSEG2
MUL BX
MOV CODE32.BASEL,AX
MOV CODE32.BASEM,DL
MOV CODE32.BASEH,DH
MOV AX,CSEG3
MUL BX
MOV CODE16.BASEL,AX
MOV CODE16.BASEM,DL
MOV CODE16.BASEH,DH
MOV AX,SS
MUL BX
MOV STACKS.BASEL,AX
MOV STACKS.BASEM,DL
MOV STACKS.BASEH,DH
MOV VARSS,SS
LGDT QWORD PTR VGDTR
CLI
CALL ENABLEA20
MOV EAX,CR0
OR EAX,1
MOV CR0,EAX
JUMP16 <CODE32_SEL>,<0>
TOREAL:MOV AX,DSEG
MOV DS,AX
MOV SS,VARSS
CALL DISABLEA20
STI
MOV AH,4CH
INT 21H
ENABLEA20 PROC
PUSH AX
IN AL,92H
OR AL,2
OUT 92H,AL
POP AX
RET
ENABLEA20 ENDP
DISABLEA20 PROC
PUSH AX
IN AL,92H
AND AL,0FDH
OUT 92H,AL
POP AX
RET
DISABLEA20 ENDP
CSEG1 ENDS
CSEG2 SEGMENT USE32 'PM32'
ASSUME CS:CSEG2
SPM32:MOV AX,STACKS_SEL
MOV SS,AX
MOV AX,DATAS_SEL
MOV DS,AX
MOV AX,DATAD_SEL
MOV ES,AX
XOR ESI,ESI
XOR EDI,EDI
MOV ECX,DATALEN
CLD
NEXT:LODSB
PUSH AX
CALL TOASCII
MOV AH,7
SHL EAX,16
POP AX
SHR AL,4
CALL TOASCII
MOV AH,7
STOSD
MOV AL,20H
STOSW
LOOP NEXT
JUMP32 <CODE16_SEL>,<0>
TOASCII PROC
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
RET
TOASCII ENDP
CODE32LEN = $ - SPM32
CSEG2 ENDS
CSEG3 SEGMENT USE16 'PM16'
ASSUME CS:CSEG3
SPM16:XOR SI,SI
MOV DI,DATALEN * 3 *2
MOV AH,7
MOV CX,DATALEN
CLD
AGAIN:LODSB
STOSW
LOOP AGAIN
MOV AX,NORMAL_SEL
MOV DS,AX
MOV ES,AX
MOV EAX,CR0
AND EAX,0FFFFFFFEH
MOV CR0,EAX
JMP FAR PTR TOREAL
CSEG3 ENDS
END START
2.关于实现步骤的注释
（1）切换到保护方式的准备工作
建立全局描述符表，这里的全局描述符表含有两个16位数据段的描述符、一个16位代码段的描述符和一个16位堆栈段的描述符。
此外，GDT还有一个32位代码段的描述符，描述32位代码段，该描述符的属性字段中的D位是1。
（2）工作方式切换
由实方式切换到保护方式32位代码段的方法与切换到保护方式16位代码段的方法相同。由保护方式16位代码段切换回实方式的方法与实例一相似。
在保护方式下，通过如下直接段间转移指令从32位代码段切换到16位代码段：
JUMP32 <CODE16_SEL>,<0>
从该宏指令的定义可知，该转移指令含48位指针，其高16位是16位代码段的选择子，低32位是16位代码段入口偏移。
该指令在32位方式下预取，在16位方式下执行。由于在32位方式下，所以要使用48位指针。
（3）显示指定区域的内容
在本实例中，采用直接写显示缓冲区的方法实现显示。
假设显示缓冲区的开始物理地址是B8000H，黑底白字显示方式下，在屏幕的第2行上进行显示。
3.特别说明
尽管本实例没有自己专用的堆栈段，但还是在原堆栈的基础上建立了堆栈段，所以在保护方式下使用了涉及堆栈操作的指令。
本实例仍作了大量的简单化处理。如：没有建立IDT和LDT等，各特权级均是0。也没有采用分页管理机制。
从本实例的GDT中可见，两个数据段的界限都是根据实际大小而设置的。
从源程序代码段CSEG3可见，在切换到实方式之前，把一个指向似乎没有用的数据段描述符NORMAL的选择子装载到DS和ES。
这是为什么呢？
表10.4实方式下段描述符高速缓冲寄存器之内容
段寄存器      段基地址      段界限(固定)      存在性 特权级 已存取 粒度 扩展方向 可读性 可写性 可执行 堆栈大小 一致特权
CS              当前CSX16    0000FFFFH        Y         0          Y         B     U             Y          Y         Y         -              N
SS              当前SS×16    0000FFFFH        Y         0          Y         B     U             Y           Y        N        W             -
DS             当前DSX16    0000FFFFH        Y         0          Y         B     U             Y           Y        N         -              -
ES              当前ESX16     0000FFFFH        Y        0          Y         B     U              Y           Y       N         -              -
FS              当前FSX16     0000FFFFH        Y        0          Y         B     U              Y           Y       N         -              -
GS              当前GSX16    0000FFFFH        Y        0          Y         B     U              Y           Y       N         -              -
在10.2.5节中已介绍过每个段寄存器都配有段描述符高速缓冲寄存器，这些高速缓冲寄存器在实方式下仍发挥作用，
只是内容上与保护方式下有所不同。
如表10.4所示，其中“Y”表示“是”；“N”表示“否”；“B”表示字节；“U”表示向高扩展段；“W”表示字方式操作堆栈。
段基地址仍是32位，其值是相应段寄存器值（段值）乘16，在把段值装载到段寄存器时被刷新。
由于其值是16位段值乘上16，所以在实方式下基地址实际有效位只有20位。每个段的32位段界限都固定为0FFFFH，段属性的许多位也是固定的。
所谓固定是指在实方式下必须是表10.4中所列值。但在实方式下，不可设置这些属性值，只能继续沿用保护方式下所设置的值。
因此，在准备结束保护方式回到实方式之前，要通过加载一个合适的描述符的选择子到有关段寄存器，
以使得对应段描述符高速缓冲寄存器中含有合适的段界限和属性。
本实例GDT中的段描述符NORMAL就是这样的一个描述符，在返回实方式之前把对应选择子NORMAL_SEL加载到DS和ES就是为此目的。
由于SS段描述符中的内容已符合实方式的需要，所以尽管在也改变了SS后，但没有重新加载SS。
16位代码段描述符中的内容也符合实方式的需要，所以在通过16位代码段返回时，CS段描述符高速缓冲寄存器中的内容也是符合要求的。
顺便说一下，实例一的描述符都是符合实方式要求的。
4.关于32位代码段程序设计的说明
在32位代码段中，缺省的操作数大小是32位，缺省的存储单元地址大小也是32位。
由于串操作指令使用的指针寄存器是ESI和EDI，LOOP指令使用的计数器是ECX，所以，在代码段CSEG2中，为了使用串操作指令，
对ESI和EDI等寄存器赋初值。请比较代码段CSEG3中的相关片段和实例一中的相关片段，它们是16位代码段。
10.5任务状态段和控制门
每个任务有一个任务状态段TSS，用于保存任务的有关信息，在任务内变换特权级和任务切换时，要使用这些信息。
为了控制任务内发生特权级变换的转移，为了控制任务切换，一般要通过控制门进行这些转移。本节介绍任务状态段和控制门。
10.5.1系统段描述符
系统段是为实现存储管理机制所使用的一种特别的段。在80386中，有两种系统段：任务状态段TSS和局部描述符表LDT段。
用于描述系统段的描述符称为系统段描述符，也称为特殊段描述符。
1.系统段描述符的一般格式
DESCRIPTOR <LIMITL  DW,BASEL   DW,BASEM DB,ATTRIBUTES DW,BASEH  DB>
ATTRIBUTES GD00   LIMITH   P DPL DT   TYPE
ATTRIBUTES GX00   LIMITH   P DPL DT   TYPE
系统段描述符的一般格式如图10.12所示。与图10.5所示的存储段描述符相比，它们很相似，区分的标志是属性字节中的描述符类型位DT的值。
DT=1表示存储段，DT=0表示系统段。系统段描述符中的段基地址和段界限字段与存储段描述符中意义完全相同；
属性中的G位、AVL位、P位和DPL字段的作用也完全相同。存储段描述符属性中的D位在系统段描述符中不使用，现用符号X表示。
系统段描述符的类型字段TYPE仍是4位，其编码及表示的类型列于表10.5，其含义与存储段描述符的类型完全不同。
从表10.5可见，只有类型编码为2、1、3、9和B的描述符才是真正的系统段描述符，它们用于描述系统段LDT和任务状态段TSS，
其它类型的描述符是门描述符。
利用在10.2节中定义的存储段描述符结构类型DESCRIPTOR仍能方便地在程序中说明系统段描述符。
表10.5系统段和门描述符类型字段的编码及含义
类型编码         说明         类型编码         说明
0                  未定义              8                未定义
1                  可用286TSS      9                可用386TSS
2                   LDT                  A               未定义
3                   忙的286TSS     B                忙的386TSS
4                   286调用门        C                386调用门
5                   任务门              D                未定义
6                   286中断门        E                386中断门
7                   286陷阱门        F                386陷阱门
2.LDT段描述符
LDT段描述符描述任务的局部描述符表段。例如：如下描述符LDTABLE描述一个局部描述符表段，基地址是654321H，
以字节为单位的界限是1FH，描述符特权级是0。
LDTABLE DESCRIPTOR <1FH,4321H,65H,82H,0>
LDT段描述符必须安排在全局描述符表中才有效。
在装载LDTR寄存器时，描述符中的LDT段基地址和段界限等信息被装入如图10.9所示的LDTR高速缓冲寄存器中。
          15      0 31         0 31         0 11         0
LDTR 选择子   Base            Limit     Attributes
TR     选择子    Base           Limit      Attributes
3.任务状态段描述符
任务状态段TSS用于保存任务的各种状态信息。任务状态段描述符描述某个任务状态段。TSS描述符分为286TSS和386TSS两类。
TSS描述符规定了任务状态段的基地址和任务状态段的大小。
例如：如下描述符TEMPTASKS描述一个可用的386任务状态段，基地址是123456H，以字节为单位的界限是104，描述符特权级是0。
TEMPTASKS DESCRIPTOR <104,3456H,12H,89H,0>
在装载任务状态段寄存器TR时，描述符中的TSS段基地址和段界限等信息被装入如图10.9所示的TR高速缓冲寄存器中。
在任务切换或执行LTR指令时，要装载TR寄存器。
TSS描述符中的类型规定：TSS要么为“忙”，要么为“可用”。
如果一个任务是当前正执行的任务，或者是用TSS中的链接字段沿挂起任务链接到当前任务上的任务，那么该任务是“忙”的任务；
否则该任务为“可用”任务。
利用段间转移指令JMP和段间调用指令CALL，直接通过TSS描述可实现任务切换。
10.5.2门描述符
除存储段描述符和系统段描述符外，还有一类门描述符。门描述符并不描述某种内存段，而是描述控制转移的入口点。
这种描述符好比一个通向另一代码段的门。通过这种门，可实现任务内特权级的变换和任务间的切换。所以，这种门描述符也称为控制门。
1.门描述符的一般格式
m+7         m+6         m+5         m+4         m+3         m+2         m+1         m
      offset                       Attributes             selector                            offset
31               16                                                                               15             0
Attributes
7      6      5      4      3      2      1      0      7      6      5      4      3      2      1      0
P      DPL         DT    TYPE                                  Dword Count
门描述符的一般格式如图10.13所示。门描述符只有位于描述符内偏移5的类型字节与系统段描述符保持一致，
也由该字节标识门描述符和系统段描述符。该字节内的P和DPL的意义与其他描述符中的意义相同。
其它字节主要用于存放一个48位的全指针（16位的选择子和32位的偏移量）。
根据如图10.13给出的门描述符的结构，可定义如下的门描述符结构类型：
GATE STRUC
OFFSETL DW 0
SELECTOR DW 0
DCOUNT DB 0
GTYPE DB 0
OFFSETH DW 0
GATE ENDS
利用门描述符结构类型GATE能方便地在程序中说明门描述符。
DESCRIPTOR <LIMITL  DW,BASEL   DW,BASEM DB,ATTRIBUTES DW,BASEH  DB>
ATTRIBUTES GD00   LIMITH   P DPL DT   TYPE
ATTRIBUTES GX00   LIMITH   P DPL DT   TYPE
GATE <OFFSETL DW,SELECTOR DW,DCOUNT DB,GTYPE DB,OFFSETH DW>
类型编码         说明         类型编码         说明
0                  未定义              8                未定义
1                  可用286TSS      9                可用386TSS
2                   LDT                  A               未定义
3                   忙的286TSS     B                忙的386TSS
4                   286调用门        C                386调用门
5                   任务门              D                未定义
6                   286中断门        E                386中断门
7                   286陷阱门        F                386陷阱门
例如，如下门描述符SUBRG描述一个386调用门，门内的选择子是10H，入口偏移是123456H，门描述符特权级是3，双字计数是0。
SUBRG GATE <3456H,10H,0,8CH + 60H,0012H>
从表10.5可见，门描述符又可分为：任务门、调用门、中断门和陷阱门，并且除任务门外，其他门描述符还各分成286和386两种。
2.调用门
调用门描述某个子程序的入口。调用门内的选择子必须指向代码段描述符，调用门内的偏移是对应代码段内的偏移。
利用段间调用指令CALL，通过调用门可实现任务内从外层特权级变换到内层特权级。
在图10.13所示门描述符内偏移4字节m+4的位0至位4是双字计数字段，该字段只在调用门描述符中有效，在其它门描述符中无效。
主程序通常通过堆栈把入口参数传递给子程序，如果在利用调用门调用子程序时引起特权级的转换和堆栈的改变，
那么就需要将外层堆栈中的参数复制到内层堆栈。该双字计数字段就是用于说明这种情况发生时，要复制的双字参数的数量。
3.任务门
任务门指示任务。任务门内的选择子必须指向GDT中的任务状态段TSS描述符，门中的偏移无意义。任务的入口点保存在TSS中。
利用段间转移指令JMP和段间调用指令CALL，通过任务门可实现任务切换。
4.中断门和陷阱门
中断门和陷阱门描述中断/异常处理程序的入口点。中断门和陷阱门内的选择子必须指向代码段描述符，门内的偏移就是对应代码段的入口点偏移。
中断门和陷阱门只有在中断描述符表IDT中才有效。关于中断门和陷阱门的区别在10.7节中介绍。
10.5.3任务状态段
任务状态段（Task State Segment）是保存一个任务重要信息的特殊段。任务状态段描述符用于描述这样的系统段。
任务状态段寄存器TR的可见部分含有当前任务的任务状态段描述符的选择子，TR的不可见部分含有当前任务状态段的段基地址和段界限等信息。
TSS在任务切换过程中起着重要作用，通过它实现任务的挂起和恢复。所谓任务切换是指，挂起当前正在执行的任务，恢复另一个任务的执行。
在任务切换过程中，首先，处理器中各寄存器的当前值被自动地保存到TR所指定的TSS中；然后，下一任务的TSS的选择子被装入TR；
最后从TR所指定的TSS中取出各寄存器的值送到处理器的各寄存器中。
由此可见，通过在TSS中保存任务现场各寄存器状态的完整映象，实现任务的切换。
任务状态段TSS的基本格式如图10.14所示。
31                        16  15                0   偏移
0000000000000000   链接字段          0
ESP0                                                    4
0000000000000000    SS0                  8
ESP1                                                    0CH
0000000000000000    SS1                  10H
ESP2                                                    14H
0000000000000000    SS2                  18H
CR3                                                      1CH
EIP                                                        20H
EFLAGS                                                24H
EAX                                                      28H
ECX                                                      2CH
EDX                                                      30H
EBX                                                      34H
ESP                                                      38H
EBP                                                      3CH
ESI                                                       40H
EDI                                                      44H
0000000000000000   ES                     48H
0000000000000000   CS                     4CH
0000000000000000   SS                      50H
0000000000000000   DS                     54H
0000000000000000  FS                       58H
0000000000000000  GS                      5CH
0000000000000000   LDT                   60H
I/O许可位图 偏移        000000000000000 T 64H
104字节=68H字节
从中可见，TSS的基本格式有104字节组成。这104字节的基本格式是不可改变的，但在此之外系统软件还可定义若干附加信息。
基本的104字节可分为链接字段区域、内存堆栈指针区域、地址映射寄存器区域、寄存器保存区域和其它字段等五个区域。
1.寄存器保存区域
寄存器保存区域位于TSS内偏移20H至5FH处，用于保存通用寄存器、段寄存器、指令指针和标志寄存器。
当TSS对应的任务正在执行时，保存区域是未定义的；在当前任务被切换出时，这些寄存器的当前值就保存在该区域。
当下次切换回原任务时，再从保存区域恢复出这些寄存器的值，从而使处理器恢复成该任务换出前的状态，最终使任务能够恢复执行。
从图10.14可见，各通用寄存器对应一个32位的双字，指令指针和标志寄存器各对应一个32位的双字；
各段寄存器也对应一个32位的双字，段寄存器中的选择子只有16位，安排在双字的低16位，高16位空着未用。
2.内层堆栈指针区域
因为每个任务最多可能在四个特权级间转移，所以每个任务最多需要4个堆栈。
当从外层转移到内层时，内层堆栈的SS和ESP从TSS中的SS0、ESP0、SS1、ESP1、SS2、ESP2这里取得。
每当从外层转移到内层时，内层堆栈的SS和ESP都是TSS中确定的，相当于每次内层堆栈都初始化为空。
系统会把返回地址和外层堆栈的指针保留到内层堆栈中，将外层堆栈指针放入到内层堆栈中是为了向外层返回时，保证外层堆栈的正确。
当从内层返回到外层时，将恢复外层堆栈。
从外层到内层，可以通过CALL/JMP来直接转移，但从内层到外层，不能直接通过CALL/JMP，只能通过远程RET，
这样做的原因是为了确保内层的堆栈不被外层代码得知。
因为是从低特权级向高特权级转换，故TSS中没有最外层（最低特权级）的堆栈信息。
任务最开始执行时的SS和ESP就是最外层（最低特权级）的堆栈。
为了有效地实现保护，一个任务在不同的特权级下使用不同的堆栈。
例如，当从外层特权级3变换到内层特权级0时，任务使用的堆栈也同时从3级堆栈变换到0级堆栈；
当从内层特权级0变换到外层特权级3时，任务使用的堆栈也同时从0级堆栈变换到3级堆栈。
所以，一个任务可能具有四个堆栈，对应四个特权级。四个堆栈需要四个堆栈指针。
TSS的内层堆栈指针区域中有三个堆栈指针，它们都是48位的全指针（16位的选择子和32位的偏移），分别指向0级、1级和2级堆栈的栈顶，
依次存放在TSS中偏移为4、12及20开始的位置。当发生向内层转移时，则把适当的堆栈指针装入到SS及ESP寄存器以变换到内层的堆栈，
外层堆栈的指针保存在内层堆栈中。没有指向3级堆栈的指针，因为3级是在最外层，所以任何一个向内层的转移都不可能转移到3级。
但是，当特权级由内层向外层变换时，并不把内层堆栈的指针保存到TSS的内层堆栈指针区域。
这表明向内层转移时，总是把内层堆栈认为是一个空栈。
因此，不允许发生同级内层转移的递归，一旦发生向某级内层转移，那么返回到外层的正常途径是相匹配的向外层返回。
3.地址映射寄存器区域
由虚拟地址空间到线性地址空间的映射由GDT和LDT确定，与特定任务相关的部分由LDT确定，而LDT又由LDTR确定。
如果采用分页机制，那么由线性地址空间到物理地址空间的映射由包含页目录表起始物理地址的控制寄存器CR3确定。
所以，与特定任务相关的虚拟地址空间到物理地址空间的映射由LDTR和CR3确定。显然，随着任务的切换，地址映射关系也要切换。
TSS的地址映射寄存器区域由位于偏移1CH处的双字字段（CR3）和位于偏移60H处的字字段（LDT）组成。
在任务切换时，处理器自动从轮到执行的任务的TSS中取出这两个字段，分别装入到寄存器CR3和寄存器LDTR。
这样就改变了虚拟地址空间到物理地址空间的映射。
但是，在任务切换时，处理器并不把换出任务当时的寄存器CR3和LDTR的内容保存到TSS中的地址映射寄存器区域。
因此，如果程序改变了LDTR或CR3，那么必须把新值保存到TSS中的地址映射寄存器区域相应字段中。
4.链接字段
链接字段安排在TSS内偏移0开始的双字中，其高16位未用。在起链接作用时，低16位保存前一任务的TSS描述符的选择子。
如果当前的任务由段间调用指令CALL或者中断/异常而激活，那么链接字段保存被挂起任务的TSS的选择子，
并且标志寄存器EFLAG中的NT位被置1，使链接字段有效。
在返回时，由于NT位为1，中断返回指令IRET将使得控制沿着链接字段所指恢复到链上的前一个任务。
5.其它字段
为了实现输入/输出保护，要使用I/O许可位图。任务使用的I/O许可位图也存放在TSS中，作为TSS的扩展部分。
在TSS内偏移66H处的字用于存放I/O许可位图在TSS内的开始偏移。关于I/O许可位图的作用在10.9节中介绍。
在TSS偏移102字节处有一个单字被称为“I/O位图基址”（它的值一般为当前地址-TSS基址+2，表示I/O许可位图从TSS的104字节开始），
它的每一位表示一个字节的端口地址是否可用。如果某一位为0，则表示此位对应的端口号可用，为1则不可用。
每一个任务都可以有单独的TSS，故每一个任务可以有它单独的I/O许可位图。I/O许可位图必须以0FFh结尾。
如果I/O位图基址大于或等于TSS段界限，就表示没有I/O许可位图，如果CPL>=IOPL（IO特权级，位于寄存器eflags的第13位），
则所有I/O指令都会引起异常。I/O许可位图的使用使得即便在同一特权级下不同的任务也可以有不同的I/O访问权限。
I/O地址空间由64K个可单独寻址的8位I/O端口组成，I/O许可位图的最大尺寸就是8K字节。
一般这样分配, 从TSS的104字节开始, 列出自己想填写的I/O许可位图, 对于不想列出的后面部分以0FF结束就可以了。
CLI, STI, IN, INS, OUT, OUTS等指令是I/O敏感指令
保护模式下处理器在执行I/O敏感指令时进行许可检查的细节如下所示。 
(1)若CPL<=IOPL，则直接转步骤(8)；
(2)取得I/O位图开始偏移；
(3)计算I/O地址对应位所在字节在I/O许可位图内的偏移；
(4)计算位偏移以形成屏蔽码值，即计算I/O地址对应位在字节中的第几位；
(5)把字节偏移加上位图开始偏移，再加1，所得值与TSS界限比较，若越界，则产生通用保护异常；
(6)若不越界，则从位图中读对应字节及下一个字节；
(7)把读出的两个字节与屏蔽码进行与运算，若结果不为0表示检查未通过，则产生通用保护异常；
(8)进行I/O访问。
INSD, 一次访问4个端口地址, 需要4个位, 有可能低位在一个字节, 高位又在一个字节。 
为了避免这种情况, 处理器每次读取I/O许可位图的时候是2个字节2个字节读取的, 这样， 不管多坏的情况也不可能超过2个字节。
这样在结尾加个0FFh也就比较好理解了, 如果不加那就越界了。 加其他的值也不好区分, 只有每个位加1才不会曲解原来的I/O许可位图.
只有特权级为0的程序才能够修改Eflags中的IOPL和VM位, 相对于IOPL更内层的特权级才能够修改IF位。
 如果特权级不符合要求, 修改这些位的话, 也不会异常, CPU会忽略。
在TSS内偏移64H处的字是为任务提供的特别属性。在80386中，只定义了一种属性，即调试陷阱。
该属性是字的最低位，用T表示。该字的其他位被保留，必须被置成0。
在发生任务切换时，如果进入任务的T位为1，那么在任务切换完成之后，新任务的第一条指令执行之前产生调试陷阱。
6.用结构类型定义TSS
根据如图10.14给出的任务状态段TSS的结构，可定义如下的TSS结构类型：
TASKSS STRUC
DW ?,0
DD ?
DW ?,0
DD ?
DW ?,0
DD ?
DW ?,0
DD ?
DD ?
DW ?,?
DD ?
DD ?
DD ?
DD ?
DD ?
DD ?
DD ?
DD ?
DW ?,0
DW ?,0
DW ?,0
DW ?,0
DW ?,0
DW ?,0
DW ?,0
DW 0
DW $ + 2
DB 0FFH
TASKSS ENDS
DESCRIPTOR <LIMITL  DW,BASEL   DW,BASEM DB,ATTRIBUTES DW,BASEH  DB>
ATTRIBUTES GD00   LIMITH   P DPL DT   TYPE
ATTRIBUTES GX00   LIMITH   P DPL DT   TYPE
GATE <OFFSETL DW,SELECTOR DW,DCOUNT DB,GTYPE DB,OFFSETH DW>
0                  未定义              8                未定义
1                  可用286TSS      9                可用386TSS
2                   LDT                  A               未定义
3                   忙的286TSS     B                忙的386TSS
4                   286调用门        C                386调用门
5                   任务门              D                未定义
6                   286中断门        E                386中断门
7                   286陷阱门        F                386陷阱门
位15-位3         位2   位1-位0
 描述符索引     TI     RPL
空选择子是特别定义的，一般把它置成全0。
空选择子装入LDTR，表示当前任务没有LDT。
在这种情况下，所有装入到段寄存器的选择子都必须指示GDT中的描述符，也即当前任务涉及的段均由GDT中的描述符来描述。
如果再把一个TI为1的选择子装入到段寄存器，将引起异常。
TI=0指示从全局描述符表GDT中读取描述符；TI=1指示从局部描述符表LDT中读取描述符。
一般从GDT读取描述符 TI=0 RPL=00H
一般从LDT读取描述符 TI=1 RPL=11H
实模式下，GD00=0000=0
保护模式下，GD00=1100=C
G=0表示界限粒度为字节，G=1表示界限粒度是4K字节
在描述可执行段的描述符中，D位决定了指令使用的地址及操作数所默认的大小。
D=1表示默认情况下指令使用32位地址及32位或8位操作数，这样的代码段也称为32位代码段；
D=0表示默认情况下使用16位地址及16位或8位的操作数，这样的代码段也称为16位代码段，它与80286兼容。
在向低扩展数据段的描述符中，D位决定段的上部边界。
D=1表示段的上部界限为4G；D=0表示段的上部界限为64K，这是为了与80286兼容。
在描述由SS寄存器寻址的段描述符中，D位决定隐式的堆栈访问指令使用何种堆栈指针寄存器。
D=1表示使用32位堆栈指针寄存器ESP；D=0表示使用16位堆栈指针寄存器SP，这与80286兼容。
应用程序存储段 P DPL DT 一般为1111 = F
操作系统存储段 P DPL DT 一般为1001 = 9
P位称为存在（Present）位。
P=1表示描述符对地址转换是有效的，或者表示该描述符所描述的段存在；P=0表示描述符对地址转换无效，并且使用该描述符会引起异常。
DPL表示描述符特权级（Descriptor Privilege Level），共2位。
它规定了所描述段的特权级，用于特权检查，以决定对该段能否进行访问。
DT位说明描述符的类型。
对于存储段描述符而言，DT=1，以区别于系统段描述符和门描述符（DT=0）。
TYPE 0 ED  W A  数据段 堆栈段
         1 C    R  A   代码段
位0指示描述符是否被访问（Accessed），用符号A标记。A=0表示尚未被访问，A=1表示段已被访问。
位3指示所描述的段是代码段还是数据段，用符号E标记。
E=0表示段是不可执行段，也就是数据段，相应的描述符也就是数据段（包括堆栈段）描述符。
E=1表示段是可执行段，也就是代码段，相应的描述符也就是代码段描述符。
在数据段描述符中（E=0的情况），TYPE中的位1指示所描述的数据段是否可写，用W标记。
W=0表示对应的数据段不可写，只能读，W=1表示对应的数据段可写。
TYPE中的位2就是ED位，指示所描述的数据段的扩展方向。
ED=0表示数据段向高扩展，也即段内偏移必须小于等于段界限。ED=1表示数据段向低扩展，也即段内偏移必须大于段界限。
在代码段描述符中（E=1的情况），TYPE中的位1指示所描述的代码段是否可读，用符号R标记。
R=0表示对应的代码段不可读，只能执行，R=1表示对应的代码段可读可执行。
TYPE中的位2指示所描述的代码段是否是一致码段，用C代表。
C=0表示对应的代码段不是一致码段（普通代码段），C=1表示对应的代码段是一致码段。
       31                                            16 15        11                 4   3   2    1     0
CR0 PG 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 ET TS EM MP PE
CR1 保留
CR2 页故障线性地址
CR3 页目录表物理页码                                      0 0 0 0 0 0 0 0 0 0 0 0
PG         PE         处理器工作方式
0            0           实方式
0            1           保护方式，禁用分页机制
1            0            非法组合
1            1            保护方式，启用分页机制
          31              0 15       0
GDTR  Base             Limit
IDTR    Base             Limit
          15      0 31         0 31         0 11         0
LDTR 选择子   Base            Limit     Attributes
TR     选择子    Base           Limit      Attributes
PDESC STRUC
LIMIT DW 0
BASE DD 0
PDESC ENDS
门描述符的一般格式
m+7         m+6         m+5         m+4         m+3         m+2         m+1         m
      offset                       Attributes             selector                            offset
31               16                                                                               15             0
Attributes
7      6      5      4      3      2      1      0      7      6      5      4      3      2      1      0
P      DPL         DT    TYPE                                  Dword Count
任务状态段TSS的基本格式有104字节组成。这104字节的基本格式是不可改变的，但在此之外系统软件还可定义若干附加信息。
31                        16  15                0   偏移
0000000000000000   链接字段          0
ESP0                                                    4
0000000000000000    SS0                  8
ESP1                                                    0CH
0000000000000000    SS1                  10H
ESP2                                                    14H
0000000000000000    SS2                  18H
CR3                                                      1CH
EIP                                                        20H
EFLAGS                                                24H
EAX                                                      28H
ECX                                                      2CH
EDX                                                      30H
EBX                                                      34H
ESP                                                      38H
EBP                                                      3CH
ESI                                                       40H
EDI                                                      44H
0000000000000000   ES                     48H
0000000000000000   CS                     4CH
0000000000000000   SS                      50H
0000000000000000   DS                     54H
0000000000000000  FS                       58H
0000000000000000  GS                      5CH
0000000000000000   LDT                   60H
I/O许可位图基地址     000000000000000 T 64H
一般情况下代码都在自己的级别下做自己的工作，同一级别之间可以相互访问，不同级别之间不允许随意访问。
有时候，允许低特权级别的程序访问高特权级别的程序，比如应用程序调用系统的接口函数等。
非一致代码就是需要隔离的代码，低特权级别不允许随意访问，同一特权级别可以相互访问。
一致代码就是不需要隔离的代码，允许被同特权级别或低特权级别代码调用。
通过DPL、RPL、CPL实现特权分级和特权级检查 
DPL 描述符特权（Descriptor Privilege Level）存储在描述符中，用于描述段的特权等级。
RPL 请求特权（Request Privilege Level）存储在选择子的最低两位，说明当前对段访问的请求权限。
不要想随便设置一个rpl来访问一个比cpl更内层的段，因为申请的权限一定要比你实际权限低才能通过CPU的审查。 
CPL 当前任务特权（Current Privilege Level）表示当前代码段的特权级。CPL保存在CS中的最低两位，当选择子成功装入CS寄存器后，
相应的选择子中的RPL就变成了CPL。CS与SS的特权级必须保持一致。
访问一个段时，需要检查特权级，一般要求max {CPL, RPL} ≤ DPL。
访问数据段或堆栈段的程序的CPL≤待访问的数据段或堆栈段的DPL，同时选择子的RPL≤待访问的数据段或堆栈段的DPL，
即程序访问数据段或堆栈段要遵循一个准则：只有相同或更高特权级的代码才能访问相应的数据段。
访问数据段或堆栈段时，默认用CPU和RPL中的最小特权级去访问数据段，所以max {CPL, RPL} ≤ DPL，否则访问失败。
所有的程序跳转，都只能跳到等于当前特权级或比当前特权级更高的段。
所有的JMP，成功跳转后程序的CPL(CS.RPL) = 跳转前程序的CPL(CS.RPL) 
所有的CaLL，成功跳转到一致代码段后程序的CPL(CS.RPL) = 跳转前程序的CPL(CS.RPL)
成功跳转到非一致代码段后程序的CPL(CS.RPL) = 跳转后程序的Descriptor.DPL
RPL让程序有需要的时候（检查特权级的时候）可以表示一个比特权级CPL更低的身份Max(RPL,CPL)，而不会失去本身的特权级CPL(CS.RPL)，
RPL的值在成功跳转后并不赋给跳转后的CS.RPL。
普通跳转（没有经过Gate 这东西）：即JMP或Call后跟着48位全指针（16位段选择子+32位地址偏移），且其中的段选择子指向代码段描述符，
这样的跳转称为直接（普通）跳转。普通跳转不能使特权级发生跃迁，即不会引起CPL的变化。
目标是一致代码段：
要求：CPL(CS.RPL)>=DestinationDescriptorCode.DPL ，其他RPL是不检查的。只能外层特权级跳转到内层特权级，或者同特权级跳转。
跳转后程序的CPL(NewCS.RPL) = 跳转前程序的CPL( OldCS.RPL)
CPL没有发生变化，纵使它执行了特权级（DPL）较高的代码。
若访问时不满足要求，则发生异常。如果从内层特权级跳转到外层特权级，则发生异常。
目标是非一致代码段：
要求：CPL(CS.RPL)＝DestinationDescriptorCode.DPL AND RPL≤CPL(CS.RPL)
跳转后程序的CPL(NewCS.RPL) = DestinationDescriptorCode.DPL
因为前提是CPL=DPL，所以跳转后程序的CPL(NewCS.RPL) = DestinationDescriptorCode.DPL不会改变CPL的值，特权级(CPL)也没有发生变化。
如果访问时不满足前提CPL=DPL，则引发异常。
通过调用门的跳转：当段间转移指令JMP和段间转移指令CALL后跟着的目标段选择子指向一个调用门描述符时，该跳转就是利用调用门的跳转。
这时如果选择子后跟着32位的地址偏移，也不会被cpu使用，因为调用门描述符已经记录了目标代码的偏移。
使用调用门进行的跳转比普通跳转多一个步骤，即在访问调用门描述符时要将调用门描述符当作一个数据段来检查访问权限，
要求指示调用门描述符的选择子的RPL≤调用门描述符DPL，同时当前代码段CPL≤调用门描述符DPL，
就如同访问数据段一样，要求访问数据段的程序的CPL≤待访问的数据段的DPL，同时选择子的RPL≤待访问的数据段的DPL。
只有满足了以上条件，CPU才会进一步从调用门描述符中读取目标代码段的选择子和地址偏移，进行下一步的操作。
从调用门中读取到目标代码的段选择子和地址偏移后，我们当前掌握的信息又回到了先前，和普通跳转站在了同一条起跑线上
（普通跳转一开始就得到了目标代码的段选择子和地址偏移），有所不同的是，此时，CPU会将读到的目标代码段选择子中的RPL清0，
即忽略了调用门中代码段选择子的RPL的作用。完成这一步后，CPU开始对当前程序的CPL，目标代码段选择子的RPL
（事实上它被清0后总能满足要求）以及由目标代码选择子指示的目标代码段描述符中的DPL进行特权级检查，并根据情况进行跳转。
目标是一致代码段：
要求：CPL(CS.RPL)≥DestinationDescriptorCode.DPL ，RPL不检查。只能外层特权级跳转到内层特权级，或者同特权级跳转。
跳转后程序的CPL(NewCS.RPL) = 跳转前程序的CPL( OldCS.RPL)，因此特权级没有发生跃迁。
目标是非一致代码段：
当用JMP指令跳转时：
要求：CPL(CS.RPL)＝DestinationDescriptorCode.DPL　AND　RPL<= CPL(CS.RPL)
事实上因为RPL被清0，所以RPL≤CPL总能满足，因此RPL与CPL的关系在此不检查。若不满足要求则程序引起异常。
跳转后程序的CPL(NewCS.RPL) = DestinationDescriptorCode.DPL
因为前提是CPL=DPL，所以跳转后程序的CPL(NewCS.RPL) = DestinationDescriptorCode.DPL不会改变CPL的值，特权级也没有发生变化。
如果访问时不满足前提CPL=DPL，则引发异常。
当用CALL指令跳转时：
要求：CPL(CS.RPL)≥DestinationDescriptorCode.DPL（RPL被清0，不检查），若不满足要求则程序引起异常。
跳转后程序的CPL(NewCS.RPL) = DestinationDescriptorCode.DPL
当条件CPL=DPL时，程序跳转后CPL=DPL,特权级不发生跃迁；
当CPL＞DPL时，程序跳转后CPL=DPL,特权级发生跃迁。
这是目前见到的唯一使程序CPL发生变化的跳转方法，即用CALL指令+调用门方式跳转，且目标代码段是非一致代码段。
也就是从外层优先级跳转到内层优先级的非一致代码段。特权级发生变化，会引起堆栈切换，会切换为目的代码段相应特权级的堆栈。
10.6控制转移
控制转移基本上可分为两大类：同一任务内的控制转移和任务间的控制转移（任务切换）。
同一任务内的控制转移又分为：段内转移、特权级不变的段间转移和特权级变换的段间转移。
段内转移与实方式下相似，不涉及特权级变换和任务切换。只有段间转移才涉及特权级变换和任务切换。
本节介绍保护方式下的控制转移，重点是任务内的特权级变换和任务间的切换。
10.6.1任务内无特权级变换的转移
各种段内转移与实方式下相似，当然不涉及特权级变换和任务切换。只有各种形式的段间转移才涉及特权级变换和任务切换。
1.段间转移指令
与实方式下一样，指令JMP、CALL和RET都具有段间转移的功能，指令INT和IRET总是段间转移。
此外，中断/异常也将引起段间转移。有时把这些具有段间转移功能的指令统称为段间转移指令。
在保护方式下，段间转移的目标位置由选择子和偏移构成的地址表示，常把它称为目标地址指针。
在32位代码段中，上述指针内的偏移使用32位表示，这样的指针也称为48位全指针。
在实例二的32位代码段内就使用了48位全指针。在16位代码段中，上述指针内的偏移只使用16位表示。
与实方式下相似，段间转移指令JMP和段间调用指令CALL还可分为段间直接转移和段间间接转移两类。
如果指令JMP和CALL在指令中直接含有目标地址指针，那么就是段间直接转移；
如果指令中含有指向包含目标地址指针的门描述符或TSS描述符的指针，那么就是段间间接转移，
这种指针只有选择子部分有效，指示调用门、任务门或TSS描述符，而偏移部分不起作用。
实际上，当段间转移指令JMP和段间调用指令CALL所含指针的选择子部分指示代码段描述符，那么就是段间直接转移，
偏移部分表示目标代码段的入口点；当选择子部分指示门描述符或TSS描述符时，就是段间间接转移。
2.向目标代码段转移的步骤
处理器在执行上述段间转移指令向目标代码段实施转移的过程中，一般至少要经过如下步骤：
（1）判别目标地址指针内的选择子指示的描述符是否为空描述符。
空描述符是GDT中的第0个描述符，是一个特殊的描述符。目标代码段描述符不能为空描述符，也即选择子的高14位不能为0。
（2）从全局或者局部描述符表内读出目标代码段描述符。
由选择子内的TI位，确定使用全局描述符表还是局部描述表。
（3）根据情况，检测描述符类型是否正确；调整RPL。
（4）把目标代码段描述符内的有关内容装载到CS高速缓冲寄存器。
（5）判别目标地址指针内的偏移是否越出代码段。
目标地址指针内的偏移必须不超过目标代码段界限。
（6）装载CS段寄存器和指令指针寄存器EIP；CPL存入CS内选择子的RPL字段。
上述步骤只是对转移过程的简单说明，实际的动作还要复杂。
在把目标代码段描述符内的有关内容装载到CS高速缓冲寄存器时，还要进行如下保护检测，其中的DPL表示目标代码段描述符特权级：
（1）对于非一致代码段，要求CPL=DPL，RPL<=DPL；对于一致代码段，要求CPL>=DPL。
（2）代码段必须存在，即描述符中的P位必须为1。
通常描述符特权级DPL规定了对应段的特权级。如果描述符描述的是数据段，那么DPL就规定了访问该数据段的最外层特权级；
如果描述符描述的是代码段，那么DPL就规定了执行该代码段所需要的CPL。
但从上述装载CS高速缓冲寄存器时进行的保护检测可见，对于一致代码段，却要求CPL>=DPL，也就是说，
一致代码段描述符中的DPL，规定可以转移到一致的代码段的最内层特权级。
于是，3级的程序可以转移到任何一致的代码段，而0级的程序只允许转移到DPL等于0的一致代码段。
一致代码段描述符内DPL的这种解释，正好与正常的DPL的解释相反。
一致的可执行段是一种特别的存储段。这种存储段，为在多个特权级执行的程序，提供对子例程的共享支持，而不要求改变特权级。
例如，通过把数值库例程放在一致的代码段中，可以使不同级执行的程序共享数值库例程。
这样，任何特权级的程序可以使用段间调用指令，调用库中的例程，并在调用者所具有的特权级执行该例程。
3.任务内无特权级变换的转移
所谓任务内无特权级变换的转移指：在转移到新的代码段时，当前特权级CPL保持不变。
利用段间转移指令JMP、段间调用指令CALL和段间返回指令RET可实现任务内无特权级变换的转移。
利用INT指令和IRET指令也可实现任务内无特权级变换的转移。
（1）利用段间直接转移指令JMP或CALL
在执行段间转移指令JMP时，如果指令内所含指针指示一个代码段，那么就直接开始上述向目标代码段转移的步骤；
在执行段间调用指令CALL时，如果指令内所含指针指示一个代码段，那么就把返回地址指针压入堆栈，
然后就直接开始上述向目标代码段转移的步骤。顺利通过这几步（不调整RPL），就完成了任务内无特权级变换的转移。
由此可见，利用段间直接转移指令JMP或调用指令CALL可方便地进行任务内无特权级变换的转移，但不能进行任务内特权级变换的转移。
（2）利用段间返回指令RET
在执行段间返回指令RET时，如果从堆栈中弹出的目标地址指针指示一个代码段，并且选择子符合RPL=CPL的条件，
那么就开始上述向目标代码段转移的步骤。顺利通过这几步，就完成了任务内无特权级变换的转移。
通常情况下，段间返回指令RET与段间调用指令CALL对应。在利用段间调用指令CALL以任务内无特权级变换的方式转移到某个子程序后，
在子程序内利用段间返回指令RET以任务内无特权级变换的方式返回主程序。
由于调用时无特权级变换，所以返回时也无特权级变换，如果真是如此，那么必定能够满足条件RPL=CPL。
（3）利用调用门和其他途径
如何利用调用门实现任务内无特权级变换的转移在10.6.3节中介绍。其他实现任务内无特权级变换的途径在10.7节中介绍。
4.装载数据段和堆栈段寄存器时的特权检测
上面简单地说明了把选择子装入代码段寄存器CS时为实现保护而进行的检测，
下面也简单地说明在把选择子装入数据段寄存器和堆栈段寄存器时要进行的检测。
在把选择子装入数据段寄存器DS、ES、FS或GS时，要进行如下检测：
（1）选择子不能为空；
（2）选择子指定的描述符必须是数据段描述符、可读可执行的代码段或一致的可读可执行代码段；
（3）对于数据段和可读可执行代码段，要求CPL<=DPL，RPL<=DPL；
（4）对应段必须存在。
在把选择子装入堆栈段寄存器SS时要进行如下检测：
（1）选择子不能为空；
（2）选择子指定的描述符必须是可读可写数据段描述符；
（3）要求CPL=RPL=DPL；
（4）对应段必须存在。
10.6.2演示任务内无特权级变换转移的实例（实例三）
在实例二中，32位代码段到16位代码段的转移就是任务内无特权级变换转移的例子。
下面再给出一个用于演示任务内无特权级变换转移的实例。
该实例使用了段间转移指令JMP、段间调用指令CALL和段间返回RET指令实现同一任务内相同特权级转移。
该实例还建立并使用了局部描述符表LDT。
1.实现步骤和源程序
实现步骤如下：
（1）实方式下初始化，包括对GDT和演示任务LDT的初始化，装载GDTR；
（2）从实方式切换到保护方式，处于0特权级；
（3）装载LDTR，并设置堆栈；
（4）利用段间转移指令JMP实现从代码段K到同级代码段L的转移；
（5）利用段间CALL指令调用同级代码段C中的子程序D显示字符串信息；
（6）利用段间CALL指令调用同级代码段C中的子程序H把十六进制数转换成对应的ASCII码；
（7）再利用段间CALL指令调用同级代码段C中的子程序D显示字符串信息；
（8）利用段间转移指令JMP实现从代码段L到代码段K的转移；
（9）从保护方式切换到实方式；
（10）在实方式下结束。
该实例的逻辑功能是用十六进制数的形式显示代码段L的段界限值。源程序如下：
；程序名：T10-3.ASM
；演示任务内无特权级变换的转移
DESCRIPTOR STRUC
LIMITL DW 0
BASEL DW 0
BASEM DB 0
ATTRIBUTES DW 0
BASEH DB 0
DESCRIPTOR ENDS
GATE STRUC
OFFSETL DW 0
SELECTOR DW 0
DCOUNT DB 0
GTYPE DB 0
OFFSETH DW 0
GATE ENDS
PDESC STRUC
LIMIT DW 0
BASE DD 0
PDESC ENDS
TASKSS STRUC
TRLINK DW ?,0
TRESP0 DD ?
TRSS0 DW ?,0
TRESP1 DD ?
TRSS1 DW ?,0
TRESP2 DD ?
TRSS2 DW ?,0
TRCR3 DD ?
TREIP DD ?
TREFLAG DW ?,?
TREAX DD ?
TRECX DD ?
TREDX DD ?
TREBX DD ?
TRESP DD ?
TREBP DD ?
TRESI DD ?
TREDI DD ?
TRES DW ?,0
TRCS DW ?,0
TRSS DW ?,0
TRDS DW ?,0
TRFS DW ?,0
TRGS DW ?,0
TRLDT DW ?,0
TRFLAG DW 0
TRIOMAP DW $ + 2
TASKSS ENDS
ATDR = 90H
ATDW = 92H
ATDWA = 93H
ATCE = 98H
ATCER = 9AH
ATCCO = 9CH
ATCCOR = 9EH
ATLDT = 82H
ATTASKGAT = 85H
AT386TSS = 89H
AT386CGAT = 8CH
AT386IGAT = 8EH
AT386TGAT = 8FH
DPL1 = 20H
DPL2 = 40H
DPL3 = 60H
RPL1 = 01H
RPL2 = 02H
RPL3 = 03H
IOPL1 = 1000H
IOPL2 = 2000H
IOPL3 = 3000H
D32 = 4000H
TIL = 04H
VMFL = 0002H
IFL = 0200H
JUMP32 MACRO selector,offsetv
DB 0EAH
DW offsetv
DW 0
DW selector
ENDM
CALL32 MACRO selector,offsetv
DB 9AH
DW offsetv
DW 0
DW selector
ENDM
JUMP16 MACRO selector,offsetv
DB 0EAH
DW offsetv
DW selector
ENDM
CALL16 MACRO selector,offsetv
DB 9AH
DW offsetv
DW selector
ENDM
.386P
GDTSEG SEGMENT PARA USE16 'GDT'
GDT LABEL BYTE
DUMMY DESCRIPTOR <>
NORMAL DESCRIPTOR <0FFFFH,0,0,ATDW,0>
NORMAL_SEL = NORMAL - GDT
CODEK DESCRIPTOR <0FFFFH,,,ATCE,>
CODEK_SEL = CODEK - GDT
LDTABLE DESCRIPTOR <LDTLEN - 1,,,ATLDT,>
LDT_SEL = LDTABLE - GDT
GDTLEN = $ - GDT
GDTSEG ENDS
LDTSEG SEGMENT PARA USE16 'LDT'
LDT LABEL BYTE
CODEL DESCRIPTOR <CODELLEN - 1,CODELSEG,,ATCE,>
CODEL_SEL = (CODEL - LDT) + TIL
CODEC DESCRIPTOR <CODECLEN - 1,CODECSEG,,ATCE,>
CODEC_SEL = (CODEC - LDT) + TIL
VIDEOBUFF DESCRIPTOR <0FFFFH,0,0,0F00H + ATDW,0>
VIDEO_SEL = (VIDEOBUFF - LDT) + TIL
TOLDT DESCRIPTOR <LDTLEN - 1,LDTSEG,,ATDR + DPL3,>
TOLDT_SEL = (TOLDT - LDT) + TIL
MDATA DESCRIPTOR <MDATALEN - 1,MDATASEG,,ATDW + DPL3,>
MDATA_SEL = (MDATA - LDT) + TIL + RPL3
STACKS DESCRIPTOR <TOPOFS - 1,STACKSEG,,ATDWA,>
STACK_SEL = (STACKS - LDT) + TIL
LDNUM = ($ - LDT) / 8
LDTLEN = $ - LDT
LDTSEG ENDS
MDATASEG SEGMENT PARA USE16 'MDATA'
MESSAGE DB 'Value=',0
BUFFER DB 80 DUP (0)
MDATALEN = $
MDATASEG ENDS
STACKSEG SEGMENT PARA USE16 'STACK'
DW 512 DUP (0)
TOPOFS = $
STACKSEG ENDS
CODECSEG SEGMENT PARA USE16 'CODEC'
ASSUME CS:CODECSEG
DISPMESS PROC FAR
MOV AH,7
DISPMESS1:MOV AL,FS:[SI]
INC SI
OR AL,AL
JZ DISPMESS2
MOV ES:[EDI],AX
INC EDI
INC EDI
JMP DISPMESS1
DISPMESS2:RETF
DISPMESS ENDP
HTOASC PROC FAR
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
RETF
HTOASC ENDP
CODECLEN = $
CODECSEG ENDS
CODELSEG SEGMENT PARA USE16 'CODEL'
ASSUME CS:CODELSEG
VIRTUAL2:MOV AX,VIDEO_SEL
MOV ES,AX
MOV EDI,0B8000H
MOV AX,MDATA_SEL
MOV FS,AX
MOV SI,OFFSET MESSAGE
CALL16 CODEC_SEL,DISPMESS
MOV AX,TOLDT_SEL
MOV GS,AX
MOV DX,GS:CODEL.LIMITL
MOV SI,OFFSET BUFFER
MOV CX,4
VIR:ROL DX,4
MOV AL,DL
CALL16 CODEC_SEL,HTOASC
MOV FS:[SI],AL
INC SI
LOOP VIR
MOV BYTE PTR FS:[SI],'H'
MOV SI,OFFSET BUFFER
CALL16 CODEC_SEL,DISPMESS
JUMP16 CODEK_SEL,VIRTUAL3
CODELLEN = $
CODELSEG ENDS
CODEKSEG SEGMENT PARA USE16 'CODEK'
ASSUME CS:CODEKSEG
VIRTUAL1:MOV AX,LDT_SEL
LLDT AX
MOV AX,STACK_SEL
MOV SS,AX
MOV SP,OFFSET TOPOFS
JUMP16 CODEL_SEL,VIRTUAL2
VIRTUAL3:MOV AX,NORMAL_SEL
MOV ES,AX
MOV FS,AX
MOV GS,AX
MOV SS,AX
MOV EAX,CR0
AND EAX,0FFFFFFFEH
MOV CR0,EAX
JUMP16 <SEG REAL>,<OFFSET REAL>
CODEKLEN = $
CODEKSEG ENDS
RDATASEG SEGMENT PARA USE16
VGDTR PDESC <GDTLEN - 1,>
SPVAR DW ?
SSVAR DW ?
RDATASEG ENDS
RCODESEG SEGMENT PARA USE16
ASSUME CS:RCODESEG
START:ASSUME DS:GDTSEG
MOV AX,GDTSEG
MOV DS,AX
MOV BX,16
MOV AX,CODEKSEG
MUL BX
MOV CODEK.BASEL,AX
MOV CODEK.BASEM,DL
MOV CODEK.BASEH,DH
MOV AX,LDTSEG
MUL BX
MOV LDTABLE.BASEL,AX
MOV LDTABLE.BASEM,DL
MOV LDTABLE.BASEH,DH
ASSUME DS:RDATASEG
MOV AX,RDATASEG
MOV DS,AX
MOV AX,GDTSEG
MUL BX
MOV WORD PTR VGDTR.BASE,AX
MOV WORD PTR VGDTR.BASE+2,DX
CLD
CALL INIT_MLDT
MOV WORD PTR SSVAR,SS
MOV WORD PTR SPVAR,SP
LGDT QWORD PTR VGDTR
CLI
MOV EAX,CR0
OR EAX,1
MOV CR0,EAX
JUMP16 <CODEK_SEL>,<OFFSET VIRTUAL1>
REAL:LSS SP,DWORD PTR SPVAR
STI
MOV AX,4C00H
INT 21H
INIT_MLDT PROC
PUSH DS
MOV AX,LDTSEG
MOV DS,AX
MOV CX,LDNUM
MOV SI,OFFSET LDT
INITL:MOV AX,[SI].BASEL
MOVZX EAX,AX
SHL EAX,4
SHLD EDX,EAX,16
MOV [SI].BASEL,AX
MOV [SI].BASEM,DL
MOV [SI].BASEH,DH
ADD SI,8
LOOP INITL
POP DS
RET
INIT_MLDT ENDP
RCODESEG ENDS
END START
在DOSBOX下测试通过
2.被包含文件386SCD.ASM
DESCRIPTOR <LIMITL  DW,BASEL   DW,BASEM DB,ATTRIBUTES DW,BASEH  DB>
ATTRIBUTES GD00   LIMITH   P DPL DT   TYPE
ATTRIBUTES GX00   LIMITH   P DPL DT   TYPE
GATE <OFFSETL DW,SELECTOR DW,DCOUNT DB,GTYPE DB,OFFSETH DW>
GTYPE = P DPL DT   TYPE
TYPE
类型编码         说明         类型编码         说明
0                  未定义              8                未定义
1                  可用286TSS      9                可用386TSS  当TSS段描述符没被加载进TR寄存器时，TYPE=9
2                   LDT                  A               未定义
3                   忙的286TSS     B                忙的386TSS  当TSS段描述符被加载进TR寄存器时，TYPE=B
4                   286调用门        C                386调用门
5                   任务门              D                未定义
6                   286中断门        E                386中断门
7                   286陷阱门        F                386陷阱门
任务状态段TSS的基本格式
31                        16  15                0   偏移
0000000000000000   链接字段          0
ESP0                                                    4
0000000000000000    SS0                  8
ESP1                                                    0CH
0000000000000000    SS1                  10H
ESP2                                                    14H
0000000000000000    SS2                  18H
CR3                                                      1CH
EIP                                                        20H
EFLAGS                                                24H
EAX                                                      28H
ECX                                                      2CH
EDX                                                      30H
EBX                                                      34H
ESP                                                      38H
EBP                                                      3CH
ESI                                                       40H
EDI                                                      44H
0000000000000000   ES                     48H
0000000000000000   CS                     4CH
0000000000000000   SS                      50H
0000000000000000   DS                     54H
0000000000000000  FS                       58H
0000000000000000  GS                      5CH
0000000000000000   LDT                   60H
I/O许可位图基地址     000000000000000 T 64H
31          18 17   16  15  14  13 12   11   10  9  8    7   6   5  4   3  2   1  0
                   VM  RF  0   NT  IOPL    OF  DF IF TF  SF ZF  0 AF 0  PF     CF
为了节省篇幅，把有关结构类型的定义、宏指令的定义和符号常量的定义等语句集中在一个文件中，以便供每个实例程序使用。
；文件名：386SCD.ASM
：内容：符号常量等的定义
DESCRIPTOR STRUC
LIMITL DW 0
BASEL DW 0
BASEM DB 0
ATTRIBUTES DW 0
BASEH DB 0
DESCRIPTOR ENDS
GATE STRUC
OFFSETL DW 0
SELECTOR DW 0
DCOUNT DB 0
GTYPE DB 0
OFFSETH DW 0
GATE ENDS
PDESC STRUC
LIMIT DW 0
BASE DD 0
PDESC ENDS
TASKSS STRUC
TRLINK DW ?,0
TRESP0 DD ?
TRSS0 DW ?,0
TRESP1 DD ?
TRSS1 DW ?,0
TRESP2 DD ?
TRSS2 DW ?,0
TRCR3 DD ?
TREIP DD ?
TREFLAG DW ?,?
TREAX DD ?
TRECX DD ?
TREDX DD ?
TREBX DD ?
TRESP DD ?
TREBP DD ?
TRESI DD ?
TREDI DD ?
TRES DW ?,0
TRCS DW ?,0
TRSS DW ?,0
TRDS DW ?,0
TRFS DW ?,0
TRGS DW ?,0
TRLDT DW ?,0
TRFLAG DW 0
TRIOMAP DW $ + 2
TASKSS ENDS
ATDR = 90H
ATDW = 92H
ATDWA = 93H
ATCE = 98H
ATCER = 9AH
ATCCO = 9CH
ATCCOR = 9EH
ATLDT = 82H
ATTASKGAT = 85H
AT386TSS = 89H
AT386CGAT = 8CH
AT386IGAT = 8EH
AT386TGAT = 8FH
DPL1 = 20H
DPL2 = 40H
DPL3 = 60H
RPL1 = 01H
RPL2 = 02H
RPL3 = 03H
IOPL1 = 1000H
IOPL2 = 2000H
IOPL3 = 3000H
D32 = 4000H
TIL = 04H
VMFL = 0002H
IFL = 0200H
JUMP32 MACRO selector,offsetv
DB 0EAH
DW offsetv
DW 0
DW selector
ENDM
CALL32 MACRO selector,offsetv
DB 9AH
DW offsetv
DW 0
DW selector
ENDM
JUMP16 MACRO selector,offsetv
DB 0EAH
DW offsetv
DW selector
ENDM
CALL16 MACRO selector,offsetv
DB 9AH
DW offsetv
DW selector
ENDM
3.关于实例三的说明
有些步骤的实现方法已在前面的实例中做过介绍，下面就任务内无特权级变换的转移和使用局部描述符LDT等作些说明：
（1）实方式下初始化LDT
演示任务使用了局部描述符表LDT，该LDT在实方式下初始化。为了简便，LDT中各描述的界限和属性值在定义时预置，
利用一个子程序设置各段的段基地址。为了方便，在定义时把各段的段值安排在相应描述符的段基地址低16位字段中。
由于实例中各段在实方式下定位，所以把段值乘16就是对应的段基地址。
（2）装载LDTR寄存器
在使用LDT之前，还要装载局部描述符表寄存器LDTR。本实例中的如下两条指令用于装载LDTR，
MOV AX LDT_SEL
LLDT AX
LLDT指令是专门用于装载LDTR的指令。该指令的操作数是对应LDT段描述符的选择子。
根据该选择子，处理器从GDT中取出相应的LDT段描述符，在进行合法性等检查后，
LDT段描述符的基地址和界限等信息被装入LDTR的高速缓冲寄存器中。
由于要引用GDT，所以不能在实方式下装载LDTR。在10.8节中对LLDT指令作详细说明。
（3）利用段间转移指令JMP实现任务内无特权级变换的转移
在本实例中进入保护方式后，特权级是0。通过如下段间直接转移指令实现从代码段K到代码段L的转移：
JUMP16 CODEL_SEL,VIRTUAL2
其中，选择子CODEL_SEL是对应代码段L的描述符的选择子。该描述符在LDT中，所以选择子中的描述符表指示位TI是1。
描述符特权级是0，表示对应代码段的特权级是0，选择子中的请求特权级RPL也是0。
目标代码段不是一致代码段，所以在CPL=DPL，RPL<=DPL的情况下，顺利进行相同特权级的转移：
目标代码段的选择子CODEL_SEL被装入CS，对应描述符中的信息被装入高速缓冲寄存器，偏移VIRTUAL2被装入指令指针寄存器。
由于是16位代码段，所以偏移用16位表示。类似地，通过如下段间直接转移指令实现从代码段L转移到代码段K：
JUMP16 CODEK_SEL VIRTUAL3
其中，选择子CODEK_SEL是对应代码段K的描述符的选择子。由于描述符在GDT中，所以选择子中的TI位是0。
（4）利用段间调用指令CALL实现任务内无特权级变换的转移
在代码段L中，通过段间直接调用指令CALL调用了在代码段C中的两个子程序，这些调用都是无特权级变换的转移。
例如：利用如下指令调用了显示字符串子程序DISPMESS：
CALL16 CODEC_SEL,DISPMESS
其中，CODEC_SEL是代码段C的选择子，DISPMESS表示子程序入口。
描述代码段C的描述符在LDT中，描述符特权级DPL是0，所以使用的选择子CODEC_SEL的请求特权级RPL是0，描述符表指示位TI是1。
目标代码段C不是一致代码段，所以在CPL=DPL，RPL<=DPL的情况下，顺利进行相同特权级的转移：
当前CS和IP压入堆栈，目标代码段的选择子CODEC_SEL被装入CS，对应描述符中的信息被装入高速缓冲寄存器，
16位偏移DISPMESS被装入指令指针。由于是16位段，所以偏移用16位表示，压入堆栈的是字而不是双字。
（5）段间返回指令RET实现任务内无特权级变换的转移
段间返回指令RET从堆栈弹出返回地址（由选择子和偏移构成）。
弹出选择子内的RPL=CPL，并且对应DPL=CPL，RPL<=DPL是当然的，所以能顺利进行相同特权级转移。
4.别名技术
在上述实例三中，使用了两个描述符来描述演示任务的LDT段。描述符LDTABLE被安排在GDT中，它是系统段描述，
把段LDTSEG描述成演示任务的局部描述符表LDT。
描述符TOLDT被安排在LDT中，它是数据段描述符，把段LDTSEG描述成一个普通的数据段。
描述符LDTABLE被装载到LDTR，描述符TOLDT被装载到某个数据段寄存器。为什么要这样处理呢？
根据实例三的功能要求，需要访问演示任务的局部描述符表LDT段，以取得代码段L的段界限值，这需要通过某个段寄存器进行，
但不能把系统段描述选择子装载到段寄存器，所以采用两个描述符来描述段LDTSEG。
这种为了满足对同一个段实施不同方式操作的需要，而用多个描述符加以描述的技术称为别名技术。
这好比一个演员在一部戏中扮演多个角色，在不同的情景下，使用不同的称呼。
在保护方式程序设计中，常常要采用别名技术。
例如：用两个具有不同类型值的描述符来描述同一个段。再如，用两个具有不同DPL的描述符来描述符同一个段。
10.6.3任务内不同特权级的变换
在一个任务之内，可以存在四种特权级，所以常常会发生不同特权级之间的变换。
例如：外层的应用程序调用内层操作系统的例程，以获得必要的诸如存储器分配等系统服务；内层操作系统的例程完成后，返回到外层应用程序。
在同一任务内，实现特权级从外层到内层变换的普通途径是：使用段间调用指令CALL，通过调用门进行转移；
实现特权级从内层到外层变换的普通途径是：使用段间返回指令RET。注意，不能利用JMP指令实现任务内不同特权级的变换。
1.通过调用门的转移
当段间转移指令JMP和段间调用指令CALL所含指针的选择子指示调用门描述符时，就可实现通过调用门的转移。
调用门描述调用转移的入口点，从图10.13可见，它包含目标地址的段及偏移量的48位全指针。
在执行通过调用门的段间转移指令JMP或段间调用指令CALL时，指令所含指针内的选择子用于确定调用门，而偏移被丢弃；
把调用门内的48位全指针，作为目标地址指针进行转移。
处理器采用与访问数据段相同的特权级规则控制对门描述符的访问。门描述符的DPL规定了访问门的最外层特权级，
只有在相同级或者更内层级的程序才可以访问门。
同时，还要求指示门的选择子的RPL必须满足RPl<=DPL的条件。
调用门是门描述符的一种。所以，在取出调用门内的48位全指针，把它作为目标地址指针向目标代码段转移之前，要进行特权级检测。
必须符合CPL<=DP1并且RPL<=DPL的条件。检测通过后，开始在10.6.1节中所述的转移步骤。
其中还要检测目标描述符是否是描述符代码段，调用门内的选择子指示的描述符必须是代码段描述符。
此外，在装载高速缓冲寄存器之前调整RPL=0，也即调用门中选择子的RPL被忽略。
如10.6.1节中所述，在装载CS高速缓冲寄存器时，还要对目标代码段描述符进行保护检测。
检测过程中的DPL不再是调用门的DPL，而是调用门内选择子所指示的目标代码段描述符的DPL。
段间调用指令CALL和段间转移指令JMP所做的检测不一样。
对于使用调用门的段间转移指令JMP，检测条件与段间直接转移相同。由于已置RPL=0，所以可认为RPL<=DPL的条件总能满足。
所以，对于普通的非一致代码段，当CPL=DPL时，发生无特权级变换的转移；
对于一致代码段，在满足CPL>=DPL时也发生无特权级变换的转移；其他情形就引起异常。
对于使用调用门的段间调用指令CALL，情形就不同了。由于已置RPL=0，所以可认为RPL<=DPL的条件总能满足。
对于一致代码段，在满足CPL>=DPL时发生无特权级变换的转移。
对于非一致代码段，当CPL=DPL时，仍发生无特权级变换的转移；
当CPL>DPL时，就发生向内层特权级变换的转移，使CPL保持等于DPL，同时切换到对应的内层堆栈。
综上所述，使用段间调用指令CALL，通过调用门可以实现从外层程序调用进入内层程序；通过调用门也可实现无特权级变换的转移。
当然，CALL指令在最后把目标代码段的指针装入CS和EIP之前，要把原CS和EIP，即返回地址保存到堆栈。
如无特权级变换，堆栈保持不变，返回地址就保存在原堆栈中；如变换特权级，那么返回地址保存在内层堆栈中。
2.堆栈切换
在使用CALL指令，通过调用门向内层转移时，不仅特权级发生变换，控制转移到一个新的代码段，而且也切换到内层的堆栈段。
从图10.14所示的任务状态段TSS的格式可见，TSS中包含有指向0级、1级和2级堆栈的指针。
在特权级发生向内层变换时，根据特权级使用TSS中相应的堆栈指针对SS及ESP寄存器进行初始化，建立起一个空栈。
在建立起内层堆栈后，先把外层堆栈的指针SS及ESP寄存器的值压入内层堆栈，以使得相应的向外层返回可恢复原来的外层堆栈。
然后，从外层堆栈复制以双字为单位的调用参数到内层堆栈，调用门中的DCOUNT字段值决定了复制参数的量。
这些被复制的参数是主程序通过堆栈传递给子程序的实参，在调用之前被压入外层堆栈。
通过复制堆栈中的参数，使内层的子程序不需要考虑堆栈的切换，而容易地访问主程序传递过来的实参。
最后，调用的返回地址被压入堆栈，以便在调用结束时返回。
外层EIP  <-后压入
外层CS
参数2
参数1
外层ESP
外层SS    <-先压入
图10.15给出了在向内层变换时，建立内层堆栈，并从外层堆栈复制2个双字参数到内层堆栈的示意图。
图中每项是双字，可见的段寄存器内的选择子被扩展成32位，高16位为0。无论是否通过调用门，只要不发生特权级变换，就不会切换堆栈。
3.向外层返回
与使用CALL指令通过调用门向内层变换相反，使用RET指令实现向外层返回。
段间返回指令RET从堆栈中弹出返回地址，并且可以采用调整ESP的方法，跳过相应的在调用之前压入堆栈的参数。
返回地址的选择子指示要返回的代码段描述符，从而确定返回的代码段。
选择子的RPL确定返回后的特权级，而不是对应描述符的DPL，这是因为，段间返回指令RET可能使控制返回到一致代码段，
而一致代码段可以在DPL规定的特权级以外的特权级执行。
RET指令先从堆栈弹出返回地址。如果返回地址的选择子的RPL规定相对于CPL更外层的级，那么就引起向外层返回。
其次，为向外层返回，跳过内层堆栈中的参数，再从内层堆栈中弹出指向外层堆栈的指针，并装入到SS及ESP，以恢复外层堆栈。
再次，调整ESP，跳过在相应的调用之前压入到外层堆栈的参数。然后，检查数据段寄存器DS、ES、FS及GS，
以保证寻址的段在外层是可访问的，如果段寄存器寻址的段在外层是不可访问的，那么装入一个空选择子，以避免在返回时发生保护空洞。
最后，返回（外层）继续执行。
上述五步是对带立即数段间返回指令而言的，立即数规定了堆栈中要跳过的参数的字节数。
对无立即数段间返回指令而言，缺少第二和第三步，请参见下面的实例四。如果RET指令不需要向外层返回，那么就只有开始和最后的两步。
10.6.4演示任务内特权级变换的实例（实例四）
下面给出一个演示任务内特权级变换的实例。该实例演示在任务内通过调用门从外层特权级变换到内层特权级；
也演示通过段间返回指令从内层特权级变换到外层特权级；还演示通过调用门的无特权级变换的转移。
实例使用了任务状态段TSS，这是因为任务内特权级变换时要使用的内层堆栈指针存放在TSS中。
1.实现流程
实例四的主要实现步骤如图10.16所示。在图的右边标出了特权级变换的分界情况。
由于在任务内发生特权级变换时要切换堆栈，而内层堆栈的指针存放在当前任务的TSS中，所以在进入保护方式后设置任务状态段寄存器TR。
由于演示任务使用了局部描述符表，所以设置LDTR。从实方式切换到保护方式下的16位临时代码段，CPL=0。
在临时代码段通过任务门转移到32位过渡代码段，不发生特权级变换，CPL=0。为了演示外层程序通过调用门调用内层程序，要使CPL>0。
实例先通过段间返回指令RET从特权级0变换到特权级3的演示代码段。在特权级3下，通过调用门调用1级的子程序。
随着执行段间RET，又返回到3级的演示代码段。
在3级演示代码段通过调用门转移到0级的过渡代码段，再转0级的临时代码段，最后切换回实方式。
2.源程序组织和清单
实例四有如下部分组成：
（1）全局描述符表GDT。
GDT含有演示任务的TSS段描述符和LDT段描述符，此外还含临时代码段描述符、规范数据段描述符和视频缓冲区段描述符。
（2）演示任务的LDT段。
它含有除临时代码段外的其他代码段的描述符和演示任务各级堆栈段描述符，还含有3个调用门。
（3）演示任务的TSS段。
（4）演示任务的0级、1级和3级堆栈段。
（5）显示子程序段。32位代码段，特权级1。
（6）演示代码段。32位代码段，特权级3。
（7）过渡代码段。32位段，特权级0。
（8）临时代码段。16位段，特权级0。
（9）实方式下的数据和代码段。
该实例的逻辑功能是显示演示程序代码段执行时的当前特权级CPL。源程序清单如下：
；程序名：T10-4.ASM
；演示在任务内如何进行特权级变换
DESCRIPTOR STRUC
LIMITL DW 0
BASEL DW 0
BASEM DB 0
ATTRIBUTES DW 0
BASEH DB 0
DESCRIPTOR ENDS
GATE STRUC
OFFSETL DW 0
SELECTOR DW 0
DCOUNT DB 0
GTYPE DB 0
OFFSETH DW 0
GATE ENDS
PDESC STRUC
LIMIT DW 0
BASE DD 0
PDESC ENDS
TASKSS STRUC
TRLINK DW ?,0
TRESP0 DD ?
TRSS0 DW ?,0
TRESP1 DD ?
TRSS1 DW ?,0
TRESP2 DD ?
TRSS2 DW ?,0
TRCR3 DD ?
TREIP DD ?
TREFLAG DW ?,?
TREAX DD ?
TRECX DD ?
TREDX DD ?
TREBX DD ?
TRESP DD ?
TREBP DD ?
TRESI DD ?
TREDI DD ?
TRES DW ?,0
TRCS DW ?,0
TRSS DW ?,0
TRDS DW ?,0
TRFS DW ?,0
TRGS DW ?,0
TRLDT DW ?,0
TRFLAG DW 0
TRIOMAP DW $ + 2
TASKSS ENDS
ATDR = 90H
ATDW = 92H
ATDWA = 93H
ATCE = 98H
ATCER = 9AH
ATCCO = 9CH
ATCCOR = 9EH
ATLDT = 82H
ATTASKGAT = 85H
AT386TSS = 89H
AT386CGAT = 8CH
AT386IGAT = 8EH
AT386TGAT = 8FH
DPL1 = 20H
DPL2 = 40H
DPL3 = 60H
RPL1 = 01H
RPL2 = 02H
RPL3 = 03H
IOPL1 = 1000H
IOPL2 = 2000H
IOPL3 = 3000H
D32 = 4000H
TIL = 04H
VMFL = 0002H
IFL = 0200H
JUMP32 MACRO selector,offsetv
DB 0EAH
DW offsetv
DW 0
DW selector
ENDM
CALL32 MACRO selector,offsetv
DB 9AH
DW offsetv
DW 0
DW selector
ENDM
JUMP16 MACRO selector,offsetv
DB 0EAH
DW offsetv
DW selector
ENDM
CALL16 MACRO selector,offsetv
DB 9AH
DW offsetv
DW selector
ENDM
.386P
GDTSEG SEGMENT PARA USE16
GDT LABEL BYTE
DUMMY DESCRIPTOR <>
NORMAL DESCRIPTOR <0FFFFH,0,0,ATDW,0>
NORMAL_SEL = NORMAL - GDT
EFFGDT LABEL BYTE
EFFGDTOFF = $ - GDT
DEMOTSS DESCRIPTOR <DEMOTSSLEN - 1,DEMOTSSSEG,,AT386TSS,>
DEMOTSS_SEL = DEMOTSS - GDT
LDTABLE DESCRIPTOR <LDTLEN - 1,LDTSEG,,ATLDT,>
LDT_SEL = LDTABLE - GDT
TEMPCODE DESCRIPTOR <0FFFFH,TEMPCODESEG,,ATCE,>
TEMPCODE_SEL = TEMPCODE - GDT
VIDEOBUFF DESCRIPTOR <0FFFFH,0,0,0F00H + ATDW + DPL3,0>
VIDEO_SEL = VIDEOBUFF - GDT
GDNUM= ($ - EFFGDT) / 8
GDTLEN = $ - GDT
GDTSEG ENDS
LDTSEG SEGMENT PARA USE16
EFFLDT LABEL BYTE
EFFLDTOFF = $ - EFFLDT
DEMOSTACK0 DESCRIPTOR <DEMOSTACK0LEN - 1,DEMOSTACK0SEG,,ATDW + D32,>
DEMOSTACK0_SEL = (DEMOSTACK0 - EFFLDT) + TIL
DEMOSTACK1 DESCRIPTOR <DEMOSTACK1LEN - 1,DEMOSTACK1SEG,,ATDW + D32 + DPL1 ,>
DEMOSTACK1_SEL = (DEMOSTACK1 - EFFLDT) + TIL + RPL1
DEMOSTACK3 DESCRIPTOR <DEMOSTACK3LEN - 1,DEMOSTACK3SEG,,ATDW + D32 + DPL3,>
DEMOSTACK3_SEL = (DEMOSTACK3 - EFFLDT) + TIL + RPL3
DEMOCODE DESCRIPTOR <DEMOCODELEN - 1,DEMOCODESEG,,ATCE + D32 + DPL3,>
DEMOCODE_SEL = (DEMOCODE - EFFLDT) + TIL + RPL3
T32CODE DESCRIPTOR <T32CODELEN - 1,T32CODESEG,,ATCE + D32,>
T32CODE_SEL = (T32CODE - EFFLDT) + TIL
ECHOSUBR DESCRIPTOR <ECHOSUBRLEN - 1,ECHOSUBRSEG,,ATCER + D32 + DPL1,>
ECHOSUBR_SEL1 = (ECHOSUBR - EFFLDT) + TIL + RPL1
ECHOSUBR_SEL3 = (ECHOSUBR - EFFLDT) + TIL + RPL3
LDNUM = ($ - EFFLDT) / 8
TOT32GATEA GATE <T32BEGINOFF,T32CODE_SEL,0,AT386CGAT,0>
TOT32GATEA_SEL = (TOT32GATEA - EFFLDT) + TIL
TOT32GATEB GATE <T32ENDOFF,T32CODE_SEL,0,AT386CGAT + DPL3,0>
TOT32GATEB_SEL = (TOT32GATEB - EFFLDT) + TIL
TOECHOGATE GATE <ECHOSUBOFF,ECHOSUBR_SEL3,0,AT386CGAT + DPL3,0>
TOECHOGATE_SEL = (TOECHOGATE - EFFLDT) + TIL
LDTLEN = $ - EFFLDT
LDTSEG ENDS
DEMOTSSSEG SEGMENT PARA USE16
EFFTSS LABEL BYTE
DW 0,0
DW DEMOSTACK0LEN,0
DW DEMOSTACK0_SEL,0
DW DEMOSTACK1LEN,0
DW DEMOSTACK1_SEL,0
DD ?
DW ?,0
DD 0
DD ?
DD ?
DD ?
DD ?
DD ?
DD ?
DD ?
DD ?
DD ?
DD ?
DW ?,0
DW ?,0
DW ?,0
DW ?,0
DW ?,0
DW ?,0
DW LDT_SEL,0
DW 0
DW $ + 2
DB 0FFH
DEMOTSSLEN = $ - EFFTSS
DEMOTSSSEG ENDS
DEMOSTACK0SEG SEGMENT PARA USE32
DEMOSTACK0LEN = 512
DB DEMOSTACK0LEN DUP (0)
DEMOSTACK0SEG ENDS
DEMOSTACK1SEG SEGMENT PARA USE32
DEMOSTACK1LEN = 512
DB DEMOSTACK1LEN DUP (0)
DEMOSTACK1SEG ENDS
DEMOSTACK3SEG SEGMENT PARA USE32
DEMOSTACK3LEN = 512
DB DEMOSTACK3LEN DUP (0)
DEMOSTACK3SEG ENDS
ECHOSUBRSEG SEGMENT PARA USE32
EFFECHO LABEL BYTE
MESSAGE DB 'CPL=',0
ASSUME CS:ECHOSUBRSEG
ECHOSUBOFF = $ - EFFECHO
ECHOSUB PROC FAR
CLD
PUSH EBP
MOV EBP,ESP
MOV AX,ECHOSUBR_SEL1
MOV DS,AX
MOV AX,VIDEO_SEL
MOV ES,AX
MOV EDI,0B8000H
MOV ESI,OFFSET MESSAGE
MOV AH,17H
ECHOSUB1:LODSB
OR AL,AL
JZ ECHOSUB2
STOSW
JMP ECHOSUB1
ECHOSUB2:MOV EAX,[EBP+8]
AND AL,3
ADD AL,'0'
MOV AH,17H
STOSW
POP EBP
RETF
ECHOSUB ENDP
ECHOSUBRLEN = $ - EFFECHO
ECHOSUBRSEG ENDS
DEMOCODESEG SEGMENT PARA USE32
ASSUME CS:DEMOCODESEG
EFFDEMO LABEL BYTE
DEMOBEGINOFF = $ - EFFDEMO
DEMOBEGIN:CALL32 TOECHOGATE_SEL,0
CALL32 TOT32GATEB_SEL,0
DEMOCODELEN = $ - EFFDEMO
DEMOCODESEG ENDS
T32CODESEG SEGMENT PARA USE32
ASSUME CS:T32CODESEG
EFFT32 LABEL BYTE
T32BEGINOFF = $ - EFFT32
T32BEGIN:MOV AX,DEMOSTACK0_SEL
MOV SS,AX
MOV ESP,DEMOSTACK0LEN
MOV EAX,DEMOSTACK3_SEL
PUSH EAX
MOV EAX,DEMOSTACK3LEN
PUSH EAX
MOV EAX,DEMOCODE_SEL
PUSH EAX
MOV EAX,DEMOBEGINOFF
PUSH EAX
RETF
T32ENDOFF = $ - EFFT32
T32END:JUMP32 TEMPCODE_SEL,TOREALOFF
T32CODELEN = $ - EFFT32
T32CODESEG ENDS
TEMPCODESEG SEGMENT PARA USE16
ASSUME CS:TEMPCODESEG
EFFTEMP LABEL BYTE
VIRTUALOFF = $ - EFFTEMP
VIRTUAL:MOV AX,DEMOTSS_SEL
LTR AX
MOV BX,LDT_SEL
LLDT BX
JUMP16 TOT32GATEA_SEL,0
TOREALOFF = $ - EFFTEMP
TOREAL:MOV AX,NORMAL_SEL
MOV DS,AX
MOV ES,AX
MOV FS,AX
MOV GS,AX
MOV SS,AX
MOV EAX,CR0
AND AX,0FFFEH
MOV CR0,EAX
JUMP16 <SEG REAL>,<OFFSET REAL>
TEMPCODELEN = $ - EFFTEMP
TEMPCODESEG ENDS
RDATASEG SEGMENT PARA USE16
VGDTR PDESC <GDTLEN - 1,>
SPVAR DW ?
SSVAR DW ?
RDATASEG ENDS
RCODESEG SEGMENT PARA USE16
ASSUME CS:RCODESEG,DS:RDATASEG
START:MOV AX,RDATASEG
MOV DS,AX
CLD
CALL INIT_GDT
MOV AX,LDTSEG
MOV FS,AX
MOV SI,EFFLDTOFF
MOV CX,LDNUM
CALL INIT_LDT
MOV WORD PTR SSVAR,SS
MOV WORD PTR SPVAR,SP
LGDT QWORD PTR VGDTR
CLI
MOV EAX,CR0
OR AX,1
MOV CR0,EAX
JUMP16 TEMPCODE_SEL,VIRTUALOFF
REAL:MOV AX,RDATASEG
MOV DS,AX
LSS SP,DWORD PTR SPVAR
STI
MOV AX,4C00H
INT 21H
INIT_GDT PROC NEAR
PUSH DS
MOV AX,GDTSEG
MOV DS,AX
MOV CX,GDNUM
MOV SI,EFFGDTOFF
INITG:MOV AX,[SI].BASEL
MOVZX EAX,AX
SHL EAX,4
SHLD EDX,EAX,16
MOV [SI].BASEL,AX
MOV [SI].BASEM,DL
MOV [SI].BASEH,DH
ADD SI,8
LOOP INITG
POP DS
MOV BX,16
MOV AX,GDTSEG
MUL BX
MOV WORD PTR VGDTR.BASE,AX
MOV WORD PTR VGDTR.BASE+2,DX
RET
INIT_GDT ENDP
INIT_LDT PROC NEAR
ILDT:MOV AX,FS:[SI].BASEL
MOVZX EAX,AX
SHL EAX,4
SHLD EDX,EAX,16
MOV FS:[SI].BASEL,AX
MOV FS:[SI].BASEM,DL
MOV FS:[SI].BASEH,DH
ADD SI,8
LOOP ILDT
RET
INIT_LDT ENDP
RCODESEG ENDS
END START
在XP下使用tasm t458.asm编译，tlink /3 t458.obj链接
在DOS下运行t458.exe，在左上角蓝底白字显示CPL=3
3.关于实例四的说明
程序中部分片段的背景和实现方法已在前面的实例中做过介绍，下面主要就如何实现任务内特权级变换作些说明：
（1）通过段间返回指令实现特权级变换
实例在两处使用段间返回指令实现任务内的特权级变换。一处是在0级的过渡代码段中用段间返回RETF指令，从特权级0变换到特权级3的演示代码段。
该处RETF指令并不对应CALL指令。实例从实方式切换到保护方式后CPL=0。为了演示如何通过调用门调用内层程序，要设法使CPL>0。
为此，实例先建立一个已发生从外层到内层变换的环境，也即按如图10.15所示，
在当前堆栈（0级堆栈）中放入外层堆栈的指针和外层演示程序的入口指针，形成一个如图10.17所示的0级堆栈，无需传递参数。
然后，执行段间返回指令RETF，从堆栈中弹出3级演示代码的选择子，RPL=3，而当时CPL=0，所以导致向外层变换特权级，
就从0级的过渡代码段变换到3级的演示代码段，同时切换到3级堆栈。
另一处是从1级的显示子程序ECHOSUB返回到3级的演示程序段。这处的RETF指令与演示程序中使用的通过调用门的段间调用指令CALL相对应，
执行段间返回指令RETF时的1级堆栈也如图10.17所示，其中的返回地址指针和外层堆栈指针由指令CALL压入。
（2）通过调用门实现特权级变换
实例在两处使用了段间调用指令，通过调用门实现特权级的变换。一处是3级演示代码通过调用门TOECHOGATE调用1级的显示子程序。
调用门TOECHOGATE自身DPL=3，只有这样，3级的演示代码才能够使用该调用门。
由于调用门内的选择子ECHOSUBR_SEL3所指示的显示子程序代码段描述符DPL=1，而当时CPL=3，
所以引起从外层特权级向内层特权级的变换，使CPL=1。同时形成如图10.17所示的1级堆栈。
虽然调用门内的选择子ECHOSUBR_SEL3的RPL=3，大于目标代码段描述符的DPL，但没有关系，因为在通过调用门转移时，
门内指示目标代码段的选择子RPL总被当作0对待。
另一处是3级演示代码还通过调用门TOT32GATEB调用了0级的过渡代码。该处使用的调用门描述符DPL也等于3。
由于调用门内的选择子T32CODE_SEL所指示的过渡代码段描述符DPL=0，而当时CPL=3，所以引起从3特权级向0特权级的变换，使CPL=0。
同时形成如图10.17所示的0级堆栈。但该处的调用实际上是“有去无回”的，调用的目的是转移到0级的过渡代码，准备返回到实方式。
由于从3级的演示代码到0级的过渡代码要发生特权级变换，所以不能使用转移指令JMP，必须使用调用指令CALL。
（3）通过调用门实现无特权级变换的转移
在临时代码段中，使用调用门TOT32GATEA转移到过渡代码段。尽管调用门内的选择子T32CODE_SEL所指示的过渡代码段描述符DPL=0，
但当时CPL=0，所以不发生特权级变换。正是这个原因，才可以使用段间转移指令JMP。
（4）子程序ECHOSUB的实现
子程序ECHOSUB的功能是显示调用程序执行时的特权级。调用程序的执行特权级在代码段寄存器CS内选择子的RPL字段。
在调用ECHOSUB时，CS寄存器内容被压入堆栈。子程序从堆栈取得调用程序的代码段选择子，再从中分离出RPL就可得调用程序的执行特权级。
（5）装载任务状态段寄存器TR
在任务内发生特权级变换时堆栈也随着自动切换，外层堆栈指针保存在内层堆栈中，而内层堆栈指针存放在当前任务的TSS中。
所以，在从外层向内层变换时，要访问TSS。
实例在进入保护方式下的临时代码段后，通过如下两条指令，装载任务状态段寄存器TR，使其指向已预置好的演示任务的TSS：
MOV AX,DEMOTSS_SEL
LTR AX
LTR指令是专门用于装载任务状态段寄存器TR的指令。该指令的操作数是对应TSS段描述符的选择子。LTR指令从GDT中取出相应的TSS段描述符，
把TSS段描述符的基地址和界限等信息装入TR的高速缓冲寄存器中。在10.8节中对LTR指令的一般格式作说明。
10.6.5任务切换
利用段间转移指令JMP或者段间调用指令CALL，通过任务门或者直接通过任务状态段，可以切换到别的任务。
此外，在中断/异常或者执行IRET指令时也可能发生任务切换。
1.直接通过TSS进行任务切换
当段间转移指令JMP或段间调用指令CALL所含指针的选择子指示一个可用任务状态段TSS描述符时，
正常情况下就发生从当前任务到由该可用TSS对应任务（目标任务）的切换。目标任务的入口点由目标任务TSS内的CS和EIP字段所规定的指针确定。
这样的JMP或CALL指令内的偏移被丢弃。
处理器采用与访问数据段相同的特权级规则控制对TSS段描述符的访问。
TSS段描述符的DPL规定了访问该描述符的最外层特权级，只有在相同级或者更内层级的程序才可以访问它。
同时，还要求指示它的选择子的RPL必须满足RPL<=DPL的条件。当这些条件满足时，就开始任务切换。
2.通过任务门进行任务切换
任务门内的选择子指示某个任务的TSS描述符。当段间转移指令JMP或段间调用指令CALL所含指针的选择子指示一个任务门时，
正常情况下就发生任务切换，也即从当前任务切换到由任务门内的选择子所指示的TSS描述符对应的任务（目标任务）。
这样的JMP或CALL指令内的偏移被丢弃；任务门内的偏移也无意义。
处理器采用与访问数据段相同的特权级规则控制对任务门的访问。
任务门的DPL规定了访问该门的最外层特权级，只有在相同级或者更内层级的程序才可以访问它。
同时，还要求指示任务门的选择子的RPL必须满足RPL<=DPL的条件。在这些条件满足时，再检查任务门内的选择子，
要求该选择子指示GDT中的可用TSS描述符。在检查通过后，就开始任务切换。
3.任务切换过程
在任务切换过程中当任务挂起时，处理器会更新动态字段，动态字段有：
（1）通用寄存器字段一任务切换之前，EAX，ECX，EDX，EBX，ESP，EBP，ESI，EDI寄存器状态。
（2）段选择符字段一任务切换之 前，ES，CS，SS，DS，FS，GS寄存 器保存的段选择符。
（3）EFLAGS寄存器字段一任务切换之前，EFAGS寄存器的状态。
（4）EIP字段-任务切换之前，EIP寄存器的状态。
（5）先前任务链接字段-包含先前任务的TSS的段选择符。该字段禁止任务通过使用IRET指令返回先前的任务。
当任务创建时会创建静态字段，静态字段可读，不可写：
（1）LDT段选择符字段
（2）CR3控制寄存器字段
（3）特权级0，1，2栈指针字段
（4）T标志（调试陷阱，100字节，位0）
（5）I/O映射基址字段
控制寄存器CR0中的位1~位4分别标记为MP（算术存在位）、EM（模拟位）、TS（任务切换位）和ET（扩展类型位），
它们控制浮点协处理器的操作。
当处理器复位时，ET位被初始化，以指示系统中数字协处理器的类型。
如果系统中存在80387协处理器，那么ET位被置1；如果系统中存在80287协处理器或者不存在协处理器，那么ET位被清0。
EM位控制浮点指令的执行是用软件模拟，还是由硬件执行。EM=0时，硬件控制浮点指令传送到协处理器；EM=1时，浮点指令由软件模拟。
TS位用于加快任务的切换，通过在必要时才进行协处理器切换的方法实现这一目的。
每当进行任务切换时，处理器把TS置1。TS=1时，浮点指令将产生设备不可使用（DNA）异常。
MP位控制WAIT指令在TS=1时，是否产生DNA异常。MP=1和TS=1时，WAIT产生异常；MP=0时，WAIT指令忽略TS条件。
CR0第0位是保护允许位PE(Protedted Enable)，用于启动保护模式，如果PE位置1，则保护模式启动，如果PE=0，则在实模式下运行。
CR0第1位是监控协处理位MP(Moniter coprocessor)，它与第3位一起决定：当TS=1时操作码WAIT是否产生一个“协处理器不能使用”的出错信号。
CR0第3位是任务转换位(Task Switch)，当一个任务转换完成之后，自动将它置1。随着TS=1，就不能使用协处理器。
The processor sets the TS flag every time a task switch occurs. 
The flag is used to synchronize the saving of FPU context in multitasking applications. 
Allows saving x87 task context upon a task switch only after x87 instruction used
CR0第2位是模拟协处理器位 EM (Emulate coprocessor)，如果EM=1，则不能使用协处理器，如果EM=0，则允许使用协处理器。
CR0第4位是微处理器的扩展类型位ET(Processor Extension Type)，其内保存着处理器扩展类型的信息，
如果ET=0，则标识系统使用的是287协处理器，如果 ET=1，则表示系统使用的是387浮点协处理器。
嵌套任务标志NT控制中断返回指令IRET的执行。
如果NT=0，用堆栈中保存的值恢复EFLAGS、CS和EIP，执行常规的从中断返回的动作。
如果NT=1，通过任务转换实现中断返回。
根据指示目标任务TSS描述符的选择子进行任务切换的一般过程如下：
第一，测试目标任务状态段的界限。
TSS用于保存任务的各种状态信息，不同的任务，TSS中可以有数量不等的其他信息，但根据图10.14所示的任务状态段基本格式，
TSS的界限应大于或等于103。
第二，把寄存器现场保存到当前任务的TSS。
把通用寄存器、段寄存器、EIP及EFLAGS的当前值保存到当前TSS中。保存的EIP的值是返回地址，指向引起任务切换指令的下一条指令。
但不把LDTR和CR3内容保存到TSS中。
第三，把指示目标任务TSS的选择子装入TR。同时，把对应TSS描述符装入TR高速缓冲寄存器中。
此后，当前任务改称为原任务，目标任务改称为当前任务。
第四，基本恢复当前任务（目标任务）的寄存器现场。
根据保存在TSS中的内容，恢复各通用寄存器、段寄存器、EFLAGS及EIP。
在装入段寄存器的过程中，为了能正确地处理可能发生的异常，只把对应选择子装入各段寄存器。还装载CR3寄存器。
第五，进行链接处理。如果需要链接，那么将指向原任务TSS的选择子写入当前任务TSS的链接字字段，把当前任务TSS描述符类型改为“忙”，
并将标志寄存器EFLAGS中的NT位置1，表示是嵌套任务。如果需要解链，那么把原任务TSS描述符类型改为“可用”。
如果无链接处理，那么将原任务TSS描述符类型置为“可用”，当前任务TSS描述符类型置为“忙”。
由JMP指令引起的任务切换不实施链接/解链处理；由CALL指令、中断、IRET指令引起的任务切换要实施链接/解链处理。
第六，把CR0中的TS标志置为1。这表示已发生过任务切换，在当前任务使用协处理器指令时，产生自陷。
由自陷处理程序完成有关协处理器现场的保存和恢复。这有利于快速地进行任务切换。
第七，把TSS中的CS选择子的RPL作为当前任务特权级设置为CPL。
任务切换可以在一个任务的任何特权级发生，并可切换到另一任务的任何特权级。
第八，装载LDTR寄存器。
一个任务可以有自己的LDT，也可以没有。当任务没有LDT时，TSS中LDT选择子为0。
如果TSS中LDT选择子非空，则从GDT中读出对应LDT描述符，在经过测试后，把所读LDT描述符装入LDTR高速缓冲寄存器。
如果，LDT选择子为空，则将LDT的存在位置成0，表明任务不使用LDT。
第九，装载代码段寄存器CS、堆栈段寄存器SS和各数据段寄存器及其它的高速缓冲寄存器。
第十，把调试寄存器DR7中的局部启用位设置为0，以清除局部于原任务的各个断点和方式。
4.关于任务状态和嵌套的说明
在段间转移指令JMP引起任务切换时，不实施链接，不导致任务的嵌套。
它要求目标任务是可用的任务。切换过程中把原任务置为“可用”，目标任务置为“忙”。
在段间调用指令CALL引起任务切换时，实施链接，导致任务的嵌套。它要求目标任务是可用的任务。
在切换过程中把目标任务置为“忙”，原任务仍保持“忙”；标志寄存器EFLAGS中的NT位被置1，表示是嵌套任务。
在由中断/异常引起任务切换时，实施链接，导致任务的嵌套。要求目标任务是可用的任务。
在切换过程中把目标任务置为“忙”，原任务仍保持“忙”；标志寄存器EFLAG中的NT位被置1，表示是嵌套任务。
在执行IRET时引起任务切换，那么实施解链。要求目标任务是忙的任务。在切换过程中把原任务置为“可用”，目标任务仍保持“忙”。
关于中断/异常如何引起任务切换和指令IRET如何考虑任务切换的内容在10.7节中介绍。
10.6.6演示任务切换的实例（实例五）
下面给出一个用于演示任务切换的实例。该实例的逻辑功能是在任务切换后显示原任务的挂起点（EIP）值。
该实例演示内容包括：直接通过TSS段的任务切换，通过任务门的任务切换，任务内特权级的变换及参数传递。
1.实现流程
为了达到演示任务切换和特权级变换的目的，实例五在保护方式下涉及到两个任务，一个任务称为临时任务，另一个任务称为演示任务。
演示任务的功能是演示通过调用门实现特权级的变换和堆栈间参数的自动复制。临时任务和演示任务配合展示任务切换。
实例五的主要实现步骤如图10.18所示。在图的右边标出了任务切换和特权级变换的分界情况。
在任务切换时，把原任务的现场保存到TR所指示的TSS内，然后再把指向目标任务TSS描述符的选择子装入TR，
所以，在从临时任务切换到演示任务之前，要把指向临时任务TSS描述符的选择子装入TR。
通过把演示任务的TSS初始化成恢复点在特权级为2的代码段，使得在从临时任务切换到演示任务后，当前特权级CPL=2。
2.源程序组织和清单
实例五有如下部分组成：
（1）全局描述符表GDT。
GDT含有演示任务TSS描述符和LDT段描述符，还含有临时任务TSS描述符和临时任务的代码段描述符，此外，
还含有子程序代码段描述符、规范数据段描述符和视频缓冲区段描述符。
（2）演示任务的TSS段。已根据演示要求初始化。
（3）演示任务的LDT段。
它含有演示任务的0级和2级堆栈段描述符、代码段和数据段描述符、分别以数据段方式描述LDT和临时任务TSS的数据段描述符、
以及指向子程序的调用门和指向临时任务的任务门。
（4）演示任务的0级和2级堆栈段。32位段，特权级分别为0和2。
（5）演示任务数据段。32位段，特权级3。
（6）子程序代码段。32位代码段，特权级0。
（7）演示任务代码段。32位代码段，特权级2。
（8）临时任务的TSS段。未初始化。
（9）临时任务代码段。16位段，特权级0。
（10）实方式下的数据和代码段。
该实例的逻辑功能是在任务切换后显示原任务的挂起点值。源程序清单如下：
；程序名：T10-5.ASM
；功能：演示任务切换和任务内特权级变换
DESCRIPTOR STRUC
LIMITL DW 0
BASEL DW 0
BASEM DB 0
ATTRIBUTES DW 0
BASEH DB 0
DESCRIPTOR ENDS
GATE STRUC
OFFSETL DW 0
SELECTOR DW 0
DCOUNT DB 0
GTYPE DB 0
OFFSETH DW 0
GATE ENDS
PDESC STRUC
LIMIT DW 0
BASE DD 0
PDESC ENDS
TASKSS STRUC
TRLINK DW ?,0
TRESP0 DD ?
TRSS0 DW ?,0
TRESP1 DD ?
TRSS1 DW ?,0
TRESP2 DD ?
TRSS2 DW ?,0
TRCR3 DD ?
TREIP DD ?
TREFLAG DW ?,?
TREAX DD ?
TRECX DD ?
TREDX DD ?
TREBX DD ?
TRESP DD ?
TREBP DD ?
TRESI DD ?
TREDI DD ?
TRES DW ?,0
TRCS DW ?,0
TRSS DW ?,0
TRDS DW ?,0
TRFS DW ?,0
TRGS DW ?,0
TRLDT DW ?,0
TRFLAG DW 0
TRIOMAP DW $ + 2
TASKSS ENDS
ATDR = 90H
ATDW = 92H
ATDWA = 93H
ATCE = 98H
ATCER = 9AH
ATCCO = 9CH
ATCCOR = 9EH
ATLDT = 82H
ATTASKGAT = 85H
AT386TSS = 89H
AT386CGAT = 8CH
AT386IGAT = 8EH
AT386TGAT = 8FH
DPL1 = 20H
DPL2 = 40H
DPL3 = 60H
RPL1 = 01H
RPL2 = 02H
RPL3 = 03H
IOPL1 = 1000H
IOPL2 = 2000H
IOPL3 = 3000H
D32 = 4000H
TIL = 04H
VMFL = 0002H
IFL = 0200H
JUMP32 MACRO selector,offsetv
DB 0EAH
DW offsetv
DW 0
DW selector
ENDM
CALL32 MACRO selector,offsetv
DB 9AH
DW offsetv
DW 0
DW selector
ENDM
JUMP16 MACRO selector,offsetv
DB 0EAH
DW offsetv
DW selector
ENDM
CALL16 MACRO selector,offsetv
DB 9AH
DW offsetv
DW selector
ENDM
.386P
GDTSEG SEGMENT PARA USE16
GDT LABEL BYTE
DUMMY DESCRIPTOR <>
NORMAL DESCRIPTOR <0FFFFH,0,0,ATDW,0>
NORMAL_SEL = NORMAL - GDT
EFFGDT LABEL BYTE
EFFGDTOFF = $ - GDT
DEMOTSS DESCRIPTOR <DEMOTSSLEN - 1,DEMOTSSSEG,,AT386TSS,>
DEMOTSS_SEL = DEMOTSS - GDT
DEMOLDTABLE DESCRIPTOR <DEMOLDTLEN - 1,DEMOLDTSEG,,ATLDT,>
DEMOLDT_SEL = DEMOLDTABLE - GDT
TEMPTSS DESCRIPTOR <TEMPTSSLEN - 1,TEMPTSSSEG,,AT386TSS + DPL2,>
TEMPTSS_SEL = TEMPTSS - GDT
TEMPCODE DESCRIPTOR <0FFFFH,TEMPCODESEG,,ATCE,>
TEMPCODE_SEL = TEMPCODE - GDT
SUBR DESCRIPTOR <SUBRLEN - 1,SUBRSEG,,ATCE + D32,>
SUBR_SEL = (SUBR - GDT) + RPL3
VIDEOBUFF DESCRIPTOR <0FFFFH,0,0,0F00H + ATDW + DPL3,0>
VIDEO_SEL = VIDEOBUFF - GDT
GDNUM= ($ - EFFGDT) / 8
GDTLEN = $ - GDT
GDTSEG ENDS
DEMOTSSSEG SEGMENT PARA USE16
EFFTSS LABEL BYTE
DW 0,0
DW DEMOSTACK0LEN,0
DW DEMOSTACK0_SEL,0
DW 0,0
DW ?,0
DW DEMOSTACK2LEN,0
DW DEMOSTACK2_SEL,0
DD 0
DD DEMOBEGINOFF
DD 0
DD 0
DD 0
DD 0
DD 0
DD DEMOSTACK2LEN
DD 0
DD 0
DD 0B8000H
DW VIDEO_SEL,0
DW DEMOCODE_SEL,0
DW DEMOSTACK2_SEL,0
DW DEMODATA_SEL,0
DW TODLDT_SEL,0
DW TOTTSS_SEL,0
DW DEMOLDT_SEL,0
DW 0
DW $ + 2
DB 0FFH
DEMOTSSLEN = $ - EFFTSS
DEMOTSSSEG ENDS
DEMOLDTSEG SEGMENT PARA USE16
EFFLDT LABEL BYTE
EFFLDTOFF = $ - EFFLDT
DEMOSTACK0 DESCRIPTOR <DEMOSTACK0LEN - 1,DEMOSTACK0SEG,,ATDW + D32,>
DEMOSTACK0_SEL = (DEMOSTACK0 - EFFLDT) + TIL
DEMOSTACK2 DESCRIPTOR <DEMOSTACK2LEN - 1,DEMOSTACK2SEG,,ATDW + D32 + DPL2,>
DEMOSTACK2_SEL = (DEMOSTACK2 - EFFLDT) + TIL + RPL2
DEMOCODE DESCRIPTOR <DEMOCODELEN - 1,DEMOCODESEG,,ATCE + D32 + DPL2,>
DEMOCODE_SEL = (DEMOCODE - EFFLDT) + TIL + RPL2
DEMODATA DESCRIPTOR <DEMODATALEN - 1,DEMODATASEG,,ATDW + D32 + DPL3,>
DEMODATA_SEL = (DEMODATA - EFFLDT) + TIL
TODLDT DESCRIPTOR <DEMOLDTLEN - 1,DEMOLDTSEG,,ATDW + DPL2,>
TODLDT_SEL = (TODLDT - EFFLDT) + TIL
TOTTSS DESCRIPTOR <TEMPTSSLEN - 1,TEMPTSSSEG,,ATDW + DPL2,>
TOTTSS_SEL = (TOTTSS - EFFLDT) + TIL
DEMOLDNUM = ($ - EFFLDT) / 8
TOSUBR GATE <SUBRBOFF,SUBR_SEL,0,AT386CGAT + DPL3,0>
TOSUBR_SEL = (TOSUBR - EFFLDT) + TIL + RPL2
TOTEMPT GATE <0,TEMPTSS_SEL,0,ATTASKGAT + DPL3,0>
TOTEMPT_SEL = (TOTEMPT - EFFLDT) + TIL
DEMOLDTLEN = $ - EFFLDT
DEMOLDTSEG ENDS
DEMOSTACK0SEG SEGMENT PARA USE32
DEMOSTACK0LEN = 1024
DB DEMOSTACK0LEN DUP (0)
DEMOSTACK0SEG ENDS
DEMOSTACK2SEG SEGMENT PARA USE32
DEMOSTACK2LEN = 512
DB DEMOSTACK2LEN DUP (0)
DEMOSTACK2SEG ENDS
DEMODATASEG SEGMENT PARA USE32
EFFDATA LABEL BYTE
MESSAGE DB 'Value=',0
DEMODATALEN = $ - EFFDATA
DEMODATASEG ENDS
SUBRSEG SEGMENT PARA USE32
EFFSUBR LABEL BYTE
ASSUME CS:SUBRSEG
SUBRBOFF = $ - EFFSUBR
SUBRB PROC FAR
PUSH EBP
MOV EBP,ESP
PUSHAD
MOV EAX,[EBP+12]
MOV ESI,EAX
MOV AH,7
JMP SHORT SUBR2
SUBR1:STOSW
SUBR2:LODSB
OR AL,AL
JNZ SUBR1
MOV EDX,[EBP+16]
MOV ECX,8
SUBR3:ROL EDX,4
MOV AL,DL
CALL HTOASC
STOSW
LOOP SUBR3
POPAD
POP EBP
RETF 8
SUBRB ENDP
HTOASC PROC
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
RET
HTOASC ENDP
SUBRLEN = $ - EFFSUBR
SUBRSEG ENDS
DEMOCODESEG SEGMENT PARA USE32
ASSUME CS:DEMOCODESEG
EFFDEMO LABEL BYTE
DEMOBEGINOFF = $ - EFFDEMO
DEMOBEGIN:MOV FS:TOSUBR.DCOUNT,2
MOV EAX,GS:TEMPTASK.TREIP
PUSH EAX
MOV EAX,OFFSET MESSAGE
PUSH EAX
CALL32 TOSUBR_SEL,0
ASSUME DS:TEMPTSSSEG
PUSH GS
POP DS
MOV AX,NORMAL_SEL
MOV TEMPTASK.TRDS,AX
MOV TEMPTASK.TRES,AX
MOV TEMPTASK.TRFS,AX
MOV TEMPTASK.TRGS,AX
MOV TEMPTASK.TRSS,AX
JUMP32 TOTEMPT_SEL,0
DEMOCODELEN = $ - EFFDEMO
DEMOCODESEG ENDS
TEMPTSSSEG SEGMENT PARA USE16
EFFTEMPT LABEL BYTE
TEMPTASK TASKSS <>
DB 0FFH
TEMPTSSLEN = $ - EFFTEMPT
TEMPTSSSEG ENDS
TEMPCODESEG SEGMENT PARA USE16
ASSUME CS:TEMPCODESEG
EFFTEMPC LABEL BYTE
VIRTUALOFF = $ - EFFTEMPC
VIRTUAL:MOV BX,TEMPTSS_SEL
LTR BX
JUMP16 DEMOTSS_SEL,0
TOREALOFF = $ - EFFTEMPC
TOREAL:CLTS
MOV EAX,CR0
AND EAX,0FFFFFFFEH
MOV CR0,EAX
JUMP16 <SEG REAL>,<OFFSET REAL>
TEMPCODELEN = $ - EFFTEMPC
TEMPCODESEG ENDS
RDATASEG SEGMENT PARA USE16
VGDTR PDESC <GDTLEN - 1,>
SPVAR DW ?
SSVAR DW ?
RDATASEG ENDS
RCODESEG SEGMENT PARA USE16
ASSUME CS:RCODESEG,DS:RDATASEG
START:MOV AX,RDATASEG
MOV DS,AX
CLD
CALL INIT_GDT
MOV AX,DEMOLDTSEG
MOV FS,AX
MOV SI,EFFLDTOFF
MOV CX,DEMOLDNUM
CALL INIT_LDT
MOV WORD PTR SSVAR,SS
MOV WORD PTR SPVAR,SP
LGDT QWORD PTR VGDTR
CLI
MOV EAX,CR0
OR EAX,1
MOV CR0,EAX
JUMP16 TEMPCODE_SEL,VIRTUALOFF
REAL:MOV AX,RDATASEG
MOV DS,AX
LSS SP,DWORD PTR SPVAR
STI
MOV AX,4C00H
INT 21H
INIT_GDT PROC NEAR
PUSH DS
MOV AX,GDTSEG
MOV DS,AX
MOV CX,GDNUM
MOV SI,EFFGDTOFF
INITG:MOV AX,[SI].BASEL
MOVZX EAX,AX
SHL EAX,4
SHLD EDX,EAX,16
MOV [SI].BASEL,AX
MOV [SI].BASEM,DL
MOV [SI].BASEH,DH
ADD SI,8
LOOP INITG
POP DS
MOV BX,16
MOV AX,GDTSEG
MUL BX
MOV WORD PTR VGDTR.BASE,AX
MOV WORD PTR VGDTR.BASE+2,DX
RET
INIT_GDT ENDP
INIT_LDT PROC NEAR
ILDT:MOV AX,FS:[SI].BASEL
MOVZX EAX,AX
SHL EAX,4
SHLD EDX,EAX,16
MOV FS:[SI].BASEL,AX
MOV FS:[SI].BASEM,DL
MOV FS:[SI].BASEH,DH
ADD SI,8
LOOP ILDT
RET
INIT_LDT ENDP
RCODESEG ENDS
END START
在XP下使用tasm t459.asm编译，tlink /3 t459.obj链接
在DOS下运行t459.exe，在左上角黑底白字显示Value=0000000B
3.关于实例五的说明
程序中部分片段的背景和实现方法已在前面的实例中做过介绍，
下面主要就任务切换和通过调用门实现任务内特权级变换时参数的复制等情形作些说明：
（1）从临时任务直接通过TSS切换到演示任务
在从实方式切换到保护方式后，就认为进入了临时任务。但TR并没有指向临时任务的TSS。
在从临时任务切换到演示任务时，要把临时任务的现场保存到临时任务的TSS，这就要求TR指向临时任务的TSS。
所以，首先要使用LTR指令把指向临时任务TSS描述符的选择子装入TR。在利用LTR指令显式地装载TR时，并不引用TSS的内容，
所以临时任务的TSS几乎没有初始化。理由是这不是真正的任务切换。临时任务采用段间转移指令JMP，直接指向演示任务的TSS，切换到演示任务。
在执行切换到演示任务的段间转移指令JMP时，CPL=0，JMP指令中所含选择子内的RPL=0，演示任务TSS的描述符DPL=0，并且是一个可用的TSS，
所以顺利进行从临时任务到演示任务的切换。切换过程包括：把临时任务的执行现场保存到临时任务的TSS中；
从演示任务的TSS中恢复演示任务的现场；把演示任务的LDT描述符选择子装载到LDTR等。从源程序可见，
初始化后的演示任务TSS中CS字段存放的选择子是DEMOCODE_SEL，对应的描述符在演示任务的LDT中，并且DPL=2，
它描述了代码段DEMOCODE；挂起点是DEMOBEGIN，所以在切换到演示任务后从该点开始执行，并且CPL=2。
由于使用JMP指令进行任务切换，所以不实施任务链接。
（2）从演示任务通过任务门切换到临时任务
演示任务采用段间转移指令JMP，通过任务门TOTEMPT切换到临时任务。在执行切换到临时任务的段间转移指令JMP时，CPL=2，
JMP指令中所含选择子TOTEMPT_SEL内的RPL=0，它指示的任务门DPL=3，所以可以访问该任务门。
任务门内的选择子TEMPTSS_SEL指示临时任务TSS，并且此时的临时任务TSS是可用的，所以可顺利进行任务切换。
演示任务的现场保存到演示任务的TSS；临时任务的现场从临时任务的TSS恢复。
临时任务的挂起点是临时任务代码段内的TOREAL点，所以恢复后的临时任务从该点开始，CS含临时任务代码段选择子。
但由于在演示任务内“强硬”地改变了临时任务TSS内的SS和DS等字段，所以在恢复到临时任务时，SS和DS等段寄存器内已含规范数据段的选择子，
而非挂起时的原有值。注意，这种做法不被提倡，但在这里却充分地展示如何从TSS恢复任务。
（3）演示任务内的特权级变换和堆栈传递参数
演示任务采用段间调用指令CALL，通过调用门TOSUBR调用子程序SUBRB。
执行段间调用指令CALL时的CPL=2，指令所含指向调用门的选择子RPL=2，调用门的DPL=3，所以对调用门的访问是允许的；
尽管调用门内的选择子RPL=3，但由于它所指示的子程序代码段描述符DPL=0，所以在调用过程中就发生了从特权级2到特权级0的变换，
同时堆栈也被切换。演示代码通过堆栈传递了两个参数给子程序SUBRB。在把参数压入堆栈时，CPL=2，使用的也是对应特权级2的堆栈。
通过调用门进入子程序后，CPL=0，使用0级堆栈。为此，把调用门TOSUBR中的DCOUNT字段设置为2，表示在特权级向内层变换时，
需从外层堆栈依次复制2个双字参数到内层堆栈。随着特权级变换，堆栈也跟着变换，如图10.15所示。
这种在堆栈切换的同时复制所需参数的做法，保证了子程序方便地访问堆栈中的参数，而无需考虑是哪个堆栈。
随着从子程序SUBRB的返回，CPL=0变换为CPL=2，堆栈也回到2级堆栈。由于再进入0级堆栈时，总是从空开始，
所以在返回前不是非要保持内层堆栈平衡的。但2级堆栈中的2个双字参数需要废除。从源程序可见，这是采用带立即数的段间返回指令实现的，
在返回的同时自动废除外层堆栈中的参数。
（4）别名技术的应用
在10.6.2节对实例三作说明时，已介绍过别名技术。实例五也有两处应用了别名技术。
为了把调用门TOSUBR中的DCOUNT字段设置成2，使用一个数据段描述符TODLDT描述调用门所在演示任务LDT段，
该描述符把演示任务的LDT段描述成数据段。请读者考虑源程序如何把指向该数据段描述符的选择子装载到FS寄存器。
还有一处是把临时任务的TSS视作为普通数据段。在从演示任务切换到临时任务之前，
把指向描述规范数据段的描述符NORMAL的选择子NORMAL_SEL填到临时任务TSS中的各数据段寄存器（包括堆栈段寄存器）字段，
于是在切换到临时任务时，作为恢复临时任务的现场，该选择子就被装到DS等数据段寄存器，
对应的描述符NORMAL内的信息也就被装入到对应的高速缓冲寄存器中，达到为从临时任务切换到实方式作准备的目的。
10.780386的中断和异常
第5章介绍了中断的基本概念和8086/8088处理中断的有关内容。
80386除了保持8086/8088的相关功能外，还增强了中断处理功能，并引入“异常”的概念。本节在第5章的基础上介绍80386的中断和异常。
10.7.180386的中断和异常
8086/8088把中断分为内部中断和外部中断两大类。为了支持多任务和虚拟存储器等功能，80386把外部中断称为“中断”，把内部中断称为“异常”。
与8086/8088一样，80386通常在两条指令之间响应中断或异常；80386最多处理256种中断或异常。
1.中断
对80386而言，中断是由异步的外部事件引起的。外部事件及中断响应与正执行的指令没有关系。通常，中断用于指示I/O设备的一次操作已完成。
与8086/8088一样，80386有两根引脚INTR和NMI接受外部中断请求信号。INTR接受可屏蔽中断请求。NMI接受不可屏蔽中断请求。
在80386中，标志寄存器EFLAGS中的IF标志决定是否屏蔽可屏蔽中断请求。
外部硬件在通过INTR发出中断请求信号的同时，还要向处理器给出一个8位的中断向量号。处理器在响应可屏蔽中断请求时，
读取这个由外部硬件给出的中断向量号。处理器对这个中断向量号并没有规定。但在具体的微机系统中，系统必须通过软件和硬件的配合设置，
使得给出的这个中断向量号不仅与外部中断源对应，而且要避免中断向量号使用冲突情况的出现。
可编程中断控制器芯片8259A可配合80386工作，能够根据设置向处理器提供上述这个中断向量号，还能处理中断请求的优先级。
每个8259A芯片可以支持8路中断请求信号，如果使用9个8259A芯片，就可使80386在单个引脚INTR上接受多达64个中断源的中断请求信号。
处理器不屏蔽来自NMI的中断请求。处理器在响应NMI中断时，不从外部硬件接收中断向量号。与8086/8088一样，在80386中，
不可屏蔽中断所对应的中断向量号固定为2。为了避免不可屏蔽中断的嵌套，每当接受一个NMI中断，处理器就在内部屏蔽了再次响应NMI，
这一屏蔽过程直到执行中断返回指令IRET后才结束。所以，NMI处理程序应以IRET指令结束。
2.异常
异常是80386在执行指令期间检测到不正常的或非法的条件所引起的。异常与正执行的指令有直接的联系。例如：执行除法指令时，除数等于0。
再如，执行指令时发现特权级不正确。当发生这些情况时，指令就不能成功完成。
软中断指令“INT n”和“INTO”也归类于异常而不称为中断，这是因为执行这些指令产生异常事件。
80386识别多种不同类别的异常，并赋予每一种类别不同的中断向量号。异常发生后，处理器就象响应中断那样处理异常。
也即，根据中断向量号，转相应的中断处理程序。把这种中断处理程序称为异常处理程序可能更合适。
根据引起异常的程序是否可被恢复和恢复点不同，把异常进一步分类为故障（Fault）、陷阱（Trap）和中止（Abort）。
我们把对应的异常处理程序分别称为故障处理程序、陷阱处理程序和中止处理程序。
故障是在引起异常的指令之前，把异常情况通知给系统的一种异常。80386认为故障是可排除的。
当控制转移到故障处理程序时，所保存的断点CS及EIP的值指向引起故障的指令。这样，在故障处理程序把故障排除后，
执行IRET返回到引起故障的程序继续执行时，刚才引起故障的指令可重新得到执行。这种重新执行，不需要操作系统软件的额外参与。
故障的发现可能在指令开始执行之前，也可能在指令执行期间。如果在执行指令期间检测到故障，那么中止故障指令，
并把指令的源操作数恢复为指令开始执行之前的值。这可保证故障指令的重新执行得到正确的结果。
例如，在一条指令的执行期间，如果发现段不存在，那么停止该指令的执行，并通知系统产生段故障，
对应的段故障处理程序可通过加载该段的方法来排除故障，之后，原指令就可成功执行，至少不再发生段不存在故障。
陷阱是在引起异常的指令之后，把异常情况通知给系统的一种异常。当控制转移到异常处理程序时，
所保存的断点CS及EIP的值指向引起陷阱的指令的下一条要执行指令。下一条要执行的指令，不一定就是下一条指令。
因此，陷阱处理程序并不是总能根据保存的断点，反推确定出产生异常的指令。在转入陷阱处理程序时，引起陷阱的指令应正常完成，
它有可能改变了寄存器或存储单元。软中断指令、单步异常是陷阱的例子。
中止是在系统出现严重情况时，通知系统的一种异常。引起中止的指令是无法确定的。产生中止时正执行的程序不能被恢复执行。
系统接收中止后，处理程序要重新建立各种系统表格，并可能需要重新启动操作系统。硬件故障和系统表中出现非法值或不一致值是中止的例子。
中断的分类：外中断和内中断
根据系统对中断处理的需要，操作系统一般对中断进行分类并对不同的中断赋予不同的处理优先级，以便在不同的中断同时发生时，按轻重缓急进行处理。
 根据中断源产生的条件，可把中断分为外中断和内中断。
外中断是指来自处理器和内存外部的中断，包括I/O设备发出的I/O中断、外部信号中断(例如用户键入ESC键)。
各种定时器引起的时钟中断以及调试程序中设置的断点等引起的调试中断等。外中断一般被称为中断。 
内中断主要指在处理器和内存内部产生的中断，包括程序运算引起的各种错误，如地址非法、校验错、页面失效、存取访问控制错、算术操作溢出、
数据格式非法、除数为零、非法指令、用户程序执行特权指令、分时系统中的时间片中断以及从用户态到核心态的切换等。 内中断一般被称为异常。
为了按中断源的轻重缓急处理响应中断，操作系统为不同的中断赋予不同的优先级。
各中断源的优先级在系统设计时给定，在系统运行时是固定的。而处理器的优先级则根据执行情况由系统程序动态设定。 
除了在优先级的设置方面有区别之外，中断和异常还有如下主要区别：
1、异常通常由处理器正在执行的现行指令引起，而中断则是由与现行指令无关的中断源引起的。
异常处理程序提供的服务为当前进程所用，而中断处理程序提供的服务则不是为了当前进程的。
2、中断是由硬件引起的，而异常是由软件引起。
3、中断是异步的，而异常是同步的。 CPU执行完一条指令之后，下一条指令开始之前响应中断，而在一条指令执行中也可以响应异常。
例如执行指令非法时，尽管被执行的非法指令不能执行结束，但CPU仍可对其进行处理。
异常的类别：故障、陷阱、中止
故障可能被故障处理程序修正，如果修正成功，将返回到当前正在执行的指令，重新执行。故障的一个典型是缺页异常。
陷阱最重要的用途是在用户程序和内核之间提供系统调用接口。陷阱总返回到当前指令的下一条指令。
中止由不可恢复的错误造成。
3.优先级
在一条指令执行期间，如检测到不止一个中断或异常，那么按表10.6所列优先级通知系统。
把优先级最高的中断或异常通知系统，其他优先级较低的异常被废弃，而优先级较低的中断则保持悬挂。
请读者考虑，为什么优先级较低的异常可被废弃？
表10.680386响应中断/异常的优先级
中断/异常类型         优先级         中断/异常类型         优先级
调试故障                 最高             调试陷阱
其他故障                                     NMI中断
陷阱指令INT n和INTO                INTR中断                最低
调试故障>其他故障>陷阱指令INT n和INTO>调试陷阱>NMI中断>INTR中断   
10.7.2异常类型
象中断分为多种类型一样，异常也分为多种类型。
1.80386识别的异常
80386识别的多种不同类别的异常及赋予的对应中断向量号列于表10.7。
某些异常还以出错码的形式提供一些附加的信息传递给异常处理程序，出错代码列中的“无”表示没有出错代码，“有”表示有出错代码。
表10.7异常一览表
向量号         异常名称         异常类型         出错代码         相关指令
0              除法出错             故障               无                   DIV,IDIV
1              调试异常           故障/陷阱        无                    任何指令
3            单字节INT3         陷阱                无                    INT 3
4            溢出                    陷阱                无                    INTO
5            边界检查             故障                无                    BOUND
6          非法操作码            故障                无                   非法指令编码或操作数
7          设备不可用            故障                无                   浮点指令或WAIT
8          双重故障               中止                有                    任何指令
9         协处理器段越界      中止                无                    访问存储器的浮点指令
0A       无效TSS异常          故障                有                    JMP、CALL、IRET、中断
0B       段不存在异常         故障                 有                   装载段寄存器的任何指令
0C       堆栈段异常            故障                 有                   装载SS寄存器的任何指令 对SS寻址的段访问的任何指令
0D      通用保护异常         故障                 有                   任何特权指令 任何访问存储器的指令
0E      页异常                   故障                 有                   任何访问存储器的指令
10      协处理器出错          故障                无                    浮点指令或WAIT
00~FF 软中断                   陷阱                无                    INT n
表5.2部分中断向量的分配
向量号                  使用                  向量号                  使用
0                       除法出错               4                          溢出
1                       单步                      5                       打印屏幕
2                       非屏蔽中断            6                          保留
3                       断点                      7                          保留
8                       定时器                  0C                     串行通信接口1
9                       键盘                     0D                     硬盘（并行口）
0A              保留（从中断控制器） 0E                         软盘
0B                  串行通信接口2         0F                        打印机
10              视频显示                      17                      打印输出
11              设备配置                      18                   ROM BASIC
12              存储容量                      19                     系统自举
13              磁盘I/O                        1A                     时钟管理
14              串行I/O                        1B                Ctrl+ Break键处理
15            扩充的BIOS                    1C                      定时处理
16              键盘输入                   1D--1F                  参数指针
20--2F       DOS使用                   30--3F                 为DOS保留
把表10.7与表5.2比较，就会发现某些中断向量号（如08-10H）的分配发生了冲突。
表5.2所列的中断向量号的分配基于PC微机系统，使用的CPU是8088。
表10.7所列中断向量号的分配是80386所规定的。实际上，Intel在宣布8086/8088时，保留了这些发生冲突的中断向量号。
尽管发生这样的冲突，但以80386为CPU的微机系统仍可保持与以8088为CPU的微机系统的兼容，
原因是在80386的实方式下，几乎不会发生那些中断向量号与外部硬件在提出中断请求时所提供的中断向量号存在冲突的异常。
2.故障类异常
当发生故障，控制转移到故障处理程序时，所保存的断点CS及EIP的值指向引起故障的指令，以便在排除故障后恢复执行。
（1）除法出错故障（异常0）
除法出错是一种故障。当执行DIV指令或IDIV指令时，如果除数等于0，或者商太大，以至于存放商的操作数容纳不下，那么产生这一故障。
除法出错故障不提供出错码。
（2）边界检查故障（异常5）
如果BOUND指令发现被测试的值超出了指令中给定的范围，那么发生边界检查故障。边界检查故障不提供出错码。
（3）非法操作码故障（异常6）
如果80386不能把CS及EIP所指存储单元处的位模式识别为某条指令的部分，那么就发生非法操作码故障。
当出现如下情况时，发生这样的故障：
①操作码字段的内容不是一个合法的80386指令的代码；
②要求使用存储器操作数的场合，使用了寄存器操作数；
③不能被加锁的指令使用了LOCK前缀。
非法操作码故障不提供出错码。
（4）设备不可用故障（异常7）
设备不可用故障支持80387数字协处理器。在没有80387协处理器硬件的系统中，可用该异常的处理程序代替协处理器的软件模拟器。
在发生任务切换时，使得只有在新任务使用浮点指令时，才进行80387寄存器状态的切换。设备不可用故障不提供出错码。
EM位控制浮点指令的执行是用软件模拟，还是由硬件执行。EM=0时，硬件控制浮点指令传送到协处理器；EM=1时，浮点指令由软件模拟。
TS位用于加快任务的切换，通过在必要时才进行协处理器切换的方法实现这一目的。
每当进行任务切换时，处理器把TS置1。TS=1时，浮点指令将产生设备不可使用异常。
MP位控制WAIT指令在TS=1时，是否产生DNA异常。MP=1和TS=1时，WAIT产生异常；MP=0时，WAIT指令忽略TS条件。
该故障在下列情况下产生：
①在执行浮点指令时，控制寄存器CR0中的EM位或TS为1；
②在执行WAIT指令时，控制寄存器CR0中TS位及MP位都为1。
（5）段不存在故障（异常0BH）
处理器在把描述符装入非SS段寄存器的高速缓冲器时，如果发现描述符其他方面有效，而P位为0（表示对应段不存在），那么就发生段不存在故障。
有关SS段的情形纳入堆栈段故障。在进入故障处理程序时，保存的CS及EIP指向发生故障的指令；或者该故障作为任务切换的一部分发生时，
指向任务的第一条指令。段不存在故障提供一个包含引起该异常的段选择子的出错码。出错码的格式如图10.19所示。
15                        3   2   1   0
选择子的索引部分     TI  IDT EXT
16位出错码的主要成分是选择子，高13位是选择子的索引部分，TI位是描述符表指示位。
图10.19所示出错码格式是段异常时出错码的一般格式。从图中可见出错码中不含选择子的RPL，而由IDT位和EXT位代替。
当处理某一异常或外部中断时，又发生了某种异常，那么EXT位置1。当从中断描述符表IDT中读出表项并产生异常时，IDT位置1，
这只在中断或异常的处理期间才会发生。当没有选择子时，构成出错码选择子部分的值为0。
（6）堆栈段故障（异常0CH）
当处理器检测到用SS寄存器进行寻址的与段有关的某种问题时，就发生堆栈段故障。
在进入故障处理程序时，保存的CS及EIP指向发生故障的指令；或者该故障作为任务切换的一部分发生时，指向任务的第一条指令。
堆栈段故障提供一个出错码，出错码的一般格式也如图10.19所示。
具体地说，当出现下列三种情况时，将引起堆栈段故障：
①在堆栈操作时，偏移超出段界限所规定的范围。这种情况下的出错码是0。例如，PUSH操作时，堆栈溢出。
②在由特权级变换所引起的对内层堆栈的操作时，偏移超出段界限所规定的范围。这种情况下的出错码包含有内层堆栈的选择子。
③装入到SS寄存器（高速缓冲寄存器）的描述符中的存在位为0。这种情况下的出错码包含有对应的选择子。
上述第一种情况是容易辨别的。第二和第三种情况的辨别要通过判断出错码所含选择子所指示的描述符中的存在位进行。
如果存在位为1，那么是第二种情况；否则是第三种情况。
（7）无效TSS故障（异常0AH）
当正从任务状态段TSS装入选择子时，如果发生除了不存在故障以外的段异常时，就发生无效TSS故障。
在进入故障处理程序时，保存的CS及EIP指向发生故障的指令；或者该故障作为任务切换的一部分发生时，指向任务的第一条指令。
无效TSS故障提供一个出错码，出错码的格式也如图10.19所示，其中选择子部分是指向引起故障的TSS的选择子。
一些引起无效TSS故障的原因如下：
TSS描述符中的段限长小于103；无效的LDT描述符，或者LDT未出现；堆栈段不是一个可写段；堆栈段选择子索引的描述符超出描述符表界限；
堆栈段DPL与新的CPL不匹配；堆栈段选择子RPL不等于CPL；代码段选择子索引的描述符超出描述符表界限；代码段选择子不指向代码段；
非一致代码段的DPL不等于新的CPL；一致代码段DPL大于新的CPL；对应DS、ES、FS或GS的选择子指向一个不可读段；
对应DS、ES、FS或GS的选择子索引的描述符超出描述符表界限。
（8）通用保护故障（异常0DH）
除了明确列出的段异常外，其他的段异常都被视作为通用保护故障。在进入故障处理程序时，保存的CS及EIP指向发生故障的指令；
或者该故障作为任务切换的一部分发生时，指向任务的第一条指令。
通用保护故障提供一个出错码，出错码的一般格式也如图10.19所示。
根据处理程序可能进行的响应，通用保护故障可分为如下两类：
①违反保护方式，但程序无须终止的异常。这类故障提供的出错码是0。
这种异常在应用程序执行特权指令或I/O访问时发生，支持虚拟8086程序的系统或支持虚拟I/O访问的系统，需要模拟这些指令，
并在模拟完成产生故障的指令后，重新执行被中断的程序。
②违反保护方式，并导致程序终止的异常。这类故障提供的出错码可能为0，也可能不为0（能确定选择子时）。
引起这类故障的一些原因如下：
向某个只读数据段或代码段写；从某个只能执行的代码段读出；将某个系统段描述符装入到数据段寄存器DS、ES、FS、GS或SS；
将控制转移到一个不可执行的段；在通过段寄存器CS、DS、ES、FS或GS访问内存时，偏移越出段界限；
当访问某个描述符表时，超过描述符表段界限；把PG位为1但PE位为0的控制信息装入到CR0；切换到一个正忙的任务。
对上述两类通用保护故障的辨别，可通过检查引起故障的指令和出错码进行。如果出错码非0，那么肯定是第二类通用保护故障。
如果出错码是0，那么需进一步检查引起故障的指令，以确定它是否是系统支持的可以模拟的指令。
（9）页故障（异常0EH）关于页故障的详细说明见10.10.4节。
（10）协处理器出错（异常10H）协处理器出错故障指示协处理器发生了未被屏蔽的数字错误，如上溢或下溢。
在引起故障的浮点指令之后的下一条浮点指令或WAIT指令，把协处理器出错作为一个故障通知给系统。协处理器出错故障不提供出错码。
2.陷阱类异常
（1）调试陷阱（异常1）
调试异常有故障类型，也有陷阱类型。调试程序可以访问调试寄存器DR6，以确定调试异常的原因和类型。调试异常不提供出错码。
（2）单字节INT3（异常3）
INT 3是一条特别的一字节“INT n”指令。调试程序可利用该指令支持程序断点。
INT 3指令被看成是一种陷阱，而不是一个中断。当由于执行INT 3指令进入异常3处理程序时，被保存的CS和EIP指向紧跟INT3的指令，
也即INT 3指令后面的一个字节。INT 3陷阱不提供出错码。
（3）溢出（异常4）
INTO指令提供条件陷阱。如果OF标志为1，那么INTO指令产生陷阱；否则不产生陷阱，继续执行INTO后面的指令。
在进入溢出处理程序时，被保存的CS和EIP指向INTO指令的下一条指令。溢出陷阱不提供出错码。
3.中止类异常
（1）双重故障异常（异常8）
当系统正在处理一个异常时，如果又检测到一个异常，处理器试图向系统通知一个双重故障，而不是通知第二个异常。
双重故障被分在中止异常那一类，所以在转入双重故障处理程序时，被保存的CS和EIP可能不指向引起双重故障的指令，
而且指令的重新启动不支持双重故障。双重故障提供的出错码是0。
当正处理一个段故障异常时，有可能又产生一个页故障。在这种情况下，通知给系统的是页故障异常而不是双重故障异常。
但是，如果正处理一个段或页故障时，又一个段故障被检测到；或者如果正处理一个页故障时，又一个页故障被检测到，那么就引起双重故障。
当正处理一个双重故障时，又一个段或页故障被检测到，那么处理器暂停执行指令，并进入关机方式。
关机方式类似于处理器执行一条HLT指令后的状态：处理器空转，并维持到处理器接收到一个NMI中断请求或者被重新启动为止。
在关机方式下，处理器不响应INTR中断请求。双重故障通常指示系统表出现严重的问题，例如段描述符表、页表或中断描述符表出现问题。
双重故障处理程序在重建系统表后，可能不得不重新启动操作系统。
（2）协处理器段越界（异常9）
协处理器段越界异常被分在中止异常这一类。当浮点指令操作数超出段界限时，产生该中止异常。协处理器段越界异常不提供出错码。
10.7.3中断和异常的转移方法
80386在实方式下的中断和异常转移方法与第5章所介绍的8086/8088响应中断的方法相同。
这里介绍的中断和异常的转移方法是指80386在保护方式下响应中断和处理异常时所采用的转移方法。
1.中断描述符表IDT
与8086/8088一样，在响应中断或者处理异常时，80386根据中断向量号转对应的处理程序。
但是，在保护方式下80386不再使用实方式下的中断向量表，而是使用中断描述符表IDT（Interrupt Descriptor Table）。
在保护方式下，80386把中断向量号作为中断描述符表IDT中描述符的索引，而不再是中断向量表中的中断向量的索引。
像全局描述符表GDT一样，在整个系统中，中断描述符表IDT只有一个。中断描述符表寄存器IDTR指示IDT在内存中的位置，
这也与如图10.10所示的GDTR指示GDT相似。由于80386只识别256个中断向量号，所以IDT最大长度是2K。
中断描述符表IDT所含的描述符只能是中断门、陷阱门和任务门。也就是说，在保护方式下，
80386只有通过中断门、陷阱门或任务门才能转移到对应的中断或异常处理程序。
图10.13给出了门描述符的格式。从中可见门描述符包含由选择子和偏移量构成的48位全指针。
另外，双字计数字段对中断门、陷阱门和任务门而言无意义。
2.中断响应和异常处理的步骤
由硬件自动实现的中断响应和异常处理的步骤如下：
首先，判中断向量号要索引的门描述符是否超出IDT的界限。如果超出界限，就引起通用保护故障，出错码是中断向量号乘8再加2。
其次，从IDT中取得对应的门描述符，分解出选择子、偏移量和描述符属性类型，并进行有关检查。
描述符只能是任务门、286中断门、286陷阱门、386中断门或386陷阱门，否则，就引起通用保护故障，出错码是中断向量号乘8再加2。
如果是由于INT n指令或者INTO指令引起转移，还要检查中断门或陷阱门描述符中的DPL是否满足CPL<=DPL。
这种检查可以避免应用程序执行INT n指令时，使用分配给各种设备用的中断向量号。
如果检查不通过，就引起通用保护故障，出错码是中断向量号乘8再加2。
门描述符中的P位必须是1，表示门描述符是一个有效项，否则就引起段不存在故障，出错码是中断向量号乘8再加2。
最后，根据门描述符类型，分情况转入中断或异常处理程序。
对于异常处理，在开始上述步骤之前，还要根据异常类型确定返回点；如果有出错码，则形成符合出错码格式的出错码。
对于异常处理，如果有出错码，在实际执行异常处理程序之前，还要把出错码压入堆栈。
为了保证堆栈的双字边界对齐，16位的出错码以32位的值压入，其中高16位的值未作定义。
3.通过中断门或陷阱门的转移
如果中断向量号所指示的门描述符是386中断门或386陷阱门，那么控制转移到当前任务的一个处理程序过程，并且可以变换特权级。
与通过调用门的CALL指令一样，从中断门或陷阱门中获取指向处理程序的48位全指针。
其中，16位选择子是对应处理程序代码段的选择子，它指示GDT或LDT中的描述符；32位偏移指示处理程序入口点在代码段内的偏移。
通过中断门或陷阱门的转移过程如图10.20所示。该过程由硬件自动进行。
图中“开始”处表示接上述分情况转移，所以此时已对由中断向量号所索引的IDT中的中断门或陷阱门描述符进行过必要的检查，
并从中取得指示处理程序的由选择子和偏移构成的48位全指针。“结束”处表示转入实际的中断或陷阱处理程序。
图10.20所示通过中断门或陷阱门的转移与通过调用门的转移很相似。
从图10.20可见，中断门或陷阱门中指示处理程序的选择子必须指向描述一个可执行代码段的描述符。
如果选择子为空，就引起通用保护故障，出错码是0。如果描述符不是代码段描述符，就引起通用保护故障，出错码含选择子。
中断或异常可以转移到同一特权级或内层特权级。上述指定处理程序段的描述符中的类型及DPL字段，
决定了这种同一任务内的转移是否要发生特权级的变换。如果是一个非一致的代码段，并且DPL<CPL，
那么要发生特权级的变换，堆栈也要切换成内层堆栈。但不复制堆栈中的参数。
图10.20中的“把描述符装入CS”是指把上述指定处理程序段的描述符装入CS的高速缓冲寄存器中，
在这一步骤中要对描述符进行如10.6.1节所述的其他检查，包括是否是代码段描述符和代码段是否存在等，因此可能再发生异常。
在对该描述符进行检查时，通过调整RPL=0的方法，实现只考虑DPL，而不考虑门中选择子的RPL。在把描述符装入CS之后，
还要检查门描述符中给出的表示处理程序代码段入口的偏移是否越界，即是否超出段界限。如果越界，就引起出错码为0的通用保护故障。
从图10.20可见，把标志寄存器和断点压入堆栈的做法和顺序与实方式是相同的，但这里每一次堆栈操作是一个双字，CS被扩展成32位。
把TF置成0，表示不允许处理程序单步执行。把NT置成0，表示处理程序在利用中断返回指令IRET返回时，返回到同一任务而不是一个嵌套任务。
从图10.20可见，通过中断门的转移和通过陷阱门的转移之间的差别只是对IF标志的处理。
对于中断门，在转移过程中，把IF置成0，使得在处理程序执行期间，屏蔽掉INTR中断；
对于陷阱门，在转移过程中，保持IF位不变，即如果IF位原是1，那么通过陷阱门转移到处理程序之后仍允许INTR中断。
因此，中断门最适宜于处理中断，而陷阱门适宜于处理异常。
从图10.20可见，在有出错码的情况下，在转入处理程序之前，还要把出错码压入堆栈。只有异常处理才可能有出错码。
图10.21给出了通过中断门或陷阱门转移时的堆栈情况。
（a）是没有变换特权级和没有出错码的情形；
PUSH EFLAG
PUSH CS
PUSH EIP
（b）是没有变换特权级和有出错码的情形；
PUSH EFLAG
PUSH CS
PUSH EIP
PUSH 出错码
（c）是变换特权级和没有出错码的内层堆栈情形；
PUSH 外层SS
PUSH 外层ESP
PUSH EFLAG
PUSH CS
PUSH EIP
（d）是变换特权级和有出错码的内层堆栈情形。
PUSH 外层SS
PUSH 外层ESP
PUSH EFLAG
PUSH CS
PUSH EIP
PUSH 出错码
注意，图中每一项为双字。
4.通过任务门的转移
如果中断向量号所指示的门描述符是任务门描述符，那么控制转移到一个作为独立的任务方式出现的处理程序。
如图10.13所示，任务门中含48位全指针。这时，16位选择子是指向描述对应处理程序任务的TSS段的选择子，
也即该选择子指示一个可用的286TSS或386TSS。通过任务门的转移与通过任务门到一个可用的386TSS的CALL指令的转移很相似，
主要的区别是，对于提供出错码的异常处理，在完成任务切换之后，把出错码压入新任务的堆栈中。
通过任务门的转移，在进入中断或异常处理程序时，标志寄存器EFLAGS中的NT位被置1，表示是嵌套任务。
在响应中断或处理异常时，使用任务门可提供一个处理程序任务的自动调度。
这种任务调度由硬件直接执行，并且越过包含在操作系统中的软件任务切换，这就为处理程序提供了一个快速的任务切换。
5.转移方法的比较
对中断的响应和异常的处理，80386允许通过使用中断门或陷阱门实现由当前任务之内的一个过程进行处理；
也允许通过使用任务门实现由另外一个任务进行处理。在当前任务内的处理程序较为简单，并可以很快转移到处理程序，
但处理程序要负责保存及恢复处理器的寄存器等内容。转到不同任务的处理程序要花费较长时间，
保存及恢复处理器寄存器内容的开销作为任务切换的一部分。使用当前任务内的处理程序的方法，在响应中断或处理异常时，
对正执行任务的状态可直接进行访问，但是，这样就要求每一个任务之内都包含一个处理程序。
使用独立任务的处理方法，使处理程序得到较好的隔离，但在响应中断或处理异常时，对原任务状态的访问变得较为复杂。
无效TSS异常必须使用任务门进行处理，以保证处理程序有一个有效的任务环境。
其他的异常通常在任务环境之内进行处理。在任务内，异常被检测并且不必屏蔽中断，所以使用陷阱门。
由陷阱门指示的异常处理程序，是一个由所有任务共享的过程，所以该处理程序最好置于全局地址空间之内。
如果各个任务要求有不同的处理程序，那么全局异常处理程序可保存一个各处理程序的入口表，并为引起异常的任务调用相应的处理程序。
中断通常与正执行的任务没有关系，并可能从使用任务门提供的隔离中获得好处。要求较快响应的中断，通过中断门可以得到较好的处理。
因为中断随时都可能发生，所以，通过中断门访问的中断处理程序，必须置于全局地址空间中，以便对所有的任务都有效。
6.中断或异常处理后的返回
中断返回指令IRET用于从中断或异常处理程序的返回。该指令的执行根据任务嵌套标志NT是否为1，分两种情形。
NT为1，表示是嵌套任务的返回。当前TSS中的链接字段保存有前一任务的TSS的选择子，取出该选择子，进行任务切换就完成了返回。
这种情形在由通过任务门转入的中断或异常处理程序返回时出现，因为在由中断门或陷阱门转入处理程序时，NT位已被清0。
NT为0，表示当前任务内的返回。这种情形在由通过中断门或陷阱门转入的中断或异常处理程序返回时出现。
具体进行的操作包括：从堆栈顶弹出返回指针EIP及CS，然后弹出EFLAG值。弹出的CS选择子的RPL字段，确定返回后的特权级。
如果返回选择子的RPL与CPL相同，则不进行特权级的改变。
若RPL规定了一个外层特权级，则需要特权级改变，从内层堆栈中弹出外层堆栈的ESP及SS的值，参见图10.21。这些做法与RET指令的实现相似。
例如，使用返回CS选择子的RPL，而不是由选择子标识的段的DPL，是为了返回到不在DPL给定的级执行的一致代码段。
对于提供出错代码的异常的处理程序，必须先从堆栈中弹出出错代码，然后再执行IRET指令。
中断返回指令IRET不仅能够用于由中断/异常引起的嵌套任务的返回，而且也适用于由段间调用指令CALL通过任务门引起的嵌套任务的返回。
如10.6.5节所述，在执行通过任务门进行任务切换的CALL指令时，标志寄存器中的NT被置1，表示任务嵌套。
表10.7异常一览表
向量号         异常名称         异常类型         出错代码         相关指令
0              除法出错             故障               无                   DIV,IDIV
1              调试异常           故障/陷阱        无                    任何指令
3            单字节INT3         陷阱                无                    INT 3
4            溢出                    陷阱                无                    INTO
5            边界检查             故障                无                    BOUND
6          非法操作码            故障                无                   非法指令编码或操作数
7          设备不可用            故障                无                   浮点指令或WAIT
8          双重故障               中止                有                    任何指令
9         协处理器段越界      中止                无                    访问存储器的浮点指令
0A       无效TSS异常          故障                有                    JMP、CALL、IRET、中断
0B       段不存在异常         故障                 有                   装载段寄存器的任何指令
0C       堆栈段异常            故障                 有                   装载SS寄存器的任何指令 对SS寻址的段访问的任何指令
0D      通用保护异常         故障                 有                   任何特权指令 任何访问存储器的指令
0E      页异常                   故障                 有                   任何访问存储器的指令
10      协处理器出错          故障                无                    浮点指令或WAIT
00~FF 软中断                   陷阱                无                    INT n
表5.2部分中断向量的分配
向量号                  使用                  向量号                  使用
0                       除法出错               4                          溢出
1                       单步                      5                       打印屏幕
2                       非屏蔽中断            6                          保留
3                       断点                      7                          保留
8                       定时器                  0C                     串行通信接口1
9                       键盘                     0D                     硬盘（并行口）
0A              保留（从中断控制器） 0E                         软盘
0B                  串行通信接口2         0F                        打印机
10              视频显示                      17                      打印输出
11              设备配置                      18                   ROM BASIC
12              存储容量                      19                     系统自举
13              磁盘I/O                        1A                     时钟管理
14              串行I/O                        1B                Ctrl+ Break键处理
15            扩充的BIOS                    1C                      定时处理
16              键盘输入                   1D--1F                  参数指针
20--2F       DOS使用                   30--3F                 为DOS保留
从普通汇编语言程序设计者的角度看，中断控制器8259A包含两个寄存器：中断屏蔽寄存器和中断命令寄存器。
中断屏蔽寄存器的I/O端口地址是21H，它的8位对应控制8个外部设备，通过设置这个寄存器的某位为0或为1来允许或禁止相应外部设备中断。
当第i位为0时，表示允许传出来自IRQi的中断请求信号，当第i位为1时，表示禁止传出来自IRQi的中断请求信号。
中断屏蔽寄存器的内容称为中断屏蔽字。在PC系列及其兼容机上，中断屏蔽寄存器各位与对应外设的关系如图5.9所示。
中断命令寄存器的I/O端口地址是20H，其各位的定义如图5.10所示。
7   6   5   4   3   2   1   0
         EOI
中断命令寄存器中EOI位是中断结束位，当把它置为1时，表示当前中断处理结束。
下面程序片段通知8259A当前中断结束：
MOV AL,20H
OUT 20H,AL
注意，通知中断控制器8259A当前中断结束，并非中断返回。只有在执行了中断返回指令后，才返回被中断程序。
10.7.4演示中断处理的实例（实例六）
下面给出一个用于演示中断处理的实例。
该实例的逻辑功能是，在屏幕的左上角以倒计时方式显示秒为单位的时间，在时间用完后结束。
该实例演示内容包括：外部中断处理程序，陷阱处理程序。
1.源程序组织和清单
本实例有如下几部分组成：
（1）全局描述符表GDT。
GDT中除了含有常见的几个描述符外，含有描述时钟中断处理程序所使用的代码段和数据段，还含有描述显示程序所使用的代码段和数据段。
（2）中断描述符表IDT。
为了在保护方式下响应中断和处理异常，必须有IDT。IDT含有256个门描述符。08H号安排的是一个通向时钟中断处理程序的中断门，
0FEH号安排的是通向显示处理程序的陷阱门，其他均安排成通向其他中断或异常处理程序的陷阱门。
（3）时钟中断处理程序的代码段和数据段。
（4）实现直接填显示缓冲区进行显示的显示程序的代码段和数据段。
（5）处理其他中断或异常的处理程序的代码段。
（6）演示程序的代码段、数据段和堆栈段等。
（7）实方式下执行的启动和结束程序代码段和数据段。
源程序清单如下：
：程序名：T10-6.ASM
；功能：演示中断处理的实现
DESCRIPTOR STRUC
LIMITL DW 0
BASEL DW 0
BASEM DB 0
ATTRIBUTES DW 0
BASEH DB 0
DESCRIPTOR ENDS
GATE STRUC
OFFSETL DW 0
SELECTOR DW 0
DCOUNT DB 0
GTYPE DB 0
OFFSETH DW 0
GATE ENDS
PDESC STRUC
LIMIT DW 0
BASE DD 0
PDESC ENDS
TASKSS STRUC
TRLINK DW ?,0
TRESP0 DD ?
TRSS0 DW ?,0
TRESP1 DD ?
TRSS1 DW ?,0
TRESP2 DD ?
TRSS2 DW ?,0
TRCR3 DD ?
TREIP DD ?
TREFLAG DW ?,?
TREAX DD ?
TRECX DD ?
TREDX DD ?
TREBX DD ?
TRESP DD ?
TREBP DD ?
TRESI DD ?
TREDI DD ?
TRES DW ?,0
TRCS DW ?,0
TRSS DW ?,0
TRDS DW ?,0
TRFS DW ?,0
TRGS DW ?,0
TRLDT DW ?,0
TRFLAG DW 0
TRIOMAP DW $ + 2
TASKSS ENDS
ATDR = 90H
ATDW = 92H
ATDWA = 93H
ATCE = 98H
ATCER = 9AH
ATCCO = 9CH
ATCCOR = 9EH
ATLDT = 82H
ATTASKGAT = 85H
AT386TSS = 89H
AT386CGAT = 8CH
AT386IGAT = 8EH
AT386TGAT = 8FH
DPL1 = 20H
DPL2 = 40H
DPL3 = 60H
RPL1 = 01H
RPL2 = 02H
RPL3 = 03H
IOPL1 = 1000H
IOPL2 = 2000H
IOPL3 = 3000H
D32 = 4000H
TIL = 04H
VMFL = 0002H
IFL = 0200H
JUMP32 MACRO selector,offsetv
DB 0EAH
DW offsetv
DW 0
DW selector
ENDM
CALL32 MACRO selector,offsetv
DB 9AH
DW offsetv
DW 0
DW selector
ENDM
JUMP16 MACRO selector,offsetv
DB 0EAH
DW offsetv
DW selector
ENDM
CALL16 MACRO selector,offsetv
DB 9AH
DW offsetv
DW selector
ENDM
.386P
EOICOM = 20H
ICREGP = 20H
IMREGP = 21H
GDTSEG SEGMENT PARA USE16
GDT LABEL BYTE
DUMMY DESCRIPTOR <>
NORMAL DESCRIPTOR <0FFFFH,0,0,ATDW,0>
NORMAL_SEL = NORMAL - GDT
EFFGDT LABEL BYTE
EFFGDTOFF = $ - GDT
TEMPCODE DESCRIPTOR <0FFFFH,TEMPCODESEG,,ATCE,>
TEMPCODE_SEL = TEMPCODE - GDT
DEMOCODE DESCRIPTOR <DEMOCODELEN - 1,DEMOCODESEG,,ATCE,>
DEMOCODE_SEL = DEMOCODE - GDT
DEMODATA DESCRIPTOR <DEMODATALEN - 1,DEMODATASEG,,ATDW,>
DEMODATA_SEL = DEMODATA - GDT
DEMOSTACK DESCRIPTOR <DEMOSTACKLEN - 1,DEMOSTACKSEG,,ATDWA,>
DEMOSTACK_SEL = DEMOSTACK - GDT
ECHOCODE DESCRIPTOR <ECHOCODELEN - 1,ECHOCODESEG,,ATCE,>
ECHOCODE_SEL = ECHOCODE - GDT
ECHODATA DESCRIPTOR <ECHODATALEN - 1,ECHODATASEG,,ATDW,>
ECHODATA_SEL = ECHODATA - GDT
VIDEOBUFF DESCRIPTOR <4000 - 1,0B800H,,ATDW,>
VIDEOBUFF_SEL = VIDEOBUFF - GDT
TICODE DESCRIPTOR <TICODELEN - 1,TICODESEG,,ATCE,>
TICODE_SEL = TICODE - GDT
TIDATA DESCRIPTOR <TIDATALEN - 1,TIDATASEG,,ATDW,>
TIDATA_SEL = TIDATA - GDT
OTHERCODE DESCRIPTOR <OTHERCODELEN - 1,OTHERCODESEG,,ATCE,>
OTHERCODE_SEL = OTHERCODE - GDT
GDNUM = ($ - EFFGDT) / 8
GDTLEN = $ - GDT
GDTSEG ENDS
IDTSEG SEGMENT PARA USE16
IDT LABEL BYTE
REPT 8
GATE <OTHERBEGINOFF,OTHERCODE_SEL,0,AT386TGAT,0>
ENDM
INT08 GATE <TIBEGINOFF,TICODE_SEL,0,AT386IGAT,0>
REPT 254 - 9
GATE <OTHERBEGINOFF,OTHERCODE_SEL,0,AT386TGAT,0>
ENDM
INTFE GATE <ECHOBEGINOFF,ECHOCODE_SEL,0,AT386TGAT,0>
GATE <OTHERBEGINOFF,OTHERCODE_SEL,0,AT386TGAT,0>
IDTLEN = $ - IDT
IDTSEG ENDS
OTHERCODESEG SEGMENT PARA USE16
ASSUME CS:OTHERCODESEG
EFFOTHERC LABEL BYTE
OTHERBEGINOFF = $ - EFFOTHERC
OTHERBEGIN:MOV AX,VIDEOBUFF_SEL
MOV ES,AX
MOV AH,17H
MOV AL,'!'
MOV ES:[0],AX
JMP $
OTHERCODELEN = $ - EFFOTHERC
OTHERCODESEG ENDS
TIDATASEG SEGMENT PARA USE16
EFFTID LABEL BYTE
COUNT DB 0
TIDATALEN = $ - EFFTID
TIDATASEG ENDS
TICODESEG SEGMENT PARA USE16
ASSUME CS:TICODESEG,DS:TIDATASEG
EFFTIC LABEL BYTE
TIBEGINOFF = $ - EFFTIC
TIBEGIN:PUSH EAX
PUSH DS
PUSH FS
PUSH GS
MOV AX,TIDATA_SEL
MOV DS,AX
MOV AX,ECHODATA_SEL
MOV FS,AX
MOV AX,DEMODATA_SEL
MOV GS,AX
CMP COUNT,0
JNZ TI2
MOV COUNT,18
INT 0FEH
CMP BYTE PTR FS:MESS,'0'
JNZ TI1
MOV BYTE PTR GS:FLAG,1
JMP TI3
TI1:DEC BYTE PTR FS:MESS
JMP TI3
TI2:DEC COUNT
TI3:POP GS
POP FS
POP DS
MOV AL,EOICOM
OUT ICREGP,AL
POP EAX
IRETD
TICODELEN = $ - EFFTIC
TICODESEG ENDS
ECHODATASEG SEGMENT PARA USE16
EFFECHOD LABEL BYTE
MESS DB '8',07H
ECHODATALEN = $ - EFFECHOD
ECHODATASEG ENDS
ECHOCODESEG SEGMENT PARA USE16
ASSUME CS:ECHOCODESEG,DS:ECHODATASEG
EFFECHOC LABEL BYTE
ECHOBEGINOFF = $ - EFFECHOC
ECHOBEGIN:PUSH AX
PUSH DS
PUSH ES
MOV AX,ECHODATA_SEL
MOV DS,AX
MOV AX,VIDEOBUFF_SEL
MOV ES,AX
MOV AX,WORD PTR MESS
MOV ES:[0],AX
POP ES
POP DS
POP AX
IRETD
ECHOCODELEN = $ - EFFECHOC
ECHOCODESEG ENDS
DEMOSTACKSEG SEGMENT PARA USE16
DEMOSTACKLEN = 1024
DB DEMOSTACKLEN DUP (0)
DEMOSTACKSEG ENDS
DEMODATASEG SEGMENT PARA USE16
EFFDEMOD LABEL BYTE
FLAG DB 0
DEMODATALEN = $ - EFFDEMOD
DEMODATASEG ENDS
DEMOCODESEG SEGMENT PARA USE16
ASSUME CS:DEMOCODESEG,DS:DEMODATASEG
EFFDEMOC LABEL BYTE
DEMOBEGINOFF = $ - EFFDEMOC
DEMOBEGIN:MOV AX,DEMOSTACK_SEL
MOV SS,AX
MOV SP,DEMOSTACKLEN
MOV AX,DEMODATA_SEL
MOV DS,AX
MOV ES,AX
MOV FS,AX
MOV GS,AX
MOV AL,11111110B
OUT IMREGP,AL
STI
DEMOCONTI:CMP FLAG,0
JZ DEMOCONTI
CLI
OVER:JUMP16 TEMPCODE_SEL,TODOSOFF
DEMOCODELEN = $ - EFFDEMOC
DEMOCODESEG ENDS
TEMPCODESEG SEGMENT PARA USE16
ASSUME CS:TEMPCODESEG
EFFTEMPC LABEL BYTE
VIRTUALOFF = $ - EFFTEMPC
VIRTUAL:JUMP16 DEMOCODE_SEL,DEMOBEGINOFF
TODOSOFF = $ - EFFTEMPC
TODOS:MOV AX,NORMAL_SEL
MOV DS,AX
MOV ES,AX
MOV FS,AX
MOV GS,AX
MOV SS,AX
MOV EAX,CR0
AND EAX,0FFFFFFFEH
MOV CR0,EAX
JUMP16 <SEG REAL>,<OFFSET REAL>
TEMPCODELEN = $ - EFFTEMPC
TEMPCODESEG ENDS
RDATASEG SEGMENT PARA USE16
VGDTR PDESC <GDTLEN - 1,>
VIDTR PDESC <IDTLEN - 1,>
NORVIDTR PDESC <3FFH,0>
SPVAR DW ?
SSVAR DW ?
IMASKREGV DB ?
RDATASEG ENDS
RCODESEG SEGMENT PARA USE16
ASSUME CS:RCODESEG,DS:RDATASEG
START:MOV AX,RDATASEG
MOV DS,AX
CLD
CALL INIT_GDT
CALL INIT_IDT
MOV WORD PTR SSVAR,SS
MOV WORD PTR SPVAR,SP
SIDT NORVIDTR
IN AL,IMREGP
MOV IMASKREGV,AL
LGDT QWORD PTR VGDTR
CLI
LIDT QWORD PTR VIDTR
MOV EAX,CR0
OR EAX,1
MOV CR0,EAX
JUMP16 TEMPCODE_SEL,VIRTUALOFF
REAL:MOV AX,RDATASEG
MOV DS,AX
LSS SP,DWORD PTR SPVAR
LIDT NORVIDTR
MOV AL,IMASKREGV
OUT IMREGP,AL
STI
MOV AX,4C00H
INT 21H
INIT_GDT PROC NEAR
PUSH DS
MOV AX,GDTSEG
MOV DS,AX
MOV CX,GDNUM
MOV SI,EFFGDTOFF
INITG:MOV AX,[SI].BASEL
MOVZX EAX,AX
SHL EAX,4
SHLD EDX,EAX,16
MOV [SI].BASEL,AX
MOV [SI].BASEM,DL
MOV [SI].BASEH,DH
ADD SI,8
LOOP INITG
POP DS
MOV BX,16
MOV AX,GDTSEG
MUL BX
MOV WORD PTR VGDTR.BASE,AX
MOV WORD PTR VGDTR.BASE+2,DX
RET
INIT_GDT ENDP
INIT_IDT PROC NEAR
MOV BX,16
MOV AX,IDTSEG
MUL BX
MOV WORD PTR VIDTR.BASE,AX
MOV WORD PTR VIDTR.BASE+2,DX
RET
INIT_IDT ENDP
RCODESEG ENDS
END START
在XP下使用tasm t460.asm编译，tlink /3 t460.obj链接
在DOS下运行t460.exe，在左上角黑底白字依次显示8 7 6 5 4 3 2 1 0，每次1秒，显示0之后，返回DOS
2.关于实例六的说明
下面再对上述演示程序作些说明：
（1）时钟中断仍使用08H号中断向量
为了既简单又清楚地演示在保护方式下响应外部中断并进行处理，实例使用了时钟中断源，
但没有通过重新设置中断控制器的方法改变对应的中断向量。所以，时钟中断使用的08H号中断向量号就与双重故障异常使用的中断向量号发生冲突。
但实例仅是演示程序，所以只要保证不发生双重故障异常，就可避免冲突，就不会影响演示。
设置中断屏蔽寄存器，仅开放时钟中断。所以，在开中断状态下，也只可能发生时钟中断，而不会发生其他外部中断。
（2）时钟中断处理程序的设计
由于通过中断门转时钟中断处理程序，所以在控制转移时不发生任务切换。但作为外部中断，随时可能发生，
因此中断处理程序必须采取保护现场等措施。作为演示程序，该中断处理程序检查和调整在其数据段中的计数器；
在满18次后，就认为已满一秒，再调整用于显示的倒计数信息；如果倒计数信息为0，那么就设置演示程序数据段中的时间为0标志。
该中断处理程序通过约定的数据区与显示程序及演示程序交换信息。
（3）利用一个“软中断”（陷阱处理）程序实现显示
为了演示陷阱及其处理，把显示过程安排成陷阱处理程序，简称为显示程序。上述时钟中断处理程序，通过软中断指令INT调用该显示程序，
显示倒计时数。在控制转移时，也没有任务切换。该陷阱处理程序相当于一个“软中断”处理程序。
（4）对其他中断或异常的响应
为了简单，除了08H号和0FEH号外，IDT中其他的门均通向同一个处理程序。该处理程序用于处理其他中断或异常。
处理过程也极其简单，在屏幕左上角显示蓝底白色的符号"!"，然后进入无限循环。实际上，按演示程序现在的安排，不可能发生这种情况。
（5）没有特权级变换
为了简单，实例涉及的中断处理程序和异常处理程序都保持特权级0。所以，控制转移时不发生特权级变换。因此，没有使用其他堆栈。
（6）对IDT的初始化
由于IDT中门描述符没有32位段基地址，并且入口点偏移较小，所以就直接填门描述符结构变量，没有额外再初始化。
过程INIT_IDT只是设置IDT伪描述符。
（7）装载和保存IDTR寄存器
在使IDT发挥作用之前，还要装载中断描述符表寄存器IDTR；但为了回到实方式后，恢复原IDTR之内容，所以先保存IDTR的内容。
实例使用如下指令保存IDTR：
SIDT NORVIDTR
该指令的功能是把IDTR的内容保存到存储器中的伪描述符NORVIDTR。伪描述符NORVIDTR的结构如前述结构类型PDESC所示，
低字是以字节为单位的界限，高双字是基地址。在10.8节中对SIDT指令作详细说明。
本实例使用如下指令装载IDTR：
LIDT QWORD PTR VIDTR
LIDT QWORD PTR NORVIDTR
LIDT指令类似于LGDT指令，在10.8节中对LIDT指令再作详细说明。
10.7.5演示异常处理的实例（实例七）
下面给出一个用于模拟异常和演示异常处理的实例。
该实例的逻辑功能是，在屏幕上显示一条提示用户击键方式选择模拟异常类型的字符，然后模拟指定的异常。
该实例演示内容包括：除法出错故障处理、溢出陷阱处理、段不存在故障处理、堆栈段出错故障处理和通用保护故障处理；
还有作为一个独立任务方式出现的陷阱处理程序。
0              除法出错             故障               无                   DIV,IDIV
4            溢出                    陷阱                无                    INTO
0B       段不存在异常         故障                 有                   装载段寄存器的任何指令
0C       堆栈段异常            故障                 有                   装载SS寄存器的任何指令 对SS寻址的段访问的任何指令
0D      通用保护异常         故障                 有                   任何特权指令 任何访问存储器的指令
1.源程序组织和清单
为了演示以独立任务方式出现的陷阱处理程序，实例含有两个任务：演示任务和读键盘任务。实例有如下几部分组成：
（1）全局描述符表GDT和中断描述符表IDT；
（2）读键盘任务局部描述符表、任务状态段、堆栈段和代码段等；
（3）演示任务的局部描述符表、任务状态段、堆栈段、代码段和数据段等；
（4）作为演示任务一部分的有关陷阱处理和故障处理程序的代码段；
（5）作为演示任务一部分的显示出错码过程代码段；
（6）实方式下执行的启动和结束程序代码段和数据段。
在切换到保护方式后，就进入临时代码段。为了简单，演示不发生特权级的变换。演示步骤如下：
（1）从临时代码段转移到演示代码段。
（2）做演示准备。把演示任务的LDT选择子装入LDTR，并填入TSS，装载任务寄存器TR，建立演示任务堆栈，设置其他数据段寄存器。
（3）接收要模拟的异常类型号。通过软中断指令INT调用读键盘任务完成该步骤。
读键盘任务只有在接收到指定的字符后才结束。接收的字符是0、4、B、C和D。
（4）按接收的字符模拟异常。也即根据键入的字符，执行有关片段。在这些片段中，有意安排了能引起有关故障或陷阱的指令。
（5）结束演示，转临时代码段，返回DOS。
源程序清单如下：
；程序名：T10-7.ASM
；功能：模拟异常和演示异常处理
DESCRIPTOR STRUC
LIMITL DW 0
BASEL DW 0
BASEM DB 0
ATTRIBUTES DW 0
BASEH DB 0
DESCRIPTOR ENDS
GATE STRUC
OFFSETL DW 0
SELECTOR DW 0
DCOUNT DB 0
GTYPE DB 0
OFFSETH DW 0
GATE ENDS
PDESC STRUC
LIMIT DW 0
BASE DD 0
PDESC ENDS
TASKSS STRUC
TRLINK DW ?,0
TRESP0 DD ?
TRSS0 DW ?,0
TRESP1 DD ?
TRSS1 DW ?,0
TRESP2 DD ?
TRSS2 DW ?,0
TRCR3 DD ?
TREIP DD ?
TREFLAG DW ?,?
TREAX DD ?
TRECX DD ?
TREDX DD ?
TREBX DD ?
TRESP DD ?
TREBP DD ?
TRESI DD ?
TREDI DD ?
TRES DW ?,0
TRCS DW ?,0
TRSS DW ?,0
TRDS DW ?,0
TRFS DW ?,0
TRGS DW ?,0
TRLDT DW ?,0
TRFLAG DW 0
TRIOMAP DW $ + 2
TASKSS ENDS
ATDR = 90H
ATDW = 92H
ATDWA = 93H
ATCE = 98H
ATCER = 9AH
ATCCO = 9CH
ATCCOR = 9EH
ATLDT = 82H
ATTASKGAT = 85H
AT386TSS = 89H
AT386CGAT = 8CH
AT386IGAT = 8EH
AT386TGAT = 8FH
DPL1 = 20H
DPL2 = 40H
DPL3 = 60H
RPL1 = 01H
RPL2 = 02H
RPL3 = 03H
IOPL1 = 1000H
IOPL2 = 2000H
IOPL3 = 3000H
D32 = 4000H
TIL = 04H
VMFL = 0002H
IFL = 0200H
JUMP32 MACRO selector,offsetv
DB 0EAH
DW offsetv
DW 0
DW selector
ENDM
CALL32 MACRO selector,offsetv
DB 9AH
DW offsetv
DW 0
DW selector
ENDM
JUMP16 MACRO selector,offsetv
DB 0EAH
DW offsetv
DW selector
ENDM
CALL16 MACRO selector,offsetv
DB 9AH
DW offsetv
DW selector
ENDM
.386P
GDTSEG SEGMENT PARA USE16
GDT LABEL BYTE
DUMMY DESCRIPTOR <>
NORMAL DESCRIPTOR <0FFFFH,0,0,ATDW,0>
NORMAL_SEL = NORMAL - GDT
EFFGDT LABEL BYTE
EFFGDTOFF = $ - GDT
TEMPCODE DESCRIPTOR <0FFFFH,TEMPCODESEG,,ATCE,>
TEMPCODE_SEL = TEMPCODE - GDT
DEMOCODE DESCRIPTOR <DEMOCODELEN - 1,DEMOCODESEG,,ATCE,>
DEMOCODE_SEL = DEMOCODE - GDT
DEMOLDTABLE DESCRIPTOR <DEMOLDTLEN - 1,DEMOLDTSEG,,ATLDT,>
DEMOLDT_SEL = DEMOLDTABLE - GDT
DEMOTSS DESCRIPTOR <DEMOTSSLEN - 1,DEMOTSSSEG,,AT386TSS,>
DEMOTSS_SEL = DEMOTSS - GDT
XBUFFER DESCRIPTOR <BUFFERLEN - 1,BUFFERSEG,,ATDW,>
XBUFFER_SEL = XBUFFER - GDT
GKEYLDT DESCRIPTOR <GKEYLDTLEN - 1,GKEYLDTSEG,,ATLDT,>
GKEYLDT_SEL = GKEYLDT - GDT
GKEYTSS DESCRIPTOR <GKEYTSSLEN - 1,GKEYTSSSEG,,AT386TSS,>
GKEYTSS_SEL = GKEYTSS - GDT
VIDEOBUFF DESCRIPTOR <4000 - 1,0B800H,,ATDW,>
VIDEOBUFF_SEL = VIDEOBUFF - GDT
ECHOCODE DESCRIPTOR <ECHOCODELEN - 1,ECHOCODESEG,,ATCE,>
ECHOCODE_SEL = ECHOCODE - GDT
SUBCODE DESCRIPTOR <SUBCODELEN - 1,SUBCODESEG,,ATCE,>
SUBCODE_SEL = SUBCODE - GDT
OTHERCODE DESCRIPTOR <OTHERCODELEN - 1,OTHERCODESEG,,ATCE,>
OTHERCODE_SEL = OTHERCODE - GDT
GDNUM = ($ - EFFGDT) / 8
GDTLEN = $ - GDT
GDTSEG ENDS
IDTSEG SEGMENT PARA USE16
IDT LABEL BYTE
INT00 GATE <DIVBEGINOFF,DIVCODE_SEL,0,AT386TGAT,0>
REPT 3
GATE <OTHERBEGINOFF,OTHERCODE_SEL,0,AT386TGAT,0>
ENDM
INT04 GATE <OFBEGINOFF,OFCODE_SEL,0,AT386TGAT,0>
REPT 6
GATE <OTHERBEGINOFF,OTHERCODE_SEL,0,AT386TGAT,0>
ENDM
INT0B GATE <SNPBEGINOFF,SNPCODE_SEL,0,AT386TGAT,0>
INT0C GATE <SSEBEGINOFF,SSECODE_SEL,0,AT386TGAT,0>
INT0D GATE <GPBEGINOFF,GPCODE_SEL,0,AT386TGAT,0>
REPT 254 - 14
GATE <OTHERBEGINOFF,OTHERCODE_SEL,0,AT386TGAT,0>
ENDM
INTFE GATE <ECHOBEGINOFF,ECHOCODE_SEL,0,AT386TGAT,0>
INTFF GATE <0,GKEYTSS_SEL,0,ATTASKGAT,0>
IDTLEN = $ - IDT
IDTSEG ENDS
GKEYLDTSEG SEGMENT PARA USE16
GLDT LABEL BYTE
GKEYCODE DESCRIPTOR <0FFFFH,GKEYCODESEG,,ATCE,>
GKEYCODE_SEL = (GKEYCODE - GLDT) + TIL
GKEYSTACK DESCRIPTOR <GKEYSTACKLEN - 1,GKEYSTACKSEG,,ATDWA,>
GKEYSTACK_SEL = (GKEYSTACK - GLDT) + TIL
GKEYLDNUM = ($ - GLDT) / 8
GKEYLDTLEN = $ - GLDT
GKEYLDTSEG ENDS
GKEYTSSSEG SEGMENT PARA USE16
EFFGKTSS LABEL BYTE
DW 0,0
DW ?,0
DW ?,0
DW ?,0
DW ?,0
DD ?
DW ?,0
DD 0
DD GKEYBEGINOFF
DD ?
DD ?
DD ?
DD ?
DD ?
DD GKEYSTACKLEN
DD ?
DD ?
DD ?
DW NORMAL_SEL,0
DW GKEYCODE_SEL,0
DW GKEYSTACK_SEL,0
DW NORMAL_SEL,0
DW NORMAL_SEL,0
DW NORMAL_SEL,0
DW GKEYLDT_SEL,0
DW 0
DW $ + 2
DB 0FFH
GKEYTSSLEN = $ - EFFGKTSS
GKEYTSSSEG ENDS
GKEYSTACKSEG SEGMENT PARA USE16
GKEYSTACKLEN = 1024
DB GKEYSTACKLEN DUP (0)
GKEYSTACKSEG ENDS
GKEYCODESEG SEGMENT PARA USE16
ASSUME CS:GKEYCODESEG,DS:RDATASEG,ES:BUFFERSEG
EFFGKC LABEL BYTE
GKEYBEGINOFF = $ - EFFGKC
GKEYBEGIN:PUSH DS
PUSH ES
PUSH FS
PUSH GS
MOV AX,NORMAL_SEL
MOV SS,AX
MOV EAX,CR0
AND EAX,0FFFFFFFEH
MOV CR0,EAX
JUMP16 <SEG GETKEY>,<OFFSET GETKEY>
GETKEY:MOV AX,RDATASEG
MOV DS,AX
MOV EBP,ESP
LSS SP,DWORD PTR SPVAR
LIDT NORVIDTR
STI
MOV DX,OFFSET MESS
MOV AH,9
INT 21H
GETKEY1:MOV AH,0
INT 16H
CMP AL,'0'
JZ GETKEY2
CMP AL,'4'
JZ GETKEY2
AND AL,11011111B
CMP AL,'B'
JB GETKEY1
CMP AL,'D'
JA GETKEY1
GETKEY2:MOV DL,AL
MOV AH,2
INT 21H
MOV AX,BUFFERSEG
MOV ES,AX
MOV ES:KEYASCII,DL
CLI
LIDT QWORD PTR VIDTR
MOV EAX,CR0
OR EAX,1
MOV CR0,EAX
JUMP16 <GKEYCODE_SEL>,<OFFSET GETKEYV>
GETKEYV:MOV AX,GKEYSTACK_SEL
MOV SS,AX
MOV ESP,EBP
POP GS
POP FS
POP ES
POP DS
IRETD
JMP GKEYBEGIN
GKEYCODELEN = $ - EFFGKC
GKEYCODESEG ENDS
OTHERCODESEG SEGMENT PARA USE16
ASSUME CS:OTHERCODESEG
EFFOTHERC LABEL BYTE
OTHERBEGINOFF = $ - EFFOTHERC
OTHERBEGIN:MOV SI,OFFSET MESSOTHER
MOV DI,0
INT 0FEH
JMP $
OTHERCODELEN = $ - EFFOTHERC
OTHERCODESEG ENDS
DIVCODESEG SEGMENT PARA USE16
ASSUME CS:DIVCODESEG
EFFDIVC LABEL BYTE
DIVBEGINOFF = $ - EFFDIVC
DIVBEGIN:MOV SI,OFFSET MESS0
MOV DI,0
INT 0FEH
SHR AX,1
IRETD
DIVCODELEN = $ - EFFDIVC
DIVCODESEG ENDS
OFCODESEG SEGMENT PARA USE16
ASSUME CS:OFCODESEG
EFFOFC LABEL BYTE
OFBEGINOFF = $ - EFFOFC
OFBEGIN:MOV SI,OFFSET MESS4
MOV DI,0
INT 0FEH
IRETD
OFCODELEN = $ - EFFOFC
OFCODESEG ENDS
SNPCODESEG SEGMENT PARA USE16
ASSUME CS:SNPCODESEG
EFFSNPC LABEL BYTE
SNPBEGINOFF = $ - EFFSNPC
SNPBEGIN:MOV SI,OFFSET MESSB
MOV DI,0
INT 0FEH
POP EAX
CALL16 SUBCODE_SEL,SUBBEGINOFF
POP EAX
ADD EAX,2
PUSH EAX
IRETD
SNPCODELEN = $ - EFFSNPC
SNPCODESEG ENDS
SSECODESEG SEGMENT PARA USE16
ASSUME CS:SSECODESEG
EFFSSEC LABEL BYTE
SSEBEGINOFF = $ - EFFSSEC
SSEBEGIN:MOV SI,OFFSET MESSC
MOV DI,0
INT 0FEH
POP EAX
CALL16 SUBCODE_SEL,SUBBEGINOFF
POP EAX
ADD EAX,4
PUSH EAX
IRETD
SSECODELEN = $ - EFFSSEC
SSECODESEG ENDS
GPCODESEG SEGMENT PARA USE16
ASSUME CS:GPCODESEG
EFFGPC LABEL BYTE
GPBEGINOFF = $ - EFFGPC
GPBEGIN:PUSH EBP
MOV EBP,ESP
PUSH EAX
PUSH ESI
PUSH EDI
MOV SI,OFFSET MESSD
MOV DI,0
INT 0FEH
MOV EAX,[BP+4]
CALL16 SUBCODE_SEL,SUBBEGINOFF
POP EDI
POP ESI
POP EAX
ADD DWORD PTR [EBP+8],2
POP EBP
ADD SP,4
IRETD
GPCODELEN = $ - EFFGPC
GPCODESEG ENDS
SUBCODESEG SEGMENT PARA USE16
ASSUME CS:SUBCODESEG
EFFSUBC LABEL BYTE
SUBBEGINOFF = $ - EFFSUBC
SUBBEGIN:PUSH AX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV SI,OFFSET ERRCODE
MOV DX,AX
MOV CX,4
SUBR1:ROL DX,4
MOV AL,DL
AND AL,0FH
ADD AL,30H
CMP AL,'9'
JBE SUBR2
ADD AL,7
SUBR2:MOV [SI],AL
INC SI
LOOP SUBR1
MOV SI,OFFSET ERRMESS
MOV DI,80 * 2
INT 0FEH
POP DI
POP SI
POP DX
POP CX
POP AX
RETF
SUBCODELEN = $ - EFFSUBC
SUBCODESEG ENDS
ECHOCODESEG SEGMENT PARA USE16
ASSUME CS:ECHOCODESEG
EFFECHOC LABEL BYTE
ECHOBEGINOFF = $ - EFFECHOC
ECHOBEGIN:PUSHAD
CLD
MOV AH,7
MOV AL,20H
MOV CX,80
PUSH DI
REP STOSW
POP DI
ECHO1:LODSB
OR AL,AL
JZ ECHO2
STOSW
JMP ECHO1
ECHO2:POPAD
IRETD
ECHOCODELEN = $ - EFFECHOC
ECHOCODESEG ENDS
BUFFERSEG SEGMENT PARA USE16
EFFBUFFER LABEL BYTE
KEYASCII DB ?
BUFFER DB 128 DUP (?)
BUFFERLEN = $ - EFFBUFFER
BUFFERSEG ENDS
DEMOLDTSEG SEGMENT PARA USE16
EFFLDT LABEL BYTE
EFFLDTOFF = $ - EFFLDT
TODEMOTSS DESCRIPTOR <DEMOTSSLEN - 1,DEMOTSSSEG,,ATDW,>
TODEMOTSS_SEL = (TODEMOTSS - EFFLDT) + TIL
DEMOSTACK DESCRIPTOR <DEMOSTACKLEN - 1,DEMOSTACKSEG,,ATDWA,>
DEMOSTACK_SEL = (DEMOSTACK - EFFLDT) + TIL
DEMODATA DESCRIPTOR <DEMODATALEN - 1,DEMODATASEG,,ATDW,>
DEMODATA_SEL = (DEMODATA - EFFLDT) + TIL
DIVCODE DESCRIPTOR <DIVCODELEN - 1,DIVCODESEG,,ATCE,>
DIVCODE_SEL = (DIVCODE - EFFLDT) + TIL
OFCODE DESCRIPTOR <OFCODELEN - 1,OFCODESEG,,ATCE,>
OFCODE_SEL = (OFCODE - EFFLDT) + TIL
SNPCODE DESCRIPTOR <SNPCODELEN - 1,SNPCODESEG,,ATCE,>
SNPCODE_SEL = (SNPCODE - EFFLDT) + TIL
SSECODE DESCRIPTOR <SSECODELEN - 1,SSECODESEG,,ATCE,>
SSECODE_SEL = (SSECODE - EFFLDT) + TIL
GPCODE DESCRIPTOR <GPCODELEN - 1,GPCODESEG,,ATCE,>
GPCODE_SEL = (GPCODE - EFFLDT) + TIL
SNPTEST DESCRIPTOR <0FFFFH,0,,ATDW - 80H,>
SNPTEST_SEL = (SNPTEST - EFFLDT) + TIL
DEMOLDNUM = ($ - EFFLDT) / 8
DEMOLDTLEN = $ - EFFLDT
DEMOLDTSEG ENDS
DEMOTSSSEG SEGMENT PARA USE16
EFFDEMOTSS LABEL BYTE
DEMOTASKSS TASKSS <>
DB 0FFH
DEMOTSSLEN = $ - EFFDEMOTSS
DEMOTSSSEG ENDS
DEMOSTACKSEG SEGMENT PARA USE16
DEMOSTACKLEN = 1024
DB DEMOSTACKLEN DUP (0)
DEMOSTACKSEG ENDS
DEMODATASEG SEGMENT PARA USE16
EFFDEMOD LABEL BYTE
MESS0 DB 'Divide Exception',0
MESS4 DB 'Overflow Exception',0
MESSB DB 'Segment Not Present Exception',0
MESSC DB 'Stack Segment Exception',0
MESSD DB 'General Protection Exception',0
MESSOTHER DB 'Other Exception',0
ERRMESS DB 'Error Code='
ERRCODE DB 4 DUP (0),'H',0
DEMODATALEN = $ - EFFDEMOD
DEMODATASEG ENDS
DEMOCODESEG SEGMENT PARA USE16
ASSUME CS:DEMOCODESEG
EFFDEMOC LABEL BYTE
DEMOBEGINOFF = $ - EFFDEMOC
DEMOBEGIN:MOV AX,DEMOLDT_SEL
LLDT AX
MOV AX,DEMOSTACK_SEL
MOV SS,AX
MOV ESP,DEMOSTACKLEN
MOV AX,TODEMOTSS_SEL
MOV GS,AX
MOV WORD PTR GS:DEMOTASKSS.TRLDT,DEMOLDT_SEL
MOV AX,DEMOTSS_SEL
LTR AX
MOV AX,DEMODATA_SEL
MOV DS,AX
MOV AX,VIDEOBUFF_SEL
MOV ES,AX
MOV AX,XBUFFER_SEL
MOV FS,AX
MOV AX,XBUFFER_SEL
MOV GS,AX
INT 0FFH
MOV AL,FS:KEYASCII
CMP AL,'0'
JNZ DEMO4
EXCEPTION0:MOV AX,1000
MOV CL,2
DIV CL
JMP OVER
DEMO4:CMP AL,'4'
JNZ DEMO11
EXCEPTION4:MOV AL,100
ADD AL,50
INTO
JMP OVER
DEMO11:CMP AL,'B'
JNZ DEMO12
EXCEPTION11:MOV AX,SNPTEST_SEL
MOV GS,AX
JMP OVER
DEMO12:CMP AL,'C'
JNZ DEMO13
EXCEPTION12:MOV EBP,ESP
MOV AL,[EBP]
JMP OVER
DEMO13:CMP AL,'D'
JNZ OVER
EXCEPTION13:MOV AX,DEMOTSS_SEL
MOV GS,AX
JMP OVER
OVER:JUMP16 TEMPCODE_SEL,TODOSOFF
DEMOCODELEN = $ - EFFDEMOC
DEMOCODESEG ENDS
TEMPCODESEG SEGMENT PARA USE16
ASSUME CS:TEMPCODESEG
EFFTEMPC LABEL BYTE
VIRTUALOFF = $ - EFFTEMPC
VIRTUAL:JUMP16 DEMOCODE_SEL,DEMOBEGINOFF
TODOSOFF = $ - EFFTEMPC
TODOS:MOV AX,NORMAL_SEL
MOV DS,AX
MOV ES,AX
MOV FS,AX
MOV GS,AX
MOV SS,AX
MOV EAX,CR0
AND EAX,0FFFFFFFEH
MOV CR0,EAX
JUMP16 <SEG REAL>,<OFFSET REAL>
TEMPCODELEN = $ - EFFTEMPC
TEMPCODESEG ENDS
RDATASEG SEGMENT PARA USE16
VGDTR PDESC <GDTLEN - 1,>
VIDTR PDESC <IDTLEN - 1,>
NORVIDTR PDESC <3FFH,0>
SPVAR DW ?
SSVAR DW ?
MESS DB 'Strike a key[0,4,B,C,D]:','$'
RDATASEG ENDS
RCODESEG SEGMENT PARA USE16
ASSUME CS:RCODESEG,DS:RDATASEG
START:MOV AX,RDATASEG
MOV DS,AX
CLD
CALL INIT_GDT
CALL INIT_IDT
MOV AX,GKEYLDTSEG
MOV FS,AX
MOV CX,GKEYLDNUM
MOV SI,OFFSET GLDT
CALL INIT_LDT
MOV AX,DEMOLDTSEG
MOV FS,AX
MOV CX,DEMOLDNUM
MOV SI,OFFSET EFFLDT
CALL INIT_LDT
MOV WORD PTR SSVAR,SS
MOV WORD PTR SPVAR,SP
LGDT QWORD PTR VGDTR
SIDT NORVIDTR
CLI
LIDT QWORD PTR VIDTR
MOV EAX,CR0
OR EAX,1
MOV CR0,EAX
JUMP16 TEMPCODE_SEL,VIRTUALOFF
REAL:MOV AX,RDATASEG
MOV DS,AX
LSS SP,DWORD PTR SPVAR
LIDT NORVIDTR
STI
MOV AX,4C00H
INT 21H
INIT_GDT PROC NEAR
PUSH DS
MOV AX,GDTSEG
MOV DS,AX
MOV CX,GDNUM
MOV SI,EFFGDTOFF
INITG:MOV AX,[SI].BASEL
MOVZX EAX,AX
SHL EAX,4
SHLD EDX,EAX,16
MOV [SI].BASEL,AX
MOV [SI].BASEM,DL
MOV [SI].BASEH,DH
ADD SI,8
LOOP INITG
POP DS
MOV BX,16
MOV AX,GDTSEG
MUL BX
MOV WORD PTR VGDTR.BASE,AX
MOV WORD PTR VGDTR.BASE+2,DX
RET
INIT_GDT ENDP
INIT_IDT PROC NEAR
MOV BX,16
MOV AX,IDTSEG
MUL BX
MOV WORD PTR VIDTR.BASE,AX
MOV WORD PTR VIDTR.BASE+2,DX
RET
INIT_IDT ENDP
INIT_LDT PROC NEAR
ILDT:MOV AX,FS:[SI].BASEL
MOVZX EAX,AX
SHL EAX,4
SHLD EDX,EAX,16
MOV FS:[SI].BASEL,AX
MOV FS:[SI].BASEM,DL
MOV FS:[SI].BASEH,DH
ADD SI,8
LOOP ILDT
RET
INIT_LDT ENDP
RCODESEG ENDS
END START
在XP下使用tasm t461.asm编译，tlink /3 t461.obj链接
在DOS下运行t461.exe，根据提示输入，Strike a key[0,4,B,C,D]:
分别选择0,4,B,C,D，在左上角黑底白字分别显示异常信息，选择B,C,D还显示出错码
2.关于实例七的说明
上述模拟与演示程序的许多内容与实例六相同，下面就各异常处理程序和读键盘任务的实现作些说明：
（1）除法出错故障处理程序的实现
从源程序可见，除法出错是在执行故意安排的被除数为1000，而除数为2的无符号除指令时引起。作为演示，除法出错故障处理程序先显示一条提示信息，
然后把存放被除数的AX内容右移一位，然后就返回。由于除法出错归入故障异常这一类，所以，在故障处理结束返回后，仍执行该无符号除指令。
显然，将再次引起同样的故障，仍把被除数右移一位。但由于每次处理时都把被除数减半，所以几次故障后就不发生该故障。
（2）溢出陷阱处理程序的实现
作为演示的溢出陷阱处理程序较简单。先显示一条提示信息，然后就返回。因为溢出异常归入陷阱这一类，所以在陷阱处理结束后，就直接返回到引起陷阱的指令的下一条指令。
（3）段不存在故障处理程序的实现
从源程序可见，段不存在故障是在执行故意安排的把一个选择子送段寄存器GS的指令时引起。该选择子索引的描述符中的存在位P被故意置为0，表示对应段不在内存。
在正常情况下，段不存在故障处理程序要把对应的段装入内存，再把描述符内的P位修改为1，于是，在故障处理结束后，引起故障的指令可得到顺利执行。
为了简单，这里安排的故障处理程序先显示一条提示信息，然后显示出错码，最后调整堆栈中的返回地址并返回。
段不存在故障提供一个出错码，该故障处理程序利用POP指令把它从堆栈中弹出，这样堆栈指针就指向返回地址。
由于段不存在异常归入故障这一类，所以返回点仍是引起故障的指令。因此，作为演示程序调整了堆栈中的返回地址。
（4）堆栈段出错故障处理程序的实现
引起堆栈出错故障的原因有多种，实例通过执行故意安排的偏移超过段界限的堆栈段访问指令来模拟堆栈段出错故障的产生。
作为演示的堆栈出错故障处理程序比较简单，先显示一条提示信息，然后显示出错码，最后调整堆栈中的返回地址并返回。
（5）通用保护故障处理程序的实现
引起通用保护故障的原因有多种，实例通过把一个指向系统段描述符的选择子装入数据段寄存器GS来模拟通用保护故障的产生。
作为演示的通用保护故障处理程序，象上述两个故障处理一样比较简单，先显示一条提示信息，然后显示出错码，最后调整堆栈中的返回地址并返回，
但在废除堆栈中的出错码和调整堆栈中的返回地址时采用了其他方法。
（6）异常处理程序的一般说明
在实例中，通向上述各种异常处理程序的门都是陷阱门。所以，在发生异常而转入这些异常处理程序时，都不发生任务切换。于是，这些异常处理仍作为演示任务的一部分。
正常情况下，异常处理程序应该注意现场的保护和恢复，但为了简单，作为演示的异常处理程序没有能够切实地保护现场。
注意，这些异常处理程序所采用的处理方法与所模拟的指令有关，不适用于一般情况。
（7）显示出错代码的过程
实例采用一个过程用于显示出错码，该过程的入口参数是AX含出错码。利用该过程不仅缩短程序，而且也用于表现异常处理程序的实现。
（8）读键盘任务的实现
在实例的IDT中，0FFH号门描述符是任务门，指向一个独立的任务。该任务的功能是读键盘，接收一个指定范围内的字符。
演示任务通过指令“INT 0FFH”指令调用它，接收一个代表需要模拟异常的字符。
为了简单，该任务在实方式下读键盘，接收指定范围内的字符。为此，该任务每次经历如下步骤：
①转回到实方式。此前要做必要的准备，回到实方式后，要恢复必须的实方式下的部分现场。
②接收指定的字符。调用DOS功能显示提示信息，调用BIOS读键盘，如在指定范围内那么就显示，并保存在约定的数据段中。
③转回到保护方式，此前也要做必要的准备。
尽管在任务切换时，自动利用TSS保护和恢复现场，但由于该任务相当于一个读键盘的过程，所以在开始任务时，还通过堆栈保护必要的现场，在结束任务时恢复现场。
请特别注意，安排在该任务代码段中的IRETD指令之后的转移指令的作用。
begin:
..........
IRETD  ;当当前任务被切换后CPU记下它的位置（即下面的JMP begin处),所以
JMP begin ;在任务的最后加上JMP指令是为了下次调用这个任务时能够从头执行。
10.7.6各种转移途径小结
如上所述，中断/异常可引起任务切换、任务内特权级变换和任务内无特权级变换的转移。至此，任务切换、任务内特权级变换和任务内无特权级变换转移的各种途径已全部列出。
1.任务切换的途径
任务之间切换的途径如图10.22所示。段间转移指令JMP、段间调用指令CALL、软中断指令INT和中断返回指令IRET引起的任务切换是主动的任务切换，
或者说是当前任务要求的任务切换。中断和异常（不包括软中断指令）引起的任务切换是被动的任务切换，或者说是不受当前任务左右的任务的切换。
伴随着任务切换，特权级当然可能发生变换。只要任务切换发生，这种特权级的变换取决于目标任务，而与当前特权级无关。
2.任务内特权级变换的途径
任务内特权级变换的途径如图10.23所示。图中特权级m是外层特权级，特权级n是内层特权级。通常RET与CALL对应；IRET与INT、中断/异常对应。
但也可以通过在堆栈中建立合适环境的手段，使用RET或IRET从内层特权级变换到外层特权级。
3.任务内相同特权级转移的途径
任务内相同特权级转移的途径如图10.24所示。由图可见，任务内相同特权级转移的途径多种多样。
10.8操作系统类指令
在第9章已介绍了80386新增的普通指令，本节介绍操作系统类指令。其中的某些指令始于80286。通常只在操作系统代码中使用这些指令，而不在应用程序代码中使用这些指令。
这是把它们称为操作系统类指令的原因。为了保证操作系统的安全，保护方式下的80386支持四个特权级。相应地，这些操作系统类指令也可分为三种：
实方式和任何特权级下可执行的指令、实方式及特权级0下可执行的指令和仅在保护方式下执行的指令。
10.8.1实方式和任何特权级下可执行的指令
1.存储全局和中断描述符表寄存器指令
全局描述符表GDT和中断描述符表IDT包含着系统的重要数据，对应的两个描述符表寄存器GDTR和IDTR含有这两张表的定位信息。
利用存储描述符表寄存器指令能把描述符表寄存器的内容保存到指定的存储单元。这样，访问这些存储单元就可获得描述符表的定位信息。
与GDT和IDT被所有任务共享不同，LDT是每个任务私有，所以存储局部描述符表寄存器LDTR的指令不在所列。
（1）存储全局描述符表寄存器指令
存储全局描述符表寄存器指令的格式如下：
SGDT DST
其中，操作数DST是48位（6字节）的存储器操作数。
该指令的功能是把全局描述符表寄存器GDTR的内容存储到存储单元DST。GDTR中的16位界限存入DST的低字，GDTR中的32位基地址存入DST的高双字。
该指令对标志没有影响。
例如：如下指令把GDTR保存到由BX所指向的存储单元中：
SGDT [BX]
（2）存储中断描述符表寄存器指令
存储中断描述符表寄存器指令的格式如下：
SIDT DST
其中，操作数DST是48位（6字节）的存储器操作数。
该指令的功能是把中断描述符表寄存器IDTR的内容存储到存储单元DST。IDTR中的16位界限存入DST的低字，IDTR中的32位基地址存入DST的高双字。
该指令与上面的存储全局描述符表寄存器指令SGDT相似。
该指令对标志没有影响。
例如：如下指令把IDTR保存到由EDX所指向的存储单元中：
SIDT [EDX]
2.存储机器状态字指令
存储机器状态字指令的格式如下：SMSW DST
其中，操作数DST可以是16位通用寄存器或存储单元。该指令的功能是把机器状态字存储到DST。
该指令对标志没有影响。
例如：如下指令把机器状态字存储到AX：
SMSW AX
80386有此指令是为了包含80286的指令集。由于80386的控制寄存器CR0的低16位等同于80286的机器状态字，
所以在为80386编程时，如果需要存储机器状态字，那么应该使用存储CR0寄存器的指令。
10.8.2实方式及特权级 0下可执行的指令
下列指令涉及设置最关键的寄存器，所以只能在实方式和保护方式的特权级0下执行。为了从初始时的实方式转入保护方式，必须作基本的准备工作。
例如，设置妥全局描述符表寄存器GDTR等。这是允许下列指令在实方式下执行的原因。
在保护方式下，如当前特权级（CPL）不为0，执行这些指令将引起错误码为0的通用保护故障。
在虚拟8086方式下，因为CPL为3，所以执行这些指令也就会引起错误码为0的通用保护故障。，
1.清任务切换标志指令
每当任务切换时，控制寄存器CR0中的任务切换标志TS被自动置1。这样安排的原因已在前面说明过。
清任务切换标志指令的功能是把TS标志清0。该指令的格式如下：
CLTS
该指令仅影响TS标志，对其他标志没有影响。
2.暂停指令
暂停指令的格式如下：
HLT
该指令使处理机暂停执行。暂停之后的系统，只有在接受一个已经启用的中断，或者让系统复位，才能重新启动。
该指令对标志没有影响。
3.装载全局描述符表和中断描述符表寄存器的指令
（1）装载全局描述符表寄存器指令
装载全局描述符表寄存器指令的格式如下：
LGDT SRC
其中，操作数SRC是48位（6字节）的存储器操作数。
该指令的功能是把存储器中的伪描述符装入到全局描述符表寄存器GDTR。伪描述符SRC的结构如前述结构类型PDESC所示，低字是以字节为单位的段界限，高双字是段基地址。
该指令对标志没有影响。
例如：如下指令从BX所指向的存储单元中装载GDTR：
LGDT [BX]
在前几节所举实例中，已多次使用了该指令。
（2）装载中断描述符表寄存器指令
装载中断描述符表寄存器指令的格式如下：
LIDT SRC
其中，操作数SRC是48位（6字节）的存储器操作数。该指令的功能是把存储器中的伪描述符装入到中断描述符表寄存器IDTR。
该指令的格式与功能与装载全局描述符表寄存器指令的格式与功能类似。请参见实例六和七。
4.装载机器状态字指令
装载机器状态字指令的格式如下：
LMSW SRC
其中，操作数SRC可以是16位通用寄存器或存储单元。该指令的功能是将SRC装入机器状态字（也就是CR0的低16位）。
该指令对标志寄存器中的标志没有影响。
例如：如下指令把AX的内容装载到机器状态字：
LMSW AX
将PE位置1，便进入保护方式。在80286中，没有控制寄存器，为进入保护方式需要通过该指令把MSW中的PE位置1。
如果的确是这样，那么在LMSW指令后面必须紧跟一条转移指令。
80386提供此指令是为了包含80286的指令集。由于80386的控制寄存器CR0的低16位等同于80286的机器状态字，
所以在为80386编程时，如果需要装载机器状态字，那么应该使用控制寄存器传送指令。
5.控制寄存器数据传送指令
控制寄存器数据传送指令的一般格式如下：
MOV DST,SRC
控制寄存器数据传送指令实现80386的控制寄存器和32位通用寄存器之间的数据传送。
所以，操作数SRC和DST可以是80386使用的三个控制寄存器和任一32位通用寄存器，但不能同时是控制寄存器。
该指令对标志没有影响。
例如：MOV EAX,CR2
MOV CR0,EAX
6.调试寄存器数据传送指令
调试寄存器数据传送指令的一般格式与上面的控制寄存器数据传送指令的格式相同。功能是实现80386的调试寄存器和32位通用寄存器之间的数据传送。
操作数SRC和DST可以是80386使用的6个调试寄存器和任一32位通用寄存器，但不能同时是调试寄存器。
80386可使用的6个调试寄存器记为：DR0、DR1、DR2、DR3、DR6和DR7。
这些寄存器全是32位，其中Dr0~Dr3存放断点地址，Dr4、Dr5保留不使用，Dr7是一些控制位，用于控制断点的方式，Dr6用于显示是哪个硬件调试寄存器引起的断点。
其他说明与控制寄存器数据传送指令相同。
7.测试寄存器数据传送指令
测试寄存器数据传送指令的一般格式与上面的控制寄存器数据传送指令的格式相同。功能是实现80386的测试寄存器和32位通用寄存器之间的数据传送。
80386使用的2个测试寄存器是TR6和TR7。其他说明与控制寄存器数据传送指令相同。
80386提供了一种机制来测试Translation Lookaside Buffer（TLB），TLB存储了当前最可能被访问到的页表项。
只有在TLB无法完成地址翻译任务时，才会到内存中查询页表，这样就减少了页表查询导致的处理器性能下降。
TR6是测试命令寄存器，TR7是测试数据寄存器。这些寄存器可以用MOV命令来访问。测试命令寄存器可以是源操作数，也可以是目的操作数。
8个32-bit寄存器:
  eax 一般用作累加器；
  ebx 一般用作基址寄存器(Base)；
  ecx 一般用来计数(Count)；
  edx 一般用来存放数据(Data)；
  esp 一般用作堆栈指针(Stack Pointer)；
  ebp 一般用作基址指针(Base Pointer)；
  esi 一般用作源变址(Source Index)；
  edi 一般用作目标变址(Destinatin Index)；
8个16-bit寄存器：
  它们事实上是上面8个32-bit寄存器的低16位：ax，bx，cx，dx，di，si，bp，sp；
8个8-bit寄存器：
  它们事实上是寄存器ax，bx，cx，dx的高8位和低8位：ah，al，bh，bl，ch，cl，dh，dl；
6个段寄存器：
  cs 代码段寄存器；
  ds 数据段寄存器；
  ss 堆栈段寄存器；
  es 附加数据段寄存器；
  fs 附加数据段寄存器；
  gs 附加数据段寄存器；
4个控制寄存器：cr0，cr2，cr3(其中cr1保留未使用)；
一个标志寄存器：EFLAGS
8个浮点寄存器栈：st(0)，st(1)，st(2)，st(3)，st(4)，st(5)，st(6)，st(7)；
2个测试寄存器：tr6，tr7；
6个debug寄存器：db0，db1，db2，db3，db6，db7。
10.8.3只能在保护方式下执行的指令
下面介绍的指令只能在保护方式下执行。如果在实方式下执行这些指令，将引起非法操作码故障（向量号6）。
1.装载和存储局部描述符表寄存器指令
（1）装载局部描述符表寄存器指令
装载局部描述符表寄存器指令的格式如下：
LLDT SRC
其中，操作数SRC可以是16位通用寄存器或存储单元。该指令的功能是把SRC中的内容作为指示局部描述符表LDT的选择子装入到LDTR。
该指令不影响标志。
例如：如下指令把CX的内容作为指向LDT的选择子装入LDTR：
LLDT CX
操作数SRC给定的选择子应该指示GDT中的类型为LDT的描述符。但SRC也可以是一个空的选择子，如果这样的话，表示暂时不使用局部描述符表LDT。
若CPL不为0，那么执行该指令将产生错误码为0的通用保护故障。若被装载的选择子不指示GDT中描述符，或者描述符类型不是LDT描述符，
那么产生通用保护故障，错误码由该选择子构成。
从10.3节可知，象段寄存器那样，LDTR也有两部分。在把指示LDT的选择子装入到LDTR可见部分时，
处理器自动把选择子所索引的LDT描述符中的段基地址等信息保存到不可见的高速缓冲寄存器中。
（2）存储局部描述符表寄存器指令
存储局部描述符表寄存器指令的格式如下：
SLDT DST
其中，操作数DST可以是16位通用寄存器或存储单元。
该指令的功能是把局部描述符表寄存器LDTR的内容存储到存储单元DST，也就是把指向当前任务LDT的选择子存储到DST。
例如：如下指令把局部描述符表寄存器LDTR的内容保存到寄存器DX：
SLDT DX
2.装载和存储任务寄存器指令
任务寄存器TR指示当前任务的任务状态段TSS。随着任务的切换，TR的内容也随之改变；如果任务嵌套，那么TR的原值作为链接字保存到新任务的TSS中。
但有时候需要直接地装载TR，或者保存TR，这就需要使用装载TR指令和存储TR指令。
（1）装载任务寄存器指令
装载任务寄存器指令的格式如下：
LTR SRC
其中，操作数SRC可以是16位通用寄存器或存储单元。该指令的功能是将SRC作为指示TSS描述符的选择子装载到任务寄存器TR。
从10.3节可知，象LDTR那样，TR也有两部分。在把指示TSS的选择子装入到TR可见部分时，
处理器自动把选择子所索引的描述符中的段基地址等信息保存到不可见的高速缓冲寄存器中。
所以，SRC表示的选择子不能为空，必须索引位于GDT中的描述符，并且描述符的类型必须是TSS。
该指令对标志没有影响。
例如：如下指令把AX的内容作为指示TSS描述符的选择子装载到TR：
LTR AX
若CPL不为0，那么执行该指令将产生错误码为0的通用保护故障。若被加载的选择子不指示GDT中的TSS描述符，那么产生通用保护故障，错误码由该选择子构成。
（2）存储任务寄存器指令
存储任务寄存器指令的格式如下：
STR DST
其中，操作数DST可以是16位通用寄存器或存储单元。该指令的功能是把TR所含的指示当前任务TSS描述符的选择子存储到DST。
该指令对标志没有影响。
例如：如下指令把TR的内容存储到AX中：
STR AX
3.调整申请特权级指令
调整申请特权级指令的格式如下：
ARPL OPRD1,OPRD2
其中，操作数OPRD1可以是16位通用寄存器或存储单元，操作数OPRD2是16位通用寄存器。
该指令把操作数OPRD1和OPRD2视为两个选择子，用OPRD2的申请特权级（RPL）去检查OPRD1的RPL。选择子OPRD1和OPRD2的RPL分别由它们的最低2个位规定。
如果OPRD1的RPL小于OPRD2的RPL，那么零标志ZF被置1，并把OPRD2的RPL值赋予OPRD1的RPL（使它们最低2位相等）；否则，ZF被清0。
OPRD1和OPRD2都可以是空的选择子。
该指令影响ZF，不影响其他标志。
请参见本节的示例程序。
4.装载存取权指令
装载存取权指令的格式如下：
LAR OPRD1,OPRD2
其中，操作数OPRD1可以是16位通用寄存器或32位通用寄存器；操作数OPRD2可以是16位通用寄存器或存储单元，也可以是32位通用寄存器或存储单元。
操作数OPRD1和操作数OPRD2的尺寸应该一致。该指令把操作数OPRD2视为选择子（当32位时仅使用低16位），
如果OPRD2所指示的描述符满足如下条件，那么零标志ZF被置1，并把描述符内的属性字段装入OPRD1；否则，ZF被清0，OPRD1不变。
①在描述符表的范围内；
②是存储段描述符或系统段描述符，或者任务门描述符和调用门描述符；
⑧CPL和OPRD2的RPL都不大于DPL。
在满足条件的情况下，装入到OPRD1的由OPRD2所指示的描述符中的属性字段是指描述符的高4字节和00FXFF00H相与的结果，其中X表示第16位到第19位无定义。
注意，如果指令使用16位操作数，那么只有上述高4字节中的低字被装入到OPRD1，也即装入到OPRD1的属性字段不包括G位和AVL位等。参见本节给出的示例程序。
该指令影响ZF，不影响其他标志。
5.装载段界限指令
装载界限指令的格式如下：
LSL OPRD1,OPRD2
其中，操作数OPRD1可以是16位通用寄存器或32位通用寄存器；操作数OPRD2可以是16位通用寄存器或存储单元，也可以是32位通用寄存器或存储单元。
操作数OPRD1和操作数OPRD2的尺寸应该一致。该指令把操作数OPRD2视为选择子（当32位时仅使用低16位），
如果OPRD2所指示的描述符满足如下条件，那么零标志ZF被置1，并把描述符内的界限字段装入OPRD1；否则，ZF被清0，OPRD1不变。
①在描述符表的范围内；
②是存储段描述符或系统段描述符，而非门描述符；
③CPL和OPRD2的RPL都不大于DPL。
在满足条件的情况下，装入到OPRD1的由OPRD2所指示的描述符中的界限字段以字节为单位。
如果描述符中的界限字段以4K字节为单位（G=1），那么在装入到OPRD1时被左移12位，空出的低位全部填成1。
注意，如果指令使用16位操作数，那么只有段界限的低16位被装入到OPRD1。参见本节给出的示例程序。
该指令影响ZF，不影响其他标志。
6.读写检验指令
利用读检验指令和写检验指令可分别检查在当前特权级上指定的段能否读或写，从而避免引起不必要的异常。
（1）读检验指令
读检验指令的一般格式如下：
VERR OPRD
其中，操作数OPRD可以是16位通用寄存器或存储单元，也可以是32位通用寄存器或存储单元。
该指令的功能是把OPRD的内容作为一个选择子（当32位时仅使用低16位），判断在当前特权级上该选择子所指示的段是否能读。
如果该选择子指示合法的一个存储段描述符，并且所描述的段在当前特权级上可读，那么零标志ZF被置1，否则ZF被清0。
该指令只影响零标志ZF，而不影响其他标志。
（2）写检验指令
写检验指令的一般格式如下：
VERW OPRD
其中，操作数OPRD可以是16位通用寄存器或存储单元，也可以是32位通用寄存器或存储单元。
该指令的功能是把OPRD的内容作为一个选择子（当32位时仅使用低16位），判断该选择子所指示的段在当前特权级上是否能写。
如果该选择子指示合法的一个存储段描述符，并且所描述的段在当前特权级上可写，那么零标志ZF被置1，否则ZF被清0。
该指令只影响零标志ZF，而不影响其他标志。
10.8.4显示关键寄存器内容的实例（实例八）
下面结合说明部分操作系统类指令的使用，给出一个显示80386关键寄存器内容的实例。
该实例的逻辑功能，是显示系统中GDTR、IDTR、LDTR和DR等关键寄存器的当前内容。
实例八源程序清单如下：
；程序名：T10-8.ASM
；功能：显示关键寄存器内容兼说明操作系统类指令的使用
DESCRIPTOR STRUC
LIMITL DW 0
BASEL DW 0
BASEM DB 0
ATTRIBUTES DW 0
BASEH DB 0
DESCRIPTOR ENDS
GATE STRUC
OFFSETL DW 0
SELECTOR DW 0
DCOUNT DB 0
GTYPE DB 0
OFFSETH DW 0
GATE ENDS
PDESC STRUC
LIMIT DW 0
BASE DD 0
PDESC ENDS
TASKSS STRUC
TRLINK DW ?,0
TRESP0 DD ?
TRSS0 DW ?,0
TRESP1 DD ?
TRSS1 DW ?,0
TRESP2 DD ?
TRSS2 DW ?,0
TRCR3 DD ?
TREIP DD ?
TREFLAG DW ?,?
TREAX DD ?
TRECX DD ?
TREDX DD ?
TREBX DD ?
TRESP DD ?
TREBP DD ?
TRESI DD ?
TREDI DD ?
TRES DW ?,0
TRCS DW ?,0
TRSS DW ?,0
TRDS DW ?,0
TRFS DW ?,0
TRGS DW ?,0
TRLDT DW ?,0
TRFLAG DW 0
TRIOMAP DW $ + 2
TASKSS ENDS
ATDR = 90H
ATDW = 92H
ATDWA = 93H
ATCE = 98H
ATCER = 9AH
ATCCO = 9CH
ATCCOR = 9EH
ATLDT = 82H
ATTASKGAT = 85H
AT386TSS = 89H
AT386CGAT = 8CH
AT386IGAT = 8EH
AT386TGAT = 8FH
DPL1 = 20H
DPL2 = 40H
DPL3 = 60H
RPL1 = 01H
RPL2 = 02H
RPL3 = 03H
IOPL1 = 1000H
IOPL2 = 2000H
IOPL3 = 3000H
D32 = 4000H
TIL = 04H
VMFL = 0002H
IFL = 0200H
JUMP32 MACRO selector,offsetv
DB 0EAH
DW offsetv
DW 0
DW selector
ENDM
CALL32 MACRO selector,offsetv
DB 9AH
DW offsetv
DW 0
DW selector
ENDM
JUMP16 MACRO selector,offsetv
DB 0EAH
DW offsetv
DW selector
ENDM
CALL16 MACRO selector,offsetv
DB 9AH
DW offsetv
DW selector
ENDM
.386P
GDTSEG SEGMENT PARA USE16
GDT LABEL BYTE
DUMMY DESCRIPTOR <>
NORMAL DESCRIPTOR <0FFFFH,0,0,ATDW,0>
NORMAL_SEL = NORMAL - GDT
EFFGDT LABEL BYTE
EFFGDTOFF = $ - GDT
TEMPCODE DESCRIPTOR <0FFFFH,TEMPCODESEG,,ATCE,>
TEMPCODE_SEL = TEMPCODE - GDT
BUFFER DESCRIPTOR <BUFFERLEN - 1,BUFFERSEG,,ATDW,>
BUFFER_SEL = BUFFER - GDT
TEST1 DESCRIPTOR <1111H,0,,8792H,>
TEST1_SEL = TEST1 - GDT
TESTR_SEL = (TEST1 - GDT) + RPL3
TEST2 DESCRIPTOR <2222H,0,,1782H,>
TEST2_SEL = TEST2 - GDT
GDNUM = ($ - EFFGDT) / 8
GDTLEN = $ - GDT
GDTSEG ENDS
BUFFERSEG SEGMENT PARA USE16
EFFBUF LABEL BYTE
GDTR_V PDESC <>
IDTR_V PDESC <>
MSW_V DW ?
LDTR_V DW ?
TR_V DW ?
CR0_V DD ?
CR3_V DD ?
DR7_V DD ?
TEST_RPL DW ?
TEST1_SLD DD ?
TEST1_ARD DD ?
TEST1_SLW DW ?
TEST1_ARW DW ?
TEST1_RF DW ?
TEST1_WF DW ?
TEST2_SLD DD ?
TEST2_ARD DD ?
TEST2_SLW DW ?
TEST2_ARW DW ?
TEST2_RF DW ?
TEST2_WF DW ?
BUFFERLEN = $ - EFFBUF
BUFFERSEG ENDS
TEMPCODESEG SEGMENT PARA USE16
ASSUME CS:TEMPCODESEG,DS:BUFFERSEG
EFFTEMPC LABEL BYTE
VIRTUALOFF = $ - EFFTEMPC
VIRTUAL:MOV AX,BUFFER_SEL
MOV DS,AX
MOV EAX,CR0
MOV CR0_V,EAX
MOV EAX,CR3
MOV CR3_V,EAX
MOV EAX,DR7
MOV DR7_V,EAX
STR TR_V
SLDT LDTR_V
MOV WORD PTR TEST_RPL,TEST1_SEL
MOV AX,TESTR_SEL
ARPL TEST_RPL,AX
MOV BX,0
MOV AX,TEST1_SEL
LAB1:MOV EDX,0
MOV CX,0
LSL EDX,EAX
LSL CX,AX
MOV TEST1_SLD[BX],EDX
MOV TEST1_SLW[BX],CX
MOV EDX,0
MOV CX,0
LAR EDX,EAX
LAR CX,AX
MOV TEST1_ARD[BX],EDX
MOV TEST1_ARW[BX],CX
MOV WORD PTR TEST1_RF[BX],0
VERR AX
JNZ LAB2
MOV WORD PTR TEST1_RF[BX],1
LAB2:MOV WORD PTR TEST1_WF[BX],0
VERW AX
JNZ LAB3
MOV WORD PTR TEST1_WF[BX],1
LAB3:ADD BX,16
MOV AX,TEST2_SEL
CMP BX,32
JB LAB1
OVER:MOV AX,NORMAL_SEL
MOV DS,AX
MOV EAX,CR0
AND EAX,0FFFFFFFEH
MOV CR0,EAX
JUMP16 <SEG REAL>,<OFFSET REAL>
TEMPCODELEN = $ - EFFTEMPC
TEMPCODESEG ENDS
RCODESEG SEGMENT PARA USE16
VGDTR PDESC <GDTLEN - 1,>
ASSUME CS:RCODESEG,DS:BUFFERSEG
START:MOV AX,BUFFERSEG
MOV DS,AX
SGDT GDTR_V
SIDT IDTR_V
SMSW MSW_V
PUSH CS
POP DS
CLD
CALL INIT_GDT
MOV BX,OFFSET VGDTR
LGDT [BX]
CLI
MOV EAX,CR0
OR EAX,1
MOV CR0,EAX
JUMP16 TEMPCODE_SEL,VIRTUALOFF
REAL:STI
MOV AX,BUFFERSEG
MOV DS,AX
MOV AX,TEST_RPL
CALL ECHOAX
CALL NEWLINE
MOV AX,WORD PTR TEST1_SLD+2
CALL ECHOAX
MOV AX,WORD PTR TEST1_SLD
CALL ECHOAX
CALL NEWLINE
MOV AX,WORD PTR TEST1_ARD+2
CALL ECHOAX
MOV AX,WORD PTR TEST1_ARD
CALL ECHOAX
CALL NEWLINE
MOV AX,WORD PTR TEST1_SLW
CALL ECHOAX
CALL NEWLINE
MOV AX,WORD PTR TEST1_ARW
CALL ECHOAX
CALL NEWLINE
MOV AX,WORD PTR TEST1_RF
CALL ECHOAX
CALL NEWLINE
MOV AX,WORD PTR TEST1_WF
CALL ECHOAX
CALL NEWLINE
MOV AX,WORD PTR TEST2_SLD+2
CALL ECHOAX
MOV AX,WORD PTR TEST2_SLD
CALL ECHOAX
CALL NEWLINE
MOV AX,WORD PTR TEST2_ARD+2
CALL ECHOAX
MOV AX,WORD PTR TEST2_ARD
CALL ECHOAX
CALL NEWLINE
MOV AX,WORD PTR TEST2_SLW
CALL ECHOAX
CALL NEWLINE
MOV AX,WORD PTR TEST2_ARW
CALL ECHOAX
CALL NEWLINE
MOV AX,WORD PTR TEST2_RF
CALL ECHOAX
CALL NEWLINE
MOV AX,WORD PTR TEST2_WF
CALL ECHOAX
CALL NEWLINE
MOV AX,4C00H
INT 21H
INIT_GDT PROC NEAR
PUSH DS
MOV AX,GDTSEG
MOV DS,AX
MOV CX,GDNUM
MOV SI,EFFGDTOFF
INITG:MOV AX,[SI].BASEL
MOVZX EAX,AX
SHL EAX,4
SHLD EDX,EAX,16
MOV [SI].BASEL,AX
MOV [SI].BASEM,DL
MOV [SI].BASEH,DH
ADD SI,8
LOOP INITG
POP DS
MOV BX,16
MOV AX,GDTSEG
MUL BX
MOV WORD PTR VGDTR.BASE,AX
MOV WORD PTR VGDTR.BASE+2,DX
RET
INIT_GDT ENDP
ECHOAX PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV DX,AX
MOV CX,4
ECHOAX1:ROL DX,4
MOV AL,DL
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
MOV BH,0
MOV AH,0EH
INT 10H
LOOP ECHOAX1
POP DX
POP CX
POP BX
POP AX
RET
ECHOAX ENDP
NEWLINE PROC NEAR
PUSH AX
PUSH BX
MOV BH,0
MOV AL,0DH
MOV AH,0EH
INT 10H
MOV AL,0AH
MOV AH,0EH
INT 10H
POP BX
POP AX
RET
NEWLINE ENDP
RCODESEG ENDS
END START
在XP下使用tasm t462.asm编译，tlink /3 t462.obj链接
在DOS下运行t462.exe，c:\TASM16\T462.exe
0023
71111FFF
00879200
1FFF
9200
0001
0001
00072222
00178200
2222
8200
0000
0000
10.8.5特权指令
所谓特权指令是指保护方式下只有当前特权级CPL=0时，才可以执行的指令。如果CPL不等于0而执行它们，那么会引起通用保护异常。
从上面介绍的操作系统类指令可归纳出如表10.8所列的80386特权指令。这些特权指令在构成完善的保护机制方面起了重要作用。
表10.8特权指令
指令                  功能                  指令                  功能
CLTS          清除CR0中的TS位      LTR                  装入TR
HLT            停机                      MOV CRn,reg     装入控制寄存器
LGDT         装入GDTR              MOV reg,CRn     保存控制寄存器
LIDT          装入IDTR                MOV DRn,reg     装入调试寄存器
LLDT         装入LDTR                MOV reg,DRn    保存调试寄存器
LMSW       装入MSW（CR0低16位）
从表10.8可见，装入GDTR、IDTR、LDTR、TR和MSW的指令都是特权指令，而存储上述寄存器的指令不是特权指令。
这表示，保护方式下任何程序可获取这些寄存器的值，但只有具有特权级0的程序才能够改变这些寄存器的值。
从表10.8还可见，设置和存储控制寄存器及调试寄存器的指令都是特权指令。
10.9输入/输出保护
为了支持多任务，80386不仅要有效地实现任务隔离，而且还要有效地控制各任务的输入/输出，避免输入/输出冲突。本节介绍输入/输出保护。
10.9.1输入/输出保护
80386采用I/O特权级IOPL和I/O许可位图的方法来控制输入/输出，实现输入/输出的保护。
IO特权标志IOPL（I/O Privilege Level）
IO特权标志有2位宽，也称为IO特权级字段。IOPL字段指定了要求执行I/O指令的特权级。
如果当前的特权级别在数值上小于或等于IOPL，那么I/O指令可执行，否则，发生一个保护异常。在80286的16位标志寄存器中已含有该标志。
31          18 17   16  15  14  13 12   11   10  9  8    7   6   5  4   3  2   1  0
                   VM  RF  0   NT  IOPL    OF  DF IF TF  SF ZF  0 AF 0  PF     CF
1.I/O敏感指令
输入/输出特权级（I/O Privilege Level）规定了可以执行所有与I/O相关的指令和访问I/O空间中所有地址的最外层特权级。IOPL值在如图9.2所示的标志寄存器中。
I/O许可位图规定了I/O空间中的哪些地址可以由在任何特权级执行的程序所访问。I/O许可位图在任务状态段TSS中。
表10.9 I/O 敏感指令
指令                  功能                  保护方式下执行条件
CLI         清除EFLAGS中的IF位     CPL <= IOPL
STI         设置EFLAGS中的IF位     CPL <= IOPL
IN          从I/O地址读出数据        CPL <= IOPL或I/O位图允许
INS        从I/O地址读出字符串     CPL <= IOPL或I/O位图允许
OUT      向I/O地址写数据            CPL <= IOPL或I/O位图允许
OUTS    向I/O地址写字符串        CPL <= IOPL或I/O位图允许
表10.9所列的指令称为I/O敏感指令。由于这些指令与I/O有关，并且只有在满足所列条件时才可以执行，所以把它们称为I/O敏感指令。
从表10.9可见，当前特权级不在I/O特权级外层时，可以正常执行所列的全部I/O敏感指令；当前特权级在I/O特权级外层时，执行CLI和STI指令将引起通用保护异常；
当前特权级在1/O特权级外层时，其他四条输入/输出指令是否能够执行要根据访问的I/O地址及I/O许可位图情况而定（在下面细述），如果条件不满足而执行，
那么将引起通用保护异常。
由于每个任务使用各自的EFLAGS值和拥有自己的TSS，所以每个任务可以有不同的IOPL，并且可以定义不同的I/O许可位图。
注意，这些I/O敏感指令在实方式下总是可执行的。
2.I/O许可位图
如果只用IOPL限制I/O指令的执行是很不方便的，不能满足实际需要。因为这样做会使得在特权级3执行的应用程序，要么可访问所有I/O地址，要么不可访问所有I/O地址。
实际需要与此刚好相反，只允许任务甲的应用程序访问部分I/O地址，只允许任务乙的应用程序访问另一部分的I/O地址，以避免任务甲和任务乙在访问I/O地址时发生冲突，
从而避免任务甲和任务乙使用独享设备时发生冲突。
所以，在IOPL的基础上，再采用了I/O许可位图。I/O许可位图由二进制位串组成。位串中的每一位依次对应一个I/O地址，位串的第0位对应I/O地址0，
位串的第n位对应I/O地址n。如果位串中的m位为0，那么对应的I/O地址m可以由在任何特权级执行的程序访问；
否则对应的I/O地址m只能由在IOPL特权级或更内层特权级执行的程序访问。如果在IOPL外层特权级执行的程序访问位串中位值为1的位所对应的I/O地址，
那么引起通用保护异常。
I/O地址空间按字节进行编址。一条I/O指令最多可涉及四个I/O地址。例如，如下指令读取I/O端口71H~74H内的四个字节至EAX
IN EAX,71H
在需要根据I/O位图决定是否可访问I/O地址的情况下，当一条I/O指令涉及多个I/O地址时，只有这多个I/O地址所对应的I/O位图中的位都为0时，该I/O指令才能正常执行；
如果对应位中任一位为1，就会引起通用保护异常。
80386支持的I/O地址空间大小是64K，所以构成I/O许可位图的二进制位串最大长度是64K个位，也即I/O许可位图有效部分最大是8K字节。
一个任务实际需要使用的I/O许可位图大小通常要远小于这个数目。
当前任务使用的I/O许可位图存储在当前任务TSS中低端的64K字节内。I/O许可位图总以字节为单位存储，所以位串所含的位数总被认为是8的倍数。
从如图10.14所示的TSS格式可见，TSS内偏移66H的字确定I/O许可位图的开始偏移。由于I/O许可位图最长可达8K字节，所以开始偏移应该小于56K。
3.I/O访问许可检查细节
保护方式下处理器在执行I/O指令时进行许可检查的细节如图10.25所示。
图中“字节偏移”是I/O指令访问的I/O地址对应位所在字节在I/O许可位图内的偏移，把I/O地址右移3位就得该字节偏移；
“位偏移”是上述对应位在字节内的位数，根据它计算出屏蔽码字。把字节偏移加上位图开始偏移，再加上1，所得值与TSS界限比较，如果越界，那么就引起通用保护异常。
如果不越界，那么就从位图中读出对应字节及下一字节，并和屏蔽字进行与运算，结果为0表示检查通过可以进行I/O访问，结果非0就引起通用保护异常。
在TSS偏移102字节处有一个单字被称为“I/O位图基址”（它的值一般为当前地址-TSS基址+2，表示I/O许可位图从TSS的104字节开始），
它的每一位表示一个字节的端口地址是否可用。如果某一位为0，则表示此位对应的端口号可用，为1则不可用。
每一个任务都可以有单独的TSS，故每一个任务可以有它单独的I/O许可位图。I/O许可位图必须以0FFh结尾。
如果I/O位图基址大于或等于TSS段界限，就表示没有I/O许可位图，如果CPL>=IOPL（IO特权级，位于寄存器eflags的第13位），
则所有I/O指令都会引起异常。I/O许可位图的使用使得即便在同一特权级下不同的任务也可以有不同的I/O访问权限。
I/O地址空间由64K个可单独寻址的8位I/O端口组成，I/O许可位图的最大尺寸就是8K字节。
一般这样分配, 从TSS的104字节开始, 列出自己想填写的I/O许可位图, 对于不想列出的后面部分以0FF结束就可以了。
CLI, STI, IN, INS, OUT, OUTS等指令是I/O敏感指令
保护模式下处理器在执行I/O敏感指令时进行许可检查的细节如下所示。 
(1)若CPL<=IOPL，则直接转步骤(8)；
(2)取得I/O位图开始偏移；
(3)计算I/O地址对应位所在字节在I/O许可位图内的偏移；
(4)计算位偏移以形成屏蔽码值，即计算I/O地址对应位在字节中的第几位；
(5)把字节偏移加上位图开始偏移，再加1，所得值与TSS界限比较，若越界，则产生通用保护异常；
(6)若不越界，则从位图中读对应字节及下一个字节；
(7)把读出的两个字节与屏蔽码进行与运算，若结果不为0表示检查未通过，则产生通用保护异常；
(8)进行I/O访问。
INSD, 一次访问4个端口地址, 需要4个位, 有可能低位在一个字节, 高位又在一个字节。 
为了避免这种情况, 处理器每次读取I/O许可位图的时候是2个字节2个字节读取的, 这样， 不管多坏的情况也不可能超过2个字节。
这样在结尾加个0FFh也就比较好理解了, 如果不加那就越界了。 加其他的值也不好区分, 只有每个位加1才不会曲解原来的I/O许可位图.
只有特权级为0的程序才能够修改Eflags中的IOPL和VM位, 相对于IOPL更内层的特权级才能够修改IF位。
 如果特权级不符合要求, 修改这些位的话, 也不会异常, CPU会忽略。
设任务甲的TSS段如下：
TSSSEGA SEGMENT PARA USE16
EFFTSSA LABEL BYTE
TASKSS <>
DB 8 DUP (0)
DB 10000000B
DB 01100000B
DB 8182 DUP (0FFH)
DB 0FFH
TSSLENA = $ - EFFTSSA
TSSSEGA ENDS
端口0-3F,41-48,4C-4F
再假设IOPL=1,CPL=3。那么如下I/O指令有些能正常执行，有些会引起通用保护异常：
IN AL,21H
IN AL,47H
OUT 20H,AL
OUT 4EH,AL
IN AX,20H
OUT 20H,EAX
OUT 4CH,AX
IN AX,46H
IN EAX,42H
从图10.25所示的细节可见，不论是否有必要，当进行许可位检查时，80386总是从I/O许可位图中读取两个字节。
目的是为了尽快地进行I/O许可检查。一方面，常常要读取I/O许可位图中的两个字节。例如：指令IN AX,47H要对I/O位图中的两个位进行检查，
其低位是某字节的最高位，高位是下一字节的最低位。可见即使只要检查两个位，也可能需要读取两个字节。
另一方面，最多检查四个连续的位，也即最多也只需读取两个字节。所以每次都读取两个字节。这也是在判别是否越界时再加1的缘故。
为此，为了避免在读取I/O许可位图内的最高字节时产生越界，必须在I/O许可位图的最后添加一个全1的字节。
从图10.25及其关于字节越界的说明可知，I/O许可位图开始偏移加8K所得值与TSS界限值二者中较小的值决定I/O许可位图的末端。
当TSS的界限大于I/O许可位图开始偏移加8K时，I/O许可位图有效部分就有8K字节，I/O许可检查全部根据该位图进行。
当TSS的界限不大于I/O许可位图开始偏移加8K时，I/O许可位图有效部分就不到8K字节，于是对较小I/O地址访问的许可检查根据位图进行，
而对较大I/O地址访问的许可检查总被认为不可访问而引起通用保护异常，因为这时会发生字节越界而引起通用保护异常，
所以在这种情况下，可认为不足的I/O许可位图的高端部分是全1。利用这一特点。可大大节约TSS中I/O许可位图占用的存储单元，也就大大减小了TSS。
设任务乙的TSS段如下：
TSSSEGB SEGMENT PARA USE16
EFFTSSB LABEL BYTE
TASKSS <>
DB 100H / 8 DUP (0FFH)
DB 100H / 8 DUP (0)
DB 0FFH
TSSLENB = $ - EFFTSSB
TSSSEGB ENDS
上面任务乙的TSS内只含I/O许可位图的最初200H位，对应I/O端口地址0-1FFH，而其他位都可以被认为是1。
设任务丙的TSS段如下：
TSSSEGC SEGMENT PARA USE16
EFFTSSC LABEL BYTE
TASKSS <>
DB 100H / 8 DUP (0)
DB 0FFH
TSSLENC = $ - EFFTSSC
TSSSEGC ENDS
上面任务丙的TSS内只含I/O许可位图的最初100H位，对应1/O端口地址0-0FFH，而其他位都可以被认为是1。
设任务丁的TSS段如下：
TSSSEGD SEGMENT PARA USE16
EFFTSSD LABEL BYTE
TASKSS <>
DB 0FFH
TSSLEND = $ - EFFTSSD
TSSSEGD ENDS
上面任务丁的TSS内只有I/O许可位图结束字节，而无有效的I/O许可位图。
综上所述，使用I/O许可位图可以较好地满足实际应用需要。在方便应用程序进行输入/输出的同时，限制输入/输出，避免任务间在使用外设时发生冲突。
10.9.2重要标志保护
输入/输出的保护与存储在标志寄存器EFLAGS中的IOPL密切相关，显然不能允许随便地改变IOPL，否则就不能有效地实现输入/输出保护。
类似地，对EFLAGS中的IF位也必须加以保护，否则CLI和STI作为敏感指令对待是无意义的。此外，EFLAGS中的VM位决定着处理器是否按虚拟8086方式工作。
80386对EFLAGS中的这三个字段的处理比较特殊，只有在较高特权级执行的程序才能执行IRET、POPF、CLI和STI等指令来改变它们。
表10.10列出了不同特权级下对这三个字段的处理情况。
表10.10不同特权级对EFLAGS特殊字段处理
                                                标志字段
特权级                  VM                  IOPL                  IF
CPL= 0     可变（除POPF指令外  可变                   可变
0< CPL <= IOPL  不变                不变                   可变
CPL > IOPL          不变                不变                   不变
从表10.10可见，只有在特权级0执行的程序才可以修改IOPL位及VM位；只能由相对于IOPL同级或更内层特权级执行的程序才可以修改IF位。
与CLI和STI指令不同，在特权级不满足上述条件的情况下，当执行POPF指令和IRET指令时，如果试图修改这些字段中的任何一个字段，并不引起异常，
但试图要修改的字段也未被修改，也不给出任何特别的信息。
此外，指令POPF总不能改变VM位，而PUSHF指令总把0压入到VM位。
10.9.3演示输入/输出保护的实例（实例九）
下面给出一个用于演示输入/输出保护的实例。演示内容包括：I/O许可位图的作用、I/O敏感指令引起的异常和特权指令引起的异常；
使用段间调用指令CALL通过任务门调用任务，实现任务嵌套等。
Intel 8253 (或 8254)是一个可编程定时/计数器（PIT-Programmable Interval Timer)芯片，用于解决计算机中通常碰到的时间控制问题，
即在软件的控制下产生精确的时间延迟。该芯片提供了3个独立的16位计数器通道。每个通道可工作在不同的工作方式下，并且这些工作方式均可以使用软件来设置。 
8254是8253的更新产品，主要功能基本一样，只是8254芯片加了回读命令。
8254芯片的IO端口地址范围是0x40~0x43。其中0x40~0x42分别对应计数器通道0~2，0x43对应控制字寄存器写端口。
通过向8253写入一个控制字和一个初始计数值，我们就可以对想要使用的一个计数器进行编程。
控制字的内容会指定正在编程的计数器通道，当控制字写完后，就可以向某个通道写入初始计数值。
初始计数值必须根据控制字中设定的格式写入（二进制或BCD码格式）。
7         6         5         4               3         2         1         0
00 计数器0  00 计数器锁存命令  000 方式0              0 二进制
01 计数器1  01 只读写低字节      001 方式1              1 十进制
10 计数器2  10 只读写高字节      x10 方式2
11 非法        11 先读写低字节     x11  方式3
                         后读写高字节     100  方式4
                                                   101 方式5
61H是8255口PB口的地址,8253定时器的控制端由PB1和PB0控制,PB0控制GATE,PB1控制扬声器的输出,只有当PB0和PB1为1的时候,由8253控制的扬声器才能发声。
定时器通道3的GATE端与61H端口的bit0位相连，如果把61H端口的bit0位置为1，那么定时器通道3就会被启动，若61H的端口bit0位为0，则定时器被关闭。
扬声器控制原理
8255的地址为：60H~63H;PB端口地址为61H,控制口为63H；
8253的地址为：40H~43H;通道2地址42H，控制口地址43H。
PC的扬声器以计数器2为核心。计数器8255的CLK2的输入频率为1.193182MHz，工作于方式3，改变计数器初值可以得到不同频率的方波输出。
1.演示步骤
实例演示的内容比较丰富，具体演示步骤如下：
（1）在实方式下作必要准备后，切换到保护方式。
（2）进入保护方式的临时代码段后，把演示任务的TSS段描述符装入TR，设置演示任务的堆栈。
（3）进入演示代码段，演示代码段的特权级是0。
（4）通过任务门调用测试任务1。测试任务1能够顺利执行。
（5）通过任务门调用测试任务2。测试任务2演示由于违反I/O许可位图规定而导致通用保护异常。
（6）通过任务门调用测试任务3。测试任务3演示I/O敏感指令如何引起通用保护异常。
（7）通过任务门调用测试任务4。测试任务4演示特权指令如何引起通用保护异常。
（8）从演示代码转临时代码，准备返回实方式。
（9）返回实方式，并作结束处理。
2.源程序组织和清单
为了达到演示目的，实例除了演示任务外，还涉及四个测试任务和一个通用保护故障处理任务。实例有如下几部分组成：
（1）全局描述符表GDT和中断描述符表IDT；
（2）其他中断/异常处理程序代码段；
（3）通用保护故障处理任务的任务状态段、堆栈段和代码段；
（4）四个测试任务合用的任务状态段、堆栈段和代码段；
（5）演示任务的任务状态段、堆栈段和代码段；
（6）演示任务的临时代码段；
（7）实方式下执行的启动和结束程序代码段和数据段。
实例九源程序清单如下：
；程序名：T10-9.ASM
；功能：演示I/O保护及I/O敏感指令的作用
DESCRIPTOR STRUC
LIMITL DW 0
BASEL DW 0
BASEM DB 0
ATTRIBUTES DW 0
BASEH DB 0
DESCRIPTOR ENDS
GATE STRUC
OFFSETL DW 0
SELECTOR DW 0
DCOUNT DB 0
GTYPE DB 0
OFFSETH DW 0
GATE ENDS
PDESC STRUC
LIMIT DW 0
BASE DD 0
PDESC ENDS
TASKSS STRUC
TRLINK DW ?,0
TRESP0 DD ?
TRSS0 DW ?,0
TRESP1 DD ?
TRSS1 DW ?,0
TRESP2 DD ?
TRSS2 DW ?,0
TRCR3 DD ?
TREIP DD ?
TREFLAG DW ?,?
TREAX DD ?
TRECX DD ?
TREDX DD ?
TREBX DD ?
TRESP DD ?
TREBP DD ?
TRESI DD ?
TREDI DD ?
TRES DW ?,0
TRCS DW ?,0
TRSS DW ?,0
TRDS DW ?,0
TRFS DW ?,0
TRGS DW ?,0
TRLDT DW ?,0
TRFLAG DW 0
TRIOMAP DW $ + 2
TASKSS ENDS
ATDR = 90H
ATDW = 92H
ATDWA = 93H
ATCE = 98H
ATCER = 9AH
ATCCO = 9CH
ATCCOR = 9EH
ATLDT = 82H
ATTASKGAT = 85H
AT386TSS = 89H
AT386CGAT = 8CH
AT386IGAT = 8EH
AT386TGAT = 8FH
DPL1 = 20H
DPL2 = 40H
DPL3 = 60H
RPL1 = 01H
RPL2 = 02H
RPL3 = 03H
IOPL1 = 1000H
IOPL2 = 2000H
IOPL3 = 3000H
D32 = 4000H
TIL = 04H
VMFL = 0002H
IFL = 0200H
JUMP32 MACRO selector,offsetv
DB 0EAH
DW offsetv
DW 0
DW selector
ENDM
CALL32 MACRO selector,offsetv
DB 9AH
DW offsetv
DW 0
DW selector
ENDM
JUMP16 MACRO selector,offsetv
DB 0EAH
DW offsetv
DW selector
ENDM
CALL16 MACRO selector,offsetv
DB 9AH
DW offsetv
DW selector
ENDM
.386P
GDTSEG SEGMENT PARA USE16
GDT LABEL BYTE
DUMMY DESCRIPTOR <>
NORMAL DESCRIPTOR <0FFFFH,0,0,ATDW,0>
NORMAL_SEL = NORMAL - GDT
EFFGDT LABEL BYTE
EFFGDTOFF = $ - GDT
VIDEOBUFF DESCRIPTOR <4000 - 1,0B800H,,ATDW + DPL3,>
VIDEOBUFF_SEL = VIDEOBUFF - GDT
DEMOTSS DESCRIPTOR <DEMOTSSLEN - 1,DEMOTSSSEG,,AT386TSS,>
DEMOTSS_SEL = DEMOTSS - GDT
DEMOSTACK DESCRIPTOR <DEMOSTACKLEN - 1,DEMOSTACKSEG,,ATDW + D32,>
DEMOSTACK_SEL = DEMOSTACK - GDT
DEMOCODE DESCRIPTOR <DEMOCODELEN - 1,DEMOCODESEG,,ATCE + D32,>
DEMOCODE_SEL = DEMOCODE - GDT
TEMPCODE DESCRIPTOR <0FFFFH,TEMPCODESEG,,ATCE,>
TEMPCODE_SEL = TEMPCODE - GDT
TOGDT DESCRIPTOR <GDTLEN - 1,GDTSEG,,ATDW,>
TOGDT_SEL = TOGDT - GDT
TOGPTSS DESCRIPTOR <GPTSSLEN - 1,GPTSSSEG,,ATDW,>
TOGPTSS_SEL = TOGPTSS - GDT
TOTESTTSS DESCRIPTOR <TESTTSSLEN - 1,TESTTSSSEG,,ATDW,>
TOTESTTSS_SEL = TOTESTTSS - GDT
TESTTSS DESCRIPTOR <TESTTSSLEN - 1,TESTTSSSEG,,AT386TSS,>
TESTTSS_SEL = TESTTSS - GDT
TEST1STACK DESCRIPTOR <TESTSTACKLEN - 1,TESTSTACKSEG,,ATDW + D32 + DPL1,>
TEST1STACK_SEL = (TEST1STACK - GDT) + RPL1
TEST1CODE DESCRIPTOR <TESTCODELEN - 1,TESTCODESEG,,ATCE + D32 + DPL1,>
TEST1CODE_SEL = (TEST1CODE - GDT) + RPL1
TEST2STACK DESCRIPTOR <TESTSTACKLEN - 1,TESTSTACKSEG,,ATDW + D32 + DPL2,>
TEST2STACK_SEL = (TEST2STACK - GDT) + RPL2
TEST2CODE DESCRIPTOR <TESTCODELEN - 1,TESTCODESEG,,ATCE + D32 + DPL2,>
TEST2CODE_SEL = (TEST2CODE - GDT) + RPL2
TEST3STACK DESCRIPTOR <TESTSTACKLEN - 1,TESTSTACKSEG,,ATDW + D32 + DPL3,>
TEST3STACK_SEL = (TEST3STACK - GDT) + RPL3
TEST3CODE DESCRIPTOR <TESTCODELEN - 1,TESTCODESEG,,ATCE + D32 + DPL3,>
TEST3CODE_SEL = (TEST3CODE - GDT) + RPL3
GPTSS DESCRIPTOR <GPTSSLEN - 1,GPTSSSEG,,AT386TSS,>
GPTSS_SEL = GPTSS - GDT
GPSTACK DESCRIPTOR <GPSTACKLEN - 1,GPSTACKSEG,,ATDW + D32,>
GPSTACK_SEL = GPSTACK - GDT
GPCODE DESCRIPTOR <GPCODELEN - 1,GPCODESEG,,ATCE + D32,>
GPCODE_SEL = GPCODE - GDT
ERRCODE DESCRIPTOR <ERRCODELEN - 1,ERRCODESEG,,ATCCOR + D32,>
ERRCODE_SEL = ERRCODE - GDT
GDNUM = ($ - EFFGDT) / 8
TESTTASK GATE <0,TESTTSS_SEL,0,ATTASKGAT,0>
TESTTASK_SEL = TESTTASK - GDT
GDTLEN = $ - GDT
GDTSEG ENDS
IDTSEG SEGMENT PARA USE16
IDT LABEL BYTE
REPT 13
GATE <ERRBEGINOFF,ERRCODE_SEL,0,AT386TGAT,0>
ENDM
INT0D GATE <0,GPTSS_SEL,0,ATTASKGAT,0>
REPT 254 - 14
GATE <ERRBEGINOFF,ERRCODE_SEL,0,AT386TGAT,0>
ENDM
GATE <ERRBEGINOFF,ERRCODE_SEL,0,AT386TGAT,0>
GATE <ERRBEGINOFF,ERRCODE_SEL,0,AT386TGAT,0>
IDTLEN = $ - IDT
IDTSEG ENDS
ERRCODESEG SEGMENT PARA USE32
EFFERRC LABEL BYTE
ERRMESS DB 'Error................'
ERRMESSLEN = $ - EFFERRC
ASSUME CS:ERRCODESEG
ERRBEGINOFF = $ - EFFERRC
ERRBEGIN:CLD
MOV AX,ERRCODE_SEL
MOV DS,AX
LEA ESI,ERRMESS
MOV AX,VIDEOBUFF_SEL
MOV ES,AX
XOR EDI,EDI
MOV ECX,ERRMESSLEN
MOV AH,17H
ERR1:LODSB
STOSW
LOOP ERR1
JMP $
ERRCODELEN = $ - EFFERRC
ERRCODESEG ENDS
GPTSSSEG SEGMENT PARA USE16
GPTASKSS LABEL BYTE
DW 0,0
DW ?,0
DW ?,0
DW ?,0
DW ?,0
DD ?
DW ?,0
DD 0
DD GPBEGINOFF
DD ?
DD ?
DD ?
DD ?
DD ?
DD GPSTACKLEN
DD ?
DD ?
DD ?
DW VIDEOBUFF_SEL,0
DW GPCODE_SEL,0
DW GPSTACK_SEL,0
DW TOTESTTSS_SEL,0
DW TOGPTSS_SEL,0
DW 0,0
DW 0,0
DW 0
DW $ + 2
DB 0FFH
GPTSSLEN = $ - GPTASKSS
GPTSSSEG ENDS
GPSTACKSEG SEGMENT PARA USE32
GPSTACKLEN = 512
DB GPSTACKLEN DUP (0)
GPSTACKSEG ENDS
GPCODESEG SEGMENT PARA USE32
ASSUME CS:GPCODESEG
EFFGPC LABEL BYTE
GPSTART:XOR EDI,EDI
MOV EBX,OFFSET TESTTASKSS
MOV EDX,DWORD PTR [EBX].TRCS
CLD
CALL ECHOEDX
MOV AX,(17H SHL 8) + ':'
STOSW
MOV EDX,[EBX].TREIP
CALL ECHOEDX
MOV ECX,81234567H
LOOP $
MOV EBX,OFFSET GPTASKSS
MOV AX,DEMOTSS_SEL
MOV FS:[EBX].TRLINK,AX
IRETD
GPBEGINOFF = $ - EFFGPC
GPBEGIN:JMP GPSTART
ECHOEDX PROC NEAR
MOV AH,17H
MOV ECX,8
ECHOEDX1:ROL EDX,4
MOV AL,DL
CALL HTOASC
STOSW
LOOP ECHOEDX1
RET
ECHOEDX ENDP
HTOASC PROC NEAR
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
RET
HTOASC ENDP
GPCODELEN = $ - EFFGPC
GPCODESEG ENDS
TESTTSSSEG SEGMENT PARA USE16
EFFTESTTSS LABEL BYTE
TESTTASKSS TASKSS <>
IOMAP LABEL BYTE
DB 8 DUP (0)
DB 11000100B
DB 00111011B
DB 0,0
DB 11110010B
DB 0
DB 0FFH
TESTTSSLEN = $ - EFFTESTTSS
TESTTSSSEG ENDS
TESTSTACKSEG SEGMENT PARA USE32
TESTSTACKLEN = 1024
DB TESTSTACKLEN DUP (0)
TESTSTACKSEG ENDS
TESTCODESEG SEGMENT PARA USE32
ASSUME CS:TESTCODESEG
EFFTESTC LABEL BYTE
TEST3BEGINOFF = $ - EFFTESTC
TEST3BEGIN:CLI
CLTS
IRETD
TESTBEGINOFF = $ - EFFTESTC
TESTBEGIN:MOV AL,0B6H
OUT 43H,AL
MOV AL,2
OUT 42H,AL
MOV AL,34H
OUT 42H,AL
IN AL,61H
MOV AH,AL
OR AL,3
OUT 61H,AL
MOV ECX,81234567H
LOOP $
MOV AL,AH
OUT 61H,AL
IRETD
TESTCODELEN = $ - EFFTESTC
TESTCODESEG ENDS
DEMOTSSSEG SEGMENT PARA USE16
EFFDEMOTSS LABEL BYTE
DEMOTASKSS TASKSS <>
DB 0FFH
DEMOTSSLEN = $ - EFFDEMOTSS
DEMOTSSSEG ENDS
DEMOSTACKSEG SEGMENT PARA USE32
DEMOSTACKLEN = 1024
DB DEMOSTACKLEN DUP (0)
DEMOSTACKSEG ENDS
DEMOCODESEG SEGMENT PARA USE32
ASSUME CS:DEMOCODESEG
EFFDEMOC LABEL BYTE
DEMOBEGINOFF = $ - EFFDEMOC
DEMOBEGIN:MOV AX,TOTESTTSS_SEL
MOV DS,AX
MOV EBX,OFFSET TESTTASKSS
MOV WORD PTR [EBX].TRSS,TEST1STACK_SEL
MOV DWORD PTR [EBX].TRESP,TESTSTACKLEN
MOV WORD PTR [EBX].TRCS,TEST1CODE_SEL
MOV DWORD PTR [EBX].TREIP,TESTBEGINOFF
MOV DWORD PTR [EBX].TREFLAG,IOPL1
CALL32 TESTTASK_SEL,0
MOV WORD PTR [EBX].TRSS,TEST2STACK_SEL
MOV DWORD PTR [EBX].TRESP,TESTSTACKLEN
MOV WORD PTR [EBX].TRCS,TEST2CODE_SEL
MOV DWORD PTR [EBX].TREIP,TESTBEGINOFF
MOV DWORD PTR [EBX].TREFLAG,IOPL1
CALL32 TESTTASK_SEL,0
MOV AX,TOGDT_SEL
MOV FS,AX
MOV FS:TESTTSS.ATTRIBUTES,AT386TSS
MOV WORD PTR [EBX].TRSS,TEST3STACK_SEL
MOV DWORD PTR [EBX].TRESP,TESTSTACKLEN
MOV WORD PTR [EBX].TRCS,TEST3CODE_SEL
MOV DWORD PTR [EBX].TREIP,TEST3BEGINOFF
MOV DWORD PTR [EBX].TREFLAG,IOPL2
CALL32 TESTTASK_SEL,0
MOV AX,TOGDT_SEL
MOV FS,AX
MOV FS:TESTTSS.ATTRIBUTES,AT386TSS
MOV WORD PTR [EBX].TRSS,TEST3STACK_SEL
MOV DWORD PTR [EBX].TRESP,TESTSTACKLEN
MOV WORD PTR [EBX].TRCS,TEST3CODE_SEL
MOV DWORD PTR [EBX].TREIP,TEST3BEGINOFF
MOV DWORD PTR [EBX].TREFLAG,IOPL3
CALL32 TESTTASK_SEL,0
OVER:JUMP32 TEMPCODE_SEL,TODOSOFF
DEMOCODELEN = $ - EFFDEMOC
DEMOCODESEG ENDS
TEMPCODESEG SEGMENT PARA USE16
ASSUME CS:TEMPCODESEG
EFFTEMPC LABEL BYTE
VIRTUALOFF = $ - EFFTEMPC
VIRTUAL:MOV AX,0
MOV DS,AX
MOV ES,AX
MOV FS,AX
MOV GS,AX
MOV AX,DEMOSTACK_SEL
MOV SS,AX
MOV ESP,DEMOSTACKLEN
MOV AX,DEMOTSS_SEL
LTR AX
JUMP16 DEMOCODE_SEL,DEMOBEGINOFF
TODOSOFF = $ - EFFTEMPC
TODOS:CLTS
MOV AX,NORMAL_SEL
MOV DS,AX
MOV ES,AX
MOV FS,AX
MOV GS,AX
MOV SS,AX
MOV EAX,CR0
AND EAX,0FFFFFFFEH
MOV CR0,EAX
JUMP16 <SEG REAL>,<OFFSET REAL>
TEMPCODELEN = $ - EFFTEMPC
TEMPCODESEG ENDS
RDATASEG SEGMENT PARA USE16
VGDTR PDESC <GDTLEN - 1,>
VIDTR PDESC <IDTLEN - 1,>
NORVIDTR PDESC <3FFH,0>
SPVAR DW ?
SSVAR DW ?
RDATASEG ENDS
RCODESEG SEGMENT PARA USE16
ASSUME CS:RCODESEG,DS:RDATASEG
START:MOV AX,RDATASEG
MOV DS,AX
CLD
CALL INIT_GDT
CALL INIT_IDT
LGDT QWORD PTR VGDTR
MOV WORD PTR SSVAR,SS
MOV WORD PTR SPVAR,SP
SIDT NORVIDTR
CLI
LIDT QWORD PTR VIDTR
MOV EAX,CR0
OR EAX,1
MOV CR0,EAX
JUMP16 TEMPCODE_SEL,VIRTUALOFF
REAL:MOV AX,RDATASEG
MOV DS,AX
LSS SP,DWORD PTR SPVAR
LIDT NORVIDTR
STI
MOV AX,4C00H
INT 21H
INIT_GDT PROC NEAR
PUSH DS
MOV AX,GDTSEG
MOV DS,AX
MOV CX,GDNUM
MOV SI,EFFGDTOFF
INITG:MOV AX,[SI].BASEL
MOVZX EAX,AX
SHL EAX,4
SHLD EDX,EAX,16
MOV [SI].BASEL,AX
MOV [SI].BASEM,DL
MOV [SI].BASEH,DH
ADD SI,8
LOOP INITG
POP DS
MOV BX,16
MOV AX,GDTSEG
MUL BX
MOV WORD PTR VGDTR.BASE,AX
MOV WORD PTR VGDTR.BASE+2,DX
RET
INIT_GDT ENDP
INIT_IDT PROC NEAR
MOV BX,16
MOV AX,IDTSEG
MUL BX
MOV WORD PTR VIDTR.BASE,AX
MOV WORD PTR VIDTR.BASE+2,DX
RET
INIT_IDT ENDP
RCODESEG ENDS
END START
在XP下使用tasm t463.asm编译，tlink /3 t463.obj链接
在DOS下运行t463.exe，c:\TASM16\T463.exe
扬声器发出声音
依次在屏幕左上角以蓝底白色显示如下信息
第一次
00000072:0000000A
第二次
00000083:00000000
第三次
00000083:00000001
3.关于实例九的说明
为了节省篇幅，同时也反映任务状态段的作用，实例通过任务门调用的四个测试任务合用一个任务状态段。
从源程序可见，这种合用，实际上是串行的。先把测试任务1的入口点填入测试任务状态段，同时填入堆栈指针，然后调用测试任务1。
在测试任务1完成后，再填入测试任务2的入口点，也填入堆栈指针，然后调用测试任务2。依次类推。通用保护故障处理程序作为一个独立的任务出现。
在发生通用保护故障后，通用保护故障处理程序在屏幕的左上角显示故障点的选择子和偏移，然后通过调整存放在任务状态段内的任务链接指针的方法，
终止引起故障的测试任务。
实例的其他实现细节作为习题留给读者思考。
10.10分页管理机制
80386开始支持存储器分页管理机制。分页机制是存储器管理机制的第二部分。段管理机制实现虚拟地址（由段和偏移构成的逻辑地址）到线性地址的转换，
分页管理机制实现线性地址到物理地址的转换。如果不启用分页管理机制，那么线性地址就作为物理地址。本节介绍80386的存储器分页管理机制和线性地址如何转换为物理地址。
10.10.1存储器分页管理机制
在保护方式下，控制寄存器CR0中的最高位PG位控制分页管理机制是否生效。如果PG=1，分页机制生效，把线性地址转换为物理地址。
如果PG=0，分页机制无效，线性地址就直接作为物理地址。请参见图10.1。必须注意，只有在保护方式下分页机制才可能生效。
只有在保证使PE位为1的前提下，才能够使PG位为1，否则将引起通用保护异常。请参见表10.3。
分页机制把线性地址空间和物理地址空间分别划分为大小相同的块。这样的块称之为页。通过在线性地址空间的页与物理地址空间的页之间建立的映射，
分页机制实现线性地址到物理地址的转换。线性地址空间的页与物理地址空间的页之间的映射可根据需要而确立，可根据需要而改变。
图10.26反映了线性地址空间的部分页与物理地址空间的部分页之间的映射关系，线性地址空间的任何一页，可以映射为物理地址空间中的任何一页。
采用分页管理机制实现线性地址到物理地址转换映射的主要目的是便于实现虚拟存储器。不像段的大小可变，页的大小是相等并固定的。
根据程序的逻辑划分段，而根据实现虚拟存储的方便划分页。
在80386中，页的大小固定为4K字节，每一页的边界地址必须是4K的倍数。因此，4G大小的地址空间被划分为1M个页，页的开始地址具有“XXXXX000H”的形式。为此，
我们把页开始地址的高20位XXXXXH称为页码。线性地址空间页的页码也就是页开始边界线性地址的高20位；物理地址空间页的页码也就是页开始边界物理地址的高20位。
可见，页码左移12位就是页开始地址，所以页码规定了页。
由于页的大小固定为4K字节，且页的边界是4K的倍数，所以在把32位线性地址转换成32位物理地址的过程中，低12位地址可以保持不变。也就是说，
线性地址的低12位就是物理地址的低12位。假设分页机制采用的转换映射把线性地址空间的XXXXXH页映射到物理地址空间的YYYYYH页，
那么线性地址XXXXXxxxH被转换为YYYYYxxxH。
因此，线性地址到物理地址的转换要解决的是线性地址空间页到物理地址空间页的映射，也就是线性地址高20位到物理地址高20位的转换。
10.10.2线性地址到物理地址的转换
1.映射表结构
线性地址空间页到物理地址空间页之间的映射用表来描述。由于4G的地址空间划分为1M个页，因此，如果用一张表来描述这种映射，那么该映射表就要有1M个表项，
如果每个表项占用4个字节，那么该映射表就要占用4M字节。为避免映射表占用如此巨大的存储器资源，所以80386把页映射表分为两级。
页映射表的第一级称为页目录表，存储在一个4K字节的物理页中。页目录表共有1K个表项，其中，每个表项为4字节长，包含对应第二级表所在物理地址空间页的页码。
页映射表的第二级称为页表，每张页表也安排在一个4K字节的页中。每张页表都有1K个表项，每个表项为4字节长，包含对应物理地址空间页的页码。
由于页目录表和页表均由1K个表项组成，所以使用10位就能指定表项。
图10.27示出了由页目录表和页表构成的页映射表结构。从图10.27中可见，控制寄存器CR3指定页目录表；页目录表可以指定1K个页表，这些页表可以分散存放在任意的物理页中，
而不需要连续存放；每张页表可以指定1K个物理地址空间页，这些物理地址空间页可以任意地分散在物理地址空间中。
       31                                            16 15        11                 4   3   2    1     0
CR0 PG 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 ET TS EM MP PE
CR1 保留
CR2 页故障线性地址
CR3 页目录表物理页码                                      0 0 0 0 0 0 0 0 0 0 0 0
31                  12   11   10   9   8   7   6   5   4   3   2   1   0
      物理页码          AVL           0   0   D   A  0   0   U   R   P
                                                                            S   W
2.表项格式
页目录表和页表中的表项都采用如图10.28所示的格式。从图可见，最高20位（位12至位31）包含物理地址空间页的页码，也就是物理地址的高20位。低12位包含页的属性。
图10.28所示属性中内容为0的位是Intel公司为80486等处理器留下的保留位，在为80386编程使用到它们时必须设置成0。在位9至位11的AVL字段供软件使用。
表项的最低位是存在属性位，记作P。P位表示该表项是否有效。P=1表项有效；P=0表项无效，表项中其余各位均可供软件使用，80386不解释P=0的表项中的任何其他的位。
在通过页目录表和页表进行的线性地址到物理地址的转换过程中，无论在页目录表或页表中遇到无效表项，都会引起页故障。
其他属性位的作用在下一小节中介绍。
3.线性地址到物理地址的转换
分页管理机制通过上述页目录表和页表实现32位线性地址到32位物理地址的转换。控制寄存器CR3的高20位作为页目录表所在目录页的页码。
首先，把线性地址的最高10位（即位22至位31）作为页目录表的索引，对应表项所包含的页码指定页表；
然后，再把线性地址的中间10位（即位12至位21）作为已指定页表的索引，对应表项所包含的页码指定物理地址空间中的一页；
最后，把已指定物理页的页码作为高20位，把线性地址的低12不加改变直接作为低12位，构成32位物理地址。
图10.29示出了分页管理机制通过页目录表和页表实现32位线性地址到32位物理地址的转换过程。设分页管理机制有效，CR3的内容是00200000H，
部分页目录表项和对应的部分页表项如图10.30所示，线性地址00402567H被转换成物理地址00303567H。
由CR3得到页目录表的基地址是00200000H，线性地址00402567H的高10位是001H，作为页目录表中的索引，所以对应表项的物理地址是00200004H；
从该表项得到页表所在物理页的页码是00201H，也即页表所在物理页的基地址是00201000H，线性地址的中间10位是002H，作为页表中的索引，
所以对应表项的物理地址是00201008H；从该表项得到物理页的页码是00303H；线性地址的低12位是567H，直接作为物理地址的低12位，于是得物理地址是00303567H。
基于上述假设，线性地址000F0123H被转换成物理地址000B8123H；线性地址00000987H被转换成物理地址00000987H，与线性地址相同。
000F0123H = (000H) + (0F0H) + 123H = (00202000 + 3C0H) + 123H = 000B8000 + 123H = 000B8123H
00000987H = (000H) + (000H) + 987H = (00202000 + 000H) + 987H = 00000000 + 987H = 00000987H
4.不存在的页表
采用如图10.27所示结构的页映射表，存储全部1K张页表需要4M字节，此外还需要4K字节用于存储页目录表。
这样的两级页映射表似乎反而要比单一的整张页映射表多占用4K字节。其实不然，事实上不需要在内存存储完整的两级页映射表。
两级页映射表结构中对于线性地址空间中不存在的或未使用的部分不必分配页表。除必须给页目录表分配物理页外，仅当在需要时才给页表分配物理页，
于是页映射表的大小就对应于实际使用的线性地址空间大小。因为任何一个实际运行的程序使用的线性地址空间，都远小于4G字节，
所以用于分配给页表的物理页也远小于4M字节。
页目录表项中的存在位P表明对应页表是否有效。如果P=1，表明对应页表有效，可利用它进行地址转换；如果P=0，表明对应页表无效。
如果试图通过无效的页表进行线性地址到物理地址的转换，那么将引起页故障。因此，页目录表项中的属性位P使得操作系统只给实际使用的线性地址范围的页表分配物理页。
页目录表项中的属性位P也可用于把页表存储在虚拟存储器中。当发生由于所需页表无效而引起的页故障时，页故障处理程序再申请物理页，从磁盘上把对应的页表读入，
把对应页目录表项中的P位置1。换句话说，可以当需要时才为所要的页表分配物理页。这样，页表占用的物理页数量可降到最小。
5.页的共享
从如图10.27所示的页映射表结构可见，分页机制没有全局页和局部页的规定。每一个任务可使用自己的页映射表独立地实现线性地址到物理地址的转换。
但是，如果使每一个任务所用的页映射表具有部分相同的映射，那么也就可以实现部分页的共享。
常用的实现页共享的方法是线性地址空间的共享。也就是不同任务的部分相同的线性地址空间的映射信息相同.具体表现为部分页表相同或页表内的部分表项的页码相同。
例如：如果任务A和任务B分别使用的页目录表A和页目录表B内的第0项中的页码相同，也就是页表0相同，
那么任务A和任务B的00000000H至003FFFFFH线性地址空间就映射到相同的物理页。再如，任务A和任务B使用的页表0不同，但这两张页表内第0至第0FFH项的页码对应相同，
那么任务A和任务B的00000000H至000FFFFFH线性地址空间就映射到相同的物理页。
10.10.3页级保护和虚拟存储器支持
在如图10.28所示格式的表项中，安排了用于页级保护的属性位和用于支持虚拟存储器的属性位。
1.页级保护
80386不仅提供段级保护，也提供页级保护。分页机制只区分两种特权级。特权级0、1和2统称为系统特权级，特权级3称为用户特权级。
在如图10.28所示页目录表和页表的表项中保护属性位R/W和U/S就是用于对页的保护。
表项的位1是读/写属性位，记作R/W。R/W位指示该表项所指定的页是否可读、写或执行。
如R/W=1，对表项所指定页可进行读、写或执行；如R/W=0，对表项所指定页可读或执行，但不能对该指定页写。
但是，R/W位对页的写保护只在处理器处于用户特权级时发挥作用：当处理器处于系统特权级时，R/W位被忽略，也即总可以读、写或执行。
表项的位2是用户/系统属性位，记作U/S。U/S位指示该表项所指定的页是否是用户级页。如U/S=1，表项所指定页是用户级页，可由任何特权级下执行的程序访问；
如U/S=0，表项所指定页是系统级页，只能由在系统特权级下执行的程序访问。
表10.11页级保护属性
U/S                  R/W                  用户级访问权限                  系统级访问权限
0                      0                       无                                      读/写/执行
0                      1                       无                                      读/写/执行
1                      0                       读/执行                              读/写/执行
1                      1                       读/写/执行                          读/写/执行
表10.11列出了在上述属性位R/W和U/S所确定的页级保护下，用户级程序和系统级程序分别具有的对用户级页和系统级页进行操作的权限。
用户级页可以规定为只允许读/执行或者规定为读/写/执行。系统级页对于系统级程序总是可读/写/执行，而对用户程序级程序总是不可访问的。
与分段机制一样，外层用户级执行的程序只能访问用户级的页，而内层系统级执行的程序，既可访问系统级页，也可访问用户级页。
与分段机制不同的是，在内层系统级执行的程序，对任何页都有读/写/执行访问权，即使规定为只允许读/执行的用户页，内层系统级程序也对该页有写访问权。
页目录表项中的保护属性位R/W和U/S对由该表项指定页表所指定的全部1K个页起到保护作用。
所以，对页访问时引用的保护属性位R/W和U/S的值是组合计算页目录表项和页表项中的保护属性位的值所得。
表10.12列出了组合计算前后的保护属性位值，组合计算是“与”操作。
例如：假设某页表中的某项的R/W=1和U/S=1，表示所指定页是可由用户级程序读/写/执行的用户级页。如果指定该页表的页目录项中的R/W=0，U/S=1，
那么用户级程序实际上可对该页的访问被限制为读/执行；如果指定该页表的页目录项中的R/W=1，U/S=0，那么实际上用户级程序没有对该页的访问权。
表10.12组合页保护属性
目录表项U/S      页表项U/S      组合U/S      目录表项R/W      页表项R/W      组合R/W
0                           0                      0           0                        0                     0
0                           1                      0           0                        1                     0
1                           0                      0           1                         0                    0
1                           1                      1           1                         1                    1
正如在80386地址转换机制中分页机制在分段机制之后起作用一样，由分页机制支持的页级保护也在由分段机制支持的段级保护之后起作用。
先测试有关的段级保护，如果启用分页机制，那么在检查通过后；再测试页级保护。
例如，设启用分页机制和当前特权级是3，那么，对于一个存储单元，仅当其所在段及页都允许写入时，该存储单元才是可写的；
如果段的类型为读/写，而页规定为只允许读/执行，那么不允许写；如果段的类型为只读/执行，那么不论页保护如何，也不允许写。
页级保护的检查是在线性地址转换成物理地址的过程中进行的，如果违反页保护属性的规定，对页进行访问（读/写/执行），那么将引起页异常。
2.对虚拟存储器的支持
页表项中的P位是支持采用分页机制虚拟存储器的关键。P=1，表示表项指定的页存在于物理存储器中，并且表项的高20位是物理页的页码；
P=0表示该线性地址空间中的页所对应的物理地址空间中的页不在物理存储器中。如果程序访问不存在的页，会引起页异常，这样操作系统可把该不存在的页从磁盘上读入，
把所在物理页的页码填入对应表项和把表项中的P置为1，然后使引起异常的程序恢复运行。
此外，在如图10.28所示表项中的访问位A和写标志位D也用于支持有效地实现虚拟存储器。
表项的位5是访问属性位，记作A。在为了访问某存储单元而进行线性地址到物理地址的转换过程中，
处理器总要把页目录表内的对应表项和其所指定页表内的对应表项中的A位置1，除非页表或页不存在，或者访问违反保护属性规定。
所以A=1表示已访问过对应的物理页。处理器永不清除A位。通过周期地检测及清除A位、操作系统就可确定哪些页在最近一段时间未被访问过。
当存储器资源紧缺时，这些最近未被访问的页很可能就被选择出来，将它们从内存换出到磁盘上去。
表项的位6是写标志位，记作D。在为了访问某存储单元而进行线性地址到物理地址的转换过程中，如果是写访问并且可以写访问，处理器就把页表内对应表项中的D位置1，
但并不把页目录表内对应表项中的D置1。当某页从磁盘上读入内存时，页表中对应表项的D位被清0。所以，D=1表示已写过对应的物理页。
当某页需要从内存换出到磁盘上去，如果该页的D位为1，那么必须进行写操作。但是，如果要写到磁盘上的页的D位为0，那么不需要实际的磁盘写操作，
而只要简单地放弃内存中的该页即可。因为内存中的页与磁盘中的页具有完全相同的内容。
10.10.4页异常
启用分页机制后，线性地址不再直接等于物理地址，线性地址要经过分页机制转换才成为物理地址。在转换过程中，如果出现下列情况之一就会引起页异常：
（1）涉及的页目录表内的表项或者页表内的表项中的P=0，也即涉及的页不在内存；
（2）发现试图违反页保护属性的规定而对页进行访问
报告页异常的中断向量号是14（0EH）。页异常属于故障类异常。在进入故障处理程序时，保存的CS及EIP指向发生故障的指令。
一旦引起页故障的原因被排除后，即可从页故障处理程序通过执行一条IRET指令直接地重新执行产生故障的指令。
当页故障发生时，处理器把引起页故障的线性地址装入控制寄存器CR2。页故障处理程序可以利用该线性地址确定对应的页目录项和页表项。
页故障还在堆栈中提供一个出错码，出错码的格式如图10.31所示。页故障的响应处理模式同其他故障一样。
15                  3   2   1   0
未使用                 U   W   P
在如图10.31所示的页故障出错码中，U位表示引起故障程序的特权级，U=1表示用户特权级（特权级3），U=0表示系统特权级（特权级0、1和2）；
W位表示访问类型，W=0表示读/执行，W=1表示写；P位表示异常类型，P=0表示页不存在故障，P=1表示保护故障。
31                  12   11   10   9   8   7   6   5   4   3   2   1   0
      物理页码          AVL           0   0   D   A  0   0   U   R   P
                                                                            S   W
10.10.5演示分页机制的实例（实例十）
下面给出一个演示如何启用分页管理机制的实例。
该实例的逻辑功能是，在屏幕上显示一条表示已启用分页管理机制的提示信息。
该实例演示内容包括：初始化页目录表和部分页表；启用分页管理机制；关闭分页管理机制等。该实例假设系统有4M字节物理内存。
1.演示步骤和源程序清单
为了简单化，实例只有一个任务，并且没有局部描述符表和中断描述符表，不允许中断，也不考虑发生异常，甚至没有使用堆栈。
实例执行步骤如下：
（1）在实方式下为进入保护方式作初始化；
（2）切换到保护方式后进入临时代码段，把部分演示代码传送到预定的内存，然后转演示代码段；
（3）建立页目录表，如图10.30所示；
（4）建立页表，如图10.30所示；
（5）启用分页管理机制；
（6）演示在分页管理机制启用后的程序执行和数据存取；
（7）关闭分页管理机制；
（8）退出保护方式，结束。
实例十源程序清单如下：
；程序名：T10-10.ASM
；功能：演示使用分页管理机制
DESCRIPTOR STRUC
LIMITL DW 0
BASEL DW 0
BASEM DB 0
ATTRIBUTES DW 0
BASEH DB 0
DESCRIPTOR ENDS
GATE STRUC
OFFSETL DW 0
SELECTOR DW 0
DCOUNT DB 0
GTYPE DB 0
OFFSETH DW 0
GATE ENDS
PDESC STRUC
LIMIT DW 0
BASE DD 0
PDESC ENDS
TASKSS STRUC
TRLINK DW ?,0
TRESP0 DD ?
TRSS0 DW ?,0
TRESP1 DD ?
TRSS1 DW ?,0
TRESP2 DD ?
TRSS2 DW ?,0
TRCR3 DD ?
TREIP DD ?
TREFLAG DW ?,?
TREAX DD ?
TRECX DD ?
TREDX DD ?
TREBX DD ?
TRESP DD ?
TREBP DD ?
TRESI DD ?
TREDI DD ?
TRES DW ?,0
TRCS DW ?,0
TRSS DW ?,0
TRDS DW ?,0
TRFS DW ?,0
TRGS DW ?,0
TRLDT DW ?,0
TRFLAG DW 0
TRIOMAP DW $ + 2
TASKSS ENDS
ATDR = 90H
ATDW = 92H
ATDWA = 93H
ATCE = 98H
ATCER = 9AH
ATCCO = 9CH
ATCCOR = 9EH
ATLDT = 82H
ATTASKGAT = 85H
AT386TSS = 89H
AT386CGAT = 8CH
AT386IGAT = 8EH
AT386TGAT = 8FH
DPL1 = 20H
DPL2 = 40H
DPL3 = 60H
RPL1 = 01H
RPL2 = 02H
RPL3 = 03H
IOPL1 = 1000H
IOPL2 = 2000H
IOPL3 = 3000H
D32 = 4000H
TIL = 04H
VMFL = 0002H
IFL = 0200H
JUMP32 MACRO selector,offsetv
DB 0EAH
DW offsetv
DW 0
DW selector
ENDM
CALL32 MACRO selector,offsetv
DB 9AH
DW offsetv
DW 0
DW selector
ENDM
JUMP16 MACRO selector,offsetv
DB 0EAH
DW offsetv
DW selector
ENDM
CALL16 MACRO selector,offsetv
DB 9AH
DW offsetv
DW selector
ENDM
PL = 1
RWR = 0
RWW = 2
USU = 0
USS = 4
PDT_AD = 200000H
PT0_AD = 202000H
PT1_AD = 201000H
PHVB_AD = 0B8000H
LOVB_AD = 0F0000H
MPVB_AD = 301000H
PHSC_AD = 303000H
LOSC_AD = 402000H
.386P
GDTSEG SEGMENT PARA USE16
GDT LABEL BYTE
DUMMY DESCRIPTOR <>
NORMAL DESCRIPTOR <0FFFFH,0,0,ATDW,0>
NORMAL_SEL = NORMAL - GDT
PDTABLE DESCRIPTOR <0FFFH,PDT_AD AND 0FFFFH,PDT_AD SHR 16,ATDW,0>
PDT_SEL = PDTABLE - GDT
PTABLE0 DESCRIPTOR <0FFFH,PT0_AD AND 0FFFFH,PT0_AD SHR 16,ATDW,0>
PT0_SEL = PTABLE0 - GDT
PTABLE1 DESCRIPTOR <0FFFH,PT1_AD AND 0FFFFH,PT1_AD SHR 16,ATDW,0>
PT1_SEL = PTABLE1 - GDT
LOVIDEOB DESCRIPTOR <3999,LOVB_AD AND 0FFFFH,LOVB_AD SHR 16,ATDW,0>
LOVIDEOB_SEL = LOVIDEOB - GDT
LOCODE DESCRIPTOR <SCODELEN - 1,LOSC_AD AND 0FFFFH,LOSC_AD SHR 16,ATCE,0>
LOCODE_SEL = LOCODE - GDT
TPSCODE DESCRIPTOR <SCODELEN - 1,PHSC_AD AND 0FFFFH,PHSC_AD SHR 16,ATDW,0>
TPSCODE_SEL = TPSCODE - GDT
EFFGDT LABEL BYTE
EFFGDTOFF = $ - GDT
TEMPCODE DESCRIPTOR <0FFFFH,TEMPCODESEG,,ATCE,>
TEMPCODE_SEL = TEMPCODE - GDT
DEMOCODE DESCRIPTOR <DEMOCODELEN - 1,DEMOCODESEG,,ATCE,>
DEMOCODE_SEL = DEMOCODE - GDT
DEMODATA DESCRIPTOR <DEMODATALEN - 1,DEMODATASEG,,ATDW,>
DEMODATA_SEL = DEMODATA - GDT
SCODE DESCRIPTOR <SCODELEN - 1,SCODESEG,,ATDR,>
SCODE_SEL = SCODE - GDT
GDNUM = ($ - EFFGDT) / 8
GDTLEN = $ - GDT
GDTSEG ENDS
SCODESEG SEGMENT PARA USE16
ASSUME CS:SCODESEG,DS:DEMODATASEG
EFFSCODE LABEL BYTE
SBEGINOFF = $ - EFFSCODE
SBEGIN:CLD
MOV AX,LOVIDEOB_SEL
MOV ES,AX
MOV DI,0
MOV AH,17H
MOV CX,MESSLEN
S1:LODSB
STOSW
LOOP S1
JUMP16 DEMOCODE_SEL,DEMO3OFF
MLEN = $ - SBEGIN
SCODELEN = $ - EFFSCODE
SCODESEG ENDS
DEMODATASEG SEGMENT PARA USE16
EFFDEMOD LABEL BYTE
MESS DB 'Page is ok!'
MESSLEN = $ - MESS
DEMODATALEN = $ - EFFDEMOD
DEMODATASEG ENDS
DEMOCODESEG SEGMENT PARA USE16
ASSUME CS:DEMOCODESEG
EFFDEMOC LABEL BYTE
DEMOBEGINOFF = $ - EFFDEMOC
DEMOBEGIN:CLD
MOV AX,PDT_SEL
MOV ES,AX
XOR DI,DI
MOV CX,1024
XOR EAX,EAX
REP STOSD
MOV DWORD PTR ES:[0],PT0_AD OR (USU + RWW + PL)
MOV DWORD PTR ES:[4],PT1_AD OR (USU + RWW + PL)
MOV AX,PT0_SEL
MOV ES,AX
XOR DI,DI
MOV CX,1024
XOR EAX,EAX
OR EAX,USU + RWW + PL
DEMO1:STOSD
ADD EAX,1000H
LOOP DEMO1
MOV DI,(PHVB_AD SHR 12) * 4
MOV DWORD PTR ES:[DI],MPVB_AD + USS + RWW + PL
MOV DI,(LOVB_AD SHR 12) * 4
MOV DWORD PTR ES:[DI],PHVB_AD + USU + RWW + PL
MOV AX,PT1_SEL
MOV ES,AX
XOR DI,DI
MOV CX,1024
MOV EAX,400000H
DEMO2:STOSD
ADD EAX,1000H
LOOP DEMO2
MOV DI,((LOSC_AD SHR 12) AND 3FFH) * 4
MOV DWORD PTR ES:[DI],PHSC_AD + USU + RWR + PL
MOV EAX,PDT_AD
MOV CR3,EAX
MOV EAX,CR0
OR EAX,80000000H
MOV CR0,EAX
JMP SHORT PAGEE
PAGEE:MOV AX,DEMODATA_SEL
MOV DS,AX
MOV SI,OFFSET MESS
JUMP16 LOCODE_SEL,SBEGINOFF
DEMO3OFF = $ - EFFDEMOC
DEMO3:MOV EAX,CR0
AND EAX,7FFFFFFFH
MOV CR0,EAX
JMP SHORT PAGED
PAGED:MOV AX,NORMAL_SEL
JUMP16 TEMPCODE_SEL,TODOSOFF
DEMOCODELEN = $ - EFFDEMOC
DEMOCODESEG ENDS
TEMPCODESEG SEGMENT PARA USE16
ASSUME CS:TEMPCODESEG
EFFTEMPC LABEL BYTE
VIRTUALOFF = $ - EFFTEMPC
VIRTUAL:CLD
MOV AX,SCODE_SEL
MOV DS,AX
MOV AX,TPSCODE_SEL
MOV ES,AX
MOV SI,SBEGINOFF
MOV DI,SI
MOV CX,MLEN
REP MOVSB
JUMP16 DEMOCODE_SEL,DEMOBEGINOFF
TODOSOFF = $ - EFFTEMPC
TODOS:MOV DS,AX
MOV ES,AX
MOV EAX,CR0
AND EAX,0FFFFFFFEH
MOV CR0,EAX
JUMP16 <SEG REAL>,<OFFSET REAL>
TEMPCODELEN = $ - EFFTEMPC
TEMPCODESEG ENDS
RCODESEG SEGMENT PARA USE16
ASSUME CS:RCODESEG,DS:RCODESEG
VGDTR PDESC <GDTLEN - 1,>
START:PUSH CS
POP DS
CLD
CALL INIT_GDT
CALL ENABLEA20
LGDT QWORD PTR VGDTR
CLI
MOV EAX,CR0
OR EAX,1
MOV CR0,EAX
JUMP16 TEMPCODE_SEL,VIRTUALOFF
REAL:CALL DISABLEA20
STI
MOV AX,4C00H
INT 21H
INIT_GDT PROC NEAR
PUSH DS
MOV AX,GDTSEG
MOV DS,AX
MOV CX,GDNUM
MOV SI,EFFGDTOFF
INITG:MOV AX,[SI].BASEL
MOVZX EAX,AX
SHL EAX,4
SHLD EDX,EAX,16
MOV [SI].BASEL,AX
MOV [SI].BASEM,DL
MOV [SI].BASEH,DH
ADD SI,8
LOOP INITG
POP DS
MOV BX,16
MOV AX,GDTSEG
MUL BX
MOV WORD PTR VGDTR.BASE,AX
MOV WORD PTR VGDTR.BASE+2,DX
RET
INIT_GDT ENDP
ENABLEA20 PROC
PUSH AX
IN AL,92H
OR AL,2
OUT 92H,AL
POP AX
RET
ENABLEA20 ENDP
DISABLEA20 PROC
PUSH AX
IN AL,92H
AND AL,0FDH
OUT 92H,AL
POP AX
RET
DISABLEA20 ENDP
RCODESEG ENDS
END START
测试通过的完整程序如下
DESCRIPTOR STRUC
LIMITL DW 0
BASEL DW 0
BASEM DB 0
ATTRIBUTES DW 0
BASEH DB 0
DESCRIPTOR ENDS
GATE STRUC
OFFSETL DW 0
SELECTOR DW 0
DCOUNT DB 0
GTYPE DB 0
OFFSETH DW 0
GATE ENDS
PDESC STRUC
LIMIT DW 0
BASE DD 0
PDESC ENDS
TASKSS STRUC
TRLINK DW ?,0
TRESP0 DD ?
TRSS0 DW ?,0
TRESP1 DD ?
TRSS1 DW ?,0
TRESP2 DD ?
TRSS2 DW ?,0
TRCR3 DD ?
TREIP DD ?
TREFLAG DW ?,?
TREAX DD ?
TRECX DD ?
TREDX DD ?
TREBX DD ?
TRESP DD ?
TREBP DD ?
TRESI DD ?
TREDI DD ?
TRES DW ?,0
TRCS DW ?,0
TRSS DW ?,0
TRDS DW ?,0
TRFS DW ?,0
TRGS DW ?,0
TRLDT DW ?,0
TRFLAG DW 0
TRIOMAP DW $ + 2
TASKSS ENDS
ATDR = 90H
ATDW = 92H
ATDWA = 93H
ATCE = 98H
ATCER = 9AH
ATCCO = 9CH
ATCCOR = 9EH
ATLDT = 82H
ATTASKGAT = 85H
AT386TSS = 89H
AT386CGAT = 8CH
AT386IGAT = 8EH
AT386TGAT = 8FH
DPL1 = 20H
DPL2 = 40H
DPL3 = 60H
RPL1 = 01H
RPL2 = 02H
RPL3 = 03H
IOPL1 = 1000H
IOPL2 = 2000H
IOPL3 = 3000H
D32 = 4000H
TIL = 04H
VMFL = 0002H
IFL = 0200H
JUMP32 MACRO selector,offsetv
DB 0EAH
DW offsetv
DW 0
DW selector
ENDM
CALL32 MACRO selector,offsetv
DB 9AH
DW offsetv
DW 0
DW selector
ENDM
JUMP16 MACRO selector,offsetv
DB 0EAH
DW offsetv
DW selector
ENDM
CALL16 MACRO selector,offsetv
DB 9AH
DW offsetv
DW selector
ENDM
PL = 1
RWR = 0
RWW = 2
USU = 0
USS = 4
.386P
GDTSEG SEGMENT PARA USE16
GDT LABEL BYTE
DUMMY DESCRIPTOR <>
NORMAL DESCRIPTOR <0FFFFH,0,0,ATDW,0>
NORMAL_SEL = NORMAL - GDT
PDTABLE DESCRIPTOR <0FFFH,200000H AND 0FFFFH,200000H SHR 16,ATDW,0>
PDT_SEL = PDTABLE - GDT
PTABLE0 DESCRIPTOR <0FFFH,202000H AND 0FFFFH,202000H SHR 16,ATDW,0>
PT0_SEL = PTABLE0 - GDT
PTABLE1 DESCRIPTOR <0FFFH,201000H AND 0FFFFH,201000H SHR 16,ATDW,0>
PT1_SEL = PTABLE1 - GDT
LOVIDEOB DESCRIPTOR <3999,0F0000H AND 0FFFFH,0F0000H SHR 16,ATDW,0>
LOVIDEOB_SEL = LOVIDEOB - GDT
LOCODE DESCRIPTOR <SCODELEN - 1,402000H AND 0FFFFH,402000H SHR 16,ATCE,0>
LOCODE_SEL = LOCODE - GDT
TPSCODE DESCRIPTOR <SCODELEN - 1,303000H AND 0FFFFH,303000H SHR 16,ATDW,0>
TPSCODE_SEL = TPSCODE - GDT
EFFGDT LABEL BYTE
EFFGDTOFF = $ - GDT
TEMPCODE DESCRIPTOR <0FFFFH,TEMPCODESEG,,ATCE,>
TEMPCODE_SEL = TEMPCODE - GDT
DEMOCODE DESCRIPTOR <DEMOCODELEN - 1,DEMOCODESEG,,ATCE,>
DEMOCODE_SEL = DEMOCODE - GDT
DEMODATA DESCRIPTOR <DEMODATALEN - 1,DEMODATASEG,,ATDW,>
DEMODATA_SEL = DEMODATA - GDT
SCODE DESCRIPTOR <SCODELEN - 1,SCODESEG,,ATDR,>
SCODE_SEL = SCODE - GDT
GDNUM = ($ - EFFGDT) / 8
GDTLEN = $ - GDT
GDTSEG ENDS
SCODESEG SEGMENT PARA USE16
ASSUME CS:SCODESEG,DS:DEMODATASEG
EFFSCODE LABEL BYTE
SBEGINOFF = $ - EFFSCODE
SBEGIN:CLD
MOV AX,LOVIDEOB_SEL
MOV ES,AX
MOV DI,0
MOV AH,17H
MOV CX,MESSLEN
S1:LODSB
STOSW
LOOP S1
JUMP16 DEMOCODE_SEL,DEMO3OFF
MLEN = $ - SBEGIN
SCODELEN = $ - EFFSCODE
SCODESEG ENDS
DEMODATASEG SEGMENT PARA USE16
EFFDEMOD LABEL BYTE
MESS DB 'Page is ok!'
MESSLEN = $ - MESS
DEMODATALEN = $ - EFFDEMOD
DEMODATASEG ENDS
DEMOCODESEG SEGMENT PARA USE16
ASSUME CS:DEMOCODESEG
EFFDEMOC LABEL BYTE
DEMOBEGINOFF = $ - EFFDEMOC
DEMOBEGIN:CLD
MOV AX,PDT_SEL
MOV ES,AX
XOR DI,DI
MOV CX,1024
XOR EAX,EAX
REP STOSD
MOV DWORD PTR ES:[0],202000H OR (USU + RWW + PL)
MOV DWORD PTR ES:[4],201000H OR (USU + RWW + PL)
MOV AX,PT0_SEL
MOV ES,AX
XOR DI,DI
MOV CX,1024
XOR EAX,EAX
OR EAX,USU + RWW + PL
DEMO1:STOSD
ADD EAX,1000H
LOOP DEMO1
MOV DI,(0B8000H SHR 12) * 4
MOV DWORD PTR ES:[DI],301000H + USS + RWW + PL
MOV DI,(0F0000H SHR 12) * 4
MOV DWORD PTR ES:[DI],0B8000H + USU + RWW + PL
MOV AX,PT1_SEL
MOV ES,AX
XOR DI,DI
MOV CX,1024
MOV EAX,400000H
DEMO2:STOSD
ADD EAX,1000H
LOOP DEMO2
MOV DI,((402000H SHR 12) AND 3FFH) * 4
MOV DWORD PTR ES:[DI],303000H + USU + RWR + PL
MOV EAX,200000H
MOV CR3,EAX
MOV EAX,CR0
OR EAX,80000000H
MOV CR0,EAX
JMP SHORT PAGEE
PAGEE:MOV AX,DEMODATA_SEL
MOV DS,AX
MOV SI,OFFSET MESS
JUMP16 LOCODE_SEL,SBEGINOFF
DEMO3OFF = $ - EFFDEMOC
DEMO3:MOV EAX,CR0
AND EAX,7FFFFFFFH
MOV CR0,EAX
JMP SHORT PAGED
PAGED:MOV AX,NORMAL_SEL
JUMP16 TEMPCODE_SEL,TODOSOFF
DEMOCODELEN = $ - EFFDEMOC
DEMOCODESEG ENDS
TEMPCODESEG SEGMENT PARA USE16
ASSUME CS:TEMPCODESEG
EFFTEMPC LABEL BYTE
VIRTUALOFF = $ - EFFTEMPC
VIRTUAL:CLD
MOV AX,SCODE_SEL
MOV DS,AX
MOV AX,TPSCODE_SEL
MOV ES,AX
MOV SI,SBEGINOFF
MOV DI,SI
MOV CX,MLEN
REP MOVSB
JUMP16 DEMOCODE_SEL,DEMOBEGINOFF
TODOSOFF = $ - EFFTEMPC
TODOS:MOV DS,AX
MOV ES,AX
MOV EAX,CR0
AND EAX,0FFFFFFFEH
MOV CR0,EAX
JUMP16 <SEG REAL>,<OFFSET REAL>
TEMPCODELEN = $ - EFFTEMPC
TEMPCODESEG ENDS
RCODESEG SEGMENT PARA USE16
ASSUME CS:RCODESEG,DS:RCODESEG
VGDTR PDESC <GDTLEN - 1,>
START:PUSH CS
POP DS
CLD
CALL INIT_GDT
CALL ENABLEA20
LGDT QWORD PTR VGDTR
CLI
MOV EAX,CR0
OR EAX,1
MOV CR0,EAX
JUMP16 TEMPCODE_SEL,VIRTUALOFF
REAL:CALL DISABLEA20
STI
MOV AX,4C00H
INT 21H
INIT_GDT PROC NEAR
PUSH DS
MOV AX,GDTSEG
MOV DS,AX
MOV CX,GDNUM
MOV SI,EFFGDTOFF
INITG:MOV AX,[SI].BASEL
MOVZX EAX,AX
SHL EAX,4
SHLD EDX,EAX,16
MOV [SI].BASEL,AX
MOV [SI].BASEM,DL
MOV [SI].BASEH,DH
ADD SI,8
LOOP INITG
POP DS
MOV BX,16
MOV AX,GDTSEG
MUL BX
MOV WORD PTR VGDTR.BASE,AX
MOV WORD PTR VGDTR.BASE+2,DX
RET
INIT_GDT ENDP
ENABLEA20 PROC
PUSH AX
IN AL,92H
OR AL,2
OUT 92H,AL
POP AX
RET
ENABLEA20 ENDP
DISABLEA20 PROC
PUSH AX
IN AL,92H
AND AL,0FDH
OUT 92H,AL
POP AX
RET
DISABLEA20 ENDP
RCODESEG ENDS
END START
在XP下使用tasm t465.asm编译，tlink /3 t465.obj链接
在DOS下运行t465.exe，c:\TASM16\T465.exe
在屏幕左上角以蓝底白色显示Page is ok!
2.关于实例十的说明
上述演示程序的许多内容与其他实例相同，下面仅就演示分页管理机制方面的内容作些说明：
（1）部分演示代码的移动
为了充分说明分页机制所实现的线性地址到物理地址的转换，在初始化时把部分演示代码移动到预定的内存区域。
预定的内存区域从00303000H开始，也即是页码为00303H的物理页。该部分演示代码的功能是显示指定的字符串。
在进入保护方式后做这初始化工作的原因是预定的内存区域在扩展内存中，注意初始化时还没有启用分页机制。
（2）页映射表的初始化
实例按如图10.30所示安排映射表。页目录表安排在页码为00200H的物理页中，页表0安排在页码为00202H的物理页中，页表1安排在页码为00201H的物理页中。
演示程序涉及的线性地址空间不超出007FFFFFH，所以只使用两张页表，为此页目录表中的其他项被置为无效（P=0）。
页表0把线性地址空间中的0000000H ~ 003FFFFFH映射到物理地址空间中。实例在初始化页表0时，使该线性地址空间直接映射到相同地址的物理地址空间，
除线性地址空间中页码为000B8H和000F0H这两页以外。000B8H页被映射到页码为00301H的物理页，而000F0H页被映射到页码为000B8H的物理页。
页表1把线性地址空间中的000000H~007FFFFFH映射到物理地址空间中。实例在初始化页表1时，似乎使该线性地址空间直接映射到相同地址的物理地址空间，
但是除了对应线性地址空间中00402H页的表项被另外设置外，其他表项中的P位为0，也即表示对应物理页不存在。
初始化后，页表1的第2项把线性地址空间中的00402H页，映射到页码为00303H的物理页，也就是存放部分演示代码的指定内存区域。
（3）启用分页管理机制
在建立好页映射表后，启用分页机制所要做的操作是简单的，只要把控制寄存器中的最高位，也就是PG位置1。具体指令如下：
MOV EAX,CR0
OR EAX,80000000H
MOV CR0,EAX
JMP SHORT PAGEE
PAGEE:
在启用分页机制前，线性地址就是物理地址；在启用分页机制后，线性地址要通过分页机制的转换，才成为物理地址。
尽管使用一条转移指令，可清除预取的指令，随后在取指令时使用的线性地址就要经过转换才成为物理地址。
为了保证顺利过渡，在启用分页机制之后的过渡阶段，仍要维持线性地址等同于物理地址。为了做到这一点，在建立页映射表时，
必须使实现过渡的代码所在的线性地址空间页映射到具有相同地址的物理地址空间页。实例中页表0就做到了这一点。
（4）关闭分页管理机制
只要把控制寄存器CR0中的PG位清0，便关闭分页机制。在这一过渡阶段，也要保持地址转换前后的一致。
（5）地址转换的演示
在启用分页机制之后，就转移到位于线性地址空间中00402000H处开始的代码，该部分代码的功能是显示提示信息"Page is ok!"。
实际上这部分代码存放在从物理地址00303000H开始的内存区域中，是在初始化时被移到此区域的。
在显示提示信息时，把要显示的字符ASCII和显示属性填到线性地址空间中000F0000H开始的区域中，而不是000B8000H开始的区域。
从在初始化时建立的映射表可见，线性地址空间中的000F0H页，被映射到物理地址空间中的000B8H页。
所以，向线性地址空间中的000F0H页写，实际上是向物理地址空间中的000B8H页写，也就是真正显示。
（6）页级保护的演示
在进入保护方式之后，特权级一直是0级。所以，无论系统级和用户级页，无论只能读/执行，还是读/执行/写，总是可进行各种形式的访问。
表10.7异常一览表
向量号         异常名称         异常类型         出错代码         相关指令
0              除法出错             故障               无                   DIV,IDIV
1              调试异常           故障/陷阱        无                    任何指令
3            单字节INT3         陷阱                无                    INT 3
4            溢出                    陷阱                无                    INTO
5            边界检查             故障                无                    BOUND
6          非法操作码            故障                无                   非法指令编码或操作数
7          设备不可用            故障                无                   浮点指令或WAIT
8          双重故障               中止                有                    任何指令
9         协处理器段越界      中止                无                    访问存储器的浮点指令
0A       无效TSS异常          故障                有                    JMP、CALL、IRET、中断
0B       段不存在异常         故障                 有                   装载段寄存器的任何指令
0C       堆栈段异常            故障                 有                   装载SS寄存器的任何指令 对SS寻址的段访问的任何指令
0D      通用保护异常         故障                 有                   任何特权指令 任何访问存储器的指令
0E      页异常                   故障                 有                   任何访问存储器的指令
10      协处理器出错          故障                无                    浮点指令或WAIT
00~FF 软中断                   陷阱                无                    INT n
表5.2部分中断向量的分配
向量号                  使用                  向量号                  使用
0                       除法出错               4                          溢出
1                       单步                      5                       打印屏幕
2                       非屏蔽中断            6                          保留
3                       断点                      7                          保留
8                       定时器                  0C                     串行通信接口1
9                       键盘                     0D                     硬盘（并行口）
0A              保留（从中断控制器） 0E                         软盘
0B                  串行通信接口2         0F                        打印机
10              视频显示                      17                      打印输出
11              设备配置                      18                   ROM BASIC
12              存储容量                      19                     系统自举
13              磁盘I/O                        1A                     时钟管理
14              串行I/O                        1B                Ctrl+ Break键处理
15            扩充的BIOS                    1C                      定时处理
16              键盘输入                   1D--1F                  参数指针
20--2F       DOS使用                   30--3F                 为DOS保留
10.11虚拟 8086方式
继推出80386之后，Intel又推出了80486、Pentium和Pentium PRO。这些处理器都具有实方式和保护方式两种工作模式。
前面已介绍过，实方式与8086方式兼容，可以运行DOS及以其为平台的几乎所有软件；但在实方式下，处理器不能发挥自身的优越性能，不能支持多用户、
多任务操作系统的运行。为了充分发挥处理器的功能，同时使DOS及以其为平台的软件继续有效地运行，从80386开始增加了虚拟8086方式。本节介绍虚拟8086方式。
31          18 17   16  15  14  13 12   11   10  9  8    7   6   5  4   3  2   1  0
                   VM  RF  0   NT  IOPL    OF  DF IF TF  SF ZF  0 AF 0  PF     CF
10.11.1 V86方式
1.V86方式
虚拟8086方式是保护方式下的一种工作方式，也称为V8086方式，或者简称为V86方式。在虚拟8086方式下，处理器类似于8086。寻址的地址空间是1M字节；
段寄存器的内容作为段值解释；20位存储单元地址由段值乘16加偏移构成。所以，在虚拟8086方式下，可以运行DOS及以其为平台的软件。
但V86方式毕竟是虚拟8086的一种方式，所以不完全等同于8086。
当如图9.2所示的标志寄存器中的标志VM为1时，处理器就处于V86方式。当处理器处于V86方式时，其当前特权级必定是3。
2.V86任务
8086程序可直接在V86方式下运行，而V86方式受到称为V86监控程序的控制。
V86监控程序和在V86方式下的8086程序构成的任务称为虚拟8086任务，或者简称为V86任务。V86任务形成一个由处理器硬件和属于系统软件的监控程序组成的“虚拟8086机"。
V86监控程序控制V86外部界面、中断和I/O。硬件提供该任务最低端1M字节线性地址空间的虚拟存储空间，包含虚拟寄存器的TSS，并执行处理这些寄存器和地址空间的指令。
80386把V86任务作为与其他任务具有同等地位的一个任务。它可以支持多个V86任务，每个V86任务是相对独立的。
所以，通过V86方式这种形式，运行8086程序可充分发挥处理器的能力和充分利用系统资源。
10.11.2进入和离开V86方式
保护方式和V86方式之间的切换情形如图10.32所示。图中左面部分为V86任务。
从图10.32可见，V86方式与保护方式的切换可发生在V86任务之内，这种切换是V86方式下的8086程序与保护方式下的监控程序之间的转换；
V86方式与保护方式的切换可发生在任务之间，这种切换是V86任务与其他任务的切换。此外，V86监控程序与其他任务之间的切换是普通的任务切换。
由于80386没有提供直接改变VM标志的指令，并且只有当前特权级CPL=0时，对VM的改变才有效，所以V86方式与保护方式的切换不能简单地通过设置或改变VM而进行。
下面介绍V86方式与保护方式之间的切换，也就是如何进入和离开V86方式。为了方便，先介绍如何离开V86方式。
1.离开V86方式
在V86方式下，如果处理器响应中断/异常，那么就会退出当前V86任务的V86方式。在V86方式下，处理器对中断/异常的响应处理不同于真正的8086，
而仍然采用保护方式下对中断/异常响应处理的方法。所以，在V86方式下，不是根据位于线性地址空间最低端的中断向量表内的对应中断向量转入处理程序，
而是根据中断描述符表IDT内的对应门描述符的指示转入处理程序。
（1）在V86任务内离开V86方式
如果对应的门描述符是386中断门或386陷阱门，那么就发生在当前V86任务内从V86方式到保护方式的转换。80386要求执行这种中断/异常处理程序时的CPL必须等于0。
由于V86方式下的CPL=3，而转换到保护方式后的CPL=0，所以这种转换包含了特权级的变换。
在按10.7节介绍的方法转入处理程序之前，处理器先将V86方式下的段寄存器GS、FS、DS及ES压入0级堆栈，并装入空选择子。
为保持使堆栈对齐，在把段寄存器压入堆栈时，一律按32位值压入，低16位是段寄存器的值，高16位为空。
于是，转换后的0级堆栈如图10.33所示。其中，段寄存器SS和CS的值也是V86方式下的段值。图（a）是没有出错码的情形；图（b）是有出错码的情形。请与图10.21作比较。
（a）是没有出错码的情形
PUSH GS
PUSH FS
PUSH DS
PUSH ES
PUSH SS
PUSH ESP
PUSH EFLAG
PUSH CS
PUSH EIP
（b）是有出错码的情形
PUSH GS
PUSH FS
PUSH DS
PUSH ES
PUSH SS
PUSH ESP
PUSH EFLAG
PUSH CS
PUSH EIP
PUSH 出错码
图10.21给出了通过中断门或陷阱门转移时的堆栈情况。
（a）是没有变换特权级和没有出错码的情形；
PUSH EFLAG
PUSH CS
PUSH EIP
（b）是没有变换特权级和有出错码的情形；
PUSH EFLAG
PUSH CS
PUSH EIP
PUSH 出错码
（c）是变换特权级和没有出错码的内层堆栈情形；
PUSH 外层SS
PUSH 外层ESP
PUSH EFLAG
PUSH CS
PUSH EIP
（d）是变换特权级和有出错码的内层堆栈情形。
PUSH 外层SS
PUSH 外层ESP
PUSH EFLAG
PUSH CS
PUSH EIP
PUSH 出错码
在这种V86任务内从V86方式转换到保护方式的过程中，为了保证中断/异常处理程序工作于特权级0，对目标代码段描述符特权级进行检查，
如果由目标代码段描述符特权级决定的CPL不等于0，将引起通用保护异常。
此外，标志寄存器EFLAGS中的VM位被清0，从而使得中断/异常处理在保护方式下进行，也即离开V86方式。
这种情况下，相应的中断/异常处理在当前V86任务之内进行。中断/异常处理程序可以检查保存在堆栈中的EFLAGS映象，根据VM位的值来确定被中断程序的工作方式。
如果VM=1，那么被中断的程序工作于V86方式，是8086程序；否则，被中断的程序工作于保护方式，是V86监控程序。
（2）任务切换离开V86方式
如果对应的门描述符是任务门，那么就发生从当前V86任务到其他任务的切换，也就离开当前V86任务的V86方式。象普通任务切换一样，
V86方式的各通用寄存器、段寄存器、指令指针和标志寄存器EFLAGS等保存到原V86任务的386TSS中。被保存的段寄存器的内容是V86方式下的段值。
被保存的EFLAGS内的VM=1。
这种情况下，相应的中断/异常处理在另一个任务内进行。目标任务可以是普通任务，也可以是另一个V86任务。
如果目标任务TSS内的EFLAGS字段内的VM=1，那么就转入另一个V86任务的V86方式。
2.进入V86方式
与离开V86方式的两条途径相对应，有两条进入V86方式的途径。
（1）通过IRET指令进入V86方式
通常在中断/异常处理结束时使用IRET指令返回被中断的程序继续执行。指令IRET的执行流程如图10.34所示，尽管它不够细致和没包括异常情况，
但还是体现了指令IRET执行时所处理的三种情形。第一种情形是当前EFLAGS中的NT=1，也即嵌套任务返回，那么就进行任务切换，
指向目标任务TSS的选择子在当前任务TSS的链接字段。NT=0表示当前中断/异常处理程序与被中断程序属于同一任务，于是就从堆栈弹出EIP、CS和EFLAGS。
第二和第三种情形是在NT=0的条件下产生。第二种情形是弹出的EFLAGS中VM=0，表示被中断的程序是普通保护方式程序，那么就考虑特权级变换，
如果向外层返回，那么就恢复外层堆栈指针，不允许向内层返回。在10.7.3中介绍的指令IRET的动作只考虑情形一和情形二，并不是指令IRET的完整动作。
第三种情形是弹出的EFLAGS中VM=1且CPL=0，表示被中断的程序是V86方式下的8086程序，当前是从同一V86任务下的中断/异常处理程序返回。
由于V86方式的特权级是3，所以要进行堆栈切换，也即从堆栈中弹出3级堆栈的指针（ESP和SS）。此外，还从堆栈中弹出段寄存器ES、DS、FS和GS。
在这种情形下，弹到各段寄存器（包括CS和SS）的内容都作为段值，而非选择子。这种处理动作对应于上述第一种离开V86方式的情形，
有关堆栈操作也与图10.33所示的堆栈内容相符。当然，如果产生异常时提供出错码，那么异常处理程序在利用IRET指令返回时，
必须确保堆栈指针指向图10.33所示保存EIP的单元。简单的实现方法是，异常处理程序在执行IRET前，先从堆栈弹出出错码。
利用指令IRET处理的这第三种情形，可以方便地从V86任务下的中断/异常处理程序返回到V86方式下的8086程序。
利用这条途径还可以直接进入V86方式。为此，先在0级堆栈中形成如图10.33（a）所示的栈顶。
对应EIP值是V86方式下要执行的8086程序入口点的16 位偏移；对应CS值是V86方式下要执行的8086程序入口点的段值；对应EFLAGS值中的VM位必须是1；
对应SS和ESP的值是要执行的8086程序的堆栈指针；对应ES、DS、FS和GS的值是相应的段值。然后，在CPL=0和NT=0的情况下，执行IRET指令。
实际上，这种进入V86方式的途径是，先建立一个V86方式下执行的8086程序被中断而离开V86方式的环境，然后再返回。
（2）通过任务切换进入V86方式
通过任务切换的途径，可以从其他任务进入V86任务内的V86方式。
利用在前面几节介绍的任务切换方法可以进行任务切换。如果目标任务由386TSS描述，并且其中EFLAGS字段内的VM位为1，那么在切换到目标任务时，也就进入V86方式。
在切换到V86方式时，CPL被规定为3。目标任务TSS中的各段寄存器字段被解释为8086可以接受的段值，而不是选择子。
任务切换时也将装载LDTR和CR3。如果利用这条途径建立V86任务并进入V86方式，那么主要是把对应386TSS中EFLAGS字段内的VM位置1，
把8086程序的有关段值填入对应386TSS中的相应段寄存器字段。此外，如果V86监控程序需要用到LDT，那么还要填LDTR字段；如果需要采用分页机制，那么还要填CR3字段。
10.11.3演示进入和离开V86方式的实例（实例十一）
下面给出一个用于演示进入和离开V86方式的实例。
该实例的逻辑功能是，以驻留方式结束程序，退出时已处于V86方式。
该实例演示内容包括：两种方式进入V86方式和两种方式离开V86方式；V86方式下的8086程序如何调用实方式下的软中断处理程序。
1.演示步骤和源程序清单
为了便于演示，本实例含有三个任务：临时任务、V86任务和INTFF任务。在实方式下作必要的初始化工作后切换到保护方式，也即进入临时任务，开始演示。
演示分两个阶段：第一阶段进入V86任务的V86方式，并驻留退出；第二阶段进入INTFF任务，切换到临时任务，并返回实方式。
第一阶段的演示步骤如下：
（1）开始临时任务后，作切换到V86任务的准备；
（2）切换到V86任务，由于V86任务TSS中的EFLAGS字段内的VM= 1，所以伴随着任务切换，就进入V86方式；
（3）进入V86任务的V86方式后，显示提示信息，驻留结束，出现DOS提示符，第一阶段至此结束。
在V86方式下，可进行各种操作，运行其他8086程序。如果8086程序引起通用保护异常，那么在屏幕第一行显示提示信息，并中止该8086程序。
如果在8086程序中执行"INT FF"指令，开始第二阶段。
第二阶段的演示步骤如下：
（1）进入INTFF任务后，显示提示信息，切换到临时任务；
（2）在临时任务内切换回到实方式；
（3）在实方式下，中止发出“INT FF"的程序。
源程序有如下几部分组成：
（1）全局描述符表GDT；
（2）中断描述符表IDT（只适用于V86任务）；
（3）INTFF任务的TSS段、LDT段、0级堆栈段和代码段；
（4）V86任务的TSS段、LDT段、0级堆栈段、3级堆栈段及数据段，通用保护异常处理程序段和其他中断/异常处理程序段，V86方式下的8086程序段；
（5）临时任务的TSS段和代码段；
（6）实方式下的初始化代码段及有关过程。
源程序清单如下：
；程序名：T10-11.ASM
；功能：演示进入和离开V86方式
DESCRIPTOR STRUC
LIMITL DW 0
BASEL DW 0
BASEM DB 0
ATTRIBUTES DW 0
BASEH DB 0
DESCRIPTOR ENDS
GATE STRUC
OFFSETL DW 0
SELECTOR DW 0
DCOUNT DB 0
GTYPE DB 0
OFFSETH DW 0
GATE ENDS
PDESC STRUC
LIMIT DW 0
BASE DD 0
PDESC ENDS
TASKSS STRUC
TRLINK DW ?,0
TRESP0 DD ?
TRSS0 DW ?,0
TRESP1 DD ?
TRSS1 DW ?,0
TRESP2 DD ?
TRSS2 DW ?,0
TRCR3 DD ?
TREIP DD ?
TREFLAG DW ?,?
TREAX DD ?
TRECX DD ?
TREDX DD ?
TREBX DD ?
TRESP DD ?
TREBP DD ?
TRESI DD ?
TREDI DD ?
TRES DW ?,0
TRCS DW ?,0
TRSS DW ?,0
TRDS DW ?,0
TRFS DW ?,0
TRGS DW ?,0
TRLDT DW ?,0
TRFLAG DW 0
TRIOMAP DW $ + 2
TASKSS ENDS
ATDR = 90H
ATDW = 92H
ATDWA = 93H
ATCE = 98H
ATCER = 9AH
ATCCO = 9CH
ATCCOR = 9EH
ATLDT = 82H
ATTASKGAT = 85H
AT386TSS = 89H
AT386CGAT = 8CH
AT386IGAT = 8EH
AT386TGAT = 8FH
DPL1 = 20H
DPL2 = 40H
DPL3 = 60H
RPL1 = 01H
RPL2 = 02H
RPL3 = 03H
IOPL1 = 1000H
IOPL2 = 2000H
IOPL3 = 3000H
D32 = 4000H
TIL = 04H
VMFL = 0002H
IFL = 0200H
JUMP32 MACRO selector,offsetv
DB 0EAH
DW offsetv
DW 0
DW selector
ENDM
CALL32 MACRO selector,offsetv
DB 9AH
DW offsetv
DW 0
DW selector
ENDM
JUMP16 MACRO selector,offsetv
DB 0EAH
DW offsetv
DW selector
ENDM
CALL16 MACRO selector,offsetv
DB 9AH
DW offsetv
DW selector
ENDM
.386P
GDTSeg          SEGMENT PARA USE16                ;全局描述符表数据段(16位)
GDT             LABEL   BYTE
DUMMY           DESCRIPTOR    <>
Normal          DESCRIPTOR    <0ffffh,,,ATDW,>
Normal_Sel      =       Normal - GDT
Video           DESCRIPTOR    <07fffh,8000h,0bh,ATDW,>
Video_Sel       =       Video - GDT
EFFGDT          LABEL   BYTE
V86TSS          DESCRIPTOR    <V86TSSLen - 1,V86TSSSeg,,AT386TSS,>
V86TSS_Sel      =       V86TSS - GDT
V86LDT          DESCRIPTOR    <V86LDTLen - 1,V86LDTSeg,,ATLDT,>
V86LDT_Sel      =       V86LDT - GDT
IntFFTSS        DESCRIPTOR    <IntFFTSSLen - 1,IntFFTSSSeg,,AT386TSS,>
IntFFTSS_Sel    =       IntFFTSS - GDT
IntFFLDT        DESCRIPTOR    <IntFFLDTLen - 1,IntFFLDTSeg,,ATLDT,>
IntFFLDT_Sel    =       IntFFLDT - GDT
TempTSS         DESCRIPTOR    <TempTSSLen - 1,TempTSSSeg,,AT386TSS,>
TempTSS_Sel     =       TempTSS - GDT
TempCode        DESCRIPTOR    <0ffffh,TempCodeSeg,,ATCE,>
TempCode_Sel    =       TempCode - GDT
GDNum           =       ($ - EFFGDT) / 8    ;需特殊处理的描述符数
GDTLen          =       $ - GDT                     ;全局描述符表长度
GDTSeg          ENDS                              ;全局描述符表段定义结束
IDTSeg          SEGMENT PARA USE16                ;V86任务使用的中断描述符表
IDT             LABEL   BYTE
                REPT    13
                GATE    <,TPCode_Sel,,AT386IGAT + DPL3,>
                ENDM
                GATE   <GPBegin,GPCode_Sel,,AT386TGAT + DPL3,>
                REPT    241
                GATE    <,TPCode_Sel,,AT386IGAT + DPL3,>
                ENDM
                GATE    <,IntFFTSS_Sel,,ATTASKGAT + DPL3,>
IDTLen          =       $ - IDT
IDTSeg          ENDS                              ;中断描述符表段定义结束
IntFFTSSSeg     SEGMENT PARA USE16
                DD      0                         ;链接字
                DD      0                         ;0级堆栈指针(实例不使用)
                DW      0,0                       ;0级堆栈选择子(实例不使用)
                DD      0                         ;1级堆栈指针(实例不使用)
                DW      0,0                       ;1级堆栈选择子(实例不使用)
                DD      0                         ;2级堆栈指针(实例不使用)
                DW      0,0                       ;2级堆栈选择子(实例不使用)
                DD      0                         ;CR3
                DW      IntFFBegin,0              ;EIP
                DD      0                         ;EFLAGS
                DD      0                         ;EAX
                DD      0                         ;ECX
                DD      0                         ;EDX
                DD      0                         ;EBX
                DD      IntFFStackLen             ;ESP
                DD      0                         ;EBP
                DD      0                         ;ESI
                DD      0                         ;EDI
                DW      Normal_Sel,0              ;ES
                DW      IntFFCode_Sel,0           ;CS
                DW      IntFFStack_Sel,0          ;SS
                DW      Normal_Sel,0              ;DS
                DW      Normal_Sel,0              ;FS
                DW      Normal_Sel,0              ;GS
                DW      IntFFLDT_Sel,0            ;LDTR
                DW      0                         ;调试陷阱标志
                DW      $+2                       ;指向I/O许可位图
                DB      0ffh                      ;I/O许可位图结束标志
IntFFTSSLen     =       $
IntFFTSSSeg     ENDS
IntFFLDTSeg     SEGMENT PARA USE16
FLDT            LABEL   BYTE
IntFFStack      DESCRIPTOR    <IntFFStackLen - 1,IntFFStackSeg,,ATDWA,>
IntFFStack_Sel  =       (IntFFStack - FLDT) + TIL
IntFFCode       DESCRIPTOR    <IntFFCodeLen - 1,IntFFCodeSeg,,ATCER,>
IntFFCode_Sel   =       (IntFFCode - FLDT) + TIL
IntFFLDNum      =       ($ - FLDT) / 8
IntFFLDTLen     =       $
IntFFLDTSeg     ENDS
IntFFStackSeg   SEGMENT PARA USE16
IntFFStackLen   =       512
                DB      IntFFStackLen DUP (0)
IntFFStackSeg   ENDS
IntFFCodeSeg    SEGMENT PARA USE16
                ASSUME  CS:IntFFCodeSeg
IntFFMess       DB      'Return to real mode.'
IntFFMessLen    =       $ - IntFFMess
IntFFBegin      PROC    FAR
                mov     si,OFFSET IntFFMess
                mov     ax,Video_Sel
                mov     es,ax
                mov     di,0
                mov     ah,17h
                mov     cx,IntFFMessLen
                cld
INext:          mov     al,BYTE PTR cs:[si]
                inc     si
                stosw
                loop    INext
                JUMP16  TempTSS_Sel,0
IntFFBegin      ENDP
IntFFCodeLen    =       $
IntFFCodeSeg    ENDS
V86TSSSeg       SEGMENT PARA USE16
                DD      0                         ;链接字
                DD      V86Stack0Len              ;0级堆栈指针
                DW      V86Stack0_Sel,0           ;0级堆栈选择子
                DD      0                         ;1级堆栈指针(实例不使用)
                DW      0,0                       ;1级堆栈选择子(实例不使用)
                DD      0                         ;2级堆栈指针(实例不使用)
                DW      0,0                       ;2级堆栈选择子(实例不使用)
                DD      0                         ;CR3
                DW      V86Begin,0                ;EIP
                DW IOPL3,VMFL             ;EFLAGS(IO特权级为3,VM=1)
                DD      0                         ;EAX
                DD      0                         ;ECX
                DD      0                         ;EDX
                DD      0                         ;EBX
                DD      V86Stack3Len              ;ESP
                DD      0                         ;EBP
                DD      0                         ;ESI
                DD      0                         ;EDI
                DW      V86CodeSeg,0              ;ES
                DW      V86CodeSeg,0              ;CS
                DW      V86Stack3Seg,0            ;SS
                DW      V86CodeSeg,0              ;DS
                DW      V86CodeSeg,0              ;FS
                DW      V86CodeSeg,0              ;GS
                DW      V86LDT_Sel,0              ;LDTR
                DW      0                         ;调试陷阱标志
                DW      $+2                       ;指向I/O许可位图
                DB      4000h/8 DUP (0)            ;I/O许可位图
                DB      0ffh                      ;I/O许可位图结束标志
V86TSSLen       =       $
V86TSSSeg       ENDS
V86LDTSeg       SEGMENT PARA USE16
VLDT            LABEL   BYTE
VAllMem         DESCRIPTOR    <0FFFFH,0,,0F00H + ATDWA,>
VAllMem_Sel     =       (VAllMem - VLDT) + TIL
V86Stack0       DESCRIPTOR    <V86Stack0Len - 1,V86Stack0Seg,,ATDWA,>
V86Stack0_Sel   =       (V86Stack0 - VLDT) + TIL
V86Data         DESCRIPTOR    <V86DataLen - 1,V86DataSeg,,ATDR,>
V86Data_Sel     =       (V86Data - VLDT) + TIL
TPCode          DESCRIPTOR    <TPCodeLen - 1,TPCodeSeg,,ATCE,>
TPCode_Sel      =       (TPCode - VLDT) + TIL
GPCode          DESCRIPTOR    <GPCodeLen - 1,GPCodeSeg,,ATCE,>
GPCode_Sel      =       (GPCode - VLDT) + TIL
V86LDNum        =       ($ - VLDT) / 8
V86LDTLen       =       $
V86LDTSeg       ENDS
V86Stack0Seg    SEGMENT PARA USE16
V86Stack0Len    =       512
                DB      V86Stack0Len DUP (0)
V86Stack0Seg    ENDS
V86Stack3Seg    SEGMENT PARA USE16
V86Stack3Len    =       1024
                DB      V86Stack3Len DUP (0)
V86Stack3Seg    ENDS
V86DataSeg      SEGMENT PARA USE16
GPErrMess       DB      '......General Protection Error......'
GPErrMessLen    =       $ - GPErrMess
V86DataLen      =       $
V86DataSeg      ENDS
Perr            EQU     <WORD PTR [BP+0]>
Pip             EQU     <WORD PTR [BP+4]>
Pcs             EQU     <WORD PTR [BP+8]>
Pflag           EQU     <WORD PTR [BP+12]>
Psp             EQU     <WORD PTR [BP+16]>
Pss             EQU     <WORD PTR [BP+20]>
Pes             EQU     <WORD PTR [BP+24]>
Pds             EQU     <WORD PTR [BP+28]>
Pfs             EQU     <WORD PTR [BP+32]>
Pgs             EQU     <WORD PTR [BP+36]>
TPCodeSeg       SEGMENT PARA USE16
                ASSUME  CS:TPCodeSeg
TPBegin         PROC    FAR
Count           =       0
                REPT    256                       ;对应256个入口
                IF      Count EQ 21h
Ent21H          LABEL   BYTE                      ;在第21H项处定义标号Ent21H
                ENDIF
                push    bp
                mov     bp,Count                  ;置中断向量号到BP
                jmp     Process                   ;都转统一的处理程序
Count           =       Count+1
                ENDM
Process:        push    bp                        ;保存BP
                mov     bp,sp                     ;堆栈指针送BP
                push    eax
                push    ebx                       ;保存EAX、EBX
                mov     ax,VAllMem_Sel            ;转载描述最低1M字节线性地址
                mov     ds,ax                     ;  空间的描述符选择子
                xor     eax,eax
                mov     ax,Psp                    ;修改在V86任务0级堆栈中保存
                sub     ax,3*2                    ;  的3级堆栈的指针，减3个字
                mov     Psp,ax                    ;  即在栈顶空出3个字
                xor     ebx,ebx
                mov     bx,Pss                    ;使EBX指向V86堆栈顶
                shl     ebx,4
                add     ebx,eax
                mov     ax,Pip                    ;把保存在0级堆栈中的返回地址
                mov     WORD PTR [ebx],ax         ;的偏移部分送V86堆栈
                mov     ax,Pcs
                mov     WORD PTR [ebx+2],ax       ;段值部分送V86堆栈
                mov     ax,Pflag
                mov     WORD PTR [ebx+4],ax       ;标志值送V86堆栈
                mov     bx,[bp]                   ;取中断向量号
                shl     bx,2                      ;乘4
                mov     ax,[bx]                   ;取实模式下对应中断向量的偏移
                mov     Pip,ax                    ;代替0级堆栈中的EIP
                mov     ax,[bx+2]                 ;取实模式下对应中断向量的段值
                mov     Pcs,ax                    ;代替0级堆栈中的CS
                pop     ebx                       ;恢复现场
                pop     eax
                pop     bp
                pop     bp
                iretd
TPBegin         ENDP
TPCodeLen       =       $
TPCodeSeg       ENDS
GPCodeSeg       SEGMENT PARA USE16
                ASSUME  CS:GPCodeSeg
GPBegin         PROC    FAR
                mov     ax,V86Data_Sel
                mov     ds,ax
                mov     si,OFFSET GPErrMess
                mov     ax,Video_Sel
                mov     es,ax
                mov     di,0
                mov     ah,17h
                mov     cx,GPErrMessLen
                cld
GNext:          lodsb
                stosw
                loop    GNext
                add     esp,4
                mov     ax,4c01h
                JUMP16  TPCode_Sel,Ent21H
GPBegin         ENDP
GPCodeLen       =       $
GPCodeSeg       ENDS
V86CodeSeg      SEGMENT PARA USE16
                ASSUME  CS:V86CodeSeg,DS:V86CodeSeg
Message         DB      'V86 is OK!',0dh,0ah,24h
V86Begin        PROC    FAR
                mov     ah,9
                mov     dx,OFFSET Message
                int     21h
                mov     ax,RCodeSeg
                sub     ax,GDTSeg
                mov     dx,OFFSET TSRLine+15
                shr     dx,4
                add     dx,ax
                add     dx,10h
                mov     ax,3100h
                int     21h
V86Begin        ENDP
V86CodeSeg      ENDS
TempTSSSeg      SEGMENT PARA USE16                ;临时任务的TSS段
                TASKSS     <>
                DB      0ffh                      ;I/O许可位图结束标志
TempTSSLen      =       $
TempTSSSeg      ENDS
TempCodeSeg     SEGMENT PARA USE16                ;临时任务的代码段
                ASSUME  CS:TempCodeSeg
Virtual         PROC    FAR
                mov     ax,Normal_Sel
                mov     ds,ax
                mov     es,ax
                mov     fs,ax
                mov     gs,ax
                mov     ss,ax
                mov     ax,TempTSS_Sel            ;装载TR
                ltr     ax
                JUMP16  V86TSS_Sel,0              ;直接切换到演示任务
ToDos:          clts
                mov     eax,cr0                   ;准备返回实模式
                and     al,11111110b
                mov     cr0,eax
                JUMP16  <SEG Real>,<OFFSET Real>
Virtual         ENDP
TempCodeSeg     ENDS
RDataSeg        SEGMENT PARA USE16                ;实方式数据段
RDataSeg        ENDS
RCodeSeg        SEGMENT PARA USE16
                ASSUME  CS:RCodeSeg,DS:RCodeSeg
VGDTR           PDesc   <GDTLen - 1,>               ;GDT伪描述符
VIDTR           PDesc   <IDTLen - 1,>               ;IDT伪描述符
NORVIDTR        PDesc   <>                        ;用于保存原IDTR值
SPVar           DW      ?                         ;用于保存实方式下的SP
SSVar           DW      ?                         ;用于保存实方式下的SS
Start           PROC
                mov     ax,RCodeSeg
                mov     ds,ax
                cld
                call    InitGDT                   ;初始化全局描述符表GDT
                call    InitIDT                   ;初始化中断描述符表IDT
                mov     ax,V86LDTSeg
                mov     fs,ax
                mov     cx,V86LDNum
                mov     si,OFFSET VLDT
                call    InitLDT
                mov     ax,IntFFLDTSeg
                mov     fs,ax
                mov     cx,IntFFLDNum
                mov     si,OFFSET FLDT
                call    InitLDT
                mov     SSVar,ss
                mov     SPVar,sp
                lgdt    QWORD PTR VGDTR           ;装载GDTR并切换到保护方式
                sidt    QWORD PTR NORVIDTR        ;保存IDTR
                cli                               ;关中断
                lidt    QWORD PTR VIDTR           ;装载IDTR
                mov     eax,cr0
                or      al,1
                mov     cr0,eax
                JUMP16  <TempCode_Sel>,<OFFSET Virtual>
Real:           mov     ax,cs
                mov     ds,ax
                lss     sp,DWORD PTR SPVar        ;又回到实方式
                lidt    QWORD PTR NORVIDTR
                sti
                mov     ax,4c00h
                int     21h
Start           ENDP
TSRLine         LABEL   BYTE
InitGDT         PROC
                push    ds
                mov     ax,GDTSeg
                mov     ds,ax
                mov     cx,GDNum
                mov     si,OFFSET EFFGDT
InitG:          mov     ax,[si].BaseL
                movzx   eax,ax
                shl     eax,4
                shld    edx,eax,16
                mov     WORD PTR [si].BaseL,ax
                mov     BYTE PTR [si].BaseM,dl
                mov     BYTE PTR [si].BaseH,dh
                add     si,8
                loop    InitG
                pop     ds
                mov     bx,16
                mov     ax,GDTSeg
                mul     bx
                mov     WORD PTR VGDTR.Base,ax
                mov     WORD PTR VGDTR.Base+2,dx
                ret
InitGDT         ENDP
InitLDT         PROC
                mov     ax,WORD PTR FS:[si].BaseL
                movzx   eax,ax
                shl     eax,4
                shld    edx,eax,16
                mov     WORD PTR fs:[si].BaseL,ax
                mov     BYTE PTR fs:[si].BaseM,dl
                mov     BYTE PTR fs:[si].BaseH,dh
                add     si,8
                loop    InitLDT
                ret
InitLDT         ENDP
InitIDT         PROC
                push    ds
                mov     ax,IDTSeg
                mov     ds,ax
                mov     cx,256-1
                mov     si,OFFSET IDT
                mov     ax,OFFSET TPBegin
IIDT1:          cmp     cx,256 - 1 - 13
                jz      IIDT2
                mov     [si],ax
IIDT2:          add     si,8
                add     ax,7
                loop    IIDT1
                pop     ds
                mov     bx,16
                mov     ax,IDTSeg
                mul     bx
                mov     WORD PTR VIDTR.Base,ax
                mov     WORD PTR VIDTR.Base+2,dx
                ret
InitIDT         ENDP
RCodeSeg        ENDS
                END     Start
演示V86模式下的INTFF任务
Text            SEGMENT
                ASSUME  cs:Text,ds:Text
Start           PROC
                int     0ffh
                mov     ax,4c00h
                int     21h
Start           ENDP
Text            ENDS
                END     Start
在XP下使用tasm t468.asm编译，tlink t468.obj链接，使用tasm t469.asm编译，tlink t469.obj链接
在DOS下运行t468.exe，以黑底白色显示V86 is OK!
c:\TASM16\T468.exe
V86 is OK!
运行t469.exe，在屏幕左上角以蓝底白色显示......General Protection Error......
2.说明
（1）对IDT表的初始化
为了方便地书写IDT表，采用了重复汇编。从采用重复汇编方式定义的IDT表可见，除对应通用保护异常的13号陷阱门描述符和255号任务门描述符外，
其他中断门描述内的偏移均未设定。为此，在实方式下初始化时，把相应的入口偏移填入这些门描述符。
从源程序可见，这些处理程序的入口片段也用重复汇编书写，并且字节数相同，所以间隔等长。
（2）任务切换方式进入V86方式
实例从临时任务切换到V86任务时进入V86方式。在V86任务的TSS中，EFLAGS字段内的VM=1，所以随着任务切换，就进入V86方式。
为此，TSS中对应各段寄存器字段内的初始值都是V86方式下要执行的8086程序的各段值，而非选择子。
由于在发生中断/异常时要进入V86任务的特权级0，所以初始化了0级堆栈指针。V86任务使用局部描述表LDT，所以TSS中对应字段填有相应的选择子。
（3）V86方式下对中断的处理
实例对V86方式下响应中断和执行软中断指令“INT n”的处理方法是，转实方式下的对应中断处理程序。
具体步骤如下：①在V86方式堆栈（V86任务的3级堆栈）顶形成返回点的现场；
②用实方式下对应的中断向量值代替返回地址；
③从保护方式返回V86方式。
由于堆栈中保存的EFLAGS内的VM=1，所以在保护方式下执行IRET指令时，返回V86方式；
由于在0级堆栈中保存的返回地址（段值和偏移）已被修改成实方式下的中断向量，所以这时的返回也就是转入实方式下的对应中断处理程序；
由于在V86堆栈顶已安排了返回地址，所以在实方式下执行对应中断处理程序时，遇到IRET指令就返回到V86任务的被中断处。这种处理方法似乎绕了个弯。
但就是利用这个方法有效地调用了DOS功能，方便地显示了提示信息"V86 is OK!"，顺利地实现了驻留退出。
所以，除为了确定中断向量号在中断处理程序之初的代码不同外，其他代码可重复利用。这也是可用重复汇编和循环填写偏移初始化的条件。
这种处理方法没有充分考虑异常，更没有考虑异常时的出错码。
（4）V86任务的通用保护异常处理
在演示的第一阶段和第二阶段，不会发生任何异常。但在这两个阶段之间，由于允许执行其他程序，可能引起异常。为了简单，实例只考虑了通用保护异常，而未考虑其他异常。
该可能发生异常的阶段是在V86方式下。如果发生通用保护异常，那么就转入V86任务的通用保护异常处理程序。通用保护异常处理程序在保护方式下显示提示信息
"......General Protection Error......"，然后再转21H号中断处理程序，通过设置入口参数AX=4C01H，中止引起通用保护异常的程序。
（5）INTFF任务：为了演示以任务切换方式离开V86方式，在实例中安排了这一任务，并称之为INTFF任务。
由于IDT表中的255（0FFH）号描述符是任务门描述符，所以当在V86方式下执行“INT FFH"时便从V86方式切换到INTFF任务。INTFF任务的TSS是初始化好的，
在INTFF任务下不发生特权级变换，不使用局部描述表LDT。INTFF任务先显示提示信息"Return to real mode."，然后再切换到临时任务。
10.11.4 V86 方式下的敏感指令
表10.8特权指令
指令                  功能                  指令                  功能
CLTS          清除CR0中的TS位      LTR                  装入TR
HLT            停机                      MOV CRn,reg     装入控制寄存器
LGDT         装入GDTR              MOV reg,CRn     保存控制寄存器
LIDT          装入IDTR                MOV DRn,reg     装入调试寄存器
LLDT         装入LDTR                MOV reg,DRn    保存调试寄存器
LMSW       装入MSW（CR0低16位）
表10.9 I/O 敏感指令
指令                  功能                  保护方式下执行条件
CLI         清除EFLAGS中的IF位     CPL <= IOPL
STI         设置EFLAGS中的IF位     CPL <= IOPL
IN          从I/O地址读出数据        CPL <= IOPL或I/O位图允许
INS        从I/O地址读出字符串     CPL <= IOPL或I/O位图允许
OUT      向I/O地址写数据            CPL <= IOPL或I/O位图允许
OUTS    向I/O地址写字符串        CPL <= IOPL或I/O位图允许
在V86方式下，CPL=3，执行10.8.5节所述特权指令或者要引起出错码为0的通用保护故障，或者要引起非法操作码故障。
在V86方式下，表10.9所列的指令仍是I/O敏感指令，但输入/输出指令的敏感条件有所变化。指令CLI和STI的敏感条件不变，由于CPL=3，所以如果IOPL<3，
那么执行CLI或STI指令引起通用保护故障。输入/输出指令IN，INS，OUT或OUTS的敏感条件仅仅是当前V86任务TSS内的I/O许可位图，而忽略EFLAGS中的IOPL。
输入/输出指令IN、INS、OUT或OUTS是否可以执行与CPL是否小于IOPL无关，而直接由I/O许可位图对应位决定，
如果输入/输出指令所使用I/O地址对应的I/O许可位图内的各位都为0时，输入/输出指令可正常执行，否则引起通用保护故障。
此外，在V86方式下，指令PUSHF、POPF、INT n和IRET却对IOPL敏感。也就是说，在V86方式下，当IOPL<3时，
执行指令PUSHF、POPF、INT n及IRET会引起出错码为0的通用保护故障，并非象10.9.2节所述保持沉默。
采取这些措施的目的是使操作系统软件可以支持一个“虚拟EFLAG"寄存器。
10.12习题
题10.1 80386的哪些功能只有在保护方式下才能起作用？
80386有32根地址线，在保护方式下，全部32条地址线有效，可寻址高达4G字节的物理地址空间；
扩充的存储器分段管理机制和可选的存储器分页管理机制，不仅为存储器共享和保护提供了硬件支持，而且为实现虚拟存储器提供了硬件支持；
支持多任务，能够快速地进行任务切换和保护任务环境；
4个特权级和完善的特权检查机制，既能实现资源共享又能保证代码及数据的安全和保密、及任务的隔离；
支持虚拟8086方式，便于执行8086程序。
题10.2 80386的物理地址空间有多大？虚拟地址空间有多大？是如何计算的？
80386有32根地址线，在保护方式下，它们都能发挥作用，所以可寻址的物理地址空间高达4G字节。
保护方式下的虚拟存储器由大小可变的存储块构成，这样的存储块称为段。
80386采用称为描述符的数据来描述段的位置、大小和使用情况。
虚拟存储器的地址（逻辑地址）由指示描述符的选择子和段内偏移两部分构成，这样的地址集合称为虚拟地址空间。
80386支持的虚拟地址空间可达64T字节(最多16K个段，一个段最大4GB)。
题10.3有选择子和偏移构成的逻辑地址如何转换成物理地址？
由于物理地址空间远小于虚拟地址空间，所以只有虚拟地址空间中的部分可以映射到物理地址空间。
由于物理存储器的大小要远小于物理地址空间，所以只有上述部分中的部分才能真正映射到物理存储器。
每一个任务有一个虚拟地址空间。为了避免多个并行任务的多个虚拟地址空间直接映射到同一个物理地址空间，
采用线性地址空间隔离虚拟地址空间和物理地址空间。线性地址空间由一维的线性地址构成，线性地址空间和物理地址空间对等。
线性地址32位长，线性地址空间容量为4G字节。
80386分两步实现虚拟地址空间到物理地址空间的映射，也就是分两步实现虚拟地址到物理地址的转换，但第二步是可选的。
图10.1是地址映射转换的示意。
15      0   31      0                               31      0    ->分页管理机制 ->31      0
 选择子 :   偏移量 ->分段管理机制  ->线性地址                           ->物理地址
通过描述符表和描述符，分段管理机制实现虚拟地址空间到线性地址空间的映射，实现把二维的虚拟地址转换为一维的线性地址。这一步总是存在的。
分页管理机制把线性地址空间和物理地址空间分别划分为大小相同的块，这样的块称之为页。
通过在线性地址空间的页与物理地址空间的页之间建立的映射表，分页管理机制实现线性地址空间到物理地址空间的映射，实现线性地址到物理地址的转换。
分页管理机制是可选的，在不采用分页管理机制时，线性地址空间就直接等同于物理地址空间，线性地址就直接等于物理地址。
虚拟地址到物理地址的映射函数在每个任务中进行定义，随着任务切换，映射函数也切换。
因此，两个不同的任务，尽管虚拟存储单元地址相同，但实际的物理存储单元地址可以不同。
题10.4 80386的四个特权级是如何划分的？哪级最高？哪级最低？
在一个任务之内，定义有四种执行特权级别，用于限制对任务中的段进行访问。
按照包含在段中的数据的重要性和代码的可信任程度，给段指定特权级别。
把最高的特权级别分配给最重要的数据段和最可信任的代码段。具有最高特权级别的数据，只能由最可信任的代码访问。
给不重要的数据段和一般代码段分配较低的特权级别。具有最低特权级别的数据，可被具有任何特权级别的代码访问。
特权级别用数字0~3表示，数字0表示最高特权级别，而数字3表示最低特权级别。数字较大的级别具有较低的特权。
为了避免模糊和混淆，在比较特权级别时，不使用“大于”或“小于”这样的术语，
而使用“里面”或“内层”这样的术语表示较高特权级，级别的数字较小；
使用“外面”或“外层”这样的术语表示较低特权级别，级别的数字较大。
0级为最内层的特权级别，3级为最外层的特权级别。
每个存储器段都与一个特权级别相联系。特权级别限制是指，只有足够级别的程序，才可对相应的段进行访问。
在任何时候，一个任务总是在4个特权级之一下运行，任务在特定时刻的特权级称为当前特权级（Current Privilege Level），标记为CPL。
每当一个程序试图访问一个段时，就把CPL与要访问的段的特权级进行比较，以决定是否允许这一访问。
对给定CPL执行的程序，允许访问同一级别或外层级别的数据段。
题10.5在保护方式下，80386如何定义一个段？
在保护方式下，每个段由如下三个参数进行定义：段基地址（BaseAddress）、段界限（Limit）和段属性（Attributes）。
段基地址规定线性地址空间中段的开始地址。在80386保护方式下，段基地址长32位。因为基地址长度与寻址地址的长度相同，
所以任何一个段都可以从32位线性地址空间中的任何一个字节开始，而不像实方式下规定段的边界必须被16整除。
段界限规定段的大小。在80386保护方式下，段界限用20位表示，而且段界限可以是以字节为单位或以4K字节为单位。
段属性中有一位对此进行定义，把该位称为粒度位(granularity)，用符号G标记。
G=0表示段界限以字节为单位，于是20位的界限可表示的范围是1字节至1M字节，增量为1字节；
G=1表示段界限以4K字节为单位，于是20位的界限可表示的范围是4K字节至4G字节，增量为4K字节。
当段界限以4K字节为单位时，实际的段界限LIMIT可通过下面的公式从20位段界限Limit 计算出来：
LIMIT = Limit*4K+0FFFH = (limit<<12) + 0FFFH
所以，当粒度位为1时，段的界限实际上就扩展成为32位。
段内偏移0到Limit范围内的虚拟地址对应于从Base到Base+Limit范围内的线性地址。
数据段的段属性中有一扩展方向位，标记为ED。ED=0表示向高扩展，ED=1表示向低扩展。
数据段的扩展方向和段界限一起决定了数据段内偏移的有效范围。
只有数据段（堆栈段作为特殊的数据段）才有向高扩展和向低扩展之分，其它段都是自然的向高扩展。
在每次把虚拟地址转换为线性地址的过程中，要对偏移进行检查。如果偏移不在有效的范围内，那么就引起异常。
段属性规定段的主要特性。在对段进行各种访问时，将对访问是否合法进行检查，主要依据是段属性。
用于表示上述定义段的三个参数的数据称为描述符。每个描述符长8个字节。在保护方式下，每一个段都有一个相应的描述符来描述。
题10.6按描述符所描述的对象来划分，80386有哪几类描述符？
按描述符所描述的对象来划分，描述符可分为如下三类：存储段描述符、系统段描述符、门描述符（控制描述符）。
存储段描述符
存储段是存放可由程序直接进行访问的代码和数据的段。存储段描述符描述存储段，所以存储段描述符也被称为代码和数据段描述符。
存储段描述符的格式如图10.5所示。
m+7      m+6   m+5      m+4   m+3   m+2      m+1   m
31   24                           23                   0            15      0
Base       Attributes       Segment Base             Segment Limit
7   6   5   4   3   2   1   0   7   6   5   4   3   2   1   0
G   D  0   A     Limit         P    DPL   D  TYPE
               V   19         16                  T
               L                                       
最低地址字节（假设地址为m）在最右边，其余字节依次向左，直到最高字节，地址为m+7。
长32位的段基地址（段开始地址）被安排在描述符的两个域中，其位0~位23安排在描述符内的第2~第4字节中，其位24~位31被安排在描述符内的第7字节中。
长20位的段界限也被安排在描述符的两个域中，其位0~位15被安排在描述符内的第0~第1字节中，其位16~位19被安排在描述符内的第6字节的低4位中。
80386描述符中的段属性也被安排在两个域中。下面对其定义及意义作说明。
（1）P位称为存在（Present）位。
P=1表示描述符对地址转换是有效的，或者表示该描述符所描述的段存在；P=0表示描述符对地址转换无效，并且使用该描述符会引起异常。
（2）DPL表示描述符特权级（Descriptor Privilege Level），共2位。
它规定了所描述段的特权级，用于特权检查，以决定对该段能否进行访问。
（3）DT位说明描述符的类型。
对于存储段描述符而言，DT=1，以区别于系统段描述符和门描述符（DT=0）。
（4）TYPE说明存储段描述符所描述的存储段的具体属性。
其中的位0指示描述符是否被访问（Accessed），用符号A标记。A=0表示尚未被访问，A=1表示段已被访问。
当把描述符的相应选择子装入到段寄存器时，80386把该位置为1，表明描述符已被访问。
操作系统可测试访问位，以确定描述符是否被访问过。
其中的位3指示所描述的段是代码段还是数据段，用符号E标记。
E=0表示段是不可执行段，也就是数据段，相应的描述符也就是数据段（包括堆栈段）描述符。
E=1表示段是可执行段，也就是代码段，相应的描述符也就是代码段描述符。
在数据段描述符中（E=0的情况），TYPE中的位1指示所描述的数据段是否可写，用W标记。
W=0表示对应的数据段不可写，只能读，W=1表示对应的数据段可写。
TYPE中的位2就是ED位，指示所描述的数据段的扩展方向。
ED=0表示数据段向高扩展，也即段内偏移必须小于等于段界限。ED=1表示数据段向低扩展，也即段内偏移必须大于段界限。
在代码段描述符中（E=1的情况），TYPE中的位1指示所描述的代码段是否可读，用符号R标记。
R=0表示对应的代码段不可读，只能执行，R=1表示对应的代码段可读可执行。
TYPE中的位2指示所描述的代码段是否是一致码段，用C代表。
C=0表示对应的代码段不是一致码段（普通代码段），C=1表示对应的代码段是一致码段。
下面说明的属性位是80386在80286基础上的扩充的属性位。
（5）G位就是段界限粒度（Granularity）位。
G=0表示界限粒度为字节，G=1表示界限粒度是4K字节。注意，界限粒度只对段界限有效，对段基地址无效，段基地址总是以字节为单位。
（6）D位是一个很特殊的位。
在描述可执行段、向低扩展数据段或者由SS寄存器寻址的段（通常就是堆栈段）的三种描述符中的意义各不相同。
在描述可执行段的描述符中，D位决定了指令使用的地址及操作数所默认的大小。
D=1表示默认情况下指令使用32位地址及32位或8位操作数，这样的代码段也称为32位代码段；
D=0表示默认情况下使用16位地址及16位或8位的操作数，这样的代码段也称为16位代码段，它与80286兼容。
在向低扩展数据段的描述符中，D位决定段的上部边界。
D=1表示段的上部界限为4G；D=0表示段的上部界限为64K，这是为了与80286兼容。
在描述由SS寄存器寻址的段描述符中，D位决定隐式的堆栈访问指令（如PUSH和POP指令）使用何种堆栈指针寄存器。
D=1表示使用32位堆栈指针寄存器ESP；D=0表示使用16位堆栈指针寄存器SP，这与80286兼容。
（7）AVL位是软件可利用位。
80386对该位的使用未做规定，Intel公司也保证今后开发生产的处理器只要与80386兼容，就不会对该位的使用做任何定义或规定。
此外，描述符内第六字节中的位5须置成0，可理解成是为以后的处理器保留的。
根据如图10.5给出的存储段描述符的结构，可定义如下的描述符结构类型：
DESCRIPTOR STRUC
LIMITL  DW 0
BASEL   DW 0
BASEM DB 0
ATTRIBUTES DW 0
BASEH  DB 0
DESCRIPTOR ENDS
利用结构类型DESCRIPTOR能方便地在程序中说明存储段描述符。
系统段是为实现存储管理机制所使用的一种特别的段。在80386中，有两种系统段：任务状态段TSS和局部描述符表LDT段。
用于描述系统段的描述符称为系统段描述符，也称为特殊段描述符。
系统段描述符的一般格式
DESCRIPTOR <LIMITL  DW,BASEL   DW,BASEM DB,ATTRIBUTES DW,BASEH  DB>
系统段描述符的一般格式如图10.12所示。与图10.5所示的存储段描述符相比，它们很相似，区分的标志是属性字节中的描述符类型位DT的值。
DT=1表示存储段，DT=0表示系统段。系统段描述符中的段基地址和段界限字段与存储段描述符中意义完全相同；
属性中的G位、AVL位、P位和DPL字段的作用也完全相同。存储段描述符属性中的D位在系统段描述符中不使用，现用符号X表示。
系统段描述符的类型字段TYPE仍是4位，其编码及表示的类型列于表10.5，其含义与存储段描述符的类型完全不同。
从表10.5可见，只有类型编码为2、1、3、9和B的描述符才是真正的系统段描述符，它们用于描述系统段LDT和任务状态段TSS，
其它类型的描述符是门描述符。
利用在10.2节中定义的存储段描述符结构类型DESCRIPTOR仍能方便地在程序中说明系统段描述符。
表10.5系统段和门描述符类型字段的编码及含义
类型编码         说明         类型编码         说明
0                  未定义              8                未定义
1                  可用286TSS      9                可用386TSS
2                   LDT                  A               未定义
3                   忙的286TSS     B                忙的386TSS
4                   286调用门        C                386调用门
5                   任务门              D                未定义
6                   286中断门        E                386中断门
7                   286陷阱门        F                386陷阱门
LDT段描述符描述任务的局部描述符表段。LDT段描述符必须安排在全局描述符表中才有效。
任务状态段描述符描述某个任务状态段。TSS描述符分为286TSS和386TSS两类。TSS描述符规定了任务状态段的基地址和任务状态段的大小。
TSS描述符中的类型规定：TSS要么为“忙”，要么为“可用”。
如果一个任务是当前正执行的任务，或者是用TSS中的链接字段沿挂起任务链接到当前任务上的任务，那么该任务是“忙”的任务；否则该任务为“可用”任务。
除存储段描述符和系统段描述符外，还有一类门描述符。门描述符并不描述某种内存段，而是描述控制转移的入口点。
这种描述符好比一个通向另一代码段的门。通过这种门，可实现任务内特权级的变换和任务间的切换。所以，这种门描述符也称为控制门。
门描述符的一般格式
m+7         m+6         m+5         m+4         m+3         m+2         m+1         m
      offset                       Attributes             selector                            offset
31               16                                                                               15             0
Attributes
7      6      5      4      3      2      1      0      7      6      5      4      3      2      1      0
P      DPL         DT    TYPE                                  Dword Count
门描述符的一般格式如图10.13所示。门描述符只有位于描述符内偏移5的类型字节与系统段描述符保持一致，
也由该字节标识门描述符和系统段描述符。该字节内的P和DPL的意义与其他描述符中的意义相同。
其它字节主要用于存放一个48位的全指针（16位的选择子和32位的偏移量）。
根据如图10.13给出的门描述符的结构，可定义如下的门描述符结构类型：
GATE STRUC
OFFSETL DW 0
SELECTOR DW 0
DCOUNT DB 0
GTYPE DB 0
OFFSETH DW 0
GATE ENDS
利用门描述符结构类型GATE能方便地在程序中说明门描述符。
题10.7有哪些门描述符？
从表10.5可见，门描述符又可分为：任务门、调用门、中断门和陷阱门，并且除任务门外，其他门描述符还各分成286和386两种。
调用门描述某个子程序的入口。调用门内的选择子必须指向代码段描述符，调用门内的偏移是对应代码段内的偏移。
利用段间调用指令CALL，通过调用门可实现任务内从外层特权级变换到内层特权级。
在图10.13所示门描述符内偏移4字节m+4的位0至位4是双字计数字段，该字段只在调用门描述符中有效，在其它门描述符中无效。
主程序通常通过堆栈把入口参数传递给子程序，如果在利用调用门调用子程序时引起特权级的转换和堆栈的改变，
那么就需要将外层堆栈中的参数复制到内层堆栈。该双字计数字段就是用于说明这种情况发生时，要复制的双字参数的数量。
任务门指示任务。任务门内的选择子必须指向GDT中的任务状态段TSS描述符，门中的偏移无意义。任务的入口点保存在TSS中。
利用段间转移指令JMP和段间调用指令CALL，通过任务门可实现任务切换。
中断门和陷阱门描述中断/异常处理程序的入口点。中断门和陷阱门内的选择子必须指向代码段描述符，门内的偏移就是对应代码段的入口点偏移。
中断门和陷阱门只有在中断描述符表IDT中才有效。
题10.8长度最大的段可达多少？如何表示？
在保护方式下，每个段由如下三个参数进行定义：段基地址（BaseAddress）、段界限（Limit）和段属性（Attributes）。
段基地址规定线性地址空间中段的开始地址。在80386保护方式下，段基地址长32位。因为基地址长度与寻址地址的长度相同，
所以任何一个段都可以从32位线性地址空间中的任何一个字节开始，而不像实方式下规定段的边界必须被16整除。
段界限规定段的大小。在80386保护方式下，段界限用20位表示，而且段界限可以是以字节为单位或以4K字节为单位。
段属性中有一位对此进行定义，把该位称为粒度位(granularity)，用符号G标记。
G=0表示段界限以字节为单位，于是20位的界限可表示的范围是1字节至1M字节，增量为1字节；
G=1表示段界限以4K字节为单位，于是20位的界限可表示的范围是4K字节至4G字节，增量为4K字节。
当段界限以4K字节为单位时，实际的段界限LIMIT可通过下面的公式从20位段界限Limit 计算出来：
LIMIT = Limit*4K+0FFFH = (limit<<12) + 0FFFH
所以，当粒度位为1时，段的界限实际上就扩展成为32位。
段内偏移0到Limit范围内的虚拟地址对应于从Base到Base+Limit范围内的线性地址。
G=1表示段界限以4K字节为单位，于是20位的界限可表示的范围是4K字节至4G字节，增量为4K字节。
D=1表示段的上部界限为4G；D=0表示段的上部界限为64K，这是为了与80286兼容。
保护模式下，GD00=1100=C
DESCRIPTOR STRUC
LIMITL  DW 0
BASEL   DW 0
BASEM DB 0
ATTRIBUTES DW 0
BASEH  DB 0
DESCRIPTOR ENDS
VAllMem         DESCRIPTOR    <0FFFFH,0,,CF00H + ATDWA,>
题10.9符号 CPL、RPL、DPL代表什么？它们之间有何关系？
一般情况下代码都在自己的级别下做自己的工作，同一级别之间可以相互访问，不同级别之间不允许随意访问。
有时候，允许低特权级别的程序访问高特权级别的程序，比如应用程序调用系统的接口函数等。
非一致代码就是需要隔离的代码，低特权级别不允许随意访问，同一特权级别可以相互访问。
一致代码就是不需要隔离的代码，允许被同特权级别或低特权级别代码调用。
通过DPL、RPL、CPL实现特权分级和特权级检查 
DPL 描述符特权（Descriptor Privilege Level）存储在描述符中，用于描述段的特权等级。
RPL 请求特权（Request Privilege Level）存储在选择子的最低两位，说明当前对段访问的请求权限。
不要想随便设置一个rpl来访问一个比cpl更内层的段，因为申请的权限一定要比你实际权限低才能通过CPU的审查。 
CPL 当前任务特权（Current Privilege Level）表示当前代码段的特权级。CPL保存在CS中的最低两位，当选择子成功装入CS寄存器后，
相应的选择子中的RPL就变成了CPL。CS与SS的特权级必须保持一致。
访问一个段时，需要检查特权级，一般要求max {CPL, RPL} ≤ DPL。
访问数据段或堆栈段的程序的CPL≤待访问的数据段或堆栈段的DPL，同时选择子的RPL≤待访问的数据段或堆栈段的DPL，
即程序访问数据段或堆栈段要遵循一个准则：只有相同或更高特权级的代码才能访问相应的数据段。
访问数据段或堆栈段时，默认用CPU和RPL中的最小特权级去访问数据段，所以max {CPL, RPL} ≤ DPL，否则访问失败。
所有的程序跳转，都只能跳到等于当前特权级或比当前特权级更高的段。
所有的JMP，成功跳转后程序的CPL(CS.RPL) = 跳转前程序的CPL(CS.RPL) 
所有的CaLL，成功跳转到一致代码段后程序的CPL(CS.RPL) = 跳转前程序的CPL(CS.RPL)
成功跳转到非一致代码段后程序的CPL(CS.RPL) = 跳转后程序的Descriptor.DPL
RPL让程序有需要的时候（检查特权级的时候）可以表示一个比特权级CPL更低的身份Max(RPL,CPL)，而不会失去本身的特权级CPL(CS.RPL)，
RPL的值在成功跳转后并不赋给跳转后的CS.RPL。
普通跳转（没有经过Gate 这东西）：即JMP或Call后跟着48位全指针（16位段选择子+32位地址偏移），且其中的段选择子指向代码段描述符，
这样的跳转称为直接（普通）跳转。普通跳转不能使特权级发生跃迁，即不会引起CPL的变化。
目标是一致代码段：
要求：CPL(CS.RPL)>=DestinationDescriptorCode.DPL ，其他RPL是不检查的。只能外层特权级跳转到内层特权级，或者同特权级跳转。
跳转后程序的CPL(NewCS.RPL) = 跳转前程序的CPL( OldCS.RPL)
CPL没有发生变化，纵使它执行了特权级（DPL）较高的代码。
若访问时不满足要求，则发生异常。如果从内层特权级跳转到外层特权级，则发生异常。
目标是非一致代码段：
要求：CPL(CS.RPL)＝DestinationDescriptorCode.DPL AND RPL≤CPL(CS.RPL)
跳转后程序的CPL(NewCS.RPL) = DestinationDescriptorCode.DPL
因为前提是CPL=DPL，所以跳转后程序的CPL(NewCS.RPL) = DestinationDescriptorCode.DPL不会改变CPL的值，特权级(CPL)也没有发生变化。
如果访问时不满足前提CPL=DPL，则引发异常。
通过调用门的跳转：当段间转移指令JMP和段间转移指令CALL后跟着的目标段选择子指向一个调用门描述符时，该跳转就是利用调用门的跳转。
这时如果选择子后跟着32位的地址偏移，也不会被cpu使用，因为调用门描述符已经记录了目标代码的偏移。
使用调用门进行的跳转比普通跳转多一个步骤，即在访问调用门描述符时要将调用门描述符当作一个数据段来检查访问权限，
要求指示调用门描述符的选择子的RPL≤调用门描述符DPL，同时当前代码段CPL≤调用门描述符DPL，
就如同访问数据段一样，要求访问数据段的程序的CPL≤待访问的数据段的DPL，同时选择子的RPL≤待访问的数据段的DPL。
只有满足了以上条件，CPU才会进一步从调用门描述符中读取目标代码段的选择子和地址偏移，进行下一步的操作。
从调用门中读取到目标代码的段选择子和地址偏移后，我们当前掌握的信息又回到了先前，和普通跳转站在了同一条起跑线上
（普通跳转一开始就得到了目标代码的段选择子和地址偏移），有所不同的是，此时，CPU会将读到的目标代码段选择子中的RPL清0，
即忽略了调用门中代码段选择子的RPL的作用。完成这一步后，CPU开始对当前程序的CPL，目标代码段选择子的RPL
（事实上它被清0后总能满足要求）以及由目标代码选择子指示的目标代码段描述符中的DPL进行特权级检查，并根据情况进行跳转。
目标是一致代码段：
要求：CPL(CS.RPL)≥DestinationDescriptorCode.DPL ，RPL不检查。只能外层特权级跳转到内层特权级，或者同特权级跳转。
跳转后程序的CPL(NewCS.RPL) = 跳转前程序的CPL( OldCS.RPL)，因此特权级没有发生跃迁。
目标是非一致代码段：
当用JMP指令跳转时：
要求：CPL(CS.RPL)＝DestinationDescriptorCode.DPL　AND　RPL<= CPL(CS.RPL)
事实上因为RPL被清0，所以RPL≤CPL总能满足，因此RPL与CPL的关系在此不检查。若不满足要求则程序引起异常。
跳转后程序的CPL(NewCS.RPL) = DestinationDescriptorCode.DPL
因为前提是CPL=DPL，所以跳转后程序的CPL(NewCS.RPL) = DestinationDescriptorCode.DPL不会改变CPL的值，特权级也没有发生变化。
如果访问时不满足前提CPL=DPL，则引发异常。
当用CALL指令跳转时：
要求：CPL(CS.RPL)≥DestinationDescriptorCode.DPL（RPL被清0，不检查），若不满足要求则程序引起异常。
跳转后程序的CPL(NewCS.RPL) = DestinationDescriptorCode.DPL
当条件CPL=DPL时，程序跳转后CPL=DPL,特权级不发生跃迁；
当CPL＞DPL时，程序跳转后CPL=DPL,特权级发生跃迁。
这是目前见到的唯一使程序CPL发生变化的跳转方法，即用CALL指令+调用门方式跳转，且目标代码段是非一致代码段。
也就是从外层优先级跳转到内层优先级的非一致代码段。特权级发生变化，会引起堆栈切换，会切换为目的代码段相应特权级的堆栈。
题10.10在80386的某个时刻，全局描述符表GDT、局部描述符表LDT和中断描述符表IDT各有几张？
一个任务会涉及多个段，每个段需要一个描述符来描述，为了便于组织管理，80386把描述符组织成线性表。
由描述符组成的线性表称为描述符表。
在80386中有三种类型的描述符表：全局描述符表GDT（Global Descriptor Table）、局部描述符表LDT（Local Descriptor Table）和
中断描述符表IDT（Interrupt Descriptor Table）。
在整个系统中，全局描述符表GDT和中断描述符表IDT只有一张，局部描述符表可以有若干张，每个任务可以有一张。
每个描述符表本身形成一个特殊的数据段。这样的特殊数据段最多可以含有8K（8096）个描述符。(64K字节/8=8K个)
每个任务的局部描述符表LDT含有该任务自己的代码段、数据段和堆栈段的描述符，也包含该任务所使用的一些门描述符，
如任务门和调用门描述符等。随着任务的切换，系统当前的局部描述符表LDT也随之切换。
全局描述符表GDT含有每一个任务都可能或可以访问的段的描述符，通常包含描述操作系统所使用的代码段、数据段和堆栈段的描述符，
也包含多种特殊数据段描述符，如各个用于描述任务LDT的特殊数据段等。在任务切换时，并不切换GDT。
通过LDT可以使各任务私有的各个段与其他任务相隔离，从而达到受保护的目的。
通过GDT可以使各任务都需要使用的段能够被共享。
一个任务可使用的整个虚拟地址空间分为相等的两半，一半空间的描述符在全局描述符表中，另一半空间的描述符在局部描述符表中。
由于全局和局部描述符表都可以包含多达8096个描述符，而每个描述符所描述的段最大可达4G字节，因此最大的虚拟地址空间可为：
4GB*8096*2=64MMB=64T（字节）
在实方式下，逻辑地址空间中存储单元的地址有段值和段内偏移两部分组成。
在保护方式下，虚拟地址空间（相当于逻辑地址空间）中存储单元的地址有段选择子和段内偏移两部分组成。
与实方式相比，段选择子替代了段值。段选择子长16位，其格式如图10.7所示。
15               3   2   1   0
 描述符索引     TI   RPL
从图中可见，段选择子的高13位是描述符索引（Index），2^13（2的13次方）=8K。所谓描述符索引是指描述符在描述符表中的序号。
段选择子的第2位是引用描述符表指示位，标记为TI（Table Indicator），
TI=0指示从全局描述符表GDT中读取描述符；TI=1指示从局部描述符表LDT中读取描述符。
选择子确定描述符，描述符确定段基地址，段基地址与偏移之和就是线性地址。
所以，虚拟地址空间中的由段选择子和偏移两部分构成的二维虚拟地址，就是这样确定了线性地址空间中的一维线性地址。
选择子的最低两位是请求特权级RPL（Requested Privilege Level），用于特权检查。
由于选择子中的描述符索引字段用13位表示，所以可区分8096个描述符。
这也就是描述符表最多含有8096个描述符的原因。由于每个描述符长8字节，按照图10.7所示选择子格式，
屏蔽选择子低3位后所得的值就是选择子所指定的描述符在描述符表中的偏移，这可认为是安排选择子高13位为描述符索引的原因。
有一个特殊的选择子称为空（Null）选择子，它的Index=0，TI=0，而RPL字段可以为任意值。
空选择子有特定的用途，当用空选择子进行存储器访问时会引起异常。
空选择子是特别定义的，它不对应于全局描述符表GDT中的第0个描述符，因此GDT中的第0个描述符总不会被处理器访问，一般把它置成全0。
但当TI=1时，Index为0的选择子不是空选择子，它指定了当前任务局部描述符表LDT中的第0个描述符。
在实方式下，段寄存器含有段值，为访问存储器形成物理地址时，处理器引用相应的某个段寄存器得段值。
在保护方式下，段寄存器含有段选择子，如上所述，为访问存储器形成线性地址时，处理器要使用选择子所指定的描述符中的基地址等信息。
为了避免在每次存储器访问时，都要访问描述符表而获得对应段描述符，从80286开始每个段寄存器都配有一个高速缓冲寄存器，
称之为段描述符高速缓冲寄存器或称为描述符投影寄存器，对程序员而言它是不可见的。
每当把一个选择子装入到某个段寄存器时，处理器自动从描述符表中取出相应的描述符，把描述符中的信息保存到对应的高速缓冲寄存器中。
此后在对该段访问时，处理器都使用对应高速缓冲寄存器中的描述符信息，而不用再从描述符表中取描述符。
段描述符高速缓冲寄存器在处理器内，所以可对其进行快速访问。绝大多数情况下，对存储器的访问是在对应选择子装入到段寄存器之后进行的，
所以，使用段描述符高速缓冲寄存器可以得到很好的执行性能。
把选择子装入段寄存器和通过段描述符高速缓冲寄存器实现由虚拟地址到线性地址的转换情形如图10.8所示。
当不采用分页管理机制时，线性地址就是物理地址。
段描述符高速缓冲寄存器之内保存的描述符信息将一直保持到重新把选择子装载到段寄存器时再更新。
程序员尽管不可见段描述符高速缓冲寄存器，但必须注意到它的存在和它的上述更新时机。
例如，在改变了描述符表中的某个当前段的描述符后，也要更新对应的段描述符高速缓冲寄存器的内容，这可通过重新装载段寄存器实现。
80386有四个32位的控制寄存器CR0、CR1、CR2和CR3。
CR1被保留，供今后开发的处理器使用，在80386中不能使用CR1，否则将引起无效指令操作异常。
CR0包含指示处理器工作方式的控制位，包含启用和禁用分页管理机制的控制位，包含控制浮点协处理器操作的控制位。
CR2及CR3由分页管理机制使用。CR0中的位5~位30及CR3中的位0至位11是保留位，这些位不能是随意值，必须为0。
控制寄存器CR0的低16位等同于80286的机器状态字MSW。
       31                                            16 15        11                 4   3   2    1     0
CR0 PG 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 ET TS EM MP PE
CR1 保留
CR2 页故障线性地址
CR3 页目录表物理页码                                      0 0 0 0 0 0 0 0 0 0 0 0
控制寄存器CR0中的位0用PE标记，位31用PG标记，这两个位控制分段和分页管理机制的操作，所以把它们称为保护控制位。
PE控制分段管理机制。PE=0，处理器运行于实方式；PE=1，处理器运行于保护方式。
PG控制分页管理机制。PG=0，禁用分页管理机制，此时分段管理机制产生的线性地址直接作为物理地址使用；
PG=1，启用分页管理机制，此时线性地址经过分页管理机制转换成物理地址。
由于只有在保护方式下才可启用分页机制，所以尽管两个位分别为0和1，共可以有四种组合，但只有三种组合方式有效。
PE=0且PG=1是无效的组合，因此，用PG位为1且PE位为0的值装入CR0寄存器将引起通用保护异常。
控制寄存器CR0中的位1~位4分别标记为MP（算术存在位）、EM（模拟位）、TS（任务切换位）和ET（扩展类型位），
它们控制浮点协处理器的操作。
当处理器复位时，ET位被初始化，以指示系统中数字协处理器的类型。
如果系统中存在80387协处理器，那么ET位被置1；如果系统中存在80287协处理器或者不存在协处理器，那么ET位被清0。
EM位控制浮点指令的执行是用软件模拟，还是由硬件执行。EM=0时，硬件控制浮点指令传送到协处理器；EM=1时，浮点指令由软件模拟。
TS位用于加快任务的切换，通过在必要时才进行协处理器切换的方法实现这一目的。
每当进行任务切换时，处理器把TS置1。TS=1时，浮点指令将产生设备不可使用（DNA）异常。
MP位控制WAIT指令在TS=1时，是否产生DNA异常。MP=1和TS=1时，WAIT产生异常；MP=0时，WAIT指令忽略TS条件。
CR2用于发生页异常时报告出错信息。当发生页异常时，处理器把引起页异常的线性地址保存于CR2中。
操作系统中的页异常处理程序可以检查CR2的内容，从而查出线性空间中的哪一页引起本次异常。
CR3用于保存页目录表的起始物理地址。由于目录是页对齐的，所以仅高20位有效，低12位保留未用。
向CR3中装入新的值时，低12位必须为0；但从CR3中取值时，低12位被忽略。每当用MOV指令重置CR3值时，会导致分页高速缓冲区内容无效。
在实方式下也可设置CR3，以便进行分页机制的初始化。在任务切换时，CR3要被改变，但是如果新任务中CR3的值与原任务中CR3的值相同，
那么处理器不刷新分页高速缓冲寄存器，以便当任务共享页表时有较快的执行速度。
全局描述符表GDT、局部描述符表LDT和中断描述符表IDT等是保护方式下非常重要的特殊段。
为了方便快速地定位这些段，处理器采用一些特殊的寄存器保存这些段的基地址和界限。我们把这些特殊的寄存器称为系统地址寄存器。
          31              0 15       0
GDTR  Base             Limit
IDTR    Base             Limit
          15      0 31         0 31         0 11         0
LDTR 选择子   Base            Limit     Attributes
TR     选择子    Base           Limit      Attributes
如图10.9所示，GDTR长48位，其中高32位含基地址，低16位含界限。
由于GDT不能由GDT本身之内的描述符进行描述定义，所以处理器采用GDTR为GDT这一特殊的系统段提供一个伪描述符。
GDTR中的段界限以字节为单位。
通常，对于含有N个描述符的描述符表的段界限应设置为8*N-1。
利用结构类型可定义伪描述符如下：
PDESC STRUC
LIMIT DW 0
BASE DD 0
PDESC ENDS
局部描述符表寄存器LDTR规定当前任务使用的局部描述符表LDT。
如图10.9所示，LDTR类似于段寄存器，由程序员可见的一个16位的寄存器和程序员不可见的高速缓冲寄存器组成。
实际上，每个任务的局部描述符表LDT作为系统的一个特殊段，由一个存放在GDT中的描述符描述。
在初始化或任务切换过程中，把指示描述对应任务LDT的描述符的选择子装入LDTR，处理器根据装入LDTR可见部分的选择子，
从GDT中取出对应的描述符，并把LDT的基地址和界限等信息保存到LDTR的不可见的高速缓冲寄存器中。
随后对LDT的访问，就可根据保存在高速缓冲寄存器中的有关信息进行合法性检查。
LDTR寄存器包含当前任务的LDT的选择子。所以，装入到LDTR的选择子必须确定一个位于GDT的类型为LDT的系统段描述符，
也即选择子中的TI位必须是0，而且描述符中的类型字段所表示的类型必须是LDT。
可以用一个空选择子装入LDTR，这表示当前任务没有LDT。
在这种情况下，所有装入到段寄存器的选择子都必须指示GDT中的描述符，也即当前任务涉及的段均由GDT中的描述符来描述。
如果再把一个TI为1的选择子装入到段寄存器，将引起异常。
中断描述符表寄存器IDTR指向中断描述符表IDT。如图10.9所示，IDTR长48位，
其中32位的基地址规定IDT的基地址，16位的界限规定IDT的段界限。
由于80386只支持256个中断/异常，所以IDT表最大长度是2K，以字节为单位的段界限为7FFH。
IDTR指示IDT表的方式与GDTR指示GDT表的方式相同。
任务状态段寄存器TR包含指示描述当前任务的任务状态段的描述符选择子，从而规定了当前任务的状态段。
任务状态段的格式在10.5.2节说明。如图10.9所示，TR也有程序员可见和不见两部分。
当把任务状态段的选择子装入到TR可见部分时，处理器自动把选择子所索引的描述符中的段基地址等信息保存到不可见的高速缓冲寄存器中。
在此之后，对当前任务状态段的访问可快速方便地进行。
装入到TR的选择子不能为空，必须索引位于GDT中的描述符，且描述符的类型必须是TSS。
任务状态段（Task State Segment）是保存一个任务重要信息的特殊段。任务状态段描述符用于描述这样的系统段。
任务状态段寄存器TR的可见部分含有当前任务的任务状态段描述符的选择子，TR的不可见部分含有当前任务状态段的段基地址和段界限等信息。
TSS在任务切换过程中起着重要作用，通过它实现任务的挂起和恢复。所谓任务切换是指，挂起当前正在执行的任务，恢复另一个任务的执行。
在任务切换过程中，首先，处理器中各寄存器的当前值被自动地保存到TR所指定的TSS中；然后，下一任务的TSS的选择子被装入TR；
最后从TR所指定的TSS中取出各寄存器的值送到处理器的各寄存器中。
由此可见，通过在TSS中保存任务现场各寄存器状态的完整映象，实现任务的切换。
任务状态段TSS的基本格式如图10.14所示。
31                        16  15                0   偏移
0000000000000000   链接字段          0
ESP0                                                    4
0000000000000000    SS0                  8
ESP1                                                    0CH
0000000000000000    SS1                  10H
ESP2                                                    14H
0000000000000000    SS2                  18H
CR3                                                      1CH
EIP                                                        20H
EFLAGS                                                24H
EAX                                                      28H
ECX                                                      2CH
EDX                                                      30H
EBX                                                      34H
ESP                                                      38H
EBP                                                      3CH
ESI                                                       40H
EDI                                                      44H
0000000000000000   ES                     48H
0000000000000000   CS                     4CH
0000000000000000   SS                      50H
0000000000000000   DS                     54H
0000000000000000  FS                       58H
0000000000000000  GS                      5CH
0000000000000000   LDT                   60H
I/O许可位图 偏移        000000000000000 T 64H
104字节=68H字节
从中可见，TSS的基本格式有104字节组成。这104字节的基本格式是不可改变的，但在此之外系统软件还可定义若干附加信息。
基本的104字节可分为链接字段区域、内存堆栈指针区域、地址映射寄存器区域、寄存器保存区域和其它字段等五个区域。
1.寄存器保存区域
寄存器保存区域位于TSS内偏移20H至5FH处，用于保存通用寄存器、段寄存器、指令指针和标志寄存器。
当TSS对应的任务正在执行时，保存区域是未定义的；在当前任务被切换出时，这些寄存器的当前值就保存在该区域。
当下次切换回原任务时，再从保存区域恢复出这些寄存器的值，从而使处理器恢复成该任务换出前的状态，最终使任务能够恢复执行。
从图10.14可见，各通用寄存器对应一个32位的双字，指令指针和标志寄存器各对应一个32位的双字；
各段寄存器也对应一个32位的双字，段寄存器中的选择子只有16位，安排在双字的低16位，高16位空着未用。
2.内层堆栈指针区域
因为每个任务最多可能在四个特权级间转移，所以每个任务最多需要4个堆栈。
当从外层转移到内层时，内层堆栈的SS和ESP从TSS中的SS0、ESP0、SS1、ESP1、SS2、ESP2这里取得。
每当从外层转移到内层时，内层堆栈的SS和ESP都是TSS中确定的，相当于每次内层堆栈都初始化为空。
系统会把返回地址和外层堆栈的指针保留到内层堆栈中，将外层堆栈指针放入到内层堆栈中是为了向外层返回时，保证外层堆栈的正确。
当从内层返回到外层时，将恢复外层堆栈。
从外层到内层，可以通过CALL/JMP来直接转移，但从内层到外层，不能直接通过CALL/JMP，只能通过远程RET，
这样做的原因是为了确保内层的堆栈不被外层代码得知。
因为是从低特权级向高特权级转换，故TSS中没有最外层（最低特权级）的堆栈信息。
任务最开始执行时的SS和ESP就是最外层（最低特权级）的堆栈。
3.地址映射寄存器区域
由虚拟地址空间到线性地址空间的映射由GDT和LDT确定，与特定任务相关的部分由LDT确定，而LDT又由LDTR确定。
如果采用分页机制，那么由线性地址空间到物理地址空间的映射由包含页目录表起始物理地址的控制寄存器CR3确定。
所以，与特定任务相关的虚拟地址空间到物理地址空间的映射由LDTR和CR3确定。显然，随着任务的切换，地址映射关系也要切换。
TSS的地址映射寄存器区域由位于偏移1CH处的双字字段（CR3）和位于偏移60H处的字字段（LDT）组成。
在任务切换时，处理器自动从轮到执行的任务的TSS中取出这两个字段，分别装入到寄存器CR3和寄存器LDTR。
这样就改变了虚拟地址空间到物理地址空间的映射。
4.链接字段
链接字段安排在TSS内偏移0开始的双字中，其高16位未用。在起链接作用时，低16位保存前一任务的TSS描述符的选择子。
如果当前的任务由段间调用指令CALL或者中断/异常而激活，那么链接字段保存被挂起任务的TSS的选择子，
并且标志寄存器EFLAG中的NT位被置1，使链接字段有效。
在返回时，由于NT位为1，中断返回指令IRET将使得控制沿着链接字段所指恢复到链上的前一个任务。
5.其它字段
为了实现输入/输出保护，要使用I/O许可位图。任务使用的I/O许可位图也存放在TSS中，作为TSS的扩展部分。
在TSS内偏移66H处的字用于存放I/O许可位图在TSS内的开始偏移。关于I/O许可位图的作用在10.9节中介绍。
在TSS偏移102字节处有一个单字被称为“I/O位图基址”（它的值一般为当前地址-TSS基址+2，表示I/O许可位图从TSS的104字节开始），
它的每一位表示一个字节的端口地址是否可用。如果某一位为0，则表示此位对应的端口号可用，为1则不可用。
每一个任务都可以有单独的TSS，故每一个任务可以有它单独的I/O许可位图。I/O许可位图必须以0FFh结尾。
如果I/O位图基址大于或等于TSS段界限，就表示没有I/O许可位图，如果CPL>=IOPL（IO特权级，位于寄存器eflags的第13位），
则所有I/O指令都会引起异常。I/O许可位图的使用使得即便在同一特权级下不同的任务也可以有不同的I/O访问权限。
I/O地址空间由64K个可单独寻址的8位I/O端口组成，I/O许可位图的最大尺寸就是8K字节。
一般这样分配, 从TSS的104字节开始, 列出自己想填写的I/O许可位图, 对于不想列出的后面部分以0FF结束就可以了。
CLI, STI, IN, INS, OUT, OUTS等指令是I/O敏感指令
保护模式下处理器在执行I/O敏感指令时进行许可检查的细节如下所示。 
(1)若CPL<=IOPL，则直接转步骤(8)；
(2)取得I/O位图开始偏移；
(3)计算I/O地址对应位所在字节在I/O许可位图内的偏移；
(4)计算位偏移以形成屏蔽码值，即计算I/O地址对应位在字节中的第几位；
(5)把字节偏移加上位图开始偏移，再加1，所得值与TSS界限比较，若越界，则产生通用保护异常；
(6)若不越界，则从位图中读对应字节及下一个字节；
(7)把读出的两个字节与屏蔽码进行与运算，若结果不为0表示检查未通过，则产生通用保护异常；
(8)进行I/O访问。
INSD, 一次访问4个端口地址, 需要4个位, 有可能低位在一个字节, 高位又在一个字节。 
为了避免这种情况, 处理器每次读取I/O许可位图的时候是2个字节2个字节读取的, 这样， 不管多坏的情况也不可能超过2个字节。
这样在结尾加个0FFh也就比较好理解了, 如果不加那就越界了。 加其他的值也不好区分, 只有每个位加1才不会曲解原来的I/O许可位图.
只有特权级为0的程序才能够修改Eflags中的IOPL和VM位, 相对于IOPL更内层的特权级才能够修改IF位。
 如果特权级不符合要求, 修改这些位的话, 也不会异常, CPU会忽略。
在TSS内偏移64H处的字是为任务提供的特别属性。在80386中，只定义了一种属性，即调试陷阱。
该属性是字的最低位，用T表示。该字的其他位被保留，必须被置成0。
在发生任务切换时，如果进入任务的T位为1，那么在任务切换完成之后，新任务的第一条指令执行之前产生调试陷阱。
6.用结构类型定义TSS
根据如图10.14给出的任务状态段TSS的结构，可定义如下的TSS结构类型：
TASKSS STRUC
DW ?,0
DD ?
DW ?,0
DD ?
DW ?,0
DD ?
DW ?,0
DD ?
DD ?
DW ?,?
DD ?
DD ?
DD ?
DD ?
DD ?
DD ?
DD ?
DD ?
DW ?,0
DW ?,0
DW ?,0
DW ?,0
DW ?,0
DW ?,0
DW ?,0
DW 0
DW $ + 2
DB 0FFH
TASKSS ENDS
题10.11描述符表的最大有效段界限是多少？
在80386中有三种类型的描述符表：全局描述符表GDT（Global Descriptor Table）、局部描述符表LDT（Local Descriptor Table）和
中断描述符表IDT（Interrupt Descriptor Table）。
在整个系统中，全局描述符表GDT和中断描述符表IDT只有一张，局部描述符表可以有若干张，每个任务可以有一张。
全局和局部描述符表都可以包含多达8096个描述符，所以GDT和LDT表最大长度是64K，以字节为单位的段界限为FFFFH。
由于80386只支持256个中断/异常，所以IDT表最大长度是2K，以字节为单位的段界限为7FFH。
题10.12请写出在 10.2.3节中所列描述符表DESCTAB中的6个描述符所描述的各个段的段基地址、段界限和段属性。
DESCTAB LABEL BYTE
DESC1 DESCRIPTOR <1234H,5678H,34H,92H,0>
base=00345678H,limit=1234H,attr=92H
DESC2 DESCRIPTOR <1234H,5678H,34H,93H,0>
base=00345678H,limit=1234H,attr=93H
DESC3 DESCRIPTOR <5678H,1234H,56H,98H,0>
base=00561234H,limit=5678H,attr=98H
DESC4 DESCRIPTOR <5678H,1234H,56H,99H,0>
base=00561234H,limit=5678H,attr=99H
DESC5 DESCRIPTOR <0FFFFH,0,10H,16H,0>
base=00100000H,limit=FFFFH,attr=16H
DESC6 DESCRIPTOR <0FFFFH,0,10H,90H,0>
base=00100000H,limit=FFFFH,attr=90H
题10.13如何实现某个段被两个任务共享，但又不被第三个任务所共享？
通过LDT可以使各任务私有的各个段与其他任务相隔离，通过GDT可以使各任务都需要使用的段能够被共享。
虚拟地址到物理地址的映射函数在每个任务中进行定义，通过线性地址空间的共享，也就是不同任务的部分相同的线性地址空间的映射信息相同，
实现某个段被两个任务共享，但又不被第三个任务所共享
通过描述符表和描述符，分段管理机制实现虚拟地址空间到线性地址空间的映射，实现把二维的虚拟地址转换为一维的线性地址。
通过在线性地址空间的页与物理地址空间的页之间建立的映射表，分页管理机制实现线性地址空间到物理地址空间的映射，实现线性地址到物理地址的转换。
题10.14选择子与段值有何区别？
在实方式下，逻辑地址空间中存储单元的地址有段值和段内偏移两部分组成。
在保护方式下，虚拟地址空间（相当于逻辑地址空间）中存储单元的地址有段选择子和段内偏移两部分组成。
与实方式相比，段选择子替代了段值。段选择子长16位，其格式如图10.7所示。
15               3   2   1   0
 描述符索引     TI   RPL
从图中可见，段选择子的高13位是描述符索引（Index），也就是描述符在描述符表中的序号。
段选择子的第2位是引用描述符表指示位，标记为TI（Table Indicator），
TI=0指示从全局描述符表GDT中读取描述符；TI=1指示从局部描述符表LDT中读取描述符。
选择子确定描述符，描述符确定段基地址，段基地址与偏移之和就是线性地址。
选择子的最低两位是请求特权级RPL（Requested Privilege Level），用于特权检查。
有一个特殊的选择子称为空（Null）选择子，它的Index=0，TI=0，而RPL字段可以为任意值。
空选择子有特定的用途，当用空选择子进行存储器访问时会引起异常。
空选择子是特别定义的，它不对应于全局描述符表GDT中的第0个描述符，因此GDT中的第0个描述符总不会被处理器访问，一般把它置成全0。
但当TI=1时，Index为0的选择子不是空选择子，它指定了当前任务局部描述符表LDT中的第0个描述符。
题10.15 80386 控制寄存器的作用是什么？系统地址寄存器的作用是什么？
80386有四个32位的控制寄存器CR0、CR1、CR2和CR3。
CR1被保留，供今后开发的处理器使用，在80386中不能使用CR1，否则将引起无效指令操作异常。
CR0包含指示处理器工作方式的控制位，包含启用和禁用分页管理机制的控制位，包含控制浮点协处理器操作的控制位。
CR2及CR3由分页管理机制使用。CR0中的位5~位30及CR3中的位0至位11是保留位，这些位不能是随意值，必须为0。
控制寄存器CR0的低16位等同于80286的机器状态字MSW。
       31                                            16 15        11                 4   3   2    1     0
CR0 PG 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 ET TS EM MP PE
CR1 保留
CR2 页故障线性地址
CR3 页目录表物理页码                                      0 0 0 0 0 0 0 0 0 0 0 0
控制寄存器CR0中的位0用PE标记，位31用PG标记，这两个位控制分段和分页管理机制的操作，所以把它们称为保护控制位。
PE控制分段管理机制。PE=0，处理器运行于实方式；PE=1，处理器运行于保护方式。
PG控制分页管理机制。PG=0，禁用分页管理机制，此时分段管理机制产生的线性地址直接作为物理地址使用；
PG=1，启用分页管理机制，此时线性地址经过分页管理机制转换成物理地址。
由于只有在保护方式下才可启用分页机制，所以尽管两个位分别为0和1，共可以有四种组合，但只有三种组合方式有效。
PE=0且PG=1是无效的组合，因此，用PG位为1且PE位为0的值装入CR0寄存器将引起通用保护异常。
控制寄存器CR0中的位1~位4分别标记为MP（算术存在位）、EM（模拟位）、TS（任务切换位）和ET（扩展类型位），
它们控制浮点协处理器的操作。
当处理器复位时，ET位被初始化，以指示系统中数字协处理器的类型。
如果系统中存在80387协处理器，那么ET位被置1；如果系统中存在80287协处理器或者不存在协处理器，那么ET位被清0。
EM位控制浮点指令的执行是用软件模拟，还是由硬件执行。EM=0时，硬件控制浮点指令传送到协处理器；EM=1时，浮点指令由软件模拟。
TS位用于加快任务的切换，通过在必要时才进行协处理器切换的方法实现这一目的。
每当进行任务切换时，处理器把TS置1。TS=1时，浮点指令将产生设备不可使用（DNA）异常。
MP位控制WAIT指令在TS=1时，是否产生DNA异常。MP=1和TS=1时，WAIT产生异常；MP=0时，WAIT指令忽略TS条件。
CR2用于发生页异常时报告出错信息。当发生页异常时，处理器把引起页异常的线性地址保存于CR2中。
操作系统中的页异常处理程序可以检查CR2的内容，从而查出线性空间中的哪一页引起本次异常。
CR3用于保存页目录表的起始物理地址。由于目录是页对齐的，所以仅高20位有效，低12位保留未用。
向CR3中装入新的值时，低12位必须为0；但从CR3中取值时，低12位被忽略。每当用MOV指令重置CR3值时，会导致分页高速缓冲区内容无效。
在实方式下也可设置CR3，以便进行分页机制的初始化。在任务切换时，CR3要被改变，但是如果新任务中CR3的值与原任务中CR3的值相同，
那么处理器不刷新分页高速缓冲寄存器，以便当任务共享页表时有较快的执行速度。
全局描述符表GDT、局部描述符表LDT和中断描述符表IDT等是保护方式下非常重要的特殊段。
为了方便快速地定位这些段，处理器采用一些特殊的寄存器保存这些段的基地址和界限。我们把这些特殊的寄存器称为系统地址寄存器。
          31              0 15       0
GDTR  Base             Limit
IDTR    Base             Limit
          15      0 31         0 31         0 11         0
LDTR 选择子   Base            Limit     Attributes
TR     选择子    Base           Limit      Attributes
如图10.9所示，GDTR长48位，其中高32位含基地址，低16位含界限。
由于GDT不能由GDT本身之内的描述符进行描述定义，所以处理器采用GDTR为GDT这一特殊的系统段提供一个伪描述符。
GDTR中的段界限以字节为单位。
通常，对于含有N个描述符的描述符表的段界限应设置为8*N-1。
利用结构类型可定义伪描述符如下：
PDESC STRUC
LIMIT DW 0
BASE DD 0
PDESC ENDS
局部描述符表寄存器LDTR规定当前任务使用的局部描述符表LDT。
如图10.9所示，LDTR类似于段寄存器，由程序员可见的一个16位的寄存器和程序员不可见的高速缓冲寄存器组成。
实际上，每个任务的局部描述符表LDT作为系统的一个特殊段，由一个存放在GDT中的描述符描述。
在初始化或任务切换过程中，把指示描述对应任务LDT的描述符的选择子装入LDTR，处理器根据装入LDTR可见部分的选择子，
从GDT中取出对应的描述符，并把LDT的基地址和界限等信息保存到LDTR的不可见的高速缓冲寄存器中。
随后对LDT的访问，就可根据保存在高速缓冲寄存器中的有关信息进行合法性检查。
LDTR寄存器包含当前任务的LDT的选择子。所以，装入到LDTR的选择子必须确定一个位于GDT的类型为LDT的系统段描述符，
也即选择子中的TI位必须是0，而且描述符中的类型字段所表示的类型必须是LDT。
可以用一个空选择子装入LDTR，这表示当前任务没有LDT。
在这种情况下，所有装入到段寄存器的选择子都必须指示GDT中的描述符，也即当前任务涉及的段均由GDT中的描述符来描述。
如果再把一个TI为1的选择子装入到段寄存器，将引起异常。
中断描述符表寄存器IDTR指向中断描述符表IDT。如图10.9所示，IDTR长48位，
其中32位的基地址规定IDT的基地址，16位的界限规定IDT的段界限。
由于80386只支持256个中断/异常，所以IDT表最大长度是2K，以字节为单位的段界限为7FFH。
IDTR指示IDT表的方式与GDTR指示GDT表的方式相同。
任务状态段寄存器TR包含指示描述当前任务的任务状态段的描述符选择子，从而规定了当前任务的状态段。
任务状态段的格式在10.5.2节说明。如图10.9所示，TR也有程序员可见和不见两部分。
当把任务状态段的选择子装入到TR可见部分时，处理器自动把选择子所索引的描述符中的段基地址等信息保存到不可见的高速缓冲寄存器中。
在此之后，对当前任务状态段的访问可快速方便地进行。
装入到TR的选择子不能为空，必须索引位于GDT中的描述符，且描述符的类型必须是TSS。
题10.16段描述符高速缓冲寄存器有何作用？
在实方式下，段寄存器含有段值，为访问存储器形成物理地址时，处理器引用相应的某个段寄存器得段值。
在保护方式下，段寄存器含有段选择子，如上所述，为访问存储器形成线性地址时，处理器要使用选择子所指定的描述符中的基地址等信息。
为了避免在每次存储器访问时，都要访问描述符表而获得对应段描述符，从80286开始每个段寄存器都配有一个高速缓冲寄存器，
称之为段描述符高速缓冲寄存器或称为描述符投影寄存器，对程序员而言它是不可见的。
每当把一个选择子装入到某个段寄存器时，处理器自动从描述符表中取出相应的描述符，把描述符中的信息保存到对应的高速缓冲寄存器中。
此后在对该段访问时，处理器都使用对应高速缓冲寄存器中的描述符信息，而不用再从描述符表中取描述符。
段描述符高速缓冲寄存器在处理器内，所以可对其进行快速访问。绝大多数情况下，对存储器的访问是在对应选择子装入到段寄存器之后进行的，
所以，使用段描述符高速缓冲寄存器可以得到很好的执行性能。
段描述符高速缓冲寄存器之内保存的描述符信息将一直保持到重新把选择子装载到段寄存器时再更新。
题10.17在从 保护方式切换到实方式时要注意什么？
在准备结束保护方式回到实方式之前，要通过加载一个合适的描述符的选择子到有关段寄存器，以使得对应段描述符高速缓冲寄存器中含有合适的段界限和属性。
每个段寄存器都配有段描述符高速缓冲寄存器，这些高速缓冲寄存器在实方式下仍发挥作用，只是内容上与保护方式下有所不同。
段基地址仍是32位，其值是相应段寄存器值（段值）乘16，在把段值装载到段寄存器时被刷新。
由于其值是16位段值乘上16，所以在实方式下基地址实际有效位只有20位。每个段的32位段界限都固定为0FFFFH，段属性的许多位也是固定的。
所谓固定是指在实方式下必须是某些值。但在实方式下，不可设置这些属性值，只能继续沿用保护方式下所设置的值。
在80386上，从保护方式切换到实方式的过程类似于从实方式切换到保护方式。原则上只要把控制寄存器CR0中的PE位清0就可。
实际上，在此之后也要安排一条段间转移指令，一方面清指令预取队列，另一方面把实方式下代码段的段值送CS。
这条段间转移指令在保护方式下被预取，在实方式下被执行。
PC及其兼容机的第20根地址线较特殊，计算机系统中一般安排一个“门”控制该地址线是否有效。
如果需要访问地址在1M以上的存储单元，应打开控制地址线A20的“门”。如果不用访问地址在1M以上的存储单元，应关闭控制地址线A20的“门”。
使用92h端口控制A20。
读A20状态
mov dx, 92h
in al, dx
如果al的bit 1为1表示a20打开，否则为0
如下的两个过程，在一般的PC兼容机上都是可行的。
ENABLEA20 PROC
PUSH AX
IN AL,92H
OR AL,2
OUT 92H,AL
POP AX
RET
ENABLEA20 ENDP
DISABLEA20 PROC
PUSH AX
IN AL,92H
AND AL,0FDH
OUT 92H,AL
POP AX
RET
DISABLEA20 ENDP
题10.18在从实方式切换到保护方式时要做哪些准备工作？
在从实方式切换到保护方式之前，必须作必要的准备。准备工作的内容根据实际应用而定。
最起码的准备工作是建立合适的全局描述符表，并使GDTR指向该GDT。
由于在切换到保护方式后，就要引用GDT，所以在切换到保护方式前须装载GDTR。
通常准备工作还应包含建立中断描述符表。如果没有建立中断描述符表，则整个过程应在关中断的情况下进行，并且不使用软中断指令，不发生任何异常。
通常准备工作还应包含建立局部描述符表，并在进入保护方式后使LDTR指向该LDT。
如果没有使用局部描述符表，可以在进入保护方式后使LDTR指向空选择子，同时在保护方式下使用的段选择子都指定GDT中的描述符。
在做好准备后，从实方式切换到保护方式，原则上只要把控制寄存器CR0中的PE位置1就可。可以采用如下三条指令设置PE位：
MOV EAX,CR0  把CR0复制到EAX
OR EAX,1          把对应的PE位置1
MOV CR0,EAX  把EAX复制到CR0 使CR0的PE位为1
实际情况要比这复杂些。在执行上面的三条指令后，处理器转入保护方式，但CS中的内容还是实方式下代码段的段值，
而不是保护方式下代码段的选择子，所以在取指令之前得把代码段选择子装入CS。
为此，紧接着这三条指令，安排一条如下所示的段间转移指令：
JUMP <CODE_SEL>,<OFFSET VIRTUAL>
这条段间转移指令在实方式下被预取，在保护方式下被执行。
利用这条段间转移指令可把保护方式下代码段的选择子装入CS，同时也刷新指令预取队列。从此真正进入保护方式。
题10.19 32 位段与16位段的区别是什么？代码段描述符如何描述32位代码段和16位代码段？
在实方式下，80386保持与原先的8086/8088兼容，所以段的最大长度仍是64K，这样的段称为16位段。
但在保护方式下，段长度可达4G，这样的段称为32位段。为了兼容，在保护方式下，也可使用16位段。
在32位代码段中，缺省的操作数大小是32位，缺省的存储单元地址大小也是32位。
串操作指令使用的指针寄存器是ESI和EDI，LOOP指令使用的计数器是ECX。
段属性中的G位和D位
G=0表示段界限以字节为单位，于是20位的界限可表示的范围是1字节至1M字节，增量为1字节；
G=1表示段界限以4K字节为单位，于是20位的界限可表示的范围是4K字节至4G字节，增量为4K字节。
在描述可执行段的描述符中，D位决定了指令使用的地址及操作数所默认的大小。
D=1表示默认情况下指令使用32位地址及32位或8位操作数，这样的代码段也称为32位代码段；
D=0表示默认情况下使用16位地址及16位或8位的操作数，这样的代码段也称为16位代码段，它与80286兼容。
在向低扩展数据段的描述符中，D位决定段的上部边界。
D=1表示段的上部界限为4G；D=0表示段的上部界限为64K，这是为了与80286兼容。
在描述由SS寄存器寻址的段描述符中，D位决定隐式的堆栈访问指令（如PUSH和POP指令）使用何种堆栈指针寄存器。
D=1表示使用32位堆栈指针寄存器ESP；D=0表示使用16位堆栈指针寄存器SP，这与80286兼容。
题10.20任务状态段的作用是什么？
任务状态段（Task State Segment）是保存一个任务重要信息的特殊段。任务状态段描述符用于描述这样的系统段。
任务状态段寄存器TR的可见部分含有当前任务的任务状态段描述符的选择子，TR的不可见部分含有当前任务状态段的段基地址和段界限等信息。
TSS在任务切换过程中起着重要作用，通过它实现任务的挂起和恢复。所谓任务切换是指，挂起当前正在执行的任务，恢复另一个任务的执行。
在任务切换过程中，首先，处理器中各寄存器的当前值被自动地保存到TR所指定的TSS中；然后，下一任务的TSS的选择子被装入TR；
最后从TR所指定的TSS中取出各寄存器的值送到处理器的各寄存器中。
由此可见，通过在TSS中保存任务现场各寄存器状态的完整映象，实现任务的切换。
任务状态段TSS的基本格式有104字节组成。这104字节的基本格式是不可改变的，但在此之外系统软件还可定义若干附加信息。
基本的104字节可分为链接字段区域、内存堆栈指针区域、地址映射寄存器区域、寄存器保存区域和其它字段等五个区域。
1.寄存器保存区域
寄存器保存区域位于TSS内偏移20H至5FH处，用于保存通用寄存器、段寄存器、指令指针和标志寄存器。
当TSS对应的任务正在执行时，保存区域是未定义的；在当前任务被切换出时，这些寄存器的当前值就保存在该区域。
当下次切换回原任务时，再从保存区域恢复出这些寄存器的值，从而使处理器恢复成该任务换出前的状态，最终使任务能够恢复执行。
从图10.14可见，各通用寄存器对应一个32位的双字，指令指针和标志寄存器各对应一个32位的双字；
各段寄存器也对应一个32位的双字，段寄存器中的选择子只有16位，安排在双字的低16位，高16位空着未用。
2.内层堆栈指针区域
因为每个任务最多可能在四个特权级间转移，所以每个任务最多需要4个堆栈。
当从外层转移到内层时，内层堆栈的SS和ESP从TSS中的SS0、ESP0、SS1、ESP1、SS2、ESP2这里取得。
每当从外层转移到内层时，内层堆栈的SS和ESP都是TSS中确定的，相当于每次内层堆栈都初始化为空。
系统会把返回地址和外层堆栈的指针保留到内层堆栈中，将外层堆栈指针放入到内层堆栈中是为了向外层返回时，保证外层堆栈的正确。
当从内层返回到外层时，将恢复外层堆栈。
从外层到内层，可以通过CALL/JMP来直接转移，但从内层到外层，不能直接通过CALL/JMP，只能通过远程RET，
这样做的原因是为了确保内层的堆栈不被外层代码得知。
因为是从低特权级向高特权级转换，故TSS中没有最外层（最低特权级）的堆栈信息。
任务最开始执行时的SS和ESP就是最外层（最低特权级）的堆栈。
3.地址映射寄存器区域
由虚拟地址空间到线性地址空间的映射由GDT和LDT确定，与特定任务相关的部分由LDT确定，而LDT又由LDTR确定。
如果采用分页机制，那么由线性地址空间到物理地址空间的映射由包含页目录表起始物理地址的控制寄存器CR3确定。
所以，与特定任务相关的虚拟地址空间到物理地址空间的映射由LDTR和CR3确定。显然，随着任务的切换，地址映射关系也要切换。
TSS的地址映射寄存器区域由位于偏移1CH处的双字字段（CR3）和位于偏移60H处的字字段（LDT）组成。
在任务切换时，处理器自动从轮到执行的任务的TSS中取出这两个字段，分别装入到寄存器CR3和寄存器LDTR。
这样就改变了虚拟地址空间到物理地址空间的映射。
4.链接字段
链接字段安排在TSS内偏移0开始的双字中，其高16位未用。在起链接作用时，低16位保存前一任务的TSS描述符的选择子。
如果当前的任务由段间调用指令CALL或者中断/异常而激活，那么链接字段保存被挂起任务的TSS的选择子，
并且标志寄存器EFLAG中的NT位被置1，使链接字段有效。
在返回时，由于NT位为1，中断返回指令IRET将使得控制沿着链接字段所指恢复到链上的前一个任务。
5.其它字段
为了实现输入/输出保护，要使用I/O许可位图。任务使用的I/O许可位图也存放在TSS中，作为TSS的扩展部分。
在TSS内偏移66H处的字用于存放I/O许可位图在TSS内的开始偏移。
在TSS偏移102字节处有一个单字被称为“I/O位图基址”（它的值一般为当前地址-TSS基址+2，表示I/O许可位图从TSS的104字节开始），
它的每一位表示一个字节的端口地址是否可用。如果某一位为0，则表示此位对应的端口号可用，为1则不可用。
每一个任务都可以有单独的TSS，故每一个任务可以有它单独的I/O许可位图。I/O许可位图必须以0FFh结尾。
如果I/O位图基址大于或等于TSS段界限，就表示没有I/O许可位图，如果CPL>=IOPL（IO特权级，位于寄存器eflags的第13位），
则所有I/O指令都会引起异常。I/O许可位图的使用使得即便在同一特权级下不同的任务也可以有不同的I/O访问权限。
I/O地址空间由64K个可单独寻址的8位I/O端口组成，I/O许可位图的最大尺寸就是8K字节。
一般这样分配, 从TSS的104字节开始, 列出自己想填写的I/O许可位图, 对于不想列出的后面部分以0FF结束就可以了。
在TSS内偏移64H处的字是为任务提供的特别属性。在80386中，只定义了一种属性，即调试陷阱。
该属性是字的最低位，用T表示。该字的其他位被保留，必须被置成0。
在发生任务切换时，如果进入任务的T位为1，那么在任务切换完成之后，新任务的第一条指令执行之前产生调试陷阱。
题10.21在保护方式下，控制转移有哪些情形？通过转移指令JMP的转移与通过调用指令CALL的转移有和区别？
控制转移基本上可分为两大类：同一任务内的控制转移和任务间的控制转移（任务切换）。
同一任务内的控制转移又分为：段内转移、特权级不变的段间转移和特权级变换的段间转移。
段内转移与实方式下相似，不涉及特权级变换和任务切换。只有段间转移才涉及特权级变换和任务切换。
指令JMP、CALL和RET都具有段间转移的功能，指令INT和IRET总是段间转移。
段间转移指令JMP和段间调用指令CALL还可分为段间直接转移和段间间接转移两类。
如果指令JMP和CALL在指令中直接含有目标地址指针，那么就是段间直接转移；
如果指令中含有指向包含目标地址指针的门描述符或TSS描述符的指针，那么就是段间间接转移，
这种指针只有选择子部分有效，指示调用门、任务门或TSS描述符，而偏移部分不起作用。
实际上，当段间转移指令JMP和段间调用指令CALL所含指针的选择子部分指示代码段描述符，那么就是段间直接转移，
偏移部分表示目标代码段的入口点；当选择子部分指示门描述符或TSS描述符时，就是段间间接转移。
利用段间转移指令JMP、段间调用指令CALL和段间返回指令RET可实现任务内无特权级变换的转移。
利用INT指令和IRET指令也可实现任务内无特权级变换的转移。
利用段间转移指令JMP实现任务内无特权级变换的转移，当前CS和IP不压入堆栈
利用段间调用指令CALL实现任务内无特权级变换的转移，当前CS和IP压入堆栈，
段间返回指令RET实现任务内无特权级变换的转移，从堆栈弹出返回地址（由选择子和偏移构成）。
在同一任务内，实现特权级从外层到内层变换的普通途径是：使用段间调用指令CALL，通过调用门进行转移；
实现特权级从内层到外层变换的普通途径是：使用段间返回指令RET。
不能利用JMP指令实现任务内不同特权级的变换。
当段间转移指令JMP和段间调用指令CALL所含指针的选择子指示调用门描述符时，就可实现通过调用门的转移。
段间调用指令CALL和段间转移指令JMP所做的检测不一样。
对于使用调用门的段间转移指令JMP，检测条件与段间直接转移相同。由于已置RPL=0，所以可认为RPL<=DPL的条件总能满足。
所以，对于普通的非一致代码段，当CPL=DPL时，发生无特权级变换的转移；
对于一致代码段，在满足CPL>=DPL时也发生无特权级变换的转移；其他情形就引起异常。
对于使用调用门的段间调用指令CALL，情形就不同了。由于已置RPL=0，所以可认为RPL<=DPL的条件总能满足。
对于一致代码段，在满足CPL>=DPL时发生无特权级变换的转移。
对于非一致代码段，当CPL=DPL时，仍发生无特权级变换的转移；
当CPL>DPL时，就发生向内层特权级变换的转移，使CPL保持等于DPL，同时切换到对应的内层堆栈。
综上所述，使用段间调用指令CALL，通过调用门可以实现从外层程序调用进入内层程序；通过调用门也可实现无特权级变换的转移。
当然，CALL指令在最后把目标代码段的指针装入CS和EIP之前，要把原CS和EIP，即返回地址保存到堆栈。
如无特权级变换，堆栈保持不变，返回地址就保存在原堆栈中；如变换特权级，那么返回地址保存在内层堆栈中。
在使用CALL指令，通过调用门向内层转移时，不仅特权级发生变换，控制转移到一个新的代码段，而且也切换到内层的堆栈段。
在特权级发生向内层变换时，根据特权级使用TSS中相应的堆栈指针对SS及ESP寄存器进行初始化，建立起一个空栈。
在建立起内层堆栈后，先把外层堆栈的指针SS及ESP寄存器的值压入内层堆栈，以使得相应的向外层返回可恢复原来的外层堆栈。
然后，从外层堆栈复制以双字为单位的调用参数到内层堆栈，调用门中的DCOUNT字段值决定了复制参数的量。
这些被复制的参数是主程序通过堆栈传递给子程序的实参，在调用之前被压入外层堆栈。
通过复制堆栈中的参数，使内层的子程序不需要考虑堆栈的切换，而容易地访问主程序传递过来的实参。
最后，调用的返回地址被压入堆栈，以便在调用结束时返回。
与使用CALL指令通过调用门向内层变换相反，使用RET指令实现向外层返回。
段间返回指令RET从堆栈中弹出返回地址，并且可以采用调整ESP的方法，跳过相应的在调用之前压入堆栈的参数。
返回地址的选择子指示要返回的代码段描述符，从而确定返回的代码段。
RET指令先从堆栈弹出返回地址。如果返回地址的选择子的RPL规定相对于CPL更外层的级，那么就引起向外层返回。
其次，为向外层返回，跳过内层堆栈中的参数，再从内层堆栈中弹出指向外层堆栈的指针，并装入到SS及ESP，以恢复外层堆栈。
再次，调整ESP，跳过在相应的调用之前压入到外层堆栈的参数。然后，检查数据段寄存器DS、ES、FS及GS，
以保证寻址的段在外层是可访问的，如果段寄存器寻址的段在外层是不可访问的，那么装入一个空选择子。
最后，返回（外层）继续执行。
上述五步是对带立即数段间返回指令而言的，立即数规定了堆栈中要跳过的参数的字节数。
对无立即数段间返回指令而言，缺少第二和第三步。如果RET指令不需要向外层返回，那么就只有开始和最后的两步。
利用段间转移指令JMP或者段间调用指令CALL，通过任务门或者直接通过任务状态段，可以切换到别的任务。
此外，在中断/异常或者执行IRET指令时也可能发生任务切换。
当段间转移指令JMP或段间调用指令CALL所含指针的选择子指示一个可用任务状态段TSS描述符时，
正常情况下就发生从当前任务到由该可用TSS对应任务（目标任务）的切换。目标任务的入口点由目标任务TSS内的CS和EIP字段所规定的指针确定。
这样的JMP或CALL指令内的偏移被丢弃。
当段间转移指令JMP或段间调用指令CALL所含指针的选择子指示一个任务门时，
正常情况下就发生任务切换，也即从当前任务切换到由任务门内的选择子所指示的TSS描述符对应的任务（目标任务）。
这样的JMP或CALL指令内的偏移被丢弃；任务门内的偏移也无意义。
在段间转移指令JMP引起任务切换时，不实施链接，不导致任务的嵌套。
它要求目标任务是可用的任务。切换过程中把原任务置为“可用”，目标任务置为“忙”。
在段间调用指令CALL引起任务切换时，实施链接，导致任务的嵌套。它要求目标任务是可用的任务。
在切换过程中把目标任务置为“忙”，原任务仍保持“忙”；标志寄存器EFLAGS中的NT位被置1，表示是嵌套任务。
在由中断/异常引起任务切换时，实施链接，导致任务的嵌套。要求目标任务是可用的任务。
在切换过程中把目标任务置为“忙”，原任务仍保持“忙”；标志寄存器EFLAG中的NT位被置1，表示是嵌套任务。
在执行IRET时引起任务切换，那么实施解链。要求目标任务是忙的任务。在切换过程中把原任务置为“可用”，目标任务仍保持“忙”。
题10.22如何体现特权级变换？特权级变换必须满足什么条件？
在一个任务之内，可以存在四种特权级，所以常常会发生不同特权级之间的变换。
例如：外层的应用程序调用内层操作系统的例程，以获得必要的诸如存储器分配等系统服务；内层操作系统的例程完成后，返回到外层应用程序。
在同一任务内，实现特权级从外层到内层变换的普通途径是：使用段间调用指令CALL，通过调用门进行转移；
实现特权级从内层到外层变换的普通途径是：使用段间返回指令RET。注意，不能利用JMP指令实现任务内不同特权级的变换。
当段间调用指令CALL所含指针的选择子指示调用门描述符时，根据选择子确定调用门，而偏移被丢弃；
把调用门内的48位全指针，作为目标地址指针进行转移。
对于一致代码段，在满足CPL>=DPL时发生无特权级变换的转移。
对于非一致代码段，当CPL=DPL时，仍发生无特权级变换的转移；
当CPL>DPL时，就发生向内层特权级变换的转移，使CPL保持等于DPL，同时切换到对应的内层堆栈。
综上所述，使用段间调用指令CALL，通过调用门可以实现从外层程序调用进入内层程序；通过调用门也可实现无特权级变换的转移。
当然，CALL指令在最后把目标代码段的指针装入CS和EIP之前，要把原CS和EIP，即返回地址保存到堆栈。
如无特权级变换，堆栈保持不变，返回地址就保存在原堆栈中；如变换特权级，那么返回地址保存在内层堆栈中。
题10.23特权级变换时为什么要切换堆栈？如何切换堆栈？
因为每个任务最多可能在四个特权级间转移，所以每个任务最多需要4个堆栈。
当从外层转移到内层时，内层堆栈的SS和ESP从TSS中的SS0、ESP0、SS1、ESP1、SS2、ESP2这里取得。
每当从外层转移到内层时，内层堆栈的SS和ESP都是TSS中确定的，相当于每次内层堆栈都初始化为空。
系统会把返回地址和外层堆栈的指针保留到内层堆栈中，将外层堆栈指针放入到内层堆栈中是为了向外层返回时，保证外层堆栈的正确。
当从内层返回到外层时，将恢复外层堆栈。
从外层到内层，可以通过CALL/JMP来直接转移，但从内层到外层，不能直接通过CALL/JMP，只能通过远程RET，
这样做的原因是为了确保内层的堆栈不被外层代码得知。
因为是从低特权级向高特权级转换，故TSS中没有最外层（最低特权级）的堆栈信息。
任务最开始执行时的SS和ESP就是最外层（最低特权级）的堆栈。
在使用CALL指令，通过调用门向内层转移时，不仅特权级发生变换，控制转移到一个新的代码段，而且也切换到内层的堆栈段。
在特权级发生向内层变换时，根据特权级使用TSS中相应的堆栈指针对SS及ESP寄存器进行初始化，建立起一个空栈。
在建立起内层堆栈后，先把外层堆栈的指针SS及ESP寄存器的值压入内层堆栈，以使得相应的向外层返回可恢复原来的外层堆栈。
然后，从外层堆栈复制以双字为单位的调用参数到内层堆栈，调用门中的DCOUNT字段值决定了复制参数的量。
这些被复制的参数是主程序通过堆栈传递给子程序的实参，在调用之前被压入外层堆栈。
通过复制堆栈中的参数，使内层的子程序不需要考虑堆栈的切换，而容易地访问主程序传递过来的实参。
最后，调用的返回地址被压入堆栈，以便在调用结束时返回。
与使用CALL指令通过调用门向内层变换相反，使用RET指令实现向外层返回。
段间返回指令RET从堆栈中弹出返回地址，并且可以采用调整ESP的方法，跳过相应的在调用之前压入堆栈的参数。
返回地址的选择子指示要返回的代码段描述符，从而确定返回的代码段。
RET指令先从堆栈弹出返回地址。如果返回地址的选择子的RPL规定相对于CPL更外层的级，那么就引起向外层返回。
其次，为向外层返回，跳过内层堆栈中的参数，再从内层堆栈中弹出指向外层堆栈的指针，并装入到SS及ESP，以恢复外层堆栈。
再次，调整ESP，跳过在相应的调用之前压入到外层堆栈的参数。然后，检查数据段寄存器DS、ES、FS及GS，
以保证寻址的段在外层是可访问的，如果段寄存器寻址的段在外层是不可访问的，那么装入一个空选择子。
最后，返回（外层）继续执行。
上述五步是对带立即数段间返回指令而言的，立即数规定了堆栈中要跳过的参数的字节数。
对无立即数段间返回指令而言，缺少第二和第三步。如果RET指令不需要向外层返回，那么就只有开始和最后的两步。
题10.24如何体现任务切换？
在任务切换过程中当任务挂起时，处理器会更新动态字段，动态字段有：
（1）通用寄存器字段一任务切换之前，EAX，ECX，EDX，EBX，ESP，EBP，ESI，EDI寄存器状态。
（2）段选择符字段一任务切换之 前，ES，CS，SS，DS，FS，GS寄存器保存的段选择符。
（3）EFLAGS寄存器字段一任务切换之前，EFAGS寄存器的状态。
（4）EIP字段-任务切换之前，EIP寄存器的状态。
（5）先前任务链接字段-包含先前任务的TSS的段选择符。
当任务创建时会创建静态字段，静态字段可读，不可写：
（1）LDT段选择符字段
（2）CR3控制寄存器字段
（3）特权级0，1，2栈指针字段
（4）T标志（调试陷阱，100字节，位0）
（5）I/O映射基址字段
题10.25什么时候发生任务切换？简述任务切换过程。
利用段间转移指令JMP或者段间调用指令CALL，通过任务门或者直接通过任务状态段，可以切换到别的任务。
此外，在中断/异常或者执行IRET指令时也可能发生任务切换。
1.直接通过TSS进行任务切换
当段间转移指令JMP或段间调用指令CALL所含指针的选择子指示一个可用任务状态段TSS描述符时，
正常情况下就发生从当前任务到由该可用TSS对应任务（目标任务）的切换。目标任务的入口点由目标任务TSS内的CS和EIP字段所规定的指针确定。
这样的JMP或CALL指令内的偏移被丢弃。
2.通过任务门进行任务切换
任务门内的选择子指示某个任务的TSS描述符。当段间转移指令JMP或段间调用指令CALL所含指针的选择子指示一个任务门时，
正常情况下就发生任务切换，也即从当前任务切换到由任务门内的选择子所指示的TSS描述符对应的任务（目标任务）。
这样的JMP或CALL指令内的偏移被丢弃；任务门内的偏移也无意义。
根据指示目标任务TSS描述符的选择子进行任务切换的一般过程如下：
第一，测试目标任务状态段的界限。
TSS用于保存任务的各种状态信息，不同的任务，TSS中可以有数量不等的其他信息，但根据图10.14所示的任务状态段基本格式，
TSS的界限应大于或等于103。
第二，把寄存器现场保存到当前任务的TSS。
把通用寄存器、段寄存器、EIP及EFLAGS的当前值保存到当前TSS中。保存的EIP的值是返回地址，指向引起任务切换指令的下一条指令。
但不把LDTR和CR3内容保存到TSS中。
第三，把指示目标任务TSS的选择子装入TR。同时，把对应TSS描述符装入TR高速缓冲寄存器中。
此后，当前任务改称为原任务，目标任务改称为当前任务。
第四，基本恢复当前任务（目标任务）的寄存器现场。
根据保存在TSS中的内容，恢复各通用寄存器、段寄存器、EFLAGS及EIP。
在装入段寄存器的过程中，为了能正确地处理可能发生的异常，只把对应选择子装入各段寄存器。还装载CR3寄存器。
第五，进行链接处理。如果需要链接，那么将指向原任务TSS的选择子写入当前任务TSS的链接字字段，把当前任务TSS描述符类型改为“忙”，
并将标志寄存器EFLAGS中的NT位置1，表示是嵌套任务。如果需要解链，那么把原任务TSS描述符类型改为“可用”。
如果无链接处理，那么将原任务TSS描述符类型置为“可用”，当前任务TSS描述符类型置为“忙”。
由JMP指令引起的任务切换不实施链接/解链处理；由CALL指令、中断、IRET指令引起的任务切换要实施链接/解链处理。
第六，把CR0中的TS标志置为1。这表示已发生过任务切换，在当前任务使用协处理器指令时，产生自陷。
由自陷处理程序完成有关协处理器现场的保存和恢复。这有利于快速地进行任务切换。
第七，把TSS中的CS选择子的RPL作为当前任务特权级设置为CPL。
任务切换可以在一个任务的任何特权级发生，并可切换到另一任务的任何特权级。
第八，装载LDTR寄存器。
一个任务可以有自己的LDT，也可以没有。当任务没有LDT时，TSS中LDT选择子为0。
如果TSS中LDT选择子非空，则从GDT中读出对应LDT描述符，在经过测试后，把所读LDT描述符装入LDTR高速缓冲寄存器。
如果，LDT选择子为空，则将LDT的存在位置成0，表明任务不使用LDT。
第九，装载代码段寄存器CS、堆栈段寄存器SS和各数据段寄存器及其它的高速缓冲寄存器。
第十，把调试寄存器DR7中的局部启用位设置为0，以清除局部于原任务的各个断点和方式。
题10.26如何实现任务嵌套？
在段间转移指令JMP引起任务切换时，不实施链接，不导致任务的嵌套。
它要求目标任务是可用的任务。切换过程中把原任务置为“可用”，目标任务置为“忙”。
在段间调用指令CALL引起任务切换时，实施链接，导致任务的嵌套。它要求目标任务是可用的任务。
在切换过程中把目标任务置为“忙”，原任务仍保持“忙”；标志寄存器EFLAGS中的NT位被置1，表示是嵌套任务。
在由中断/异常引起任务切换时，实施链接，导致任务的嵌套。要求目标任务是可用的任务。
在切换过程中把目标任务置为“忙”，原任务仍保持“忙”；标志寄存器EFLAG中的NT位被置1，表示是嵌套任务。
在执行IRET时引起任务切换，那么实施解链。要求目标任务是忙的任务。在切换过程中把原任务置为“可用”，目标任务仍保持“忙”。
题10.27别名技术是指什么？
为了满足对同一个段实施不同方式操作的需要，而用多个描述符加以描述的技术称为别名技术。
例如：用两个具有不同类型值的描述符来描述同一个段。再如，用两个具有不同DPL的描述符来描述符同一个段。
题10.28 80386的中断和异常有何异同？
根据中断源产生的条件，80386把中断分为外部中断和内部中断。
外部中断一般被称为中断。 内部中断一般被称为异常。80386最多处理256种中断或异常。
外部中断是指来自处理器和内存外部的中断，包括I/O设备发出的I/O中断、外部信号中断、各种定时器引起的时钟中断以及调试程序中设置的断点等引起的调试中断等。
内部中断主要指在处理器和内存内部产生的中断，包括程序运算引起的各种错误，如地址非法、校验错、页面失效、存取访问控制错、算术操作溢出、
数据格式非法、除数为零、非法指令、用户程序执行特权指令、分时系统中的时间片中断以及从用户态到核心态的切换等。 
为了按中断源的轻重缓急处理响应中断，不同的中断赋予不同的优先级。
除了在优先级的设置方面有区别之外，中断和异常还有如下主要区别：
1、异常通常由处理器正在执行的现行指令引起，而中断则是由与现行指令无关的中断源引起的。
异常处理程序提供的服务为当前进程所用，而中断处理程序提供的服务则不是为了当前进程的。
2、中断是由硬件引起的，而异常是由软件引起。
3、中断是异步的，而异常是同步的。 CPU执行完一条指令之后，下一条指令开始之前响应中断，而在一条指令执行中也可以响应异常。
例如执行指令非法时，尽管被执行的非法指令不能执行结束，但CPU仍可对其进行处理。
对80386而言，中断是由异步的外部事件引起的。外部事件及中断响应与正执行的指令没有关系。
80386有两根引脚INTR和NMI接受外部中断请求信号。INTR接受可屏蔽中断请求。NMI接受不可屏蔽中断请求。
在80386中，标志寄存器EFLAGS中的IF标志决定是否屏蔽可屏蔽中断请求。
处理器不屏蔽来自NMI的中断请求。处理器在响应NMI中断时，不从外部硬件接收中断向量号。
在80386中，不可屏蔽中断所对应的中断向量号固定为2。为了避免不可屏蔽中断的嵌套，每当接受一个NMI中断，处理器就在内部屏蔽了再次响应NMI，
这一屏蔽过程直到执行中断返回指令IRET后才结束。所以，NMI处理程序应以IRET指令结束。
异常是80386在执行指令期间检测到不正常的或非法的条件所引起的。异常与正执行的指令有直接的联系。
题10.29 80386 异常分为哪三类？各有什么特点？
根据引起异常的程序是否可被恢复和恢复点不同，把异常进一步分类为故障（Fault）、陷阱（Trap）和中止（Abort）。
我们把对应的异常处理程序分别称为故障处理程序、陷阱处理程序和中止处理程序。
故障可能被故障处理程序修正，如果修正成功，将返回到当前正在执行的指令，重新执行。故障的一个典型是缺页异常。
陷阱最重要的用途是在用户程序和内核之间提供系统调用接口。陷阱总返回到当前指令的下一条指令。
中止由不可恢复的错误造成。
故障是在引起异常的指令之前，把异常情况通知给系统的一种异常。80386认为故障是可排除的。
当控制转移到故障处理程序时，所保存的断点CS及EIP的值指向引起故障的指令。这样，在故障处理程序把故障排除后，
执行IRET返回到引起故障的程序继续执行时，刚才引起故障的指令可重新得到执行。
故障的发现可能在指令开始执行之前，也可能在指令执行期间。如果在执行指令期间检测到故障，那么中止故障指令，
并把指令的源操作数恢复为指令开始执行之前的值。这可保证故障指令的重新执行得到正确的结果。
陷阱是在引起异常的指令之后，把异常情况通知给系统的一种异常。当控制转移到异常处理程序时，
所保存的断点CS及EIP的值指向引起陷阱的指令的下一条要执行指令。
在转入陷阱处理程序时，引起陷阱的指令应正常完成，它有可能改变了寄存器或存储单元。软中断指令、单步异常是陷阱的例子。
中止是在系统出现严重情况时，通知系统的一种异常。引起中止的指令是无法确定的。产生中止时正执行的程序不能被恢复执行。
系统接收中止后，处理程序要重新建立各种系统表格，并可能需要重新启动操作系统。硬件故障和系统表中出现非法值或不一致值是中止的例子。
题10.30在发生中断和异常后，如何转入对应的处理程序？
在一条指令执行期间，如检测到不止一个中断或异常，把优先级最高的中断或异常通知系统，其他优先级较低的异常被废弃，而优先级较低的中断则保持悬挂。
80386识别多种不同类别的异常，并赋予每一种类别不同的中断向量号。异常发生后，根据中断向量号，转相应的异常处理程序（故障处理程序、陷阱处理程序和中止处理程序）。
某些异常还以出错码的形式提供一些附加的信息传递给异常处理程序。
在保护方式下，80386不再使用实方式下的中断向量表，而是使用中断描述符表IDT（Interrupt Descriptor Table）。
80386把中断向量号作为中断描述符表IDT中描述符的索引，而不再是中断向量表中的中断向量的索引。
像全局描述符表GDT一样，在整个系统中，中断描述符表IDT只有一个。中断描述符表寄存器IDTR指示IDT在内存中的位置，
这也与如图10.10所示的GDTR指示GDT相似。由于80386只识别256个中断向量号，所以IDT最大长度是2K。
中断描述符表IDT所含的描述符只能是中断门、陷阱门和任务门。也就是说，在保护方式下，
80386只有通过中断门、陷阱门或任务门才能转移到对应的中断或异常处理程序。
图10.13给出了门描述符的格式。从中可见门描述符包含由选择子和偏移量构成的48位全指针。
另外，双字计数字段对中断门、陷阱门和任务门而言无意义。
由硬件自动实现的中断响应和异常处理的步骤如下：
首先，判中断向量号要索引的门描述符是否超出IDT的界限。如果超出界限，就引起通用保护故障，出错码是中断向量号乘8再加2。
其次，从IDT中取得对应的门描述符，分解出选择子、偏移量和描述符属性类型，并进行有关检查。
描述符只能是任务门、286中断门、286陷阱门、386中断门或386陷阱门，否则，就引起通用保护故障，出错码是中断向量号乘8再加2。
如果是由于INT n指令或者INTO指令引起转移，还要检查中断门或陷阱门描述符中的DPL是否满足CPL<=DPL。
这种检查可以避免应用程序执行INT n指令时，使用分配给各种设备用的中断向量号。
如果检查不通过，就引起通用保护故障，出错码是中断向量号乘8再加2。
门描述符中的P位必须是1，表示门描述符是一个有效项，否则就引起段不存在故障，出错码是中断向量号乘8再加2。
最后，根据门描述符类型，分情况转入中断或异常处理程序。
对于异常处理，在开始上述步骤之前，还要根据异常类型确定返回点；如果有出错码，则形成符合出错码格式的出错码。
在有出错码的情况下，在转入处理程序之前，还要把出错码压入堆栈。只有异常处理才可能有出错码。
为了保证堆栈的双字边界对齐，16位的出错码以32位的值压入，其中高16位的值未作定义。
对于中断门，在转移过程中，把IF置成0，使得在处理程序执行期间，屏蔽掉INTR中断；
对于陷阱门，在转移过程中，保持IF位不变，即如果IF位原是1，那么通过陷阱门转移到处理程序之后仍允许INTR中断。
因此，中断门最适宜于处理中断，而陷阱门适宜于处理异常。
如果中断向量号所指示的门描述符是任务门描述符，那么控制转移到一个作为独立的任务方式出现的处理程序。
对于提供出错码的异常处理，在完成任务切换之后，把出错码压入新任务的堆栈中。
通过任务门的转移，在进入中断或异常处理程序时，标志寄存器EFLAGS中的NT位被置1，表示是嵌套任务。
中断返回指令IRET用于从中断或异常处理程序的返回。该指令的执行根据任务嵌套标志NT是否为1，分两种情形。
NT为1，表示是嵌套任务的返回。当前TSS中的链接字段保存有前一任务的TSS的选择子，取出该选择子，进行任务切换就完成了返回。
这种情形在由通过任务门转入的中断或异常处理程序返回时出现，因为在由中断门或陷阱门转入处理程序时，NT位已被清0。
NT为0，表示当前任务内的返回。这种情形在由通过中断门或陷阱门转入的中断或异常处理程序返回时出现。
具体进行的操作包括：从堆栈顶弹出返回指针EIP及CS，然后弹出EFLAG值。弹出的CS选择子的RPL字段，确定返回后的特权级。
如果返回选择子的RPL与CPL相同，则不进行特权级的改变。
若RPL规定了一个外层特权级，则需要特权级改变，从内层堆栈中弹出外层堆栈的ESP及SS的值，参见图10.21。这些做法与RET指令的实现相似。
例如，使用返回CS选择子的RPL，而不是由选择子标识的段的DPL，是为了返回到不在DPL给定的级执行的一致代码段。
对于提供出错代码的异常的处理程序，必须先从堆栈中弹出出错代码，然后再执行IRET指令。
中断返回指令IRET不仅能够用于由中断/异常引起的嵌套任务的返回，而且也适用于由段间调用指令CALL通过任务门引起的嵌套任务的返回。
题10.31如何防止应用程序执行“INT n”指令时，使用了分配给各种设备用的中断向量号？
如果是由于INT n指令或者INTO指令引起转移，还要检查中断门或陷阱门描述符中的DPL是否满足CPL<=DPL。
这种检查可以避免应用程序执行INT n指令时，使用分配给各种设备用的中断向量号。
如果检查不通过，就引起通用保护故障，出错码是中断向量号乘8再加2。
把中断门或陷阱门描述符中的DPL设置为0，因为应用程序CPL=3，所以检查不通过，引起通用保护故障。
题10.32特权指令的特权指的是什么？为什么要有特权指令？
特权指令是指保护方式下只有当前特权级CPL=0时，才可以执行的指令。如果CPL不等于0而执行它们，那么会引起通用保护异常。
操作系统类指令可分为三种：实方式和任何特权级下可执行的指令、实方式及特权级0下可执行的指令和仅在保护方式下执行的指令。
实方式和任何特权级下可执行的指令
1.存储全局和中断描述符表寄存器指令
2.存储机器状态字指令
实方式及特权级 0下可执行的指令
1.清任务切换标志指令
2.暂停指令
3.装载全局描述符表和中断描述符表寄存器的指令
4.装载机器状态字指令
5.控制寄存器数据传送指令
6.调试寄存器数据传送指令
7.测试寄存器数据传送指令
只能在保护方式下执行的指令
1.装载和存储局部描述符表寄存器指令
2.装载和存储任务寄存器指令
3.调整申请特权级指令
4.装载存取权指令
5.装载段界限指令
6.读写检验指令
从上面介绍的操作系统类指令可归纳出如表10.8所列的80386特权指令。这些特权指令在构成完善的保护机制方面起了重要作用。
表10.8特权指令
指令                  功能                  指令                  功能
CLTS          清除CR0中的TS位      LTR                  装入TR
HLT            停机                      MOV CRn,reg     装入控制寄存器
LGDT         装入GDTR              MOV reg,CRn     保存控制寄存器
LIDT          装入IDTR                MOV DRn,reg     装入调试寄存器
LLDT         装入LDTR                MOV reg,DRn    保存调试寄存器
LMSW       装入MSW（CR0低16位）
从表10.8可见，装入GDTR、IDTR、LDTR、TR和MSW的指令都是特权指令，而存储上述寄存器的指令不是特权指令。
这表示，保护方式下任何程序可获取这些寄存器的值，但只有具有特权级0的程序才能够改变这些寄存器的值。
从表10.8还可见，设置和存储控制寄存器及调试寄存器的指令都是特权指令。
题10.33为什么要实施输入/输出保护？80386如何实现输入/输出保护。.
为了支持多任务，80386不仅要有效地实现任务隔离，而且还要有效地控制各任务的输入/输出，避免输入/输出冲突。
80386采用I/O特权级IOPL和I/O许可位图的方法来控制输入/输出，实现输入/输出的保护。
IO特权标志有2位宽，也称为IO特权级字段。IOPL字段指定了要求执行I/O指令的特权级。
如果当前的特权级别在数值上小于或等于IOPL，那么I/O指令可执行，否则，发生一个保护异常。
31          18 17   16  15  14  13 12   11   10  9  8    7   6   5  4   3  2   1  0
                   VM  RF  0   NT  IOPL    OF  DF IF TF  SF ZF  0 AF 0  PF     CF
输入/输出特权级（I/O Privilege Level）规定了可以执行所有与I/O相关的指令和访问I/O空间中所有地址的最外层特权级。IOPL值在如图9.2所示的标志寄存器中。
I/O许可位图规定了I/O空间中的哪些地址可以由在任何特权级执行的程序所访问。I/O许可位图在任务状态段TSS中。
表10.9 I/O 敏感指令
指令                  功能                  保护方式下执行条件
CLI         清除EFLAGS中的IF位     CPL <= IOPL
STI         设置EFLAGS中的IF位     CPL <= IOPL
IN          从I/O地址读出数据        CPL <= IOPL或I/O位图允许
INS        从I/O地址读出字符串     CPL <= IOPL或I/O位图允许
OUT      向I/O地址写数据            CPL <= IOPL或I/O位图允许
OUTS    向I/O地址写字符串        CPL <= IOPL或I/O位图允许
表10.9所列的指令称为I/O敏感指令。由于这些指令与I/O有关，并且只有在满足所列条件时才可以执行，所以把它们称为I/O敏感指令。
从表10.9可见，当前特权级不在I/O特权级外层时，可以正常执行所列的全部I/O敏感指令；当前特权级在I/O特权级外层时，执行CLI和STI指令将引起通用保护异常；
当前特权级在I/O特权级外层时，其他四条输入/输出指令是否能够执行要根据访问的I/O地址及I/O许可位图情况而定，如果条件不满足而执行，
那么将引起通用保护异常。
由于每个任务使用各自的EFLAGS值和拥有自己的TSS，所以每个任务可以有不同的IOPL，并且可以定义不同的I/O许可位图。
注意，这些I/O敏感指令在实方式下总是可执行的。
如果只用IOPL限制I/O指令的执行是很不方便的，不能满足实际需要。因为这样做会使得在特权级3执行的应用程序，要么可访问所有I/O地址，要么不可访问所有I/O地址。
实际需要与此刚好相反，只允许任务甲的应用程序访问部分I/O地址，只允许任务乙的应用程序访问另一部分的I/O地址，以避免任务甲和任务乙在访问I/O地址时发生冲突，
从而避免任务甲和任务乙使用独享设备时发生冲突。
所以，在IOPL的基础上，再采用了I/O许可位图。I/O许可位图由二进制位串组成。位串中的每一位依次对应一个I/O地址，位串的第0位对应I/O地址0，
位串的第n位对应I/O地址n。如果位串中的m位为0，那么对应的I/O地址m可以由在任何特权级执行的程序访问；
否则对应的I/O地址m只能由在IOPL特权级或更内层特权级执行的程序访问。如果在IOPL外层特权级执行的程序访问位串中位值为1的位所对应的I/O地址，
那么引起通用保护异常。
在需要根据I/O位图决定是否可访问I/O地址的情况下，当一条I/O指令涉及多个I/O地址时，只有这多个I/O地址所对应的I/O位图中的位都为0时，该I/O指令才能正常执行；
如果对应位中任一位为1，就会引起通用保护异常。
只有特权级为0的程序才能够修改EFLAGS中的IOPL和VM位, 相对于IOPL更内层的特权级才能够修改IF位。
如果特权级不符合要求, 修改这些位的话, 也不会异常, CPU会忽略。
题10.34请说明线性地址到物理地址的转换过程。
80386的存储器段管理机制实现虚拟地址（由段和偏移构成的逻辑地址）到线性地址的转换，
分页管理机制实现线性地址到物理地址的转换。如果不启用分页管理机制，那么线性地址就作为物理地址。
在保护方式下，控制寄存器CR0中的最高位PG位控制分页管理机制是否生效。如果PG=1，分页机制生效，把线性地址转换为物理地址。
如果PG=0，分页机制无效，线性地址就直接作为物理地址。
只有在保证使PE位为1的前提下，才能够使PG位为1，否则将引起通用保护异常。也就是，只有在保护方式下分页机制才可能生效。
分页机制把线性地址空间和物理地址空间分别划分为大小相同的块。这样的块称之为页。通过在线性地址空间的页与物理地址空间的页之间建立的映射，
分页机制实现线性地址到物理地址的转换。线性地址空间的页与物理地址空间的页之间的映射可根据需要而确立，可根据需要而改变。
图10.26反映了线性地址空间的部分页与物理地址空间的部分页之间的映射关系，线性地址空间的任何一页，可以映射为物理地址空间中的任何一页。
采用分页管理机制实现线性地址到物理地址转换映射的主要目的是便于实现虚拟存储器。不像段的大小可变，页的大小是相等并固定的。
根据程序的逻辑划分段，而根据实现虚拟存储的方便划分页。
在80386中，页的大小固定为4K字节，每一页的边界地址必须是4K的倍数。因此，4G大小的地址空间被划分为1M个页，页的开始地址具有“XXXXX000H”的形式。为此，
我们把页开始地址的高20位XXXXXH称为页码。线性地址空间页的页码也就是页开始边界线性地址的高20位；物理地址空间页的页码也就是页开始边界物理地址的高20位。
可见，页码左移12位就是页开始地址，所以页码规定了页。
由于页的大小固定为4K字节，且页的边界是4K的倍数，所以在把32位线性地址转换成32位物理地址的过程中，低12位地址可以保持不变。也就是说，
线性地址的低12位就是物理地址的低12位。假设分页机制采用的转换映射把线性地址空间的XXXXXH页映射到物理地址空间的YYYYYH页，
那么线性地址XXXXXxxxH被转换为YYYYYxxxH。
因此，线性地址到物理地址的转换要解决的是线性地址空间页到物理地址空间页的映射，也就是线性地址高20位到物理地址高20位的转换。
线性地址空间页到物理地址空间页之间的映射用表来描述。由于4G的地址空间划分为1M个页，因此，如果用一张表来描述这种映射，那么该映射表就要有1M个表项，
如果每个表项占用4个字节，那么该映射表就要占用4M字节。为避免映射表占用如此巨大的存储器资源，所以80386把页映射表分为两级。
页映射表的第一级称为页目录表，存储在一个4K字节的物理页中。页目录表共有1K个表项，其中，每个表项为4字节长，包含对应第二级表所在物理地址空间页的页码。
页映射表的第二级称为页表，每张页表也安排在一个4K字节的页中。每张页表都有1K个表项，每个表项为4字节长，包含对应物理地址空间页的页码。
由于页目录表和页表均由1K个表项组成，所以使用10位就能指定表项。
图10.27示出了由页目录表和页表构成的页映射表结构。从图10.27中可见，控制寄存器CR3指定页目录表；页目录表可以指定1K个页表，这些页表可以分散存放在任意的物理页中，
而不需要连续存放；每张页表可以指定1K个物理地址空间页，这些物理地址空间页可以任意地分散在物理地址空间中。
       31                                            16 15        11                 4   3   2    1     0
CR0 PG 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0    0 0 0 0 0 0 0 0 0 0 ET TS EM MP PE
CR1 保留
CR2 页故障线性地址
CR3 页目录表物理页码                                      0 0 0 0 0 0 0 0 0 0 0 0
31                  12   11   10   9   8   7   6   5   4   3   2   1   0
      物理页码          AVL           0   0   D   A  0   0   U   R   P
                                                                            S   W
页目录表和页表中的表项都采用如图10.28所示的格式。从图可见，最高20位（位12至位31）包含物理地址空间页的页码，也就是物理地址的高20位。低12位包含页的属性。
图10.28所示属性中内容为0的位是Intel公司为80486等处理器留下的保留位，在为80386编程使用到它们时必须设置成0。在位9至位11的AVL字段供软件使用。
表项的最低位是存在属性位，记作P。P位表示该表项是否有效。P=1表项有效；P=0表项无效，表项中其余各位均可供软件使用，80386不解释P=0的表项中的任何其他的位。
在通过页目录表和页表进行的线性地址到物理地址的转换过程中，无论在页目录表或页表中遇到无效表项，都会引起页故障。
分页管理机制通过上述页目录表和页表实现32位线性地址到32位物理地址的转换。控制寄存器CR3的高20位作为页目录表所在目录页的页码。
首先，把线性地址的最高10位（即位22至位31）作为页目录表的索引，对应表项所包含的页码指定页表；
然后，再把线性地址的中间10位（即位12至位21）作为已指定页表的索引，对应表项所包含的页码指定物理地址空间中的一页；
最后，把已指定物理页的页码作为高20位，把线性地址的低12不加改变直接作为低12位，构成32位物理地址。
题10.3580386 如何对页面进行保护？
80386不仅提供段级保护，也提供页级保护。分页机制只区分两种特权级。特权级0、1和2统称为系统特权级，特权级3称为用户特权级。
在如图10.28所示页目录表和页表的表项中保护属性位R/W和U/S就是用于对页的保护。
表项的位1是读/写属性位，记作R/W。R/W位指示该表项所指定的页是否可读、写或执行。
如R/W=1，对表项所指定页可进行读、写或执行；如R/W=0，对表项所指定页可读或执行，但不能对该指定页写。
但是，R/W位对页的写保护只在处理器处于用户特权级时发挥作用：当处理器处于系统特权级时，R/W位被忽略，也即总可以读、写或执行。
表项的位2是用户/系统属性位，记作U/S。U/S位指示该表项所指定的页是否是用户级页。如U/S=1，表项所指定页是用户级页，可由任何特权级下执行的程序访问；
如U/S=0，表项所指定页是系统级页，只能由在系统特权级下执行的程序访问。
表10.11页级保护属性
U/S                  R/W                  用户级访问权限                  系统级访问权限
0                      0                       无                                      读/写/执行
0                      1                       无                                      读/写/执行
1                      0                       读/执行                              读/写/执行
1                      1                       读/写/执行                          读/写/执行
表10.11列出了在上述属性位R/W和U/S所确定的页级保护下，用户级程序和系统级程序分别具有的对用户级页和系统级页进行操作的权限。
用户级页可以规定为只允许读/执行或者规定为读/写/执行。系统级页对于系统级程序总是可读/写/执行，而对用户程序级程序总是不可访问的。
与分段机制一样，外层用户级执行的程序只能访问用户级的页，而内层系统级执行的程序，既可访问系统级页，也可访问用户级页。
与分段机制不同的是，在内层系统级执行的程序，对任何页都有读/写/执行访问权，即使规定为只允许读/执行的用户页，内层系统级程序也对该页有写访问权。
页目录表项中的保护属性位R/W和U/S对由该表项指定页表所指定的全部1K个页起到保护作用。
所以，对页访问时引用的保护属性位R/W和U/S的值是组合计算页目录表项和页表项中的保护属性位的值所得。
表10.12列出了组合计算前后的保护属性位值，组合计算是“与”操作。
例如：假设某页表中的某项的R/W=1和U/S=1，表示所指定页是可由用户级程序读/写/执行的用户级页。如果指定该页表的页目录项中的R/W=0，U/S=1，
那么用户级程序实际上可对该页的访问被限制为读/执行；如果指定该页表的页目录项中的R/W=1，U/S=0，那么实际上用户级程序没有对该页的访问权。
表10.12组合页保护属性
目录表项U/S      页表项U/S      组合U/S      目录表项R/W      页表项R/W      组合R/W
0                           0                      0           0                        0                     0
0                           1                      0           0                        1                     0
1                           0                      0           1                         0                    0
1                           1                      1           1                         1                    1
正如在80386地址转换机制中分页机制在分段机制之后起作用一样，由分页机制支持的页级保护也在由分段机制支持的段级保护之后起作用。
先测试有关的段级保护，如果启用分页机制，那么在检查通过后；再测试页级保护。
例如，设启用分页机制和当前特权级是3，那么，对于一个存储单元，仅当其所在段及页都允许写入时，该存储单元才是可写的；
如果段的类型为读/写，而页规定为只允许读/执行，那么不允许写；如果段的类型为只读/执行，那么不论页保护如何，也不允许写。
页级保护的检查是在线性地址转换成物理地址的过程中进行的，如果违反页保护属性的规定，对页进行访问（读/写/执行），那么将引起页异常。
题10.36 V86 方式是指什么？为什么需要V86方式？
80386具有实方式和保护方式两种工作模式，实方式与8086方式兼容，可以运行DOS及以其为平台的几乎所有软件；
但在实方式下，处理器不能发挥自身的优越性能，不能支持多用户、多任务操作系统的运行。
为了充分发挥处理器的功能，同时使DOS及以其为平台的软件继续有效地运行，从80386开始增加了虚拟8086方式。
31          18 17   16  15  14  13 12   11   10  9  8    7   6   5  4   3  2   1  0
                   VM  RF  0   NT  IOPL    OF  DF IF TF  SF ZF  0 AF 0  PF     CF
虚拟8086方式是保护方式下的一种工作方式，也称为V8086方式，或者简称为V86方式。在虚拟8086方式下，处理器类似于8086。寻址的地址空间是1M字节；
段寄存器的内容作为段值解释；20位存储单元地址由段值乘16加偏移构成。所以，在虚拟8086方式下，可以运行DOS及以其为平台的软件。
但V86方式毕竟是虚拟8086的一种方式，所以不完全等同于8086。
当如图9.2所示的标志寄存器中的标志VM为1时，处理器就处于V86方式。当处理器处于V86方式时，其当前特权级必定是3。
8086程序可直接在V86方式下运行，而V86方式受到称为V86监控程序的控制。
V86监控程序和在V86方式下的8086程序构成的任务称为虚拟8086任务，或者简称为V86任务。V86任务形成一个由处理器硬件和属于系统软件的监控程序组成的“虚拟8086机"。
V86监控程序控制V86外部界面、中断和I/O。硬件提供该任务最低端1M字节线性地址空间的虚拟存储空间，包含虚拟寄存器的TSS，并执行处理这些寄存器和地址空间的指令。
80386把V86任务作为与其他任务具有同等地位的一个任务。它可以支持多个V86任务，每个V86任务是相对独立的。
所以，通过V86方式这种形式，运行8086程序可充分发挥处理器的能力和充分利用系统资源。
题10.37在V86方式下，是否可利用IRET指令离开V86方式？
在V86方式下，IRET指令执行结果与在实方式下一样，只能从堆栈弹出IP、CS和FLAGS，不能进行任务切换，所以不能利用IRET指令离开V86方式。
V86方式与保护方式的切换可发生在V86任务之内，这种切换是V86方式下的8086程序与保护方式下的监控程序之间的转换；
V86方式与保护方式的切换可发生在任务之间，这种切换是V86任务与其他任务的切换。此外，V86监控程序与其他任务之间的切换是普通的任务切换。
由于80386没有提供直接改变VM标志的指令，并且只有当前特权级CPL=0时，对VM的改变才有效，所以V86方式与保护方式的切换不能简单地通过设置或改变VM而进行。
在V86方式下，如果处理器响应中断/异常，那么就会退出当前V86任务的V86方式。在V86方式下，处理器对中断/异常的响应处理不同于真正的8086，
而仍然采用保护方式下对中断/异常响应处理的方法。所以，在V86方式下，不是根据位于线性地址空间最低端的中断向量表内的对应中断向量转入处理程序，
而是根据中断描述符表IDT内的对应门描述符的指示转入处理程序。
如果对应的门描述符是386中断门或386陷阱门，那么就发生在当前V86任务内从V86方式到保护方式的转换。80386要求执行这种中断/异常处理程序时的CPL必须等于0。
由于V86方式下的CPL=3，而转换到保护方式后的CPL=0，所以这种转换包含了特权级的变换。
在按10.7节介绍的方法转入处理程序之前，处理器先将V86方式下的段寄存器GS、FS、DS及ES压入0级堆栈，并装入空选择子。
为保持使堆栈对齐，在把段寄存器压入堆栈时，一律按32位值压入，低16位是段寄存器的值，高16位为空。
于是，转换后的0级堆栈如图10.33所示。其中，段寄存器SS和CS的值也是V86方式下的段值。图（a）是没有出错码的情形；图（b）是有出错码的情形。
（a）是没有出错码的情形
PUSH GS
PUSH FS
PUSH DS
PUSH ES
PUSH SS
PUSH ESP
PUSH EFLAG
PUSH CS
PUSH EIP
（b）是有出错码的情形
PUSH GS
PUSH FS
PUSH DS
PUSH ES
PUSH SS
PUSH ESP
PUSH EFLAG
PUSH CS
PUSH EIP
PUSH 出错码
在这种V86任务内从V86方式转换到保护方式的过程中，为了保证中断/异常处理程序工作于特权级0，对目标代码段描述符特权级进行检查，
如果由目标代码段描述符特权级决定的CPL不等于0，将引起通用保护异常。
此外，标志寄存器EFLAGS中的VM位被清0，从而使得中断/异常处理在保护方式下进行，也即离开V86方式。
这种情况下，相应的中断/异常处理在当前V86任务之内进行。中断/异常处理程序可以检查保存在堆栈中的EFLAGS映象，根据VM位的值来确定被中断程序的工作方式。
如果VM=1，那么被中断的程序工作于V86方式，是8086程序；否则，被中断的程序工作于保护方式，是V86监控程序。
如果对应的门描述符是任务门，那么就发生从当前V86任务到其他任务的切换，也就离开当前V86任务的V86方式。象普通任务切换一样，
V86方式的各通用寄存器、段寄存器、指令指针和标志寄存器EFLAGS等保存到原V86任务的386TSS中。被保存的段寄存器的内容是V86方式下的段值。
被保存的EFLAGS内的VM=1。
这种情况下，相应的中断/异常处理在另一个任务内进行。目标任务可以是普通任务，也可以是另一个V86任务。
如果目标任务TSS内的EFLAGS字段内的VM=1，那么就转入另一个V86任务的V86方式。
与离开V86方式的两条途径相对应，有两条进入V86方式的途径。
通过IRET指令进入V86方式
通常在中断/异常处理结束时使用IRET指令返回被中断的程序继续执行。指令IRET的执行流程如图10.34所示，尽管它不够细致和没包括异常情况，
但还是体现了指令IRET执行时所处理的三种情形。第一种情形是当前EFLAGS中的NT=1，也即嵌套任务返回，那么就进行任务切换，
指向目标任务TSS的选择子在当前任务TSS的链接字段。NT=0表示当前中断/异常处理程序与被中断程序属于同一任务，于是就从堆栈弹出EIP、CS和EFLAGS。
第二和第三种情形是在NT=0的条件下产生。第二种情形是弹出的EFLAGS中VM=0，表示被中断的程序是普通保护方式程序，那么就考虑特权级变换，
如果向外层返回，那么就恢复外层堆栈指针，不允许向内层返回。在10.7.3中介绍的指令IRET的动作只考虑情形一和情形二，并不是指令IRET的完整动作。
第三种情形是弹出的EFLAGS中VM=1且CPL=0，表示被中断的程序是V86方式下的8086程序，当前是从同一V86任务下的中断/异常处理程序返回。
由于V86方式的特权级是3，所以要进行堆栈切换，也即从堆栈中弹出3级堆栈的指针（ESP和SS）。此外，还从堆栈中弹出段寄存器ES、DS、FS和GS。
在这种情形下，弹到各段寄存器（包括CS和SS）的内容都作为段值，而非选择子。这种处理动作对应于上述第一种离开V86方式的情形，
有关堆栈操作也与图10.33所示的堆栈内容相符。当然，如果产生异常时提供出错码，那么异常处理程序在利用IRET指令返回时，
必须确保堆栈指针指向图10.33所示保存EIP的单元。简单的实现方法是，异常处理程序在执行IRET前，先从堆栈弹出出错码。
利用指令IRET处理的这第三种情形，可以方便地从V86任务下的中断/异常处理程序返回到V86方式下的8086程序。
利用这条途径还可以直接进入V86方式。为此，先在0级堆栈中形成如图10.33（a）所示的栈顶。
对应EIP值是V86方式下要执行的8086程序入口点的16 位偏移；对应CS值是V86方式下要执行的8086程序入口点的段值；对应EFLAGS值中的VM位必须是1；
对应SS和ESP的值是要执行的8086程序的堆栈指针；对应ES、DS、FS和GS的值是相应的段值。然后，在CPL=0和NT=0的情况下，执行IRET指令。
实际上，这种进入V86方式的途径是，先建立一个V86方式下执行的8086程序被中断而离开V86方式的环境，然后再返回。
通过任务切换进入V86方式
通过任务切换的途径，可以从其他任务进入V86任务内的V86方式。
利用在前面几节介绍的任务切换方法可以进行任务切换。如果目标任务由386TSS描述，并且其中EFLAGS字段内的VM位为1，那么在切换到目标任务时，也就进入V86方式。
在切换到V86方式时，CPL被规定为3。目标任务TSS中的各段寄存器字段被解释为8086可以接受的段值，而不是选择子。
任务切换时也将装载LDTR和CR3。如果利用这条途径建立V86任务并进入V86方式，那么主要是把对应386TSS中EFLAGS字段内的VM位置1，
把8086程序的有关段值填入对应386TSS中的相应段寄存器字段。此外，如果V86监控程序需要用到LDT，那么还要填LDTR字段；如果需要采用分页机制，那么还要填CR3字段。
题10.38在保护方式 下，80386提供了哪些保护措施？
80386有32根地址线，在保护方式下，全部32条地址线有效，可寻址高达4G字节的物理地址空间；
80386的存储器分段管理机制实现虚拟地址到线性地址的转换，支持段级保护；分页管理机制实现线性地址到物理地址的转换，支持页级保护。
80386的存储器分段管理机制和可选的存储器分页管理机制，不仅为存储器共享和保护提供了硬件支持，而且为实现虚拟存储器提供了硬件支持；
全局描述符表GDT、局部描述符表LDT和中断描述符表IDT等是保护方式下非常重要的特殊段。
通过LDT可以使各任务私有的各个段与其他任务相隔离，通过GDT可以使各任务都需要使用的段能够被共享。
虚拟地址到物理地址的映射函数在每个任务中进行定义，通过线性地址空间的共享，也就是不同任务的部分相同的线性地址空间的映射信息相同，
实现某个段被两个任务共享，但又不被第三个任务所共享
通过描述符表和描述符，分段管理机制实现虚拟地址空间到线性地址空间的映射，实现把二维的虚拟地址转换为一维的线性地址。
通过在线性地址空间的页与物理地址空间的页之间建立的映射表，分页管理机制实现线性地址空间到物理地址空间的映射，实现线性地址到物理地址的转换。
在保护方式下，80386不再使用实方式下的中断向量表，而是使用中断描述符表IDT（Interrupt Descriptor Table）。
80386把中断向量号作为中断描述符表IDT中描述符的索引，而不再是中断向量表中的中断向量的索引。
在保护方式下，控制转移基本上可分为两大类：同一任务内的控制转移和任务间的控制转移（任务切换）。
同一任务内的控制转移又分为：段内转移、特权级不变的段间转移和特权级变换的段间转移。
段内转移与实方式下相似，不涉及特权级变换和任务切换。只有段间转移才涉及特权级变换和任务切换。
80386支持多任务，能够快速地进行任务切换和保护任务环境；
80386采用I/O特权级IOPL和I/O许可位图的方法来控制各任务的输入/输出，实现输入/输出的保护。
80386在一个任务之内，定义有四种执行特权级别，用于限制对任务中的段进行访问。
按照包含在段中的数据的重要性和代码的可信任程度，给段指定特权级别。
把最高的特权级别分配给最重要的数据段和最可信任的代码段。具有最高特权级别的数据，只能由最可信任的代码访问。
给不重要的数据段和一般代码段分配较低的特权级别。具有最低特权级别的数据，可被具有任何特权级别的代码访问。
每个存储器段都与一个特权级别相联系。只有足够级别的程序，才可对相应的段进行访问。
4个特权级和完善的特权检查机制，既能实现资源共享又能保证代码及数据的安全和保密、及任务的隔离；
80386的特权指令在构成完善的保护机制方面起了重要作用。
表10.8特权指令
指令                  功能                  指令                  功能
CLTS          清除CR0中的TS位      LTR                  装入TR
HLT            停机                      MOV CRn,reg     装入控制寄存器
LGDT         装入GDTR              MOV reg,CRn     保存控制寄存器
LIDT          装入IDTR                MOV DRn,reg     装入调试寄存器
LLDT         装入LDTR                MOV reg,DRn    保存调试寄存器
LMSW       装入MSW（CR0低16位）
支持虚拟8086方式，便于执行8086程序。
题10.3980386对实现虚拟存储器有何支持？
80386的存储器分段管理机制实现虚拟地址到线性地址的转换，支持段级保护；分页管理机制实现线性地址到物理地址的转换，支持页级保护。
80386的存储器分段管理机制和可选的存储器分页管理机制，不仅为存储器共享和保护提供了硬件支持，而且为实现虚拟存储器提供了硬件支持；
分页机制把线性地址空间和物理地址空间分别划分为大小相同的块。这样的块称之为页。通过在线性地址空间的页与物理地址空间的页之间建立的映射，
分页机制实现线性地址到物理地址的转换。线性地址空间的页与物理地址空间的页之间的映射可根据需要而确立，可根据需要而改变。
线性地址空间的任何一页，可以映射为物理地址空间中的任何一页。
采用分页管理机制实现线性地址到物理地址转换映射的主要目的是便于实现虚拟存储器。不像段的大小可变，页的大小是相等并固定的。
根据程序的逻辑划分段，而根据实现虚拟存储的方便划分页。
虚拟地址到物理地址的映射函数在每个任务中进行定义，随着任务切换，映射函数也切换。
因此，两个不同的任务，尽管虚拟存储单元地址相同，但实际的物理存储单元地址可以不同。
题10.41请画出各实例的内存映象。
实例一的逻辑功能是，以十六进制数的形式显示从内存地址110000H开始的256个字节的值。
在XP下使用tasm t452.asm编译，tlink /3 t452.obj链接
在DOS下运行t452.exe，分16行，每行16个，以十六进制数的形式显示

实例二的逻辑功能是，以十六进制数和ASCII字符两种形式显示从内存地址0FFFF0H开始的16个字节的内容。
在XP下使用tasm t453.asm编译，tlink /3 t453.obj链接
在DOS下运行t453.exe，先以十六进制数的形式显示16个字节的内容，再以ASCII字符的形式显示16个字节的内容

实例三使用了段间转移指令JMP、段间调用指令CALL和段间返回RET指令实现同一任务内相同特权级转移。
在XP下使用tasm t454.asm编译，tlink /3 t454.obj链接
在DOS下运行t454.exe，在左上角黑底白字显示Value=0048H

实例四演示在任务内通过调用门从外层特权级变换到内层特权级；
也演示通过段间返回指令从内层特权级变换到外层特权级；还演示通过调用门的无特权级变换的转移。
在XP下使用tasm t458.asm编译，tlink /3 t458.obj链接
在DOS下运行t458.exe，在左上角蓝底白字显示CPL=3

实例五的逻辑功能是在任务切换后显示原任务的挂起点（EIP）值。
该实例演示内容包括：直接通过TSS段的任务切换，通过任务门的任务切换，任务内特权级的变换及参数传递。
在XP下使用tasm t459.asm编译，tlink /3 t459.obj链接
在DOS下运行t459.exe，在左上角黑底白字显示Value=0000000B

实例六的逻辑功能是，在屏幕的左上角以倒计时方式显示秒为单位的时间，在时间用完后结束。
该实例演示内容包括：外部中断处理程序，陷阱处理程序。
在XP下使用tasm t460.asm编译，tlink /3 t460.obj链接
在DOS下运行t460.exe，在左上角黑底白字依次显示8 7 6 5 4 3 2 1 0，每次1秒，显示0之后，返回DOS

实例七的逻辑功能是，在屏幕上显示一条提示用户击键方式选择模拟异常类型的字符，然后模拟指定的异常。
该实例演示内容包括：除法出错故障处理、溢出陷阱处理、段不存在故障处理、堆栈段出错故障处理和通用保护故障处理；
还有作为一个独立任务方式出现的陷阱处理程序。
在XP下使用tasm t461.asm编译，tlink /3 t461.obj链接
在DOS下运行t461.exe，根据提示输入，Strike a key[0,4,B,C,D]:
分别选择0,4,B,C,D，在左上角黑底白字分别显示异常信息，选择B,C,D还显示出错码

实例八的逻辑功能，是显示系统中GDTR、IDTR、LDTR和DR等关键寄存器的当前内容。
在XP下使用tasm t462.asm编译，tlink /3 t462.obj链接
在DOS下运行t462.exe，c:\TASM16\T462.exe
0023
71111FFF
00879200
1FFF
9200
0001
0001
00072222
00178200
2222
8200
0000
0000

实例九的演示内容包括：I/O许可位图的作用、I/O敏感指令引起的异常和特权指令引起的异常；
使用段间调用指令CALL通过任务门调用任务，实现任务嵌套等。
在XP下使用tasm t463.asm编译，tlink /3 t463.obj链接
在DOS下运行t463.exe，c:\TASM16\T463.exe
扬声器发出声音
依次在屏幕左上角以蓝底白色显示如下信息
第一次
00000072:0000000A
第二次
00000083:00000000
第三次
00000083:00000001

实例十的逻辑功能是，在屏幕上显示一条表示已启用分页管理机制的提示信息。
该实例演示内容包括：初始化页目录表和部分页表；启用分页管理机制；关闭分页管理机制等。该实例假设系统有4M字节物理内存。
在XP下使用tasm t465.asm编译，tlink /3 t465.obj链接
在DOS下运行t465.exe，c:\TASM16\T465.exe
在屏幕左上角以蓝底白色显示Page is ok!

实例十一的逻辑功能是，以驻留方式结束程序，退出时已处于V86方式。
该实例演示内容包括：两种方式进入V86方式和两种方式离开V86方式；V86方式下的8086程序如何调用实方式下的软中断处理程序。
在XP下使用tasm t468.asm编译，tlink t468.obj链接，使用tasm t469.asm编译，tlink t469.obj链接
在DOS下运行t468.exe，以黑底白色显示V86 is OK!
c:\TASM16\T468.exe
V86 is OK!
运行t469.exe，在屏幕左上角以蓝底白色显示......General Protection Error......
题10.42请实际调试各实例。
在XP下使用tasm编译，tlink链接，在DOS下运行
第11章80486及Pentium 程序设计基础
Intel的80486和Pentium是80x86家族的新成员，它们保持与80386的兼容。本章在前两章的基础上介绍80486和Pentium。本章不涉及浮点处理部件方面的内容。
11.180486程序设计基础
80486是80x86家族中继80386之后又一种功能更强大的32位微处理器。80486有80486DX和80486SX两款，80486DX是在80386的基础上集成浮点处理部件和超高速缓存而构成的，
80486SX不包含浮点处理部件。由于我们几乎不涉及浮点处理方面的内容，所以把它们简单地统称为80486，而不加区分。
从程序设计的角度看，80486只比80386多了几个控制位和6条指令，所以第9章和第10章介绍的内容对80486仍有效。
11.1.1寄存器
80486不仅兼容80386，而且还在片上集成了相当于80387的浮点处理部件，所以80486含有80386和80387所拥有的全部32位寄存器。这些寄存器可分为如下几类：
（1）基本结构寄存器，包括通用寄存器、段寄存器、指令指针和标志寄存器。
（2）系统级寄存器，包括控制寄存器和系统地址寄存器。
（3）浮点处理部件FPU寄存器，包括数据寄存器、标志字、状态字、控制字、指令和数据指示字。
（4）调试和测试寄存器。
1.基本结构寄存器及标志寄存器
80486的8个32位的通用寄存器与80386相同，6个段寄存器与80386相同，指令指针也与80386相同。请参见图9.1。
31          19   18   17   16  15  14  13 12   11   10  9  8    7   6   5  4   3  2   1  0
                    AC  VM  RF  0   NT  IOPL    OF  DF IF TF  SF ZF  0 AF 0  PF     CF
80486的标志寄存器EFLAGS仍是32位，如图11.1所示。与图9.2所示的80386标志寄存器相比，80486的标志寄存器新增了一个对齐检查标志AC。
其他标志位的位置及意义保持与80386相同。
标志位AC参与控制地址不对齐异常的发生。所谓地址不对齐是指如下情形：访问一个奇地址的字，或访问地址不是4的倍数的双字等等。
如果AC置1，那么当出现地址不对齐情形时，引起地址对齐异常。但在特权级0、1和2运行时，忽略AC位的设置，在CR0中的AM位为1时也忽略AC位的设置。
地址对齐异常是80486新设置的异常，属于故障类异常，向量号规定为11H。80486地址对齐异常提供出错码0。只有在特权级3运行的应用程序才可能引起地址对齐故障。
2.系统级寄存器及控制寄存器
系统地址寄存器是指全局描述符表寄存器GDTR、局部描述符表寄存器LDTR、中断描述符表寄存器IDTR和任务状态段寄存器TR。
80486的这些系统地址寄存器与80386对应的系统地址寄存器相同。请参见图10.9。
80486仍只包括3个控制寄存器CR0、CR2和CR3。CR2用于指示引起页面故障的线性地址。CR0新设了5个控制位。CR3新设了2个控制位。
（1）控制寄存器CR0
       31  30  29  28                     19 18 17 16 15        11                5    4   3   2    1     0
CR0 PG CD NW 0 0 0 0 0 0 0 0 0 0 AM 0 WP 0 0 0 0  0 0 0 0  0 0 NE ET TS EM MP PE
CR1 保留
CR2 页故障线性地址
CR3 页目录表物理页码                                      0 0 0 0 0 0 0 0 0 0 0 0
图11.2给出了80486控制寄存器CR0各位的定义。与如图10.9所示的80386控制寄存器CR0相比较，80486的CR0新定义了如下控制位：
用于控制片上超高速缓存工作方式的CD位和NW位；对齐屏蔽位AM；页面写保护位WP；数字异常位NE。
PE位控制80486工作于实方式还是保护方式，PG位控制是否启用分页机制，它们的作用与80386保持兼容，它们组合定义的处理器工作方式如表10.3所列。
由于80486含浮点处理部件，所以处理器扩展类型位ET总是1。
位TS、EM和MP的作用与80386保持兼容。只是它们控制片上浮点处理部件。新设的数字异常位NE控制通过哪种方式报告未屏蔽的浮点部件出错故障。NE=0，采用外部中断方式报告。
这种方式是系统复位时的缺省方式，保持与先前微机系统的处理方式相一致。也即当浮点部件出错时，导致中断向量号为0DH的外部中断。
NE=1，通过引起浮点部件出错故障报告，对应中断向量号为10H。请参见10.7.2节。
新设的对齐屏蔽位AM控制标志寄存器EFLAGS中的对齐检查标志AC是否有效。
AM=0，忽略AC位。这是系统复位时的缺省状态，以便保持与80386兼容。AM=1，考虑AC位，这时才可能引起地址对齐异常。
新设的页面写保护位WP控制系统级程序写访问只读页面。80386允许系统特权级（0级、1级和2级）程序写访问只读页面，请参见10.10.3节。
在80486中，这种情况受到WP位的控制。WP=0，保持与80386兼容，这是系统复位时的缺省状态。WP=1，任何特权级程序向只读页面写访问，都将引起页故障。
新设的片上超高速缓存控制位CD控制是否允许超高速缓存填充。CD=0，允许片上超高速缓存填充。CD=1，禁止片上超高速缓存填充。
新设的片上超高速缓存直写方式控制位NW控制是否采用直写方式。NW=1，采用直写方式和允许使无效，这是系统复位时的缺省状态。NW=0，禁止直写方式及使无效。
关于这两个控制位的详细说明请参见11.1.4节。
为了严格与先前的处理器兼容，装入机器状态字指令LMSW，不能改变ET位和NE位。
（2）控制寄存器CR3
       31  30  29  28                     19 18 17 16 15        11                5    4   3   2    1     0
CR0 PG CD NW 0 0 0 0 0 0 0 0 0 0 AM 0 WP 0 0 0 0  0 0 0 0  0 0 NE ET TS EM MP PE
CR1 保留
CR2 页故障线性地址
       31  30  29  28                     19 18 17 16 15        11                      4   3     2   1   0
CR3 页目录表物理页码                                               0 0 0 0 0 0 0    PCD PWT  0  0  0
31                  12   11   10   9   8   7   6   5   4   3         2   1   0
      物理页码          AVL           0   0   D   A  PCD PWT   U   R   P
                                                                                  S   W
如图10.9所示，CR3的高20位是页目录表所在物理页的页码。在80386中，CR3的低12位保留未用。80486在CR3的低12位中定义了2个新的控制位PCD和PWT，如图11.3所示。
80486的页目录表和页表项也在位4和位3的位置定义了PCD和PWT位，也就是说在如图10.28所示的表项格式的位4是PCD位，位3是PWT位。
控制寄存器CR3、页目录表和页表中的这两个控制位参与控制页面可超高速缓存性。
3.调试和测试寄存器
80486象80386一样含有6个调试寄存器，它们分别是DR0、DR1、DR2、DR3、DR6和DR7。在11.2节介绍调试寄存器的使用。
80486含有5个测试寄存器。TR6和TR7用于支持转换后援缓冲器TLB的测试，这与80386相同。TR3、TR4和TR5用于测试片上超高速缓存。
11.1.2指令系统
80486的指令集是在80386指令集的基础上增加了6条新指令。所以，80486的指令集包含了80386的指令集，并保持与80386兼容。
新增的指令主要用于片上高速缓存的清洗和对多处理器系统的支持。下面就只介绍新增的6条指令。
1.字节交换指令BSWAP
字节交换指令的格式如下：
BSWAP OPRD
其中操作数OPRD是任一32位通用寄存器。
字节交换指令BSWAP的功能是在操作数OPRD内交换4个字节的顺序。交换对应关系是：第0字节与第3字节交换，第1字节与第2字节交换，如图11.4所示。
例如：
BSWAP EAX
设EAX=11223344H，执行后EAX=44332211H
BSWAP ESI
设ESI=87654321H，执行后ESI=21436587H
该指令不影响各标志。
80x86系列处理器按“高高低低”的原则存储多字节数据，但某些处理器按“低低高高”原则存储数据。
BSWAP指令特别适宜于这两种数据格式之间的转换。
2.交换加指令
交换加指令的格式如下：
XADD OPRD1,OPRD2
交换加指令XADD的功能是交换操作数OPRD1和OPRD2的内容，并把两个操作数相加结果送到操作数OPRD1中。
其中操作数OPRD1可以是8位、16位或32位通用寄存器或者存储单元，操作数OPRD2只能是8位、16位或32位通用寄存器。两个操作数的尺寸必须一致。
例如：
XADD AL,AH
设AX=1122H，执行后AX=2233H
XADD [BX],ESI
XADD [ECX+3],AL
XADD指令按照一条相当于ADD指令的操作设置标志寄存器中的各运算结果标志。
XADD指令的功能相当于连续的交换指令XCHG和加运算指令ADD的功能。但该指令能更好地实现信号量操作。例如：
MOV AL,1
XADD Sema,AL
JC Failed
当在XADD指令前加LOCK前缀时，能方便地实现多处理器场合的信号量操作。
LOCK:这是一个指令前缀，在所对应的指令操作期间使此指令的目标操作数指定的存储区域锁定，以得到保护。
XADD:先交换两个操作数的值，再进行算术加法操作。多处理器安全，在80486及以上CPU中支持。
CMPXCHG:比较交换指令，第一操作数先和AL/AX/EAX比较，如果相等ZF置1，第二操作数赋给第一操作数，否则ZF清0，第一操作数赋给AL/AX/EAX。
多处理器安全，在80486及以上CPU中支持。
3.比较交换指令CMPXCHG
比较交换指令的格式如下：
CMPXCHG OPRD1,OPRD2
其中操作数OPRD1可以是8位、16位或32位通用寄存器或者存储单元；操作数OPRD2只能是通用寄存器，并且尺寸必须与OPRD1相一致。
比较交换指令的功能是把对应尺寸的累加器（EAX、AX、AL）与操作数OPRD1比较，如果相等，把操作数OPRD2的内容送操作数OPRD1，并置零标志ZF；
如果不等，把操作数OPRD1的内容送累加器，并清零标志ZF。
例如：
CMPXCHG BL,CL
CMPXCHG [EDX],SI
CMPXCHG [SI],EAX
该指令按比较结果影响有关标志。
在加上LOCK前缀后，该指令对多处理器情况下的信号量操作非常有用。
4.使超高速缓存无效指令INVD
使超高速缓存无效指令的格式如下：
INVD
该指令使片上超高速缓存无效，也即清洗片上超高速缓存。该指令也产生一个特殊的总线周期，它可以用于使外部（二级）超高速缓存无效。
注意，该指令不把片上超高速缓存中的内容写回主存，所以使用时必须十分小心，通常应使用WBINVD指令。
该指令不影响各标志。
该指令是特权指令。只有在实方式和保护方式的特权级0下，才可执行该指令。
我们在11.1.3节介绍片上超高速缓存的有关内容，和举例说明INVD指令的使用。
5.写回并使超高速缓存无效指令WBINVD
写回并使超高速缓存无效指令的格式如下：
WBINVD
该指令使片上超高速缓存无效，也即清洗片上超高速缓存，但在清洗前把片上超高速缓存中更改的内容写回主存。
该指令会产生特殊的总线周期，指示把外部超高速缓存中更改的内容写回主存和指示外部超高速缓存无效。
通常应该使用该指令清洗片上超高速缓存。
该指令不影响各标志。
该指令是特权指令。只有在实方式和保护方式的特权级0下，才可执行该指令。
6.使TLB项无效指令INVLPG
我们知道，在启用分页机制的情况下，分页部件利用页目录表和页表把线性地址转换成物理地址。为了加快转换速度，80386和80486片上都有转换后援缓冲器TLB。
TLB含32个项，用于存放当前最常使用的物理页的页码。
使TLB项无效指令的格式如下：
INVLPG OPRD
其中操作数OPRD必须是存储器操作数。该指令的功能是，如果存储器操作数OPRD能通过TLB中的某项转换成物理地址，那么使TLB内对应项无效。
例如：
INVLPG [BX]
INVLPG [ECX*2+30H]
该指令不影响各标志。
该指令是特权指令。只有在实方式和保护方式的特权级0下，才可执行该指令。
只有在特殊情况下才使用该指令，强制更新某些TLB项。
11.1.3片上超高速缓存
为了进一步提高性能，80486在片上带有8K字节的超高速缓存器。它对软件是透明的，以保证与80x86系列先前的处理器兼容。
尽管超高速缓存器是透明的，但了解它的组织和工作方式，对优化程序很有益。
下面简单介绍片上超高速缓存的组织和工作方式，同时说明控制寄存器CR0中控制位CD和NW等的作用。
       31  30  29  28                     19 18 17 16 15        11                5    4   3   2    1     0
CR0 PG CD NW 0 0 0 0 0 0 0 0 0 0 AM 0 WP 0 0 0 0  0 0 0 0  0 0 NE ET TS EM MP PE
CR1 保留
CR2 页故障线性地址
       31  30  29  28                     19 18 17 16 15        11                      4   3     2   1   0
CR3 页目录表物理页码                                               0 0 0 0 0 0 0    PCD PWT  0  0  0
31                  12   11   10   9   8   7   6   5   4   3         2   1   0
      物理页码          AVL           0   0   D   A  PCD PWT   U   R   P
                                                                                  S   W
1.片上超高速缓存及其工作方式的控制
                  Way0         Way1         Way2         Way3
index 127 16 bytes    16 bytes     16 bytes     16 bytes
index 126 16 bytes    16 bytes     16 bytes     16 bytes
index 125 16 bytes    16 bytes     16 bytes     16 bytes
index ...
index 3 16 bytes    16 bytes     16 bytes     16 bytes
index 2 16 bytes    16 bytes     16 bytes     16 bytes
index 1 16 bytes    16 bytes     16 bytes     16 bytes
index 0 16 bytes    16 bytes     16 bytes     16 bytes
80486的8K字节片上超高速缓存既能存储数据又能存储代码（指令）。8K字节容量指能用于存储数据或指令的容量，而不包括用于存储地址标记等的容量。
片上超高速缓存采用4路组相关联结构，在物理上分成4个2K字节的块。每块由128行构成，每行16字节宽。在逻辑上，分成128组，每组4行。
每行都有一个21位的标记相关联，记录每行与主存储器中存储单元的对应关系，这21位的标记相当于主存储器中存储单元物理地址的高端部分。
每一行都有一个有效位相关联，每行不是有效就是无效，没有部分有效的行。每行还有用于记录最近最少使用情况的LRU位相关联。
超高速缓存命中是指欲访问的存储单元地址作为有效标记部分出现在超高速缓存中。如果是读命中，那么直接从片上超高速缓存中读出，从而大大提高速度。
如果读未命中，那么通常会把该存储单元所在行填入超高速缓存。如果写命中超高速缓存，那么80486通常（采用直写方式时）不仅向超高速缓存相应单元写，
同时也向主存储器相应单元写。如果写未命中，那么直接写入主存储器相应单元，不影响超高速缓存。
片上超高速缓存的工作方式由控制寄存器CR0中的CD位和NW位控制。其中，CD位允许和禁止填充片上超高速缓存，NW位控制直写和使无效。
表11.1 片上超高速缓存的工作方式
CD         NW         片上超高速缓存工作方式
0            0             允许超高速缓存填充，允许直写和使无效
0            1             无效组合，导致出错码为0的通用保护故障
1            0             禁止超高速缓存填充，允许直写和使无效
1            1             禁止超高速缓存填充，禁止直写和使无效
由CD位和NW位组合定义的片上超高速缓存的工作方式比较灵活，列于表11.1。
尽管两位可表示4种方式，但CD=0和NW=1的组合是无效组合，会引起通用保护故障。在RESET后的缺省组合是CD=1和NW=1，超高速缓存为空。
CD=0允许超高速缓存填充。当读访问存储单元时，如果未命中片上超高速缓存，那么所读存储单元所在行通常就会被填充到超高速缓存，
并且物理地址的高端部分就作为该行的标记。在处理器外部，通过其他途径可以阻止某些存储单元不被超高速缓存，这是不通常情况。
在把某行填充到超高速缓存时，首先检查该组中所有的4行是否都有效，如果有无效行，则更新该行，如果都有效，那么采用最近最不常使用算法确定更新哪一行。
CD=1禁止超高速缓存填充。当读访问存储单元未命中片上超高速缓存时，不把所在行填充到超高速缓存。不影响读命中超高速缓存，
不影响写命中超高速缓存和写未命中超高速缓存的动作。
NW=0允许直写和使无效。当写访问命中超高速缓存时，所写信息写入片上超高速缓存，同时驱动一个外部写总线周期，更新外部对应存储单元。
80486集成有监视其他外部系统写入主存储器的逻辑，当它检查到其他外部系统写入主存储器的存储单元命中片上超高速缓存时，就使片上超高速缓存的对应行无效。这就是使无效。
它在保证超高速缓存的内容与对应主存储器的内容保持一致方面起重要作用。
NW=1禁止直写和使无效。当写访问命中超高速缓存时，更新片上超高速缓存相应行，但不更新外部对应存储单元。
当其他外部系统更新主存储器的存储单元命中片上超高速缓存时，并不使片上超高速缓存对应行无效。这种处理方法会导致片上超高速缓存内容与对应主存储器的内容不一致。
Intel 8253 (或 8254)是一个可编程定时/计数器（PIT-Programmable Interval Timer)芯片，用于解决计算机中通常碰到的时间控制问题，
即在软件的控制下产生精确的时间延迟。该芯片提供了3个独立的16位计数器通道。每个通道可工作在不同的工作方式下，并且这些工作方式均可以使用软件来设置。 
8254是8253的更新产品，主要功能基本一样，只是8254芯片加了回读命令。
8254芯片的IO端口地址范围是0x40~0x43。其中0x40~0x42分别对应计数器通道0~2，0x43对应控制字寄存器写端口。
通过向8253写入一个控制字和一个初始计数值，我们就可以对想要使用的一个计数器进行编程。
控制字的内容会指定正在编程的计数器通道，当控制字写完后，就可以向某个通道写入初始计数值。
初始计数值必须根据控制字中设定的格式写入（二进制或BCD码格式）。
7         6         5         4               3         2         1         0
00 计数器0  00 计数器锁存命令  000 方式0              0 二进制
01 计数器1  01 只读写低字节      001 方式1              1 十进制
10 计数器2  10 只读写高字节      x10 方式2
11 非法        11 先读写低字节     x11  方式3
                         后读写高字节     100  方式4
                                                   101 方式5
计数从“计数初始值 开始，每当CLK信号出现一次，计数值减1，当计数值减为0时，从OUT端输出规定的信号（具体形式与工作模式有关）。
当CLK信号出现时，计数值是否减1（即是否计数），受到“门控信号”GATE的影响，一般，仅当GATE有效时，才减1。
门控信号GATE如何影响计数操作，以及输出端OUT在各种情况下输出的信号形式与定时/计数器的工作模式有关。
CLK信号是计数输入信号，即计数器对CLK端出现的脉冲个数进行计数。
OUT信号在计数结束时，发生变化。
一般情况下，“计数输出寄存器”的值随着计数器的计数值变化，CPU读取其值之前，应向“控制寄存器”发送一个锁存命令，这时，“计数输出寄存器”的值不再随计数器的值变化，
CPU用读指令从“计数输出寄存器”中读得当前计数值。读命令同时又使“计数输出寄存器”的值随计数器的值变化。
2.演示片上超高速缓存作用的实例
下面给出一个演示片上超高速缓存如何提高速度性能的演示程序。
演示程序含有一个循环访问某些存储单元的测试子程序，该测试子程序还能测定运行所耗时间。
演示程序在允许和禁止片上超高速缓存两种情况下，分别调用该测试子程序，然后显示两种情况下运行同一子程序所耗时间。
该演示程序在80486实方式下运行。源程序清单如下：
；程序名：T11-1.ASM
；功能：演示片上高速缓存的作用
；说明：仅在80486实方式下运行（用TASM汇编，用TLINK连接）
CDBIT = 30
COUNT = 100
.486P
CSEG SEGMENT PARA USE16
CacheD DB 'Cache Disable:$'
CacheE DB 'Cache Enable:$'
ASSUME CS:CSEG
BEGIN:PUSH CS
POP DS
Step1:CLI
MOV EAX,CR0
BTS EAX,CDBIT
MOV CR0,EAX
INVD
CALL Access
STI
MOV ESI,EDX
Step2:CLI
MOV EAX,CR0
BTR EAX,CDBIT
MOV CR0,EAX
INVD
CALL Access
STI
MOV EDI,EDX
Step3:MOV DX,OFFSET CacheD
MOV ECX,ESI
CALL DMESS
MOV DX,OFFSET CacheE
MOV ECX,EDI
CALL DMESS
Over:MOV AH,4CH
INT 21H
Access PROC
MOV CX,COUNT
MOV EBX,16
CALL GetCount
SHL EDX,16
ACC1:MOV EAX,[EBX]
MOV EAX,[EBX*2]
MOV EAX,[EBX+EBX*2]
LOOP ACC1
CALL GetCount
RET
Access ENDP
GetCount PROC
MOV AL,0
OUT 43H,AL
CALL DELAY
IN AL,40H
MOV DL,AL
CALL DELAY
IN AL,40H
MOV DH,AL
DELAY:RET
GetCount ENDP
DMESS PROC
MOV AH,9
INT 21H
SHLD EDX,ECX,16
SUB DX,CX
DMESS1:MOV AX,DX
CALL ECHOAX
CALL NEWLINE
RET
DMESS ENDP
ECHOAX PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV DX,AX
MOV CX,4
ECHOAX1:ROL DX,4
MOV AL,DL
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
MOV BH,0
MOV AH,0EH
INT 10H
LOOP ECHOAX1
POP DX
POP CX
POP BX
POP AX
RET
ECHOAX ENDP
NEWLINE PROC NEAR
PUSH AX
PUSH BX
MOV BH,0
MOV AL,0DH
MOV AH,0EH
INT 10H
MOV AL,0AH
MOV AH,0EH
INT 10H
POP BX
POP AX
RET
NEWLINE ENDP
CSEG ENDS
END BEGIN
在XP下使用tasm t470.asm编译，tlink t470.obj链接
在DOS下运行t470.exe
c:\TASM16\T470.exe
Cache Disable:0006
Cache Enable:0002
上述演示程序的演示过程是清楚的。现就测试子程序所耗时间表示值的测定作些说明。PC及其兼容机系统中的定时计数器芯片支持多个独立的计数器，
其中0号计数器用于形成系统软时钟。计数器采用减计数方式，每当计数到0时就自动重新按初始化时设置的计数初值开始下一轮计数。
计数器0的计数初值是65536。读取计数器0的方法是把计数器号送到定时计数器控制端口43H，然后分两次从40H端口读取计数器计数值。
测试子程序在开始循环前读取计数值，在结束循环后再读取计数值。这两个计数值可认为是开始和结束的时间表示，它们的差能够反映测试子程序所耗的时间，但不等于所耗时间，
所以我们称之为时间表示值。通常定时计数器的输入频率固定为1193180，根据该计数频率可计算出测试子程序所耗的时间。
顺便说一下，时钟中断产生的间隔时间大约55ms就是根据该输入频率计算出的。
请注意，由于Pentium片上超高速缓存通常情况下不采用直写方式，而采用回写方式，所以上述演示程序在以Pentium为处理器的系统上运行可能要出问题。
如要在Pentium上运行，那么把程序中的清洗片上超高速缓存的指令INVD，改成指令WBINVD。
3.演示控制位NW作用的子程序
上述演示程序清楚地说明了CR0中控制位CD的作用，下面的程序片段能说明控制位NW的作用，也反映禁止直写可能导致超高速缓存与主存储器相应存储单元不一致的情况。
所以，在禁止超高速缓存和禁止直写和使无效时，应清空超高速缓存。
......
ENTER 2,0
CLI
INVD
LINE1:MOV BL,[BP-2]
MOV BYTE PTR [BP-2],1
MOV EAX,CR0
BTS EAX,30
LINE2:BTS EAX,29
MOV CR0,EAX
MOV BYTE PTR [BP-2],5
MOV CL,[BP-2]
LINE3:INVD
MOV BL,[BP-2]
BTR EAX,30
BTR EAX,29
MOV CR0,EAX
STI
LEAVE
......
请考虑分别删除上述程序片段中LINE1、LINE2或LINE3后的执行情况。
       31  30  29  28                     19 18 17 16 15        11                5    4   3   2    1     0
CR0 PG CD NW 0 0 0 0 0 0 0 0 0 0 AM 0 WP 0 0 0 0  0 0 0 0  0 0 NE ET TS EM MP PE
CR1 保留
CR2 页故障线性地址
       31  30  29  28                     19 18 17 16 15        11                      4   3     2   1   0
CR3 页目录表物理页码                                               0 0 0 0 0 0 0    PCD PWT  0  0  0
31                  12   11   10   9   8   7   6   5   4   3         2   1   0
      物理页码          AVL           0   0   D   A  PCD PWT   U   R   P
                                                                                  S   W
4.页面可超高速缓存性
在处理器外部，通过对80486的输入引脚KEN#的控制，可以使访问的存储单元不被超高速缓存。软件可以设置控制位CD禁止超高速缓存填充。
在启用分页机制时，软件可以设置页表项中的PCD位阻止页面被超高速缓存。设置页目录表中的PCD位和CR3中的PCD位阻止页表和页目录表被超高速缓存。
因为存在转换后援缓冲器TLB，所以通常页表和页目录表不需要超高速缓存。
80486的输出引脚PCD和PWT能够用于控制外部高速缓存。引脚PCD和PWT受页表项、页目录项或者CR3中PCD位和PWT位的驱动。但CD能够屏蔽PCD。总之，
PCD位能够用于控制页面可超高速缓存性；PWT位控制外部高速缓存的直写策略，但不影响片上超高速缓存的直写策略。
11.2 80486对调试的支持
8086/8088提供断点指令INT3和单步标志TF，调试工具利用它们可以设置断点和实现单步。从80386开始，在片上集成了调试寄存器。
利用这些调试寄存器不仅可以设置代码执行断点，而且还可以设置数据访问断点；不仅可以把断点设置在RAM中，也可以把断点设置在ROM中。
所以说，这些调试寄存器能提供调试便利和简化调试过程。
80486的调试功能包括了80386的调试功能并稍有扩充。关于断点指令和单步与8086/8088基本相一致。本节主要介绍80486通过调试寄存器提供的支持调试能力。
11.2.1调试寄存器
31                  16   15                  0
断点0线性地址                                   DR0
断点1线性地址                                   DR1
断点2线性地址                                   DR2
断点3线性地址                                   DR3
保留                                                 DR4
保留                                                 DR5
                           B B B        B B B B                   DR6
                           T S D        3 2 1 0
L R L R L R L R            G   G L G L G L G L G L      DR7
E W E W E W E W       D   E E 3 3 2 2 1 1 0 0
N E N E N E N E
3 3 2 2 1 1 0 0
31                  16   15                  0
80386和80486都支持6个调试寄存器，如图11.5所示。它们分别是断点地址寄存器DR0、DR1、DR2和DR3，调试状态寄存器DR6和调试控制寄存器DR7。
这些断点寄存器都是32位寄存器。利用在10.8.2节介绍的调试寄存器数据传送指令，可以存取这些调试寄存器。
但必须注意，调试寄存器数据传送指令只能在实方式和保护方式的特权级0下执行，所以只有在实方式或特权级0执行的程序才能设置断点和进行断点处理。
1.断点地址寄存器
断点地址寄存器用于保存断点处的线性地址，也即指示断点位置。这些寄存器长32位，与32位线性地址长度相符。
处理器硬件把执行指令所涉及的线性地址和断点地址寄存器内的线性地址进行比较，判别执行指令是否触及断点。
处理器具有4个断点地址寄存器DR0、DR1、DR2和DR3，所以可以同时支持4个这样的“硬”断点。
因为由片上寄存器指示断点位置，而非断点中断指令指示断点位置，所以这些“硬”断点可以设置在ROM中或者几个任务共享的代码中。
不论是否启用分页机制，断点地址寄存器内保存的总是线性地址。我们知道，如果不启用分页机制，那么线性地址就等于物理地址；
如果启用分页机制，那么线性地址经过分页部件转换成物理地址。
根据线性地址设置断点保证使断点与分页无关。这种断点位置由线性地址表示的做法便于断点的表示，也符合实际调试的需要。
2.调试控制寄存器
31                  16   15                  0
断点0线性地址                                   DR0
断点1线性地址                                   DR1
断点2线性地址                                   DR2
断点3线性地址                                   DR3
保留                                                 DR4
保留                                                 DR5
                           B B B        B B B B                   DR6
                           T S D        3 2 1 0
L R L R L R L R            G   G L G L G L G L G L      DR7
E W E W E W E W       D   E E 3 3 2 2 1 1 0 0
N E N E N E N E
3 3 2 2 1 1 0 0
31                  16   15                  0
调试寄存器DR7也称为调试控制寄存器，其各字段的意义如图11.5所示。它不仅控制是否允许断点，还控制各断点是代码执行断点还是数据访问断点。DR7所含各字段作用如下：
（1）断点类型说明字段RWE
DR7有4个RWE字段，依次分别对应4个断点。RWEi字段说明DRi寄存器所指示断点的类型。
每一个RWE占两位，所表示的类型列于表11.2。
表11.2 RWE字段说明的断点类型
RWE字段取值         断点类型(断点条件)         RWE字段取值         断点类型(断点条件)
0 0                        只执行                          1 0                        未定义(不能用该值)
0 1                        只写入数据                    1 1                        只读或写数据
“00”表示指令执行断点，当执行对应断点地址寄存器所含地址处的指令时，满足断点条件。注意，指令执行断点地址必须等于指令开始的字节地址（包括前缀）。
“01”和“11”表示数据访问断点，当按所示读写方式访问对应断点地址寄存器所含地址处的存储单元时，满足断点条件。
（2）断点长度说明字段
DR7有4个LEN字段，依次分别对应4个断点。LENi字段说明DRi寄存器所指示断点的长度（范围）。
每一个LEN占两位，所表示的长度列于表11.3。
表11.3 LEN字段说明的断点长度
LEN字段取值         断点长度(范围)         断点地址寄存器指示的断点地址
0 0                       1字节                     全部32位指示一个单字节的断点
0 1                       2字节                     最低1位被忽略，确定字对齐地址开始的2字节断点
1 0                       未定义(不能取该值)
11                        4字节                     最低2位被忽略，确定双字对齐地址开始的4字节断点
指令执行断点的断点长度必须为1字节。数据访问断点的断点长度可以是1字节、2字节或4字节。
对于数据访问断点而言，如表11.3所示，实际上，断点长度说明字段LEN和对应断点寄存器规定了断点的区域范围。
例如，设DR1内的断点线性地址是XXXXXXX5H，当LEN1=00时，断点的区域范围只有1字节，地址就是XXXXXXX5H；
当LEN1=01时，断点的区域范围是地址XXXXXXX4H到XXXXXXX5H的2字节；
当LEN1=11时，断点的区域范围是地址XXXXXXX4H到XXXXXXX7H的4字节。
当按RWE所示数据访问断点方式访问存储单元触及断点范围内的字节时，就满足断点条件。
（3）全局和局部断点允许位
DR7有4个Gi和Li，分别对应4个断点。Gi和Li控制DRi所指示的断点i在断点条件满足时，是否引起断点异常。
当Gi或Li为1时，如果DRi所指示数据访问断点条件满足，那么导致进入向量号为1的调试陷阱，如果DRi所指示指令执行断点条件满足，那么导致引发向量号为1的调试故障。
Gi和Li分别称为全局断点允许位和局部断点允许位。在任务切换时，处理器清各Li位，所以Li位只支持一个任务范围内的断点。任务切换并不影响Gi位，所以Gi支持系统内各任务的断点。
（4）精确数据访问断点相符位
DR7还有GE位和LE位.用于指示是否要求数据访问断点精确相符。80486无论GE或LE是否置位，总是断点精确相符的。
在80386中，可能出现数据访问断点不精确相符，通过设置GE位或LE位可指示80386数据访问断点精确相符。
在任务切换时，LE位被自动清除，所以LE位是局部于任务的；任务切换时GE位不受影响，所以GE位是全局的。
（5）全局调试寄存器访问检测位
DR7的位13是调试寄存器访问检测位GD。尽管只能在实方式或保护方式的特权级0时才能访问调试寄存器，但GD位还提供对调试寄存器的特别保护。
在GD=1的情况下，即使在实方式或保护方式的特权级0时，访问任何调试寄存器都会引起向量号为1的调试故障。
这种附加的保护特性保证调试程序在需要的时候可以完全控制调试寄存器资源。在进入向量号为1的异常处理程序时，自动地清除GD位，以便异常1处理程序能自由地访问调试寄存器。
31                  16   15                  0
断点0线性地址                                   DR0
断点1线性地址                                   DR1
断点2线性地址                                   DR2
断点3线性地址                                   DR3
保留                                                 DR4
保留                                                 DR5
                           B B B        B B B B                   DR6
                           T S D        3 2 1 0
L R L R L R L R            G   G L G L G L G L G L      DR7
E W E W E W E W       D   E E 3 3 2 2 1 1 0 0
N E N E N E N E
3 3 2 2 1 1 0 0
31                  16   15                  0
3.调试状态寄存器
调试寄存器DR6也称为调试状态寄存器，其各位的定义如图11.5所示。它指示断点原因，也即指示进入异常1处理程序的原因。
异常1处理程序可根据DR6的有关位，确定是数据访问断点、指令执行断点、单步或其他原因。
DR6内的各指示位为1时所表示的意义如下：
Bi=1（i=0，1，2，3）表示由DRi所指示的断点引起指令执行调试故障或进入数据访问调试陷阱。每当处理器在某个允许的断点i处发现断点条件满足，就设置DR6中的Bi，
然后转入异常1处理程序。要特别注意，在某个允许的断点i处断点条件满足而设置Bi时，同时设置所有在那瞬间断点条件满足的各对应Bj位，而不论是否允许。
因此，异常1处理程序可能看到多个Bi被置位，但可以通过判断断点允许位Gi和Li位的方法来确定真实的原因。
BD=1表示在GD置位的情况下访问调试寄存器，从而引起调试故障。在进入异常1处理程序时，自动清除GD位。
BS=1表示由于单步原因进入调试陷阱。当标志寄存器EFLAGS中的单步标志TF置位时，一般每执行完一条指令后就进入异常1处理程序，这就是单步。
由于在进入异常处理程序时，自动清TF标志。实方式下的情形请参见图5.6，保护方式下的情形请参见图10.20，所以，异常1处理程序的执行不会再单步。
在异常处理程序结束时，中断返回指令IRET从堆栈中弹出原标志寄存器内容到标志寄存器，如果TF为1的话，那么又会产生单步。
实际上，在执行置位TF指令的下一条指令（通常是IRET）之后才产生单步。还请参见5.3.5节。
BT=1表示刚切换到任务状态段TSS中的调试陷阱标志T置位的任务。任务状态段TSS内安排了一个调试陷阱标志T，从图10.14可见，该标志T是任务状态段TSS内偏移64H处的字的最低位。
在任务切换时，如果进入任务的T位为1，那么通常在任务切换完成之后，新任务的第一条指令执行之前进入调试陷阱，也即进入异常1处理程序。这也称为任务切换自陷。
请注意，硬件根据上述各种情况设置调试状态寄存器DR6中的相应标志，但硬件并不自动清除它们。所以，异常1处理程序一般应该在返回前清除DR6，以免发生混淆。
31          19   18   17   16  15  14  13 12   11   10  9  8    7   6   5  4   3  2   1  0
                    AC  VM  RF  0   NT  IOPL    OF  DF IF TF  SF ZF  0 AF 0  PF     CF
80486的标志寄存器EFLAGS仍是32位，新增了一个对齐检查标志AC。
重启动标志RF（Restart Flag）
重启动标志控制是否接受调试故障。RF=0接受，RF=1忽略。在成功地完成每一条指令后，处理器把RF清0。
而当接收到一个非调试故障时，处理器把RF置1。
4.调试故障和调试陷阱的区别
调试异常分为调试故障和调试陷阱两类。数据访问断点、单步和任务切换自陷属于调试陷阱。调试陷阱是在执行引起异常的指令之后发生，
进入调试陷阱时，保存在堆栈中的返回地址指向引起陷阱的指令的下一条要执行指令。
调试故障是在引起异常的指令之前发生，进入调试故障时，堆栈中的返回地址指向引起故障的指令。
标志寄存器EFLAGS中的重启动标志RF能控制是否产生调试故障。在把RF置成1后，下一条指令的任何调试故障被忽略。
通常每当成功地执行完一条指令，那么RF被清0。但IRETD指令例外，它能根据堆栈中标志寄存器映象的RF位值设置RF。
异常1处理程序能利用这一特性，在返回断点处时不再重复产生断点故障。
11.2.2演示调试故障/陷阱的实例
下面给出一个可在实方式下运行的演示调试故障和调试陷阱的实例。
实例程序由两部分组成：异常1处理程序和演示程序，分别安排在两个段中。
异常1处理程序的处理步骤如下：
（1）在屏幕的左上角区域以二进制数的形式显示调试状态寄存器DR6、指令指针EIP的低16位部分IP和32位寄存器EAX的内容。
（2）调用BIOS键盘管理程序，等待按键。该步是让用户能够看清上述显示内容。
（3）根据DR6和DR7判断进入异常1处理程序的原因。分调试陷阱和调试故障两种情形结束异常1处理程序。
对于调试陷阱，直接用中断返回指令IRET返回。对于调试故障，通过能够设置标志寄存器中RF标志的IRETD指令返回，
为此还必须在堆栈中形成由二个双字的返回地址和32位EFLAGS映象的断点现场。
演示程序的执行步骤如下：
（1）把异常1处理程序的入口填入中断向量表。由于实例在实方式下运行，所以仍使用中断向量表。
（2）模拟单步陷阱和访问调试寄存器故障。
（3）把演示的断点线性地址装入DR0、DR2和DR3，并设置DR7。
（4）模拟指令执行断点和数据访问断点。
源程序清单如下：
；程序名：T11-2.ASM
；功能：演示调试故障/陷阱的发生及处理
；说明：用TASM汇编，用“TLINK /3”命令连接。
COLOR = 17H
.486P
CSEGD SEGMENT PARA USE16
ASSUME CS:CSEGD
Debug:PUSHAD
PUSH ES
CLD
MOV DI,0B800H
MOV ES,DI
XOR DI,DI
MOV EAX,(COLOR SHL 8 + 'R') SHL 16 + (COLOR SHL 8 + 'D')
STOSD
MOV EAX,(COLOR SHL 8 + '=') SHL 16 + (COLOR SHL 8 + '6')
STOSD
MOV EDX,DR6
BSWAP EDX
XCHG DH,DL
CALL ECHOB
BSWAP EDX
CALL ECHOB
MOV DI,160
MOV AX,COLOR SHL 8 + 20H
STOSW
MOV EAX,(COLOR SHL 8 + 'P') SHL 16 + (COLOR SHL 8 + 'I')
STOSD
MOV AX,COLOR SHL 8 + '='
STOSW
MOV DX,[ESP + 4 * 8 + 2]
CALL ECHOB
MOV DI,320
MOV EAX,(COLOR SHL 8 + 'A') SHL 16 + (COLOR SHL 8 + 'E')
STOSD
MOV EAX,(COLOR SHL 8 + '=') SHL 16 + (COLOR SHL 8 + 'X')
STOSD
MOV EDX,[ESP + 4 * 8 + 2 - 4]
ROL EDX,16
CALL ECHOB
ROL EDX,16
CALL ECHOB
MOV AH,0
INT 16H
MOV EDX,DR6
XOR EAX,EAX
MOV DR6,EAX
MOV EAX,DR7
XOR EBX,EBX
MOV CX,4
Debug1:MOV BP,CX
DEC BP
BT DX,BP
JNC Debug2
XOR BX,BX
ADD BP,BP
INC BP
BTS BX,BP
DEC BP
BTS BX,BP
TEST AX,BX
JZ Debug2
XOR BX,BX
ADD BP,BP
INC BP
BTS BX,BP
DEC BP
BTS BX,BP
SHL EBX,16
TEST EAX,EBX
JNZ Debug3
JMP SHORT Debug5
Debug2:LOOP Debug1
BT DX,14
JNC Debug4
BTR WORD PTR [ESP + 4 * 8 + 2 + 4],8
Debug3:POP ES
POPAD
IRET
Debug4:BT DX,13
JNC Debug3
Debug5:POP ES
POPAD
SUB ESP,6
PUSH EAX
MOV AX,[ESP+10]
MOVZX EAX,AX
MOV [ESP+4],EAX
MOV AX,[ESP+12]
MOV [ESP+8],EAX
PUSHFD
POP EAX
MOV AX,[ESP+14]
MOV [ESP+12],EAX
BTS DWORD PTR [ESP+12],16
POP EAX
IRETD
ECHOB:MOV AH,COLOR
MOV CX,16
ECHOB1:ROL DX,1
SETC AL
ADD AL,'0'
STOSW
LOOP ECHOB1
RET
CSEGD ENDS
CSEGM SEGMENT PARA USE16
ASSUME CS:CSEGM
VARA DW 0
VARB DW 4
VARC DW 0
VARD DB 0
BREAKD LABEL BYTE
VARE DD 0
Begin:XOR AX,AX
MOV FS,AX
MOV AX,CSEGD
SHL EAX,16
MOV AX,OFFSET Debug
XCHG FS:[1 * 4],EAX
MOV ESI,EAX
Step1:PUSHF
BTS WORD PTR [ESP],8
POPF
MOV EAX,1
Step2:MOV EAX,DR7
BTS EAX,13
MOV DR7,EAX
MOV EAX,2
MOV EAX,DR3
Step3:MOV AX,CS
MOVZX EAX,AX
SHL EAX,4
MOV EBX,OFFSET BRK0
XADD EAX,EBX
MOV DR0,EAX
XOR EDX,EDX
BTS EDX,0
MOV EAX,OFFSET BREAKD
ADD EAX,EBX
MOV DR2,EAX
BTS EDX,4
BTS EDX,24
BTS EDX,25
BTS EDX,26
BTS EDX,27
MOV DR3,EAX
BTS EDX,7
BTS EDX,28
BTS EDX,30
MOV DR7,EDX
Step4:MOV EAX,3
BRK0:MOV EAX,0
Step5:MOV EAX,DWORD PTR CS:VARB
Step6:PUSH CS
POP DS
MOV EAX,5
MOV WORD PTR VARD,AX
Step7:XOR EAX,EAX
MOV DR7,EAX
Over:MOV FS:[1 * 4],ESI
MOV AH,4CH
INT 21H
CSEGM ENDS
END Begin
在XP下使用tasm t471.asm编译，tlink /3 t471.obj链接
在DOS下运行t471.exe，1次单步陷阱、1次访问调试寄存器故障、1次指令执行断点、1次读数据断点、1次写数据断点。
异常1处理程序的相应输出保存在t471_1.jpg、t471_2.jpg、t471_3.jpg、t471_4.jpg、t471_5.jpg
11.3Pentium程序设计基础
Pentium是继80486之后的新一代微处理器，它保持与先前各代微处理器百分之百二进制兼容。它不仅采用更先进的技术实现先前微处理器的功能，而且增加了许多新功能，
因此它的性能要大大优于80486。Pentium实现超标量体系结构，支持分别称为U和V的两条流水线，理想情况下，在一个时钟周期内可以执行两条指令。
Pentium通过在片内的分支目标缓冲器（BTB），实现动态分支预测，有效地提高分支处理执行速度。
Pentium增加了片上超高速缓存的容量，8K字节用于数据，8K字节用于代码。此外，Pentium还实现了流水线浮点部件，加强了错误检测和报告功能，
完善和扩充了虚拟8086模式，提供多处理器支持。
我们在先前各章节介绍的内容几乎都适用于Pentium。本节从程序设计的角度简单介绍Pentium新增、扩充或改进的内容。
11.3.1寄存器
Pentium维持80486绝大部分寄存器的作用和使用方法。但新增了若干Pentium模型专用寄存器，这些模型专用寄存器主要用于系统测试和运行性能检测。
把它们称为模型专用寄存器的原因是它们与处理器关系密切，可能在以后的处理器中不会以相同的方法继续使用。
80486所含的测试寄存器的功能，在Pentium上由模型专用寄存器实现。
1.基本结构寄存器及其标志寄存器
Pentium的8个32位的通用寄存器与80386相同，6个段寄存器也与80386相同，指令指针也与80386相同。请参见图9.1。
31         22  21  20 19   18   17   16  15  14  13 12   11   10  9  8    7   6   5  4   3  2   1  0
                   I    V    V    AC  VM  RF  0   NT  IOPL    OF  DF IF TF  SF ZF  0 AF 0  PF     CF
                  D     I   I
                        P   F
Pentium的标志寄存器EFlAGS仍是32位，如图11.6所示。与图11.1所示的80486标志寄存器相比，Pentium的标志寄存器新增了三个标志：虚拟中断标志VIF、
虚拟中断挂起标志VIP和标识标志ID。其他标志位的位置及意义保持与80486相同。
虚拟中断标志VIF占用标志寄存器的位19。当允许虚拟8086方式扩充或者允许保护方式虚拟中断时，VIF是中断标志的虚拟映象。
当禁止虚拟8086方式扩充和禁止保护方式虚拟中断时，VIF被强制为0。
虚拟中断挂起标志VIP占用标志寄存器的位20。当允许虚拟8086方式扩充或者允许保护方式虚拟中断时，VIP指示虚拟中断是否挂起。
当禁止虚拟8086方式扩充和禁止保护方式虚拟中断时，VIP被强制为0。
标识标志ID占用标志寄存器的位21。如果可以设置或清除该标志，那么表示处理器支持CPUID指令。利用该指令可获得处理器类型等信息。请参见T11-3.ASM。
2.系统级寄存器及控制寄存器
Pentium的系统地址寄存器（全局描述符表寄存器GDTR、局部描述符表寄存器LDTR、中断描述符表寄存器IDTR和任务状态段寄存器TR）与80386的系统地址寄存器相同。
请参见图10.9。
Pentium支持4个控制寄存器CR0、CR2、CR3和CR4。与80486相比，多了CR4。
       31  30  29  28                     19 18 17 16 15        11                5    4   3   2    1     0
CR0 PG CD NW 0 0 0 0 0 0 0 0 0 0 AM 0 WP 0 0 0 0  0 0 0 0  0 0 NE ET TS EM MP PE
CR1 保留
CR2 页故障线性地址
       31  30  29  28                     19 18 17 16 15        11                      4   3     2   1   0
CR3 页目录表物理页码                                               0 0 0 0 0 0 0    PCD PWT  0  0  0
CR4                                                  M      P   D        T   P   V
                                                        C       S   E         S   V   M
                                                        E       E              D   I   E
31                  12   11   10   9   8   7   6   5   4   3         2   1   0
      物理页码          AVL           0   0   D   A  PCD PWT   U   R   P
                                                                                  S   W
控制寄存器CR0各位的安排与80486相同，如图11.2所示，但其中的CD位和NW位重新定义了片上超高速数据缓存的工作方式。请参见11.3.4节关于片上超高速缓存的说明。
控制寄存器CR2用于指示引起页面故障的线性地址，这与80486相同。
控制寄存器CR3高20位含有页目录表所在物理页的页码，低12位中定义了控制位PCD和PWT。这与80486相同，如图11.3所示。
CR4是Pentium新增的控制寄存器，其各位的定义如图11.7所示。
位2是读时间标记计数器指令RDTSC使用控制位TSD。当TSD为0时，可在任一特权级上执行读时间标记计数器指令RDTSC。
当TSD为1时，只有在当前特权级为0时，可执行指令RDTSC，否则将导致出错码为0的通用保护异常。
RESET后，TSD为0，任一特权级执行的程序都可使用指令RDTSC，读取时间标记计数器。
位3是调试扩充控制位DE。当DE为0时，禁止调试扩充，也即不支持I/O断点。当DE为1时，允许调试扩充，也即支持I/O断点。
RESET后，DE为0，禁止调试扩充，这样Pentium就保持80486原有调试功能。请参见下面关于调试寄存器的说明。
位0是虚拟8086方式扩充控制位VME。当VME为0时，禁止虚拟8086方式扩充。位1是保护方式虚拟中断控制位PVI。
当PVI为0时，禁止保护方式虚拟中断。位4是页面大小扩充控制位PSE。
当PSE为0时，禁止页面大小扩充。位6是机器检查异常控制位MCE。
当MCE为0时，禁止机器检查异常。在RESET后，这些控制位都是0，从而保持与80486相一致。
3.调试寄存器
Pentium不仅支持如图11.5所示的调试寄存器，而且调试功能还有所扩充。Pentium所支持的调试功能扩充是指支持I/O断点。
80486调试控制寄存器DR7中的各断点类型说明字段RWEi尽管是2位，但该字段取值“10”的情况被保留。
在允许调试扩充时，Pentium调试控制寄存器DR7中的各断点类型说明字段RWEi，可以取值“10”，所表示的断点条件是I/O端口读或者写。
表11.4 RWE字段说明的断点类型
RWE字段取值         断点类型(断点条件)         RWE字段取值         断点类型(断点条件)
0 0                        只执行                          1 0                        读写I/O端口
0 1                        只写入数据                    1 1                        只读或写数据
在允许调试扩充时，表11.2所列出的断点类型扩充为表11.4所列的断点类型。对应的断点地址寄存器内存放的是扩展成32位的I/O端口地址。
控制寄存器CR4中的DE位决定是否允许调试功能扩充。当DE为1时，允许调试功能扩充。
11.3.2指令系统
Pentium指令集应该说是80486指令集的超集。由于在Pentium中测试寄存器归属于Pentium模型专用寄存器，所以Pentium不再支持测试寄存器数据传送指令。
除此之外，Pentium支持其他80486的全部指令，并保持与80486兼容。与80486相比，Pentium还新增了几条指令。
但某些新增的指令是否有效与Pentium的型号有关，可利用处理器特征识别指令CPUID判别处理器是否支持某些新增指令。
Pentium支持控制寄存器CR4，所以Pentium的控制寄存器传送指令的操作数还可以是控制寄存器CR4。Pentium还提供从系统管理方式返回的指令RSM。
1.8字节比较交换指令
CMPXCHG8B
8字节比较交换指令的格式如下：
CMPXCHG8B OPRD
其中操作数OPRD是64位存储器操作数。该指令的功能是把EDX:EAX内的64位值与存储器操作数OPRD相比较，
如果相等，把ECX:EBX内的64位值存入存储器操作数OPRD；如果不等，把存储器操作数OPRD内的64位值装入EDX:EAX。
EDX和ECX分别是64位值的高32位。
例如：
CMPXCHG8B [BX]
CMPXCHG8B [EDX]
如果EDX:EAX的值与存储器操作数OPRD的值相等，那么置ZF，否则清ZF。该指令不影响其他标志。
在加上LOCK前缀后，该指令对多处理器情况下的信号量操作有用。
2.处理器特征识别指令CPUID
处理器特征识别指令的一般格式如下：
CPUID
利用该指令能够方便地获得包括处理器类型在内的若干处理器特征信息。CPUID指令返回由EAX指定的某方面的处理器特征信息。
表11.5 CPUID返回的特征信息
参数                  CPUID返回信息
EAX=0              EAX=最大值 EBX:EDX:ECX=厂商识别标识串
EAX=1              EAX=CPU说明信息 EDX=特征标志字
1<EAX<=最大值 可能在未来的处理器中定义
EAX>最大值      未定义
表11.5列出了指令CPUID根据EAX返回特征信息的定义。在Pentium第1型中，指令参数可取的最大值是1。在新一代处理器中，可能提供更丰富的特征信息。
例如，如下指令可取得最大特征参数值和厂商识别标识串：
MOV EAX,0
CPUID
Pentium处理器的厂商识别标识串是“Genuine Intel”。
关于由EAX返回的CPU说明信息和由EDX返回的特征标志字的格式及说明请参见11.3.3节。该指令不影响各标志。
从后期的80486开始，就支持该指令。软件可通过判断标志寄存器中的ID位是否可设置和清除来判断处理器是否支持该指令。如果ID可设置和清除，那么可使用CPUID指令。
3.读时间标记计数器指令RDTSC
Pentium含有一个64位的时间标记计数器。该计数器随每一时钟周期递增。在RESET后，该计数器被清0。利用该计数器可检测程序运行性能。
读时间标记计数器指令的一般格式如下：
RDTSC
该指令把时间标记计数器的高32位复制到EDX，把低32位复制到EAX。
控制寄存器CR4的TSD位限制该指令的使用。当TSD为0时，可在任一特权级上执行RDTSC指令。当TSD为1时，只有当特权级为0时，可执行RDTSC指令，
否则将导致出错码为0的通用保护异常。
该指令不影响各标志。
4.读模型专用寄存器指令RDMSR
读模型专用寄存器指令的一般格式如下：
RDMSR
该指令把由ECX寄存器指定的模型专用寄存器的内容送到EDX:EAX，EDX含高32位，EAX含低32位。如果所指定的模型寄存器不足64位，那么在EDX:EAX中的对应位未定义。
Pentium提供一组模型专用寄存器，在利用RDMSR读某个模型专用寄存器时，必须先把欲读模型专用寄存器的编号送到ECX寄存器。
如果在ECX中指定的编号未定义或被保留，将导致通用保护异常。
该指令不影响各标志。
该指令只能在实方式或者保护方式的特权级0下执行，否则将导致通用保护异常。
在使用该指令前，应该利用CPUID指令取得处理器特征标志字，以判别是否可使用该指令，否则可能导致无效操作码异常。
Pentium的上述时间标记计数器是模型专用寄存器之一。利用访问模型专用寄存器的指令也可读取时间标记计数器值。但不提倡应用程序通过RDMSR指令读取时间标记计数器。
5.写模型专用寄存器指令WRMSR
写模型专用寄存器指令的一般格式如下：
WRMSR
该指令把EDX:EAX的内容送到由ECX寄存器指定的模型专用寄存器，EDX送到高32位，EAX送到低32位。如果指定的模型寄存器有未定义的或者被保留的位，
那么这些位的内容不变。象利用RDMSR指令读模型专用寄存器那样，如果在ECX中指定的编号未定义或被保留，将导致通用保护异常。
该指令不影响各标志。
该指令只能在实方式或者保护方式的特权级0下执行，否则将导致通用保护异常。
在使用该指令前，应该利用CPUID指令取得处理器特征标志字，以判别是否可使用该指令，否则可能导致无效操作码异常。
系统程序利用WRMSR指令可设置上述时间标记计数器。
.8086 仅接受8086指令（默认状态）
.186 接受80186指令
.286 接受除特权指令外的80286指令
.286P 接受全部80286指令，包括特权指令
.386 接受除特权指令外的80386指令
.386P 接受全部80386指令，包括特权指令
.486 接受除特权指令外的80486指令，包括浮点指令
.486P 接受全部80486指令，包括特权指令和浮点指令
.8087 接受8087数学协处理器指令
.287 接受80287数学协处理器指令
.387 接受80387数学协处理器指令
.No87 取消使用协处理器指令
.586 接受除特权指令外的Pentium指令
.586P 接受全部Pentium指令
.686 接受除特权指令外的Pentium Pro指令
.686P 接受全部Pentium Pro指令
.MMX 接受MMX指令
.K3D 接受AMD处理器的3D指令
.XMM 接受SSE，SSE2和SSE3指令
注：.586 / .586P由MASM6.11引入；.686 / .686P / .MMX由MASM6.12引入；.K3D由MASM6.13引入；
.XMM由MASM6.14引入，MASM6.15支持SSE2指令，MASM8.0支持SSE3指令。
另外，书写.386及以后的处理器选择伪指令需要留心其位置，如果书写在存储模型.MODEL指令之后，
该程序将默认采用实方式和虚拟方式使用的16位段（默认是16位地址 和操作数长度）；
如果书写在存储模型.MODEL指令之前，该程序将默认采用保护方式使用 的32位段（默认是32位地址和操作数长度）。
Turbo Assembler  Version 5.2  Copyright (c) 1988, 1999 Inprise Corporation
(From  C++Builder 4)

Added new directive    ".686" ,".686P"
Added new directive    ".MMX"                (but ".XMM" not suppotred...)
TASM 5.3 was bundled with C++Builder 5 and fixed a few more bugs
6.用宏定义新增指令
低版的汇编器不识别Pentium的新增指令。可利用如下定义的宏来使用这些新增指令。
；文件名：PENTIUM.INC
；包含为Pentium新增指令定义的宏
可以使用TASM 5.3对应的tasm32.exe，并且在源程序文件中使用.686P表示接受全部Pentium Pro指令
11.3.3处理器的识别
随着处理器不断升级换代，处理器的功能越来越强，80x86系列新型号处理器具有老型号处理器的功能。
通常，在老型号处理器上可运行的程序，在新型号处理器上也可运行。这称为向前兼容，或者称为向上兼容。
另一方面，程序只有利用处理器提供的新特性，才能充分发挥处理器的能力。所以，一个良好的程序应该能够根据不同的处理器采取不同的方法，实现相同的功能。
那么如何识别处理器型号（类型）呢？对前几代处理器的识别，可通过判断标志寄存器中某些标志位的设置情况来进行。
从后期的80486开始，处理器提供了处理器特征识别指令CPUID，利用该指令可方便地获得处理器特征信息。
1.处理器说明信息和特征标志字
如果处理器支持CPUID指令，那么利用如下指令可取得CPU说明信息和特征标志字：
MOV EAX,1
CPUID
执行上述指令后，EAX含有CPU说明信息，EDX含有特征标志字。
CPU说明信息的格式如图11.8所示。
31                  14   13   12   11         8   7         4   3         0
保留                       类别      家族代号    型号         系列号
类别字段（Processor Type）占用2位，说明处理器的种类信息。
家族代号（Family）字段占用4位，80486处理器该字段值是4，Pentium处理器该字段值是5，Pentium Pro处理器该字段值是6。
型号（Model）字段占用4位，反映型号值。系列号（Stepping ID）字段占用4位。
特征标志字的每一位可用于指示一个特性是否存在。Pentium特征标志字中的基本特征标志如下：
位0是片上浮点处理单元特征位FPU。该位为1表示处理器含有浮点处理单元，可执行387指令集中的浮点处理指令。
位1是虚拟8086方式扩充特征位VME。该位为1表示处理器支持虚拟8086方式扩充，这种情况下，控制寄存器CR4中的VME位可以控制虚拟8086方式扩充是否允许；
PVI位可以控制保护方式虚拟中断；TSS可以支持软件间接位图；标志寄存器中的VIF和VIP标志位有效。
位2是调试功能扩充特征位DE。该位为1表示处理器支持调试功能扩充，这种情况下，控制寄存器CR4中的DE位可以控制调试功能扩充是否允许，也即l/O断点是否允许。
位3是页面大小扩充特征位PSE。该位为1表示处理器支持页面大小扩充，这种情况下，控制寄存器CR4中的PSE位可以控制页面大小扩充是否允许。
位4是时间标记计数器特征位TSC。该位为1表示处理器支持读时间标志计数器指令RDTSC，控制寄存器CR4中的TSD位才可以控制允许使用RDTSC指令的特权级。
位5是模型专用寄存器特征位MSR。该位为1表示处理器支持读和写模型专用寄存器指令RDMSR和WRMSR。
位7是机器检查异常特征位MCE。该位为1表示处理器支持控制寄存器CR4中的MCE位，MCE位可以控制是否允许机器检查异常。
位8是CMPXCHG8B指令特征位CX8。该位为1表示处理器支持8字节比较交换指令CMPXCHG8B。
位9是特征标志位APIC。该位为1表示处理器含有高级可编程中断控制器APIC，并可以使用APIC。
位23是特征标志位MMX。该位为1表示处理器支持MMX指令集。
31         22  21  20 19   18   17   16  15  14  13 12   11   10  9  8    7   6   5  4   3  2   1  0
                   I    V    V    AC  VM  RF  0   NT  IOPL    OF  DF IF TF  SF ZF  0 AF 0  PF     CF
                  D     I   I
                        P   F
2.识别处理器类型的实例
下面给出一个识别处理类型的实例。
该实例通过判别标志寄存器中有关标志位区分8086、80286、80386和80486，在确定处理器至少是80486之后，
根据判别ID标志来判断是否可执行处理器特征识别指令CPUID，Pentium总是支持CPUID的。
如果可以执行CPUID指令，那么利用该指令进一步获取处理器的特征信息。但该实例没有识别浮点处理部件。
；程序名：T11-3.ASM
；功能：识别处理器类型（没有显示功能）
；说明：该实例应在实方式下执行
.686P
CSEG SEGMENT USE16
ASSUME CS:CSEG,DS:CSEG
CPUTYPE DB ?
CPUIDF DB 0
INTELF DB 0
FAMILY DB 0
CMODEL DB 0
STEPID DB 0
PROPF DD 0
GetCPUID PROC
Check8086:PUSHF
POP AX
AND AX,0FFFH
PUSH AX
POPF
PUSHF
POP AX
AND AX,0F000H
CMP AX,0F000H
MOV BYTE PTR CPUTYPE,0
JNZ SHORT Check286
MOV AX,0
MOV AL,CPUTYPE
CALL ECHOAX
CALL NEWLINE
RET
Check286:PUSHF
POP AX
OR AX,3000H
PUSH AX
POPF
PUSHF
POP AX
TEST AX,3000H
MOV BYTE PTR CPUTYPE,2
JNZ SHORT Check386
MOV AX,0
MOV AL,CPUTYPE
CALL ECHOAX
CALL NEWLINE
RET
Check386:MOV BP,SP
AND SP,NOT 3
PUSHFD
POP EAX
MOV EDX,EAX
BTS EAX,18
PUSH EAX
POPFD
PUSHFD
POP EAX
BT EAX,18
JC SHORT A386
MOV BYTE PTR CPUTYPE,3
MOV SP,BP
MOV AX,0
MOV AL,CPUTYPE
CALL ECHOAX
CALL NEWLINE
RET
A386:PUSH EDX
POPFD
MOV SP,BP
Check486:MOV EAX,EDX
BTS EAX,21
PUSH EAX
POPFD
PUSHFD
POP EAX
PUSH EDX
POPFD
BT EAX,21
MOV BYTE PTR CPUTYPE,4
JNC SHORT IDOK
AE486:MOV BYTE PTR CPUIDF,1
XOR EAX,EAX
CPUID
CMP EBX,"uneG"
JNE SHORT IDOK
CMP EDX,"Ieni"
JNE SHORT IDOK
CMP ECX,"letn"
JNE SHORT IDOK
YINTEL:MOV BYTE PTR INTELF,1
CMP EAX,1
JB SHORT IDOK
MOV EAX,1
CPUID
MOV PROPF,EDX
MOV BL,AL
AND AX,0F0FH
MOV STEPID,AL
MOV FAMILY,AH
SHR BL,4
MOV CMODEL,BL
MOV CPUTYPE,AH
IDOK:MOV AX,0
MOV AL,CPUTYPE
CALL ECHOAX
CALL NEWLINE
RET
GetCPUID ENDP
Begin:PUSH CS
POP DS
CALL GetCPUID
MOV AH,4CH
INT 21H
ECHOAX PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV DX,AX
MOV CX,4
ECHOAX1:ROL DX,4
MOV AL,DL
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
MOV BH,0
MOV AH,0EH
INT 10H
LOOP ECHOAX1
POP DX
POP CX
POP BX
POP AX
RET
ECHOAX ENDP
NEWLINE PROC NEAR
PUSH AX
PUSH BX
MOV BH,0
MOV AL,0DH
MOV AH,0EH
INT 10H
MOV AL,0AH
MOV AH,0EH
INT 10H
POP BX
POP AX
RET
NEWLINE ENDP
CSEG ENDS
END Begin
在XP下使用tasm32 t472.asm编译，tlink t472.obj链接
在DOS下运行t472.exe
c:\tasm16\t472.exe
0006
为了简单，上述实例没有提供显示输出功能。读者可完善该实例，使其能够显示输出处理器类型信息和有关特征信息。
11.3.4片上超高速缓存
Pentium在片上包含了独立的指令（代码）和数据超高速缓存器，分别为8K字节。指令和数据超高速缓存可以同时被访问。
可以利用软件和硬件的方法控制片上超高速缓存的工作方式，也可以利用软件和硬件的方法控制可被超高速缓存的内存区域。
为了适应多处理器环境的需要，对于数据超高速缓存，采用一种称为MESI的协议，保持超高速缓存数据一致；
对于指令超高速缓存，则采用MESI协议的子集SI来保持一致。
下面简单介绍Pentium片上超高速缓存的组织。尽管可以认为超高速缓存器是透明的，但事实上了解它的组织对编写高效的程序有益。
                  Way0                          Way1         
index 127 16 bytes    16 bytes     16 bytes     16 bytes
index 126 16 bytes    16 bytes     16 bytes     16 bytes
index 125 16 bytes    16 bytes     16 bytes     16 bytes
index ...
index 3 16 bytes    16 bytes     16 bytes     16 bytes
index 2 16 bytes    16 bytes     16 bytes     16 bytes
index 1 16 bytes    16 bytes     16 bytes     16 bytes
index 0 16 bytes    16 bytes     16 bytes     16 bytes
1.片上超高速缓存及其工作方式的控制
Pentium片上的数据超高速缓存和指令超高速缓存的容量皆为8K字节，而且都采用二路组相关联结构。每个超高速缓存有128组，每组2行。每行32字节宽。
每个超高速缓存都使用物理地址来访问，并且每个超高速缓存都有自己的TLB将线性地址转换为物理地址。
数据超高速缓存由在4字节边界处交错的8个体构成。它在同一个时钟内可以支持两次数据访问。在两条流水线中执行的指令可以同时访同数据超高速缓存，
但如果访问对同一个体进行，那么会有延时。Pentium的数据超高速缓存是一种回写式超高速缓存，填充和替换以行为单位进行。
每一行有用于支持MESI协议的两位相关联，可表示4种状态：M状态（Modified）、E状态（Exclusive）、S状态（Shared）和I状态（Invalid）。
另外，每一行还有用于记录最近最少使用情况的LRU位相关联。
指令超高速缓存在一个时钟内可提供多达32字节的原始代码。由于指令超高速缓存无需回写，所以每一行有用于支持SI协议的一位相关联，可表示S和I这2种状态。
每一行也有用于记录最近最少使用情况的LRU位相关联。
控制寄存器CR0中的CD位和NW位可控制片上超高速缓存的工作方式，它们定义的工作方式如表11.6所列。
表11.6控制超高速缓存工作方式的CD和NW位的说明
CD                  NW                  说明
0                  0                         读命中访问超高速缓存
                                              读未命中可能引起置换
                                              写命中更新超高速缓存
                                              仅在写到共享行和写未命中时向外写出
                                              在WB/WT#引脚控制下，写命中能把共享行变换到互斥状态
                                              允许使无效
0                  1                        无效组合，导致出错码为0的通用保护故障
1                  0                        读命中访问超高速缓存
                                              读未命中不引起置换
                                              写命中更新超高速缓存
                                              仅在写到共享行和写未命中时更新存储器单元
                                              在WB/WT#引脚控制下，写命中能把共享行变换到互斥状态
                                             允许使无效
1                  1                        读命中访问超高速缓存
                                             读未命中不引起置换
                                             写命中更新超高速缓存，但不更新存储器单元
                                             写命中将使互斥状态行变换到已修改状态
                                             共享行在写命中后保留共享状态
                                             写未命中访问存储器单元
                                             禁止使无效
       31  30  29  28                     19 18 17 16 15        11                5    4   3   2    1     0
CR0 PG CD NW 0 0 0 0 0 0 0 0 0 0 AM 0 WP 0 0 0 0  0 0 0 0  0 0 NE ET TS EM MP PE
CR1 保留
CR2 页故障线性地址
       31  30  29  28                     19 18 17 16 15        11                      4   3     2   1   0
CR3 页目录表物理页码                                               0 0 0 0 0 0 0    PCD PWT  0  0  0
CR4                                                  M      P   D        T   P   V
                                                        C       S   E         S   V   M
                                                        E       E              D   I   E
31                  12   11   10   9   8   7   6   5   4   3         2   1   0
      物理页码          AVL           0   0   D   A  PCD PWT   U   R   P
                                                                                  S   W
由于Pentium的超高速缓存支持回写方式，所以与80486相比，这两个控制位的定义有所不同。
CD=0和NW=0能使片上超高速缓存发挥最高性能。把CD和NW置1能禁止超高速缓存，但为了完全禁止超高速缓存，在把CD和NW置1后，还应该清洗超高速缓存。
在RESET后，CD=1和NW=1。
RDTSC
该指令把时间标记计数器的高32位复制到EDX，把低32位复制到EAX。
2.演示片上超高速缓存作用的实例
下面给出一个演示程序，该程序演示片上指令超高速缓存和数据超高速缓存如何提高处理性能。
演示程序含有以循环方式访问某些存储单元的两个测试子程序，测试子程序能测定运行所耗时钟数。
演示程序在禁止和允许超高速缓存两种情况下，分别调用测试子程序1，然后在允许超高速缓存的情况下再调用子程序2，最后分别显示所用时钟数。
该演示程序在Pentium实方式下运行。
源程序清单如下：
；程序名：T11-4.ASM
；功能：演示Pentium片上高速缓存的作用
；说明：仅在Pentium的实方式下运行
CDBIT = 30
COUNTV = 10
.686P
DSEG SEGMENT PARA USE16
Mess1 DB 'Clock1:$'
Mess2 DB 'Clock2:$'
Mess3 DB 'Clock3:$'
COUNT1 DD ?
COUNT2 DD ?
COUNT3 DD ?
DSEG ENDS
CSEG SEGMENT PARA USE16
ASSUME CS:CSEG,DS:DSEG
BEGIN:MOV AX,DSEG
MOV DS,AX
Step1:CLI
MOV EAX,CR0
BTS EAX,CDBIT
MOV CR0,EAX
WBINVD
CALL Access1
STI
MOV COUNT1,EAX
Step2:CLI
MOV EAX,CR0
BTR EAX,CDBIT
MOV CR0,EAX
WBINVD
CALL Access1
STI
MOV COUNT2,EAX
Step3:CLI
WBINVD
CALL Access2
STI
MOV COUNT3,EAX
Step4:MOV DX,OFFSET Mess1
MOV ECX,COUNT1
CALL DMESS
MOV DX,OFFSET Mess2
MOV ECX,COUNT2
CALL DMESS
MOV DX,OFFSET Mess3
MOV ECX,COUNT3
CALL DMESS
MOV AX,4C00H
INT 21H
Access1 PROC
MOV CX,COUNTV
MOV EBX,1024
RDTSC
MOV ESI,EDX
MOV EDI,EAX
ACC1:MOV EAX,[EBX]
MOV EAX,[EBX + 1024 * 4]
MOV EAX,[EBX + 1024 * 2]
MOV EAX,[EBX + 1024 * 6]
LOOP ACC1
RDTSC
SUB EAX,EDI
SBB EDX,ESI
RET
Access1 ENDP
Access2 PROC
MOV CX,COUNTV
MOV EBX,1024
RDTSC
MOV ESI,EDX
MOV EDI,EAX
ACC2:MOV EAX,[EBX]
MOV EAX,[EBX + 1024 * 4]
MOV EAX,[EBX + 1024 * 8]
MOV EAX,[EBX + 1024 * 12]
LOOP ACC2
RDTSC
SUB EAX,EDI
SBB EDX,ESI
RET
Access2 ENDP
DMESS PROC
MOV AH,9
INT 21H
SHLD EDX,ECX,16
DMESS1:MOV AX,DX
CALL ECHOAX
MOV AX,CX
CALL ECHOAX
CALL NEWLINE
RET
DMESS ENDP
ECHOAX PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV DX,AX
MOV CX,4
ECHOAX1:ROL DX,4
MOV AL,DL
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
MOV BH,0
MOV AH,0EH
INT 10H
LOOP ECHOAX1
POP DX
POP CX
POP BX
POP AX
RET
ECHOAX ENDP
NEWLINE PROC NEAR
PUSH AX
PUSH BX
MOV BH,0
MOV AL,0DH
MOV AH,0EH
INT 10H
MOV AL,0AH
MOV AH,0EH
INT 10H
POP BX
POP AX
RET
NEWLINE ENDP
CSEG ENDS
END BEGIN
在XP下使用tasm32 t473.asm编译，tlink t473.obj链接
在DOS下运行t473.exe
c:\tasm16\t473.exe
Clock1:00002F00
Clock2:00001AD0
Clock3:00002E20
上述演示程序利用了读时间标记计数器指令RDTSC，在循环开始时读取时间标记值，在循环结束时再读取时间标记值，它们的差可认为是循环所花的时钟数。
11.4基于Pentium的程序优化技术
Pentium处理器具有双整型流水线、指令和数据独立的超高速缓存、动态分支预测机制和流水线浮点处理部件等多种新特性。Pentium的这些新特性能够大大提高处理性能。
尽管这些新特性的实现对程序员而言是透明的，但如果程序员能够在理解这些新特性后注意发挥它们的作用，那么程序运行效率就可更高。
本节简单介绍有助于提高程序执行速度的优化技术，这些优化技术以Pentium处理器为基础，这些技术的实质就是如何较好地利用Pentium的上述新特性。
注意，在Pentium Pro和PentiumⅡ及支持MMX的Pentium上可能略有差异。
本节介绍的例子都假设是在某个32位代码段中的片段。
11.4.1流水线优化技术
Pentium是一个高级的超标量处理器，它拥有两条并行的整型流水线。流水线是指，每条指令的执行过程分成若干阶段，每个阶段都有独立的部件来处理，
当一条指令的某个处理阶段完成后，它就进入到下一处理阶段，而独立的处理部件就可立即处理下一条指令。
采用流水线方式执行指令，能提高指令执行的并行程度，有效地提高机器处理性能。
Pentium的两条流水线能够同时执行指令，所以Pentium最多能在一个时钟内执行两条整型指令。
1.U流水线和V流水线
Pentium的两条流水线分别称为U流水线和V流水线。U流水线是主流水线，它能够执行指令集中的所有指令。V流水线在可执行的指令方面有限制，它只能执行大多数常用指令。
例如，如下程序片段在理想情况下执行时只要花2个时钟：
MOV EAX,EBX 在U流水线执行
MOV EDX,ECX 在V流水线执行
MOV EBX,12345678H 在U流水线执行
MOV CX,[ESI]             在V流水线执行
Pentium的整型流水线含有五步：预取（PreFetch）、译码1（Decode stage1）、译码2（Decode stage2）、执行（Execute）、回写（WriteBack）。
整型指令的执行要经过流水线中这五步。与80486的流水线相比，Pentium的流水线经过了优化，可达到更高的性能。
另一方面，如果要执行的两条指令符合“指令配对规则”能够配对，那么一条指令经由U流水线执行，另一条指令经由V流水线执行。
Pentium处理器以流水线方式执行指令的过程如图11.9所示，其中in表示指令n。
         clk0         clk1         clk2         clk3         clk4         clk5         clk6         clk7
PF      i1            i3             i5            i7
          i2            i4             i6            i8
D1                    i1             i3            i5             i7
                        i2             i4            i6             i8
D2                                   i1            i3             i5              i7
                                       i2             i4             i6             i8
EX                                                  i1              i3             i5             i7
                                                      i2              i4             i6             i8
WB                                                                  i1            i3             i5             i7
                                                                       i2             i4             i6            i8
尽管指令在两条流水线中并行执行，但执行指令的功能与指令顺序执行时是完全一致的。
流水线的第一步是预取（PF），在该阶段，从指令超高速缓存或存储器预取指令。两条流水线的预取阶段是合在一起的，由指令预取器完成。
指令预取器具有两对32字节长的预取缓冲区，一对用于顺序预取，一对用于预测分支执行预取（从分支预测机制预测执行的分支处预取）。
由于Pentium具有独立的指令超高速缓存，所以从超高速缓存预取指令不会与数据访问相冲突。
流水线的第二步是第一阶段译码（D1）。
在该阶段之初，译码器根据指令配对规则判别随后的两条指令是否配对。如果配对，那么把两条指令依次发往U流水线和V流水线；如果不配对，那么仅一条指令交U流水线。
流水线的第三步是第二阶段译码（D2）。在该阶段，计算存储器操作数的有效地址。通常该阶段仅需一个时钟。
流水线的第四步是执行（EX）。在该阶段，进行算术逻辑运算和数据存取访问。因此，那些既要算术逻辑运算，又要数据存取访问的指令在该步中需要花去多个时钟。
例如，指令"ADD [EBX],EAX"就是这样的指令，在该阶段要化3个时钟。
流水线的第五步是回写（WB）。在该阶段，改变处理器状态，最终完成指令的执行。
在依次经过流水线各步的过程中，由于某些情况，指令执行可能被拖延。U流水线和V流水线中的指令一起配对进入和离开D2和EX阶段。
如果在某条流水线中的指令在某阶段被耽搁，那么在另一条流水线中的配对指令也在同一阶段被耽搁，所以U流水线和V流水线中的配对指令同时进入EX阶段。
在EX阶段，如果U流水线中的指令被拖延，那么V流水线中可能有的配对指令也被耽搁；如果V流水线中的指令被拖延，那么U流水线中的配对指令也被耽搁。
只有当处于两条流水线EX阶段的配对指令都到达WB阶段，那么两条流水线上的随后指令才能够进入EX阶段。
在两条流水线并行执行过程中，对存储器的访问仍保持顺序执行时的次序，所以只有在U流水线中的指令完成需要的存储器访问后，
V流水线中可能有的配对指令才能够进行存储器访问，这也可能会导致某些执行被拖延。
2.整型指令配对规则
指令集中的指令根据如何进行流水线配对可分为如下四类：
（1）UV类指令，这类指令既可发到U流水线又可发到V流水线。大多数算术逻辑运算指令、全部比较指令和全部以通用寄存器为操作对象的堆栈操作指令属于UV类指令。
（2）PU类指令，这类指令在配对时只能发到U流水线。有前缀的指令属于PU类指令；带进位或借位操作指令、移位位数由立即数决定的移位指令属于PU类指令。
（3）PV类指令，这类指令在配对时只能发到V流水线。简单控制转移指令（如近调用CALL，近转移JMP，条件转移指令）属于PV类指令。
（4）NP类指令，这类指令不能配对，只能单独在U流水线中执行。移位位数由CL确定的移位指令、乘除指令（如MUL，DIV）、
扩充的指令（如PUSHA，ENTER，MOVS，LOOPNZ，MOVSX）、涉及段寄存器的指令（如远调用指令CALL，PUSH DS）属于NP类指令。
表11.7列出了主要可配对的整型指令，其中U流水线列的指令是在配对时可进入U流水线的指令（即UV类指令和PU类指令），
V流水线列的指令是在配对时可进入V流水线的指令（即UV类指令和PV类指令）。
表中的操作符alu表示算术逻辑运算操作符，shift/rot表示移位或者循环操作符，jcc near表示条件转移指令，0F jcc表示转移范围扩充的条件转移指令，
acc表示累加器，reg和r表示通用寄存器，m表示存储器操作数，r/m表示寄存器操作数或者存储器操作数，imm表示立即操作数。
表11.7整型指令配对
U流水线可配对指令                           V流水线可配对指令
mov r,r alu m,imm push imm          mov r,r alu m,imm push imm
mov r,m alu m,r pop r                     mov r,m alu m,r pop r
mov m,r alu r,m nop                        mov m,r alu r,m jmp near
mov r,imm inc/dec r shift/rot by 1   mov r,imm inc/dec r jcc near
mov m,imm inc/dec m shift by imm mov m,imm inc/dec m call near
alu r,r lea r,m test reg,r/m                 alu r,r lea r,m 0F jcc
alu r,imm push r test acc,imm           alu r,imm push r nop
                                                                          test reg,r/m test acc,imm
整型指令配对的基本规则（必要条件）如下：
（1）配对的两条指令都不能是NP类指令，前一条指令不能是PV类指令，后一条指令不能是PU类指令。
（2）配对的两条指令必须已在指令超高速缓存中，而且已执行过。但如果前一条指令是单字节指令，那么该指令不受该项约束。例如，指令“PUSH EAX”就是单字节指令。
（3）除某些特别的配对指令外，配对的指令之间不能有隐式或显式的寄存器争用。稍后再介绍寄存器争用的概念和如何避免寄存器争用。
（4）如果指令的一个操作数由立即寻址方式确定，并且另一个操作数的寻址方式中使用了相对偏移，那么这样的指令不能参与配对。
立即数和地址偏移可能是8位、16位或者32位。例如，指令"MOV BYTE PTR [EBX+1],12"，不能参与配对，属于NP类指令。
所以，如果要多次使用某个立即数，那么可先将其装入某个通用寄存器。
（5）指令基本长度（不包括前缀）超过7字节的指令不能参与配对。
如果随后的两条指令能够配对，那么前一条指令发到U流水线执行，后一条指令发到V流水线执行；
如果不能配对，那么只有前一条指令发到U流水线执行，后一条指令将作为下次配对的前一条指令。
例如，设某个程序片段中的指令分类情况是：PV1、PU2、PU3、UV4和NP5，并设这5条指令不受上述规则其他条款的限制，那么流水线配对情况如下：
PV1指令没有配对进入U流水线；PU2没有配对进入U流水线；PU3和UV4配对，PU3进入U流水线，UV4进入V流水线；NP没有配对，进入U流水线。
那么，如何提高配对机会？如何减少指令在流水线中的耽搁时间呢？下面就简单介绍这方面的技巧和方法。
3.减少寄存器争用
数据相关能够导致寄存器争用。除某些特别的配对外，如果前后指令之间发生寄存器争用，那么就不能配对。
显然，减少寄存器争用可提高配对机会。下列情况被视为寄存器争用：
（1）当前一条指令以某个寄存器为目标写，而后一条指令要引用该寄存器，就引起寄存器争用。例如：
MOV EAX,8
MOV EBX,EAX
（2）当前后两条指令都以某个寄存器为目标写，也引起寄存器争用。例如：
MOV EAX,[EBX]
ADD EAX,5
在判定寄存器争用时，访问32位寄存器的部分（字节或者字）被认为是对32位寄存器的访问。
例如，如下两条指令被认为是争用寄存器EAX：
MOV AL,0
MOV AH,1
但是，由于改变标志而影响标志寄存器，不认为是对标志寄存器的争用。
另外，如果前一条指令以某个寄存器为源读，而后一条指令以该寄存器为目标写，这种情况不认为是寄存器争用。例如：
MOV EAX,EBX
MOV EBX,ECX
为了提高可配对的机会，Pentium对某些寄存器争用情况作了特殊处理，把这些经特殊处理的争用配对称为特别配对。
特别配对主要涉及隐式读写堆栈指针寄存器ESP或者隐式写标志寄存器。如下指令对是特别配对的（以行为单位）：
PUSH reg/imm   PUSH reg/imm
PUSH reg/imm   CALL
POP reg             POP reg
CMP                   Jcc
ADD                   JNE
减少寄存器争用的一个方法，是在保持程序原有逻辑的前提下调整指令次序。
请考虑如下片段（假设是32位代码段，并且符合其他配对规则）。其中，L1至L4的4条指令争用寄存器ECX，导致它们不能配对；L5至L8的4条指令争用寄存器EDX，
导致它们不能配对；只有L4和L5处的两条指令可配对。
L1：MOV ECX,[EAX+40]
L2：ADD ECX,EBX
L3：AND ECX,0FFFF0000H
L4：MOV [EAX+40],ECX
L5：MOV EDX,[EAX+80]
L6：ADD EDX,EBX
L7：AND EDX,0FFFF0000H
L8：MOV [EAX+80],EDX
现在调整指令次序如下，那么它们就能依次两两配对（假设符合其他配对规则）：
L1：MOV ECX,[EAX+40]
L5：MOV EDX,[EAX+80]
L2：ADD ECX,EBX
L6：ADD EDX,EBX
L3：AND ECX,0FFFF0000H
L7：AND EDX,0FFFF0000H
L4：MOV [EAX+40],ECX
L8：MOV [EAX+80],EDX
充分利用其他暂时不用的通用寄存器，也能够减少寄存器争用。
4.减少地址形成相关现象
在某个通用寄存器作为基址寄存器或者变址寄存器用于计算有效地址时，如果该寄存器又是刚刚执行（发出）指令的目的寄存器，
那么就出现地址形成相关（Address Generate Interlock）。由于在一个时钟内最多可执行两条指令，所以上述“刚刚执行”的指令可能间隔2条指令。
例如，在执行如下两条指令时就会出现地址形成相关（AGI）现象：
MOV EBX,4
MOV ECX,ESI
MOV EAX,[EBX]
当出现地址相关现象时，那么在Pentium流水线的D2阶段会耽搁一个时钟。所以，为了提高流水线的效率，应该减少和避免地址形成相关现象的发生。
与调整指令次序可减少寄存器争用一样，通过调整指令次序的方法也可减少地址形成相关现象的发生。
如下片段中的4条指令都是UV类指令，但由于L4指令把EBX作为基址寄存器，而L1指令以EBX为目标，发生地址形成相关，所以在不考虑其他因素的情况下，执行时要花3个时钟。
L1：ADD EBX,4
L2：MOV EAX,[ESI]
L3：ADD ECX,8
L4：MOV [EBX],EAX
现在调整指令次序如下，避免了地址形成相关现象的发生，执行时只要化2个时钟：
L2：MOV EAX,[ESI]
L3：ADD ECX,8
L4：MOV [EBX+4],EAX 注意该指令增加了相对偏移
L1：ADD EBX,4
5.减少超高速缓存体的冲突
Pentium的数据超高速缓存由8个体构成，每个体宽4字节。它支持在两条流水线中执行的指令可以同时访问。
在两条流水线中执行的配对指令，同时对同一个体的访问称为超高速缓存体冲突。
如果出现超高速缓存体冲突，那么V流水中执行的指令在D2阶段被耽搁一个时钟。
例如，下面片段中的mem表示存储器操作数，L1指令和L2指令配对，被发到U流水线和V流水线并行执行。
但L1指令和L2指令引起超高速缓存体冲突，在V流水线执行的L2指令在D2阶段被耽搁一个时钟。由于配对指令要一起离开D2阶段进入EX阶段，所以执行将被耽搁一个时钟。
L1：MOV ECX,[EBX]
L2：MOV EDX,[EBX+32]
L3：ADD EAX,4
我们同样可采用调整指令次序的方法减少超高速缓存体冲突。
例如，把上面的片段作如下调整，这样，L1指令和L3指令配对，就避免了超高速缓存体冲突：
L1：MOV ECX,[EBX]
L3：ADD EAX,4
L2：MOV EDX,[EBX+32]
6.选择合适的指令
80x86系列处理器的指令集越来越丰富，在实现某个功能时往往有多种选择，现在举例说明如何选择合适的指令，以增加指令配对的机会。
（1）充分利用单字节指令
在指令超高速缓存中的指令才能够配对这条规则有个例外，也即如果前一条指令是单字节指令，那么该指令可不在超高速缓存中。
所以，要多采用单字节指令。请比较如下左右两边的指令（以行位单位）：
XCHG ECX,EBX XCHG EAX,EBX
ADD ESI,1        INC ESI
SUB EDX,1       DEC EDX
（2）考虑使用多条单时钟指令代替一条多时钟指令
所谓单时钟指令是指只要化一个时钟就可执行的指令，许多指令是单时钟指令。
所谓多时钟指令是指执行时要化多个时钟的指令，以存储器操作数为目标操作数的算术逻辑运算指令不是单时钟指令，执行这样的指令往往要化3个时钟。
尽管用多条单时钟指令代替一条多时钟指令一般会增加代码长度，可能还要使用更多的寄存器，但有时用这种方法可增加指令配对机会，提高流水线效率。
例如，如下右边的3条单时钟指令可代替左边的一条3时钟指令：
ADD [EBX],ECX MOV EAX,[EBX]
                         ADD EAX,ECX
                         MOV [EBX],EAX
尽管右边的3条指令之间由于寄存器争用不能配对，但首末2条指令可能和上下指令配对，即使仍不配对都在U流水线执行，也只要花3个时钟。
另外，两条流水线中的指令要同时退出EX阶段，所以某条流水线被耽搁，会影响到另一条流水线；
由于Pentium对存储器的访问仍保持顺序执行时的次序，只有在U流水线中的指令完成需要的存储器访问后，V流水线中可能有的配对指令才能够进行存储器访问。
因此，上述左边指令可能多耽搁流水线超过2个时钟，而右边的片段可避免由于存储访问而耽搁流水线。
如下左边的2条指令用右边6条指令代替后，可收到较好的效果，实际上可避免流水线被耽搁：
INC DWORD PTR [EBX]       MOV ECX,[EBX]
INC DWORD PTR [EBX+4]   MOV EDX,[EBX+4]
                                            INC ECX
                                            INC EDX
                                            MOV [EBX],ECX
                                            MOV [EBX+4],EDX
以存储器操作数为目标操作数的算术逻辑运算指令一般都可采用上述方法。但必须注意，这种方法的代价是增加目标代码长度和占用其他寄存器。
（3）避免使用NP类指令
有某些指令不仅是NP类指令，而且执行时要花多个时钟。为了提高指令配对机会，提高流水线效率，可考虑用多条指令代替它。
这类似于用多条单时钟指令代替一条多时钟指令，这种方法通常会增加目标代码长度。
例如，循环指令LOOP，要花5至8个时钟，而且属于NP类指令。用如下两条指令代替指令LOOP后，可减少分支指令执行时钟，而且增加指令配对机会：
DEC ECX
JNZ NEXT   NEXT是标号
例如，建立堆栈框架指令ENTER，要花10个以上的时钟，而且属于NP类指令。
用如下3条指令代替指令“ENTER BCOUNT,0”后，可提高流水线效率，而且增加指令配对机会：
PUSH EBP
MOV EBP,ESP
SUB ESP,BCOUNT   BCOUNT是常数
CBW 把寄存器AL中的符号扩展到寄存器AH。即若AL的最高有效位为0，则AH=0；若AL的最高有效位为1，则AH=0FFH。
CWD 把寄存器AX中的符号扩展到寄存器DX。即若AX的最高有效位为0，则DX=0；若AX的最高有效位为1，则DX=0FFFFH。
CWDE将16位寄存器AX的符号位扩展到32位寄存器EAX的高16位中。该指令是指令CBW的扩展。
CDQ将寄存器EAX的符号位扩展到EDX的所有位。该指令是指令CWD的扩展。
例如，符号扩展指令CDQ，属于NP类指令。用如下2条指令代替指令CDQ后，可增加指令配对机会。
虽然CDQ指令花2个时钟，如下两条指令也要化2个时钟，但增加了与前后指令的配对机会：
MOV EDX,EAX
SAR EDX,31            该指令属于PU类指令
7.由指令前缀带来的副作用
80x86系列处理器，通过在正常指令之前添加前缀的方法，有效地改变或者扩充了指令原有功能。例如，使用段超越前缀可方便地实现跨段访问；
使用操作数尺寸前缀和地址长度前缀可灵活地实现16位代码和32位代码的混合。可能的前缀有段超越前缀、重复前缀、封锁前缀、
操作数尺寸前缀（66H）、地址长度前缀（67H）和操作码扩充前缀等。
原本属于UV类的指令，由于添加了前缀，只能发到U流水线，也就是说在配对时只能作为PU类指令。
实际上，指令的各个前缀依次都发到U流水线，然后基本指令再参加可能的配对发到U流水线。只有扩充的增加转移范围的条件转移指令所具有的前缀（0FH）是例外。
在16位代码段（实方式下的代码段是16位代码段）中，如果使用32位操作数或者32位地址，那么指令就带有操作数前缀或者地址长度前缀；
在32位代码段中，如果使用16位操作数或者16位地址，那么指令就带有操作数前缀或者地址长度前缀。
因此，要减少16位代码和32位代码的混用，特别是在32位代码段中，要减少使用16位寄存器和减少16位存储器操作数地址。
尽管利用段超越前缀的方法可方便地访问多个段，但这会带来前缀，所以要尽量通过DS访问数据段。
11.4.2分支优化技术
Pentium具有动态分支预测能力。在采用流水线方式执行指令后，如果不能有效地预测分支转移目标，那么转移就会导致流水线被冲洗，严重降低流水线处理效率。
1.动态分支预测
Pentium利用一个称为分支目标缓存器（Branch Target Buffer）的超高速缓存，实现动态分支预测。
分支目标缓存器（BTB）是一个4路组相关联的超高速缓存，共有256项，分为64组，每组4项。访问BTB时使用的标记是分支指令的地址。
BTB项的主要内容是对应位置处转移指令的转移目标地址，该地址就作为预测的转移目标地址。
在流水线的开始阶段对转移指令的转移目标地址进行预测。在流水线的后期阶段，根据实际转移地址修正预测地址。但并非每当根据BTB项作出的预测不正确时，
就一定用实际转移地址来修正预测地址。BTB项除记录转移目标地址外，还有2位用于记录对应转移指令的转移历史信息。
在修正预测地址时，还根据历史信息位作出是否要改变BTB中记录的转移目标地址的判断。
这可避免因一次偶尔的转移变化，导致预测不正确。在连续两次BTB预测不正确的情况下，那么改变BTB中记录的该分支指令转移目标地址。
表11.8列出了对在某个循环中的如下转移指令的动态预测情况，设EBX的初值是26H：
SHR EBX,1   EBX初值是00100110B
JC NEXT
......
NEXT:
......
表11.8对某分支转移指令的动态预测情况
循环序号         转移情况         命中BTB情况         流水线被冲洗情况
1                     否，顺序         0                          0
2                     是，转移         0                          1
3                     是，转移         1                          0
4                     否，顺序         1                          1
5                     否，顺序         1                          1
6                     是，转移         1                          1
7                     否，顺序         1                          1
8                     否，顺序         1                          0
如果BTB已记录了预取的转移指令的转移目标地址，那么Pentium就预测该地址是要转移的目标地址。
如果BTB还没有记录预取转移指令的转移目标地址，也即无法根据BTB作出预测，那么Pentium就预测为不发生转移。
在不是根据BTB作出预测的情况下，如果预测正确，那么不把该顺序地址保存到对应的BTB项；如果预测不正确，那么就把实际转移地址保存到对应的BTB项。
请参见表11.8，最初情况是BTB没有记录预取转移指令的转移目标地址。
如果预测正确，Pentium流水线并未被耽搁；如果预测不正确，那么流水线将被冲洗，为此要耽搁3或4个时钟。
为了提高流水线的效率，应该减少分支转移，提高预测正确程度。下面就简单介绍这方面的技巧和方法。
2.调整基本片段位置
所谓基本片段是指只有一个入口和出口的顺序执行的片段。所谓调整基本片段的位置是指：把使用频率高的基本片段安排在分支转移指令之后的位置处，
也即使得最经常的分支是直行的；把使用频率低的基本片段安排得尽可能离开使用频率高的基本片段。
这样的安排，不仅提高可预测程度，而且可减少把很少执行的代码预取入超高速缓存，还可减少对BTB项的占用。
图11.10给出了一个简单分支所涉及的两个基本片段的调整情况。
         BB1         BB1
         JE L2      JNE L1
L1:   BB2      L2:   BB3
                       JMP L3
L2:   BB3      L1:   BB2
                       JMP L2
                   L3:
设BB3是经常使用的片段，而BB2是不太使用的基本片段。图的左边是调整前的情况，右边是调整后的情况。
尽管调整后的目标代码可能增长，而且还增加了转移指令，但当BB3片段的使用频率明显超过BB2片段使用频率时，调整后的执行效率会较好。
因为，在多数情况下，将直接执行BB3片段。
3.代替条件转移指令
有时可用无分支转移的程序片段代替含分支转移的程序片段，从而消除分支。
有两种常用的代替方法：一种是用条件字节设置指令SETcc代替条件转移指令Jcc；另一种方法是用带进位CF操作的ADC或SBB指令代替条件转移指令Jcc。
如下两个并列的程序片段，完成相同的功能（r3 = r1 AE r2 ? 1 : 0），其中的r1、r2和r3分别表示通用寄存器。
左边的片段含转移指令；右边的片段没有转移指令，效率要高于左边的片段。所以，通常情况下应该使用右边的片段代替左边的片段。
CMP r1,r2   XOR r3,r3
MOV r3,1   CMP r1,r2
JAE NEXT   SETAE r3
MOV r3,0
NEXT:
如下两个并列的程序片段，都能完成更一般化的功能，r3 = r1 cc r2 ? CONST1 : CONST2，
其中的r1、r2和r3分别表示通用寄存器，cc表示条件，CONST1和CONST2分别表示常数。
CMP r1,r2                  XOR r3,r3
MOV r3,CONST1       CMP r1,r2
Jcc NEXT                   SETcc r3L   r3L表示r3低8位寄存器
MOV r3,CONST2       DEC r3
NEXT:                        AND r3,CONST2 - CONST1
                                 ADD r3,CONST1   如CONST1为0，可省
上述左边的片段含有条件转移指令，右边的片段没有转移指令。是否要用右边的片段代替左边的片段，取决于左边片段的平均效率。
如下程序片段是利用带CF位的SBB指令代替条件转移指令的一个例子。
程序片段的功能是根据EAX内容的正负设置EDX的值（正时EDX为0，负时EDX为-1）。右边片段的效率比左边片段的效率要好。
CMP EAX,0         SHL EAX,1
MOV EDX,-1      SBB EDX,EDX
JS NEXT
MOV EDX,0
如下程序片段是利用带CF的ADC指令代替条件转移指令的一个例子。其中，r1，r2，r3是寄存器，CONST是常数。
片段的功能是实现r3 = (r1 ne r2) ? const : 0。但在某个程序中是否要用右边的片段代替左边的片段，要视具体情况而定：
CMP r1,r2                  SUB r1,r2
MOV r3,CONST         CMP r1,1
JNE NEXT                  MOV r3,0
MOV r3,0                  ADC r3,-1
NEXT:                        AND r3,CONST
另一个更一般的例子如下，它们的功能是实现r3 = (r1 e r2) ? CONST1 : CONST2。
CMP r1,r2                  SUB r1,r2
MOV r3,CONST1       CMP rl,1
JE NEXT                    SBB r3,r3
MOV r3,CONST2      AND r3,CONST1 - CONST2
NEXT:                       ADD r3,CONST2
11.4.3超高速缓存优化技术
Pentium的指令超高速缓存和数据超高速缓存是独立的，各有8K字节；都采用二路组相关联结构，都分成128组，每组2行，每行宽32字节；都使用物理地址访问；
都采用最近最少使用淘汰算法。Pentium片上超高速缓存能够支持在一个时钟内进行2次数据访问和获取32字节的原始代码。
但是，如果不能命中片上超高速缓存，那么至少要耽搁3个时钟；如果还没有命中机器系统的2级高速缓存，或者机器没有2级高速缓存，那么要耽搁的时间更多，达7个时钟。
理想情况下，Pentium在7个时钟内可能执行14条指令。所以，根据超高速缓存的特点，安排数据和组织代码对提高程序的效率是极其重要的。
1.对齐访问
尽管Pentium能够存取任何字节边界处的数据，但对数据超高速缓存不对齐的访问要多花3个时钟。所以，应该尽量实现对齐访问。
也就是说，对2字节数据的访问应在2字节边界处进行，至少不跨越4字节边界；对4字节数据的访问应在4字节边界处进行；对8字节数据的访问应在8字节边界处进行。
例如，如下两条指令左边的访问不对齐，右边的访问对齐，设数据已在超高速缓存中，那么左边的不对齐访问要比右边的对齐访问多花3个时钟：
MOV EAX,[0005H] MOV EAX,[0004H]
例如，设EBX的内容是xxxx0H，在不考虑其他因素影响的情况下，那么如下三条指令的访问要比指令“MOV AX,[EBX+3]”快：
MOV AX,[EBX]
MOV AX,[EBX+1]
MOV AX,[EBX+2]
因此，在定义变量和缓冲区时，要注意数据对齐。在定义结构类型时，要注意各字段位置的安排，以便结构变量字段的对齐和结构数组的对齐。
例如，如下两个结构类型的定义，结构STRUBB比STRUAA要好。当然，假设利用这些结构类型定义的结构变量或者结构数组是对齐的。
STRUAA STRUC
VARB1 DB ?
VARW DW ?
VARD DD ?
VARB2 DB ?
STRUAA ENDS
STRUBB STRUC
VARB1 DB ?
VARB2 DB ? 即使无需VARB2字段，也宜添一个字节以便对齐
VARW DW ?
VARD DD ?
STRUBB ENDS
注意，为了做到对齐访问，可能要浪费部分存储单元。
2.访问数据相对集中
通常程序运行时所执行的指令和所访问的数据各自相对集中，而且越是被多次访问的数据越有可能再被访问。
高速缓存正是根据这些特点设计的。为了充分利用超高速缓存，在安排数据和组织代码时要注意相对集中。
具体地说是数据相对集中和访问相同数据的代码相对集中。相对集中可使得被访问的数据尽量已出现在超高速缓存中。
例如，假设要对一组数据进行两项操作，如果分别用两个循环来处理，那么把这两个循环安排得较近为好。如果数据组较大，那么应该考虑把这两个循环合为一个循环。
3.缩短代码长度
尽量使当前活跃的代码长度在8K字节范围内，以适合指令缓冲区。算法的改进是缩短代码长度的主要手段。此外还有一些选择指令的小技巧。
采用一条多时钟的指令代替多条单时钟的指令能有效地缩短目标代码长度。但前面已提及，这种方法会减少指令配对机会，在取舍时要综合考虑。
充分利用32位寻址方式。例如，如下的指令片段可用一条指令“MOV ECX,[EBX+EDX*8+32]”代替：
SHL EDX,3
ADD EBX,EDX
ADD EBX,32
MOV ECX,[EBX]
利用LEA指令往往可方便地实现多个操作数相加。并且LEA指令是UV类指令，执行时只要花一个时钟。但要注意，LEA指令可能会增加AGI现象的发生。
例如，如下的程序片段，可用一条指令“LEA ECX,[EAX+EBX*4+CONSTV]”代替，其中CONSTV是常数：
MOV ECX,EBX
SHL ECX,2
ADD ECX,EAX
ADD ECX,CONSTV
注意采用较短的指令。在11.4.1指出了单字节指令便于配对的优点，显然单字节指令也能够缩短目标代码，但多数情况是无法用单字节指令实现的。
在使用多字节指令时，要注意选择较短的多字节指令。
例如，如下左右两个片段多根据EBX的内容是否为0进行分支，但右边的片段较短：
CMP EBX,0         OR EBX,EBX
JNZ NEXT          JNZ NEXT
当条件转移指令和无条件转移指令的转移范围较小时，要用“SHORT”明确说明，这样可只用1字节表示地址差。
例如，如果上述条件转移指令中的标号NEXT较近，并且是向前引用，那么在其前加上“SHORT”可节省3个字节（设32位代码）。
11.5习题
题11.180486有哪些新特点？Pentium有哪些新特点？
80486在80386的基础上集成浮点处理部件和超高速缓存，从程序设计的角度看，80486只比80386多了几个控制位和6条指令。
80486集成了相当于80387的浮点处理部件，所以80486含有80386和80387所拥有的全部32位寄存器。
80486的指令集是在80386指令集的基础上增加了6条新指令，新增的指令主要用于片上高速缓存的清洗和对多处理器系统的支持。
80486带有8K字节的超高速缓存器。它对软件是透明的，以保证与80x86系列先前的处理器兼容。
8086/8088提供断点指令INT3和单步标志TF，调试工具利用它们可以设置断点和实现单步。
80386集成了调试寄存器，利用这些调试寄存器不仅可以设置代码执行断点，而且还可以设置数据访问断点。
80486的调试功能包括了80386的调试功能并稍有扩充，断点指令和单步与8086/8088基本相同。
Pentium不仅采用更先进的技术实现先前微处理器的功能，而且增加了许多新功能。
Pentium实现超标量体系结构，支持分别称为U和V的两条流水线，理想情况下，在一个时钟周期内可以执行两条指令。
Pentium通过在片内的分支目标缓冲器（BTB），实现动态分支预测，有效地提高分支处理执行速度。
Pentium增加了片上超高速缓存的容量，8K字节用于数据，8K字节用于代码。此外，Pentium还实现了流水线浮点部件，加强了错误检测和报告功能，
完善和扩充了虚拟8086模式，提供多处理器支持。
Pentium维持80486绝大部分寄存器的作用和使用方法。但新增了若干Pentium模型专用寄存器，这些模型专用寄存器主要用于系统测试和运行性能检测。
80486所含的测试寄存器的功能，在Pentium上由模型专用寄存器实现。
Pentium指令集应该说是80486指令集的超集。由于在Pentium中测试寄存器归属于Pentium模型专用寄存器，所以Pentium不再支持测试寄存器数据传送指令。
除此之外，Pentium支持其他80486的全部指令，并保持与80486兼容。与80486相比，Pentium还新增了几条指令。
但某些新增的指令是否有效与Pentium的型号有关，可利用处理器特征识别指令CPUID判别处理器是否支持某些新增指令。
Pentium支持控制寄存器CR4，所以Pentium的控制寄存器传送指令的操作数还可以是控制寄存器CR4。Pentium还提供从系统管理方式返回的指令RSM。
Pentium在片上包含了独立的指令（代码）和数据超高速缓存器，分别为8K字节。指令和数据超高速缓存可以同时被访问。
可以利用软件和硬件的方法控制片上超高速缓存的工作方式，也可以利用软件和硬件的方法控制可被超高速缓存的内存区域。
为了适应多处理器环境的需要，对于数据超高速缓存，采用一种称为MESI的协议，保持超高速缓存数据一致；
对于指令超高速缓存，则采用MESI协议的子集SI来保持一致。
题11.280486标志寄存器比80386标志寄存器多定义了哪些标志？这些标志有何作用？
31          19   18   17   16  15  14  13 12   11   10  9  8    7   6   5  4   3  2   1  0
                    AC  VM  RF  0   NT  IOPL    OF  DF IF TF  SF ZF  0 AF 0  PF     CF
80486的标志寄存器EFLAGS仍是32位，与80386标志寄存器相比，80486的标志寄存器新增了一个对齐检查标志AC。其他标志位的位置及意义保持与80386相同。
标志位AC参与控制地址不对齐异常的发生。所谓地址不对齐是指如下情形：访问一个奇地址的字，或访问地址不是4的倍数的双字等等。
如果AC置1，那么当出现地址不对齐情形时，引起地址对齐异常。但在特权级0、1和2运行时，忽略AC位的设置，在CR0中的AM位为1时也忽略AC位的设置。
地址对齐异常是80486新设置的异常，属于故障类异常，向量号规定为11H。80486地址对齐异常提供出错码0。只有在特权级3运行的应用程序才可能引起地址对齐故障。
题11.3Pentium标志寄存器中的标志ID有何作用？
31         22  21  20 19   18   17   16  15  14  13 12   11   10  9  8    7   6   5  4   3  2   1  0
                   I    V    V    AC  VM  RF  0   NT  IOPL    OF  DF IF TF  SF ZF  0 AF 0  PF     CF
                  D     I   I
                        P   F
Pentium的标志寄存器EFlAGS仍是32位，与80486标志寄存器相比，Pentium的标志寄存器新增了三个标志：
虚拟中断标志VIF、虚拟中断挂起标志VIP和标识标志ID。其他标志位的位置及意义保持与80486相同。
虚拟中断标志VIF占用标志寄存器的位19。当允许虚拟8086方式扩充或者允许保护方式虚拟中断时，VIF是中断标志的虚拟映象。
当禁止虚拟8086方式扩充和禁止保护方式虚拟中断时，VIF被强制为0。
虚拟中断挂起标志VIP占用标志寄存器的位20。当允许虚拟8086方式扩充或者允许保护方式虚拟中断时，VIP指示虚拟中断是否挂起。
当禁止虚拟8086方式扩充和禁止保护方式虚拟中断时，VIP被强制为0。
标识标志ID占用标志寄存器的位21。如果可以设置或清除该标志，那么表示处理器支持CPUID指令。利用该指令可获得处理器类型等信息。
题11.480486控制寄存器CR0比80386的控制寄存器CR0多定义了哪些控制位？
80486仍只包括3个控制寄存器CR0、CR2和CR3。CR0新设了5个控制位。
       31  30  29  28                     19 18 17 16 15        11                5    4   3   2    1     0
CR0 PG CD NW 0 0 0 0 0 0 0 0 0 0 AM 0 WP 0 0 0 0  0 0 0 0  0 0 NE ET TS EM MP PE
80486的CR0新定义了如下控制位：用于控制片上超高速缓存工作方式的CD位和NW位；对齐屏蔽位AM；页面写保护位WP；数字异常位NE。
PE位控制80486工作于实方式还是保护方式，PG位控制是否启用分页机制，它们的作用与80386保持兼容。
由于80486含浮点处理部件，所以处理器扩展类型位ET总是1。位TS、EM和MP的作用与80386保持兼容。只是它们控制片上浮点处理部件。
新设的数字异常位NE控制通过哪种方式报告未屏蔽的浮点部件出错故障。NE=0，采用外部中断方式报告。
这种方式是系统复位时的缺省方式，保持与先前微机系统的处理方式相一致。也即当浮点部件出错时，导致中断向量号为0DH的外部中断。
NE=1，通过引起浮点部件出错故障报告，对应中断向量号为10H。
新设的对齐屏蔽位AM控制标志寄存器EFLAGS中的对齐检查标志AC是否有效。
AM=0，忽略AC位。这是系统复位时的缺省状态，以便保持与80386兼容。AM=1，考虑AC位，这时才可能引起地址对齐异常。
新设的页面写保护位WP控制系统级程序写访问只读页面。80386允许系统特权级（0级、1级和2级）程序写访问只读页面。
在80486中，这种情况受到WP位的控制。WP=0，保持与80386兼容，这是系统复位时的缺省状态。WP=1，任何特权级程序向只读页面写访问，都将引起页故障。
新设的片上超高速缓存控制位CD控制是否允许超高速缓存填充。CD=0，允许片上超高速缓存填充。CD=1，禁止片上超高速缓存填充。
新设的片上超高速缓存直写方式控制位NW控制是否采用直写方式。NW=1，采用直写方式和允许使无效，这是系统复位时的缺省状态。NW=0，禁止直写方式及使无效。
题11.5Pentium控制寄存器CR0比80486控制寄存器多定义了哪些控制位？
Pentium支持4个控制寄存器CR0、CR2、CR3和CR4。与80486相比，多了CR4。
       31  30  29  28                     19 18 17 16 15        11                5    4   3   2    1     0
CR0 PG CD NW 0 0 0 0 0 0 0 0 0 0 AM 0 WP 0 0 0 0  0 0 0 0  0 0 NE ET TS EM MP PE
CR4                                                  M      P   D        T   P   V
                                                        C       S   E         S   V   M
                                                        E       E              D   I   E
31                  12   11   10   9   8   7   6   5   4   3         2   1   0
控制寄存器CR0各位的安排与80486相同，但其中的CD位和NW位重新定义了片上超高速数据缓存的工作方式。
CR4是Pentium新增的控制寄存器，位2是读时间标记计数器指令RDTSC使用控制位TSD。
当TSD为0时，可在任一特权级上执行读时间标记计数器指令RDTSC。
当TSD为1时，只有在当前特权级为0时，可执行指令RDTSC，否则将导致出错码为0的通用保护异常。
RESET后，TSD为0，任一特权级执行的程序都可使用指令RDTSC，读取时间标记计数器。
位3是调试扩充控制位DE。当DE为0时，禁止调试扩充，也即不支持I/O断点。当DE为1时，允许调试扩充，也即支持I/O断点。
RESET后，DE为0，禁止调试扩充，这样Pentium就保持80486原有调试功能。
位0是虚拟8086方式扩充控制位VME。当VME为0时，禁止虚拟8086方式扩充。
位1是保护方式虚拟中断控制位PVI。当PVI为0时，禁止保护方式虚拟中断。
位4是页面大小扩充控制位PSE。当PSE为0时，禁止页面大小扩充。
位6是机器检查异常控制位MCE。当MCE为0时，禁止机器检查异常。
在RESET后，这些控制位都是0，从而保持与80486相一致。
题11.680486指令集比80386指令集增加了哪些指令？
80486的指令集是在80386指令集的基础上增加了6条新指令。新增的指令主要用于片上高速缓存的清洗和对多处理器系统的支持。
字节交换指令BSWAP的功能是在操作数OPRD内交换4个字节的顺序。交换对应关系是：第0字节与第3字节交换，第1字节与第2字节交换。
该指令不影响各标志。
80x86系列处理器按“高高低低”的原则存储多字节数据，但某些处理器按“低低高高”原则存储数据。
BSWAP指令特别适宜于这两种数据格式之间的转换。
交换加指令XADD的功能是交换操作数OPRD1和OPRD2的内容，并把两个操作数相加结果送到操作数OPRD1中。
XADD指令按照一条相当于ADD指令的操作设置标志寄存器中的各运算结果标志。
XADD指令的功能相当于连续的交换指令XCHG和加运算指令ADD的功能。但该指令能更好地实现信号量操作。
当在XADD指令前加LOCK前缀时，能方便地实现多处理器场合的信号量操作。
比较交换指令CMPXCHG的功能是把对应尺寸的累加器（EAX、AX、AL）与操作数OPRD1比较，
如果相等，把操作数OPRD2的内容送操作数OPRD1，并置零标志ZF；
如果不等，把操作数OPRD1的内容送累加器，并清零标志ZF。
该指令按比较结果影响有关标志。
在加上LOCK前缀后，该指令对多处理器情况下的信号量操作非常有用。
使超高速缓存无效指令INVD使片上超高速缓存无效，也即清洗片上超高速缓存。该指令也产生一个特殊的总线周期，它可以用于使外部（二级）超高速缓存无效。
注意，该指令不把片上超高速缓存中的内容写回主存，所以使用时必须十分小心，通常应使用WBINVD指令。
该指令不影响各标志。
该指令是特权指令。只有在实方式和保护方式的特权级0下，才可执行该指令。
写回并使超高速缓存无效指令WBINVD使片上超高速缓存无效，也即清洗片上超高速缓存，但在清洗前把片上超高速缓存中更改的内容写回主存。
该指令会产生特殊的总线周期，指示把外部超高速缓存中更改的内容写回主存和指示外部超高速缓存无效。
通常应该使用该指令清洗片上超高速缓存。
该指令不影响各标志。
该指令是特权指令。只有在实方式和保护方式的特权级0下，才可执行该指令。
使TLB项无效指令INVLPG的功能是，如果存储器操作数OPRD能通过TLB中的某项转换成物理地址，那么使TLB内对应项无效。
在启用分页机制的情况下，分页部件利用页目录表和页表把线性地址转换成物理地址。为了加快转换速度，80386和80486片上都有转换后援缓冲器TLB。
TLB含32个项，用于存放当前最常使用的物理页的页码。
该指令不影响各标志。
该指令是特权指令。只有在实方式和保护方式的特权级0下，才可执行该指令。
题11.7Pentium指令集比80486指令集增加了哪些指令？
在Pentium中测试寄存器归属于Pentium模型专用寄存器，所以Pentium不再支持测试寄存器数据传送指令。
除此之外，Pentium支持其他80486的全部指令，并保持与80486兼容。与80486相比，Pentium还新增了几条指令。
Pentium支持控制寄存器CR4，所以Pentium的控制寄存器传送指令的操作数还可以是控制寄存器CR4。Pentium还提供从系统管理方式返回的指令RSM。
8字节比较交换指令CMPXCHG8B的功能是把EDX:EAX内的64位值与存储器操作数OPRD相比较，
如果相等，把ECX:EBX内的64位值存入存储器操作数OPRD；如果不等，把存储器操作数OPRD内的64位值装入EDX:EAX。
EDX和ECX分别是64位值的高32位。
如果EDX:EAX的值与存储器操作数OPRD的值相等，那么置ZF，否则清ZF。该指令不影响其他标志。
在加上LOCK前缀后，该指令对多处理器情况下的信号量操作有用。
处理器特征识别指令CPUID返回由EAX指定的某方面的处理器特征信息。
EAX=0              EAX=最大值 EBX:EDX:ECX=厂商识别标识串
EAX=1              EAX=CPU说明信息 EDX=特征标志字
1<EAX<=最大值 可能在未来的处理器中定义
EAX>最大值      未定义
该指令不影响各标志。
读时间标记计数器指令RDTSC把时间标记计数器的高32位复制到EDX，把低32位复制到EAX。
Pentium含有一个64位的时间标记计数器。该计数器随每一时钟周期递增。在RESET后，该计数器被清0。利用该计数器可检测程序运行性能。
控制寄存器CR4的TSD位限制该指令的使用。当TSD为0时，可在任一特权级上执行RDTSC指令。当TSD为1时，只有当特权级为0时，可执行RDTSC指令，
否则将导致出错码为0的通用保护异常。
该指令不影响各标志。
读模型专用寄存器指令RDMSR把由ECX寄存器指定的模型专用寄存器的内容送到EDX:EAX，EDX含高32位，EAX含低32位。
如果所指定的模型寄存器不足64位，那么在EDX:EAX中的对应位未定义。
Pentium提供一组模型专用寄存器，在利用RDMSR读某个模型专用寄存器时，必须先把欲读模型专用寄存器的编号送到ECX寄存器。
如果在ECX中指定的编号未定义或被保留，将导致通用保护异常。
该指令不影响各标志。
该指令只能在实方式或者保护方式的特权级0下执行，否则将导致通用保护异常。
在使用该指令前，应该利用CPUID指令取得处理器特征标志字，以判别是否可使用该指令，否则可能导致无效操作码异常。
Pentium的上述时间标记计数器是模型专用寄存器之一。利用访问模型专用寄存器的指令也可读取时间标记计数器值。但不提倡应用程序通过RDMSR指令读取时间标记计数器。
写模型专用寄存器指令WRMSR把EDX:EAX的内容送到由ECX寄存器指定的模型专用寄存器，EDX送到高32位，EAX送到低32位。
如果指定的模型寄存器有未定义的或者被保留的位，那么这些位的内容不变。如果在ECX中指定的编号未定义或被保留，将导致通用保护异常。
该指令不影响各标志。
该指令只能在实方式或者保护方式的特权级0下执行，否则将导致通用保护异常。
在使用该指令前，应该利用CPUID指令取得处理器特征标志字，以判别是否可使用该指令，否则可能导致无效操作码异常。
系统程序利用WRMSR指令可设置上述时间标记计数器。
题11.880486片上超高速缓存有哪些特点？
80486在片上带有8K字节的超高速缓存器。它对软件是透明的，以保证与80x86系列先前的处理器兼容。
       31  30  29  28                     19 18 17 16 15        11                5    4   3   2    1     0
CR0 PG CD NW 0 0 0 0 0 0 0 0 0 0 AM 0 WP 0 0 0 0  0 0 0 0  0 0 NE ET TS EM MP PE
                  Way0         Way1         Way2         Way3
index 127 16 bytes    16 bytes     16 bytes     16 bytes
index 126 16 bytes    16 bytes     16 bytes     16 bytes
index 125 16 bytes    16 bytes     16 bytes     16 bytes
index ...
index 3 16 bytes    16 bytes     16 bytes     16 bytes
index 2 16 bytes    16 bytes     16 bytes     16 bytes
index 1 16 bytes    16 bytes     16 bytes     16 bytes
index 0 16 bytes    16 bytes     16 bytes     16 bytes
80486的8K字节片上超高速缓存既能存储数据又能存储代码（指令）。8K字节容量指能用于存储数据或指令的容量，而不包括用于存储地址标记等的容量。
片上超高速缓存采用4路组相关联结构，在物理上分成4个2K字节的块。每块由128行构成，每行16字节宽。在逻辑上，分成128组，每组4行。
每行都有一个21位的标记相关联，记录每行与主存储器中存储单元的对应关系，这21位的标记相当于主存储器中存储单元物理地址的高端部分。
每一行都有一个有效位相关联，每行不是有效就是无效，没有部分有效的行。每行还有用于记录最近最少使用情况的LRU位相关联。
超高速缓存命中是指欲访问的存储单元地址作为有效标记部分出现在超高速缓存中。如果是读命中，那么直接从片上超高速缓存中读出，从而大大提高速度。
如果读未命中，那么通常会把该存储单元所在行填入超高速缓存。如果写命中超高速缓存，那么80486通常（采用直写方式时）不仅向超高速缓存相应单元写，
同时也向主存储器相应单元写。如果写未命中，那么直接写入主存储器相应单元，不影响超高速缓存。
片上超高速缓存的工作方式由控制寄存器CR0中的CD位和NW位控制。其中，CD位允许和禁止填充片上超高速缓存，NW位控制直写和使无效。
CD         NW         片上超高速缓存工作方式
0            0             允许超高速缓存填充，允许直写和使无效
0            1             无效组合，导致出错码为0的通用保护故障
1            0             禁止超高速缓存填充，允许直写和使无效
1            1             禁止超高速缓存填充，禁止直写和使无效
尽管两位可表示4种方式，但CD=0和NW=1的组合是无效组合，会引起通用保护故障。在RESET后的缺省组合是CD=1和NW=1，超高速缓存为空。
CD=0允许超高速缓存填充。当读访问存储单元时，如果未命中片上超高速缓存，那么所读存储单元所在行通常就会被填充到超高速缓存，
并且物理地址的高端部分就作为该行的标记。
在把某行填充到超高速缓存时，首先检查该组中所有的4行是否都有效，如果有无效行，则更新该行，如果都有效，那么采用最近最不常使用算法确定更新哪一行。
CD=1禁止超高速缓存填充。当读访问存储单元未命中片上超高速缓存时，不把所在行填充到超高速缓存。不影响读命中超高速缓存，
不影响写命中超高速缓存和写未命中超高速缓存的动作。
NW=0允许直写和使无效。当写访问命中超高速缓存时，所写信息写入片上超高速缓存，同时驱动一个外部写总线周期，更新外部对应存储单元。
80486集成有监视其他外部系统写入主存储器的逻辑，当它检查到其他外部系统写入主存储器的存储单元命中片上超高速缓存时，就使片上超高速缓存的对应行无效。
这就是使无效。它在保证超高速缓存的内容与对应主存储器的内容保持一致方面起重要作用。
NW=1禁止直写和使无效。当写访问命中超高速缓存时，更新片上超高速缓存相应行，但不更新外部对应存储单元。
当其他外部系统更新主存储器的存储单元命中片上超高速缓存时，并不使片上超高速缓存对应行无效。这种处理方法会导致片上超高速缓存内容与对应主存储器的内容不一致。
题11.9Pentium片上超高速缓存有哪些特点？
Pentium包含独立的指令（代码）和数据超高速缓存器，分别为8K字节。指令和数据超高速缓存可以同时被访问。
可以利用软件和硬件的方法控制片上超高速缓存的工作方式，也可以利用软件和硬件的方法控制可被超高速缓存的内存区域。
为了适应多处理器环境的需要，对于数据超高速缓存，采用一种称为MESI的协议，保持超高速缓存数据一致；
对于指令超高速缓存，则采用MESI协议的子集SI来保持一致。
                  Way0                          Way1         
index 127 16 bytes    16 bytes     16 bytes     16 bytes
index 126 16 bytes    16 bytes     16 bytes     16 bytes
index 125 16 bytes    16 bytes     16 bytes     16 bytes
index ...
index 3 16 bytes    16 bytes     16 bytes     16 bytes
index 2 16 bytes    16 bytes     16 bytes     16 bytes
index 1 16 bytes    16 bytes     16 bytes     16 bytes
index 0 16 bytes    16 bytes     16 bytes     16 bytes
Pentium片上的数据超高速缓存和指令超高速缓存的容量皆为8K字节，而且都采用二路组相关联结构。每个超高速缓存有128组，每组2行。每行32字节宽。
每个超高速缓存都使用物理地址来访问，并且每个超高速缓存都有自己的TLB将线性地址转换为物理地址。
数据超高速缓存由在4字节边界处交错的8个体构成。它在同一个时钟内可以支持两次数据访问。在两条流水线中执行的指令可以同时访同数据超高速缓存，
但如果访问对同一个体进行，那么会有延时。Pentium的数据超高速缓存是一种回写式超高速缓存，填充和替换以行为单位进行。
每一行有用于支持MESI协议的两位相关联，可表示4种状态：M状态（Modified）、E状态（Exclusive）、S状态（Shared）和I状态（Invalid）。
另外，每一行还有用于记录最近最少使用情况的LRU位相关联。
指令超高速缓存在一个时钟内可提供多达32字节的原始代码。由于指令超高速缓存无需回写，所以每一行有用于支持SI协议的一位相关联，可表示S和I这2种状态。
每一行也有用于记录最近最少使用情况的LRU位相关联。
控制寄存器CR0中的CD位和NW位可控制片上超高速缓存的工作方式。
       31  30  29  28                     19 18 17 16 15        11                5    4   3   2    1     0
CR0 PG CD NW 0 0 0 0 0 0 0 0 0 0 AM 0 WP 0 0 0 0  0 0 0 0  0 0 NE ET TS EM MP PE
由于Pentium的超高速缓存支持回写方式，所以与80486相比，这两个控制位的定义有所不同。
CD=0和NW=0能使片上超高速缓存发挥最高性能。把CD和NW置1能禁止超高速缓存，但为了完全禁止超高速缓存，在把CD和NW置1后，还应该清洗超高速缓存。
在RESET后，CD=1和NW=1。
题11.10在11.1.3中有一个演示NW位作用的程序片段。请说明在分别删除该程序片段中LINE1、LINE2或LINE3行后，该片段的执行情况。
......
ENTER 2,0
CLI
INVD
LINE1:MOV BL,[BP-2]
MOV BYTE PTR [BP-2],1
MOV EAX,CR0
BTS EAX,30
LINE2:BTS EAX,29
MOV CR0,EAX
MOV BYTE PTR [BP-2],5
MOV CL,[BP-2]
LINE3:INVD
MOV BL,[BP-2]
BTR EAX,30
BTR EAX,29
MOV CR0,EAX
STI
LEAVE
......
没有删除LINE1、LINE2、LINE3时，超高速缓存中有[BP-2]->内存 [BP-2] = 1->内存 [BP-2] = 1，超高速缓存 [BP-2] = 5->CL = 超高速缓存 [BP-2] ->BL = 内存 [BP-2]
删除LINE1:MOV BL,[BP-2]后，超高速缓存中没有[BP-2]->内存 [BP-2] = 1->内存 [BP-2] = 5->CL = 内存 [BP-2] ->BL = 内存 [BP-2]
删除LINE2:BTS EAX,29后，超高速缓存中有[BP-2]->内存 [BP-2] = 1->内存 [BP-2] = 5，超高速缓存 [BP-2] = 5->CL = 超高速缓存 [BP-2] ->BL = 内存 [BP-2]
删除LINE3:INVD后，超高速缓存中有[BP-2]->内存 [BP-2] = 1->内存 [BP-2] = 1，超高速缓存 [BP-2] = 5->CL = 超高速缓存 [BP-2] ->BL = 超高速缓存 [BP-2]
题11.1180386和80486等增加了哪些调试功能？它们如何实现数据访问断点？
8086/8088提供断点指令INT3和单步标志TF，调试工具利用它们可以设置断点和实现单步。从80386开始，在片上集成了调试寄存器。
利用这些调试寄存器不仅可以设置代码执行断点，而且还可以设置数据访问断点；不仅可以把断点设置在RAM中，也可以把断点设置在ROM中。
80486的调试功能包括了80386的调试功能并稍有扩充。关于断点指令和单步与8086/8088基本相同。
31                  16   15                  0
断点0线性地址                                   DR0
断点1线性地址                                   DR1
断点2线性地址                                   DR2
断点3线性地址                                   DR3
保留                                                 DR4
保留                                                 DR5
                           B B B        B B B B                   DR6
                           T S D        3 2 1 0
L R L R L R L R            G   G L G L G L G L G L      DR7
E W E W E W E W       D   E E 3 3 2 2 1 1 0 0
N E N E N E N E
3 3 2 2 1 1 0 0
31                  16   15                  0
80386和80486都支持6个调试寄存器，分别是断点地址寄存器DR0、DR1、DR2和DR3，调试状态寄存器DR6和调试控制寄存器DR7。
这些断点寄存器都是32位寄存器。利用调试寄存器数据传送指令，可以存取这些调试寄存器。
但必须注意，调试寄存器数据传送指令只能在实方式和保护方式的特权级0下执行，所以只有在实方式或特权级0执行的程序才能设置断点和进行断点处理。
断点地址寄存器用于保存断点处的线性地址，也即指示断点位置。这些寄存器长32位，与32位线性地址长度相符。
处理器硬件把执行指令所涉及的线性地址和断点地址寄存器内的线性地址进行比较，判别执行指令是否触及断点。
处理器具有4个断点地址寄存器DR0、DR1、DR2和DR3，所以可以同时支持4个这样的“硬”断点。
因为由片上寄存器指示断点位置，而非断点中断指令指示断点位置，所以这些“硬”断点可以设置在ROM中或者几个任务共享的代码中。
不论是否启用分页机制，断点地址寄存器内保存的总是线性地址。根据线性地址设置断点保证使断点与分页无关。
这种断点位置由线性地址表示的做法便于断点的表示，也符合实际调试的需要。
调试控制寄存器不仅控制是否允许断点，还控制各断点是代码执行断点还是数据访问断点。DR7所含各字段作用如下：
（1）断点类型说明字段RWE
DR7有4个RWE字段，依次分别对应4个断点。RWEi字段说明DRi寄存器所指示断点的类型。
每一个RWE占两位，所表示的类型列于表11.2。
表11.2 RWE字段说明的断点类型
RWE字段取值         断点类型(断点条件)         RWE字段取值         断点类型(断点条件)
0 0                        只执行                          1 0                        未定义(不能用该值)
0 1                        只写入数据                    1 1                        只读或写数据
“00”表示指令执行断点，当执行对应断点地址寄存器所含地址处的指令时，满足断点条件。注意，指令执行断点地址必须等于指令开始的字节地址（包括前缀）。
“01”和“11”表示数据访问断点，当按所示读写方式访问对应断点地址寄存器所含地址处的存储单元时，满足断点条件。
（2）断点长度说明字段
DR7有4个LEN字段，依次分别对应4个断点。LENi字段说明DRi寄存器所指示断点的长度（范围）。
每一个LEN占两位，所表示的长度列于表11.3。
表11.3 LEN字段说明的断点长度
LEN字段取值         断点长度(范围)         断点地址寄存器指示的断点地址
0 0                       1字节                     全部32位指示一个单字节的断点
0 1                       2字节                     最低1位被忽略，确定字对齐地址开始的2字节断点
1 0                       未定义(不能取该值)
11                        4字节                     最低2位被忽略，确定双字对齐地址开始的4字节断点
指令执行断点的断点长度必须为1字节。数据访问断点的断点长度可以是1字节、2字节或4字节。
对于数据访问断点而言，断点长度说明字段LEN和对应断点寄存器规定了断点的区域范围。
例如，设DR1内的断点线性地址是XXXXXXX5H，当LEN1=00时，断点的区域范围只有1字节，地址就是XXXXXXX5H；
当LEN1=01时，断点的区域范围是地址XXXXXXX4H到XXXXXXX5H的2字节；
当LEN1=11时，断点的区域范围是地址XXXXXXX4H到XXXXXXX7H的4字节。
当按RWE所示数据访问断点方式访问存储单元触及断点范围内的字节时，就满足断点条件。
（3）全局和局部断点允许位
DR7有4个Gi和Li，分别对应4个断点。Gi和Li控制DRi所指示的断点i在断点条件满足时，是否引起断点异常。
当Gi或Li为1时，如果DRi所指示数据访问断点条件满足，那么导致进入向量号为1的调试陷阱，如果DRi所指示指令执行断点条件满足，那么导致引发向量号为1的调试故障。
Gi和Li分别称为全局断点允许位和局部断点允许位。在任务切换时，处理器清各Li位，所以Li位只支持一个任务范围内的断点。
任务切换并不影响Gi位，所以Gi支持系统内各任务的断点。
（4）精确数据访问断点相符位
DR7还有GE位和LE位，用于指示是否要求数据访问断点精确相符。80486无论GE或LE是否置位，总是断点精确相符的。
在80386中，可能出现数据访问断点不精确相符，通过设置GE位或LE位可指示80386数据访问断点精确相符。
在任务切换时，LE位被自动清除，所以LE位是局部于任务的；任务切换时GE位不受影响，所以GE位是全局的。
（5）全局调试寄存器访问检测位
DR7的位13是调试寄存器访问检测位GD。尽管只能在实方式或保护方式的特权级0时才能访问调试寄存器，但GD位还提供对调试寄存器的特别保护。
在GD=1的情况下，即使在实方式或保护方式的特权级0时，访问任何调试寄存器都会引起向量号为1的调试故障。
这种附加的保护特性保证调试程序在需要的时候可以完全控制调试寄存器资源。
在进入向量号为1的异常处理程序时，自动地清除GD位，以便异常1处理程序能自由地访问调试寄存器。
调试状态寄存器指示断点原因，也即指示进入异常1处理程序的原因。
异常1处理程序可根据DR6的有关位，确定是数据访问断点、指令执行断点、单步或其他原因。
DR6内的各指示位为1时所表示的意义如下：
Bi=1（i=0，1，2，3）表示由DRi所指示的断点引起指令执行调试故障或进入数据访问调试陷阱。每当处理器在某个允许的断点i处发现断点条件满足，就设置DR6中的Bi，
然后转入异常1处理程序。要特别注意，在某个允许的断点i处断点条件满足而设置Bi时，同时设置所有在那瞬间断点条件满足的各对应Bj位，而不论是否允许。
因此，异常1处理程序可能看到多个Bi被置位，但可以通过判断断点允许位Gi和Li位的方法来确定真实的原因。
BD=1表示在GD置位的情况下访问调试寄存器，从而引起调试故障。在进入异常1处理程序时，自动清除GD位。
BS=1表示由于单步原因进入调试陷阱。当标志寄存器EFLAGS中的单步标志TF置位时，一般每执行完一条指令后就进入异常1处理程序，这就是单步。
由于在进入异常处理程序时，自动清TF标志。所以，异常1处理程序的执行不会再单步。
在异常处理程序结束时，中断返回指令IRET从堆栈中弹出原标志寄存器内容到标志寄存器，如果TF为1的话，那么又会产生单步。
实际上，在执行置位TF指令的下一条指令（通常是IRET）之后才产生单步。
BT=1表示刚切换到任务状态段TSS中的调试陷阱标志T置位的任务。任务状态段TSS内安排了一个调试陷阱标志T，该标志T是任务状态段TSS内偏移64H处的字的最低位。
在任务切换时，如果进入任务的T位为1，那么通常在任务切换完成之后，新任务的第一条指令执行之前进入调试陷阱，也即进入异常1处理程序。这也称为任务切换自陷。
请注意，硬件根据上述各种情况设置调试状态寄存器DR6中的相应标志，但硬件并不自动清除它们。所以，异常1处理程序一般应该在返回前清除DR6，以免发生混淆。
31          19   18   17   16  15  14  13 12   11   10  9  8    7   6   5  4   3  2   1  0
                    AC  VM  RF  0   NT  IOPL    OF  DF IF TF  SF ZF  0 AF 0  PF     CF
重启动标志RF（Restart Flag）
重启动标志控制是否接受调试故障。RF=0接受，RF=1忽略。在成功地完成每一条指令后，处理器把RF清0。
而当接收到一个非调试故障时，处理器把RF置1。
调试异常分为调试故障和调试陷阱两类。数据访问断点、单步和任务切换自陷属于调试陷阱。调试陷阱是在执行引起异常的指令之后发生，
进入调试陷阱时，保存在堆栈中的返回地址指向引起陷阱的指令的下一条要执行指令。
调试故障是在引起异常的指令之前发生，进入调试故障时，堆栈中的返回地址指向引起故障的指令。
标志寄存器EFLAGS中的重启动标志RF能控制是否产生调试故障。在把RF置成1后，下一条指令的任何调试故障被忽略。
通常每当成功地执行完一条指令，那么RF被清0。但IRETD指令例外，它能根据堆栈中标志寄存器映象的RF位值设置RF。
异常1处理程序能利用这一特性，在返回断点处时不再重复产生断点故障。
题11.12在80386和80486等微处理器上通过哪些途径可实现程序执行断点？
由DRi所指示的断点引起指令执行调试故障，每当处理器在某个允许的断点i处发现断点条件满足，就设置DR6中的Bi，然后转入异常1处理程序。
在GD置位的情况下访问调试寄存器，从而引起调试故障。在进入异常1处理程序时，自动清除GD位。
由于单步原因进入调试陷阱。当标志寄存器EFLAGS中的单步标志TF置位时，一般每执行完一条指令后就进入异常1处理程序，这就是单步。
刚切换到任务状态段TSS中的调试陷阱标志T置位的任务。在任务切换时，如果进入任务的T位为1，那么通常在任务切换完成之后，新任务的第一条指令执行之前进入调试陷阱，
也即进入异常1处理程序。这也称为任务切换自陷。
题11.13请画出程序T11-2.ASM为结束调试故障处理而安排的堆栈。
实例程序由两部分组成：异常1处理程序和演示程序，分别安排在两个段中。
异常1处理程序的处理步骤如下：
（1）在屏幕的左上角区域以二进制数的形式显示调试状态寄存器DR6、指令指针EIP的低16位部分IP和32位寄存器EAX的内容。
（2）调用BIOS键盘管理程序，等待按键。该步是让用户能够看清上述显示内容。
（3）根据DR6和DR7判断进入异常1处理程序的原因。分调试陷阱和调试故障两种情形结束异常1处理程序。
对于调试陷阱，直接用中断返回指令IRET返回。对于调试故障，通过能够设置标志寄存器中RF标志的IRETD指令返回，
为此还必须在堆栈中形成由二个双字的返回地址和32位EFLAGS映象的断点现场。
SUB ESP,6
PUSH EAX
MOV AX,[ESP+10]
MOVZX EAX,AX
MOV [ESP+4],EAX
MOV AX,[ESP+12]
MOV [ESP+8],EAX
PUSHFD
POP EAX
MOV AX,[ESP+14]
MOV [ESP+12],EAX
BTS DWORD PTR [ESP+12],16
POP EAX
IRETD
堆栈如下
32位EFLAGS中的高16位 + 原先压入的16位FLAG
高16位为0+原先压入的16位CS
高16位为0+原先压入的16位IP                              <-ESP
题11.14Pentium的调试功能扩充指什么？
Pentium所支持的调试功能扩充是指支持I/O断点。80486调试控制寄存器DR7中的各断点类型说明字段RWEi尽管是2位，但该字段取值“10”的情况被保留。
在允许调试扩充时，Pentium调试控制寄存器DR7中的各断点类型说明字段RWEi，可以取值“10”，所表示的断点条件是I/O端口读或者写。
表11.4 RWE字段说明的断点类型
RWE字段取值         断点类型(断点条件)         RWE字段取值         断点类型(断点条件)
0 0                        只执行                          1 0                        读写I/O端口
0 1                        只写入数据                    1 1                        只读或写数据
在允许调试扩充时，表11.2所列出的断点类型扩充为表11.4所列的断点类型。对应的断点地址寄存器内存放的是扩展成32位的I/O端口地址。
控制寄存器CR4中的DE位决定是否允许调试功能扩充。当DE为1时，允许调试功能扩充。
题11.15请完善程序T11-3.ASM，使其具有显示输出功能。
.686P
CSEG SEGMENT USE16
ASSUME CS:CSEG,DS:CSEG
CPUTYPE DB ?
CPUIDF DB 0
INTELF DB 0
FAMILY DB 0
CMODEL DB 0
STEPID DB 0
PROPF DD 0
GetCPUID PROC
Check8086:PUSHF
POP AX
AND AX,0FFFH
PUSH AX
POPF
PUSHF
POP AX
AND AX,0F000H
CMP AX,0F000H
MOV BYTE PTR CPUTYPE,0
JNZ SHORT Check286
MOV AX,0
MOV AL,CPUTYPE
CALL ECHOAX
CALL NEWLINE
RET
Check286:PUSHF
POP AX
OR AX,3000H
PUSH AX
POPF
PUSHF
POP AX
TEST AX,3000H
MOV BYTE PTR CPUTYPE,2
JNZ SHORT Check386
MOV AX,0
MOV AL,CPUTYPE
CALL ECHOAX
CALL NEWLINE
RET
Check386:MOV BP,SP
AND SP,NOT 3
PUSHFD
POP EAX
MOV EDX,EAX
BTS EAX,18
PUSH EAX
POPFD
PUSHFD
POP EAX
BT EAX,18
JC SHORT A386
MOV BYTE PTR CPUTYPE,3
MOV SP,BP
MOV AX,0
MOV AL,CPUTYPE
CALL ECHOAX
CALL NEWLINE
RET
A386:PUSH EDX
POPFD
MOV SP,BP
Check486:MOV EAX,EDX
BTS EAX,21
PUSH EAX
POPFD
PUSHFD
POP EAX
PUSH EDX
POPFD
BT EAX,21
MOV BYTE PTR CPUTYPE,4
JNC SHORT IDOK
AE486:MOV BYTE PTR CPUIDF,1
XOR EAX,EAX
CPUID
CMP EBX,"uneG"
JNE SHORT IDOK
CMP EDX,"Ieni"
JNE SHORT IDOK
CMP ECX,"letn"
JNE SHORT IDOK
YINTEL:MOV BYTE PTR INTELF,1
CMP EAX,1
JB SHORT IDOK
MOV EAX,1
CPUID
MOV PROPF,EDX
MOV BL,AL
AND AX,0F0FH
MOV STEPID,AL
MOV FAMILY,AH
SHR BL,4
MOV CMODEL,BL
MOV CPUTYPE,AH
IDOK:MOV AX,0
MOV AL,CPUTYPE
CALL ECHOAX
CALL NEWLINE
RET
GetCPUID ENDP
Begin:PUSH CS
POP DS
CALL GetCPUID
MOV AH,4CH
INT 21H
ECHOAX PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV DX,AX
MOV CX,4
ECHOAX1:ROL DX,4
MOV AL,DL
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
MOV BH,0
MOV AH,0EH
INT 10H
LOOP ECHOAX1
POP DX
POP CX
POP BX
POP AX
RET
ECHOAX ENDP
NEWLINE PROC NEAR
PUSH AX
PUSH BX
MOV BH,0
MOV AL,0DH
MOV AH,0EH
INT 10H
MOV AL,0AH
MOV AH,0EH
INT 10H
POP BX
POP AX
RET
NEWLINE ENDP
CSEG ENDS
END Begin
在XP下使用tasm32 t472.asm编译，tlink t472.obj链接
在DOS下运行t472.exe
c:\tasm16\t472.exe
0006
Pentium拥有两条并行的整型流水线，两条流水线能够同时执行指令，所以Pentium最多能在一个时钟内执行两条整型指令。
Pentium的两条流水线分别称为U流水线和V流水线。U流水线是主流水线，它能够执行指令集中的所有指令。V流水线在可执行的指令方面有限制，它只能执行大多数常用指令。
Pentium的整型流水线含有五步：预取（PreFetch）、译码1（Decode stage1）、译码2（Decode stage2）、执行（Execute）、回写（WriteBack）。
整型指令的执行要经过流水线中这五步。
如果要执行的两条指令符合“指令配对规则”能够配对，那么一条指令经由U流水线执行，另一条指令经由V流水线执行。
尽管指令在两条流水线中并行执行，但执行指令的功能与指令顺序执行时是完全一致的。
在依次经过流水线各步的过程中，由于某些情况，指令执行可能被拖延。U流水线和V流水线中的指令一起配对进入和离开D2和EX阶段。
如果在某条流水线中的指令在某阶段被耽搁，那么在另一条流水线中的配对指令也在同一阶段被耽搁。
只有当处于两条流水线EX阶段的配对指令都到达WB阶段，那么两条流水线上的随后指令才能够进入EX阶段。
在两条流水线并行执行过程中，对存储器的访问仍保持顺序执行时的次序，所以只有在U流水线中的指令完成需要的存储器访问后，
V流水线中可能有的配对指令才能够进行存储器访问，这也可能会导致某些执行被拖延。
指令集中的指令根据如何进行流水线配对可分为如下四类：
（1）UV类指令，这类指令既可发到U流水线又可发到V流水线。大多数算术逻辑运算指令、全部比较指令和全部以通用寄存器为操作对象的堆栈操作指令属于UV类指令。
（2）PU类指令，这类指令在配对时只能发到U流水线。有前缀的指令属于PU类指令；带进位或借位操作指令、移位位数由立即数决定的移位指令属于PU类指令。
（3）PV类指令，这类指令在配对时只能发到V流水线。简单控制转移指令（如近调用CALL，近转移JMP，条件转移指令）属于PV类指令。
（4）NP类指令，这类指令不能配对，只能单独在U流水线中执行。移位位数由CL确定的移位指令、乘除指令（如MUL，DIV）、
扩充的指令（如PUSHA，ENTER，MOVS，LOOPNZ，MOVSX）、涉及段寄存器的指令（如远调用指令CALL，PUSH DS）属于NP类指令。
整型指令配对的基本规则（必要条件）如下：
（1）配对的两条指令都不能是NP类指令，前一条指令不能是PV类指令，后一条指令不能是PU类指令。
（2）配对的两条指令必须已在指令超高速缓存中，而且已执行过。但如果前一条指令是单字节指令，那么该指令不受该项约束。
（3）除某些特别的配对指令外，配对的指令之间不能有隐式或显式的寄存器争用。
（4）如果指令的一个操作数由立即寻址方式确定，并且另一个操作数的寻址方式中使用了相对偏移，那么这样的指令不能参与配对。
（5）指令基本长度（不包括前缀）超过7字节的指令不能参与配对。
如果随后的两条指令能够配对，那么前一条指令发到U流水线执行，后一条指令发到V流水线执行；
如果不能配对，那么只有前一条指令发到U流水线执行，后一条指令将作为下次配对的前一条指令。
题11.16在基于Pentium优化程序时，要考虑哪些方面？
提高指令配对的机会，提高动态分支预测正确程度，根据超高速缓存的特点，安排数据和组织代码。
提高指令配对的机会包括减少寄存器争用、减少地址形成相关现象、减少超高速缓存体的冲突、选择合适的指令。
提高动态分支预测正确程度包括调整基本片段位置、代替条件转移指令。
根据超高速缓存的特点，安排数据和组织代码，包括对齐访问、访问数据相对集中、缩短代码长度。
减少寄存器争用
数据相关能够导致寄存器争用。除某些特别的配对外，如果前后指令之间发生寄存器争用，那么就不能配对。
显然，减少寄存器争用可提高配对机会。下列情况被视为寄存器争用：
（1）当前一条指令以某个寄存器为目标写，而后一条指令要引用该寄存器，就引起寄存器争用。
（2）当前后两条指令都以某个寄存器为目标写，也引起寄存器争用。
在判定寄存器争用时，访问32位寄存器的部分（字节或者字）被认为是对32位寄存器的访问。
但是，由于改变标志而影响标志寄存器，不认为是对标志寄存器的争用。
另外，如果前一条指令以某个寄存器为源读，而后一条指令以该寄存器为目标写，这种情况不认为是寄存器争用。
为了提高可配对的机会，Pentium对某些寄存器争用情况作了特殊处理，把这些经特殊处理的争用配对称为特别配对。
特别配对主要涉及隐式读写堆栈指针寄存器ESP或者隐式写标志寄存器。
减少寄存器争用的一个方法，是在保持程序原有逻辑的前提下调整指令次序。
充分利用其他暂时不用的通用寄存器，也能够减少寄存器争用。
减少地址形成相关现象
在某个通用寄存器作为基址寄存器或者变址寄存器用于计算有效地址时，如果该寄存器又是刚刚执行（发出）指令的目的寄存器，
那么就出现地址形成相关（Address Generate Interlock）。由于在一个时钟内最多可执行两条指令，所以上述“刚刚执行”的指令可能间隔2条指令。
当出现地址相关现象时，那么在Pentium流水线的D2阶段会耽搁一个时钟。所以，为了提高流水线的效率，应该减少和避免地址形成相关现象的发生。
与调整指令次序可减少寄存器争用一样，通过调整指令次序的方法也可减少地址形成相关现象的发生。
减少超高速缓存体的冲突
Pentium的数据超高速缓存由8个体构成，每个体宽4字节。它支持在两条流水线中执行的指令可以同时访问。
在两条流水线中执行的配对指令，同时对同一个体的访问称为超高速缓存体冲突。
如果出现超高速缓存体冲突，那么V流水中执行的指令在D2阶段被耽搁一个时钟。
我们同样可采用调整指令次序的方法减少超高速缓存体冲突。
选择合适的指令
80x86系列处理器的指令集越来越丰富，在实现某个功能时往往有多种选择，选择合适的指令，可以增加指令配对的机会。
充分利用单字节指令
在指令超高速缓存中的指令才能够配对这条规则有个例外，也即如果前一条指令是单字节指令，那么该指令可不在超高速缓存中。
所以，要多采用单字节指令。
考虑使用多条单时钟指令代替一条多时钟指令
所谓单时钟指令是指只要化一个时钟就可执行的指令，许多指令是单时钟指令。
所谓多时钟指令是指执行时要化多个时钟的指令，以存储器操作数为目标操作数的算术逻辑运算指令不是单时钟指令，执行这样的指令往往要化3个时钟。
尽管用多条单时钟指令代替一条多时钟指令一般会增加代码长度，可能还要使用更多的寄存器，但有时用这种方法可增加指令配对机会，提高流水线效率。
但是，这种方法通常会增加目标代码长度和占用其他寄存器。
避免使用NP类指令
有某些指令不仅是NP类指令，而且执行时要花多个时钟。为了提高指令配对机会，提高流水线效率，可考虑用多条指令代替它。
这类似于用多条单时钟指令代替一条多时钟指令，这种方法通常会增加目标代码长度。
由指令前缀带来的副作用
80x86系列处理器，通过在正常指令之前添加前缀的方法，有效地改变或者扩充了指令原有功能。
原本属于UV类的指令，由于添加了前缀，只能发到U流水线，也就是说在配对时只能作为PU类指令。
减少16位代码和32位代码的混用，尽量通过DS访问数据段。
Pentium具有动态分支预测能力。在采用流水线方式执行指令后，如果不能有效地预测分支转移目标，那么转移就会导致流水线被冲洗，严重降低流水线处理效率。
减少分支转移，提高动态分支预测正确程度。
调整基本片段位置
所谓基本片段是指只有一个入口和出口的顺序执行的片段。所谓调整基本片段的位置是指：把使用频率高的基本片段安排在分支转移指令之后的位置处，
也即使得最经常的分支是直行的；把使用频率低的基本片段安排得尽可能离开使用频率高的基本片段。
这样的安排，不仅提高可预测程度，而且可减少把很少执行的代码预取入超高速缓存，还可减少对BTB项的占用。
代替条件转移指令
有时可用无分支转移的程序片段代替含分支转移的程序片段，从而消除分支。
有两种常用的代替方法：一种是用条件字节设置指令SETcc代替条件转移指令Jcc；另一种方法是用带进位CF操作的ADC或SBB指令代替条件转移指令Jcc。
Pentium的指令超高速缓存和数据超高速缓存是独立的，各有8K字节；都采用二路组相关联结构，都分成128组，每组2行，每行宽32字节；都使用物理地址访问；
都采用最近最少使用淘汰算法。Pentium片上超高速缓存能够支持在一个时钟内进行2次数据访问和获取32字节的原始代码。
但是，如果不能命中片上超高速缓存，那么至少要耽搁3个时钟；如果还没有命中机器系统的2级高速缓存，或者机器没有2级高速缓存，那么要耽搁的时间更多，达7个时钟。
理想情况下，Pentium在7个时钟内可能执行14条指令。所以，根据超高速缓存的特点，安排数据和组织代码对提高程序的效率是极其重要的。
对齐访问
尽管Pentium能够存取任何字节边界处的数据，但对数据超高速缓存不对齐的访问要多花3个时钟。所以，应该尽量实现对齐访问。
也就是说，对2字节数据的访问应在2字节边界处进行，至少不跨越4字节边界；对4字节数据的访问应在4字节边界处进行；对8字节数据的访问应在8字节边界处进行。
因此，在定义变量和缓冲区时，要注意数据对齐。在定义结构类型时，要注意各字段位置的安排，以便结构变量字段的对齐和结构数组的对齐。
注意，为了做到对齐访问，可能要浪费部分存储单元。
访问数据相对集中
通常程序运行时所执行的指令和所访问的数据各自相对集中，而且越是被多次访问的数据越有可能再被访问。
高速缓存正是根据这些特点设计的。为了充分利用超高速缓存，在安排数据和组织代码时要注意相对集中。
具体地说是数据相对集中和访问相同数据的代码相对集中。相对集中可使得被访问的数据尽量已出现在超高速缓存中。
缩短代码长度
尽量使当前活跃的代码长度在8K字节范围内，以适合指令缓冲区。算法的改进是缩短代码长度的主要手段。此外还有一些选择指令的小技巧。
采用一条多时钟的指令代替多条单时钟的指令能有效地缩短目标代码长度。但前面已提及，这种方法会减少指令配对机会，在取舍时要综合考虑。
充分利用32位寻址方式。
利用LEA指令往往可方便地实现多个操作数相加。并且LEA指令是UV类指令，执行时只要花一个时钟。但要注意，LEA指令可能会增加AGI现象的发生。
注意采用较短的指令。单字节指令能够缩短目标代码，但多数情况是无法用单字节指令实现的。
在使用多字节指令时，要注意选择较短的多字节指令。
当条件转移指令和无条件转移指令的转移范围较小时，要用“SHORT”明确说明，这样可只用1字节表示地址差。
题11.17请用一条指令代替如下由于寄存器争用而不能配对的两条指令：
MOV ECX,EBX
ADD ECX,EAX
利用LEA指令往往可方便地实现多个操作数相加。并且LEA指令是UV类指令，执行时只要花一个时钟。但要注意，LEA指令可能会增加AGI现象的发生。
LEA ECX,[EAX+EBX]
题11.18考虑如下程序片段，请调整指令次序，以增加指令配对机会：
MOV EAX,ECX         MOV EAX,ECX
ADD EAX,4             MOV EBX,3 
ADD EDX,EAX         ADD EAX,4
MOV EBX,3             ADD ECX,EBX 
ADD ECX,EBX         ADD EDX,EAX
TEST EBX,EBX         TEST EBX,EBX  
题11.19考虑如下程序片段，请通过调整指令次序的方法，避免AGI现象：
ADD ECX,4                  MOV [ECX+4],EAX
MOV [ECX],EAX           INC EAX
INC EAX                      ADD ECX,4 
CMP EAX,100              CMP EAX,100
JL NEXT                      JL NEXT
题11.20请考虑如何用多条单时钟指令代替如下指令片段：
ADD DWORD PTR [EBX],123456H
SUB DWORD PTR [EBX+8],EAX
多条单时钟指令
MOV ECX,[EBX]
MOV EDX,[EBX+8]
ADD ECX,123456H
SUB EDX,EAX
MOV [EBX],ECX
MOV [EBX+8],EDX
题11.21请考虑如何用多条指令代替如下属于NP类的指令：
（1）LEAVE
MOV SP,BP
POP BP
（2）XCHG
MOV ECX,OPRD1
MOV EDX,OPRD2
MOV OPRD1,EDX
MOV OPRD2,ECX
（3）MOVSX
假设为MOVSX EAX,AX
MOV DX,AX
SAR DX,15
SHL EDX,16
MOV DX,AX
MOV EAX,EDX
（4）MOVZX
假设为MOVZX EAX,AX
MOV DX,0
SHL EDX,16
MOV DX,AX
MOV EAX,EDX
题11.22请比较如下左右两边指令片段的效率：
（1）IMUL ECX,16         SHL ECX,4                  SHL更快
（2）IMUL ECX,4           LEA ECX,[ECX*4]        LEA更快
（3）IMUL EAX,7           MOV EBX,EAX           右边的更快
                                      SHL EAX,3
                                      SUB EAX,EBX
乘除指令（如MUL，DIV）属于NP类指令。这类指令不能配对，只能单独在U流水线中执行。
移位位数由立即数决定的移位指令属于PU类指令。
算术逻辑运算指令ADD、SUB，LEA指令，MOV指令属于UV类指令。
题11.23请考虑如何调整"IF THEN ELSE"结构所涉及的基本片段。
把使用频率高的基本片段安排在分支转移指令之后的位置处，也即使得最经常的分支是直行的；把使用频率低的基本片段安排得尽可能离开使用频率高的基本片段。
这样的安排，不仅提高可预测程度，而且可减少把很少执行的代码预取入超高速缓存，还可减少对BTB项的占用。
图11.10给出了一个简单分支所涉及的两个基本片段的调整情况。
         BB1         BB1
         JE L2      JNE L1
L1:   BB2      L2:   BB3
                       JMP L3
L2:   BB3      L1:   BB2
                       JMP L2
                   L3:
设BB3是经常使用的片段，而BB2是不太使用的基本片段。图的左边是调整前的情况，右边是调整后的情况。
尽管调整后的目标代码可能增长，而且还增加了转移指令，但当BB3片段的使用频率明显超过BB2片段使用频率时，调整后的执行效率会较好。
因为，在多数情况下，将直接执行BB3片段。
题11.24如下两个程序片段实现相同的功能，r3 = (r1 e r2) ? b+1 : b。
其中，b是常数，r3L表示r3的低8位寄存器。请对它们作比较：
CMP r1,r2         XOR r3,r3
MOV r3,b+1     CMP r1,r2
Je NEXT            SETe r3L
MOV r3,b         ADD r3,b
用无分支转移的程序片段代替含分支转移的程序片段，从而消除分支。
有两种常用的代替方法：一种是用条件字节设置指令SETcc代替条件转移指令Jcc；另一种方法是用带进位CF操作的ADC或SBB指令代替条件转移指令Jcc。
r3 = (r1 e r2) ? CONST1 : CONST2。
CMP r1,r2                  SUB r1,r2
MOV r3,CONST1       CMP r1,1
JE NEXT                    SBB r3,r3
MOV r3,CONST2      AND r3,CONST1 - CONST2
NEXT:                       ADD r3,CONST2
r3 = r1 cc r2 ? CONST1 : CONST2，
CMP r1,r2                  XOR r3,r3
MOV r3,CONST1       CMP r1,r2
Jcc NEXT                   SETcc r3L
MOV r3,CONST2       DEC r3
NEXT:                        AND r3,CONST2 - CONST1
                                 ADD r3,CONST1
题11.25请考虑如下程序片段所能完成的功能，其中d是常数（1、2、4、8），CONST1和CONST2也是常数。
XOR ECX,ECX
CMP EAX,EBX
SETGE CL
LEA ECX,[ECX*d+ECX+CONST1-CONST2]
ECX = (EAX >= EBX) ? d +1 + CONST1-CONST2 : CONST1-CONST2
题11.26请利用含有ADC或者SBB指令的片段代替如下含条件转移指令的片段：
r3 = r1 < r2 ? CONST+1 : CONST
CMP r1,r2
MOV r3,CONST+1
JL NEXT
MOV r3,CONST
NEXT:
用条件字节设置指令SETcc代替条件转移指令Jcc
XOR r3,r3
CMP r1,r2
SETL r3L
DEC r3
AND r3,-1
ADD r3,CONST + 1
r3 = r1 cc r2 ? CONST1 : CONST2，
CMP r1,r2                  XOR r3,r3
MOV r3,CONST1       CMP r1,r2
Jcc NEXT                   SETcc r3L
MOV r3,CONST2       DEC r3
NEXT:                        AND r3,CONST2 - CONST1
                                 ADD r3,CONST1
r3 = (r1 ne r2) ? const : 0
CMP r1,r2                  SUB r1,r2
MOV r3,CONST         CMP r1,1
JNE NEXT                  MOV r3,0
MOV r3,0                  ADC r3,-1
NEXT:                        AND r3,CONST
r3 = (r1 e r2) ? CONST1 : CONST2。
CMP r1,r2                  SUB r1,r2
MOV r3,CONST1       CMP r1,1
JE NEXT                    SBB r3,r3
MOV r3,CONST2      AND r3,CONST1 - CONST2
NEXT:                       ADD r3,CONST2
题11.27如何尽可能实现数据对齐？为何追求对齐访问可能要浪费部分存储单元？
对2字节数据的访问应在2字节边界处进行，至少不跨越4字节边界；对4字节数据的访问应在4字节边界处进行；对8字节数据的访问应在8字节边界处进行。
在定义变量和缓冲区时，要注意数据对齐。在定义结构类型时，要注意各字段位置的安排，以便结构变量字段的对齐和结构数组的对齐。
例如，如下两个结构类型的定义
STRUAA STRUC
VARB1 DB ?
VARW DW ?
VARD DD ?
VARB2 DB ?
STRUAA ENDS
STRUBB STRUC
VARB1 DB ?
VARB2 DB ? 即使无需VARB2字段，也宜添一个字节以便对齐
VARW DW ?
VARD DD ?
STRUBB ENDS
为了做到对齐访问，可能要浪费部分存储单元。
题11.28请简化如下程序片段：
ADD EAX,4
SHL EAX,2
ADD EBX,EAX         LEA EBX,[EBX+EAX*4+16]
MOV ECX,[EBX]      MOV ECX,[EBX]
题11.29哪些优化方法总是可取的？哪些优化方法要根据具体情况而定，为什么？
以下优化方法总是可取的
提高指令配对的机会包括减少寄存器争用、减少地址形成相关现象、减少超高速缓存体的冲突。
提高动态分支预测正确程度包括调整基本片段位置、代替条件转移指令。
根据超高速缓存的特点，安排数据和组织代码，包括对齐访问、访问数据相对集中。
以下优化方法要根据具体情况而定
选择合适的指令、缩短代码长度
采用一条多时钟的指令代替多条单时钟的指令能有效地缩短目标代码长度。但是，这种方法会减少指令配对机会，在取舍时要综合考虑。
利用LEA指令往往可方便地实现多个操作数相加。并且LEA指令是UV类指令，执行时只要花一个时钟。但要注意，LEA指令可能会增加AGI现象的发生。
题11.30请在80486或者Pentium上调试第9和第10章的例题，并作优化。
添加.686P
.686P
在XP下使用tasm32编译，tlink链接，在DOS下运行

IBM PC 汇编语言程序设计 第五版 Peter Abel 著 沈美明 温冬婵 译
个人计算机的核心是微处理器，它负责处理计算机在算术运算、逻辑运算和控制方面的需求。微处理器起源于20世纪60年代，
当时的研究设计人员所设计的集成电路（IC）是在一块硅“芯片”上把各种电子元件组合成一个部件。
20世纪70年代初期，Intel公司制造出了8008芯片，它宣告了第一代微处理器的诞生。
到了1974年，8008已发展到8080，这是一种通用的、流行的第二代微处理器。1978年，Intel又生产出第三代的8086微处理器，在设计上取得了重要的进展。
8088是8086的改型，它提供一种稍微简单的设计，以及与当时流行的输入输出设备的兼容性。1981年IBM公司选中8088用于它即将推出的个人计算机中。
8086的各种改进版包括80286，80386，80486，Pentium，其他更先进的Pentium，以及Celeron等型号，它们当中的每一种都提供增强了的处理能力。
每种处理器系列都有它自己唯一的指令系统，它们用于控制处理器的操作。例如，从键盘接受输入，在屏幕上显示数据，以及完成算术运算。
这种指令系统（机器语言）非常复杂，在用于程序开发时又令人很难理解。软件供应商为处理器系列提供了一种汇编语言，它以较易于理解的符号代码来表示各种不同的指令。
程序设计的级别
程序设计语言的级别如下：
机器语言
CPU能直接识别并遵照执行的指令称为机器指令。机器指令在形式上表现为二进制编码。
机器语言是用二进制编码的机器指令的集合及一组使用机器指令的规则。
它是CPU能直接识别的唯一语言。只有用机器语言描述的程序，CPU才能直接执行。
汇编语言，它是为专门的处理器系列设计的；这种符号指令直接与机器语言指令一一对应并被汇编成机器语言。
为了克服机器语言的缺点，人们采用便于记忆、并能描述指令功能的符号来表示指令的操作码。
这些符号被称为指令助记符。同时也用符号表示操作数，如CPU的寄存器、存储单元地址等。
用指令助记符、地址符号等符号表示的指令称为汇编格式指令。
汇编语言是汇编格式指令、伪指令的集合及使用这些指令的一组规则。
高级语言，例如C、C++以及Visual BASIC。它们被设计成与特定计算机的技术细节无关的语言，用高级语言编译的语句一般会产生许多低级指令。
汇编语言的优点
通过它可最直接和最有效地操纵机器硬件系统。
另外，使用汇编语言的理由是：
用汇编语言编写的程序比用高级语言编写的程序所要求的存储空间与执行时间将显著减少。
汇编语言使程序员可以完成技术性非常强的任务；而使用高级语言，即使可能做到，恐怕也会非常困难。
虽然大多数软件专家是用高级语言开发新的应用软件的（那样做，程序会比较容易编写和维护），但是对于执行时间要求比较苛刻的部分，常常还要用汇编语言来重新编写。
常驻程序（当其他程序运行的时候，常驻在存储器中的程序）和中断服务例行程序（处理输入与输出的程序）几乎都是用汇编语言开发的。
学习汇编语言需要以下工具：
IBM个人计算机（任何一种型号）或等效的兼容机。
一种Windows 95/98或DOS操作系统并熟悉它的使用。当工作在DOS这种相对简单的操作系统而不是在Windows环境时，学习汇编语言的难度要小一些。
你可以先在DOS中练习，以后再进入到Windows环境中。
一种汇编语言翻译程序。MASM，TASM。
学习汇编语言不要求以下知识：
程序设计语言的知识，尽管这些知识可能有助于你更快地理解一些编程概念。
电子或电路方面的知识。这本书提供了汇编语言程序设计所要求的有关PC体系结构的所有信息。
本书的焦点
为了帮助读者学习汇编语言程序设计，本书首先涉及的是比较简单的硬件和语言方面的情况，然后介绍所需要的指令。同时，本书还力图使程序示例更为清晰。
因此，程序使用了那些最容易理解的指令和方法，尽管专业程序员通常会用较为复杂而又不太清晰的代码来解决类似的问题。
程序还省略了宏指令（将在第21章介绍）。虽然专业程序员广泛地使用宏，但它们在书中的出现会影响对语言原理的学习。
你一旦学会了这些原理，这些专业技能自然就会得到提高。
学习的方法
本书可以起到指导与参考两方面的作用。为了能最有效地利用自己在PC和软件上的投资，你应该仔细地把每一章读一遍并重读那些没有马上搞清楚的内容。
利用所举的程序例子并把它们放在你的计算机上加以执行（或“运行”）。同时，一定要做每章后面的习题。前面8章提供的是汇编语言的一些基本知识。
在学完这些章节之后，你可以继续学习第9，11，12，14，15，16，20，21或22章。24章到26章作为参考。相互关联的章节是：
第8章到第10章（屏幕和键盘操作）。第12章和第13章（算术运算操作）。
第16章到第19章（磁盘处理）。
第22章和第23章（子程序和覆盖）。
在学完这本书的时候，你应该能够：
了解个人计算机的硬件。
了解机器语言代码和十六进制格式。
了解汇编、连接与执行程序的步骤。
用汇编语言编写管理键盘与屏幕，完成算术运算，ASCII与二进制格式之间的转换，实现表格的查找与排序，以及处理磁盘输入与输出的程序。
作为程序调试的一种辅助手段，跟踪机器的执行过程。
编写你自己的宏指令，以便提高编码速度。
连接各个汇编语言程序，形成一个可执行程序。
学习汇编语言并使你的程序正确运行是一种令人兴奋而又有挑战性的体验。对于所付出的时间和精力，你肯定会得到很大的回报。
有关第五版的说明
第五版在以下几方面内容上比以前版本大有提高：
更多的Intel Pentium处理器的特性。
更多的程序举例和习题。更早地引入中断操作。
全文重组和注释的修订。
更多的有关保护方式、传送参数、堆栈使用、寻址方式、显示系统与INT 10H功能、数组处理、子程序以及端口方面的内容。
修订并增加了每章末尾的习题。
第四版的用户应该注意第7章的内容（.COM程序）已和这一版的第5章合并在一起了。另外，第21章是以这样的方法分散的：
有关鼠标处理的内容单独成为一章（第15章），第15章的其余内容（端口、串输入/输出以及发声）与BIOS和程序中断合并在一起，放在第24章。
学生或读者注意：可以在网上查阅所选择习题的答案，下载书中的程序，以及有关实验方面的问题。网址是www.prenhall.com/abel。
感谢
作者感谢所有对本书提供过帮助与合作的人，他们曾为本书先前的版本提出过建议，进行了文稿的审阅和校对。
第一部分PC硬件与软件的基础知识
第1章PC硬件的基本特征
1.1引言
1.2位与字节
1.3二进制数系统
1.4十六进制表示法
1.5ASCII码
1.6PC的组成
1.7内存储器
1.8段与寻址
1.9寄存器
1.10硬件中断
1.11要点
1.12习题
1.1引言
用汇编语言编写一个程序，需要计算机硬件（或体系结构）方面的知识和有关指令系统的详细说明。
本章提供的是关于基本硬件――位、字节、寄存器、处理器以及数据总线的说明。
本书的其余部分阐述指令系统及其使用方法。
计算机主要的内部硬件部件是处理器、存储器和寄存器（寄存器是用来保存地址和数据的专用处理器部件）。
外部硬件部件包括计算机的输入/输出设备，如键盘、显示器、磁盘和CD-ROM。软件包括操作系统、各种程序以及存储在磁盘上的数据文件。
为了执行（或运行）一个程序，系统要把这个程序从外部设备复制到内部存储器（例如，人们在谈到自己的计算机有64MB的存储器时，指的就是内存储器或RAM）中。
处理器执行程序指令，而它的寄存器则要处理所要求的算术运算、数据传送与寻址。
1.2位与字节
计算机存储的基本构造单元是“位”（bit）。一个位可能是“关闭”（of）态，它的值被看作是0；或者它是“开通”（on）态，它的值则被看作是1。
单个的位提供不了更多信息，但一些位要是组合在一起就会有意想不到的作为。
字节
一个字节代表内存储器和外部设备的一个存储单元。每个字节由8个位组成。
8个位为二进制运算和诸如字母A与星号（*）这样一些字符的表示打下了基础。字节中的8位允许有256（2的8次方）个“开”一“关”状态的不同组合，
从所有都为“关”状态（00000000）到所有都为“开”状态（11111111）。例如，字母A的位表示是01000001（41H），而星号的位表示则是00101010（2AH）。
怎么做才能使计算机“知道”位值01000001是代表字母A呢？当你在键盘上键入A时，系统传送这个特定键盘信号到存储器并设置一个字节（在你的程序的一个单元内），
其位值为01000001。你可以按需要在存储器范围内传送该字节的内容，还可以把字母A打印出来或显示在屏幕上。
处理奇偶校验是一种自动的硬件功能，我们不必去管它。一个字节中的各位从右到左是按0到7编号的，如字母A表示如下：
位7   6   5   4   3   2   1   位0
   0   1   0   0   0   0   0   1
处理器还支持一些特定的数据大小：
字。2字节（16位）。
双字。4字节（32位）。
四字。8字节（64位）。
小段。16字节（128位）。
千字节（KB）。2的10次方等于1024（正好是K值）。因此，640K就是640×1024=655360字节。
兆字节（MB）。2的20次方等于1048576，1MB=1048576字节。
在一个字中，各位从右到左的编号是0到15。对于字符串"PC"则表示成最左边的字节为P（01010000=50H），而最右边的字节为C（01000011=43H）。
在存储器中的每个字节都有一个唯一的地址。第一个字节在最低的存储器单元中，编号为0，第二个字节编号为1，等等。
1.5二进制数系统
由于计算机只能辨别位0和位1，所以它只能工作在以2为基数的称为二进制的计数系统中，实际上，二进制位“bit”（“位”）是“Binary digit”的缩写。
位的集合可以表示任何数字的值。二进制数的值是由为1的位及其相关位置所决定的。
如同十进制数一样，位置代表从右到左幂次的上升（但这是2的幂，不是10的幂）。在以下的8位数中，所有位均置为1：
1         1         1         1         1         1         1         1
128      64      32        16       8         4         2         1
7          6        5          4        3         2         1         0
最右边的位设其值为1（2的0次方），向左的下一位设其值为2（2的1次方），再下一位的值为4（2的2次方），以此类推。
在这种情况下，二进制数的值是1+2+4+8+16+32+64+128=255（2的8次方-1）。
让我们考虑一个二进制数01000001的值：
你可以计算它的值1+64=65。但是你可能会想到位值01000001也是字母A。的确，01000001既可以代表65这个数，也可以代表字母A：
如果程序是为算术运算目的而定义与使用数据的，那么位值01000001就是表示一个二进制数，它等于十进制数65。
如果程序是为描述目的而定义与使用数据的，如标题，那么01000001就代表一个字母字符。
当你开始编程的时候，由于要为一个特定目的而定义与使用每个数据项（即为运算目的而用的运算数据以及为显示输出而用的描述数据），所以你就会更清楚地看到这种区别。
实际上，两种用法很少会发生混淆。
二进制数不受8位限制。使用16位（或32位）体系结构的处理机会自动处理16位（或32位）数。对于16位机，所能提供的值在2的16次方-1（即65535）之内；
而对于32位机，所能提供的值可以达到2的32次方-1，即（4294967295）。
二进制算术运算
因为微计算机只以二进制格式完成算术运算，所以一个汇编语言程序员必须熟悉二进制格式与二进制加法。以下4个例子可以简单说明二进制加法：
0+0=0
0+1=1
1+1=10
1+1+1=11
最后两个例子表明有一个1的进位进到下一个（左边）位置。现在，让我们把位值01000001(41H)和00101010(2AH)相加。我们是把字母A和一个星号相加吗？不是的，
这时它们代表的是十进制值65和42。
为了检验二进制和01101011(6BH)实际上就是107，可以把是1的位的值相加。作为另个例子，我们把十进制值60(3CH)与53(35H)以及它们的二进制等效值相加：
再一次检查二进制的和，实际上就是113(71H)。
负二进制数。带符号的二进制数（即一种用于算术运算的数）是这样认定的：如果它的最左边的位是0，它就是正数；反之，带符号的负二进制数的最左边的位是1。
但是，表示一个进制数是负的，不能简单地把最左边的位设置成1就行了，如把01000001（+65=41H）变成11000001，而应该把负二进制值用二进制补码表示法来表示。
也就是说，把一个二进制数表示成负数的规则是：位值求反并加1。例如，利用这一规则求出01000001（或65）的二进制补码：BEH+1=BFH
当带符号的二进制数最左边的位是1时，它是负数，并且处理器会对它做相应的处理。
但是，如果你想用加1的办法求得二进制数10111111的十进制值，你将不会得到65。为了求得一个负二进制数的绝对值，需要采用二进制补码规则，也就是按位求反再加1：
40H+1=41H
为了说明这种做法是正确的，+65与-65的和应该是零。让我们试一下：
BFH+41H=100H
注意，8位数以外还有一位溢出的1。在这个和中，8位的值是全0，而在左边溢出的1则被丢弃了。但是，因为既有进入符号位的进位，又有进位输出，所以认为结果是正确的。
为了处理二进制减法，需要把进行减法的数转换成二进制补码格式，再把它们相加。例如，65减42。42(2AH)的二进制表示是00101010，
它的二进制补妈是11010110(D5H+1=D6H)；把-42加上65就变成这样：D6H+41H=117H
结果23是正确的。注意：又有一个有效的进位输入和符号位输出。
假如对于二进制补码表示法还没有弄清楚，可以考虑以下问题：你必须把一个什么样的值加到二进制数00000001上，才会使它等于00000000呢？
对于十进制数而言，答案将是-1。
00000001的二进制补码是11111111=FFH，所以+1与-1相加等于零：1+FFH=100H
忽略进位的1，你会看到二进制数11111111等于十进制数-1。你还会看到二进制数按值减少的一种模式：
3=03H
2=02H
1=01H
0=00H
-1=FFH
-2=FEH
-3=FDH
实际上，在负二进制数中为0的位可以指出这个数的绝对值：把每个是0的位的位置值看成是1，把这些值求和并加1，也就是按位求反再加1。
当你接触到有关算术运算的第12章和第13章时，你将会发现有关二进制算术运算和负数的更为详细的内容。
1.4十六进制表示法
尽管一个字节可以包含256种位的任意组合，但它们当中许多是无法按标准的ASCII字符显示或打印的。这类字符的例子包括这样一些操作的位组合，
比如制表符（Tab）、回车符（Enter）、换页符（Form Feed）以及换码符（Escape）。
因此，计算机设计人员开发了一种表示二进制数据的简化方法，把每个字节分成两半并把每半个字节的值表示出来。
假设你想看看存储器中四个邻接字节（一个双字）的二进制值的内容。考虑以下四个字节，它们分别表示为二进制与十进制格式：
0101 1001 0011 0101 1010 1001 1100 1110
5       9      3       5       10     9       12    14
由于十进制数10，12和14每个都需要2个数字，让我们采用扩充记数系统，使10=A，11=B，12=C，13=D，14=E，15=F。
这样，记数系统就包括了“数字”0到F，由于有16个这样的数字，所以这一系统便被称为十六进制（或hex）表示法。
下面就是修正过的简化数，它表示出了上面所给字节的内容：
0101 1001 0011 0101 1010 1001 1100 1110
5       9      3       5       A      9       C      E
图1-1给出了十进制数0到15及与其等值的二进制值与十六进制值。
0000         0   0    1000         8   8
0001         1   1    1001         9   9
0010         2   2    1010        10   A
0011         3   3    1011        11   B
0100         4   4    1100        12   C
0101         5   5    1101        13   D
0110         6   6    1110        14   E
0111         7    7   1111        15   F
汇编语言大量使用十六进制格式。一个汇编程序的列表文件中，所有地址、机器码指令以及数据常数的内容都是以十六进制格式表示的。
为了调试程序，你可以使用DEBUG程序，它也是按十六进制格式显示地址与字节内容的。
你很快就能按十六进制格式工作。要记位：十六进制数中紧跟着十六进制F的是十六进制的10，它的十进制值是16。以下是十六进制算术运算的一些简单例子：
7+3=A
6+7=D
F+1=10
F+F=1E
10+30=40
38+18=50
FF+1=100
还要注意：十六进制40等于十进制的64，十六进制100是十进制的256，而十六进制的1000则是十进制的4096。例如38+18=50，注意十六进制的8+8等于10。
为了指明在汇编语言程序中的十六进制数，在这个数的后面你要写上一个“H”，如25H（十进制的37）。
汇编语言要求十六进制数永远是用十进制数字0~9作为开始，所以就要把B8H写成0B8H。
在本书中，十六进制的值是用数的前面放一个“hex”或者数后面跟一个“H”来表示的（如hex4C或4CH）；
二进制的值是用放一个“binary”在数的前面或者数的后而跟一个“B”来表示（如binary 01001100或01001100B）；而十进制值就简单地用一个数表示（如76）。
如果根据上下文能够明确地确定该基数值是十进制还是十六进制，也可以不必像上述那样标得那么清楚。
附录A给出了如何把十六进制数转换成十进制数格式，或者进行相反转换的说明。
1.5ASCII码
PC中的数据可以按数（用于算术运算的二进制数据）或字母数字（字符与描述性数据）来分类。
字母类型的数据通常用于键盘输入，屏幕与打印机输出。为了使数据表示标准化，微计算机设计人员采用ASCII（美国标准信息交换代码）码。
由于一个字节包含8位，所以PC使用8位ASCII码，它可以提供2的8次方=256个字符，其中许多字符是用在键盘上的。
例如，你已经见过的字母A的ASCII码：01000001（hex41）。幸运的是，你不必记住这些ASCIl码；当需要的时候，你可以参阅附录B给出的完整的表，
而且第8章还说明了在屏幕上如何把它们当中的大多数显示出来。
1.6PC的组成
PC的主要组成部分是它的系统板（或称主板）。它包括处理器、协处理器、主存储器、接插件以及为可选电路卡用的扩展槽。
这些槽和接插件为下列部件提供了出入口，比如只读存储器（ROM）、随机存取存储器（RAM）、硬盘、CD-ROM设备、
附加的主存储器、显示设备、键盘、鼠标、并行与串行设备、声音合成器以及高速缓冲存储器等。处理器利用高速缓冲存储器，减少对较低速主存储器的访问。
总线（BUS）用一些附加在系统板的线把各个部件连接起来。它在处理器、存储器和外部设备之间传送数据，有效地处理数据流量。
例如当程序需要从外部设备读取数据时，处理器确定已送达的数据要存放在存储器的哪个地址中，并把该地址放到地址总线上。
然后，存储器部件把数据放到数据总线上，并通知处理器数据已经准备就绪。现在，处理器从数据总线上取来数据，存入存储器的地址单元中。
电源把标准的220V交流转换成直流并降低电压，使之符合计算机的要求。电源的功率通常约为300W。
处理器
PC的大脑是处理器（也称为中央处理器或CPU），它是建立在Intel8086系列的基础上的，用来完成所有的指令执行与数据处理。
各种处理器的速度、存储器容量、寄存器以及数据总线是不相同的。内部时钟用来同步与控制所有的处理器操作。
基本时间单位――时钟周期是按MHz（每秒钟百万周期）计算的。以下是各种Intel处理器的简要介绍：
1.8088
有16位寄存器和8位数据总线，并且最大可以寻址到1MB内存。虽然寄存器一次可以处理二个字节，但数据总线一次只能传送一个字节。
该处理器是在实模式（real mode）下运行的，也就是说，用段寄存器中的实际（“实”）地址，一次运行一个程序。
2.8086
类似于8088，但有16位数据总线，运行速度较快。
3.80286比前两种处理器运行速度都快，具有附加的能力，并且最大可寻址到16MB。
这种处理器及其后继者可以在实模式或保护模式（Protected mode）下工作，保护模式使操作系统能像Windows一样执行多任务（同时运行一个以上的作业），
而且对它们彼此加以保护。
4.80386
有32位寄存器和32位的数据总线，并且最大可寻址达4GB的存储器。处理器不但支持保护模式，而且还支持虚模式（virtual mode），从而可以把存储器的一部分交换到磁盘上。
用这种方法，程序在并发运行时就有了操作空间。
5.80486
同样有32位寄存器和32位的数据总线，并增加了快速的高速缓冲存储器，使处理器可以存放最近使用的指令与数据的副本。
当直接使用高速缓冲存储器而不必去访问较慢的主存储器时，处理器可以工作得更快。
6.Pentium
有32位寄存器和64位的数据总线，还有分别用于数据和存储器的各自的高速缓冲存储器（Intel采用“Pentium”的名字是因为和那些数字编号不同，名字是有版权的）。
它的超标量设计使处理器能在每个时钟周期内译码并执行多条指令。
7.Pentium II和Pentium III
有双独立总线设计，使到达高速缓存和内存储器能有各自独立的通路。以前的处理器与在系统板上的高速缓冲存储器连接时会产生延迟，
而这些处理器则是以64位宽的总线连接到个内部的高速缓冲存储器上。
80486之前的处理器都采用通常所说的单级流水线，这就限制它们只有在完成一条指令后才能开始执行下一条指令。
流水线所涉及的方法是处理器要把一条指令分成利用不同资源的顺序的一些步骤。Pentium有5级流水线结构，PentiumII有12级超流水线结构。
这一特性使它们能并行地运行许多操作。
设计人员所面临的问题是：由于处理器的运行速度要比存储器的动作快得多，所以它不得不等待存储器提供指令。
为了解决这个问题，每种先进的处理器就要有更多的动态执行能力。例如，借助于多路的转移预测，处理器先行几步去预测下一步要做什么。
执行部件与总线接口部件
如图1-2所示，处理器划分成两个逻辑部件：执行部件（EU）和总线接口部件（BIU）。EU的作用是执行指令，而BIU则是给EU提供指令和数据。
EU包含算术逻辑部件（ALU）、控制部件（CU）以及几个寄存器。这些部件用于执行指令和算术与逻辑操作。
BIU的最重要功能是管理总线控制部件、段寄存器和指令队列。BIU控制传送数据到EU、存储器和外部输入/输出设备传送数据的总线，段寄存器则控制存储器寻址。
BIU另外一个功能是取指令。因为正在执行的程序的指令是在存储器中的，所以BU必须从存储器取出指令，然后把它放入指令队列中，队列规模的不同取决于处理器。
这一特性使BIU能做到预取指令，以便始终能有一个准备好执行的指令队列。
EU和BIU是并行工作的，同时BIU保持领先一步。当EU需要从存储器或I/O设备取数据时，它会通知BIU。
此外，EU需要来自指令队列的机器指令。队列顶部的指令是当前可执行的指令，当EU正在执行一条指令时，BIU就从存储器预取下一条指令。
这种预取能与执行重叠并提高了处理速度。程序员不能访问处理器这些部件中的任何一个部件。
1.7内存储器
在PC中有两种类型的内存储器，即随机存取存储器（RAM）和只读存储器（ROM）。存储器中的字节是顺序编号的，从00开始使得每个单元都有它唯一编号的地址。
图1-3作为一个简单例子所表示的是8086类型PC的物理存储器映像。在存储器的1MB中，前面640KB是基本RAM，它们当中的大多数你是可以使用的。
在存储器最底部的中断向量表会在本章稍后加以说明，BIOS数据区在第3章和第24章讨论，而视频显示区则要在第9章阐述。
起始地址                                    用途
十进制 十六进制
960KB F0000                  64KB基本系统ROM
                                      192KB存储器扩充区
768KB C0000                  （ROM）
                                      128KB视频显示区
640KB A0000                  （RAM）
                                       640KB存储器（RAM）
                                       BIOS数据区
zero 00000                      中断向士表
图1-3基本存储器映像
ROM
ROM是一种专门的存储器芯片，顾名思义，它是只读的。因为指令与数据是永久性地“烧进”芯片中的，所以它们是不能修改的。
地址从768KB开始的ROM基本输入/输出系统（BIOS）管理输入/输出设备，如硬盘控制器。
从960KB开始的ROM控制计算机的基本功能，如接通电源后的自检，图形用的点模式，以及磁盘的自装入程序。
当你接通电源后，ROM完成各种检查并把专门的系统数据从磁盘装入RAM。
RAM
程序员主要关心的是RAM，把它叫做“读一写存储器”可能更贴切一些。RAM可以当作程序暂时存储与执行的“工作单”来使用。
当你接通电源以后，ROM通过引导程序把操作系统的一部分装入RAM。然后就可以要求它完成动作，如从磁盘上把程序装入到RAM中。
你的程序在RAM中执行并通常会在屏幕、打印机或磁盘上产生输出。当完成以后，你可以要求系统把另一程序装入到RAM中，对以前的程序进行覆盖写入。
关闭电源时，会抹掉RAM的内容，但对ROM没有影响。因此，如果你已经改变了文档中的数据，那么在关闭PC之前，你就需要把它先保存在磁盘上。
在有关RAM的进一步的讨论中，将使用存储器这个通用术语。
通过寻址找到存储器中的数据
根据型号，处理器一次可以存取存储器中一个或多个字节。考虑一个十进制数1321。这个值的十六进制表示是0529H，需要存储器的二个字节或一个字。
它由高位（最高有效）字节05和低位（最低有效）字节29组成。处理器在存储器中是按相反字节顺序存放数据的：低位字节在低的存储器地址里，高位字节在高的存储器地址里。
例如，处理器把值0529H从寄有器传送到存储器地址04A26H和04A27H处，就像下面这样：
寄存器   05                  29

存储器   29                  05
            04A26H         04A27H
处理器要求存储器中的数值数据按相反字节顺序存放，并且要按这种方法处理数据。当处理器从存储器取回该字节时，再把字节顺序反一下，
把它们正确地重新按hex 0529存放到寄存器中。虽然这一特性是完全自动的，但在编写和测试汇编语言程序时，你一定要对它加以注意。
当用汇编语言编程时，你必须清楚存储器单元的地址和它的内容并不是一回事。在前面的例子中，地址04A26H的内容是29，而地址04A27H的内容是05。
寻址方案有两种类型：
1.绝对地址寻址，比如04A26H是一个20位的值，它直接对应存储器中的指定单元。
2.段：偏移地址寻址，把段的起始地址和偏移地址组合在一起来寻址。下一节会详细介绍这一方案。
1.8段与寻址
段是在程序中定义的一个专门区域，它是个包括代码、数据以及堆栈的区域。段是从小段边界（paragraph boundary）即能被16或hex10除尽的单元开始的。
虽然段可以位于存储器的几乎所有地方并在实模式下可以多达64KB，但它只需要程序所要用的那么多空间，也就是数据与处理这些数据的指令所占用的空间。
当一条指令往一个段寄存器中装入段地址时，会自动移掉最右边的4个0。
你可以定义任何数据的段；为了访问一个特定的段，只需要适当改变段寄存器中的地址就可以了。在实模式下，三个主要的段是代码段、数据段和堆栈段：
代码段包括要执行的机器指令。典型地，第一条可执行的指令是在这个段的起点，而操作系统连接到开始执行程序的单元。
顾名思义，代码段（CS）寄存器寻址代码段。数据段包括程序所定义的数据，常量和工作区。数据段（DS）寄存器寻址数据段。
堆栈段包括程序需要暂存的任何数据与地址，或由你自己“调用”的子程序所用的数据与地址。堆栈段（SS）寄存器寻址堆栈段。
1.8.1段边界
段寄存器的大小是16位，包含段的起始地址。图1-4说明了有关SS、DS和CS寄存器以及它们与堆栈段、数据段和代码段关系（寄存器与段不必要按顺序表示）。
其他的段寄存器还有ES（附加段寄存器），80386和更新的处理器中还有FS与GS寄存器，它们为存储数据提供了附加段。
如前所述，一个段起始于小段边界，它是一个可以被十进制16或hex10除尽的地址。
假定一个数据段的起点是存储器单元038E0H，由于在这种及所有其他情况下，最右边十六进制数位都是0，所以存放数字0到段寄存器中是没有必要的。
因此，038E0H是以038E存放在寄存器中的，最右边的4位被移掉了。在适当的场合，本书使用方括号指明最右边的十六进制的0，如038E[0]。
1.8.2段偏移值
在一个程序中，段范围内的所有存储单元都是相对于段起始地址的。我们把一个段内从段地址到另一个单元以字节为单位的距离称为偏移值（或位移量）。
在实模式下，2字节（16位）的偏移值的范围可以从0000H到FFFFH，或是从0到65535。
因此，代码段的第一个字节在偏移值00处，第二个字节在偏移值01处，依此类推，直到偏移值65535。
为了访问一个段内的存储器任何存储单元，处理器要把在段寄存器中的段地址与该单元的偏移值（即它与段起始点的字节距离）组合起来。
假设数据段的起点是在038E0H单元，DS寄存器包含数据段的段地址038E[0]H，而指令访问的单元距数据段起点的偏移值是0032H字节。
为了访问所要求的单元，处理器就要把数据段的地址和偏移值组合在一起：
038E0+0032=03912H
因此，由指令访问的字节的实际存储单元是03912H。注意：程序包含一个或多个段，它们可以从存储器的任何地方开始，大小也可以不同，并且可以排成任何序列。
你仅仅会偶然涉及到段地址和偏移值，这是因为汇编程序和处理器会处理它们。但是，你还需要知道它们的含义和用法。
1.9寄存器
处理器的寄存器用于控制指令执行，存储器寻址，并提供算术运算能力。程序按名字访问寄存器，如CS，DS，以及SS。
在寄存器中的位（如同在字节中的位一样）一般是从0开始从右到左编号，如：
...15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
1.9.1段寄存器
段寄存器为一个称为当前段的区提供寻址。PC系列所用的lntel处理器提供不同的寻址能力。
1.8086/8088寻址
这些处理器的段寄存器长度是16位，工作在实模式下。因为段地址是在小段边界上的（可被16或hex10除尽的），它的地址最右边4位是0。
如前所述，段地址是存放在段寄存器中的，而且处理器移掉了最右边的4个0位，所以十六进制的nnnn0就变成了nnnn。
例如，十六进制地址038E0是按038E存放在段寄存器中的。处理器承担了最右边的4位，所以段寄存器的有效长度是20位。
FFFF[0]H的允许子址范围最大值达到1048560个字节。如果你不能确定，那么每个hex F译码成二进制的1111，考虑到最右边的4个0位，所以再加上4位为1的值。
2.80286寻址
在实模式下，80286处理器处理寻址和8086是一样的。在保护模式下，24位的寻址方案提供的寻址范围达到FFFFF[0]，即16MB。
段寄存器作为选择器，用来从存储器中存取24位段地址。保护模式允许处理器实现多任务，这时它能从正在执行的任务（或程序）转换到另一任务。
系统必须能够保护存储器中的每个任务不受其他任务的影响。
3.80386/486/Pentium寻址
在实模式下，这些处理器也能处理像8086那样多的寻址。在保护模式下，处理器用48位寻址，这时允许寻址的段可达4GB。
16位的段寄存器作为选择器用来从存储器中存取32位段地址。6个段寄存器是CS、DS、SS、ES、FS以及GS。
1.CS寄存器
有效程序代码段的起始地址。这个段地址加上在指令指针（IP）寄存器中的偏移值，就指明了为执行指令所要取得的指令地址。在通常的编程中，不需要直接访问这个寄存器。
2.DS寄存器
包含程序数据段的起始地址。指令使用这一地址放置数据；该地址加上在指令中的偏移值，就可以访问位于数据段中的指定字节单元。
3.SS寄存器
容许在存储器中实现堆栈，程序可用来暂时存放地址和数据。系统在SS寄存器中存放程序堆栈段的起始地址。
这一段地址加上堆栈指针（SP）寄存器中的偏移值，就指明了正被寻址的堆栈中的当前字。在通常的编程中，不需要直接访问SS寄存器。
4.ES 寄存器
在某些串（字符数据）操作中，用于存储器寻址。在这方面，ES（附加段）寄存器是和DI（变址）寄存器相关联的。
如果程序需要使用ES，你就必须用一个适当的段地址将它初始化。
5.FS和GS寄存器
是80386为处理存储器请求而采用的备用的附加段寄存器。
1.9.2指针寄存器
指针寄存器有32位的EIP、ESP和EBP；最右边16位的部分分别是IP、SP和BP。
1.指令指针（IP）寄存器
16位的IP寄存器包含要执行的下一条指令的偏移地址。IP是和CS寄存器相关联的（如CS:IP），其中IP指明现在正在执行的代码段内的当前指令。
通常是不能在程序中访问IP的，但你可以改变它的值，例如：在使用DEBUG程序去测试一个程序的时候。
80386采用了一个扩充的32位IP，叫做EIP。
在以下的例子中，CS含有39B4[0]H，IP含有514H。为了找到要执行的下条指令，处理器要把在CS中的地址与在IP中的偏移值组合在一起：
39B40H+0514H=3A054H
对于每条执行的指令，处理器都要改变在IP中的偏移值，以便IP能有效地指向每个执行步骤。
SP（堆栈指针）和BP（基址指针）寄存器是与SS寄存器相关联的，并且容许系统访问在堆栈段中的数据。处理器自动管理这些寄存器。
2.堆栈指针（SP）寄存器
16位的SP寄存器提供一个偏移值，当它和SS寄存器相关联时（SS:SP），它可以访问在堆栈中正在处理的当前字。80386采用了一个扩充的32位堆栈指针，即ESP寄存器。
在下面的例子中，SS寄存器含有段地址4BB3[0]H，SP含有偏移值412H，为了找到在堆栈中正在处理的当前字，处理器要把SS中的地址与SP中的偏移值加以组合：
4BB30H+0412H=4BF42H
3.基址指针（BP）寄存器
16位的BP简化了对参数的访问，这些参数是程序通过堆栈传递的数据和地址。处理器把在SS中的地址和在BP中的偏移值组合起来，BP还可以和DI或SI组合起来，
作为用于特殊寻址的基址寄存器。80386采用了扩充的32位BP，即EBP寄存器。
1.9.3通用寄存器
通用寄存器是32位的EAX，EBX，ECX，以及EDX；最右边的16位部分分别是AX，BX，CX以及DX。例如，AX是EAX最右边的16位。
AX本身由二部分组成：最左边8位（“高”的部分）称为AH；最右边的8位（“低”的部分）称为AL。
这一特性允许你去访问任何部分一EAX，AX，AH，或AL一按照名称分别处理双字，字或字节。
以下的汇编语言指令说明把0分别传送到AX，BH和ECX寄存器：
MOV AX,00H
MOV BH,00
MOV ECX,00
1.AX寄存器
AX――主累加器，用于有关输入/输出和大多数算术运算操作。例如：乘法，除法及换码指令都使用AX。
此外，某些指令如果访问AX而不是访问其他寄存器就会生成更为有效的机器代码。
8位的AH和AL分别是16位AX的左边的和右边的部分，而AX则是32位的EAX的最右边的16位。
2.BX寄存器
BX即基址寄存器，它只是个通用寄存器，可以用作扩展寻址的变址。BX另一个用途是做计算。BX还可以和DI或SI组合起来作为专用于寻址的基址寄存器。
8位的BH和BL分别是16位的BX的左边与右边两部分，而BX则是32位的EBX最右边的16位。
3.CX寄存器
CX即计数寄存器。它可以包含控制循环的重复次数的值或左、右移位的次数。还可以用CX进行许多计算。8位的CH和CL分别是16位的CX左边与右边的两部分，
而CX则是32位的ECX最右边16位。
4.DX寄存器
DX即数据寄存器。一些输入/输出操作需要使用它，涉及很大值的乘法与除法操作是把DX和AX配成对合在一起使用。8位的DH和DL分别是16位的DX的左边与右边两部分，
而DX则是32位的EDX的最右边16位。
通用寄存器可以用作8位、16位或32位的加法与减法：
MOV EAX,225
ADD AX,CX
SUB BL,AL
1.9.4变址寄存器
变址寄存器是32位的ESI和EDI，它们最右边的16位部分分别是SI和DI。这些寄存器可用于变址寻址，并也可用于某些加法与减法中。
1.SI寄存器
16位的源变址寄存器是某些串（字符）处理操作所需要的。在本书中，SI是和DS寄存器联合在起的。80386采用了32位扩充寄存器ESI。
2.DI寄存器
16位的目的变址寄存器也是某些串操作所需要的。在本书中，DI是和ES寄有器联合在一起的。80386采用了32位扩充寄存器EDI。
1.9.5标志寄存器。
32位标志寄存器所包含的位用来指明不同的活动状态，这种标志寄存器最右边的16位部分是标志寄存器，这16位中的9位是指明计算机的当前状态和处理结果的。
许多含有比较与算术运算的指令会改变标志的状态，这样，某些指令就可以通过测试某一位来确定下一步的动作。
以下简要地讨论一下这些公用的标志位：
OF（溢出）指出在算术运算后高阶（最左边）位的溢出。
DF（方向）确定传送或比较串（字符）数据时的左右方向。
IF（中断）指明所有外部中断（如键盘输入）是处理还是不去管它。
TF（陷阱）允许处理器以单步方式工作。调试程序（如DEBUG）要设置陷阱标志，便于一步步地通过每次执行单条指令的办法，去检查它对寄存器和存储器的影响、
SF（符号）包含一次算术运算操作的结果的符号（0=正，1=负）。
ZF（零）指明算术运算或比较操作的结果（0等于结果为非零，1等于结果为零）。
AF（辅助进位）包含在算术运算操作中第3位到第4位的进位输出，用于专门的算术运算。
PF（奇偶）指明在操作产生的结果中为1的位的数量。是偶数，则奇偶性为偶；是奇数，则奇偶性为奇。
CF（进位）包含一个算术运算操作后，来自高阶（最左边）位的进位；还包含移位或循环操作最后位的内容。
标志寄存器中的标志位的位置如下（你不必记住它们）：
31          19   18   17   16  15  14  13 12   11   10  9  8    7   6   5  4   3  2   1  0
                    AC  VM  RF  0   NT  IOPL    OF  DF IF TF  SF ZF  0 AF 0  PF     CF
对于比较和算术运算操作而言与汇编程序最有关系的标志，是OF，SF，ZF，以及CF。
DF用于串操作的定向。一些其他的标志作为内部使用，主要和保护模式有关。第7章会对标志寄存器作更详细的说明。
1.10硬件中断
某些事件会使处理器挂起当前的操作并为引起中断的原因去做一些事情。通常，事件是正常的和预期的，比如来自键盘的输入请求。
处理器中断当前的操作，调用BIOS的例行程序去处理键盘请求，然后返回到被中断的程序。另外一些中断可能是危险的，比如企图除以零，这会造成系统终止处理过程。
另一类中断是软件中断，由程序本身发出一个请求，比如要在屏幕上显示数据。系统要再次进行控制，处理中断，然后返回到被中断的程序。
1.11要点
处理器只能识别一个位是0（“关闭”）还是1（“开通”），并只能完成二进制算术运算。
二进制数的值是由它的位位置决定的。例如，二进制值1101等于（从右到左）1+0+4+8，即13。
负的二进制数是用二进制补码来表示的：它的原码表达式按位求反，然后加1。
一个存储器单元是一个字节，由8个位组成。2个相邻的字节组成一个字，4个相邻的字节组成一个双字。
十六进制格式是一种速记的记数法，用来表示4位的组。十六进制数字0～9和A~F代表二进制值0000到1111。
字符格式采用ASCII码表示数据。
PC的核心―处理器按相反字节顺序，以字和双字的形式在存储器中存放数值数据。
内存储器的两种类型是ROM和RAM。
汇编语言程序由一个或多个段组成：堆栈段用于保存返回地址，数据段用于定义数据和工作区，而代码段则是用于可执行的指令。
在段范围内的单元被表示成相对于段起始地址的偏移值。
CS，DS和SS寄存器分别用来对代码段、数据段和堆栈段寻址。
CS:IP的含义是段：下一条要执行的指令的偏移地址。
SP和BP指针寄存器是与SS寄存器联合在一起的，并且允许系统访问堆栈中的数据。
AX、BX、CX以及DX是系统承担繁重任务的通用寄存器。最左边的字节是“高”位部分，而最右边的字节是“低”位部分。
AX（主累加器）用于输入/输出和大多数算术运算。BX还可以用作扩展寻址的变址。CX用于计算与专用计数，DX也可以用于计算。
EAX、EBX、ECX以及EDX是32位的通用寄存器。
SI和DI变址寄存器可以用于扩展寻址，也可以用于加法与减法。这些寄存器还用于某些串（字符）操作。
标志寄存器指明处理器的当前状态和执行指令的结果。
1.12习题
1-1.计算机存储的基本构件是什么？它的两个状态是什么？
计算机存储的基本构造单元是“位”（bit）。一个位可能是0（“关闭”）还是1（“开通”）。
1-2.在1-1题中提到的8个bit的集合是什么？
一个字节代表内存储器和外部设备的一个存储单元。每个字节由8个位组成。2个相邻的字节组成一个字，4个相邻的字节组成一个双字。
1-3.给出以下数据项的长度：（a）小段，（b）字，（c）双字，（d）字节，（e）千字节。
字节。8位
字。2字节（16位）。
双字。4字节（32位）。
四字。8字节（64位）。
小段。16字节（128位）。
千字节（KB）。2的10次方等于1024（正好是K值）。
兆字节（MB）。2的20次方等于1048576，1MB=1048576字节。
1-4.将以下十进制数转换成二进制格式：（a）7，（b）15，（c）25，（d）28，（e）33。
7=0111，15=1111，25=11001，28=11100，33=100001
1-5.将以下8位二进制数相加：
（a）00101101（b）00110110（c）00101111（d）01111111
        00000101         00111001        00000001         01010101
2DH+05H=32H，36H+39H=6FH，2FH+01H=30H，7FH+55H=D4H
1-6.把1-5题中的每个二进制数及它们的和转换成十进制值并检查所得的和是否正确。
2DH+05H=32H=50，36H+39H=6FH=111，2FH+01H=30H=48，7FH+55H=D4H=212
1-7.给出以下二进制数的二进制补码：（a）00110110，（b）00111101，（c）01111100，（d）00000000。
36H->C9H+1=CAH，3DH->C2H+1=C3H，7CH->83H+1=84H，00H->FFH+1=100H
1-8.把以下负的二进制数转换成正的二进制值：（a）11001100，（b）10110111，（c）10101010，（d）11111111。
CCH->33H+1=34H=52，B7H->48H+1=49H=73，AAH->55H+1=56H=86，FFH->00H+1=01H=1
1-9.（a）将以下2个8位二进制数相加：11001011和01110111。（b）8位和的十进制值是多少？（c）把二进制值转换成十进制值并检查和是否正确。
CBH+77H=142H=322
1-10.给出以下值的十六进制表示：（a）ASCII字母R，（b）ASCII数7，（c）二进制数01110101，（d）二进制数01110110。
'R'=52H，'7'=37H，75H，76H
1-11.把以下十六进制数相加：
（a）13B4（b）53CD（c）8798（d）DCBE（e）FDAC
      +0033      +0004       +0777      +35B5       +0BAF
13E7H，53D1H，8F0FH，11273H，1095BH
1-12.确定以下十进制数的十六进制表示。转换方法参考附录A。并把十六进制值转换为二进制值后把1的位相加，检查结果正确性。
（a）23，（b）37，（c）75，（d）255，（e）4，095，（f）56217。
17H，25H，4BH，FFH，FFFH，DB99H
1-13.参照附录B，给出以下ASCII字符的位配置：（a）G，（b）S，（c）#，（d）6，（e）*，（f）冒号（：）。
47H，53H，23H，36H，2AH，3AH
1-14.处理器的主要功能是什么？
处理器完成所有的指令执行与数据处理。
1-15.区别PC存储器的两种主要类型并指出它们的主要用途。
在PC中有两种类型的内存储器，即随机存取存储器（RAM）和只读存储器（ROM）。
ROM是只读的，无法修改ROM中的指令与数据。
地址从768KB开始的ROM基本输入/输出系统（BIOS）管理输入/输出设备，如硬盘控制器。
地址从960KB开始的ROM控制计算机的基本功能，如接通电源后的自检。接通电源后，ROM完成各种检查并把专门的系统数据从磁盘装入RAM。
RAM是可读可写的，可以用来暂时存储程序和数据。关闭电源时，会抹掉RAM的内容，但对ROM没有影响。
1-16.说明处理器在存储器中是如何存放以下十六进制值的：（a）2AB5，（B）0AD4C2。
高地址          0A
             2A   D4
低地址   B5   C2
1-17.解释以下术语：（a）段，（b）偏移值，（c）地址边界。
段是在程序中定义的一个专门区域，一个段起始于小段边界，它是一个可以被十进制16或hex10除尽的地址。
在一个程序中，段范围内的所有存储单元都是相对于段起始地址的。我们把一个段内从段地址到另一个单元以字节为单位的距离称为偏移值（或位移量）。
为了访问一个段内的存储器任何存储单元，处理器要把在段寄存器中的段地址与该单元的偏移值（即它与段起始点的字节距离）组合起来。
假设数据段的起点是在038E0H单元，DS寄存器包含数据段的段地址038E[0]H，而指令访问的单元距数据段起点的偏移值是0032H字节。
为了访问所要求的单元，处理器就要把数据段的地址和偏移值组合在一起：
038E0+0032=03912H
因此，由指令访问的字节的实际存储单元是03912H。
1-18.（a）段的三种类型是什么？（b）它们的最大范围是多少？（c）它们的起始地址是什么？
在实模式下，三个主要的段是代码段、数据段和堆栈段。代码段包括要执行的机器指令。数据段包括程序需要用的数据。堆栈段包括程序需要暂存的数据。
在实模式下，2字节（16位）的偏移值的范围是从0000H到FFFFH，也就是从0到65535。
段的起始地址是一个可以被十进制16或hex10除尽的地址。
1-19.CS，DS，ES以及SS段寄存器的用途各是什么？
代码段寄存器（CS）存放代码段的起始地址。这个段地址加上指令指针寄存器（IP）中的偏移值寻址代码段。
数据段寄存器（DS）存放数据段的起始地址。这个段地址加上相应的偏移值寻址数据段。
堆栈段（SS）寄存器存放堆栈段的起始地址。这个段地址加上堆栈指针寄存器（SP）中的偏移值寻址堆栈段。
附加段寄存器（ES）存放附加段的起始地址。这个段地址加上相应的偏移值寻址附加段。
1-20.（a）SS的内容是2AB4[0]H和SP的内容是24H，（b）CS的内容是2BC3[0]H和IP的内容是3AH，求它们所形成的绝对地址。
2AB40H+24H=2AB64H，2BC30H+3AH=2BC6AH
1-21.说明用于以下目的的是哪些寄存器：（a）循环计数，（b）乘法与除法，（c）对段寻址，（d）指明零结果，（e）一条将要执行指令的偏移地址，（f）加法与减法。
CX，DX和AX，BX、SI、DI、BP，标志寄存器，IP，AX、BX、CX、DX、SI、DI、BP、SP
1-22.表示出EBX寄存器以及BH、BL和BX在其中的位置并说明它们的大小。
80386有8个32位通用寄存器，这8个寄存器分别定名为EAX、EBX、ECX、EDX、EBP、ESP、ESI和EDI。
这些通用寄存器的低16位可以作为16位的寄存器独立存取，并把它们分别定名为AX、BX、CX、DX、BP、SP、SI和DI。
在存取这些16位的寄存器时，相应的32位通用寄存器的高16位不受影响。
AX、BX、CX和DX这4个16位的数据寄存器的高8位和低8位可以被独立存取，分别命名为AH、AL、BH、BL、CH、CL、DH和DL。
在存取这些8位寄存器时，相应的16位寄存器的其它位不受影响，相应的通用寄存器的其它位也不受影响。
1-23.用汇编语言指令编码，将传送（MOV）值50到以下每个寄存器中：（a）CX，（b）CH，（c）CL，（d）ECX。
MOV CX,50
MOV CH,50
MOV CL,50
MOV ECX,50
1-24.用指令编码，把28的值加（ADD）到以下寄存器中：（a）CL，（b）CH，（c）CX，（d）ECX。
ADD CL,28
ADD CH,28
ADD CX,28
ADD ECX,28
1-25.指出受以下动作影响的标志：（a）算术运算的和是零，（b）算术运算的和是负的，（c）串数据由左向右传送。
OF（溢出）指出在算术运算后高阶（最左边）位的溢出。
DF（方向）确定传送或比较串（字符）数据时的左右方向。
SF（符号）包含一次算术运算操作的结果的符号（0=正，1=负）。
ZF（零）指明算术运算或比较操作的结果（0等于结果为非零，1等于结果为零）。
AF（辅助进位）包含在算术运算操作中第3位到第4位的进位输出，用于专门的算术运算。
PF（奇偶）指明在操作产生的结果中为1的位的数量。是偶数，则奇偶性为偶；是奇数，则奇偶性为奇。
CF（进位）包含一个算术运算操作后，来自高阶（最左边）位的进位；还包含移位或循环操作最后位的内容。
OF、SF、ZF、AF、PF、CF，DF
第2章指令寻址与执行
2.1引言
2.2操作系统的特点
2.3BIOS引导过程
2.4系统程序的装入程序
2.5堆栈
2.6指令的执行与寻址
2.7指令的操作数
2.8保护模式
2.9要点
2.10习题
目的：说明在PC上装入与执行程序的一般要求。
2.1引言
在这一章里，我们讨论PC的软件环境：操作系统的功能和其主要组成部分。我们要探讨引导过程（当你的计算机加电时，系统本身是如何装入的），
要研究系统是如何装入将要执行的程序，系统怎样使用堆栈，以及在代码段中一条指令是如何引用数据段中的数据的。
本章完成对PC硬件和软件的基本阐述，并且使你能进入到第3章，在那一章里，你可以把简单的程序键入到存储器中并一步步地执行它们。
2.2操作系统的特点
操作系统提供通用地、设备无关地访问计算机资源（如键盘、屏幕和磁盘驱动器这样的一些设备）的能力。
设备无关的意思是，你不必专门地去访问设备，因为系统可以在设备级处理输入/输出（I/O）操作，与要求这一操作的程序无关。
与我们有关的一些功能如下：
文件管理。操作系统维护在系统磁盘上的目录与文件。程序负责建立与修改文件，而系统则负责管理它们在磁盘上的定位。
输入/输出。程序需要借助中断从系统输入数据或向系统输出数据。程序员可以减轻在I/O低层次上的编码负担。
程序装入。当用户或程序要求执行程序时，程序的装入程序会处理从磁盘上取出程序，读入存储器中，以及为了执行程序而进行的初始化等这样些步骤。
存储器管理。当程序的装入程序为执行一个程序而把它从磁盘装入到存储器时，它会为程序代码和数据在存储器中分配足够大的空间。
程序可以在它的存储区里处理数据，可以释放不需要的存储区，而且还可以要求追加存储区。
中断处理。系统可借助于中断访问外部设备。
2.3BIOS引导过程
接通计算机电源的时候，会使处理器进入复位状态，把所有存储单元清除为0，完成存储器的奇偶校验，以及把CS寄存器设置成段地址FFFF[0]H，并把IP寄存器设置成偏移值为0。
因此，第一条要执行的指令是在由CS:IP对所形成的地址里的，这个地址是FFFF0H，是ROM中的BIOS入口点。
BIOS包含在ROM中的一组例行程序提供对设备的支持。起始单元为FFFF0H的BIOS例行程序检查各种端口去识别与初始化一些设备，
这些设备被连接到计算机上并提供在设备上进行读写的各种服务。因此，BIOS要建立两个数据区：
1.中断向最表。它开始于低端存储器的0单元并包含256个4字节地址，其格式是：段：偏移值。BIOS和操作系统在中断发生时使用这些地址。
2.BIOS数据区。它开始于40[0]单元，大部分与所连接设备的状态有关。我们将在第24章详细讨论。
下一步BIOS要确定磁盘是否包含现存的系统文件，如果有，它就要访问来自磁盘的引导装入程序。
由这个程序把系统文件从磁盘装入内存，并把控制权交给它们。系统文件包括设备驱动程序和其他硬件专用代码。
这些模块初始化内部系统表和中断向量表的系统部分。操作系统的一项任务是当需要访问BIOS的设备时能和BIOS连接。
当用户程序请求I/O操作时，它要传送请求给BIOS，在BIOS的控制下访问所需要的设备。
但是，有时程序会直接向BIOS发出请求，如对于键盘和屏幕的服务。在其他时间――虽然很难得而且不提倡――程序可以绕过操作系统与BIOS直接访问设备。
图2-1表明这些可供选择的通路。
2.4系统程序的装入程序
一旦BIOS把控制交还操作系统，你就可以请求执行程序。可执行程序有两种类型：.COM和.EXE。
.COM程序由一个包含代码、数据和堆栈的段组成。.COM程序作为小的实用程序或常驻程序（安装在存储器内，在其他程序运行期间它是可用的）是有用的。
在实模式下，.EXE程序是由各自独立的代码段、数据段和堆栈段组成，是一种较为正式的程序。本书采用这两种类型的程序。
要求系统把.EXE程序从磁盘装入存储器时，装入程序是按以下步骤执行的：
1.从磁盘上取.EXE程序。
2.在可用内存储器的一个小段边界上，构造一个256字节（100H）的程序段前缀（PSP）。
3.紧随PSP的下一地址。把程序装入存储器中
4.把PSP的地址装入DS与ES寄存器。
5.把代码段地址装入CS寄存器并把IP寄存器设置成代码段中第一条指令的偏移值（通常是0）。
6.把堆栈段地址装入SS寄存器并把SP寄存器设置成堆栈的大小。
7.传送控制给要执行的程序，通常从代码段的第一条指令开始。
通过上述方法，程序的装入程序将CS:IP和SS:SP正确地初始化。
但是请注意，程序的装入程序在DS和ES中都存放了PSP的地址，而在这些寄存器中你的程序需要数据段的地址。
因此，EXE程序必须按数据段地址去初始化DS，正如你在第4章将会看到的那样。
现在，我们来研究堆栈段、代码段与数据段。
2.5堆栈
COM程序与.EXE程序都需要在程序中保留一个区作为堆栈。堆栈有3个主要的用途：
1.当调用一个子程序时，程序要在堆栈中保留返回地址，用于子程序返回。
2.调用子程序的程序还可以用把数据放在堆栈中的办法来传送数据，了程序可以通过堆栈存取这些数据。
3.当程序要使用寄存器计算时，可以在堆栈中保存寄存器当前的内容，进行计算后，再把数据从堆栈恢复到寄存器中。
装入程序自动地为.COM程序定义堆栈，而必须为.EXE程序明确地定义堆栈。
在实模式下，堆栈中的每个数据项是一个字（2个字节）。SS寄存器在被装入程序初始化时，包含了堆栈的起始地址。
最初，SP寄存器包含堆栈的大小，它的值所指向的字节超过堆栈的末端。
堆栈在存储数据的方法上是和其他段不同的：它从段的最高的单元开始存放数据，而且存放数据的顺序是向下（或相反方向）通过存储器的。
PUSH和POP是那些修改SP寄存器内容的若干指令中的两条，用来在堆栈中存放数据和取回数据。
PUSH执行SP减2，指向堆栈中下一个较低的存储字并存放一个值在那里（或称“进栈”）；POP执行从堆栈回送一个值并使SP加2，去指向下一个较高的存储字（或称“出栈”）。
.对于一个特定的过程，将全部数据进栈，保存在堆钱的一个部分，这进栈部分称为堆栈帧。
下面的例子说明把AX与BX寄存器的内容进栈，然后顺序地从堆栈中将数据出栈再返回到寄存器。
假定AX的内容是hex026B，BX的内容是04E3，SP内容是36（在SS中的堆栈的段地址在这里与我们无关）。
1.最初，堆栈是空的并如下所示：
偏移值         堆栈帧         SP=36
34                0000
32                0000
30                0000
2E                0000
2.PUSH AX:SP减2（到34），并把AX的内容026B存入堆栈。注意，操作使所存放的字节次序变反了，即026B变成了6B02：
偏移值         堆栈帧         SP=34
                    02
34                6B
32                0000
30                0000
2E                0000
3.PUSH BX:SP减2（到32）并把BX的内容04E3存入堆栈，成为E304：
偏移值         堆栈帧         SP=32
                    02
34                6B
                    04
32                E3
30                0000
2E                0000
4.POP BX：把堆栈中SP所指向的字（E304）恢复到BX中，并且SP加2（到34）。由于字节是正确恢复的，所以BX现在的内容是04E3：
偏移值         堆栈帧         SP=34
                    02
34                6B
                    04
32                E3
30                0000
2E                0000
5.POP AX：把堆栈中SP所指向的字（6B02）恢复到AX中，并且SP加2（到36）。由于字节是正确恢复的，所以AX现在的内容是026B：
偏移值         堆栈帧         SP=36
                    02
34                6B
                    04
32                E3
30                0000
2E                0000
注意：POP指令是以和PUSH指令相反的顺序编码的，在这个例子中按照这样的顺序进栈时是AX和BX，而出栈时是BX和AX。
而且进入堆栈的值仍然在那里，尽管SP指针已经不再指向它们。随后的PUSH操作将会用新的值取代旧的值。
要确保你的程序进入堆栈的值和堆栈出栈的值是等同的。尽管这是一个相当简单的要求，但是如果使用不当就会导致严重的程序错误。
另外，对于一个.EXE程序，堆栈必须足够大，以便它能装下可能进栈的所有值。注意，当SP=0时，堆栈是满的。
其他的一些与进栈或出栈有关的指令是：
PUSHF和POPF：保存和恢复标志的状态。
PUSHA和POPA（80286+）：保存和恢复所有通用寄存器（AX、CX、DX、BX、SP、BP、SI以及DI）的内容并使SP加/减16。
PUSHAD和POPAD（80386+）：保存和恢复所有扩充寄存器（EAX、ECX、EDX、EBX、ESP、EBP、ESI和EDI）的内容并使SP加/减32。
2.6指令的执行与寻址
汇编语言程序员用符号代码编写程序并用汇编程序把它翻译成机器码，如.COM或.EXE程序。为了执行程序，系统只把机器码装入到存储器中。
每条指令至少要包含一种操作，如传送、加或返回。依据不同的操作，一条指令可以有一个或多个操作数，用来访问该操作要处理的数据。
在执行指令的过程中，处理器所采取的基本步骤是：
1.从存储器中取出要执行的下一条指令并把它放在指令队列中。
2.指令译码：计算访问存储器的地址，把数据传送到算术逻辑部件中，并且增加指令指针（IP）寄存器的值。
3.执行指令：完成所要求的操作，把结果存入寄存器或存储器中，并且按要求设置标志位（如零或进位）。
Pentium的流水线功能使它能重叠进行操作，如以下三条指令的简单举例：
取指         译码         执行
               取指         译码         执行
                              取指         译码         执行
正如已经讨论过的，对于.EXE程序，CS寄存器提供程序代码段的起始地址，DS提供数据段的起始地址。
代码段包含要被执行的指令，数据段则包含指令要访问的数据。IP寄存器指明在代码段中当前指令的偏移地址，指令操作数指明在数据段中要被访问的偏移地址。
考虑一个例子，在这个例子中，程序的装入程序已确定把一个.EXE程序装入到起始地址为05BE0H的存储区中。装入程序相应地用段地址05BE[0]H初始化CS，并且用0初始化IP。
CS:IP一起确定了要执行的第一条指令的地址：05BE0H+0000H=05BE0H。用这种方法，使代码段中的第一条指令开始执行。
如果第一条指令是2字节长，则处理器使IP加2，这样下一条要执行的指令就在05BE0H+2=05BE2H单元中。
假定程序继续执行，并且IP当前的内容是偏移值0023H。现在CS:IP确定下一条要执行指令的地址如下：
CS段地址：05BE0H+0023H=05C03H   指令地址：05C03H
假设起始于05C03H的MOV指令要把在存储器中的一个字节内容复制到AL寄存器中，该字节在数据段中的偏移值为0016H。下面是这一操作的机器码与符号码：
地址05C03H         A01600 MOV AL,[0016]
地址05C03H包含的是处理器要访问的机器码指令的第一个字节（A0）。第二与第三个字节包含的是以相反字节顺序存放的偏移值（0016是按1600存放的）。
在符号码中，在方括号（变址操作符）中的操作数[0016]指明一个偏移值，它和实际存储器地址16是有区别的。
假设程序是用数据段地址05D1[0]H来初始化DS奇存器的。为访问数据项，处理器是由DS中的段地址加上指令操作数中的偏移值（0016H）来确定它的存储单元。
因为DS的内容是05D1[0]H，所以所访问的数据项的实际单元是：
DS段地址：05D10H+0016H=05D26H   数据项地址：05D26H
假设地址05D26H含有4AH，处理器现在要在地址05D26H上提取4AH并把它复制到AL寄存器。如图2-2所示，CS指向代码段的起始点，DS指向数据段的起始点，
在代码与数据段中的偏移值，以及4A的值被复制到AL。
随着处理器取指令中的每个字节，IP寄存器加1。因为IP原来的内容是23H，并且执行的机器码是3个字节，所以IP现在的内容是0026H，它是下条指令的偏移值。
处理器现在准备好执行这条指令，它再一次由CS中的段地址（05BE0H）加上IP中当前的偏移值（0026H）来确定存储地址，即05C06H。
指令也可以访问一个以上的字节。例如。假定一条指令要把AX寄存器的内容（0248H）存入数据段中起始于偏移值0016H的2个相邻字节中。
该指令的符号码是：MOV [0016],AX。处理器是以相反字节顺序把2个字节存放在存储器中的，如：
字节内容：             48                  02
数据段中的偏移值：0016             0017
另一条指令MOV AX,[0016]随后可以使用把这些字节从存储器复制到AX的办法，重新取回它们。这一操作把字节顺序变反并正确地存放在AX中，成为0248。
2.7指令的操作数
指令可以没有操作数，也可以有1、2或3个操作数。使用标准的名字和方括号中的名字与数字，可以清晰地表示操作数。
在以下的例子中，DW定义WORDX为一个字（两个字节）：
WORDX DW 0         把WORDX定义为字
MOV CX,WORDX    把WORDX的内容传送到CX
MOV CX,25             把值25传送到CX
MOV CX,BX            把BX的内容传送到CX
MOV CX,[BX]          把BX中的地址单元的内容传送到CX
第一个MOV在存储器（WORDX）与寄存器（CX）之间传送数据。
第二个MOV传送立即数（25）到寄存器（CX）。
第三个MOV在寄存器之间传送数据（BX到CX）。
第四个MOV中的方括号定义了一个变址操作符，其含义是：利用在BX中的偏移地址（与DS中的段地址组合起来，成为DS:BX）去定位存储器中的一个字，
并把它的内容传送到CX。比较这条指令和第三条MOV（简单地把BX的内容传送到CX）的作用。第6章将详细说明这种间接寻址。
2.8保护模式
在Windows保护模式下，处理器可以从一个任务切换到另一个任务。每个程序都有自己的存储区，而且处理器保护每个区域并保存每个程序的状态。
在实模式下，段寄存器包含实际的段地址，但只限于1MB的寻址。然而，保护模式需要更大的寻址能力。
为了这一目的，它使用了各种表格，这些表格包括：
局部描述符表（local descriptortable）。取决于系统，每个任务有一个表。16位的LDT寄存器包含正在执行的当前任务的这张表的地址。
中断描述符表（nterupt descriplor table）。此表处理中断操作，IDT寄存器包含其地址。
全局描述符表（global descriptor table）。此表包含每个局部描述符表的地址，32位的GDT寄存器包含这个表的地址。
段的实际地址是存放在描述符表中的，段寄存器（或称选择器）存放的是指向当前局部描述符表的指针。该表提供32位寻址，可达4GB。
通常，中断向量表是放在0000：0000单元，并且每个任务可以有自己的这个表的副本。
2.9要点
接通计算机电源使处理器进入复位状态，把全部存储器单元清除为0，完成存储器的奇偶校验，并且把CS和IP寄存器设置成在ROM中的BIOS的入口点。
两种可执行程序类型是.COM和.EXE。
为了装入.EXE程序，装入程序要在存储器的小段边界上建立一个256字节（100H）的PSP并紧跟PSP立即存放此程序。
然后在DS与ES寄存器中装入PSP的地址，把代码段的地址装入CS，设置IP为代码段第一条指令的偏移值，把堆栈的地址装入SS，并把SP设置成堆栈的大小。
最后，装入程序传送控制给要执行的程序。
堆栈的用途是提供地址和数据项的暂存空间。
程序的装入程序为.COM程序定义堆栈，而你必须明确地为.EXE程序定义堆栈。
当处理器取指令的每个字节的时候，它要使IP寄存器增量，使得CS:IP对包含要执行的下一条指令的段：偏移值地址。
2.10习题
2-1.指出操作系统的5种主要功能。
操作系统提供通用地、设备无关地访问计算机资源（如键盘、屏幕和磁盘驱动器这样的一些设备）的能力。
与我们有关的一些功能如下：
文件管理。操作系统维护在系统磁盘上的目录与文件。程序负责建立与修改文件，而系统则负责管理它们在磁盘上的定位。
输入/输出。程序需要借助中断从系统输入数据或向系统输出数据。程序员可以减轻在I/O低层次上的编码负担。
程序装入。当用户或程序要求执行程序时，程序的装入程序会处理从磁盘上取出程序，读入存储器中，以及为了执行程序而进行的初始化等这样些步骤。
存储器管理。当程序的装入程序为执行一个程序而把它从磁盘装入到存储器时，它会为程序代码和数据在存储器中分配足够大的空间。
程序可以在它的存储区里处理数据，可以释放不需要的存储区，而且还可以要求追加存储区。
中断处理。系统可借助于中断访问外部设备。
2-2.给出在引导过程中系统所采取的步骤。
接通计算机电源的时候，会使处理器进入复位状态，把所有存储单元清除为0，完成存储器的奇偶校验，以及把CS寄存器设置成段地址FFFF[0]H，并把IP寄存器设置成偏移值为0。
因此，第一条要执行的指令是在地址FFFF0H，这个地址是ROM中的BIOS入口点。
起始单元为FFFF0H的BIOS例行程序检查各种端口去识别与初始化一些设备。
BIOS要建立两个数据区：
中断向最表。它开始于低端存储器的0单元并包含256个4字节地址，其格式是：段：偏移值。BIOS和操作系统在中断发生时使用这些地址。
BIOS数据区。它开始于40[0]单元，大部分与所连接设备的状态有关。
下一步BIOS要确定磁盘是否包含现存的系统文件，如果有，它就要访问来自磁盘的引导装入程序。
由这个程序把系统文件从磁盘装入内存，并把控制权交给它们。系统文件包括设备驱动程序和其他硬件专用代码。
这些模块初始化内部系统表和中断向量表的系统部分。
2-3.程序的装入程序在它装入要执行的模块时，在可执行模块的前面要建立和存放一个数据区。（a）这个数据区叫什么名字？（b）它的大小是多少？
系统把.EXE程序从磁盘装入存储器时，在可用内存储器的一个小段边界上，构造一个256字节（100H）的程序段前缀（PSP）。
2-4.程序的装入程序在它装入一个有待执行的.EXE程序时，要完成某些操作。装入程序用什么样的值来初始化下列寄存器：（a）SS和SP，（b）CS和IP，（c）DS和ES。
系统把.EXE程序从磁盘装入存储器时，装入程序是按以下步骤执行的：
1.从磁盘上取.EXE程序。
2.在可用内存储器的一个小段边界上，构造一个256字节（100H）的程序段前缀（PSP）。
3.紧随PSP的下一地址。把程序装入存储器中
4.把PSP的地址装入DS与ES寄存器。
5.把代码段地址装入CS寄存器并把IP寄存器设置成代码段中第一条指令的偏移值（通常是0）。
6.把堆栈段地址装入SS寄存器并把SP寄存器设置成堆栈的大小。
7.传送控制给要执行的程序，通常从代码段的第一条指令开始。
2-5.说明堆栈的用途。
堆栈有3个主要的用途：
1.当调用一个子程序时，程序要在堆栈中保留返回地址，用于子程序返回。
2.调用子程序的程序还可以用把数据放在堆栈中的办法来传送数据，了程序可以通过堆栈存取这些数据。
3.当程序要使用寄存器计算时，可以在堆栈中保存寄存器当前的内容，进行计算后，再把数据从堆栈恢复到寄存器中。
2-6.说明对于（a）COM程序和（b）EXE程序，堆栈是如何定义的（即谁来定义堆栈或堆栈定义成什么样的）。
装入程序自动地为.COM程序定义堆栈，而必须为.EXE程序明确地定义堆栈。
2-7.（a）栈顶最初在什么地方？如何确定它的地址的？（b）堆栈中每项的大小是多少？
在实模式下，堆栈中的每个数据项是一个字（2个字节）。SS寄存器在被装入程序初始化时，包含了堆栈的起始地址。
最初，SP寄存器包含堆栈的大小，它的值所指向的字节超过堆栈的末端。
堆栈在存储数据的方法上是和其他段不同的：它从段的最高的单元开始存放数据，而且存放数据的顺序是向下（或相反方向）通过存储器的。
PUSH和POP是那些修改SP寄存器内容的若干指令中的两条，用来在堆栈中存放数据和取回数据。
PUSH执行SP减2，指向堆栈中下一个较低的存储字并存放一个值在那里（或称“进栈”）；POP执行从堆栈回送一个值并使SP加2，去指向下一个较高的存储字（或称“出栈”）。
2-8.给定一堆栈定义为DW 32H，当（a）谁栈是空的和（b）堆栈是满的时，SP的内容是什么
当SP=2时，堆栈是空的，当SP=0时，堆栈是满的。
2.9.堆栈的大小被定义为64H个字节。（a）SP寄存器中的初始值是什么？（b）CX内容为25A4H，在PUSH CX之后，表示出堆栈和SP的内容。
（c）DX的内容是3B2AH，在PUSH DX之后，表示出堆栈和SP的内容。（d）指出在POP DX和POP CX之后SP的内容。
64H
偏移值         堆栈帧         SP=62H
                    25
62H             A4
偏移值         堆栈帧         SP=60H
                    25
62H             A4
                    3B
60H             2A
偏移值         堆栈帧         SP=64H
                    25
62H             A4
                    3B
60H             2A
2-10.在程序执行期间，CS的内容为4AB6[0]，SS的内容为4A82[0]，IP的内容为36H，以及SP的内容为28H（这些值是按正常的而不是按反向字节顺序表示的）。
计算（a）栈顶（当前单元）的地址和（b）要执行的指令的地址。
4A820H+0028H=4A848H
4AB60H+0036H=4AB96H
2-11.在程序执行期间，CS的内容为5C9B[0]，SS的内容为5C84[0]，IP的内容为48H，以及SP的内容为1AH（这些值是按正常的而不是按反向字节顺序表示的）。
计算（a）栈顶（当前单元）的地址和（b）要执行的指令的地址。
5C840H+1AH=5C85AH
5C9B0H+48H=5C9F8H
2-12.计算以下被访问数据的存储器地址。（a）DS内容为7E9B[0]，并且把数据从存储器传送到AX的指令是MOV AX,[24H]。
（b）DS的内容为43C6[0]，并且把数据从存储器传送到BX的指令是MOV BX,[48H]。
7E9B0H+0024H=7E9D4H
43C60H+0048H=43CA8H
第3章计算机存储器与执行指令
3.1引言
3.2使用DEBUG程序
3.3查看存储单元
3.4机器语言举例1：使用立即数据
3.5机器语言举例2：使用定义的数据
3.6一个汇编语言程序
3.7使用INT指令
3.8使用PTR操作符
3.9要点
3.10习题
目的：介绍程序向存储器的输入并跟踪它们的执行情况。
3.1引言
本章使用叫做DEBUG的DOS程序（它允许你查看存储器）把程序输入到存储器中，并跟踪它们的执行情况。书中讲述了怎样把程序直接输入到代码段中，
同时提供了对每个执行步骤的说明。虽然有不少完善的调试程序，例如CODEVIEW和TurboDebugger，我们还是使用DEBUG，原因在于它用起来既简单又通用。
最初的练习说明如何检查存储器的特定区域的内容。第一个程序例子使用“立即”数据，它是在指令中定义的，用于向寄存器装入数据并执行算术运算。
第二个程序例子使用分别由可执行指令定义的数据。伴随指令执行去跟踪它们，可以对程序的操作和各种寄存器的作用有更加深入的了解。
你可以在没有汇编语言预备知识、甚至没有程序设计预备知识的情况下马上开始工作了。只需一台基于Intel的PC和DOS系统（独立的或是Windows下的）。
不过，我们还是得假定你对系统命令、选择磁盘驱动器与文件比较熟悉。
3.2使用DEBUG程序
DEBUG程序是用来测试和调试可执行程序的。它能显示所有的程序代码和十六进制格式的数据，以及输入存储器的任何数据（也必须是十六进制格式）。
DEBUG还提供了一种单步方式，这种方式允许一次执行一条指令，这样就能查看每条指令在存储单元和寄存器中的结果。
DEBUG命令
DEBUG的一组命令能完成许多有用的操作。常用命令如下：
A把符号指令汇编成机器码
D以十六进制格式显示一个存储区的内容
E从一个指定的存储单元开始，把数据输入到存储器中
G运行在存储器中的可执行程序（G的意思是“go”）
H完成十六进制算术运算
N给程序命名
P执行一组相关指令
Q退出DEBUG
R以十六进制格式显示一个或多个寄存器的内容
T跟踪一条指令的执行
U把机器码反汇编为符号码
DEBUG命令的规则
这里是一些使用DEBUG的基本规则：
DEBUG不区分大小写字母，可以用任何一种方法输入命令。
DEBUG假定所有数都是十六进制格式的。
命令中的空格只是用来分隔参数的。
段和偏移值是用冒号来指定的，形如“段基址：偏移值”。
附录C提供全部DEBUG命令的完整说明，包括有关如何启动它。现在就让我们利用DEBUG命令在存储器中做一番“游历”。
DEBUG显示命令
D命令把指定数据区内容显示在屏幕上。下面3个例了使用DEBUG的D命令显示存储器的同一个区域，这个区域从数据段（DS）的偏移值200H处开始：
D DS:200（大写字母的命令，跟着空格）
DDS:200（大写字母的命令，未跟着空格）
dds:200（小写字母的命令，未跟着空格）
显示的屏幕由3部分组成：
1.左边是最左边所显示的字节的十六进制地址，其格式为：段：偏移值。
2.中央宽的区域是所显示区域的十六进制表示。
3.右边是字节的ASCII表示，它包含可显示的字符，这些字符解释十六进制区域。
D（显示）命令显示8行数据，每行包含16个字节（32个十六进制数字），一共是128个字节，从指定的地址开始。
左边的地址只是最左边（起点）字节的地址，其格式是段：偏移值，可以跨行计数去确定每个其他字节的位置。
十六进制表示的区域把每个字节表示成2个十六进制字符，为清晰起见，用一个空格跟着。另外，还是为清晰起见，第二个8个字节与第一个8个字节之间用一个短线加以分隔。
这样，如果你要去定位在偏移值xx13H处的字节，那么就从xx10H开始，并逐次向右数3个字节即可。
DEBUG的R命令还能列出寄存器的内容和标志寄存器的状态。
3.3查看存储单元
最初的两个练习涉及使用DEBUG的D（显示）命令去查看所选择的存储单元的内容。
3.3.1练习1：检查BIOS数据区
第一个练习是检查在存储器低端、起点在400H单元（或更精确地说是段地址40[0]）的BIOS数据区的内容。当计算机接通电源后，
BIOS初始化这个区域的值并在程序执行过程中修改它们。
可以用一个两部分组成的地址查看这些值：一部分是段地址40（技术上说是400，因为最后的0被移出了）；另一部分表示与段地址间距离的偏移值nn。
把地址40：nn理解为段40[0]H加上偏移值nnH。在24.3节“BIOS数据区”会对这些数据项做更详细的解释。
1.检查串行与并行端口
BIOS数据区的第一个16字节包含串行与并行端口的地址。准确地键入：
D 40:00（并按<Enter>键）
所显示的第一个4个字表示串行端口COM1到COM4。如果有两个串行端口，则第一个双字是以相反字节顺序排列的F803和F802，端口是在03F8和02F8。
第二个4个字表示并行端口LPT1到LPT4。对于有一个并行端口的系统，第一个字很可能是7803，它对应于端口0378。
address size
40:0000   2  Port of COM1
40:0002   2  Port of COM2
40:0004   2  Port of COM3
40:0006   2  Port of COM4
40:0008   2  Port of LPT1
40:000A   2  Port of LPT2
40:000C   2  Port of LPT3
40:000E   2  Port of LPT4
2.检查系统设备
BIOS数据区里的设备状态字提供已安装设备的简单的指示。可以用DEBUG命令把这个字定位在410H-411H单元，这条命令是：
D 40:10（并按<Enter>键）
显示结果如下：
0040：0010 xxxx...
address size
40:0010   2  Equipment/hardware installed/active; see Equipment List
假定在设备状态字中的两个字节是十六进制值23和44。为解释它们，把字节反向排列为4423并把它们转换成二进制格式：
二进制值：0100 0100 0010 0011
位位置：15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0
下面是对这些位的说明：
位设备
15，14所连接的并行打印机端口数=1（二进制01）
11-9所连接的串行端口数=2（二进制010）
7，6软盘设备数=1（00=1，01=2，10-3，11=4）
5，4初始显示方式=10（01=40×25彩色 10=80×25彩色，11=80×25单色）
1   1=数值协处理器存在
0   1=软盘驱动器存在
bit 0  When this is 0, the computer has no diskette drives.
bit 1  1 means that a numeric coprocessor is present.
bits 4-5  Currently-active video adaptor
00=(reserved)   10=80-clm color
01=40-clm color 11=TTL Monochrome
bits 6-7  number of detected diskette drives 00=1; 01=2; 10=3; 11=4
bits 9-11  detected RS-232 serial ports 000=0; 001=1...100=4...111=7
bits 14-15  number of parallel printer ports 00=0; 01=1; 10=2; 11=3
不使用其他未涉及到的位。
3.检查键盘 Shift状态
位于BIOS数据区417H单元的是键盘Shift状态的第一个字节。首先要确认NumLock和CapsLock是关闭的，然后用命令D去查看40：17单元，显示如下开始：
0040：0017 0000...
现在打开两个Lock键并重复显示命令，40：17中的值应该是6000。
40:0013   2  Total memory in K-bytes (same as obtained via INT 12H)
40:0017   2  Keyboard status bits; see Keyboard Shift Status Flags
Two bytes at address 0040:0017 and 0040:0018 identify the status of the keyboard shift keys and keyboard toggles.
INT 16H 02H returns one byte in the AL register; it is exactly as found in the byte at 0040:0017 in the BIOS Data Area:
0:  01H right shift (right side) DOWN
1:  02H left shift (left side) DOWN
2:  04H Ctrl (either side) DOWN
3:  08H Alt (either side) DOWN
4:  10H ScrollLock state
5:  20H NumLock state
6:  40H CapsLock state
7:  80H Insert state
0040：17单元存储键盘状态字节，该字节记录了控制键和切换键的状态。
键盘状态字节各位记录的信息如下。
0：右shift状态，置1表示按下右shift键；
1：左shift状态，置1表示按下左shift键；
2：Ctrl状态，置1表示按下Ctrl键；
3：Alt状态，置1表示按下Alt键；
4：ScrollLock状态，置1表示Scroll指示灯亮；
5：NumLock状态，置1表示小键盘输入的是数字；
6：CapsLock状态，置1表示输入大写字母；
7：Insert状态，置1表示处于删除态。
4.检查显示状态
位于BIOS数据区449H单元的是第一个显示数据区。键入命令D 40:49。第一个字节包含当前显示方式（如03表示彩色），而第二个字节是屏靠上的列数（这里是50H-80）。
你还能找到位于40：84H单元的行数。
40:0049   1  Current active video mode.  See Video Modes and INT 10H.
40:004a   2  Screen width in text columns
40:0084   1  EGA text rows (maximum valid row value)

AL  Type     Format   Cell  Colors        Adapter  Addr  Monitor
0  text     40x25     8x8* 16/8 (shades) CGA,EGA  b800  Composite
1  text     40x25     8x8* 16/8               CGA,EGA  b800  Comp,RGB,Enh
2  text     80x25     8x8* 16/8 (shades) CGA,EGA  b800  Composite
3  text     80x25     8x8* 16/8               CGA,EGA  b800  Comp,RGB,Enh
3.3.2练习2：考察ROM BIOS
以下练习检查在存储器高端的ROM BIOS中的数据。
1.检查版权通告与系列号
计算机的版权通告是嵌入在ROM BIOS中的FE00H单元的。为了查看这一段，可以键入D FE00:0。由计算机制造时间决定，紧跟版权通告之后，
在一般机器上还有7位数字的系列号。版权通告更多地可以从屏幕右边ASCII区域的字符中观察到，而系列号则按十六进制数加以辨认。
版权通告可能比较长，超出了已经显示的部分，为继续查看它，可以简单地再按一次D键并跟着按一下回车（<Enter>）键。
2.检查ROM BIOS数据
ROM BIOS的制造日期是按mm/dd/yy记录的，起点在FFFF5H单元。需要这一段时，键入D FFFF:5。了解这日期对于确定计算机的年代和型号是有用的。
现在你已经知道如何使用显示命令了，可以查看任何存储单元的内容，还可以步进地从头到尾查看存储器，这只要简单地重复按D键即可―DEBUG依次显示8行（128个学节）。
直到最后的D操作为止。
f000:fff0 5  FAR JMP instruction to begin POST (after a hard reset, the CPU jumps here)  ffff:0
f000:fff5 8  ROM-BIOS release date in ASCII ffff:5
f000:fffc 2  (unused)
f000:fffe 1  IBM computer-type code; see also BIOS INT 15H C0H
当你完成上述试验后，键入Q（用于退出）从DEBUG退出，或者继续进行下面的练习。
3.4机器语言举例1：使用立即数据
现在让我们使用DEBUG把两个程序中的第一个程序直接输入到存储器中，并跟踪它的执行情况。两个程序都说明简单的机器语言指令在存储器中的出现和它们执行的效果。
为了这一目的，我们将从使用DEBUGE（Enter）命令开始。要特别注意，在一个错误单元输入数据或者输入错误的数据可能会产生无法预料的后果，
好像并没有造成任何破坏，但你可能会得到意外的一个位，也可能丢失在DEBUG对话期间所输入的数据。
第一个程序使用立即数据一―数据被定义为指令的一部分。
下面所表示的是十六进制格式的机器语言，为清晰起见而与注释合在一起的符号码。
对于第一条指令――B82301，符号码是MOV AX,0123，它把值0123H传送到AX（你定义一个正常的而不是反向字节顺序的立即值）。
MOV是指令，AX是第一个操作数，而立即值0123H是第二个操作数。
B82301 MOV AX,0123         把值0123H传送到AX
052500 ADD AX,0025          把值0025加到AX中
8BD8    MOV BX,AX             把AX的内容传送到BX
03D8    ADD BX,AX              把AX的内容加到BX
8BCB    MOV CX,BX             把BX的内容传送到CX
2BC8    SUB CX,AX               从CX中减去AX的内容
2BC0    SUB AX,AX              从AX中减去AX（清除AX）
E8EE    JMP 100                  返回到起点
注意：机器指令的长度可能是一个、两个或三个字节。第一个字节是实际操作，而存在的任何其他字节都是操作数一―访问的立即值，寄存器，或存储单元。
程序是从第一条机器指令开始执行的，并且顺序地、一个接一个地步进执行每条指令。现在不要求弄清楚机器码的意思。
例如，在一种情况下，MOV的机器码（第一个字节）是hexB8，而在另一种情况下，MOV的代码是hex8B。
3.4.1键入程序指令
就像你前面所做的那样，开始进行这个练习：键入命令DEBUG并按回车键。当DEBUG全部装入完毕，会显示它的提示符（-）。
为了把这个程序直接键入到存储器中，只是输入机器指令部分，而不是符号码或注释。键入以下的E命令（包括空格），表示为：
E CS:100 B8 23 01 05 25 00（并按<Enter>键）
CS:100指明要存放数据的存储器起始地址是在代码段起点之后100H（256）字节处（在DEBUG下，机器码的正常起始地址）。
E命令使DEBUG把每一对十六进制数字存入存储器中的一个字节，从CS：100到CS：105。
下一条E命令存放6个字节，从CS：106到CS：10B：
E CS:106 8B D8 03 D8 8B CB（并按<Enter>键）
后一条E命令存放6个字节，从CS:10C到111：
E CS:10C 2B C8 2B C0 E8 EE（并按<Enter>键）
如果你键入了错误命令，那么就用正确的值简单地重复做下。
3.4.2执行程序指令
现在要做每次执行一条上述指令是一件简单事情。图3-1表明了整个步骤，包括使用E命令去键入机器码。屏幕应该显示出和你输入的每条DEBUG命令类似的结果。
在每条指令执行完之后，还可以查看寄存器的内容。这里，和我们有关的新的命令是R（寄存器）和T（跟踪）。
为了查看寄存器和标志的初始内容，可以键入R命令，接着按回车键，如图3-1的第4行所示。DEBUG以十六进制格式显示寄存器的内容，如：
AX=0000 BX=0000...
由于计算机配置的不同，在屏幕的某些寄存器内容也将与图3-1所示的不同。DEBUG已经把DS、ES、SS和CS全部用同样的段地址xxxx[0]初始化了。
IP应该显示IP=0100，它指明指令的执行是从代码段起点后的100H个字节开始的（这就是你要用E CS:100作为程序起点的原因）。
图3-1中的标志寄存器指明以下对于溢出、方向、中断、符号、零、辅助进位、奇偶性以及进位标志的初始设置：
NV UP EI PL NZ NA PO NC
这些设置的意思分别是无溢出，方向向上（或向右），允许中断，符号为正，非零，无辅助进位，奇的奇偶性，以及无进位。此时，这些改置对我们来说都是不重要的。
紧随寄存器并同样用R命令显示的，是第一条要执行的指令。注意，在图中CS寄存器的内容是21C1。由于CS段地址肯定和这个值不同，所以在指令中把它表示为xxxx：
xxxx:0100 B82301   MOV AX,0123
xxxx指明代码段的起点是xxxx[0]。值xxxx:0100指的是在CS段地址xxxx[0]之后有100个字节的偏移。
B82301是CS:100输入的机器码。
MOV AX,0123是符号汇编指令，由DEBUG根据机器码确定。实际上，这条指令的意思是：把立即值0123H传送到AX。DEBUG把机器指令进行“反汇编”，以便更容易解读它们。
在本章之后，你将专用符号汇编指令编码。
请记住这里的警告：在试图执行一条指令之前，定要确保它是有效的。即使你键入了一个不正确的机器码，DEBUG还是会试图去执行它，
而且假如这个代码是无效的，处理器就会死锁，DEBUG无法工作下去，系统只能重新引导。
为了执行MOV指令，键入T（跟踪）命令并按<Enter>键。机器码是B8（传送到AX）后面跟着2301。该操作把23传送到AX的低半部分（AL），
并把01传送到AX的高半部分（AH）：
AH AL
01 23
DEBUG显示寄存器中的操作结果。IP寄存器现在的内容是0103H（原来的0100H加上第一个机器码指令长度的3个字节），
0103H这个值指明代码段中下一条要执行指令的偏移地址，即：xxxx：0103 052500   ADD AX,0025
为了执行这条ADD指令，要输入另一个T命令。该指令把25H加到AX的低半部分（AL），并把00H加到AX的高半部分（AH），实际上是把0025H加到AX中。
现在AX的内容是0148H，而IP的内容是0106H，用于下一条要执行的指令：xxxx:0106 8BD8 MOV BX,AX
键入另一个T命令。MOV指令把AX的内容传送到BX。注意：传送之后，BX的内容是0148H，AX仍然是0148H，因为MOV是复制，
而不是真的把数据从一个地方移到另一个地方。现在连续键入T命令，一步步地执行余下的各条指令。ADD指令把AX的内容加到BX，在BX中得到0290H，
然后，程序把BX的内容传送（复制）到CX，从CX中减去AX，并且从AX本身再减去AX。最后的操作是把AX清除为零并把零标志从NZ改为ZR（零），以便指明操作的结果。
JMP指令把IP复位成100H，使得正在进行的过程“跳转”返回到程序的起点。
这里，它是作为一种预防措施，因为在最后输入的指令之后是“无用信息”，这时如果试图去执行它，将会造成处理器死锁。
注意，已被写入的程序是个无限的循环，也就是说，没有办法结束它，尽管DEBUG还让它循环地工作。这类处理过程通常用在特殊的环境中，比如监控系统。
另外，图3-1还表明DS、ES、SS和CS全部含有同样的段地址。这是因为DEBUG会把全部段当作.COM程序，用数据、堆栈和代码全在同一段内的办法来处理，
尽管你为它们留有各自独立的段。当编写.EXE程序时，要把这3个区域保存在各自独立的段内，每个段都在它自己的段地址之下。
为了返回这一程序，可以简单地按T键去执行JMP指令，它把IP复位成100H，即回到程序的起点。
3.4.3显示存储器内容
为了查看在代码段中的机器语言程序，要输入如下命令：
D CS:100
图3-2表示这条命令的结果，每行显示16个字节（32个十六进制数字）的数据。右边是每个字节的ASCII表示（如果是标准字符）。
在机器码的情况下，ASCII表示法是没有意义的，可以忽略不管。下面几节将更详细地讨论显示的右边部分。
显示的第一行是从代码段的偏移值100H开始的，并且表示出了单元CS:100到CS:10F的内容。第二行表示的是CS:110到CS:11F的内容。
实际上，虽然程序是在CS：111结束，但D命令会自动地显示从CS：100到CS：170的8行。在这个例子中，紧跟CS：111的任何数据都是“无用信息”。
只是希望从CS：100到CS：111的机器代码和你自己显示的是一样的，随后的那些字节的内容是无用的。
输入Q命令，结束DEBUG对话，或继续进行下一个练习。
3.5机器语言举例2：使用定义的数据
上一个例子是在MOV和ADD指令中使用直接定义的立即值。下一个例子是在程序中定义值（或常数）为0123H和0025H的数据项，程序指令去访问含有这些值的存储单元。
通过这个例子，可以深入了解计算机是如何借助于在DS寄存器中的地址和偏移地址来存取数据的。
这个例子定义以下的数据项，它起始于偏移值0200H，这样可以清楚地和在0100H的指令分隔开来：
DS偏移值         十六进制内容
0200H                2301H
0202H                2500H
0204H                0000H
0206H                2A2A2AH
请记住，一个十六进制数字占有半个字节，使得比如23H就被存放在数据区的偏移值0200H（第一个字节）内，而01H则被存放在偏移值0201H（第二个字节）内。
下面是处理这些数据项的机器指令，数据项是按相反字节顺序输入的值（比如0200成为0002）：
指令注释
A10002         把起始于DS偏移值0200H的一个字（2个字节）传送到AX中。
03060202      把起始于DS偏移值0202H的字（2个字节）内容加到AX。
A30402         把AX的内容传送到起始于DS偏移值0204H的字中。
EBF4             跳转到程序的起点。
请注意二条传送指令有不同的机器码：A1和A3。
实际的机器码取决于所访问的寄存器、数据的大小（字节或字）、数据的传送方向（从寄存器来或到寄存器去）以及访问的是立即数据、存储器还是寄存器。
3.5.1键入程序指令与数据
再一次使用DEBUG键入程序并跟踪它的执行。首先，使用E命令键入指令，起点在CS:0100：
E CS:100 A1 0002 0306 0202（按（Enter）键）
E CS:107 A3 0402 EBF4（按（Enter）键）
使用E命令定义数据，假设从DS：0200开始：
E DS:0200 2301 2500 0000（按《Enter）键）
E DS:0206 2A2A2A（按（Enter）键）
第一条E命令在偏移值为0200的数据区起点上存放3个字（6个字节），必须按相反字节顺序键入每一个字，使0123变成2301，而0025变成2500。
当MOV指令顺序地取出这些字并把它们装入到寄存器中时，再把字节顺序反过来，使2301变成0123，而2500变成0025。
第二条E命令存放3个星号（***），它们被定义为2A2A2A，以便以后可以使用D（显示）命令查看它们，其实这些星号在数据区里是没有什么特别用处的。
图3-3表示在程序中包括E命令在内的所有步骤，屏幕会显示类似的结果，注意在CS与DS中的地址可能不同。
为了考察存放的数据（从DS：200H到208H）和指令（从CS：100H到10AH），键入以下D命令：
查看代码：D CS:100,10B（按<Enter>键）
查看数据：D DS:200,208（按<Enter>键）
检查2个所显示的区域的内容和图3-3所示的什么内容是相同的。
3.5.2执行程序指令
键入指令之后，就可以像以前所做的那样来执行它们了。首先，要确定IP的内容为100H。
然后，按R键去观察寄存器与标志的内容并显示第一条指令。虽然AX可能仍然包含来自以前练习的值，但你可以立刻取代它。第一条显示的指令是：
xxxx:0100   A10002   MOV AX,[0200]
CS:0100访问第一条指令A10002。DEBUG把这条指令解释成MOV并决定对数据区的第一单元[0200]进行访问。
方括号告诉你这次访问的是存储器地址而不是一个立即值（把立即值0200H传送到AX应当表示为MOV AX,0200）。
现在键入T（跟踪）命令。指令MOV AX,[0200]把在偏移为0200H中的字内容传送到AX。
该内容是2301H，在按反向顺序操作送到AX中成为0123H，并由它取代了AX以前的任何内容。
键入另一条T命令去执行下一条ADD命令。该操作把DS:0202中的字的内容加到AX。
AX中的结果现在是0123H与0025H的和，即0148H。
下一条指令是MOV [0204],AX。为执行这条指令，键入T命令。该指令是把AX内容（0148H）复制到在DS偏移值204H与205H处的数据区，反向排列为4801H。
为查看从200H到208H数据内容的变化，键入：D DS:200,208（按<Enter>键）
所显示的值为：
数据区：2301 2500 4801 2A2A2A
显示的左边表示的是出现在存储器中的实际机器码，右边简单地帮助你更容易定位字符数据。
注意：这些表示在屏幕右边的十六进制值是它们的ASCII等效值。23H与25H分别显示为一个符号（#）和一个百分号（%），而3个2AH字节则产生星号（*）。
现在可以输入Q，结束DEBUG对话，或者继续下一个练习。
3.5.3重新执行指令
有时会需要复位IP寄存器的值，具体操作如下：
1.键入R IP，显示IP的内容。
2.输入值100（或另一条指令的地址），按回车键。
这一过程使你返回到程序（或程序中一条指令）的起点，现在就可以重复以前的步骤。
键入R命令（不跟IP），DEBUG显示寄存器、标志以及要执行的第一条指令。现在，你可以使用T命令再去跟踪指令的步骤。
如果你的程序累计总数，则用E命令去清除各存储单元并用R命令去清除各寄存器。但是要确保CS、DS、SP和SS的内容不变，这些寄存器都是有专门用途的。
3.5.4用DEBUG保存程序
在两种情况下，可以使用DEBUG把程序保存在磁盘上：
1.从磁盘上取回一个己有的程序，加以修改，然后再保存它。
2.使用DEBUG创建一个非常小的机器语言程序，并保存这个程序。
要做详细了解，可以参阅附录C中的W（写）命令。
现在你可能发现DEBUG的H（十六进制）命令对加减十六进制值是有用的。最大字段长度是4个十六进制数字。键入该命令，例如H 3443 2A2B。
该操作把和显示在左边，并把差显示在右边，如5E6E 0A18。
3.6一个汇编语言程序
虽然这里的程序举例都是机器语言格式的，我们也可以使用DEBUG去键入汇编语言语句。现在让我们试验一下用于把汇编语句输入到计算机中去的DEBUG A和DEBUG U 命令。
3.6.1A（汇编）命令
A命令告诉DEBUG开始接收符号汇编指令并把它们转换成机器语言。初始化指令的起始地址，它位于代码段偏移值100H处。如下所示：
A 100（Enter）
DEBUG 显示代码段的地址和偏移值（0100）为xxxx：0100。键入以下命令，每条指令后跟一个（Enter）：
MOV CL,42（Enter）
MOV DL,2A（Enter）
ADD CL,DL（Enter）
JMP 100（Enter）
当键入完程序，再一次按（Enter）键，从A命令中退出。这是一个额外的（Enter），它告诉DEBUG已经没有更多的符号指令输入了。
完成后，DEBUG会显示每条指令的偏移地址：
xxxx:0100 MOV CL,42
xxxx:0102 MOV DL,2A
xxxx:0104 ADD CL,DL
xxxx:0106 JMP100
xxxx:0108
在执行此程序之前，我们使用DEBUG的U（反汇编）命令来检查一下所生成的机器语言。
3.6.2U（反汇编）命令
DEBUG的U命令把汇编语言指令显示成机器码，可以使用这条命令查看第一条与最后一条指令的存储单元的位置。在这里，它们是100H和107H。键入：
U 100,107（Enter）
屏幕显示的各列是存储单元、机器码以及符号码，如下所示：
xxxx：0100 B142   MOV CL,42
xxxx：0102 B22A   MOV DL,2A
xxxx：0104 00D1   ADD CL,DL
xxxx：0106 E8F8   JMP 100
xxxx：0108
现在跟踪程序机器码的执行。从键入R去显示寄存器IP的内容应该是（0100）和第一条指令（MOV CL,42）开始，然后用相继的T命令去跟踪随后的指令。
当到达JMP时，IP的内容应该是106H，而且CL应该是6CH。继续进行下一个练习或按Q键退出执行。
现在你已经了解到如何键入机器语言和汇编语言程序了。顾名思义，DEBUG是为调试程序而设计的，而大多数工作涉及的将是常规汇编语言的使用，与DEBUG无关。
3.7使用INT指令
以下4个例子说明如何请求有关系统的信息。使用INT（中断）指令退出程序，进入DOS或BIOS例行程序，实现所需功能后，再返回程序。
有不同类型的INT操作，其中的某些操作需要在AH寄存器中的功能码去请求指定的动作。我们将使用P（继续进行）命令去执行全部中断例行程序，而不是用单步操作的T命令。
必须确保IP复位成100H。
MOV AH,2aH
INT 21H
                                                                  
Returns: CX    year (1980 to 2099)
DH    month (1 to 12)
DL    day (1 to 31)

AL    day of the week (0=Sun, 1=Mon,...6=Sat)
Returns the current date as known to the system.
3.7.1获得当前日期和时间
访问当前日期的指令是INT 21H，功能码2AH。键入DEBUG命令A 100，然后键入以下汇编指令：
MOV AH,2A <Enter>
INT 21<Enter>
JMP 100<Enter>，<Entex>
键入R显示寄存器，并键入T执行MOV，再键入P直接运行整个中断例行程序，该操作停在JMP，寄存器包含以十六进制格式表示的这一信息：
AL：星期，其中0=星期日
CX：年（例如，07D4H=2004）DH：月（01H到0CH）DL：日（01H到1FH）
MOV AH,2cH
INT 21H
                                                                  
Returns: CH    hour (0 to 23)
CL    minutes (0 to 59)
DH    seconds (0 to 59)
DL    hundredths of a second (0 to 99)
                                                                  
Returns the current time as known to the system.
访问当前时间的操作是INT21H功能码2CH。首先用R IP把IP复位为100，然后键入DEBUG A命令和以下汇编指令：
MOV AH,20<Enter>
INT 21<Enter>
JMP 100<Enter>，<Enter>
接着发生的过程和为取得日期所做过的事情是一样的。该操作把小时送给CH（在24小时格式下，00=午夜），把分钟送给CL，把秒送给DH，而把百分之一秒送给DL。
按Q键退出，或者继续进行下一个练习（把IP复位为100）。
3.7.2确定安装的设备
前面的练习已经检查了与计算机所包含的设备有关的401H和411H单元。BIOS还提供一个中断例行程序INT 11H，它传送信息给AX。
键入DEBUG命令A 100，然后键入下面的指令：
INT 11<Enter>
JMP 100<Enter>，<Enter>
键入R，显示寄存器和第一条指令。INT 11H这条指令传送控制给BIOS中的例行程序，该例行程序把设备数据传送给AX。
重复按T键和回车键，观察每条BIOS指令的执行情况（这一过程违反了不跟踪整个中断过程的规则，但这一操作还是正确的）。
INT 11H returns a 16-bit value that provides some information about the
devices attached to the computer.
The same information is found at 0040:0010 in the BIOS Data Area.
在BIOS中的实际指令可能和这里的指令稍微有些不同，这取决于所安装的版本（右边的注释是作者加的）：
JMP EE53
PUSH DS         把DS地址保存在堆栈中
MOV AX,0040 得到段地址
MOV DS,AX   把它送到DS
MOV AX,[0010]   把从0040:10中得到的数据送到AX
POP DS         恢复DS中的地址
IRET   从中断返回
最后的T命令从BIOS退出并返回到DEBUG。如果刚才BIOS中的执行没有出错，现在AX中就包含了已安装设备的记录。
现在显示的指令是你所输入的JMP。按Q键退出，或者继续进行下一个练习（把IP复位为100）。
3.7.3使用INT完成显示
这个在屏幕上显示数据的练习引入一些新的特性，键入DEBUG命令A 100和以下一些汇编指令：
100   MOV AH,09
102   MOV DX,109
105   INT 21
107   JMP 100
109   DB 'your name','$'<Enter>，<Enter>
两条MOV指令告诉INT21H要进行显示（AH=09）和从什么起始地址（DX=109）开始。注意，偏移值109开始定义你的名字，其中DB指的是“定义字节”，
而字符则包含在单引号中。你的名字（your name）之后是美元符号（$），它也在引号中，是用来通知INT结束显示的。
键入R显示寄存器和第一条指令，然后为2条MOV指令键入T命令。键入P去执行INT 21H，将会看到所显示的"your name"。
按Q退出，或者继续进行下一个练习（把IP复位为100）。
3.7.4使用INT进行键盘输入
这个从键盘上接受字符的练习又引入了一些新的特性。键入DEBUG命令A 100和以下这些汇编指令：
100   MOV AH,10
102   INT 16
104   JMP 100<Enter>，<Enter>
第一条MOV指令提供了功能码10H，它通知INT 16H从键盘上接收数据，该操作把来自键盘的字符传送到AL 寄存器。
键入R显示寄存器和第一条指令，然后键入T命令执行该指令。当为INT 16H键入P时，系统会等待你按键。
如果你按的是1键，那么会看到该操作把31H（ASCII字符'1'的十六进制表示）送到AL。键入T去执行JMP指令，将返回到在100处的MOV。
使用T去执行MOV。当为INT键入P时，系统会再一次等待你按键。如果你按2，就可以看到该操作把32H送到AL。你可以不受限制地继续像这样做下去。
可以得到在附录F中的键盘ASCII码的表。按Q键退出或继续进行下一个练习（把IP复位成100）。
3.8使用PTR操作符
下一个程序举例引入了某些新的特性。在这个例子中，你会在寄存器与存储单元之间进行数据的传送与相加。
在以前的程序中，把数据传送到寄存器，DEBUG能从寄存器（AL或AX）的长度来判断要传送多少字节。但是，这里的程序是要传送立即数据到存储器的。
由于象 MOV [120],25这样的指令不能指明字节的数量，这时，你可以使用PTR操作符。下面是指令：
100   MOV AX,[11A]   AX=2314H
103   ADD AX,[11C]   AX=2314H+0005H=2319H
107   ADD AX,25      AX=2319H+0025H=233EH
10A   MOV [11E],AX
10D   MOV WORD PTR [120],25
113   MOV BYTE PTR [122],30
118   JMP 100
11A   DB 1423
11C   DB 0500
11E   DB 0000
120   DB 000000
以下是这些指令的说明：
100：把存储单元11AH-11BH的内容传送到AX。方括号指出这是存储器地址，而不是立即值。
103：把存储单元11CH-1lDH的内容加到AX。
107：把立即值25H加到AX。
10A：把AX的内容传送到存储单元11EH-11FH。
10D：把立即值25H传送到存储单元120H-121H。
注意WORD PTR操作符的使用，这个操作符通知DEBUG值25H是传送给在存储器中的一个字。
如果你编写的指令是MOV [120]，25，则DEBUG将无法确定想要的长度并会显示ERROR（错误）信息。
尽管你很少需要使用PTR操作符，但是真需要它的时候，你就会理解它还是非常必要的。
113：把立即值30H传送到存储单元122H。这时，使用BYTE PTR操作符去指明一个字节的长度。
11A：定义字节值14H和23H。DB告诉DEBUG为数据项“定义字节”，这些数据项是指令（比如在100的一条）所要访问的。
11C，11E和120；定义程序中所用的其他字节值。
为了键入这一程序，首先键入A 100<Enter>，然后键入每条符号指令（但不要存储单元）。
最后，键入一个附加的回车键，从A命令退出。
为了执行程序，开始先键入R显示寄存器和第一条指令，然后连续键入了命令。当到达118的JMP时，停止执行。
键入D 110去查看改变了的AX的内容（233E）以及存储单元11EH-11FH（3E23）、120H-121H（2500）和122H（30）的内容。键入T去重复该程序或键入Q退出该程序。
本章中已经涉及了许多资料，这些资料通过复习可以理解得更加清楚。
3.9要点
DEBUG程序对于测试与调试机器语言程序和汇编语言程序是有用的。它的命令包括像显示、输入与跟踪这样一些有用的操作。
由于DEBUG对大、小写字母是不加区别的，所以可以用二者之中任何一种方法输入命令。
在DEBUG中，所有输入与显示的数都是十六进制的。
如果在数据段或代码段中输入一个不正确的值，那就要重新输入E命令去更正它。
使用T命令执行单条指令，使用P命令正确执行一个完整的INT操作。
为重新执行第一条指令，要把指针寄存器IP设置成0100。键入R（寄存器）命令后跟个选定的寄存器，如R IP，然后按回车键，DEBUG显示IP的内容并等待输入。
键入值100，接着按回车键。
3.10习题
3-1.说明以下DEBUG命令的用途：
（a）A，（b）U，（c）P，（d）T，（e）Q，（f）D，（g）R，（h）E。
A把符号指令汇编成机器码
D以十六进制格式显示一个存储区的内容
E从一个指定的存储单元开始，把数据输入到存储器中
G运行在存储器中的可执行程序
H完成十六进制算术运算
N给程序命名
P执行一组相关指令
Q退出DEBUG
R以十六进制格式显示一个或多个寄存器的内容
T跟踪一条指令的执行
U把机器码反汇编为符号码
3-2.分别写出满足下列要求的DEBUG命令：
（a）显示所有寄存器的内容。
R
（b）显示IP寄存器的内容并把它的内容改变成100H。
R IP
100
（c）显示在数据段中起始于偏移值2BCH的数据。
D ds:02BC
（d）显示起始于存储单元3AFH的数据（要求把这一地址分离成它的段和偏移值）。
d 003A:000F
（e）把在单元100H到12BH的符号码进行反汇编。
u cs:0100,012B
（f）把24A63BH键入数据段内起始于18AH的存储单元。
E ds:018A 24 A6 3B
3-3.为以下操作提供机器码指令（a）把十六进制立即值03A8加到AX，（b）把十六进制值2CA4传送到AX寄存器。
ADD AX,03A8H
MOV AX,2CA4H
3-4.假设已用DEBUG输入了以下E命令：
E CS:100 B8 45 01 05 25 00
十六进制45应该是54。编写另一个E命令去校正一个不正确的字节，即直接把45变成54.
E CS:101 54
3-5.在文本方式下，彩色显示器的视频显示区是在地址为B800[0]处。（a）使用DEBUG D命令显示这个区域。注意：视频区中的每个字符后面都跟着它的属性（07表示黑白的）。
使用附加的单个D命令去显示更多的部分。d b800:0
（b）使用DEBUG F（填充）命令用50个星号（2AH）部分地填充屏幕。
F b800:0 L64 2A 07
例如，以下的命令用4000（FA0H）个心形符号（03）与属性（这里，16H是指在蓝色背景下的褐色字符的属性）填入整个视频区域：F B800:0 LFA0 03 16。
3-6.假设已输入以下DEBUGE命令：
E CS:100 B8 05 1B 05 00 2C EB F8
（a）这里3条符号指令所表示的是什么？（参照本章第一个程序）
MOV AX,1B05H
ADD AX,2C00H
JMP 0100
（b）在执行这一程序时，你发现AX寄存器是以4705结束而不是预期的0547，错误是什么？你准备如何去更正它？
E CS:100 B8 1b 05 05 2c 00 EB F8
MOV AX,1B05H
ADD AX,2C00H
JMP 0100
（c）更正指令后，现在想从第一条指令起重新执行该程序，所需的DEBUG命令是什么？
R IP
100
3-7.考虑机器语言指令：
B0 1C D0 E0 B3 12 F6 E3 EB F6
这些指令完成以下操作：（a）把十六进制值1C传送到AL寄存器，（b）将AL的内容向左移一位（等于乘以2），AL=1CH*2=38H
（c）把十六进制值12传送到BL，（d）AL乘以BL。BL=12H,38H*12H=03F0H=1008
使用DEBUG的E命令从CS：100（记住这些是十六进制值）开始输入程序。下一步键入D CS：100去查看它。然后键入R和足够多相继的T命令，一步步地执行程序直到到达JMP。
AX中的最终乘积是什么？03F0H=1008
3-8.使用DEBUG的E命令，输入以下机器语言程序：
机器码（在100H）：A0 00 02 D0 E0 F6 26 01 02 A3 02 02 90
数据（在200H）：1E 16 00 00
该程序完成以下操作：（a）把DS：200处的字节内容（1E）传送到AL奇存器，（b）把AL的内容左移一位，AL=3CH
（c）AL乘以DS：0201处的一个字节内容（16），AX=3CH*16H=0528H=1320
（d）把乘积从AX传送到起始于DS：0202的字中。
键入D命令，查看代码和数据。然后键入R和足够多相继的T命令，步步地执行程序直到到达IMP为止。
AX中的最终乘积是什么？AX=0528H=1320
键入另一个D DS：0200并注意乘积是如何存放在DS：0202中的。
3-9.根据习题3-7编写命令。该命令在用HEXMULT.COM的名字，把程序写入磁盘（见附录C）。
e cs:0100 B0 1C D0 E0 B3 12 F6 E3 EB F6
n HEXMULT.COM
r bx
0000
r cx
000A
w
3-10.使用DEBUG的A命令，输入以下指令：
MOV DX,2E   DX=2EH
ADD DX,1F   DX=4DH
SHL DX,1   DX=9AH
SUB DX,BA   DX=9AH-BAH=-32=FFE0H
JMP 100
把这些指令反汇编并跟踪它们的执行情况，直到JMP为止，同时检查每条指令执行后的DX值。
3-11.中断指令的用途是什么？
使用INT（中断）指令，进入DOS或BIOS中断例行程序，实现所需功能后，再返回程序。
3-12.使用DEBUG建立并运行一个程序。该程序显示短语“Coffee Break”。由A 100开始输入指令并为该短语使用A 120（记住$定界符）。提示：参阅“使用INT完成显示”一节。
A CS:0100
MOV AH,09
MOV DX,120
INT 21
JMP 100
A DS:0120 
DB  'Coffee Break','$'
3-13.使用DEBUG建立并运行一个程序。该程序从键盘接收3个字符并加以显示。（a）由A 100开始。（b）使用INT 16接受一个字符到AL中并把该字符传送到单元[200]。
（c）使用第二个INT 16接受一个字符到AL中并把该字符传送到单元[201]。（d）使用第三个INT 16接受一个字符到AL中并把该字符传送到单元[202]。
（e）使用一个E 123 '$'命令在3个被存储的字符末尾定义一个‘$'。（f）最后，使用INT 21去显示这些字符。提示：参阅3.7.4节“使用INT进行键盘输入”。
A CS:0100
MOV AH,10
INT 16
MOV [200],AL
MOV AH,10
INT 16
MOV [201],AL
MOV AH,10
INT 16
MOV [202],AL
MOV BYTE PTR [203],24
MOV AH,09
MOV DX,200
INT 21
JMP 100
第二部分汇编语言的基础知识
第4章汇编语言编码要求
4.1引言
4.2汇编语言特性
4.3常规的段伪操作
4.4简化的段伪操作
4.5保护模式下的初始化
4.6定义数据类型
4.7相等伪操作
4.8要点
4.9习题
目的：阐述汇编语言程序与定义数据项的基本要求。
4.1引言
在第3章里，我们学习了如何利用DEBUG键入和执行机器语言程序。毫无疑问，机器码在理解方面是非常困难的，即使对于小程序也是一样。
利用DEBUG的A命令键入一个小的汇编源程序，毫无疑问它比机器码更加容易理解。DEBUG A命令的使用只是提供一种方便，从这一章起，你将开发更大的程序，
这将需要更多的对于程序进行文档处理与修改的能力。
编写汇编程序要遵循一套严格的规则，首先使用编辑程序或字处理程序把它作为文件键入到计算机中，然后使用汇编编译程序去读取该文件并把它转换成机器码。
在这一章里，我们说明开发汇编程序的基本要求：注释的使用，通用的编码格式，控制汇编程序列表的伪操作，以及定义段与过程的要求。
还会涉及程序的一般组织，包括初始化程序和结束程序的执行。最后要提及的是有关定义数据项方面的要求。
程序设计语言的两个主要级别是高级的和低级的。程序员用高级语言（如C或BASIC）编写程序，使用强有力的命令，这些命令中的每一个都可以生成许多机器语言指令。
另一方面，程序员用低级的汇编语言编写程序时，每条代码符号指令只能生成一条机器指令。
虽然用高级语言编码更为富有成效，但是用汇编语言编码也有它的一些优点，大体有以下几方面：
在管理专用的硬件设备方面提供了更多的控制方法。
生成较小的、更加紧凑的可执行模块。
更快的执行效果。
通常的做法是把2种级别程序设计的好处结合起来：工程中的大部分使用高级语言编码，而一些关键性的模块（会产生显著延迟的）则用汇编语言编码。
不管你使用的是什么程序设计语言，它仍是符号语言，还必须把它翻译成计算机能够执行的形式。高级语言使用编译程序把源码翻译成机器码（称为目标码）。
低级语言使用汇编程序把程序翻译成目标码。连接程序对高级语言与低级语言完成这样的过程：把目标码转换成可执行的机器语言。
4.2汇编语言特性
首先涉及的汇编语言的一些特性是：程序注释，保留字，标识符，语句，以及伪操作。
这些特性为语言提供了基本规则和框架。
4.2.1程序注释
遍及整个程序的注释的使用可以改善程序的清晰度，特别是在汇编语言程序中更是如此，因为一组指令的目的往往是不清楚的。
例如，指令MOV AH,10H把10H传送给AH是显而易见的，但是这么做的原因可能并不清楚。注释用一个分号（;）开始，可以把它放在任何地方，
汇编程序假定一行中所有在它右边的字符就是注释。注释可以包括任何可打印字符，连空格在内。
注释本身可以自成一行，如：
;Calculate productivity ratio（计算生产率）
或跟在指令之后的同一行里，如：
ADD AX,BX   ;Accumulate total quantity（累计总量）
因为注释只出现在汇编的源程序列表中，而且不产生机器码，所以你可以有任意数量的注释而不会对汇编程序的大小和执行有影响。
在本书中，所有汇编指令都是用大写字母，而所有注释都是用小写字母，这样做只是一种习惯并能使程序更具可读性。
从技术上说，指令和注释可以随便使用大写或小写字母。提供注释的另一个途径是用COMMENT伪操作，这将在第25章加以讨论。
4.2.2保留字
汇编语言里的某些名字是为它们固有的用途而保留的，只在特殊情况下使用。根据类型，保留字包括：
指令，如MOV和ADD，这些是计算机可执行的操作。
伪操作，如END或SEGMENT，可以利用它们为汇编程序提供信息。
操作符，如FAR和SIZE，可以在表达式中使用。
预定义符号，如@Data和@Model，它们在汇编期间向程序返回信息。错误地使用了保留字，会使汇编程序产生出错信息。见附录D有关保留字的表。
4.2.3标识符
标识符（或符号）是在程序中加到所希望访问的项上的名字。有两类标识符：名字和标号：
1.名字指的是一个数据项的地址，比如下列语句中的 COUNTER：
COUNTER DB 0
2.标号指的是指令、过程或段的地址，比如下列语句中的MAIN和B30：
MAIN PROC FAR
B30:ADD BL,25
名字与标号的规则是一样的。标识符可以使用以下字符：
类型                  容许的字符
字母表中的字母：A到Z与a到z
数字：                0到9（不能是第一个字符）
专用字符：         问号（?）
                         破折号，或下划线（_）
                         美元（$）
                         at（@）
                         点或句号（.）（不能是第一个字符）
标识符的第一个字符必须是字母或专用字符，但专用字符的点（.）除外。由于汇编程序使用一些@打头的专用字，所以应当避免把它用在你自己的定义中。
默认地，汇编程序把大写和小写字母看成是相同的（命令行有一个选项，该选项强制汇编程序对大小写敏感）。
MASM6.0以前，标识符的最大长度是31个字符，此后它可以是247个。有效名字的例子是TOTAL，QTY250，以及$P50。推荐使用描述性的、有意义的名字。
寄存器的名字，比如AH、BX和DX，它们是为访问这些寄存器而保留的。因此，在一条指令中，如ADD CX,BX，汇编程序知道CX和BX指的是寄存器。
然而，在一条MOV REGSAVE,CX的指令中，只有你把REGSAVE定义为一个数据项的名字，汇编程序才能识别它。
4.2.4语句
汇编程序是由一组语句组成的。语句的两种类型是：
（1）指令类，如MOV和ADD，汇编程序把它们翻译成目标码；
（2）伪操作类，通知汇编程序完成特定的动作，如定义数据项。
以下是语句的格式，其中方括号指明可选的输入：
[identifier]| operation [operand(s)][;comnent]
标识符（identifier）（如果有的话），操作（operation），以及操作数（operand（如果有的话）是用至少一个空格或制表符（tab）分隔开的。
MASM6.0以前，一行的最大字符数为132个，此后可以是512个。然而大多数程序员宁愿把它限制在80个字符以内，因为这是大多数屏幕可以容纳的最大数量。
两个语句的例子如下：
                  标识符         操作         操作数         注释
伪操作：     COUNT       DB           1                ;名字，操作，操作数
指令：        L30              MOV       AX,0           ;标号，操作，2个操作数
标识符，操作，以及操作数可以从任一列开始。但是，为了这些输入项能产生更为可读的程序，一般都是从同一列开始。
此外，许多编辑程序提供制表符（tab键）让每8个位置断开一下，以便于字段间留出空格。
正如在前面“标识符”标题下所说明的，术语名字是用作所定义的项目或伪操作的名字，而术语标号则是用作指令的名字。从现在起，我们将使用这些术语。
操作是语句中必须有的，最通常的用途是定义数据区和指令编码。对于数据项，如DB或DW那样的操作是定义字段、工作区或常数的。
对于指令，如MOV和ADD那样的操作是指明要完成的动作。
操作数（如果有的话）提供操作要用的信息，对于数据项，操作数定义它的初始值，例如，在以下名字为COUNTER的数据项定义中，
操作DB的意思是“定义字节”，操作数把它的内容初始化为零：
名字         操作         操作数         注释
COUNTER DB         0                 ;用初始的零值定义字节
对于一条指令，操作数指明要完成的动作。指令的操作数可以是一个、两个或甚至于没有。以下是3个例子：
操作         操作数         注释
RET                           ;从一个过程返回
INC          BX            ;BX寄存器加1
ADD        CX,25        ;将25加到CX寄存器中
4.2.5伪操作
汇编语言支持许多语句，那些语句允许你控制源程序汇编与列表的方式。这些语句称为伪操作，它们只在程序汇编过程中起作用，并且不产生机器可执行的代码。
基本的伪操作在下面几节加以说明。第25章将详细介绍所有的伪操作，任何时候都可以作为参考材料使用。
1.PAGE和TITLE列表伪操作
PAGE和TITLE伪操作用来控制被汇编的程序的列表格式。这是它们仅有的用途，并且不影响其后程序的执行。
在程序的起点，PAGE伪操作指定列在一页上的最大行数和在一行中的最大字符数。它的格式是：
PAGE   [length][,width]
例如，伪操作PAGE 60,132，每页长度是60行，每行宽度是132个字符。
典型的汇编程序，每页的行数可以在10到255的范围内，而每行的字符数可以在60到132的范围内。省略PAGE语句，汇编程序默认为PAGE 50,80。
假定程序定义PAGE的最大行数为60。当汇编程序打印所汇编的程序并已经列出60行时，会自动地翻到下一页的顶端并把页数加1。
你可能还想把一页从程序列表的一个指定行强行退出来，比如段结束。在所要求的行上，简单写上没有操作数的PAGE就可以了。
遇到PAGE时，汇编程序翻到下一页的顶端，从那里继续进行列表。
可以使用TITLE伪操作为程序产生一个标题，打印在程序列表的每页的第2行。只可以在程序的开始，编写一次TITLE。它的格式是：
TITLE text[comment]
对于文本（text），通常的做法是使用程序的名字作为磁盘上的目录。例如，把程序命名为ASMSORT，编写此名字并在其后加上可选的说明性注释（不要求用“；”作为前导），
整个长度可达到60个字符，如下所示：
TITLE ASMSORT Assembly program to sort CD title
2.段（SEGMENT）伪操作
正如在第2章所讨论的，.EXE格式的汇编程序是由一个或多个段组成的。在实模式下，堆栈段定义堆栈存储区，数据段定义数据项，而代码段则提供可执行的代码。
定义段的伪操作SEGMENT和ENDS的格式如下：
名字                  操作                  操作数
seqment-name SEGMENT        [align][combine['class']
segment-name ENDS
SEGMENT语句定义段的开始。段名（segment-name）必须存在，必须是唯一的，而且必须遵循汇编语言命名的惯例。
ENDS语句指明段的结束并包含与SEGMENT语句相同的名字。
在实模式下，段的大小最大是64KB。SEGMENT语句的操作数可包括3种类型的选项：定位，组合，以及类别：
定位（align）选项指明段开始的边界。典型的要求是PARA，它使段定位在小段的边界，这样一来，起始地址正好能被16或10H整除。省略定位操作符，汇编程序默认为PARA。
组合（combine）选项指明：当汇编后进行连接时，本段是否要与其他段组合在一起（稍后在“连接程序”中解释）。
组合类型是STACK，COMMON，PUBLIC，以及AT expression（AT表达式）。例如，堆栈段通常定义为：
segment-name SEGMENT PARA STACK
当你打算把分别汇编的程序在连接时组合在一起的时候，可以使用PUBLIC和COMMON。否则，当程序不要和其他程序组合时，可以省略这个选项或写上NONE。
类别（class）选项包在单引号中，它在连接时用于把相关的段组成一组。本书使用的类别是代码段用'code'（Microsoft推荐），数据段用'data'，而堆栈段用'stack'。
图4-1中的不完整的程序说明有各种选项的SEGMENT语句。注意：程序用定位（PARA）、组合（STACK）和类别（'Stack'）等类型定义堆栈段。
page 60,132
TITLE A04ASM1 Segments for an.EXE Program
;-----------------------------------------
STACK SEGMENT PARA STACK 'Stack'
...
STACK ENDS
;-----------------------------------------
DATASEG SEGMENT PARA 'Data'
...
DATASEG ENDS
;-----------------------------------------
CODESEG SEGMENT PARA 'Code'
MAIN PROC FAR
...
MAIN ENDP         ；过程结束
CODESEG ENDS   ；段结束
END MAIN         ；程序结束
图4-1为EXE程序定义段
3.PROC伪操作
代码段包含程序的可执行代码，该程序是由一个或多个过程组成的，过程的开始用PROC伪操作定义，结束则是用ENDP伪操作定义。格式如下：
名字                  操作                  操作数                  注释
procedure-name PROC            FAR                     ;过程开始
procedure-name ENDP                                       ;过程结束
过程名（procedure-name）必须存在，必须是唯一的，而且必须遵循汇编语言的命名惯例。
在这里的操作数是FAR，它与程序的执行有关。当请求执行一个程序时，装入程序使用这一过程作为入口点，去执行它的第一条指令。
ENDP伪操作指明过程的结束并包含和PROC语句相同的名字，使汇编程序能把结束与开始联系起来。
由于一个过程必须完全包含在一个段内，ENDP定义过程的结束要在ENDS定义段结束以前，如图4-1所示。
代码段可以包含任意数量的过程作为子程序，每个过程有它自己的一组相匹配的PROC和ENDP语句。附加的PROC通常使用（或默认为）NEAR作为操作数，这会在第7章说明。
4.END伪操作
如前所述，ENDS伪操作结束一个段，而ENDP伪操作则是结束一个过程。END伪操作结束一个完整的程序并作为最后语句出现，如图4-1所示。
它的格式（操作和操作数）是：
END [procedure-name]
如果程序不执行，操作数可以是空白的。例如，你可能打算只是汇编数据定义，或者想把程序与另模块相连接。
在大多数程序中，操作数包含第一个名字或者是PROC 指定为FAR的过程名，程序要从这里开始执行。
5.ASSUME伪操作
.EXE程序使用SS寄存器访问堆栈，DS访问数据段，CS访问代码段。为此，必须告诉汇编程序在程序当中每个段的用途。所需要的伪操作是ASSUME，在代码段中的编码如下：
ASSUME ss:stackname,ds:datasegname,cs:codesegname,......
SS:stackname的意思是让汇编程序把堆栈段的名字与SS寄存器联系在一起，对于所示的其他操作数都是类似的。操作数可以按照任何次序出现。
ASSUME还可以包含ES寄存器的入口，如ES:datasegname。假如你的程序不使用ES，则可以省略对ES的说明或编码为ES:NOTHING。
（从MASM6.0开始，汇编程序自动为代码段生成ASSUME。）如同其他伪操作一样，ASSUME只是一个帮助汇编程序把符号码转换成机器码的信息，
你仍然必须编指令使程序在开始执行时实实在在地把地址装入到段寄存器中。
6.处理器伪操作
大多数汇编程序都假定源程序是运行在基本的8086级别的计算机上。结果是当你用了由后来的处理器所提供的指令或特性时，必须用处理器伪操作来通知汇编程序，
比如.286，.386，.486，或.586。该伪操作可以直接出现在指令之前，代码段之前，或在保护模式下甚至可以出现在源程序的开始。
还有，使用扩充寄存器，如EAX，需要使用.386伪操作。
下面是要求处理器伪操作的某些指令：
.286                  .386                  .486
POPA         MOVSX/MOVZX   CMPXCHG
PUSHA         SHLD/SHRD         XADD
4.3常规的段伪操作
可执行程序的两种基本类型是，.EXE和.COM。我们首先阐述有关.EXE程序的要求，留下.COM程序到第5章说明。
图4-2提供展示堆栈、数据和代码段的.EXE程序的框架。以下按行号来解释程序中的语句：
行         解释
1         使用PAGE伪操作确定每页为60行与132列。
2         使用TITLE伪操作指出程序名为A04ASM1。
3         使用在第3，7和11行的注释清楚地表明所定义的3个段的开始。
4-6      定义堆栈段STACK（但在本例中没有它的内容）。
8-10   定义数据段DATASEG（但在本例中没有它的内容）。
12      定义代码段CODESEG。
13-20 定义代码段仅有的过程，在本例中命名为MAIN，这过程说明.EXE程序所共同要求的初始化和退出。
         初始化的两个要求是：（1）通知汇编程序哪些段与段寄存器相关联，（2）将数据段的地装入DS。
14      使用ASSUME伪操作告诉汇编程序把段和段寄存器联系起来，在这里，STACK和SS，DATASEG和DS，CODESEG和CS是相关联的：
ASSUME SS:STACK,DS:DATASEG,CS:CODESEG
1   page 60,132
2   TITLE A04ASM1 Skeleton of an.EXE Program
3   ;------------------------------------------------
4   STACK SEGMENT PARA STACK'Stack'
5   ...
6   STACK ENDS
7   ;------------------------------------------------
8   DATASEG SEGMENT PARA'Data'
9   ...
10  DATASEG ENDS
11  ;------------------------------------------------
12  CODESEG SEGMENT PARA'Code'
13  MAIN PROC FAR
14  ASSUME SS:STACK,DS:DATASEG,CS:CODESEG
15  MOV AX,DATASEG   ；把数据段地址；设置在DS中
16  MOV DS,AX
17  ...
18  MOV AX,4C00H   ；结束处理
19  INT 21H
20  MAIN ENDP
21  CODESEG ENDS
22  END MAIN；程序结束
图4-2.EXE程序的框架
利用段与段寄存器的联系，汇编程序可以确定在堆栈中各项的偏移地址、在数据段中各数据项的偏移地址和在代码段中指令的偏移地址。
例如，在代码段中的每条机器指令具有确定的长度。以机器语言表示的第一条指令应该在偏移地址为0处，假如它是2字节长，那么第二条指令应该位于偏移地址为2处，以此类推。
15，16初始化数据段的地址存入DS中：
MOV AX,DATASEG   ；取得数据段地址
MOV DS,AX   ;把地址存入DS
第一条MOV指令把数据段地址装入到AX寄存器中，第二条MOV则把地址从AX复制到DS。因为处理器只允许从通用寄存器到段寄存器传送数据，所以这两条MOV指令是必需的。
语句MOV DS,DATASEG是非法的，因为它试图把数据直接从存储器传送到DS。第5章会对初始化段寄存器作更详细的讨论。
18，19要求终止程序的执行并返回到操作系统。下一节会详细说明。
22使用END伪操作告诉汇编程序这是源程序的终点。MAIN操作数指出名为MAIN的过程是随后程序执行的入口点。
MAIN可以是汇编程序能够接受的其他名字，这只要PROC、ENDP与END使用相同的名字即可实现。
你所定义的段的顺序通常是不重要的。图4-2将它们定义如下：
STACK SEGMENT PARA STACK 'Stack'
DATASEG SEGMENT PARA 'Data'
CODESEG SEGMENT PARA 'Code'
注意：图中的程序是用符号语言编码的。为了执行它，必须使用汇编程序和连接程序把它们翻译成可执行的机器码，成为.EXE程序。
正如第2章所讨论的，当装入程序为执行一个.EXE程序把它从磁盘读入存储器时，就在可用内存的某个小段边界上构造一个256个字节（100H）的PSP（程序段前缀），
并立即把程序存放在紧跟着的边界上。然后，装入程序执行以下操作：
初始化代码段地址存入CS中；
初始化堆栈地址存入SS中；
初始化PSP的地址存入DS与ES中。
装入程序初始化CS:IP和SS:SP寄存器，以便处理器可以分别访问代码与堆栈段。然而，你的程序通常需要在DS中（通常也在ES中）的数据段地址，而不是PSP的地址。
因此，必须要用数据段的地址去初始化DS，正如在图4-2中用两条MOV指令所示的那样。现在，虽然对这种初始化还不算很了解，但可喜的是，
实际上每个.EXE程序初始化的步骤都是一样的，这样你只要编写一次，然后每次加以复制就可以了。
4.3.1结束程序执行
INT 21H是公用的DOS中断，它使用AH寄存器中的功能码指定所要完成的动作。INT 21H的众多功能包括：键盘输入，屏幕处理，磁盘I/O，以及打印输出。
这里与我们有关的功能是4CH，INT 21H把它识别成结束程序执行的请求。还可以利用这一操作，为后继的批处理文件测试（通过IF ERRORLEVEL语句）传递AL中的返回码，
就像这样：
MOV AH,4CH   ;请求结束处理
MOV AL,retcode   ;选择返回码
INT 21H   ;调用中断服务程序
对于正常完成的程序，返回码通常是0。也可以把两条MOV指令重新编写为一个语句（如图4-2所示）：
MOV AX,4C00H   ;请求正常退出
4.3.2源程序举例
图4-3把前述的信息组合成一个简单而又完整的汇编源程序，该程序在AX寄存器中把两个数据项相加。段是用以下方法定义的：
STACK包括一个项：DW（定义字），它定义32个被初始化为0的字，对于小程序而言大小是足够的。
DATASEG定义3个字，命名为FLDD（用215初始化），FLDE（用125初始化），以及FLDF（未初始化）。
CODESEG包含程序的可执行指令，最先的两个语句PROC和ASSUME不生成可执行码。
ASSUME伪操作告诉汇编程序完成以下任务：
赋值STACK到SS寄存器，使处理器使用SS中的地址去访问STACK。
赋值DATASEG到DS寄存器，使处理器使用DS中的地址去访问DATASEG。
赋值CODESEG到CS寄存器，使处理器使用CS中的地址去访问CODESEG。
page 60,132
TITLE A04ASM1（EXE）Move and add operations
;-------------------------------------------
STACK SEGMENT PARA STACK 'Stack'
DW 32 DUP (0)
STACK ENDS
;-------------------------------------------
DATASEG SEGMENT PARA 'Data'
FLDD DW 215
FLDE DW 125
FLDF DW ?
DATASEG ENDS
;-------------------------------------------
CODESEG SEGMENT PARA 'Code'
MAIN PROC FAR
ASSUME SS:STACK,DS:DATASEG,CS:CODESEG
MOV AX,DATASG
MOV DS,AX
MOV AX,FLDD
ADD AX,FLDE
MOV FLDF,AX
MOV AX,4C00H
INT 21H
MAIN ENDP
CODESEG ENDS
END MAIN
测试通过的完整程序如下
SSEG SEGMENT PARA STACK
DW 32 DUP (0)
SSEG ENDS
DSEG SEGMENT
FLDD DW 215
FLDE DW 125
FLDF DW ?
DSEG ENDS
CSEG SEGMENT
ASSUME SS:SSEG,DS:DSEG,CS:CSEG
MAIN PROC FAR
MOV AX,DSEG
MOV DS,AX
MOV AX,FLDD
ADD AX,FLDE
MOV FLDF,AX
MOV AX,4C00H
INT 21H
MAIN ENDP
CSEG ENDS
END MAIN
图4-3具有常观段的.EXE程序
当为了执行而把程序从磁盘装入到存储器时，装入程序在SS和CS中设置正确的段地址，并且正如头上两条MOV指令所表示的那样，程序必须初始化DS（通常还有ES）。
在第5章里，将汇编，连接，以及执行这一程序。
4.4简化的段伪操作
汇编程序提供了一些定义段的捷径。为了使用它们，在定义任何段之前，必须初始化存储模型。不同的模型告诉汇编程序如何使用段，为目标码提供足够的空间，
以及确保最佳的执行速度。它的格式（包括前面的圆点）是：.MODEL memory-mode
l存储模型（memory model）可以是Tiny（微型），Small（小型），Medium（中型），Compact（紧凑型），Large（大型），Huge（巨型），或Flat（平面型）。
根据MASM 6.0和TASM4.0，Tiny模型是为.COM程序而设计的，该程序的数据、代码和堆栈都在一个64KB的段里。
Flat模型为代码和数据定义了一个多达4GB的区域，程序采用32位寻址方式并在保护模式的Windows下运行。
其它模型的要求是：
模型                  代码段数量                  数据段数量
SMALL              1<=64KB                    1<=64KB
Medium          任意数量，任意大小      1<=64KB
Compact          1<=64KB                  任意数量，任意大小
Large              任意数量，任意大小    任意数量，任意大小
Huge              任意数量，任意大小     任意数量，任意大小
可以在单独的程序（即不需和其他程序连接的程序）中使用这些模型中的任何一个。
Small模型适用于本书中大多数例子，汇编程序采用的地址是近的（在64K范围内）并产生16位的偏移地址。相反，对于Compact模型，汇编程序采用32位地址，
因而也就需要更多的执行时间。Huge 模型和Large模型是一样的，但可以包含诸如大于64K数组的变量。
.MODEL伪操作自动地为所有模型产生所需要的ASSUME语句。
表8.2小型模式下的段名和类型
伪指令          段名             定位类型           组合类型       类别               组名
.CODE          _TEXT          WORD             PUBLIC          'CODE'
.FARDATA   FAR_DATA  PARA               PRIVATE        'FAR_DATA'
.FARDATA? FAR_BSS      PARA               PRIVATE        'FAR_BSS'
.DATA         _DATA         WORD             PUBLIC          'DATA'           DGROUP
.CONST       CONST        WQRD             PUBLIC          'CONST'        DGROUP
.DATA?       _BSS             WORD             PUBLIC          'BSS'              DGROUP
.STACK       STACK          PARA               STACK           'STACK'         DGROUP
定义堆栈、数据和代码段的伪操作的格式（包括前面的圆点）是：
.STACK   [size]
.DATA
.CODE   [segment-name]
上述每一个伪操作都会使汇编程序产生所需要的SEGMENT语句和与其相匹配的ENDS。
默认的段名（不必定义它）是STACK，_DATA，以及_TEXT（对于Ting、Small、Compact和Flat模型的代码段而言）。
_DATA和_TEXT前面的破折号（或下划线）是必须的。默认的堆栈大小是1024个字节，可以不管它而自己定义大小。
正如编码格式所指明的那样，可以不管代码段的默认段名，使用这些伪操作去确定3个段在程序中的位置。但是要注意：现在用于初始化DS中的数据段地址的指令是：
MOV AX,@data   ;用数据段的地址来
MOV DS,AX      ;初始化DS
图4-3给出一个使用常规方式定义段的程序的例子。现在图4-4提供同样的例子，但这次是使用简化段伪操作.STACK，.DATA，以及.CODE。存储模型指定为Small，位于第4行。
堆栈定义为64字节（32个字）。注意；汇编程序不产生常规的SEGMENT和ENDS语句，并且不需要编写ASSUME语句。
page 60,132
TITLE AO4ASM2（EXE）Move and add operations
;------------------------------------------------------
.MODEL SMALL
.STACK 64
.DATA
FLDD DW 215
FLDE DW 125
FLDF DW ?
;------------------------------------------------------
.CODE
MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV AX,FLDD
ADD AX,FLDE
MOV FLDF,AX
MOV AX,4C00H
INT 21H
MAIN ENDP
END MAIN
图4-4使用简化的段伪操作的EXE程序
测试通过的完整程序如下
.MODEL SMALL
.STACK 64
.DATA
FLDD DW 215
FLDE DW 125
FLDF DW ?
.CODE
MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV AX,FLDD
ADD AX,FLDE
MOV FLDF,AX
MOV AX,4C00H
INT 21H
MAIN ENDP
END MAIN
存储模型说明伪指令.MODEL SMALL除了说明程序采用的存储模型外，还起着相当于如下语句的作用：
DGROUP GROUP _DATA,CONST,_BSS,STACK
ASSUME CS:_TEXT,DS:DGROUP,SS:DGROUP
下一章将会看到，汇编程序对于使用简化段伪操作编码的程序和使用常规段伪操作的程序在处理上是有微小差别的。
.STARTUP和.EXIT伪操作
MASM 6.0引入.STARTUP和.EXIT伪操作来简化程序的初始化和结束。.STARTUP产生指令去初始化各段寄存器，而.EXIT则产生功能为4CH的INT 21H指令退出程序。
这些伪操作需要.MODEL伪操作，并且对于除了Flat模型外的所有存储模型都是有效的。
为了学习汇编语言，本书中的例子使用全套指令系统而把捷径留给更有经验的程序设计人员。
4.5保护模式下的初始化
程序在Windows下以保护模式运行并定义Flat型的存储模型。由于段的寻址已扩展到32位，所以单个可寻址的程序区可以达到4GB。程序的框架模型是：
.386 or .486      ;首先是处理器伪操作
.MODEL FLAT,STDCALL
.STACK
.DATA      ;随后是所有数据
.CODE      ;随后是指令代码
END
在.MODEL语句前编写处理器伪操作使汇编程序采用32位寻址方式。STDCALL告诉汇编程序对于名字和过程调用使用标准的规定。
由于不必要把段：偏移值转换成实际地址，所以处理器的操作会更为有效。在实模式下，数据和指令的偏移值是16位，而在保护模式下偏移值是32位。
使用DWORD把段对准在双字地址上，能加速对32位数据总线的存储器的存取。类型USE32指示汇编程序产生适合于32位保护模式的代码：
segment-name SEGMENT DWORD USE32
由于这些处理器的DS仍然是16位，所以DS寄存器的初始化如下：
MOV EAX,DATASEG       ;得到数据段的地址
MOV DS,AX      ;把16位部分装入DS
STI，CLI，IN，以及OUT指令在实模式下是可用的，但不允许用在保护模式下。
4.6定义数据类型
如前所述，.EXE程序中的数据段包含常数，工作区，以及输入/输出区。汇编程序提供了一组伪操作，它们允许定义不同类型和长度的项，
例如，DB定义字节，而DW定义字。数据项可以包含未定义的（即未初始化的）值，也可以包含初始化的常数，所定义的或者是字符串，或者是数字值。
下面是数据定义格式：
[name] Dn expression
（1）名字（Name）。程序是通过名字来访问数据项的。上述定义中的方括号表明名字是可选项。先前的“语句”一节提供了命名规则。
（2）伪操作（Dn）。定义数据项的伪操作是DB（字节），DW（字），DD（双字），DF（远字），DQ（4字），以及DT（10字节），
每一个都明确地指出了所定义的项的长度。MASM6.0引入了BYTE，WORD，DWORD，FWORD，QWORD，以及TWORD，它们分别对应于上述伪操作。
原来的术语在汇编语言的许多版本中仍然是通用的。
（3）表达式（Expression）。操作数中的表达式可以指定未初始化的值或常数值，为了指明未初始化的项，用问号定义操作数，比如
DATAX DB ?   ;未初始化项
在这种情况下，当程序开始执行时，DATAX的初始值是未知的。使用这一项之前的通常做法是向它传送某些值，这些值必须符合所定义的大小。
可以用操作数去定义常数，比如DATAY DB 25   ;初始化项
在整个程序中，可以自由地使用这个初始化值25，甚至可以改变该值。
表达式可以包含用逗号分开的多个常数，它只受行长度的限制，如下所示：
DATAZ DB 21,22,23,24,25,26,...
汇编程序是以相邻的字节从左到右定义这些常数的。对于DATAZ的访问是访问第一个一字节常数21（可以把第一个字节看成是DATAZ+0），
而对DATAZ+1的访问则是访问第二个常数22。例如，指令MOV AL,DATAZ+3把24（18H）这个值装入到AL寄存器。
表达式还允许在如下格式的语句中重复常数：[name] Dn repeat-count DUP（expression）...
以下的例子说明这种重复：
DW 10 DUP (?)   ;10个字，未初始化
DB 5 DUP (12)   ;5个字节，为hex 0C 0C 0C 0C 0C
DB 3 DUP (5 DUP (4))   ;15个4
第三个例子产生数字4的5次复制（44444）并重复该值3次，总共是15个4。
表达式可以定义和初始化字符串或数字常数。
4.6.1字符串
字符串用于描述比如人名或产品说明等。串是在单引号内定义的，如'PC'，或在双引号内定义，如"PC"。
汇编程序把引号中的内容以ASCII形式作为目标码存储，不包括引号。在MASM中，DB（或BYTE）是定义2个以上字符的字符串的仅有格式，
这些字符以左相邻的方式并按正常的从左到右的顺序（就像名字和地址一样）存放。因此，对于定义任意长度的字符数据来说，DB是常用的格式。例如：
DB 'Computer city'
如果串中必须包含单引号或双引号，可以用以下方法之一来定义它：
DB "Crazy Sam's CD Emporium"   ;双引号用于串，单引号用作撤号
DB 'Crazy Sam''s CD Emporium'   ;单引号用于串，2个单引号用作撤号
4.6.2数字常数
数字常数用于定义算术运算的值与存储器地址。常数不定义在引号内，但要跟随一个可选的基数区分符，比如十六进制值12H中的H。
对于大多数数据定义伪操作，汇编程序把所产生的字节按相反顺序（即从右到左）存放在目标码中。以下是各种数字格式：
（1）二进制。二进制格式使用二进制数字0和1，后跟基数区分符B。二进制格式通常用在位处理指令AND，OR，XOR，以及TEST中作为识别位的值。
（2）十进制。十进制格式使用十进制数字0到9，后跟（可以选择）基数区分符D，如125或125D。
尽管汇编程序为编码的方便允许你用十进制格式定义值，但还是要把十进制值转换成二进制目标码并用十六进制格式表示它们。例如，定义的十进制的125就变成了hex7D。
（3）十六进制。十六进制格式使用十六进制数字0到F，后跟基数区分符H。
由于汇编程序希望对于字母开头的访问是符号名，所以十六进制常数的第一个数字必须是0到9。例如，3DH和0DE8H，汇编程序分别把它们存放为3D和按字节相反顺序的E80D。
因为汇编程序要把全部数字值都转换成二进制（并把它表示成十六进制），十进制12、十六进制C和二进制的1100的定义都产生相同的值：二进制的00001100或十六进制的0C，
这取决于你如何观察字节的内容。
由于字母D和B既作为基数区分符又是十六进制数字，这可能会造成某些混乱。作为解决办法，MASM6.0引入了T（代表10）和Y（代表二进制）
分别用作十进制与二进制的基数区分符。
（4）实数。汇编程序把给定的实数（十进制或十六进制常数后跟基数区分符R）转换成用于数值协处理器的浮点格式。
务必要把字符和数字常数的用法区分开来。例如，定义成DB '24'的字符常数会产生两个ASCII字符，表示为hex3234。
而定义成DB 24的数字常数则产生二进制数，表示为hex 18。
4.6.3定义数据的伪操作
下面列出了用于定义数据的一般伪操作与由MASM6.0所引入的伪操作：
定义                  一般的伪操作                  MASM 6.0伪操作
字节                 DB                                  BYTE
字                    DW                                 WORD
双字                 DD                                 DWORD
远字                 DF                                  FWORD
4字                  DQ                                 QWORD
10字节             DT                                  TBYTE
本书使用的是一般的伪操作，因为它们通用。
图4-5的汇编语言程序中提供DB、DW、DD和DQ伪操作定义字符串与数字常数的例子。生成的目标码列在左边。注意未定义值的目标码表现为十六进制的零。
这个程序只由一个数据段组成，而没有可执行的指令，它是不适于执行的。
（1）DB或BYTE：定义字节。DB或BYTE数字表达式可以定义一个或多个一个字节的常数，每个由2个十六进制数字组成。
对于无符号数字数据，值的范围是0到255；对于带符号的数据，值的范围是-128到+127。汇编程序把数字常数转换成二进制目标码（以十六进制表示）。
在图4-5中，第一个定义BYTE1使用'?'去指定未初始化的值。DB数字常数是BYTE2、BYTE3、BYTE4和BYTE5。例如，汇编程序把所定义的值48转换成hex30。
DB字符表达式可以包含任意长的串直到行结束。例如，在图中所见的BYTE6和BYTE7。十六进制目标码表示每个字节的ASCIl字符按正常从左到右顺序列出，其中20H代表空格。
BYTE8表示适用于定义表格的数字与串常数的混合。
page 60,132
TITLE A04DEFIN（EXE）Define data directives
.MODEL SMALL
.DATA
;DB - Define Bytes
BYTE1 DB ?
BYTE2 DB 48
BYTE3 DB 30H
BYTE4 DB 01111010B
BYTE5 DB 10 DUP (0)
BYTE6 DB 'PC Emporium'
BYTE7 DB '12345'
BYTE8 DB  01,'Jan',02,'Feb',03,'Mar'
;DW - Define Words
WORD1 DW 0FFF0H
WORD2 DW 01111010B
WORD3 DW BYTE8
WORD4 DW 2,4,6,7,9
WORD5 DW 8 DUP (0)
;DD - Define Doublewords
DWORD1 DD ?
DWORD2 DD 41562
DWORD3 DD 24,48
DWORD4 DD BYTE3 - BYTE2
;DQ - Define Quadwords
QWORD1 DQ 0
QWORD2 DQ 05E39H
QWORD3 DQ 41562
END
图4-5字符与数字数据的定义
（2）DW或WORD：定义字。DW或WORD伪操作定义长度为一个字（两个字节）的项。
DW数字表达式可以定义一个或多个一个字的常数。对于无符号的数字数据，值的范围是0到65535；对于带符号的数据，值的范围是-32768到+32767。
汇编程序把DW数字常数转换成二进制目标码（以十六进制表示），但是以相反顺序存放字节，因此，被定义为12345的十进制值转换成了hex3039，但按3930存放。
在图4-5中，WORD1和WORD2定义DW数字常数。WORD3定义操作数为一个地址，在这种情况下，是BYTE8的偏移地址。产生的目标码是001E（石边的R是指浮动的），
而核对一下图中的BYTE8的偏移地址（最左边一列）确实就是001E。
WORD4定义一个有5个数字常数的表。注意；每个常数的长度是一个字（两个字节）。
WORD5定义一个用8个0初始化的表。
在MASM下DW字符表达式被限制为2个字符，所以仅限于定义字符串。
（3）DD或DWORD：定义双字。DD或DWORD伪操作定义长度为双字（4个字节）的项。DD数字表达式可以定义一个或多个常数，每个最多4个字节（8个十六进制数字）。
对于无符号数字数据，值的范围是0到4294967295；对于带符号的数据，值的范围是-2147483648到+2147483647。
汇编程序把DD数字常数转换成二进制目标码（以十六进制表示），但是以相反顺序存放字节。
因此，汇编程序把定义为12345678的十进制数转换成00BC614EH并存放成4E61BC00H。
在图4-5中，DWORD2定义一个DD数字常数，而DWORD3则定义2个数字常数。DWORD4产生2个所定义地址之间的差值，在这种情况下，结果是BYTE2的长度，即一个字节。
在MASM下DD字符表达式被限制为4个字符，同这种情况下的DW一样没有多大价值。在4字节的双字中，汇编程序向右对准字符。
（4）DQ或QWORD：定义4字。DQ或QWORD伪操作定义长度为4个字（8个字节）的项。DQ数字表达式可以定义一个或多个常数，每个最多8个字节（16个十六进制数字）。
最大的正的4字十六进制数是7后面跟着15个F。作为这个数大小的一种表示，十六进制1后面跟着15个0等于十进制数1152921504606846976。
汇编程序处理DQ数字值和字符串与它处理DD和DW数字值是一样的。在图4-5中，QWORD1、QWORD2和QWORD3说明这些数字值。
4.6.4显示数据段
把源程序转换成机器码需要两个步骤：汇编和连接。虽然对于图4-5，汇编程序没有产生出错信息，但连接程序显示了“Warming:No STACK Segment”（警告：没有堆栈段）
和“There were 1 error detected（发现一个错误）。不管该警告，仍可以用DEBUG去查看目标码，如图4-6所示。
如果提前看一下第5章内容，那么就可以汇编和连接该程序。然后使用DEBUG装入.EXE文件并键入D DS:100显示数据。右边显示ASCII表达式，如“PC Emporium”。
而在左边的十六进制值则指明实际的存储内容。显示的应该和图4-6中偏移值为0100到019D的情况相同。可以预料段地址（在图中是0D98）和程序结束后的数据会不一样。
为了显示而发送DS：100的理由是因为装入程序用PSP的地址设置DS，而这个程序的数据段是从该地址之后100个字节开始的。
以后，为.EXE程序使用DEBUG时，因为该程序把DS初始化为数据段地址，所以可以用DS：0去显示它。
4.7相等伪操作
汇编语言提供了等号，EQU和TEXTEQU伪操作。它们是为了用其他名字再定义符号名，以及用名字再定义数字值而提供的。
这些伪操作不能把数据存储起来，也就是说，在程序执行时，是不能在EQU项做加法的，而是汇编程序在其他语句中用所定义的值去代替。
相等伪操作的优点是许多语句都可以使用所赋予的值。如果这个值必须要修改时，只需要修改相等语句。它的效果是使程序更具可读性，而且更易于维护。
（1）等号伪操作。等号伪操作允许把表达式的值指派给一个名字，并且可以在程序中指派任意次。以下例子说明它的用法：
VALUE_OF_PT = 3.1416
RIGHT_COL = 79
SCREEN_POSITIONS = 80*25
使用上述伪操作的例子是：
IMUL AX,VALUE_OF_PT      ;AX乘以3.1416
CMP BL,RIGHT_COL      ;把BL与79比较
MOV CX,SCREEN_POSITIONS      ;把2000传送到CX
当用这一伪操作定义双字值时，首先要使用.386伪操作去通知汇编程序：
.386
DBLWORD1 = 42A3B05CH
（2）EQU伪操作。考虑以下在数据段中编写的EQU语句：
FACTOR EQU 12
在这种情况下，名字FACTOR可以是汇编程序能够接受的任何名字。现在，每当FACTOR出现在一条指令中或另一个伪操作中时，汇编程序都会用12这个值来替代。
例如，汇编程序把伪操作TABLEX DB FACTOR DUP (?)转换成它的等效值TABLEX DB 12 DUP (?)
TABLEX只能用EQU定义一次，它不能用另一个EQU来再定义。指令也可以包含相等的操作数，如下所示：
RIGHT_COL EQU79
MOV CX,RIGHT_COL   ;把79传送到CX
还可以使符号名相等，比如在以下的代码中：
ANNL_TEMP DW 0
AT EQU ANNL TEMP
MPY EQU MUL
第一个EQU使AT与所定义的项ANNL_TEMP相等。对于任何包含操作数AT的指令，汇编程序都会用ANNL_TEMP的地址去取代它。
第二个EQU能使程序用MPY去代替规则的符号指令MUL。
（3）TEXTEQU伪操作。MASM6.0引入TEXTEQU伪操作来再定义文本数据，格式如下：
name TEXTEQU <text>
可以在角括号（<>）内定义字符文本（text），例如：
PROMPT_MSSGE TEXTEQU <'Add，Change，or Delete?'>
使用方法如下：
USER_PROMPT DB PROMPT MSSGE
汇编程序把这个定义转换为
USER_PROMPT DB 'Add，Change，or Delete?'
4.8要点
在一行中，注释的前面要用分号。
在汇编语言中，保留字只为达到专门目的而使用，即它是专用的。
标识符是程序中适用于项的名字。标识符的两种类型是名字（指的是数据项的地址）和标号（指的是指令的地址）。
操作通常是用于定义数据区和编码的指令。操作数提供操作作用于其上的信息。
程序由一个或多个段组成，每个段都是从小段边界开始的。
ENDS伪操作结束一个段，ENDP结束一个过程，而END则是结束程序。ASSUME伪操作把段寄存器CS、DS与SS和与其相应的段名联系起来。
对于.EXE程序，通常要用数据段的地址去初始化DS。对于简化段伪操作，在定义任何段之前要初始化存储模型。
INT 21H的4CH功能是退出程序的标准指令。
数据项的命名应当是唯一的和具有描述性的。
DB（或BYTE）是定义字符串的优先选用格式，因为它允许串的长度大于2个字节并把它们转换成正常的从左到右的序列。
十进制与二进制（十六进）常数会产生不同的值。考虑比较一下十进制25和十六进制25在加法中的效果：
ADD CX,25      ;加25
ADD CX,25H   ;加37
对于DW、DD和DQ，汇编程序在目标码里按相反的字节顺序存放数字值。
DB项用于处理半个寄存器（AL，BL，等等），DW用于整个寄存器（AX，BX，等等），而DD则用于扩充寄存器（EAX，EBX，等等）。较长的数据项需要特殊的处理。
4.9习题
4-1.编译程序与汇编程序的区别。
高级语言使用编译程序把源码翻译成目标码。低级语言使用汇编程序把源码翻译成目标码。连接程序把目标码转换成可执行的机器语言。
4-2.汇编语言中的保留字是什么？给出2个例子。
汇编语言里的保留字是为专门用途而保留的，只在特殊情况下使用。根据类型，保留字包括：
指令，如MOV和ADD，这些是计算机可执行的操作。
伪操作，如END或SEGMENT，可以利用它们为汇编程序提供信息。
操作符，如FAR和SIZE，可以在表达式中使用。
预定义符号，如@Data和@Model，它们在汇编期间向程序返回信息。
4-3.汇编语言中标识符的两种类型是什么？
标识符是在程序中加到所希望访问的项上的名字。有两类标识符：名字和标号。
名字指的是一个数据项的地址，标号指的是指令、过程或段的地址，名字与标号的规则是一样的。
4-4.对于以下在数据段中所定义的项，确定哪些是合法的，如果不合法，请说明原因。
（a）$50，（b）AT&T，（c）$_A，（d）23AC，（e）EBX。
合法，不合法（不能使用&），合法，不合法（标识符的第一个字符必须是字母或专用字符），不合法（EBX是32位寄存器）
标识符可以使用以下字符：
类型                  容许的字符
字母表中的字母：A到Z与a到z
数字：                0到9（不能是第一个字符）
专用字符：         问号（?）
                         破折号，或下划线（_）
                         美元（$）
                         at（@）
                         点或句号（.）（不能是第一个字符）
标识符的第一个字符必须是字母或专用字符，但专用字符的点（.）除外。由于汇编程序使用一些@打头的专用字，所以应当避免把它用在你自己的定义中。
默认地，汇编程序把大写和小写字母看成是相同的（命令行有一个选项，该选项强制汇编程序对大小写敏感）。
4-5.说明指令与伪操作之间的区别，每种各举2个例子。
指令，如MOV和ADD，汇编程序把它们翻译成目标码；
伪操作，通知汇编程序完成特定的动作，如定义数据项。
MOV AX,BX
ADD AX,BX
MESSAGE DB 'HELLO','$'
ASSUME CS:CSEG,DS:DSEG,SS:SSEG
4-6.给出伪操作，使汇编程序在程序列表时（a）在页的顶端打印一个标题，（b）前进到新页。
TITLE A04ASM1 Move and add operations
在所要求的行上，简单写上没有操作数的PAGE，遇到PAGE时，汇编程序翻到下一页的顶端，从那里继续进行列表。
4-7.用什么方法（如果有的话）使汇编程序把大小写字母区别看待？
默认地，汇编程序把大写和小写字母看成是相同的（命令行有一个选项，该选项强制汇编程序对大小写敏感）。
MASM汇编程序的命令行可选项/Cp使得汇编对所有符号均按大小写区别对待。
MASM汇编程序的命令行可选项/Cx使得汇编只对公共标识符和外部标识符等按大小写区别对待。
/Cp
Preserves case of all user identifiers.
/Cx
Preserves case in public and extern symbols.
4-8.SEGMENT伪操作的格式是
Name SEGMENT align combine 'class'
说明（a）align（定位），（b）combine（组合），（c）class'（类别）的用途。
SEGMENT语句定义段的开始。段名必须存在，必须是唯一的，而且必须遵循汇编语言命名的惯例。
ENDS语句指明段的结束并包含与SEGMENT语句相同的名字。
在实模式下，段的大小最大是64KB。SEGMENT语句的操作数可包括3种类型的选项：定位，组合，以及类别：
定位（align）选项指明段开始的边界。典型的要求是PARA，它使段定位在小段的边界，这样一来，起始地址正好能被16或10H整除。省略定位操作符，汇编程序默认为PARA。
组合（combine）选项指明：当汇编后进行连接时，本段是否要与其他段组合在一起。
组合类型是STACK，COMMON，PUBLIC，以及AT expression（AT表达式）。例如，堆栈段通常定义为：
segment-name SEGMENT PARA STACK
当你打算把分别汇编的程序在连接时组合在一起的时候，可以使用PUBLIC和COMMON。否则，当程序不要和其他程序组合时，可以省略这个选项或写上NONE。
类别（class）选项包在单引号中，它在连接时用于把相关的段组成一组。
4-9.（a）说明过程的意义。（b）什么时候把过程定义为NEAR？（c）什么时候把过程定义为FAR？（d）如何定义过程的开始与结束？
代码段包含程序的可执行代码，该程序是由一个或多个过程组成的，过程的开始用PROC伪操作定义，结束则是用ENDP伪操作定义。
ENDP伪操作指明过程的结束并包含和PROC语句相同的名字，使汇编程序能把结束与开始联系起来。
过程名必须存在，必须是唯一的，而且必须遵循汇编语言的命名惯例。
代码段可以包含任意数量的过程作为子程序，每个过程有它自己的一组相匹配的PROC和ENDP语句。
如果过程和调用过程的代码在相同的代码段内，把过程定义为NEAR。如果过程和调用过程的代码在不同的代码段内，把过程定义为FAR。
由于一个过程必须完全包含在一个段内，ENDP定义过程的结束要在ENDS定义段结束以前。
4-10.与结束（a）一个过程，（b）一个段，（c）一个程序相关的语句是什么？
ENDS伪操作结束一个段，ENDP伪操作结束一个过程，END伪操作结束一个完整的程序并作为最后语句出现。
END [procedure-name]
4-11.指出结束汇编的语句和结束执行的语句。
使用END伪操作告诉汇编程序这是源程序的终点。END可选的操作数指出程序执行的入口点。
MOV AH,4CH   ;请求结束执行
MOV AL,retcode   ;返回码
INT 21H   ;调用中断服务程序
对于正常完成的程序，返回码通常是0。也可以把两条MOV指令重新编写为一个语句：
MOV AX,4C00H   ;请求正常退出
4-12.给出堆栈段、数据段和代码段的名字分别为STKSEG、DATSEG和CODSEG，写出所需要的ASSUME语句。
ASSUME CS:CODSEG,DS:DATSEG,SS:STKSEG
4-13.考虑与INT 21H一起使用的指令MOV AX,4C00H。（a）说明指令完成什么工作，（b）说明4C00H的用途。
AH是4CH，AL是返回码，INT 21H把它识别成结束程序执行的请求。
MOV AH,4CH   ;请求结束处理
MOV AL,retcode   ;返回码
INT 21H   ;调用中断服务程序
对于正常完成的程序，返回码通常是0。把两条MOV指令重新编写为一个语句：
MOV AX,4C00H   ;请求正常退出
4-14.为了简化段伪操作，.MODEL伪操作提供了Tiny、Small、Medium、Compact，Large和Flat型的存储模型。每种模型在什么情况下使用？
存储模型（memory model）可以是Tiny（微型），Small（小型），Medium（中型），Compact（紧凑型），Large（大型），Huge（巨型），或Flat（平面型）。
Tiny模型是为.COM程序而设计的，该程序的数据、代码和堆栈都在一个64KB的段里。
Flat模型为代码和数据定义了一个多达4GB的区域，程序采用32位寻址方式并在保护模式的Windows下运行。
其它模型的要求是：
模型                  代码段数量                  数据段数量
SMALL              1<=64KB                    1<=64KB
Medium          任意数量，任意大小      1<=64KB
Compact          1<=64KB                  任意数量，任意大小
Large              任意数量，任意大小    任意数量，任意大小
Huge              任意数量，任意大小     任意数量，任意大小
Huge 模型和Large模型是一样的，但可以包含诸如大于64K数组的变量。
.MODEL伪操作自动地为所有模型产生所需要的ASSUME语句。
4-15.给出以下数据伪操作所产生的字节长度：（a）DW，（b）DQ，（c）DB，（d）DD。
2字节，8字节，1字节，4字节
定义                  一般的伪操作                  MASM 6.0伪操作
字节                 DB                                  BYTE
字                    DW                                 WORD
双字                 DD                                 DWORD
远字                 DF                                  FWORD
4字                  DQ                                 QWORD
10字节             DT                                  TWORD
4-16.定义名为CO_NAME的字符串，其中包含“Internet Services”作为常数。
DB 'Internet Services'
4-17.在名为ITEM1到ITEM5的数据项中，定义以下数字值，分别为：
（a）一个1字节项包含等价于十进制71的十六进制值。
（b）一个2字节项包含一个未定义值。
（c）一个4字节项包含等价于十进制7524的十六进制值。
（d）一个1字节项包含等价于十进制47的二进制值。
（e）一个项包含连续的字的值是6，9，14，18，23，29，31和38。
ITEM1 DB 47H
ITEM2 DW ?
ITEM3 DD 1D64H
ITEM4 DB 00101111B
ITEM5 DW 6,9,14,18,23,29,31,38
4-18.写出（a）DB 82，（）DB '82'，（c）DB 4 DUP ('5') 所产生的十六进制目标码。
52H,38H、32H，35H、35H、35H、35H
4-19.对于（a）DB 72，（b）DW 2ABEH，（c）DD 1EB6C3H，（d）DQ 24C3E29H 确定由汇编程序存放的十六进制目标码。
48H，BEH、2AH，C3H、B6H、1EH，29H、3EH、4CH、02H
4-20.（a）使用EQU伪操作把16H的值再定义为ATTRIBUTE。（b）用MOV指令把ATTRIBUTE 传送到BL寄存器。
ATTRIBUTE EQU 16H
MOV BL,ATTRIBUTE
第5章汇编、连接与执行程序
5.1引言
5.2为汇编与执行准备程序
5.3二遍扫视汇编程序
5.4连接目标程序
5.5执行程序
5.6交叉引用表
5.7出错诊断
5.8汇编程序位置计数器
5.9编写.COM程序
5.10要点
5.11习题
目的：阐明汇编、连接与执行汇编语言程序的各个步骤
5.1引言
本章阐述键入汇编语言程序并对它进行汇编、连接与执行的过程。用汇编语言进行编码的符号指令称为源程序。用汇编程序把源程序翻译成机器码，称为目标程序。
最后，再用连接程序完成对于目标程序的机器寻址，生成可执行模块。
有关汇编的几节，说明如何请求汇编程序的执行，汇编程序提供诊断（包括出错信息）并产生目标程序。
还要详细说明汇编程序列表并大致地介绍汇编程序如何处理源程序。
有关连接的几节，说明如何请求连接程序的执行，以便能生成可执行模块。
还要说明产生连接映像的细节，以及连接程序的诊断。最后讨论如何请求可执行模块的执行。
最后一节，解释如何去编码、转换和执行.COM程序。
5.2为汇编与执行准备程序
在第4章里，图4-3只表示了程序的源码，它还不是可执行的格式。为了键入这个程序，可以使用任何一种编辑程序或字处理程序，产生标准的、未格式化的ASCII文件。
通过把程序和文件装入到磁盘中，可获得很高的效率。调出编辑程序，键入在图4-3中的程序语句并把结果文件命名为A05ASM1.ASM。
尽管空格对于汇编程序并不重要，但是如果能使名字、操作、操作数和注释始终保持列的对齐，会增强程序的可读性。
许多编辑程序为了有助于列的对齐，tab键每8个位置会停一次。
一旦为该程序键入了全部语句，就应该检查代码的准确性。按现在的情况，该源程序只是一个不能执行的文本文件，必须首先对它进行汇编和连接。
图5-1提供了张汇编、连接与执行程序所要求的步骤图。
1.汇编步骤包括把源码翻译成目标码并产生中间的.OBJ（目标）文件或模块（在前面的章节里，已经见过机器码和源码的例子）。
汇编程序的任务之一就是为数据段中的每个数据项和代码段中的每条指令计算偏移值。汇编程序还要在所产生的.OBJ模块的前面直接建立一个首部（header），
首部的部分包含不确定的地址信息。.OBJ模块不是真正的可执行格式。
2.连接步骤是把.OBJ模块转换成.EXE（可执行的）机器码模块。连接程序的任务包括确定由汇编程序遗留下来的不能确定的地址，
并把分别汇编的程序组合成一个可执行的模块。
3.最后一步是装入准备执行的程序。装入程序知道程序将要装入到存储器的哪个地方，所以它能解决首部仍无法确定的任何余下地址。
装入程序略去首部并在程序装入存储器之前直接建立程序段前缀（PSP）。
5.2.1汇编源程序
汇编程序把源语句转换成机器码，并且在屏幕上显示出错信息。典型的错误包括违反命名规则的名字，拼写不正确的操作（比如用 MOVE 代替MOV），
以及操作数含有未定义的名字。由于有许多可能的错误（100个或更多）和许多不同的汇编程序版本，所以具体情况可以香阅汇编程序手册。
汇编程序试图校正某些错误，但在任何情况下，只要重新装入编辑程序，校正.ASM源程序并重新汇编它就可以了。
汇编的步骤中可选的输出文件是目标（.OBJ），列表（.LST），以及交叉引用（.CRF或.SBR）。
通常需要.OBJ文件，这个文件是连接程序形成可执行格式所要求的。往往还需要.LST文件，尤其是当它包含出错诊断信息或是你想检查一下所生成的机器码的时候。
对于大型程序，.CRF文件可能是有用的，在这里，你可以看到哪些指令引用了哪些数据项。
除此之外，.CRF文件使汇编程序产生.LST文件中项的语句编号，而它是.CRF文件所引用的。后面几节会详细说明这些文件。
有关汇编与连接方面的详细内容可以参阅附录E。
5.2.2使用常规的段定义
图5-2提供了汇编程序所产生的列表，名为A05ASM1.LST。行的宽度是PAGE的项目所指定的132个位置。
注意，在列表的顶部汇编程序是如何按PAGE和TITLE伪操作的规定工作的。包括SEGMENT，PROC，ASSUME和END在内没有一个伪操作生成机器码，
因为它们仅仅是向汇编程序提供信息。列表是按以下几部分水平排列的：
1.最左端列出每行的行号。
2.第二部分表示数据项和指令的十六进制偏移地址。
3.第三部分表示所产生的十六进制格式的机器码。
4.靠右边部分是原始的源代码。
程序本身由垂直的3段组成，每段都带着它自己的数据或指令的偏移值。
每段包含一个SEGMENT伪操作，它通知汇编程序把段对准在某个地址上，该地址是能被hex10整除的。
SEGMENT语句本身不产生机器码。装入程序把每段的内容装入存储器并把段地址初始化在段寄存器中，即STACK在SS中，DATASEG在DS中，而CODESEG则在CS中。
段的起点是从该地址起偏移值为零个字节的地方。
1.堆栈段
堆栈段包含DW（定义字）伪操作，该操作定义32个字，每个字产生一个零值，用（0）标明。
这32个字的定义是堆栈的实际大小，一个大型程序可能需要许多输入/输出中断，并且要调用很多子程序，这些都会使用堆栈。
堆栈段在偏移值0040H处结束，0040日等于十进制值64（32字×2字节）。汇编程序指出所产生的常数为左边的0020[0000]，即20H（32）个零字。
如果堆栈对于它包含的所有进栈的项来说太小，那么不论是汇编程序还是连接程序都不会发出警告，而执行的程序可能会在不可预见的情况下失败。
page 60,132
TITLE A05ASM1 (EXE) Move and add operations
;------------------------------------------------------
STACK SECMENT PARA STACK 'Stack'
DW 32 DUP (0)
STACK ENDS
;------------------------------------------------------
DATASEG SEGMENT PARA 'Data'
FLDD DW 215
FLDE DW 125
FLDF DW ?
DATASEG ENDS
;------------------------------------------------------
CODESEG SEGMENT PARA 'Code'
MAIN PROC FAR
ASSUME SS:STACK,DS:DATASEG,CS:CODESEG
MOV AX,DATASEG
MOV DS,AX
MOV AX,FLDD
ADD AX,FLDE
MOV FLDF,AX
MOV AX,4C00H
INT 21H
MAIN ENDP
CODESEG ENDS
END MAIN
2.数据段
程序的数据段DATASEG含有3个定义的值，全部是DW（定义字）格式：
（1）FLDD定义一个用十进制值215初始化的字，汇编程序把215翻译成00D7H（表示在左边）。
（2）FLDE定义个用十进制值125初始化的字，汇编程序把125翻详成007DH。
这2个常数实际被存入的值分别是D700和7D00，可以用DEBUG检查。
（3）FLDF是在操作数中用?为DW定义一个未初始化常数的字。该列表表明这个常数是0000。
FLDD、FLDE和FLDF的偏移地址分别是0000、0002和0004，这和它们的字段大小有关。
3.代码段
程序的代码段CODESEG包含程序的可执行代码，它们全部在一个过程（PROC）中。3个语句确立数据段的可寻址性：
ASSUME SS:STACK,DS:DATASEG,CS:CODESEG
MOV AX,DATASEG
MOV DS,AX
ASSUME伪操作将每个段和与它相对应的段寄存器相关联。ASSUME简单地给汇编程序提供信息，它不为此产生机器码。
第一条MOV指令把DATASEG“存入”AX寄存器中。现在指令不能真正地把段存储在寄存器里一汇编程序识别是对段的访问并假定它的地址。注意左边的机器码：
B8----R。4个短划指的是此刻汇编程序不能确定DATASEG的地址。只有当目标程序已被连接并为执行而被装入时，系统才能确定这个地址。
由于装入程序可以把程序定位于存储器的任何地方，所以汇编程序要把该地址留下不去解决它并用R（为了可再定位）来指明这一事实，
装入程序用实际地址来取代未确定的地址。
第二个MOV把AX寄存器的内容传送到DS。由于直接用立即数传送到DS的指令是无效的，所以为了初始化它，就需要两条指令。
注意：尽管许多程序员会当作一种标准操作把ES寄存器初始化，但该程序并不需要ES寄存器。
尽管装入程序在它为执行而装入一个程序时，会自动地初始化SS和CS，但如果需要的话，把DS和ES初始化却是你的责任。
虽然所有这些事情看来似乎过分复杂，可实际上现在你还不必去理解它们。在本书的所有程序中，都使用标准的定义和初始化，你可以为每个程序简单地模仿这种编码。
为此，在磁盘上存放一个汇编程序的框架，对你想创建的每个新程序，可在适当的名字下，把这一框架程序复制到文件中并使用编辑程序去完成附加的指令。
初始化DS寄存器后的第一条指令是MOV AX,FLDD，它开始于偏移单元0005并产生机器码A10000。
在列表中，A1（操作）和0000（操作数）之间的空格只是为了可读性而加的。
下一条指令ADD AX,FLDE，开始于偏移单元0008并产生4个字节的机器码。
指令MOVF FLDF,AX把AX中的和复制到FLDF，FLDF在数据段中的偏移值0004处。在这个例子中，机器指令的长度是2个、3个或4个字节。
程序中的最后一个语句是END，它含有操作数MAIN，该操作数与在偏移值0000处的PROC名字有关。
这是在代码段中的一个单元，装入程序在程序开始执行时，要传送控制给这一单元。
下面的程序列表是段与组表，以及符号表。
4.段与组表
这个表表示了所定义的段和组。注意，段没有按它们编码时同样的序列列出。
在这个例子中，汇编程序把它们按照名字的字母表顺序列出（这个程序中不包含组，以后会讨论该内容）。
该表提供了每个段的字节长度，定位（全部是小段），组合类型，以及类别。
5.符号表
这个表提供在数据段中数据字段的名字(FLDD，FLDE和FLDF)和在代码段中指令所用的标号。
对于MAIN（在例子中是唯一的入口）而言，类型F PROC指的是远过程（远是因为MAIN作为执行的入口点，必须保证在程序之外仍然是已知的）。
值的列给出名字、标号与过程的偏移值（从段的起点）。标题为“Attr”（属性）的列提供段，每个项都是在该段内定义的。
MASM6.n还列出了过程，参数，以及组表。附录E对这些表作了更详细的说明。
5.2.3使用简化段伪操作
在第4章里，图4-4说明了如何使用简化段伪操作编写程序。现在图5-3提供的是那个程序的汇编列表。对于简化段伪操作而言，初始化DS如下：
MOV AX,@data
MOV DS,AX
“Segments and Groups”下面的符号表的第一部分表示被汇编程序重新命名的3个段，并按字母表顺序列表如下：
_DATA，6字节长。
STACK，40H（64）字节长。
_TEXT，作为代码段，14H（20）字节长。
page 60,132
TITLE A05ASM2（EXE）Move and add operations
.MODEL SMALL
.STACK 64
.DATA
FLDD DW 215
FLDE DW 125
FLDF DW ?
.CODE
MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV AX,FLDD
ADD AX,FLDE
MOV FLDF,AX
MOV AX,4C00H
INT 21H
MAIN ENDP
END MAIN
标题“Symbols”下所列出的是在程序中定义的名字或默认名。简化段伪操作提供许多预定义的等同关系，由@符号开始并可以在程序中自由引用。
如同@data一样，它们是：
@CODE等效于代码段的名字_TEXT
@FILENAME 程序名
可以在ASSUME和可执行语句中使用@code和@data，如MOV AX,@data。
5.3二遍扫视汇编程序
为了解决在程序中对还未遇到的地址的向前引用问题，典型的汇编程序要2遍或多遍从头到尾地扫视源程序。
在第一遍扫视期间，汇编程序要读完整的源程序并构造程序所用的名字和标号的符号表。其中FLDD、FLDE和FLDF的偏移值分别是0000、0002和0004字节。
虽然程序没有定义指令标号，但它们还是会按本身的偏移值出现在代码段中。第一遍扫视确定每条指令所产生的代码数。
在第二遍扫视期间，汇编程序使用第一遍扫视所构造的符号表。因为它已经知道了每个数据字段和指令的长度与相对位置，就能够完成每条指令的目标码。
然后就可以根据需要产生各不相同的目标（.OBJ），列表（.LST），以及交叉引用（CRF）文件。
在第一遍扫视中，可能存在的问题是向前引用（forward reference）：在代码段中某些类型的指令可以引用指令的标号，但汇编程序还没有遇到过它的定义。
MASM是根据假设所产生的每条机器指令的长度是多少来产生目标码的。如果第一遍与第二遍扫视关于指令长度有差别，则MASM会发出出错信息“两遍扫视间相位错误”。
这种错误相对很少，但它一旦出现，就必须跟踪它的成因并加以校正。
从6.0版本开始，MASM可以更有效地处理指令长度，按照需要可进行许多遍对整个文件的扫视。
TASM用一遍扫视去汇编程序，但假如对于向前引用有困难，可以请求它进行二遍以上的扫视。
5.4连接目标程席
当程序没有出错信息时，下一步就是去连接目标模块A05ASM1.OBJ，它由汇编程序产生并只包含机器码（MASM6.1用ML命令完成汇编与连接）。
连接程序实现以下功能：
如果需要可以把一个以上分别汇编的模块组合成一个可执行的程序，比如把2个或多个汇编程序组合在一起，或者把一个汇编程序与一个C程序组合起来。
产生.EXE模块并用专门的指令把它初始化，以便它为了执行而接着被装入。
一且把一个或多个.OBJ模块连接到.EXE模块中，就可以任意次地执行.EXE模块。但每当需要修改程序时，必须校正源程序，再次把它汇编成一个.OBJ模块，
然后再把该OBJ模块连接成.EXE模块。即使最初这些步骤并不完会清楚，但你会发现那只不过是个小小的体验而已，而这些步骤将变成是自动进行的。
连接步骤输出的文件是可执行文件（EXE），映像文件（MAP）和库文件（LIB）。参阅附录E有关连接程序的细节。
1.第一个程序的连接映像
对于程序A05ASM1，连接程序产生以下的映像：
START                  STOP                  LENGTH                  NAME                  CLASS
00000H               0003FH               0040H                     STACK                  STACK
00040H               00045H               0006H                     DATASEG             DATA
00050H               00063H               0014H                     CODESEG             CODE
program entry point at 0005：0000
堆栈是第一段并且从程序起点偏移值为0处开始。由于定义为32个字，即64个字节长，所以指明了它的长度（40H）。
数据段起始于下一个可用小段边界，偏移值40H。
代码段起始于再下一个小段边界，偏移值为50H（某些汇编程序把段重新按字母顺序排列）。
程序入口点0005：0000，用的是段：偏移值形式，指的是第一条可执行指令的相对地址。实际上，相对起始地址是段位置5[0]，偏移值0字节，
这是与在50H的代码段边界相对应的。当装入程序为了执行该程序而把它装入存储器时，要使用这个值。
在这一阶段，你很可能碰到的唯一错误是输入了一个不正确的文件名。解决办法是用连接命令重新开始再做。
2.第二个程序的连接映像
使用简化段伪操作的第二个程序A05ASM2的连接映像表明它和上一程序稍有区别的安排。
首先，汇编程序按字母顺序重新排列各段；第二：，相继的段是和字（不是小段）边界对齐的，如以下连接映像所表示的：
START                  STOP                  LENGTH                  NAME                  CLASS
00000H               00013H              0014H                      _TEXT                   CODE
00014H               00019H              0006H                      _DATA                  DATA
00020H               0005FH              0040H                      STACK                  STACK
program entry point at 0000：0000
代码段现在是第一段并起始于距程序起点偏移值为0字节处。
数据段起始于下一个字边界，偏移值为14H。
堆栈起始于再下一个字边界，偏移值为20H。
程序入口点现在是0000：0000，它指的是代码段的相对位置起始于段地址为0，偏移值也为0处。
5.5执行程序
已经汇编和连接了程序，现在就可以执行它。如果.EXE文件是在默认的驱动器里，可以要求装入程序把这个要执行的文件读到存储器中。为此键入：
A05ASM1.EXE或A05ASM1（没有.EXE扩展名）如果没有键入文件扩展名，则装入程序会假定它是可执行的.EXE或.COM程序。
但是，由于这个程序的输出不可见，建议在DEBUG下面运行它并使用跟踪（T）命令一步步地跟踪它的执行过程。键入如下：
DEBUG n:A05ASM1.EXE
DEBUG装入.EXE程序模块并显示它的短划提示符。
为了观察堆栈段，键入D SS:0。堆栈的内容是全零，因为它就是那样初始化的。为了观察代码段，键入D CS:0。把显示的机器码和在汇编列表中的代码段加以比较：
B8----8ED8A10000...
汇编的列表不能准确地表示出机器码，因为汇编程序不知道第一条指令的操作数地址。
现在，可以用查看所显示的代码的办法来确定该地址。
为了观察寄存器的内容，按R键跟着按回车键。SP（堆栈指针）的内容应当是0040H，这是堆栈的大小（32个字=64个字节=40H）。IP（指令指针）应当是0000H。
SS和CS为执行而适当地进行了初始化，它们的值取决于程序在存储器中的位置。
准备执行的第一条指令MOV AX,xxxx和后继的MOV指令是有关初始化DS寄存器的。为了执行第一条MOV指令，按T键（为了跟踪）跟着按回车键并注意对IP的影响。
为了执行第二条MOV指令，要再一次按T键跟着按回车键。检查DS，它现在是用段地址初始化的。
第三条MOV指令把FLDD的内容装入AX。再次按T键并注意现在AX的内容是00D7。现在按T键去执行ADD指令并注意AX是0154。
按T键使MOV把AX存放到数据段的偏移值0004处。
为了检查数据段的内容，键入D DS:0。操作显示3个数据项是D700 7D00 5401，每个字的字节都是按相反的顺序排列的。
可以使用L去重新装入并重新运行程序或按Q键退出DEBUG对话。
5.6交叉引用表
汇编程序生成一个可选文件，可以用它产生程序标识符或符号的交叉引用表。
文件的扩展名是.SBR（对于MASM6.1），.CRF（对于MASM5.1），以及.XRF（对于TASM）。
然而，仍然必须把该文件转换成一个适当排序的交叉引用文件。有关建立这一文件的细节可参阅附录E。
图5-4表示的是图5-2的程序所产生的交叉引用表。第一列的符号是按字母顺序排列的。第二列的编号表示成n#，指明.LST文件中的行，这是每个符号定义所在的行。
这一列右边的编号是行号，指明了该符号是在哪一行上被其他语句引用的。例如，CODESEG是在第17行被定义的，是在第19行和第29行被引用的。
FLDF是在第14行被定义的，在第25+行被引用，其中“+”是指在程序执行期间（用MOV FLDF,AX）修改过它的值。
程序被汇编时产生许多冗余的文件，可以安全地删除.OBJ，.CRF和.LST文件。保留.ASM源程序以免需要进一步的改变，还要保留.EXE文件以便程序的执行。
5.7出错诊断
汇编程序对违反其规则的任何程序错误提供出错诊断。图5-5中的程序和图5-2中的程序是类似的，区别在于出于说明性的目的有意插入了几个错误。
由于汇编程序版本不同，诊断会有所区别。这里的错误是：
行         说明
9         FLDF的定义需要操作数。
14       DX应当是DS，尽管汇编程序不认为这是错误。
16       AS应当是AX。
18       FLDQ应当是FLDF。
19       字段的大小（字节和字）必须一致（警告）。
22       校正其他错误将使这一诊断消失。
23       MIAN应当是MAIN。
出错信息22“二遍扫视间相位错”在二遍扫视汇编程序的第一遍扫视时产生的地址与第二遍扫视产生的不同时才会发生。
在MASM5.1下面，为了查出含糊不清的错误要使用/D选项列出第一遍与第二遍的文件，并且比较偏移地址。
5.8汇编程序位置计数器
汇编程序维护一个位置计数器，它用来在数据段中为每个被定义的数据项作计数统计。
图5-2和图5-3借助于3个定义的数据项说明它的作用：
0000…FLDD DW…
0002…FLDE DW……
0004…FLDF DW…
最初，位置计数器设置为0，汇编程序在这里建立第一个数据项FLDD。因为FLDD定义成字，所以汇编程序要使位置计数器加2成为0002，并在这里建立FLDE。
因为FLDE也是定义成字的，所以汇编程序再一次把它的位置计数器加2成为0004。下一个数据项 FLDF，还是一个字，位置计数器再一次加2成为0006，
但不存在更多的数据项了。
汇编程序提供许多方法去改变位置计数器的当前值。例如，可以使用EQU用不同名字再定义数据项（见第4章），
使用ORG伪操作在特殊的偏移值处开始一个程序（见下一节），以及使用EVEN或ALIGN伪操作去使地址对准到偶数边界上（见第6章）。
5.9编写.COM程序
对于.EXE程序，连接程序会自动生成特定的格式，当将其存储到磁盘上时，将512字节或更长的专门的标题块加到它前面（第23章提供标题块的细节）。
也可以编写可执行的.COM程序。.COM程序的优点是它们比差不多的.EXE程序小，并且更适合于作为常驻程序。
.COM格式在早期的微计算机中是有其根源的，那时程序规模仅限于64K，因而比较原始并且受到限制。
5.9.1.EXE程序与.COM程序的区别
作为.EXE执行的程序与作为.COM执行的程序之间的重要区别包括程序的规模，分段，以及初始化。
1.程序规模
.COM程序的指令和数据都使用同一个段，基本上被限制为最大值64K，其中包括程序段前缀（PSP）。PSP是一个256字节（100H）块，
由装入程序直接插在.COM和.EXE程序的前面，这是在装入程序把它们从磁盘装入到存储器的时候进行的。
.COM程序总是比与它相对应的.EXE程序要小，原因之一是磁盘上放在.EXE程序前面的512字节的标题记录是不放在.COM程序前面的
（不能混淆标题记录，在第23章PSP部分会涉及这个问题）。.COM程序是可执行程序的绝对映像，它不具有浮动地址信息。
2.段
.COM程序段的使用是它和.EXE程序的重要的（而且是比较容易的）区别。完整的.COM程序把PSP，堆栈，数据段和代码段组合在一个代码段中。
对于.EXE程序，通常要定义数据段并且用该段的地址初始化DS。对于.COM程序，在代码段内定义数据，就像在第3章里使用DEBUG时所做的那样。
尽管必须为.EXE程序定义堆栈段，但汇编程序会自动地为.COM程序生成堆栈。因此，编写要被转换成.COM格式的程序时，定义堆栈是可以省略的。
如果对一个程序而言，64K的段是足够大的，那么装入程序会在段的末尾设置堆栈并用栈顶地址设置SP寄存器。
如果64K的段不是足够大，则汇编程序会在程序之后较高端的存储器中建立堆栈。（然而，这么大的程序应该编写成.EXE格式。）
在本书中，许多较小的程序都是.COM格式，它们很容易和.EXE格式区别开来。图5-6比较了.EXE和.COM格式的段寻址。
3.初始化
当装入程序把要执行的.COM程序装入时，它自动地用PSP的地址初始化CS、DS、SS和ES。
由于CS和DS现在的内容是指令执行时的正确的初始段地址，所以.COM程序不必把它们初始化。
因为PSP的大小是100H个字节，寻址是从100H字节的偏移值处开始的，所以必须编写伪操作ORG 100H，紧跟在代码段的SEGMENT或.CODE语句之后。
ORG伪操作告诉汇编程序把位置计数器设置在100H。然后，汇编程序在距PSP的起点100H字节的偏移值处产生目标码，在那里开始.COM程序的编码。
5.9.2编写.COM格式的程序
如果源程序是按.EXE格式编写的，那么可以使用编辑程序把指令转换成.COM格式。
图5-7的程序是类似于图5-2的程序，但现在修改成符合.COM的要求了。注意以下特点：
没有定义堆栈或数据段。
ASSUME 语句告诉汇编程序当程序为执行而装入时，CS、SS、DS和ES将包含代码段的起始地址（这里是PSP的起点）。
伪操作ORG 100H告诉汇编程序使位置计数器从PSP起点前进100H字节。
当装入程序装入.COM程序时，把100H存放到IP（指令指针）寄存器。由于这一特点，跟在ORG后面的第一个语句必须是可执行的指令。
JMP指令把执行的控制权绕过所定义的数据往下传送。有些程序员把数据项放在指令的后面，这样就不需要开始的JMP指令了。
一开始就编写数据项，可以略微加速汇编的处理，除此之外没有其他优点。在本书所举的例子中，先定义数据仅仅是一种程序设计习惯而己。
BEGIN和MAIN仅仅是描述性的标号，对于汇编程序没有其他意义。对于这些标号，你可以使用任何有效的名字。
标准的INT 21H的4CH功能结束处理过程。
TITLE A05COM1 COM program to move and add
CODESEG SEGMENT PARA 'Code'
ASSUME CS:CODESEG,DS:CODESEG,SS:CODESEG,ES:CODESEG
ORG 100H
BEGIN:JMP MAIN
FLDD DW 215
FLDE DW 125
FLDF DW ?
MAIN PROC NEAR
MOV AX,FLDD
ADD AX,FLDE
MOV FLDF,AX
MOV AX,4C00H
INT 21H
MAIN ENDP
CODESEG ENDS
END BEGIN
测试通过的完整程序如下
CSEG SEGMENT PARA 'Code'
ASSUME CS:CSEG,DS:CSEG,SS:CSEG,ES:CSEG
ORG 100H
BEGIN:JMP MAIN
FLDD DW 215
FLDE DW 125
FLDF DW ?
MAIN PROC NEAR
MOV AX,FLDD
ADD AX,FLDE
MOV FLDF,AX
MOV AX,4C00H
INT 21H
MAIN ENDP
CSEG ENDS
END BEGIN
图5-7具有常规段的.COM源程序
5.9.3把.EXE格式转换成.COM格式
由于汇编程序版本不同，产生.COM文件的方法也不一样：
Microsoft MASM6.1的ML命令汇编、连接并转换成.COM程序，如果该程序指定的是Tiny存储模型，用这一个命令就可以了。
Microsoft MASM5.1产生.OBJ文件，然后把它加以连接而生成.EXE文件。为了把.EXE文件转换成.COM文件，使用名为EXE2BIN的程序。
程序名的意思是“把EXE转换为BIN”，其中BIN指的是二进制文件，但指定输出文件扩展名是.COM。
TASM允许用TLINK程序来建立.COM文件。
有关转换成.COM格式的细节可参阅附录E。
在XP下使用tasm32 t476.asm编译，tlink /t t476.obj生成t476.COM
在XP下调试TD t476.COM
当完成.COM格式的转换后，可以删除已产生的.OBJ和.EXE文件。.EXE和.COM程序的大小分别是792个字节和24个字节。
差别是很大的，这是由存放在.EXE模块开始处的512字节的标题块造成的，图5-8表示的是使用简化段伪操作去编写.COM程序。
重复一次，只定义了代码段而没有定义堆栈或数据段。对于MASM6.1，这种程序应该使用Tiny存储模型。
调试忠告。忽略了.COM的任何一个要求，都可能导致程序的失败。例如，如果EXE2BIN发现错误，它只是简单地通知你该文件不能转换，而不提供任何理由。
检查 SEGMENT，ASSUME，以及END语句。如果遗漏了ORG 100H，正在执行的程序会错误地访问PSP中的数据，造成无法预料的后果。
如果在DEBUG下运行.COM程序，用D CS:100查看数据和指令。试图执行.COM程序中的.EXE模块，是会失败的，一定要删除这个文件。
TITLE A05COM2 COM program to move and add data
.MODEL TINY
.CODE
ORG 100H
BEGIN:JMP MAIN
FLDD DW 215
FLDE DW 125
FLDF DW ?
MAIN PROC NEAR
MOV AX,FLDD
ADD AX,FLDE
MOV FLDF,AX
MOV AX,4C00H
INT 21H
MAIN ENDP
END BEGIN
测试通过的完整程序如下
.MODEL TINY
.CODE
ORG 100H
BEGIN:JMP MAIN
FLDD DW 215
FLDE DW 125
FLDF DW ?
MAIN PROC NEAR
MOV AX,FLDD
ADD AX,FLDE
MOV FLDF,AX
MOV AX,4C00H
INT 21H
MAIN ENDP
END BEGIN
图5-8使用简化段伪操作的.COM程序
在XP下使用tasm32 t477.asm编译，tlink /t t477.obj生成t477.COM
在XP下调试TD t477.COM
5.10要点
汇编程序把源程序转换成OBJ文件并生成可选的列表文件和交叉引用文件。
跟在汇编程序列表之后的段与组表，显示在程序中所定义的任何段与组。符号表显示出所有的符号（数据名和指令标号）。
连接程序把.OBJ文件转换成可执行的.EXE文件。
简化段伪操作为数据段产生名字_DATA，为堆栈段产生STACK，为代码段产生_TEXT，并产生许多预定义的等式。
交叉引用表对于定位所有对数据项引用是有用的。
.COM程序被限制为一个64K的段，并比与它相对应的.EXE程序要小。这种程序不需要定义堆栈或数据段，也不需要初始化DS寄存器。
编写成.COM的程序要求在代码段的SEGMENT语句之后，紧跟着ORG 100H。该语句把开始执行的偏移地址设置在PSP之后。
系统把.COM程序的堆栈建立在程序的末尾。
5.11习题
5-1.编写命令行去汇编命名为MONITOR.ASM的源程序，要有列表、目标和交叉引用各文件。
tasm32 /c /l MONITOR.ASM
ml /c /Fl /Fr MONITOR.ASM
5-2.编写命令行去连接MONITOR.OBJ（习题5-1中产生的），采用单独的连接命令。
tlink MONITOR.OBJ
link MONITOR.OBJ
5-.3.为5-2题中生成的MONITOR.EXE编写如下要求的命令：（a）直接从DOS执行，（b）通过DEBUG执行。
MONITOR.EXE
DEBUG MONITOR.EXE
5-4.说明以下每一种文件的用途：（a）.ASM文件，（b）.LST文件，（c）.MAP文件，（d）.CRF文件，（e）.OBJ文件，（）.EXE文件。
.ASM文件是汇编语言的源程序文件，汇编程序把源程序文件中的源码翻译成目标码并产生中间的.OBJ文件（目标码文件），
连接程序把.OBJ目标码模块转换成.EXE机器码模块（可执行程序文件）。
汇编的步骤中可选的输出文件是目标（.OBJ），列表（.LST），以及交叉引用（.CRF或.SBR）。
通常需要.OBJ文件，这个文件是连接程序形成可执行格式所要求的。往往还需要.LST文件，尤其是当它包含出错诊断信息或是你想检查一下所生成的机器码的时候。
对于大型程序，.CRF文件可能是有用的，在这里，你可以看到哪些指令引用了哪些数据项。
连接步骤输出的文件是可执行文件（EXE），映像文件（MAP）和库文件（LIB）。
.MAP文件列出了生成的可执行程序文件中代码段、数据段、堆栈段、程序入口等相关信息
5-5.采用常规段定义并且用DATASEG作为数据段的名字，编写2条MOV指令初始化DS寄存器。
MOV AX,DATASEG
MOV DS,AX
5-6.用常规段定义编写一个汇编程序，要求如下：
（a）把立即值hex 40传送到AL寄存器，
（b）将AL的内容左移一位（SHL AL,1），
（c）把立即值hex 1A传送到BL，
（d）AL乘以BL（MUL BL）。
不要遗忘结束程序执行的指令。程序不需要定义或初始化数据段。复制框架程序并用编辑程序去开发该程序。汇编，连接并使用DEBUG跟踪和检查代码段与寄存器。
CSEG SEGMENT
ASSUME CS:CSEG
MAIN PROC FAR
MOV AL,40H
SHL AL,1
MOV BL,1AH
MUL BL
MOV AX,4C00H
INT 21H
MAIN ENDP
CSEG ENDS
END MAIN
40H*2=80H*1AH=0D00H
5-7.把5-6题修改成用简化段伪操作。汇编和连接该程序，并和原始程序比较目标码、符号表和连接映像。使用DEBUG跟踪并检查代码段和寄存器。
.MODEL SMALL
.CODE
MAIN PROC FAR
MOV AL,40H
SHL AL,1
MOV BL,1AH
MUL BL
MOV AX,4C00H
INT 21H
MAIN ENDP
END MAIN
5-8.按以下要求把数据段加到5-6题的程序中：
定义名为ITEMA的1字节项（DB），内容为hex40；定义另一个名为ITEMB的1字节项（DB），内容为hex1A。
定义2字节的项（DW），名为ITEMC，不带常数。
把ITEMA的内容传送到AL并左移一位。AL乘以ITEMB（MUL ITEMB）。
把AX中的乘积传送到ITEMC。
汇编，连接，并使用DEBUG检查该程序。
DSEG SEGMENT
ITEMA DB 40H
ITEMB DB 1AH
ITEMC DW ?
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
MAIN PROC FAR
MOV AX,DSEG
MOV DS,AX
MOV AL,ITEMA
SHL AL,1
MUL BYTE PTR ITEMB
MOV ITEMC,AX
MOV AX,4C00H
INT 21H
MAIN ENDP
CSEG ENDS
END MAIN
5.9.用简化段伪操作修改5-8题的程序。汇编、连接该程序，并和原始程序比较目标码、符号表和连接映像。使用DEBUG检查该程序。
.MODEL SMALL
.DATA
ITEMA DB 40H
ITEMB DB 1AH
ITEMC DW ?
.CODE
MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV AL,ITEMA
SHL AL,1
MUL BYTE PTR ITEMB
MOV ITEMC,AX
MOV AX,4C00H
INT 21H
MAIN ENDP
END MAIN
5-10.对于以下每个数据项，指出汇编程序的位置计数器的内容：
0，2，4，6，8
0000   WORD1 DW 0
----   WORD2 DW 0
----   BYTE1 DB 0
EVEN
----   WORD3 DW 0
----   BYTE2 DB 0
5-11..COM程序的最大规模是多少？
.COM程序被限制为一个64K的段，程序规模仅限于64K。
5-12.为了把源程序转换为.COM格式，你可以定义哪些段？
.COM程序把PSP，堆栈，数据段和代码段组合在一个代码段中，只能定义一个代码段。
5-13.解释为什么要在被转换的.COM格式程序的起点编写ORG 100H。
当装入程序把要执行的.COM程序装入时，它自动地用PSP的地址初始化CS、DS、SS和ES。
因为PSP的大小是100H个字节，寻址是从100H字节的偏移值处开始的，所以必须编写伪操作ORG 100H，紧跟在代码段的SEGMENT或.CODE语句之后。
ORG伪操作告诉汇编程序把位置计数器设置在100H。然后，汇编程序在距PSP的起点100H字节的偏移值处产生目标码，在那里开始.COM程序的编码。
5-14.为什么为.COM程序定义堆栈是没有必要的？
汇编程序会自动地为.COM程序生成堆栈。因此，编写要被转换成.COM格式的程序时，定义堆栈是可以省略的。
装入程序会在段的末尾设置堆栈并用栈顶地址设置SP寄存器。
5-15.把5-8题（常规段）中的程序修改成.COM格式。汇编、连接，把它转换成.COM，并在DEBUG执行它。
CSEG SEGMENT PARA 'Code'
ASSUME CS:CSEG,DS:CSEG,SS:CSEG,ES:CSEG
ORG 100H
BEGIN:JMP MAIN
ITEMA DB 40H
ITEMB DB 1AH
ITEMC DW ?
MAIN PROC NEAR
MOV AL,ITEMA
SHL AL,1
MUL BYTE PTR ITEMB
MOV ITEMC,AX
MOV AX,4C00H
INT 21H
MAIN ENDP
CSEG ENDS
END BEGIN
5-16.把5-9题（简化段）中的程序修改成.COM格式。汇编、连接，把它转换成.COM，并在DEBUG下执行它（对于MASM6.x，使用Tiny 存储模型）。
.MODEL TINY
.CODE
ORG 100H
BEGIN:JMP MAIN
ITEMA DB 40H
ITEMB DB 1AH
ITEMC DW ?
MAIN PROC NEAR
MOV AL,ITEMA
SHL AL,1
MUL BYTE PTR ITEMB
MOV ITEMC,AX
MOV AX,4C00H
INT 21H
MAIN ENDP
END BEGIN
5-17.下面的程序中含有许多汇编期间的错误，如右边所示。请改正每个错误。
TITLE A04ASM2（EXE）program errors
.MODEL SMALL
.STACK 64
.DATA
DATA1 DB 25
DATA2 DB 280   ;1：值超出范圈
DATA3 DW ?
.CODE
MAIN PROC
MOV AX,data   ;2：操作数类型不适当
MOV DS,AX
MOV AX,DATA1   ;3：操作数类型必须匹配
ADD AX,DATA2   ;4：操作数类型必须匹配
MOV DATA3,AX
MOV FX,4C00H   ;5：符号没有定义
INT 21H
MAIN ENDP
END MAIN
汇编程序没有定位的有关MAIN PROC语句的另一个错误，是什么？
.MODEL SMALL
.STACK 64
.DATA
DATA1 DW 25
DATA2 DW 280
DATA3 DW ?
.CODE
MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV AX,DATA1
ADD AX,DATA2
MOV DATA3,AX
MOV AX,4C00H
INT 21H
MAIN ENDP
END MAIN
第6章符号指令与寻址
6.1引言
6.2符号指令系统―概述
6.3数据传送指令
6.4基本算术指令
6.5重复传送操作
6.6 INT指令
6.7寻址方式
6.8段跨越前缀
6.9近地址与远地址
6.10对齐数据地址
6.11要点
6.12习题
目的：提供汇编语言指令系统和对于寻址数据要求的基础
6.1引言
本章介绍处理器指令系统的类别。正式包括在本章的指令是MOV、MOVSX、MOVZX、XCHG、LEA、INC、DEC、ADD、SUB和INT，
还有作为立即值使用的指令操作数中的常数。
最后，本章讨论贯穿本书其余部分所使用的基本寻址格式，然后说明地址对准和段跨越前缀。
6.2符号指令系统―概述
以下是Intel处理器系列所用的符号指令表，它是按类别排列的。虽然这个表似乎很难对付，但其中许多指令是很少用到的。
1.算术运算
ADC：带进位加法                           INC：加1
ADD：二进制数加法                       MUL：无符号数乘法
DEC：减1                                       NEG：求补
DIV：无符号数除法                        SBB：带借位减法
IDIV：带符号数（整数）除法         SUB：二进制减法
IMUL：带符号数（整数）乘法       XADD：交换并相加
2.ASCII-BCD转换
AAA：加后ASCII调整                    AAS：减后ASCII调整
AAD：除前ASCII调整                    DAA：加后十进制调整
AAM：乘后ASCII调整                   DAS：减后十进制调整
3.移位
RCL：带进位循环左移                    SAR：算术右移
RCR：带进位循环右移                   SHL：逻辑左移
ROL：循环左移                             SHR：逻辑右移
ROR：循环右移                            SHLD：双精度左移（80386+）
SAL：算术左移                             SHRD：双精度右移（80386+）
4.比较
BSF/BSR：位扫描（80386+）     CMPXCHG：比较并交换（80486+）
BT/BTC/BTR/BTS：位测试（80386+）CMPXCHG8B：比较并交换（pentium+）
CMP：比较                                  TEST：测试位
CMPSn：串比较
5.数据传送
LDS：装入数据段寄存器               MOVS：串传送
LEA：装入有效地址                      MOVSX：带符号扩展传送
LES：装入附加段寄存器                MOVZX：带零扩展传送
LODS：从串取                             STOS：存入串
LSS：装入堆栈段寄存器               XCHG：交换
MOV：传送数据                          XLAT：换码
6.标志操作
CLC：清除进位标志                     PUSHF：标志进栈
CLD：清除方向标志                     SAHF：AH送标志寄存器
CLI：清除中断标志                      STC：进位标志置1
CMC：进位标志求反                   STD：方向标志置1
LAHF：标志送AH                       STI：中断标志置1
POPF：标志出栈
7.输入/输出
IN：输入字节或字                     OUT：输出字节或字
INSn：串输入（80286+）        OUTSn：串输出（80286+）
8.逻辑操作
AND：逻辑与                           OR：逻辑或
NOT：逻辑非                           XOR：异或
9.循环
LOOP：循环直到完成               LOOPNZ：不为零时循环
LOOPE：相等时循环                 LOOPNEW：不相等时循环（80386+）
LOOPZ：为零时循环                 LOOPNZW：不为零时循环（80386+）
LOOPNE：不相等时循环
10.处理器控制
HLT：进入暂停状态                  NOP：无操作
LOCK：封锁总线                      WAIT：置处理器于等待状态
11.堆栈操作
ENTER：建立堆栈帧（80286+）         POPA：所有通用寄存器出钱（80286+）
LEAVE：结束堆栈帧（80286+）         PUSH：字进栈
POP：字出栈                                      PUSHA：所有通用寄存器进（80286+）
POPF：标志出栈                                 PUSHF：标志进栈
12.串操作
CMPS：串比较                           REPZ：为零时重复
LODS：从串取                           REPNE：不相等时重复
MOVS：串传送                          REPNZ：不为零时重复
REP：串重复                              SCAS：串扫描
REPE：相等时重复                     STOS：存入串
13.转移（条件）
INTO：溢出中断                       JNC：若进位为零则转移
JA：若高于则转移                     JNE：若不相等则转移
JAE：若高于或等于则转移         JNG：若不大于则转移
JB：若低于则转移                     JNGE：若不大于或等于则转移
JBE：若低于或等于则转移         JNL：若不小于则转移
JC：若进位为1则转移               JNLE：若不小于或等于则转移
JCXZ：若CX为零则转移            JNO：若不溢出则转移
JE：若相等则转移                     JNP：若奇偶位为0则转移
JG：若大于则转移                    JNS：若结果为正则转移
JGE：若大于或等于则转移        JNZ：若结果不为零则转移
JL：若小于则转移                     JO：若溢出则转移
JLE：若小于或等于则转移         JP：若奇偶位为1则转移
JNA：若不高于则转移              JPE：若奇偶性为偶则转移
JNAE：若不高于或等于则转移  JPO：若奇偶性为奇则转移
JNB：若不低于则转移              JS：若结果为负则转移
JNBE：若不低于或等丁则转移  JZ：若结果为零则转移
14.转移（无条件）
CALL：调用过程                      JMP：无条件转移
INT：中断                               RET：返回
IRET：中断返回                       RETN/RETF：近返回/远返回
15.类型转换
CBW：字节转换为字
CDQ：双字转换为四字（80386+）
CWD：字转换为双字
CWDE：字转换为扩展的双字（80386+）
标明处理器的指令（如80386+）要求使用处理器伪操作（第3章涉及此内容），以便正确地进行汇编。
6.3数据传送指令
这一节讨论与数据传送有关的一些通用指令。
6.3.1MOV指令
MOV指令是把第二个操作数的地址所引用的数据传送（或复制）到第一个操作数的地址中。发送字段是不变的。
引用存储器或寄存器的操作数大小必须一致（必须两个都是字节、字或双字）。MOV的格式是：
[label:] MOV register/memory，register/memory/immediate
（label：标号，register：寄存器，memory：存储器，immediate：立即数）
下面是按类型分的4个合法MOV操作的例子，给定以下数据项：
BYTEFLD DB ?   ;定义字节
WORDFLD DW ?   ;定义字
1.寄存器传送
MOV EDX,ECX   ;寄存器到寄存器
MOV ES,AX   ;寄存器到段寄存器
MOV BYTEFLD,DH   ;寄存器到存储器，直接。
MOV [DI],BX   ;寄存器到存储器，间接。
2.立即数传送
MOV CX,40H
MOV BYTEFLD,25   ;立即数到存储器，直接。
MOV WORDFLD[BX],16H   ;立即数到存储器，间接。
3.直接存储器传送
MOV CH,BYTEFLD   ;存储器到寄存器，直接。
MCV CX,WORDFLD[BX]   ;存储器到寄存器，间接。
4.段寄存器传送
MOV AX,DS   ;段寄存器到寄存器
MOV WORDFLD,DS   ;段寄存器到存储器
可以向寄存器传送字节（MOV CH,BYTEFLD），字（MOV CX,WORDFLD），或双字（MOV ECX,DWORDFLD）。
操作数只影响所引用的那一部分寄存器，例如，向CL传送字节对CH没有影响。无效的MOV操作包括以下一些：
MOV DL,WORD_VAL   ;字到字节
MOV CX,BYTE_VAL   ;字节到字
MOV WORD_VAL,EBX   ;双字到字
MOV BYTE_VAL2,BYTE_VAL1   ;存储器到存储器
MOV ES,225   ;立即数到段寄存器
MOV ES,DS   ;段寄存器到段寄存器
完成这些操作需要一条以上的指令。
6.3.2传送并填充指令：MOVSX与MOVZX
对于MOV指令，目的必须和源的长度相同，比如字节到字节，字到字。
MOVSX和MOVZX（传送并填充）指令（80386+）使传送的数据可以从字节或字的源到字或双字的目的地。
下面是它们的格式：
[label:] MOVSX/MOVZX register/memory,register memory/immediate
MOVSX用于带符号的算术值，把字节或字传送到字或双字的目的地，并把符号位（源的最左边的一位）填入该目的地的最左边的所有位。
MOVZX用于无符号的数字值，把字节或字传送到字或双字的目的地，并在该目的地的最左边所有位填入零。
下面这个例子，考虑把内容为10110000的字节传送到字，目的字的结果取决于所选择的指令：
MOVSX CX,10110000B
CX=1111111110110000
MOVZX CX,10110000B
CX=0000000010110000
下面是使用MOVSX和MOVZX的一些其他例子：
BYTE1 DB 25   ;字节
WORD1 DW 40   ;字
DWORD1 DD 160   ;双字
.386
MOVSX CX,BYTE1   ;字节到字
MOVZX WORD1,BH   ;字节到字
MOVSX EBX,WORD1   ;字到双字
MOVZX DWORD1,CX   ;字到双字
.386处理器伪操作告诉汇编程序接受由80386所引入的指令。第7章和第12章会涉及有关带符号与无符号数据的细节。
6.3.3XCHG指令
XCHG完成另一种类型的数据传送，不是简单地把数据从一个单元复制到另一个单元，XCHG要交换两个数据项。XCHG的格式是：
[label:] XCHG Register/memory,register/memory
有效的XCHG操作是要在两个寄存器之间或是寄存器与存储器之间交换数据。以下是两个例子：
WORDO DW ?
XCHG CL,BH   ;交换两个寄存器的内容
XCHG CX,WORDO   ;交换寄存器和存储器的内客
6.3.4LEA指令
LEA对于用偏移地址去初始化寄存器是有用的。其格式是：
[label:] LEA register,memory
LEA通常的用法是用偏移值来初始化BX、DI或SI，为的是指向存储器中的一个地址，本书从头到尾都是这么做的。下面是一个例子：
DATATBL DB 25 DUP (?)   ;25个字节的表
BYTEFLD DB ?
LEA BX,DATATBL   ;装入偏移地址
MOV BYTEFLD,[BX]   ;传送DATATBL的第一个字节
与LEA等效的操作是带OFFSET操作符的MOV，它产生的机器码稍短一些，像下面这样使用：
MOV BX,OFFSET DATATBL
6.4基本算术指令
这一节讨论有关加法与减法的基本指令：INC，DEC，ADD，以及SUB。
6.4.1INC与DEC指令
INC与DEC是使寄存器和存储器单元的内容加1或减1的指令。INC与DEC的格式是：
[label:] INC/DEC register/memory
注意：INC与DEC只需要一个操作数。根据运算的结果来确定是清除或设置OF（有到符号位的进位，无进位输出），SF（正/负），以及ZF（零/非零）标志。
条件转移指令可以测试这些条件。
如果字节值是FFH，INC把它“加1”到00H并置SF为0（结果为正）及ZF为1（结果为零）。
DEC把00H“减1”为FFH并置SF为1（结果为负）及ZF为0（结果为非零）。
6.4.2ADD与SUB指令
这一节概括地讨论ADD与SUB，第12章会更详细地加以说明。它们的格式是：
[label:] ADD/SUB register/memory，register/memory/immediate
有效的操作包括从寄存器到寄存器，从寄存器到存储器，从存储器到寄存器，从立即数到寄存器，以及从立即数到存储器。下面是一些例子：
ADD AX,CX   ;寄存器与寄存器相加
ADD EBX,DBLWORD   ;存储器双字加到寄存器
SUB BL,10   ;从寄存器中减去立即数
受影响的标志是AF，CF，OF，PF，SF，以及ZF。例如，结果为零时ZF置1，而结果为负时SF置1。
6.5重复传送操作
到此为止，程序己经涉及了把立即数据传送到寄存器，把所定义的存储器中的数据传送到寄存器，把寄存器内容传送到存储器，
以及把一个寄存器的内容传送到另一个寄存器。在所有情况下，数据长度被限定为1个、2个或4个字节，并且没有把来自一个存储区的数据直接传送到另一个存储区的操作。
这一节说明如何一个字节跟着一个字节地传送整个数据项。
另一种使用串指令的方法会在第11章叙述。
图6-1的程序中，数据段包含定义为HEADNG1和HEADNG2的两个9字节字段。程序的目标是把HEADNG1的内容从左到右传送到HEADNG2。
由于这些字段每个都是9个字节长，比简单的MOV指令所要求的要多。该程序有不少新特点。
为了一步步地传送HEADNG1和HEADNG2，该程序把CX初始化为9（这两个字段的长度）并用SI和DI作变址。
两条LEA指令把HEADNG1和HEADNG2的偏移地址装入到SI和DI中，如下所示：
LEA SI,HEADNG1
LEA DI,HEADNG2
程序用SI和DI中的地址，把HEADNG1的第一个字节传送到HEADNG2的第一个字节。
MOV指令操作数中的带方括号的SI和DI指的是间接寻址：指令是用给定寄存器中的偏移地址来访问存储单元的。
因此，MOV AL,[SI]的意思是“使用SI中的偏移地址（HEADNG1+0），把所引用的字节传送到AL”。指令MOV [DI],AL的意思是“把AL的内容传送到由DI所
引用的偏移地址（HEADNG2+0）”。该程序要把这两条指令重复9次，一次有一个字符传送到各自的字段中。
为此目的，程序使用了还没有说明过的条件转移指令JNZ（若非零则转移）。
TITLE A06MOVE（EXB）Repetitive move operations
.MODEL SMALL
.STACK 64
.DATA
HEADNG1 DB 'InterTech'
HEADNG2 DB 9 DUP ('*'),'$'
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
MOV CX,9
LEA SI,HEADNG1
LEA DI,HEADNG2
A20:MOV AL,[SI]
MOV [DI],AL
INC SI
INC DI
DEC CX
JNZ A20
MOV AH,09H
LEA DX,HEADNG2
INT 21H
MOV AX,4C00H
INT 21H
A10MAIN ENDP
END A10MAIN
测试通过的完整程序如下
.MODEL SMALL
.STACK 64
.DATA
HEADNG1 DB 'InterTech'
HEADNG2 DB 9 DUP ('*'),'$'
.CODE
MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
MOV CX,9
LEA SI,HEADNG1
LEA DI,HEADNG2
S1:MOV AL,[SI]
MOV [DI],AL
INC SI
INC DI
DEC CX
JNZ S1
MOV AH,09H
LEA DX,HEADNG2
INT 21H
MOV AX,4C00H
INT 21H
MAIN ENDP
END MAIN
图6-1重复传送操作
两条INC指令使SI和DI加1，DEC指令使CX减1。DEC还要设置或清除零标志，这取决于CX的结果；如果该结果是非零，则仍有更多的字符要传送，
并且JNZ转移返回到标号A20去重复传送指令。由于SI与DI已被加1，所以下一条MOV指令引用HEADNG1+1和HEADNG2+1。
循环以这种方式继续下去直到它把总共9个字符传送完，到达HEADNG2+8为止。
同样，程序需要用指令在处理结束后显示HEADNG2的内容：①在AH中装入09H功能要求显示；②在DX中装入HEADNG2的地址；③执行指令INT 21H。
INT操作显示从HEADNG2第一个字节开始到结束的'$'符号为止的全部字符。'$'是紧跟在HEADNG2定义之后的，这一操作更详细的说明见第8章。
作为练习，键入这一程序，对它进行汇编和连接，并且使用DEBUG跟踪它的运行。注意对于堆栈，各寄存器，以及IP（特别是在JNZ执行之后）的影响。
利用D DS:0查看HEADNG2的变化。
INT 33H: Mouse Support
INT 33H 0000H: Reset/Query Installed State
6.6INT指令
INT指令能中断程序本身的处理过程，例如初始化鼠标驱动程序:
MOV AX,00H
INT 33H
INT退出正常处理过程并访问位于低端存储器的中断向量表，以便确定所需要请求例程的地址。
然后该操作传送给BIOS或操作系统去完成指定的动作并返回程序继续原来的处理过程。
通常，中断必须完成输入或输出操作的许多复杂步骤。中断需要能方便地退出程序，并且在成功完成指定动作后，又立即返回该程序。
为了这一目的，INT执行以下操作：
标志寄存器的内容进栈（堆栈指针减2）。
清除中断与陷阱标志。
CS寄存器进栈
指令指针（内有下一条指令的地址）进栈。
完成所要求的操作。
为了从中断返回，发送一条IRET（中断返回），使寄存器出栈。所恢复的CS:IP使之返回到紧跟在INT后的指令。
由于上述处理是完全自动化的，所以唯一要做的是按照进栈、出栈以及使用适当的INT操作的需要，定义一个足够大的堆栈。
6.7寻址方式
操作数地址为指令的处理提供数据来源。某些指令，如CLC和RET，不需要操作数；而其它指令可能有1个、2个或3个操作数。
其中有2个操作数的，第一个操作数是目的，它包含的数据在寄存器或存储器中，并且是要被处理的。
第二个操作数是源，它包含或是要被提交的数据（立即数）或是数据的地址（在存储器中的或寄存器的）。对于大多数指令，源数据是不被操作改变的。
寻址的3个基本方式是：寄存器寻址方式，立即寻址方式，以及存储器寻址方式，存储器寻址由6种类型组成，总共有8种方式。
1.寄存器寻址
对于这种方式，寄存器提供8位、16位或32位寄存器中任何一个的名字。由指令决定，寄存器可以出现在第一个操作数中，第二个操作数中，或者两个操作数中都出现。
如以下例子所示：
MOV DX,WORD_MEM   ;寄存器在第一个操作数中
MOV WORD_MEM,CX   ;寄存器在第二个操作数中
由于在寄存器之间处理数据不涉及引用存储器，所以是最快的操作类型。
2.立即寻址
立即操作数包括常数值或表达式。下面是一些有效的立即常数的例子：
十六进制：0148H
十进制：328（汇编程序把它转换成0148H）
二进制：000101001000B（可转换成0148H）
对于许多有2个操作数的指令，第一个操作数可以是个寄存器或存储单元，而第二个操作数可以是立即常数。
目的字段（第一个操作数）定义数据的长度。下面是一些例子：
BYTE_VAL DB 150   ;定义字节
WORD_VAL DW 300   ;定义字
DBWD_VAL DD 0   ;双字
SUB BYTE PTR BYTE_VAL,50   ;立即数到存储器（字节）
MOV WORD PTR WORD_VAL,40H   ;立即数到存储器（字）
MOV DWORD PTR DBWD_VAL,0   ;立即数到存储器（双字）
MOV AX,0245H   ;立即数到寄存器（字）
最后一个例子中的指令是把立即常数0245H传送到AX。3字节的目标码是B84502，其中B8的意思是“把立即值传送到AX”，
而紧跟的2个字节是值本身（4502H，按字节相反顺序排列）。
立即操作数的使用提供了更高的处理速度，它比在数据段中定义数字常数并在操作数中引用它的处理速度要快。
立即常数的长度不能超过由第一个操作数所定义的长度。下面的无效的例子中，立即操作数是两个字节，而AL只是一个字节：
MOV AL,0245H   ;无效的立即数长度
但是，如果立即操作数比要接收的操作数短，如在下面的指令中
ADD AX,48H   ;有效的立即数长度
则汇编程序把立即操作数扩展成两个字节的0048H，并把它存放在目标码中为4800H。
3.直接存储器寻址
在这一格式中，一个操作数引用存储单元，而另一个操作数则是引用寄存器（允许2个操作数直接访问存储器的指令只有MOVS和CMPS）。
DS是访问存储器中数据的默认段寄存器，如DS：偏移值。以下是一些例子：
ADD BYTE PTR BYTE_VAL,DL   ;寄存器加到存储器（字节）
MOV BX,WORD_VAL   ;存储器传送到寄存器（字）
4.直接-偏移值寻址
这种寻址方式是直接寻址方式的变种，它使用算术操作符修改地址。以下例子是使用这些定义的表格：
BYTE_TBL DB 12,15,16,22,...
WORD_TBL DW 163,227,485,...
DBWD_TBL DD 465,563,897,...
（1）字节操作。这些指令访问BYTE_TBL中的字节：
MOV CL,BYTE_TBL[2]   ;从BYTE_TBL中取得字节
MOV CL,BYTE_TBL+2   ;同样的操作
第一条MOV使用算术操作符访问BYTE_TBL的第三个字节16（BYTE_TBL[0]是第一个字节，BYTE_TBL[1]是第二个字节，而BYTE_TBL[2]则是第三个字节）。
第二条MOV使用加（+）操作符，效果完全一样。
（2）字操作。这些指令访问WORD_TBL中的字：
MOV CX,WORD_TBL[4]   ;从WORD_TBL中取得字
MOV CX,WORD_TBL+4   ;同样的操作
MOV访问WORD_TBL的第三个字（WORD_TBL[0]是第一个字，WORD_TBL[2]是第二个字，而WORD_TBL[4]是第三个字）。
（3）双字操作。这些指令访问DBWD_TBL中的双字：
MOV CX,DBWD_TBL[8]   ;从DBWD_TBL取得双字
MOV CX,DBWD_TBL+8
MOV访问DBWD_TBL的第三个双字（DBWD_TBL[0]是第一个双字，DBWD_TBL[4]是第二个双字，而DBWD_TBL[8]是第三个双字）。
5.间接存储器寻址
间接寻址利用了计算机的段：偏移值的寻址能力。用于此目的的寄存器是基址寄存器（BX或BP）和变址寄存器（DI和SI），方括号内的编码是指明对存储器的引用。
如果使用了.386，.486或586伪操作，还可以使用任何通用寄存器（EAX，EBX，ECX，以及EDX）去做间接寻址。
如[DI]那样的间接寻址告诉汇编程序，当程序接着执行时，所用的存储器地址将在DI中。
为了处理数据段中的数据，BX、DI和SI与DS联系在一起成为DS:BX，DS:DI和DS:SI。BP和SS联系在一起成为SS:BP，用来处理堆栈中的数据。
当第一个操作数包含间接地址时，第二个操作数引用寄存器或立即值；当第二个操作数包含间接地址时，第一个操作数引用寄存器。
注意方括号中的BP，BX，DI，或SI的引用是指间接操作数，当程序执行时，处理器是把这些寄存器的内容作为偏移地址处理的。
下面的例子中，首先LEA用DATA_VAL的偏移地址初始化BX。然后MOV把CL存入由现在BX中的地址所指向的存储单元，在这种情况下，是DATA_VAL：
DATA_VAL DB 50   ;定义字节
LEA BX,DATA_VAL   ;用偏移地址装入BX
MOV [BX],CL   ;把CL传送到DATA_VAL
这两条指令和MOV DATA_VAL,CL的效果是一样的。但是，变址寻址方式是比较重要的。
这里再举几个例子：
ADD CL,[BX]   ;第2个操作数=DS:BX
MOV BYTE PTR [DI],25   ;第1个操作数=DS:DI
ADD [BP],CL   ;第1个操作数=SS:BP
.386
MOV DX,[EAX]   ;第2个操作数=DS:EAX
下面这个例子使用偏移的绝对值：
MOV CX,DS:[38B0H]   ;存储器偏移值38B0H中的字
6.基址位移量寻址
这一寻址方式还是使用基址寄存器（BX和BP）和变址寄存器（DI和SI），但与一个位移量（数或偏移值）组合起来形成有效地址。
下面的MOV指令把零传送到紧跟在DATA_TBL起点后的2个字节的单元中：
DATA_TBL DB 365 DUP (?)
LEA BX,DATA_TBL
MOV BYTE PTR [BX+2],0
一些其他的例子如下：
ADD CL,[DI+12]   ;DI内的偏移值加12（或12[DI]）
SUB BYTE PTR DATA_TBL[SI,25   ;SI的内容为偏移值（0-364）
MOV DATA_TBL[DI],DL   ;DI的内容为偏移值（0-364）
.386
MOV DX,[EAX+4]   ;EAX内的偏移值加4
ADD DATA_TBL[EDX],CL   ;EDX+偏移值DATA_TBL
7.基址-变址寻址
这种寻址方式是把基址寄存器（BX或BP）和变址寄存器（DI或SI）组合起来形成有效地址、例如，[BX+DI]指的是BX中的地址加上DI中的地址。
这种方式通常用于对二维数组的寻址，比如BX引用的是行，而SI则是列。下面是一些例子：
MOV AX,[BX+SI]   ;从存储器传送字
ADD [BX-DI],CL   ;把字节加到存储器
8.带位移量的基址-变址寻址
这一寻址方式是基址-变址寻址方式的变种，它由基址寄存器，变址寄存器和位移量组合，形成有效地址。一些例子如下：
MOV AX,[BX+DI+10]   ;或10[BX+DI]
MOV CL,DATA_TBL[BX+DI]   ;或[BX+DI+DATA_TBL]
6.8段跨越前缀
处理器在寻址时会自动地选择适当的段：为取指令用CS:IP，为存取存储器的数据用DS：偏移值，为访问堆栈用SS:SP。
有这样的时候，特别是对于大型程序，必须处理属于另外一个段的数据，比如它的段寄存器是ES、FS或GS。
例如一个大型的数据表，它的数据是在程序的另一个段里从外部存储设备装入到存储器中的。
可以使用任何指令处理在其他段中的数据，但必须确定合适的段寄存器。假定其他段的段地址在ES中，并且BX的内容是该段内的偏移地址。
要求从那个单元传送2个字节（一个字）到DX：
MOV DX,ES:[BX]   ;从ES:[BX]传送到DX
编码“ES:”代表跨越操作符，意思是“用ES代替正常使用的DS段寄存器”。
下个例子是把一个字节值从CL传送到这个其他段，段的偏移值是由SI中的值加上36形成的：
MOV ES:[SI+36],CL   ;从CL传送到ES:[SI+36]
汇编程序产生带有跨越操作符的目标码，该跨越操作符作为一个字节的前缀（26H）直接放在指令的前面，就好像已经编写成了2条指令
ES:MOV DX,[BX]   ;从ES:[BX]传送到DX
ES:MOV [SI+36],CL   ;从CL传送到ES:[SI+36]
6.9近地址与远地址
在程序中，地址可以是近的或远的。近地址仅仅是由地址的16位偏移部分组成。引用近地址的指令采用的是当前段，即对于数据段是DS，对于代码段是CS。
远地址是由段和偏移部分组成的32位的段：偏移的格式。指令可以引用来自当前段内的或是另一个段中的远地址。
几乎所有在实模式下的汇编程序设计都使用近地址，除非另有其它指定，近地址一般是由汇编程序产生的。
由许多段组成的大型程序会需要远地址，因为该程序是用Flat存储模型来定义的。
6.10对齐数据地址
由于8086和80286处理器有16位（字）数据总线，如果所存取的字从偶数（字）地址开始，那么它们的执行是比较快的。
考虑这种情况，在偏移值0012H和0013H那里包含63A7H这个字。处理器可以在偏移值0012H处直接把整个字取到比如AX中。
但该字可能开始于奇数地址，比如0013H：
存储器内容：xx         63         A7         xx
偏移值：      0012                  0014
                                0013                  0015
在这种情况下，处理器不得不完成两次取数。第一次，在0012H和0013日处取2个字节并从0013H把字节（63）发送到AL。
然后，在0014H和0015H处取2个字节并从0014H把字节（A7）发送到AH。现在AX的内容是A763H。
没有必要对偶数或奇数单元做任何特别的程序设计，也不一定要知道地址是偶数的还是奇数的。
80386+处理器有32位的数据总线，因此建议按能被4整除的地址（双字地址）对齐所引用的项。（从技术上说，486+处理器建议按16个字节（小段）边界对齐。）
可以使用ALIGN或EVEN伪操作强制按边界对齐项。例如，ALIGN 2或EVEN可对齐字边界，而ALIGN 4则是对齐双字边界。
当汇编程序根据边界调整项的地址时，位置计数器也要相应地增值。
由于用PARA定义的数据段是在小段边界上开始的，所以可以首先用双字的值，然后用字的值，最后用字节的值来组织数据。
对齐对于时间要求苛刻的应用程序可能是有帮助的。
6.11要点
MOV指令把按第二个操作数的地址引用的数据传送（或复制）到第一个操作数的地址中。
LEA指令对于用偏移地址去初始化寄存器是有用的。
INC和DEC是把寄存器或存储单元的内容加1和减1。
INT指令中断程序的执行过程，传送控制给BIOS或DOS去做指定的操作，然后用IRET返回该程序并恢复处理过程。
操作数为指令提供数据的源。一条指令可以有0到3个操作数。
存在2个操作数时，第二个操作数是源，它引用立即数据或数据的地址（寄存器的或存储器的）。第一个操作数是目的，它引用的是在寄存器或存储器中要被处理的数据。
在立即格式中，两个操作数中的第二个含有常数值或表达式。立即操作数应当与目的的大小相匹配，即两者都是字节、字或双字。
在直接存储器格式中，一个操作数引用存储器单元，而另一个操作数则引用寄存器。
间接寻址利用了处理器的段：偏移寻址的能力。使用BP、BX、DI和SI寄存器，编写在方括号内作为变址操作符。
BP与SS联系在一起，成为SS:BP，用于处理堆栈中的数据。BX、DI和SI是和DS联系在一起的，分别成为DS:BX，DS:DI和DS:SI，用于处理数据段中的数据。
可以把寄存器组合成间接地址，如[BX+DI]，它指的是BX中的偏移值加上DI中的偏移值。
6.12习题
6-1.对于有2个操作数的指令，（a）哪个操作数是源？（b）哪个操作数是目的？
第一个操作数是目的，它包含的数据在寄存器或存储器中，并且是要被处理的。
第二个操作数是源，它包含或是要被提交的数据（立即数）或是数据的地址（在存储器中的或寄存器的）。
6-2.对于以下每条不相关的指令，写出目的操作数的结果。如果指令是无效的，请指出来。假定BYTE1被定义为DB 05H。
指令前
（a）MOV CX,25H
执行前CX=0000H，执行后CX=0025H
（b）MOV CL,0
执行前CX=FFFFH，执行后CX=FF00H
（C）MOV AX,BYTE1   无效指令   改为MOV AL,BYTE1
执行前AX=1234H，执行后AX=1205H
（d）ADD DL,BYTE1
执行前DX=0120H，执行后DX=0125H
（e）INC DX
执行前DX=FFFFH，执行后DX=0000H
（f）INC DL
执行前DX=FFFFH，执行后DX=FF00H
（g）XCHG AH,AL
执行前AX=1234H，执行后AX=3412H
（h）SUB CX,CX
CX=1234H，执行后CX=0000H
（i）XCHG CX,CX
CX=1234H，执行后CX=1234H
6-3.（a）以下MOV指令在执行方面有什么明显的区别？
MOV DX,AC24H         立即数AC24H传送到寄存器DX
MOV DX,[AC24H]      立即数AC24H作为数据段的偏移值，把起始于DS:[AC24H]的一个字传送到寄存器DX
（b）对于第二条MOV，一个操作数是在方括号中的。该特征的名字是什么？
存储器寻址
64.（a）以下MOV指令在执行方面有什么明显的区别？
MOV BX,WORDA         存储器中的WORDA传送到寄存器BX（字）
MOV [BX],WORDA      存储器中的WORDA传送到存储器DS:[BX]（字）
（b）对于第二条MOV，第一个操作数用的是哪种寻址方式？
使用寄存器BX的间接存储器寻址
6-5.说明下列指令的操作
SUB CX,[BX+DI+4]         带位移量的基址变址寻址
寄存器CX减去存储器DS:[BX+DI+4]（字）
BX做基址寄存器，DI做变址寄存器，另外的位移量是4
6-6.对于以下语句，（a）指出错误，（b）指出一种改正的方法：
SUB [SI],[BX]         两个操作数同时为存储器操作数
MOV AX,[BX]
SUB WORD PTR [SI],AX
6-7.给出以下数据定义，找出语句中的错误，并编写指令加以改正：
BYTE1 DB 48
BYTE2 DB 32
WORD3 DB 216
（a）MOV BYTE1,BYTE2         两个操作数同时为存储器操作数
MOV AL,BYTE2
MOV BYTE1,AL
（b）SUB CL，WORD3         ;第二个操作数是正确的  两个操作数大小不一致
SUB CX,WORD3
（c）ADD DH,051CH         第二个操作数是正确的  两个操作数大小不一致
ADD DX,051CH
6-8.编写以下带立即操作数的指令：
（a）把hex 26加到BX，（b）从CX减去hex 26，（c）把CH右移2位，
（d）把BYTE1左移2位，（e）把426存入CX，（f）比较BYTE1和hex25。
ADD BX,0026H，SUB CX,0026H，
MOV CL,2
SHR CH,CL
MOV CL,2
SHL BYTE PTR BYTE1,CL
MOV CX,426
CMP BYTE PTR BYTE1,25H
6-9.编写指令，把名为WORD3的字的内容和AX交换。
XCHG AX,WORD3
6-10.编写指令，把名为RATE_TBL项的偏移地址放到SI中。
LEA SI,RATE_TBL
6-11.用通用术语说明INT指令的用途。
INT指令中断程序的正常处理过程，访问中断向量表，确定中断处理程序的地址。
传送控制给BIOS或操作系统的相应中断处理程序，完成相应的中断处理，用IRET返回该程序并恢复处理过程。
6-12.说明（a）INT指令是如何影响堆栈的，（b）IRET指令是如何影响堆栈的。
INT指令的处理过程
（1）（从中断信息中）取得中断类型码；
（2）标志寄存器的值入栈（因为在中断过程中要改变标志寄存器的值，所以先将其保存在栈中）；
（3）设置标志寄存器的第8位TF和第9位IF的值为0
（4）CS的内容入栈；
（5）IP的内容入栈；
（6）从内存地址为中断类型码*4和中断类型码*4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS。
IRET指令的处理过程
pop IP
pop CS
popf
在中断过程中，寄存器入栈的顺序是标志寄存器、CS、IP，而iret的出栈顺序是IP、CS、标志寄存器，刚好和其相对应，
实现了用执行中断处理程序前的CPU现场恢复标志寄存器和CS、IP的工作。
6-13.编码，汇编，连接，并使用DEBUG检查以下程序：
（a）定义名为BYTE1和BYTE2（包含任何值）的字节项，以及名为WORD3（包含0）的字项，
（b）把BYTE1的内容传送到AL，（c）把BYTE2的内容加到AL，
（d）把立即值42H传送到DL，（e）交换AL与DL的内容，
（f）AL的内容乘以DL（MUL DL），（g）把乘积从AX传送到WORD3。
.MODEL SMALL
.STACK 64
.DATA
BYTE1 DB 05H
BYTE2 DB 08H
WORD3 DW 0
.CODE
MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV AL,BYTE1
ADD AL,BYTE2
MOV DL,42H
XCHG AL,DL
MUL DL
MOV WORD3,AX
MOV AX,4C00H
INT 21H
MAIN ENDP
END MAIN
6-14.说明为什么指令ADD [BX],25是无效的，并改正它。
没有指明存储器操作数DS:[BX]的大小
ADD WORD PTR [BX],25
6-15.编写指令把BYTE_TBL中定义的每个字节逐次地加到CL寄存器中。使用直接偏移值寻址和5个ADD指令。
BYTE_TBL DB 12,15,16,10,8
ADD CL,BYTE_TBL[0]
ADD CL,BYTE_TBL[1]
ADD CL,BYTE_TBL[2]
ADD CL,BYTE_TBL[3]
ADD CL,BYTE_TBL[4]
6-16.利用6-15题所定义的BYTE_TBL编写指令向CL传送第4个字节（内容为10）。
（a）使用间接寻址。（b）使用基址-位移量寻址。
LEA SI,BYTE_TBL[3]
MOV CL,[SI]
LEA BX,BYTE_TBL
MOV CL,[BX+3]
6-17.给出以下的表和初始化指令，说明MOV的作用：
VALUE_TBL DB 1,2,3,4,5,6,7,8
LEA BX,VALUE_TBL   ;初始化BX和DI
MOV DI,4
（a）MOV CL,[BX]
CL=1
（b）MOV DL,[BX+3]
DL=4
（c）MOV AL,[BX+DI]
AL=5
（d）MOV CH,2[BX+DI]
CH=7
第7章程序逻辑与控制
7.1引言
7.2短地址，近地址和远地址
7.3 JMP 指令
7.4 LOOP指令
7.5标志寄存器
7.6 CMP指令
7.7条件转移指令
7.8调用过程
7.9程序执行对堆栈的影响
7.10布尔操作
7.11移位
7.12循环移位
7.13组织一个程序
7.14要点
7.15习题
目的：阐述对于程序控制（循环与转移），逻辑比较，逻辑位操作，以及程序组织的要求。
7.1引言
到本章为止，大多数程序都是直线执行的，即一条指令跟着另一条指令顺序地执行。但是，很少会有这种简单易编程序的问题。
大多数程序是由各种测试和若干循环组成的。这些测试用来确定要采取几个动作中的哪一个动作，而在这些循环中的一系列步骤则要重复到指定的要求被满足为止。
例如，通常的做法是去测试程序是否应该结束执行。这些要求包括传送控制给一条指令的地址，而该指令不是紧跟在当前正在执行的指令之后。
控制的传送可能是向前的，去执行一系列新的步骤；或者是向后的，去重新执行一些同样的步骤。能够传送控制的指令可以把控制传送到超出正常的顺序流程之外，
这是通过改变IP中的偏移值的办法来完成的。
以下是在这一章里按类型列出的指令：
比较操作                  传送操作                  逻辑操作                  移位和循环
CMP                         CALL                         AND                       SAR/SHR
TEST                         JMP                           NOT                      SAL/SHL
                                Jnnn                           OR                         RCR/ROR
                                LOOP                         XOR                       RCL/ROL
                                RETn
Jnnn是指所有条件转移指令，如JNE和JL。
7.2短地址，近地址和远地址
汇编程序支持三种类型的地址，是根据它们与当前地址的距离加以区别的：
（1）短地址，对距离的限制是-128（80H）到127（7FH）个字节。
（2）近地址，对距离的限制是-32768（8000H）到32767（7FFFH）个字节，在同一个段内。
（3）远地址，在同一段内，距离可超过32K，或在另一个段里。
转移操作可到达1个字节偏移值的短地址，还可到达一个或两个字节偏移值的近地址。远地址则可到达段地址和偏移值所指定的地方。
CALL是为此目的所用的标准指令，因为它便于连接到需要的地址并随后返回。
下面的表列出了JMP，LOOP，以及CALL操作在距离方面的规则。几乎没有必要记住这些规则，因为正常使用这些指令难得出现问题。
短                                             近                                             远
指令         -128到127         -32768到32767                           超过32K或在另一段
                同一段               同一段
JMP         是                      是                                                 是
Jnnn        是                      是（80386+）                              否
LOOP      是                      否                                                  否
CALL       不适用                是                                                  是
JMP，Jnnn（条件转移），或LOOP指令的操作数是另一条指令的标号。下面的例子是转移到L10，L10是INC指令的标号：
JMP L10
L10:INC CX
一条指令的标号，如L10：，是用冒号来结束的，这赋予它近的属性，即此标号是在同一代码段的一个过程之内的。
遗漏了冒号是个普通的错误，汇编程序会发出信号。注意：一条指令的操作数中的地址标号（比如JMP L10）是没有冒号的。还可以把标号写在单独的行里，如
L10:
INC CX
两种情况下，L10的地址都是位于INC指令的第一个字节。
7.3JMP指令
通用的传送控制指令是JMP（转移）指令。由于该操作在所有情况下传送控制，所以这种转移是无条件的。
JMP还要填满处理器的预取指令队列，这样有许多转移操作的程序可能会降低处理速度。JMP的格式是：
[label:] JMP short/near/far address（short；短，near：近，far：远，address：地址）
7.3.1短转移与近转移
在同一段内的转移操作可以是短转移或近转移（或甚至是远转移，如果目的是一个具有FAR属性的过程的话）。
在汇编程序第一遍扫视源程序时，会产生每条指令的长度。但是，JMP指令可能是2个、3个或4个字节长。
JMP操作到标号的距离在-128（80H）到127(7FH)字节范围之内的是短转移。汇编程序为操作产生一个字节（EB）并为操作数产生一个字节。
操作数相当于偏移值，当执行程序时，处理器把它加到IP寄存器中。
超过-128到+127字节的JMP就变成了近转移（在32K范围内），对于近转移，汇编程序产生不同的机器码（E9）和2个字节的操作数（8086/80286）或
4个字节的操作数（80386+）。暂时我们先不讨论远转移。
7.3.2向后与向前转移
转移可以是向前的或是向后的。汇编程序已经遇见过这个范围在-128字节内的指定的操作数（向后转移），比如：
L10:   ;转移地址
JMP L10   ;向后转移
这种情况下，汇编程序产生一个2个字节的机器指令。在向前转移中，汇编程序还没有遇到过这个指定的操作数：
JMP L20   ;向前转移
L20:   ;转移地址
汇编程序现在还不知道向前转移是短转移还是近转移，某些版本假定是近转移并产生3个字节指令EBXX90，其中xx是偏移值，而90是NOP的机器码。
但是，所提供的转移实际上是短转移，可以使用SHORT操作符强制它是个短转移并产生2个字节指令EBXX，编码如下：
JMP SHORT L20
7.3.3程序：使用JMP指令
图7.1的程序说明JMP的用法。程序把AX与BX初始化为0，而把CX初始化为1，并且循环完成以下的操作：
AX加1。
把AX加到BX。
左移一位（CX中的值加倍）。
在循环的末尾（SHL之后），指令JMP A20传送控制给标号为A20的指令。
重复循环的结果使AX增加为1，2，3，4，...；BX按照数字的和增加为1，3，6，10，...；而CX则加倍为1，2，4，8，...。
由于这个循环没有退出，所以处理过程是无休止的―通常仅有的适合的实际应用是用于像监控系统这样一类的专门用途。
在程序中，A20距JMP是-9个字节。可以用分析JMP的目标码（EBF7）的办法来确定这个距离。EB是短JMP的机器码，而hexF7则是-9的二进制补码表示。
因为这是一个向后转移，所以操作数F7是负的。现在，IP的内容是下一条要执行的指令的偏移值（0112H）。
JMP操作把F7（由于IP的大小是一个字，所以应转换为FFF7。）加到IP，IP的内容是跟随JMP之后的指令的偏移值0112H：
                  十进制         十六进制
IP寄存器：274              0112H
JMP操作数 -9               FFF7H
转移地址：265              0109H
汇编程序计算的转移地址是0109H（其中进位输出的1忽略不计）。检查一下，这和程序列表中A20的偏移地址是一样的。
该操作改变了IP中的偏移值，填满了指令队列，并继续重新执行跟在A20后面的指令。
TITLE A07JUMP（COM）Using JMP for looping
.MODEL TINY
.CODE
ORG 100H
A10MAIN PROC NEAR
MOV AX,0
MOV BX,0
MOV CX,1
A20:ADD AX,1
ADD BX,AX
SHL CX,1
JMP A20
A10MAIN ENDP
END A10MAIN
图7-1JMP指令的用法
作为一种有用的做法，可以使用DEBUG跟踪程序的多次迭代并观察AX，BX，CX，以及IP中的执行结果。
AX 1,2,3,4,5,6,7,8
BX 1 3 6 10 15 21 28 36
CX 2 4 8 16 32 64 128 256
完成8次迭代之后，AX的内容是08，BX是36，而CX是256（100H），键入Q退出DEBUG。
7.4 LOOP指令
图7-1中所用的JMP指令产生一个无限的循环。标准的做法是编一个例行程序，它循环指定的次数或直到满足指定的条件为止。
LOOP指令就是服务于这一目的的，它要求在CX中有一个初始值。对于每次迭代，LOOP自动地从CX中减1。一旦CX达到零，控制向下直接到下一条指令；
如果CX是非零，则控制转移到操作数地址。对操作数的距离必须是短转移，范围在-128到+127个字节。
对于超出这一限制的操作，汇编程序会发出比如“相对转移超出范围”（relative jump out of range）的信息。LOOP的格式是
[label:] LOOP short-address
图7-2的程序说明LOOP的用法。它所完成的操作除了初始化CX为8且8次循环后结束之外，和图7-1的程序是一样的。
由于LOOP要求使用CX，所以这个程序用DX代替CX，完成把初始值1加倍的工作。
LOOP指令取代了JMP A20指令，并且为了提高处理速度，INC AX（AX加1）取代了ADD AX，01。
正如JMP那样，LOOP的机器码操作数包含从该指令末尾到A20地址间的距离，当程序执行时，它被加到IP中。
TITLE A07LOOP（COM）illustration of LOOP
.MODEL TINY
.CODE
ORG 100H
A10MAIN PROC NEAR
MOV AX,0
MOV BX,0
MOV DX,1
MOV CX,8
A20:INC AX
ADD BX,AX
SHL DX,1
LOOP A20
MOV AX,4C00H
INT 21H
A10MAIN ENDP
END A10MAIN
图7-2使用LOOP指令
作为有用的练习，使用DEBUG跟踪整个8次循环的全过程并观察AX、BX、CX、DX和IP中的执行结果。
当CX减到零时，AX、BX和DX的内容分别是0008H、0024H和0100H。
LOOP指令有2个变种，它们也都是CX减1。LOOPE/LOOPZ（当相等或为零时循环）只要CX不为零且零条件被设置（ZF=1）便继续循环。
LOOPNE/LOOPNZ（当不相等或不为零时循环）只要CX不为零且零条件没有设置（ZF=0）便继续循环。
LOOP和它的LOOPxx变种都不改变标志寄存器中的任何标志的设置。但是，由于在LOOP例行程序内的其他指令会改变标志，
所以图7-2中使用的是LOOP而不是LOOPxx变种。
7.5标志寄存器
在本章余下的内容中，需要有关标志寄存器的更为详细的知识。这个寄存器有16位，由各种指令设置来指明它们的操作结果。
在所有情况下，标志要保留其设置，直到另一条指令把它改变为止。标志寄存器包含以下一些通用的位：
31          19   18   17   16  15  14  13 12   11   10  9  8    7   6   5  4   3  2   1  0
                    AC  VM  RF  0   NT  IOPL    OF  DF IF TF  SF ZF  0 AF 0  PF     CF
下面从右到左讨论标志位。引用“数据项”是指数据在寄存器或存储器中。
（1）CF（进位标志）。包含一个数据项高阶（最左边）位的进位（0或1）输出，它是伴随无符号算术操作和某些移位与循环操作而产生的。
一些磁盘操作使用CF去指明成功（0）或失败（1）。JC和JNC测试这个标志。
（2）PF（奇偶标志）。奇偶标志PF用于反映运算结果中“1”的个数。如果“1”的个数为偶数，则PF被置1，否则PF被清0。
不要把这个标志和第1章所讨论的奇偶位搞混淆了，在一般的程序设计中，很少会涉及到它。JP和JPO测试这个标志。
JNP：若奇偶位为0则转移   JPO：若奇偶性为奇则转移
JP：若奇偶位为1则转移   JPE：若奇偶性为偶则转移
（3）AF（辅助进位标志）。该标志和使用ASCII和BCD压缩字段的算术运算有关，这在第13章会涉及到。
当1字节的算术操作造成位3（从右边数第4位）的进位输出进到了位4，此时AF位置1。
（4）ZF（零标志）。根据算术操作或逻辑操作的结果进行清除或置位。非零的结果要把ZF清除为0，而零的结果则要把ZF置成1。
但是，如果这种设置不是表面上的正确而是逻辑上的正确，那么“0”的意思是“不”（结果不等于零），而“1”的意思是“是”（结果等于零）。
JE和JZ（连同其他指令一起）测试ZF。
（5）SF（符号标志）。根据算术操作后的数据项符号（高阶位或最左边的位）设置：正值，把SF清除为0：而负值则把SF置1。JG和JL（连同其他指令一起）测试SF。
（6）TF（陷阱标志）。当设置它时，处理器将按单步方式执行指令，即在用户的控制之下，每次执行一条指令。
调试程序为单步执行而设置TF，并且放在差不多是最适当的、你希望找到它的地方。INT 03操作用于设置TF。
（7）IF（中断标志）。当它为0时，禁止外部中断；为1时允许中断。IF可以由STI指令设置，由CLI指令清除，通常用在关键性的场合。
（8）DF（方向标志）。由串操作在确定数据传送方向时使用。当DF为0时，串操作实行从左到右的数据传送；当DF为1时，串操作实行从右到左的数据传送。
第11章会讨论到它。
（9）OF（溢出标志）。指明带符号算术操作后数据项的高阶（最左边）符号位的进位输出。JO和JNO测试OF。
7.6CMP指令
CMP指令是用来比较两个数字数据字段的，寄存器中包含了一个或两个字段。CMP的格式是
[label:] CMP register/memory，register/memory/immediate
从技术上说，可以使用CMP比较串（字符）数据，但是CMPS（第11章会涉及到）才是实现这一目的的合适指令。
CMP操作的结果影响AF、CF、OF、PF、SF和ZF标志，然而没有必要分别地去测试这些标志。以下代码是测试DX为零值的：
CMP DX,0
JE L10   ;如果是，则转移到L10
...
非零时的动作
...
L10:
如果DX是零，CMP设置ZF为1，并且可能改变或不改变其他标志的设置。JE（若相等则转移）指令只测试ZF。
由于ZF是1（意思是零状态），JE传送控制（转移）给由操作数L10所指明的地址。
实际上，CMP操作是比较第一个和第二个操作数。例如，第一个操作数的值高于、等于或低于第二个操作数的值吗
（CMP和SUB一样，没有为了执行所需要的附加存储周期）？下一节介绍基于测试条件进行传送控制的各种方法。
7.7条件转移指令
处理器支持各种各样的条件转移指令，这些指令根据标志寄存器的设置来传送控制。例如，可以比较或相加2个字段，然后根据比较所设置的标志值进行有条件的转移。
条件转移的格式是
[label:] Jnnn short-address
如前所述，LOOP指令使CX减1，如果它是非零，则控制传送给操作数地址。可以用2个语句取代图7-2中的LOOPA20语句，
这2个语句中的一个使CX减1，而另一个完成条件转移，如下所示：
DEC CX
JNZ A20
DEC使CX减1并设置或清除零标志，然后JNZ测试设置的零标志。如果CX是非零，则控制转移到A20；而如果CX是零，则控制往下到下一条指令
（转移操作还要填满处理器的预取指令队列）。尽管LOOP使用受到限制，但它执行的速度还是比较快的，而且比用DEC和JNZ指令使用的字节数要少。
像JMP和LOOP那样，JNZ的机器码操作数含有从指令的末尾到A20地址的距离，操作把它加到IP寄存器。
对于8086/80286，条件转移的距离必须是短的，在-128到+127字节范围之内。如果操作超出这一限制，汇编程序要发出“相对转移超出范围”的信号。
80386+处理器提供了32位（近的）偏移值，允许到达32K范围内的任意地址。
如果编写.386操作符，汇编程序会自动产生4字节的向前转移的机器码（例1）；使用SHORT操作符可以产生2字节的机器码（例2）：
例1                  例2
.386               .386
CMP BX,CX   CMP BX,CX
JE L20            JE SHORT L20
7.7.1带符号与无符号数据
判别条件转移的用途，应该了解它们的用法。所要实现的比较或算术操作的数据类型（无符号或带符号的）可以确定所使用的指令。
无符号的数据项（逻辑数据）把所有的位作为数据位处理，典型的例子如用户编号，电话号码，以及比率和系数这样一些数字值。
带符号数据项（算术数据）把最左边的位当作符号来处理，其中0表示正，而1表示负，典型的例子是数量，银行结算以及温度等，它们可能是正的，可能是负的。
在下一个例子中，假定CX是11000110，DX是00010110。指令CMP CX,DX比较CX和DX的内容。
如果把它们看成是无符号的数据，CX是较大的；如果把它们看成是带符号的数据，则由于负的符号的原因，CX是较小的。
这里所用的CMP是有效的，可以选择适当的条件转移指令，比如JB（低于则转移）用于无符号数据或JL（小于则转移）用于带符号数据。
7.7.2基于无符号（逻辑）数据的转移
以下条件转移用于无符号数据：
符号                           说明                           测试的标志
JE/JZ               相等则转移或为零则转移          ZF
JNE/JNZ         不相等则转移或不为零则转移   ZF
JA/JNBE       高于则转移或不低于/等于则转移 CF,ZF
JAE/JNB       高于/等于则转移或不低于则转移 CF
JB/JNAE       低于则转移或不高于/等于则转移 CF
JBE/JNA       低于/等于则转移或不高于则转移 AF,CF
这些条件转移中的每个都可以用两个符号操作中的一个来表示，应该选择比较清楚也比较能说明问题的那个。
7.7.3基于带符号（算术）数据的转移
以下条件转移是用于带符号数据的：
符号                           说明                           测试的标志
JE/JZ               相等则转移或为零则转移          ZF
JNE/JNZ         不相等则转移或不为零则转移   ZF
JG/JNLE       大于则转移或不小于/等于则转移 OF,SF,ZF
JGE/JNL       大于/等于则转移或不小于则转移 OF,SF
JL/JNGE       小于则转移或不大于/等于则转移 OF,SF
JLE/JNG       小于/等于则转移或不大于则转移 OF,SF,ZF
测试相等/为零（JE/JZ）和不相等/不为零（JNE/JNZ）的转移在无符号与带符号数据的两个表中都有，这是因为条件的存在与有没有符号无关。
7.7.4专用的算术运算测试
以下条件转移指令有专门的用途：
符号                           说明                           测试的标志
JCXZ                     若CX为零则转移                 没有
JC                  进位为1则转移（和JB一样）      CF
JNC               进位为0则转移                           CF
JO                 溢出则转移                                 OF
JNO              不溢出则转移                              OF
JP/JPE     奇偶位为1则转移或奇偶性为偶则转移 PF
JNP/JPO 奇偶位为0则转移或奇偶性为奇则转移 PF
JS                  符号位为1（负的）则转移          SF
JNS               符号位为0（正的）则转移          SF
JCXZ测试CX的内容是否为零。这条指令不需要紧跟在算术或比较操作之后。JCXZ的一种用法是可以放在一个循环的起点，以保证如果CX最初为零，就能绕过此例行程序。
JC和JNC通常用于测试磁盘操作的成败。
不需要记住所有这些指令的名字或它们所测试的标志。但是，作为一个提醒，请注意无符号数据的转移是相等（equal），高于（above）或低于（below）；
反过来，带符号数据的转移是相等（equal），大于（greater）或小于less。转移对于测试进位，溢出，以及奇偶标志有独特的用途。
汇编程序把符号翻译成目标码而不关心你所使用的是哪一条指令，但是比如JAE和JGE，尽管表面上类似，却测试不同的标志
（因为JAE适用于无符号数据，而JGE则适用于带符号数据）。
80386+处理器允许远条件转移。可以指定短转移和远转移，例如：
JNB SHORT address
JBE FAR address
7.7.5测试多个条件
对于条件转移，真的条件可以产生转移；相反若是假的条件，就直接往下执行下一条指令。程序可能必须测试一系列有关条件。
在下面，例1确定任一条件是否为真（OR操作），而例2确定所有条件是否为真（AND操作）：
例1任一条件为真                           例2所有条件为真
CMP AL,BL                                    CMP AL,BL
JE equal                                        JNE not_equal
CMP AL,BH                                   CMP AL,BH
JE equal                                        JNE not_equal
CMP AL,CL                                    CMP AL,CL
JE equal                                         JNE not_equal
not_equal:                                     equal:
...                                                    ...
equal:                                             not_equal:
...                                                    ...
在例1中，真的条件是按相等测试的，并且所有转移都到equal标号；在例2中，真的条件是按不相等测试的，并且转移到not_equal标号。
实际上，例2（AND操作）是使测试（JNE）和转移点（not_equal）都反向了。
7.8调用过程
到现在为止，例子中的代码段只包括一个过程，编码如下：
proc-name PROC FAR
proc-name ENDP
在这种情况下的FAR操作数通知汇编程序和连接程序所定义的过程名是程序执行的入口点，而ENDP伪操作则定义过程的结束。
但是，代码段可能包括任意个过程，每一个过程是用它自己的PROC和ENDP伪操作来区分的。
被调用的过程（或子程序）是完成有明确定义的任务的一组代码（比如设置光标或取得键盘输入）。把一个程序组织成过程能提供以下好处；
减少代码的数量，因为一个公共的过程可以在代码段的许多地方被调用；
有助于更好的程序组织；
便于程序的调试，因为可以更清楚地找出缺陷；
有助于程序的维护，因为过程容易判定要做的修改。
程序设计的习惯是在每个过程的起点提供一些注释，以便确定过程的用途和使用的寄存器，并且如有必要，在开始的时候使要改变的寄存器进栈，而在退出时使它们出栈。
CALL与RETn操作
CALL指令的目的是把控制传送给被调用的过程（在本书中转移到过程仅有的例子是在.COM程序的开始处）。RETn指令是和CALL指令配对的，作用是从被调用的过程返回到原先的调用过程。RETn通常是被调用的过程中的最后一条指令。CALL和RETn的格式是：
[label:] CALL procedure-name
[label:] RET [n] immediate
（procedure：过程，name：名）
汇编程序能区分过程的RET是近的还是远的并产生相应的目标码。然而，为了清楚起见，可以为近返回编写RETN，为远返回编写RETF。
CALL和RET产生特定的目标码，这取决于操作包含NEAR还是FAR过程。
（1）近调用与返回。在同一段内调用（CALL）一个过程是近调用，其实现如下：
通过进栈操作，SP减2（一个字）并把IP（含有跟在CALL之后指令的偏移值）传送进栈。
把被调用过程的偏移地址放入IP中（而且要填满处理器的预取指令队列）。
RET（或RETN）从一个近过程返回，基本上是CALL的相反步骤：
老的IP值从堆栈出栈，回送到IP（而且要填满处理器的预取指令队列）。
SP加2。
现在CS:IP指向调用过程中跟在原先的CALL后的指令，并且在那里恢复执行。
（2）远调用与返回。远调用（CALL）去调用标明FAR的过程，这个过程可能在另外一个代码段里。
远调用使CS和IP都进栈，并且RET（或RETF）使它们都出栈，远调用与返回在第22章讨论。
（3）近调用与返回举例。使用近调用与返回的典型程序组织如图7-3。注意以下特点：
程序分为一个远过程A10MAIN和2个近过程B10与C10。每个过程有唯一的名字，并有自己的ENDP用来结束其定义。
A10MAIN的PROC伪操作有FAR属性，因为它是操作系统中的入口点。
B10和C10的PROC伪操作有NEAR属性，它指明这些过程是在当前代码段范围之内的。因为省略属性汇编程序默认为NEAR，所以许多后面的例子都省略了它。
在过程A10MAIN中，CALL传送程序控制给过程B10并开始它的执行。
在过程B10中，CALL传送程序控制给过程C10并开始它的执行。
在过程C10中，RET使控制返回到紧跟在CALL C10之后的指令。
在过程B10中，RET使控制返回到紧跟在CALL B10之后的指令。
然后，过程A10MAIN从那一点起恢复处理过程。
RET总是返回到调用它的例行程序。如果B10不是用RET结束，则处理过程会继续经过B10并直接往下到C10。
实际上，如果C10没有用RET结束，该程序会经过C10终点继续执行指令（如果有的话，可能是碰巧在那里的任何指令），结果是不可预见的。
TITLE A07CALLP（EXE）Calling procedures
.MODEL SMALL
.STACK 64
.DATA
.CODE
A10MAIN PROC FAR
CALL B10
MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10 PROC NEAR
CALL C10
RET
B10 ENDP
C10 PROC NEAR
RET
C10 ENDP
END A10MAIN
图7-3调用过程
如前所述，可以用常规的排成行的代码传送控制给一个近过程，还可以用转移指令进入一个近过程。但是，为了清晰和一致起见，
习惯的做法是使用CALL传送控制给一个过程，并且使用RET/RETN结束过程的执行。
7.9程序执行对堆栈的影响
到现在为止，程序几乎不需要把数据放入堆栈，因此只需要定义一个非常小的堆栈。但是正如图7-3所说明的，一个被调用的过程可以调用另外一个过程，
而这个过程又可以调用另一个过程，所以堆栈必须足够大，以便容纳所有进栈的地址。
弄清楚所有这些结果比它第一次出现要容易一些，并且定义一个32个字的堆栈对我们的大多数用途来说是很宽裕的。
CALL和PUSH都是把一个字的地址或值存入堆栈。RET和POP则是出栈和取出以前进栈的字。
所有这些操作都是为下一个字而使SP寄存器中的偏移地址增量或减量。由于这一特点，RET和POP必须分别和它们相应的CALL与PUSH操作相匹配。
在为执行而装入.EXE程序时，装入程序要初始化以下寄存器的值：
DS与ES:PSP的地址，放在存储器中的可执行模块之前的一个256个字节（100H）的区域。
CS：代码段的地址，程序的入口点。
IP：如果第一条可执行指令是在代码段起点，则为零。
SS：堆栈段的地址。
SP：栈顶的偏移值。例如，堆栈定义为：.STACK 64（64个字节或32个字），SP初始内容是64或40H。
跟踪图7-3中简单程序的整个执行过程。实际上，被调用的过程可以包含任意多的指令。
你会发现汇编这个程序并使用调试程序跟踪它的执行过程，同时检查IP、SP和堆栈的内容，所有这些都是值得一做的事。
对于进栈来说，当前可用的单元是栈顶。在这个例子中，装入程序要把SP设置成堆栈的大小――64（40H）个字节。
存储器中的字包含按相反顺序排列的字节，例如，0003变成0300。
该程序完成以下操作：
CALL B10使SP减2，从40H变成3EH。然后使IP（内容为0003，下一条指令的地址）进栈，放入偏移值3EH处的栈顶。
处理器使用由CS:IP形成的地址把控制传送到B10，如以下堆栈帧所示：
CALL B10（0003进栈）：
003E   0300   <-SP=003E
003C   xxxx
003A   xxxx
在过程B10中，CALL C10使SP减2，变成3CH。然后使IP（内容是000B）进栈，放入偏移值3CH处的栈顶。
处理器使用CS:IP地址把控制传送给C10：
CALL C10（000B进栈）：
003E   0300
003C   0B00   <-SP=003C
003A   xxxx
为了从C10返回，RET使偏移值（000B）从3CH处的栈顶出栈，放入IP中，并且SP加2成为3EH。IP中的偏移值使之自动返回到过程B10中的000BH偏移值处：
RET（000B出栈）：
003E   0300   <-SP=003E
003C   0B00
003A   xxxx
在过程B10末尾的RET使地址（0003）从栈顶003EH处出栈，放入IP中，并且SP加2成为0040H。IP中的偏移值使之自动返回到偏移值0003H处，在那里程序结束执行。
                                    <-SP=0040
RET（0003出栈）：
003E   0300
003C   0B00
003A   xxxx
如果利用调试程序查看堆栈，可以发现由以前执行过的程序留在那里的未被破坏的数据。
过满的堆楼。考虑仅用12个字定义堆栈的程序。当执行时，一连串的CALL 和PUSH操作会从存储器高端到低端填满堆栈。
此刻，SP=0。由于没有RET或POP，所以下一个CALL或PUSH使SP减量，从0到FFFEH并存放新的值，这已超过所定义的堆栈，会产生不可预见的后果。
传送参数
当调用过程时，通常的做法是要传送一些参数（或自变量）供过程使用。程序可以通过值（实际的数据项），或者通过引用（数据的地址）传送参数。
同样，还可以用寄存器或用堆栈来传送参数。
1.通过值传送参数。下面的例1和例2说明通过值传送参数。程序把被乘数与乘数作为参数传送给一个过程，使它们简单地相乘。
这个版本的MUL假定被乘数是在AX中，而乘数是在操作数中，求出来的乘积在DX:AX中。
例1传送在寄存器中的值                           例2传送在堆栈中的值
MOV AX,MULTIPLICAND                      PUSH MULTIPLICAND
MOV BX,MULTIPLIER                            PUSH MULTIPLIER
CALL M30MULT                                    CALL M30MULT
M30MULT PROC NEAR                        M30MULT PROC NEAR
MUL BX                                                 PUSH BP
RET                                                        MOV BP,SP
M30MULT ENDP                                   MOV AX,[BP+6]
                                                               MUL WORD PTR [BP+4]
                                                               POP BP
                                                               RET 4
                                                               M30MULT ENDP
例2值得进一步研究。在M30MULT的入口点上，SP指向在堆栈中的返回地址。为了访问堆栈，需要间接寻址，SP做不到，但BP可以做到。该过程通过以下方式实现：
sBP进栈，以便保留其内容。堆栈帧现在是这样：
被乘数   [BP+6]
乘数   [BP+4]
返回地址   [BP+2]
BP值   <-SP和BP
复制SP偏移值到BP中。
使用BP作间接寻址去取在[BP+6]和[BP+4]中的已传送来的参数。
BP出栈（该操作还要使SP加2指向返回地址）。
执行RET 4，实现2个功能：
（1）把返回地址装入IP中并使SP加2（现在它指向堆栈中的乘数）。
（2）把RET立即值（或出栈值）4加到SP，实际上是从堆栈中“移出”2个参数。注意，由于被调用的过程没有使参数出栈，所以RET必须调整SP。
2.通过引用传送参数。下面的例3和例4说明通过引用传送参数，这也是高级语言调用子程序的方法。被传送的参数是乘数与被乘数的地址。
例3寄存器中的地址                           例4堆栈中的地址
LEA BX,MULTIPLICAND                   PUSH OFFSET MULTIPLICAND
LEA SI,MULTIPLIER                           PUSH OFFSET MULTIPLIER
CALL M30MULT                                CALL M30MULT
M30MULT PROC NEAR                    M30MULT PROC NEAR
MOV AX,[BX]                                     PUSH BP
MUL WORD PTR [SI]                         MOV BP,SP
RET                                                    MOV BX,[BP+6]
M30MULT ENDP                               MOV DI,[BP+4]
                                                          MOV AX,[BX]
                                                          MULT WORD PTR [DI]
                                                          POP BP
                                                          RET 4
                                                          M30MULT ENDP
用调试程序查看这些例子是如何工作的。
传送参数方法的选择取决于情况和习惯。例如，通过值传送的工作只是对于一些小的值：把数组作为参数传送时就需要通过引用来完成。
同样，高级语言是通过引用来传送参数的。
被调用过程的通常做法是必须使所用的一个或多个寄存器进栈，并且在返回之前使它们出栈。
当程序使用堆栈传送参数时，被调用的过程是在把SP传送到BP之后再使寄存器进栈的：
PUSH BP
MOV BP,SP
PUSHF
PUSHA
...
POPA
POPF
POP BP
第22章会阐述汇编子程序的参数传送问题。
7.10布尔操作
布尔逻辑在电路设计和并行的程序逻辑设计方面是很重要的。布尔逻辑的指令包括AND，OR，XOR，TEST，以及NOT。
它们全都可以用于清除，设置，以及测试各位。布尔操作的格式是
[label:] operation  register/memory，register/memory immediate
第一个操作数引用寄存器或存储器中的一个字节、字或双字，而且是唯一变化的值。
第二个操作数引用寄存器、存储器或立即值，但存储器到存储器的操作是无效的。
该操作使2个引用的操作数的各位相对比，并且相应地设置 CF、OF、PF、SF和ZF标志（AF是未定义的）。
需要记住这些有用的规则：和0相“与”（AND）的位被清除为0，而和1相“或”（OR）的位则被置成1。
1.AND指令。在AND情况下，如果相对比的位是2个1，那么操作将结果置成1，所有其他情况结果均为0：
操作数1：                  0101
AND操作数2：          0011
在操作数1中的结果：0001
对于下面各不相关的例子，假定BL的内容是00111010，CH的内容是10100011：
（1）AND BL,0FH   ;把BL置成00001010
（2）AND BL,00H   ;把BL置成00000000
（3）AND BL,CH   ;把就置成00100010
例（2）提供了一种把寄存器清除为0的方法。
2.OR指令。在OR情况下，如果其中一个（或两个）相对比的位是1，则操作将置结果为1；如果两个位都是0，则结果是0：
操作数1：                 0101
OR操作数2：            0011
在操作数1中的结果：0111
对于以下不相关的例子，假定BL的内容是00111010，CH的内容是10100011：
（1）OR CH,BL   ;CH=10111011
（2）OR CH,CH   ;CH=10100011
虽然使用CMP可能更清楚些，但还是可以为以下目的使用OR：
（1）OR DX,Dx   ;测试DX
        JZ exit   ;如为零则转移
（2）OR DX,DX   ;测试DX
        JS exit   ;如为负则转移
3.XOR指令。在XOR的情况下，如果相对比的位不相同，则操作置结果为1。如果相对比的位是一样的（都是0或都是1），则结果是0。
操作数1：                 0101
XOR操作数2：          0011
在操作数1中的结果：0110
对于以下不相关的例子，假定BL的内容是00111010，CH的内容是10100011：
（1）XOR BL,0FFH   ;BL=11000101
（2）XOR BL,BL   ;BL=00000000
例（2）提供把寄存器清除为零的另一种方法。
4.TEST指令。TEST和AND设置标志的做法相同，但不改变目的操作数中所引用的位。如果任何相对比的位两个都为1，则TEST清除零标志。下面是几个例子：
（1）TEST CX,0FFH   ;测试CX的内容
         JZ exit   ;是零值吗?
（2）TEST BL,00000001B   ;测试BL的内容
         JNZ exit   ;是奇数吗?
（3）TEST CL,11110000B   ;CL的最左边4位中有
         JNZ exit   ;非零位吗?
5.NOT指令。NOT把寄存器或存储器中的字节、字或双字中的各位简单地变反，即0变成1，1变成0。实际上，就是二进制反码。NOT的格式是：
[label:] NOT register/memory
例如，如果BL的内容是00111010，则指令NOT BL把BL变成11000101（其效果正好和先前例子中的XOR BL,0FFH相同），标志位不受影响。
由此可见，NOT和NEG是不同的：NEG实现的是二进制补码，它通过按位求反并加1把一个二进制值从正的变为负的，反过来一样。
通常，NOT用于无符号数据，而NEG则用于带符号数据。
程序：大写与小写字母间的转换
由于多方面的原因，大写字母与小写字母之间要进行转换。例如，你可能有个数据文件，在这个文件里，所有的字母数据都是大写字母。
或者，一个程序允许用户用大写字母或小写字母（如“YES”或“yes”）输入值，然后转换成大写字母，以便于对它进行测试。
大写字母A到Z用ASCII值41H到5AH表示，而小写字母a到z则用61H到7AH表示。唯一的区别在于：对于大写字母位5是0，而对于小写字母位5是1，如下所示：
TITLE A07CASE（COM）Change uppercase to lowercase
.MODEL TINY
.CODE
ORG 100H
BEGIN:JMP A10MAIN
CONAME DB 'LASER-12 SYSTEMS','$'
A10MAIN PROC NEAR
LEA BX,CONAME+1
MOV CX,15
A20:MOV AH,[BX]
CMP AH,41H
JB A30
CMP AH,5AH
JA A30
XOR AH,00100000B
MOV [BX],AH
A30:INC BX
LOOP A20
MOV AH,09H
LEA DX,CONAME
INT 21H
MOV AX,4C00H
INT 21H
A10MAIN ENDP
END BEGIN
测试通过的完整程序如下
.MODEL TINY
.CODE
ORG 100H
BEGIN:JMP A10MAIN
CONAME DB 'LASER-12 SYSTEMS','$'
A10MAIN PROC NEAR
LEA BX,CONAME+1
MOV CX,15
A20:MOV AH,[BX]
CMP AH,41H
JB A30
CMP AH,5AH
JA A30
XOR AH,00100000B
MOV [BX],AH
A30:INC BX
LOOP A20
MOV AH,09H
LEA DX,CONAME
INT 21H
MOV AX,4C00H
INT 21H
A10MAIN ENDP
END BEGIN
图7-4把大写字母改变成小写字母
大写                           小写
字母A：01000001   字母a：01100001
字母2：01011010   字母z：01111010
图7-4的程序从CONAME+1处开始对数据项CONAME的内容进行从大写到小写的转换。该程序用CONAME+1的地址初始化BX，
并且使用该地址从CONAME+1开始向AH传送每个字符。如果该值是在41H和5AH之间，那么XOR指令就把位5取反：
XOR AH,00100000B
除了A到Z外，所有字符都保持不变。然后该程序把改变了的字符送回到CONAME，并为处理下一个字符而使BX加1。
程序循环15次，从CONAME+1开始每个字符循环一次。这种方法的使用使BX起到寻址存储单元的变址寄存器的作用。
为了同样目的，可以使用SI和DI。最后，程序显示改变了的CONAME的内容。
7.11移位
移位指令是计算机逻辑功能的一部分，可以完成以下操作：
引用寄存器或存储器地址。
左移或右移。
一个字节最多移8位，一个字最多移16位，一个双字最多移32位。
逻辑移位（无符号）和算术移位（带符号）。
7.11.1SHR/SAR/SHRD：向右移位
SHR（逻辑右移），SAR（算术右移），以及SHRD（双字右移）操作是在指定的寄存器或存储单元中向右移位。SHR和SAR的格式是：
[label:] SHR/SAR register/memory，CL/immediate
第二个操作数包含移位值，该值是个立即数或是对CL寄存器的引用。对于8088/8086处理器而言，立即数移位值只能是1，更大的值必须放在CL中，
后继的处理器允许立即移位值最大达到31。
每个移出的位放入进位标志中。SHR（逻辑右移）是为逻辑（无符号的）数据提供的，而SAR（算术右移）则是为算术（带符号的）数据提供的：
SHR:0 -> register/memory -> CF
SAR:     符号位->register/memory -> CF
SHRD会在下一节说明。以下相关的指令说明使用SHR将无符号数据移位：
.386
MOV BH,10110111B
SHR BH,1
MOV CL,2
SHR BH,CL
SHR BH,2
第一条SHR把BH的内容向右移一位。现在移出的1驻留在进位标志中，而0填充到BH的左边。
第二条SHR使BH再移两位。进位标志包含相继的1和1，而两个0填充到BH的左边。第三个SHR也是使BH再移了两位。
SAR不同于SHR的一个重要方面是：SAR是用符号位去填充最左边腾空的位。这样，正值和负值都保留它们的符号。以下相关的指令说明使用SAR将带符号的数据移位：
.386
MOV BH,10110111B
SAR BH,1
MOV CL,2
SAR BH,CL
SAR BH,2
对于二等分值，右移是特别有用的，而且在有效的执行速度上要比用除法操作更快。
在SHR和SAR的例子中，第一次右移1位相当于除以2，而第二次和第三次右移两位，每次都相当于除以4。
二等分奇数，比如5和7会分别产生2和3，并把进位标志置成1。在移位操作之后，可以用JC（如进位则转移）测试进位标志的状态（0或1）。
在32位寄存器中右移。考虑一个32位的值，它最左边的16位在DX中，而最右边的16位在AX中，如同DX:AX。下面的例子把DX:AX传送给32位的ECX寄存器，
其中右移操作将该值除以2：
.386
MOV CX,DX
SHL ECX,16
MOV CX,AX
SHR ECX,1
对于80386及其后继机型，SHRD可以用于移16位或32位值。它的格式是：
[label:] SHRD register/memory，register，CL/immediate
第一个操作数接收被移出的位。第二个操作数的长度和第一个操作数相同，它的内容是要被移动的所有位。第三个操作数（CL或立即值）的内容是移位计数值。
下面是几个例子：
SHRD CX,DX,4   ;从DX到CX右移4位
SHRD ECX,EBX,CL   ;从EBX到ECX右移CL中的位数
7.11.2SHL/SAL/SHLD：向左移位
SHL（逻辑左移），SAL（算术左移），以及SHLD（双字左移）操作是在指定的寄存器或存储单元中向左移位。它们的格式是：
[label:] SHL/SAL register/memory，CL/immediate
第二个操作数包含移位值，它是立即值或是对CL寄存器的引用。对于8088/8086处理器，立即值只可以是1，更大的值必须放在CL中，
而其后继的处理器允许立即移位值最大达到31。
每个移出的位进入进位标志。SHL和SAL在操作方面是相同的，而且它们都可以左移逻辑（无符号）和算术（带符号）数据，也就是说，
左移无符号数据和左移带符号数据是没有区别的：
SHL和SAL：CF <- register/memory <- 0
SHLD将在下一节说明。以下相关的指令说明用SHL移位无符号数据：
.386
MOV BH,00000101B
SHL BH,1
MOV CL,2
SHL BH,CL
SHL BH,2
第一条SHL把BH的内容向左移一位。移出的1现在驻留在进位标志中，而把0填入BH的右边，第二条SHL再使BH移两位。进位标志包含的是相继的0和0，
而两个0填入BH的右边。第三条SHL再使BH移两位。
左移总是向右填充0。SHL和SAL的结果是一样的，以至于如果SAL用在前面的例子中，效果相同。
对于值的加倍，左移是特别有用的，而且比用乘法操作在执行时间上明显地要快一些。
在左移操作的例子中，第一次左移1位，相当于乘以2，而第二次和第三次左移两位，相当于乘以4。
移位操作之后，可以使用JC（如进位则转移）指令测试移入进位标志的位。
在32位寄存器中左移。考虑一个32位的值，它的最左边的16位在DX中，而最右边的16位在AX中，如同DX:AX。
下面的例子是把DX:AX传送到ECX，其中的移位操作加倍该值：
MOV CX,DX   ;DX送ECX的低半部分
SHL ECX,16   ;移位到ECX的高半部分
MOV CX,AX   ;AX送ECX的低半部分
SHL ECX,1   ;ECX乘以2
对于80386和后继的型号，SHLD可以用于16位和32位值的左移。它的格式是：
[label:] SHLD register/memory，register，CL/immediate
第一个操作数接收被移出的位。第二个操作数的长度和第一个操作数相同，它的内容是要被移位的所有位。
第三个操作数（CL或立即值）包含移位计数值。下面是几个例子：
SHLD BX,DX,2   ;从DX到BX左移2位
SHLD EAX,EDX,CL   ;从EDX到EAX左移CL中的位数
7.12循环移位
循环指令是计算机逻辑能力的一部分，可以完成以下操作：
引用寄存器或存储器。
循环右移或循环左移。被循环移出的位填充寄存器或存储单元中被腾空的位，还可以复制到进位标志中。
一个字节最多循环8位，一个字最多循环16位，一个双字最多循环32位。
逻辑（无符号）循环移位或算术（带符号）循环移位。
第二个操作数包含循环值，它是常数（立即值）或是对CL寄存器的引用。对于8088/8086处理器，循环的值只能是1，大于1的值必须放在CL中，
后继的处理器允许立即循环值最大达到31。循环指令的格式如下：
[label:] rotate register/memory，CL/immediate
7.12.1ROR/RCR：循环右移
ROR和RCR操作在指定的寄存器或存储单元中向右循环移位。移出的每一位进入进位标志中。
ROR（逻辑循环右移）是为逻辑（无符号的）数据提供的，而RCR（带进位循环右移）则是为算术（带符号的）数据提供的：
ROR   register/memory -> CF
         |                         |
         |---------<-------
RCR   register/memory -> CF
         |                                  |
         |---------<-------------
以下相关的指令说明ROR的用法：
.386
MOV BL,10110111B
ROR BL,1
MOV CL,3
ROR BL,CL
ROR BL,3
第一条ROR把BL最右边的1循环移到最左边已被腾空的位置并进入CF。第二和第三条ROR操作是把最右边的3位循环移到最左边已被腾空的位置并进入CF。
下面的RCR指令在ECX中移位：
.386
RCR ECX,6   ;循环右移双字的6位
由此可见，RCR和ROR的区别是：RCR向右循环移出的每一位首先传送到CF，而CF位传送到左边已被腾空的位置。
7.12.2ROL/RCL：循环左移
ROL和RCL操作是在指定的寄存器和存储单元中向左循环移位。移出的每一位进入进位标志中。
ROL（逻辑循环左移）是为逻辑（无符号的）数据提供的，而RCL（带进位循环左移）则是为算术（带符号的）数据提供的：
ROL   CF<- register/memory 
                   |                         |
                   |--------->-------
RCL   CF<- register/memory 
          |                                  |
          |--------------->-------
以下相关指令说明ROL的用法：
.386
MOV BL,10110111B
ROL BL,1
MOV CL,3
ROL BL,CL
ROL BL,3
第一条ROL把BL最左边的1循环移到最右边已被腾空的位置并进入CF。第二和第三条ROL操作是把最左边的3位循环移到最右边已被腾空的位置并进入CF。
下面的RCL指令在EBX中移位：
RCL EBX,4   ;循环左移双字的4位
由此可见，RCL和ROL的区别是：RCL向左循环移出的每一位首先传送到CF，然后CF位传送到右边已被腾空的位置。
在RCR或RCL操作之后，可以使用JC（如进位则转移）指令测试循环移入CF的位。
7.12.3双字移位与循环
可以使用用于乘除的移位与循环指令进行双字乘以2的操作。考虑一个32位值，它的最左边16位在DX中，而最右边的16位在AX中，形成DX:AX。
把该值“乘”以2的指令是：
SHL AX,1   ;使用左移将
RCL DX,1   ;DX:AX乘以2
SHL操作把AX中的所有位向左移，并且最左边的位移入进位标志。RCL循环左移DX并把CF位插入到最右边已腾空的位。
对于乘以4，用同样的 SHL-RCL对跟着上面的 SHL-RCL对即可。
对于除法，仍然考虑在DX:AX中的32位值。该值除以2的指令是：
SAR DX,1   ;使用右移将
RCR AX,1   ;DX:AX对除以2
SAR操作把DX中的所有位向右移，并且最右边的位移入进位标志。RCR循环右移AX并把CF位插入到最左边已腾空的位。对于除以4，用同样的对跟着SAR-RCR对。
7.13组织一个程序
以下是在编写汇编程序时推荐的步骤：
1.对于程序要解决的问题有清晰的思路。
2.概括地叙述你的思路并计划总的逻辑。
例如，如果问题要完成多字节传送操作，那么开始要定义所要传送的字段。然后规划所用指令的策略：用于初始化的例行程序，用于条件转移的例行程序，
以及使用循环的例行程序。下面说明的是主逻辑，它是许多程序员用于规划一个程序的伪代码：
初始化段寄存器。
调用转移例行程序。
调用循环例行程序。
结束处理。
转移例行程序可以规划如下：
初始化用于计数的寄存器，以及名为JMP1:的地址。
传送名字的一个字符。
为名字的下一个字符而增量。
减量计数：如为非零，则JMP1；如为零，则返问。
循环例行程序可按类似的方法处理。
3.把程序组织成为一些逻辑单元，它们是一个接一个的相关的例行程序。过程大约在25行左右（屏幕的大小），这样的过程比更长的过程容易调试一些。
4.用其他程序作为指导，试图记住所有技术资料并且想编写一个“别出心裁”的程序，通常会导致更多程序缺陷的产生。
5.使用注释清楚地说明正在执行的算术和比较操作在做什么，以及很少用的指令是做什么的（后者的例子是LOOPNE：当不相等时循环或是直到不相等时循环）。
通常的做法是，为每个过程提供一个标题注释来说明它的用途，输入和输出，以及改变的寄存器。
6.为了便于键入程序，可以用已保存的框架程序，你可以把它复制到一个新命名的文件中。
7.开发一些测试模块，尽管它们当中许多是简单的空过程。这种实践有助于故障的早期定位与识别。
8.使用数字数据进行最终测试，这些数据应该是有效值，包括零和负的情况。然后再用一些非常的数据试一下，看一看该程序如何处理它。
在本课本中，余下的程序会大量地使用JMP，LOOP，条件转移，CALL，以及调用过程。
有了前面已叙述过的汇编语言基础知识，你现在处于更为先进和实际的程序设计位置上。
7.14要点
短地址是通过偏移值到达的，被限制在-128到127个字节的距离内。
近地址通过偏移值到达并且距离被限制在同一段内的-32768到32767个字节。
在另一个段中的远地址，是通过段地址和偏移值到达的。
指令标号（比如L10：）需要冒号指明它是一个近标号。
条件转移和LOOP指令的标号必须是短的。操作数产生1个字节的目标码：01H到7FH，所覆盖的范围从十进制的+1到+127，而FFH到80H所覆盖的范围从-1到-128。
当使用LOOP时，用一个正的非零值初始化CX，因为LOOP使CX减1，然后检查它是否为零。
当一条指令设置标志时，标志保存这一设置直到另一条指令改变它为止。
选择合适的条件转移指令，取决于操作处理的是无符号还是带符号数据。
使用CALL调用一个过程，在过程结束时应包含为返回而存在的RET/RETN。
被调用的过程可以调用其他过程，并且如果遵循习惯，RET可使堆栈中的正确地址出栈。
使用左移加倍一个值，用右移减半一个值。一定要为无符号和带符号数据选择合适的移位和循环指令。
7.15习题
7-1.解释这些地址类型的含义：（a）短的，（b）近的，（c）远的。
汇编程序支持三种类型的地址，是根据它们与当前地址的距离加以区别的：
（1）短地址，对距离的限制是-128（80H）到127（7FH）个字节。
（2）近地址，对距离的限制是-32768（8000H）到32767（7FFFH）个字节，在同一个段内。
（3）远地址，在同一段内，距离可超过32K，或在另一个段里。
转移操作可到达1个字节偏移值的短地址，还可到达一个或两个字节偏移值的近地址。远地址则可到达段地址和偏移值所指定的地方。
7-2.（a）近的JMP，LOOP和条件转移的最大字节数是多少？（b）产生这一限制的机器码操作数的特点是什么？
下面的表列出了JMP，条件转移，LOOP，以及CALL操作在距离方面的规则。
短                                             近                                             远
指令         -128到127         -32768到32767                           超过32K或在另一段
                同一段               同一段
JMP         是                      是                                                 是
Jnnn        是                      是（80386+）                              否
LOOP      是                      否                                                  否
CALL       不适用                是                                                  是
JMP，Jnnn（条件转移），或LOOP指令的操作数是另一条指令的标号。
一条指令的标号，如L10：，是用冒号来结束的，这赋予它近的属性，即此标号是在同一代码段的一个过程之内的。
7-3.JMP指令从偏移单元02D4H开始。根据以下JMP操作数的目标码：（a）2AH，（b）6EH，（c）B8H，确定传送的偏移地址。
02D4H+002AH=02FEH
02D4H+006EH=0342H
B8H=-48H=-72
02D4-48H=028CH
7-4.说明以下每个LOOP操作循环多少次：
（a）MOV CX,1（b）L5:MOV CX,10
     L5:                         ...
         LOOP L5           LOOP L5
1次，无限循环
（c）MOV CX,0（d）MOV CX,10
     L5:                    L5:
         ...                       INC CX
         LOOP L5           LOOP L5
65536次，无限循环
F(1)=1，F(2)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 3）
7-5.编写计算Fibonacci序列：1，1，2，3，5，8，13，…（除了序列中最先2个数之外，其余每个数都是前面2个数之和）的程序。
使用LOOP并设置12次迭代的限制。汇编，连接，并使用DEBUG跟踪整个例行程序。
.MODEL SMALL
.STACK 512
.DATA
DW 1
DW 1
FIBONACCI_ARRAY DW 16 DUP (0)
.CODE
MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV CX,12
LEA BX,FIBONACCI_ARRAY
S1:MOV AX,DS:[BX-4]
ADD AX,DS:[BX-2]
MOV DS:[BX],AX
ADD BX,2
LOOP S1
MOV AX,4C00H
INT 21H
MAIN ENDP
END MAIN
76.编写程序，把在BYTE_TBL中定义的每个值相加并把和存放在BYTE_TOTAL中。
（提示：使用间接寻址，一条ADD，INC BX，以及LOOP。）
BYTE_TBL DB 5,6,4,9,7
BYTE_TOTAL DB 0
.MODEL SMALL
.STACK 512
.DATA
BYTE_TBL DB 5,6,4,9,7
BYTE_TOTAL DB 0
.CODE
MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV CX,5
MOV AX,0
LEA BX,BYTE_TBL
S1:ADD AL,DS:[BX]
INC BX
LOOP S1
MOV BYTE_TOTAL,AL
MOV AX,4C00H
INT 21H
MAIN ENDP
END MAIN
BYTE_TOTAL=5+6+4+9+7=31
7-7.编写程序，把 CHAR_STRING中所包含的大写字母转换成小写字母。逐次把每个字符取到寄存器中，加上20H，并把它重新存放到该串中。
使用间接寻址和LOOP指令。（提示：使用间接寻址并为逐次取字符而使BX增1。）
CHAR_STRING DB 'ABCDEFGHIJ'
.MODEL SMALL
.STACK 512
.DATA
CHAR_STRING DB 'ABCDEFGHIJ'
.CODE
MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV CX,10
MOV AX,0
LEA BX,CHAR_STRING
S1:MOV AL,DS:[BX]
ADD AL,20H
MOV DS:[BX],AL
INC BX
LOOP S1
MOV AX,4C00H
INT 21H
MAIN ENDP
END MAIN
7-8.假定CX和DX含有无符号数据，AX和BX含有带符号数据。为以下问题确定CMP（这是必要的）和条件转移指令：
（a）AX等于或小于BX吗？
CMP AX,BX
JLE Label
（b）CX等于或小于DX吗？
CMP CX,DX
JBE Label
（c）AX大于BX吗？
CMP AX,BX
JG Label
（d）CX大于DX吗？
CMP CX,DX
JA Label
（e）DX含有零吗？
判断DX为0
OR DX,DX
JZ Label
判断DX含有0
MOV DI,DX
XOR DI,0FFFFH
OR DI,DI
JNZ Label
（f）有溢出吗？
判断DX有溢出
CMP DX,0
JO Label
31          19   18   17   16  15  14  13 12   11   10  9  8    7   6   5  4   3  2   1  0
                    AC  VM  RF  0   NT  IOPL    OF  DF IF TF  SF ZF  0 AF 0  PF     CF
7-9.在以下情况下，受影响的标志是什么？它们包含的内容是什么？
（a）按单步方式处理。（b）串数据的传送是从右到左。（c）结果是负的。（d）结果是零。（e）发生了溢出。
TF=1
DF=1
SF=1
ZF=1
OF=1
1.运算结果标志
（1）进位标志CF（Carry Flag）
进位标志CF主要用于反映运算是否产生进位或借位。
如果运算结果的最高位（字操作时的第15位或字节操作时的第7位）产生一个进位或借位，则CF被置1，否则CF被清0。
在进行多字节数的加减运算时，要使用到该标志；在比较无符号数的大小时，要使用到该标志。
移位指令也把操作数的最高位或最低位移入CF。移位指令和CF的配合，可实现操作数之间的位传送。
CF也常作为子程序的出口参数之一。
（2）零标志ZF（Zero Flag）
零标志ZF用于反映运算结果是否为0。如果运算结果为0，则ZF被置1，否则ZF被清0。
在判断运算结果是否为0时，要使用到该标志。
（3）符号标志SF（Sign Flag）
符号标志SF用于反映运算结果的符号位。SF与运算结果的最高位相同，如果运算结果的最高位为1，则SF被置1，否则SF被清0。
SF反映了运算结果的符号。如果运算结果为正，则SF被清0，否则SF被置1。
（4）溢出标志OF（Overflow Flag）
溢出标志OF用于反映有符号数加减运算是否引起溢出。如运算结果超出了8位或16位有符号数的表示范围，
即在字节运算时大于127或小于-128，在字运算时大于32767或小于-32768，称为溢出。如果溢出，则OF被置1，否则OF被清0。
（5）奇偶标志PF（Parity Flag）
奇偶标志PF用于反映运算结果中“1”的个数。如果“1”的个数为偶数，则PF被置1，否则PF被清0。
利用PF可进行奇偶校验检查，或产生奇偶效验位。
（6）辅助进位标志AF（Auxiliary Carry Flag）
在字节操作时，如发生低半字节向高半字节进位或借位；在字操作时，如发生低字节向高字节进位或借位，
则辅助进位标志AF被置1，否则AF被清0。
2.状态控制标志
状态控制标志控制处理器的操作，要通过专门的指令才能使状态控制标志发生变化。
（1）方向标志DF（Direction Flag）
方向标志决定着串操作指令执行时有关指针寄存器调整方向。
当DF为1时，串操作指令按减方式改变有关的存储器指针值；当DF为0时，串操作指令按加方式改变有关的存储器指针值。
（2）中断允许标志IF（Interrupt-enable Flag）
中断允许标志决定着CPU是否响应外部可屏蔽中断请求。
当IF为1时，CPU能够响应外部的可屏蔽中断请求；当IF为0时，则不响应外部的可屏蔽中断请求。
（3）追踪标志TF（Trap Flag）
当追踪标志TF被置1后，CPU进入单步方式。所谓单步方式是指在一条指令执行后，产生一个单步中断。
这主要用于程序的调试。
7-10.编写并测试一个程序，该程序包含下面一组指令。确定目的寄存器中的值和在标志寄存器OF，ZF，SF及CF中的结果：
（a）MOV AL,0FFH（b）MOV BL,24H
         ADD AL,1                SUB BL,BL
（c）MOV CL,10101010B (d）MOV DL,01111100B
         ADD CL,01010101B        ADD DL,01110011B
.MODEL SMALL
.STACK 512
.DATA
.CODE
MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV AL,0FFH
ADD AL,1         AL=00H；CF=1 ZF=1 PF=1 AF=1 SF=0 OF=0
MOV BL,24H
SUB BL,BL        BL=00H；CF=0 ZF=1 PF=1 AF=0 SF=0 OF=0
MOV CL,10101010B
ADD CL,01010101B         CL=FFH；CF=0 ZF=0 PF=1 AF=0 SF=1 OF=0
MOV DL,01111100B
ADD DL,01110011B         DL=EFH；CF=0 ZF=0 PF=0 AF=0 SF=1 OF=1
MOV AX,4C00H
INT 21H
MAIN ENDP
END MAIN
7-11.参考图7-3并说明如果过程B10没有包含RET，程序的执行结果如何。
A10MAIN->B10->C10
                   B10<-C10
                  如果过程B10没有包含RET，则从过程C10返回到CALL C10后的下一条指令，也就是过程C10中的第一条指令RET，从过程B10返回后，程序正常结束。
.MODEL SMALL
.STACK 64
.DATA
.CODE
A10MAIN PROC FAR
CALL B10
MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10 PROC NEAR
CALL C10
RET
B10 ENDP
C10 PROC NEAR
RET
C10 ENDP
END A10MAIN
7-12.说明所定义的PROC操作数用NEAR和用FAR之间的区别。
PROC操作数用NEAR表示过程是近过程，用FAR表示过程是远过程。CALL和RET对于近过程和远过程，产生不同的机器指令。
近调用与返回。在同一段内调用（CALL）一个过程是近调用，其实现如下：
通过进栈操作，SP减2（一个字）并把IP（含有跟在CALL之后指令的偏移值）传送进栈。
把被调用过程的偏移地址放入IP中（而且要填满处理器的预取指令队列）。
RET从一个近过程返回，基本上是CALL的相反步骤：
老的IP值从堆栈出栈，回送到IP（而且要填满处理器的预取指令队列）。
SP加2。
现在CS:IP指向调用过程中跟在原先的CALL后的指令，并且在那里恢复执行。
远调用与返回。远调用（CALL）去调用标明FAR的过程，这个过程可能在另外一个代码段里。
远调用使CS和IP都进栈，并且RET（或RETF）使它们都出栈。
7-13.指出使正在执行的程序进入过程的3种方法。
[label:] CALL procedure-name
[label:] RET [n]
[label:] CALL FAR PTR procedure-name
[label:] RETF [n]
[label:] JMP 标号
[label:] JMP FAR PTR 标号
7-14.汇编并连接图7-3中的程序。先按Small存储模型，再按Medium存储模型。比较所产生的目标码和连接映像的区别。
模型                  代码段数量                  数据段数量
SMALL              1<=64KB                    1<=64KB
Medium          任意数量，任意大小      1<=64KB
Compact          1<=64KB                  任意数量，任意大小
Large              任意数量，任意大小    任意数量，任意大小
Huge              任意数量，任意大小     任意数量，任意大小
Huge 模型和Large模型是一样的，但可以包含诸如大于64K数组的变量。
按Small存储模型
Microsoft (R) Macro Assembler Version 6.15.8803		    05/03/20 17:03:18
d:\t492.asm						     Page 1 - 1


				.MODEL SMALL
				.STACK 64
 0000				.DATA
 0000				.CODE
 0000				A10MAIN PROC FAR
 0000  E8 0005			CALL B10
 0003  B8 4C00			MOV AX,4C00H
 0006  CD 21			INT 21H
 0008				A10MAIN ENDP
 0008				B10 PROC NEAR
 0008  E8 0001			CALL C10
 000B  C3			RET
 000C				B10 ENDP
 000C				C10 PROC NEAR
 000C  C3			RET
 000D				C10 ENDP
				END A10MAIN
Microsoft (R) Macro Assembler Version 6.15.8803		    05/03/20 17:03:18
d:\t492.asm						     Symbols 2 - 1




Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

DGROUP . . . . . . . . . . . . .	GROUP
_DATA  . . . . . . . . . . . . .	16 Bit	 0000	  Word	  Public  'DATA'	
STACK  . . . . . . . . . . . . .	16 Bit	 0040	  Para	  Stack	  'STACK'	 
_TEXT  . . . . . . . . . . . . .	16 Bit	 000D	  Word	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

A10MAIN  . . . . . . . . . . . .	P Far	 0000	  _TEXT	Length= 0008 Public
B10  . . . . . . . . . . . . . .	P Near	 0008	  _TEXT	Length= 0004 Public
C10  . . . . . . . . . . . . . .	P Near	 000C	  _TEXT	Length= 0001 Public


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 0000h	 
@DataSize  . . . . . . . . . . .	Number	 0000h	 
@Interface . . . . . . . . . . .	Number	 0000h	 
@Model . . . . . . . . . . . . .	Number	 0002h	 
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 DGROUP
@fardata?  . . . . . . . . . . .	Text   	 FAR_BSS
@fardata . . . . . . . . . . . .	Text   	 FAR_DATA
@stack . . . . . . . . . . . . .	Text   	 DGROUP

	   0 Warnings
	   0 Errors
按Medium存储模型
Microsoft (R) Macro Assembler Version 6.15.8803		    05/03/20 16:56:14
d:\t491.asm						     Page 1 - 1


				.MODEL MEDIUM
				.STACK 64
 0000				.DATA
 0000				.CODE
 0000				A10MAIN PROC FAR
 0000  E8 0005			CALL B10
 0003  B8 4C00			MOV AX,4C00H
 0006  CD 21			INT 21H
 0008				A10MAIN ENDP
 0008				B10 PROC NEAR
 0008  E8 0001			CALL C10
 000B  C3			RET
 000C				B10 ENDP
 000C				C10 PROC NEAR
 000C  C3			RET
 000D				C10 ENDP
				END A10MAIN
Microsoft (R) Macro Assembler Version 6.15.8803		    05/03/20 16:56:14
d:\t491.asm						     Symbols 2 - 1




Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

DGROUP . . . . . . . . . . . . .	GROUP
_DATA  . . . . . . . . . . . . .	16 Bit	 0000	  Word	  Public  'DATA'	
STACK  . . . . . . . . . . . . .	16 Bit	 0040	  Para	  Stack	  'STACK'	 
T491_TEXT  . . . . . . . . . . .	16 Bit	 000D	  Word	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

A10MAIN  . . . . . . . . . . . .	P Far	 0000	  T491_TEXT	Length= 0008 Public
B10  . . . . . . . . . . . . . .	P Near	 0008	  T491_TEXT	Length= 0004 Public
C10  . . . . . . . . . . . . . .	P Near	 000C	  T491_TEXT	Length= 0001 Public


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 0001h	 
@DataSize  . . . . . . . . . . .	Number	 0000h	 
@Interface . . . . . . . . . . .	Number	 0000h	 
@Model . . . . . . . . . . . . .	Number	 0004h	 
@code  . . . . . . . . . . . . .	Text   	 T491_TEXT
@data  . . . . . . . . . . . . .	Text   	 DGROUP
@fardata?  . . . . . . . . . . .	Text   	 FAR_BSS
@fardata . . . . . . . . . . . .	Text   	 FAR_DATA
@stack . . . . . . . . . . . . .	Text   	 DGROUP

	   0 Warnings
	   0 Errors
7-15.在一个程序中，D10调用E10，E10调用F10，F10调用G10。作为这些调用的结果，现在堆栈中包含多少地址？
D10->E10->F10->G10
如果调用都是近调用，则堆栈中的内容如下：
F10中CALL G10后的下一条指令IP   <-SP
E10中CALL F10后的下一条指令IP
D10中CALL E10后的下一条指令IP
7-16.假定DL内容是01111001，名为BOOT_AMT的项目内容是11100011。为以下不相关操作确定DL中的结果：
（a）AND DL,BOOTAMT
DL=01100001
（b）OR DL,BOOT_AMT
DL=11111011
（c）XOR DL,BOOT_AMT
DL=10011010
（d）AND DL,00000000B
DL=00000000
（e）XOR DL,11111111B
DL=10000110
7-17.按以下要求修改图7-4的程序：定义CONAME的内容为所有都是小写字母，并且编写指令把所有小写字母转换成大写字母。
.MODEL TINY
.CODE
ORG 100H
BEGIN:JMP A10MAIN
CONAME DB 'laser-12 systems','$'
A10MAIN PROC NEAR
LEA BX,CONAME
MOV CX,16
A20:MOV AH,[BX]
CMP AH,61H
JB A30
CMP AH,7AH
JA A30
XOR AH,00100000B
MOV [BX],AH
A30:INC BX
LOOP A20
MOV AH,09H
LEA DX,CONAME
INT 21H
MOV AX,4C00H
INT 21H
A10MAIN ENDP
END BEGIN
7-18.假定DX的内容是二进制的10111001 10111001。在以下不相关的指令执行之后，确定DX的二进制内容：
（a）SHL DL,1
10111001 01110010
（b）SHL DX,2
11100110 11100100
（c）SHR DX,1
01011100 11011100
（d）SAR DX,2
11101110 01101110
（e）SAL DH,3
11001000 10111001
（f）ROR DX,3
00110111 00110111
（g）ROR DL,3
10111001 00110111
7-19.使用传送（mov）、移位（shift）和加法（add）指令，用24H初始化DX并把它乘以10。
DX*10=DX*8+DX*2
24H=0010 0100
MOV DX,0024H
MOV AX,DX
SHL AX,1
MOV DX,AX
SHL AX,1
SHL AX,1
ADD DX,AX
7-20.在标题为“循环移位”一节的末尾有个例子是DX:AX乘以2。修改该子程序为
（a）乘以4
SHL AX,1
RCL DX,1
SHL AX,1
RCL DX,1
（b）除以4
SAR DX,1
RCR AX,1
SAR DX,1
RCR AX,1
（c）把DX:AX:BX中的48位值乘以2。
SHL BX,1
RCL AX,1
RCL DX,1
考虑一个32位值，它的最左边16位在DX中，而最右边的16位在AX中，形成DX:AX。
把该值“乘”以2的指令是：
SHL AX,1   ;使用左移将
RCL DX,1   ;DX:AX乘以2
对于乘以4，用同样的 SHL-RCL对跟着上面的 SHL-RCL对即可。
对于除法，仍然考虑在DX:AX中的32位值。该值除以2的指令是：
SAR DX,1   ;使用右移将
RCR AX,1   ;DX:AX对除以2
对于除以4，用同样的对跟着SAR-RCR对。
7-21.把DX:CX的内容传送到EBX并使用移位实现EBX乘以4。
MOV BX,DX
SHL EBX,16
MOV BX,CX
SHL EBX,1
SHL EBX,1
第三部分视频与键盘操作
第8章视频和键盘处理入门
8.1引言
8.2屏幕特征
8.3设置光标
8.4清屏
8.5屏幕显示的INT21H功能09H
8.6键盘输入的NT 21H功能0AH
8.7屏幕显示的NT 21H功能02H
8.8文件代号
8.9屏幕显示的NT21H功能40H
8.10键盘输入的NT21H功能3FH
8.11要点
8.12习题
目的：介绍屏幕显示信息和接收键盘输入的中断请求。
8.1引言
本章之前的程序都是在数据区定义数据项，或者在指令操作数字段给定立即数。然而，大多数程序都要求从外部设备输入源数据，
例如键盘、磁盘、鼠标或调制解调器，并且提供有效的格式输出到屏幕、打印机或磁盘上。本章包含了屏幕显示信息和接收键盘输入的基本中断请求。
INT（中断）指令能处理大部分的输入输出请求。本章包含的两个中断是屏幕处理功能INT 10H以及屏幕显示输出和接收键盘输入的INT 21H功能。
这些功能要求一个特定的动作，在AH寄存器中插入一个功能值，以识别要运行的中断服务程序的类型。
低级BIOS操作，如INT 10H直接转移控制到BIOS。然而，为了便于一些更复杂的操作，INT 21H提供了先把控制转移给操作系统的中断服务。
例如，键盘输入可包括一定数量的输入字符以及对最大数量的检测。INT 21H操作完成很多这种附加的高级处理，然后自动地把控制转移给BIOS，
由BIOS来处理操作的低级部分。
作为惯例，这本书所提到的0DH即是键盘输入以及屏幕和打印机的回车符。
本章介绍的INT 10H和INT 21H操作有：
INT 10H功能                  INT 21H功能
02H 设置光标                 02H 显示字符
06H 屏幕滚动                 09H 显示串
                                      0AH 键盘输入
                                      3FH 读文件
                                      40H 写文件
INT 10H AH= 2 置光标位置
BH=显示页号 DH=行号 DL=列号 左上角坐标是（0，0）
INT 10H AH=6 向上滚屏 仅影响当前显示页
AL=上滚行数 当滚动行数为0时表示清除整个窗口
BH=填空白行的属性
CH=窗口左上角行号
CL=窗口左上角列号
DH=窗口右下角行号
DL=窗口右下角列号
带回显键盘输入（1号功能调用）功能：从标准输入设备上读一字符，并将该字符回显在标准输出设备上。
通常情况下，标准输入设备就是键盘，标准输出设备就是屏幕。如果键盘无字符可读，则一直等待到有字符可读（即按键）。
入口参数：无。
出口参数：AL=读到字符的代码（ASCII码）。
说明：如果读到的字符是Ctrl+C或Ctrl+Break，则结束程序。
不带回显键盘输入（8号功能调用）除读到的输入字符不在屏幕上显示外，同1号功能调用。
直接键盘输入（7号功能调用）功能：从标准输入上读一字符。通常情况下，标准输入就是键盘。
如果键盘无字符可读，则一直等待到有字符可读（即按键）。
入口参数：无。
出口参数：AL=读到字符的代码。
说明：（1）不检查读到的字符是否是Ctrl+C或Ctrl+Break。
（2）不回显读到的字符。
显示输出（2号功能调用）功能：向标准输出设备写一字符。通常情况下，标准输出设备就是屏幕。
入口参数：DL=要输出的字符（ASCII码）。
出口参数：无。
说明：在显示输出时检查是否按Ctrl+C或Ctrl+Break键，如是则结束程序。
直接控制台输入输出（6号功能调用）功能：直接控制台输入输出。
通常情况下，控制台输入就是键盘输入，控制台输出就是屏幕输出。
入口参数：若DL=0FFH，表示输入；否则表示输出，DL=输出字符代码。
出口参数：输入时，ZF=1表示无字符可读；ZF=0表示读到字符，AL=输入字符代码；输出时，无。
说明：（1）在输入时，如无字符可读，并不等待。
（2）不检查Ctrl+C或Ctrl+Break键。
（3）在读到字符时也不回显。
（4）在输入时，如果AL=0，表示用户曾按过一个扩展键，在下一次调用该功能时返回扩展键的扫描码。
（5）在输出时，不解释制表符等特殊控制符。
显示字符串（9号功能调用）功能：在标准输出上显示一个字符串。通常情况下，标准输出就是屏幕。
入口参数：DS:DX=需要输出字符串的首地址，字符串以字符'$'为结束标志。
出口参数：无。
说明：在显示输出时检查是否按Ctrl+C或Ctrl+Break键，如是则结束程序。
输入字符串（0AH号功能调用）
会把当前输入的内容回显在标准输出设备上
功能：从标准输入上读一个字符串。通常情况下，标准输入就是键盘。
入口参数：DS:DX=缓冲区首地址。
出口参数：接收到的输入字符串在缓冲区中。
说明：（1）缓冲区第一字节置为缓冲区最大容量，可认为是入口参数；
缓冲区第二字节存放实际读入的字符数（不包括回车符），可认为是出口参数的一部分；第三字节开始存放接受的字符串。
（2）字符串以回车键结束，回车符是接受到的字符串的最后一个字符。也就是0DH 回车，不包含0AH 换行
（3）如果输入的字符数超过缓冲区所能容纳的最大字符数，则随后的输入字符被丢弃并且响铃，直到遇回车键为止。
（4）如果在输入时按Ctrl+C或Ctrl+Break键，则结束程序。
取键盘输入状态（0BH号功能调用）功能：判别在标准输入设备上是否有字符可读。
入口参数：无。
出口参数：AL=0，表示无字符可读；AL=0FFH，表示有字符可读。
说明：检查是否按Ctrl+C或Ctrl+Break键，如遇这种键，则程序结束。
清除输入缓冲区后再输入（0CH号功能调用）
功能：清除输入缓冲区，然后再执行某个输入功能。
入口参数：AL=清除输入缓冲区后要执行的功能号。
出口参数：决定于清除输入缓冲区后执行的功能。
说明：清除缓冲区后执行的功能应是01H、06H、07H、08H或0AH，如不是这样，则不输入。
例如：若AL=0，则在清除输入缓冲区后，没有进一步的处理。
建立文件（3CH号功能调用）
功能：建立文件（创建新的，或刷新老的文件）。
入口参数：DS:DX=代表文件名的字符串的首地址。
CX=文件属性。
出口参数：CF=0表示成功，AX=文件号（柄）。
CF=1表示失败，AX=错误代码。
说明：（1）可指定的文件属性如下：
00H普通
01H只读
02H隐含
04H系统
（2）创建文件成功后，文件长度定为0。
打开文件（3DH号功能调用）
功能：打开文件。
入口参数：DS:DX=代表文件名的字符串的首地址。
AL=存取方式。
出口参数：CF=0表示成功，AX=文件号（柄）。
CF=1表示失败，AX=错误代码。
说明：（1）存取方式规定如下：
00H只读方式
01H只写方式
02H读写方式
（2）打开文件成功后，文件指针定位于开始的第一个字节（偏移0）处。
读文件（3FH号功能调用）
功能：读文件。
入口参数：BX=文件号（柄）。
CX=读入字节数。
DS:DX=准备存放所读数据的缓冲区的首地址。
出口参数：CF=0表示成功，AX=实际读到的字节数。
CF=1表示失败，AX=错误代码。
说明：（1）通常情况下，实际读到的字节数与欲读入的字节数相同，除非不够读。
（2）缓冲区应保证能容下所读到的数据。
（3）文件应以读或读写方式打开。
（4）读文件后，文件指针将定位到读出字节之后的第一个字节处。
写文件（40H号功能调用）
功能：写文件。
入口参数：BX=文件号（柄）；
CX=写盘字节数；
DS:DX=存放写数据的缓冲区的首地址。
出口参数：CF=0表示成功，AX=实际写出的字节数。
CF=1表示失败，AX=错误代码。
说明：（1）通常情况下，实际写出的字节数与欲写盘的字节数相同，除非磁盘满。
（2）文件应以写或读写方式打开。
（3）写文件后，文件指针将定位到写入字节之后的第一个字节处。
关闭文件（3EH号功能调用）
功能：关闭文件。
入口参数：BX=文件号（柄）。
出口参数：CF=0表示成功。
CF=1表示失败。
说明：文件号是打开该文件时系统所给定的文件号。
移动文件读写指针（42H号功能调用）
功能：移动文件（读写）指针。
入口参数：BX=文件号（柄）。
CX:DX=移动位移量。
AL=移动方式。
出口参数：CF=0表示成功，此时，DX:AX=移动后文件指针值。
CF=1表示失败，此时，（AX）=1表示无效的移动方式，（AX）=6表示无效的文件号。
说明：（1）文件指针值（双字）是以文件首字节为0计算的。
（2）移动方式和表示的意义如下：
00H 移动后文件指针值=0（文件头）+移动位移量
01H =当前文件指针值+移动位移量
02H =文件长（文件尾）+移动位移量
（3）在第一种移动方式中，移动位移量总是正的。
（4）在后两种移动方式中，移动位移量可正可负。
（5）该子功能不考虑文件指针是否超出文件范围。
删除文件（41H号功能调用）
功能：删除文件。
入口参数：DS:DX=代表文件名的字符串首地址。
出口参数：CF=0表示成功；
CF=1表示失败，AX=错误代码。
说明：只能删除一个普通文件。
第9章和第10章将包含更高级的屏幕和键盘处理特性。
8.2屏幕特征
一个典型的视频显示器有25行（从0到24）和80列（从0到79）。行和列为设置光标提供了一个可寻址的网格。以下是光标位置的一些例子：
                  （行，列）
左上角        （0，0）
右上角        （0，79）
屏幕中心    （12，39、40）
左下角        （24，0）
右下角        （24，79）
系统为视频显示区在内存里提供了一块空间或缓冲区。它在BIOS中的位置是不同的，这取决于系统当前的操作方式，比如，文本或图形方式以及彩色或单色方式。
在文本方式下，视频显示区需要4K字节内存，其中2K用于存储字符，2K用于存储每个字符的属性，如反相显示、闪烁、高亮度和下划线等。
视频显示区还提供屏幕“页”，编号从0到7。这些页及其属性会在第10章中详细介绍，在本章我们假定显示页为默认的0页。
处理屏幕显示的中断功能直接将数据传输到视频显示区。从技术上讲，程序可以直接传输数据到视频显示区。
但是，存储器地址对不同的显示模式是不同的，而且也不能保证地址总是不变，所以直接往显示区写数据虽然比较快，但可能会有些危险。
通常的做法是使用适当的INT 10H和INT 21H中断操作，这些中断是知道视频显示区的位置的。
8.3设置光标
设置光标是一个基本的中断请求，因为光标的位置决定了下一个字符将在哪星显示或输入。屏幕处理的BIOS操作取决于INT 10H以及AH中的功能码。
例如，INT 10H的02H功能是告诉BIOS设置光标，并将要求的页号装入BH（页号通常为0），行号装入DH，列号装入DL。其他寄存器的内容不重要。
下面的例子将光标设置在第8行，第15列：
MOV AH,02H   ;请求设置光标
MOV BH,0   ;页号0
MOV DH,8   ;第8行
MOV DL,15   ;第15列
INT 10H   ;调用中断服务
也可以用一条带十六进制立即数的MOV指令在DX中设置行和列：
MOV DX,080FH   ;第8行，15列
8.4清屏
INT 10H的06H功能处理屏幕清除或滚动。清除全屏或部分屏幕显示，可在全屏范围内的任意位置开始和任意位置结束。设置以下寄存器：
AH=06H   功能号
AL=滚动的行数，或00H全屏为空白
BH=属性值（颜色、闪烁等）
CX=起始行：列
DX=结束行：列
CX和DX共同定义了滚动的屏幕区（或窗口），AL指明上卷的行数。如果要清除整个屏幕，就指定CX中的起始行：列为00：00H，DX中的结束行：列为18：4FH。
下例中的属性71H设置整个屏幕为白色背景（属性为7）和蓝色前景（属性为1）：
MOV AX,0600H   ;AH=06H（滚动），AL=00H（全屏空白）
MOV BH,71H   ;白色背景（7），蓝色前景（1）
MOV CX,0000H   ;左上角行：列
MOV DX,184FH   ;右下角行：列
INT 10H   ;调用中断服务
例如，要在一个从05行、00列到12行、79列的屏幕窗口中滚动，就在CX中装入0500H，在DX中装入0C4FH。
注意不要错误地设置右下角屏幕位置大于184FH。下一章将会更详细地讲述滚屏。
程序经常要显示信息，以要求用户输入数据或做一些动作。我们首先练习一些编写小程序的简单方法，随后再练习一些包含文件处理的方法。
8.5屏幕显示的INT 21H功能09H
简单的INT 21H的09H显示功能对初学者来说是很方便的，它要求在数据区定义一个显示串，紧接着用一个美元符（$或24H）作为定界符来结束显示操作。
这种方法的缺点是你无法用这个功能在屏幕上显示$字符。下面举例说明：
CUST_MSG DB 'Customer name?','$'   ;显示串
你可以像上面的例子一样紧接着显示串加上美元符，也可以在串内加美元符，如'Customer name?$'，或在下一行加美元符，如DB '$'。
在AH中设置09H功能，用LEA指令在DX中装入显示串地址，然后发出INT 21H指令：
MOV AH,09H   ;请求显示
LEA DX,CUST_MSG   ;装入提示符地址
INT 21H   ;调用中断服务
INT操作从左到右显示字符，美元定界符（$）作为数据结束标志。这个操作不改变寄存器的内容。如果一个显示串超过了屏幕最右边的列，可自动在下一行继续显示，
并在必要的时候滚动屏幕。如果在串尾省略了$符，该操作将不断显示连续存储空间中的字符直到遇到一个$―如果存在一个$的话。
显示ASCII字符
256个ASCII字符中的大多数是通过符号来表示的，这些符号能在视频屏幕上显示，而对于某些值，比如00H和FFH没有可显示的符号，所以显现为空白，
虽然实际上的ASCII空白符是20H。
图8-1的程序显示全部ASCII字符。程序A10MAIN调用3个过程：
TITLE A08DISAS (COM) Display ASCII character set
.MODEL TINY
.CODE
ORG 100H
BEGIN:JMP SHORT A10MAIN
ASCHAR DB 00H,'$'
A10MAIN PROC NEAR
CALL B10SCREEN
CALL C10CURSOR
CALL D10DISPLY
MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10SCREEN PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,0600H
MOV BH,07H
MOV CX,0000H
MOV DX,184FH
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
B10SCREEN ENDP
C10CURSOR PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AH,02H
MOV BH,00H
MOV DX,0800H
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
C10CURSOR ENDP
D10DISPLY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV CX,256
LEA DX,ASCHAR
D20:CMP BYTE PTR ASCHAR,08H
JB D30
CMP BYTE PTR ASCHAR,0DH
JBE D40
D30:MOV AH,09H
INT 21H
D40:INC BYTE PTR ASCHAR
LOOP D20
POP DX
POP CX
POP BX
POP AX
RET
D10DISPLY ENDP
END BEGIN
图8-1显示ASCII字符集
B10SCREEN 调用INT 10H的功能06H清屏。
C10CURSOR 调用INT 10H的功能02H把光标初始为08：00H。
D10DISPLY 调用INT 21H的功能09H显示ASCHAR的内容，显示内容先初始化为00H，然后连续增1直到FFH显示每个ASCII字符。
显示的第一行以一个空白（00H）、两个“笑脸”（01H和02H）和一个红心（03H）、红方块（04H）、梅花（05H）、黑桃（06H）开始，
ASCII07H使扬声器发声。程序跳过从08H到0DH的所有字符（08H将产生一个退格，09H产生一个TAB键，0AH产生的换行以及0DH产生的“回车”使显示从下一行开始）。
当然，在功能09H中符号（24H）是根本不显示出来的（在第9章，你可以调用BIOS服务以特定的符号来显示这些特殊字符）。
乐符为0EH，从80H到FFH是扩展ASCII字符。
注意，显示退格符、Tab符、换行和回车符是执行这些操作的常用方法。建议：复制先前的程序，然后编译、连接并转换成一个.COM文件执行。
8.6键盘输入的INT 21H功能0AH
从键盘接收数据的INT 21H的0AH功能特别强。键入字符的输入区需要一个包含指定区域的参数表以便进行INT操作（相当于高级语言里的记录或结构）。
首先，该操作需要知道输入字符的最大数量。其目的是防止用户从键盘输入过多的字符，如果超过最大数，这个操作使扬声器发出声音并且不再接收字符。
第二步，把实际输入的字节数传送到参数表。参数表包含这些元素：
1.第一个语句以LABEL BYTE的格式提供参数表的名字。LABEL是带有BYTE类型属性的指令，它简单地使参数表按字节边界来定位，因为这是最常用的定位，
汇编程序不必预置它的地址计数器。LABEL用来给参数表分配一个名字。
2.参数表的第一个字节限制输入字符的最大数。这个数最小是0，最大是FFH即255，因为这是一个1字节的字段。
可以对最大字符数作出决定，最大字符数是根据用户输入的数据类型而定的。
3.此操作的第二个字节是以二进制形式存储实际输入的字符数。
4.从第三个字节开始的区域，从左到右存放键入的字符。
下面的例子是为一个键盘输入区定义的参数表：
PARA_LIST LABEL BYTE   ;参数表开始
MAX_LEN DB 20   ;最大输入字符个数
ACT_LEN DB ?   ;实际输入字符数
KB_DATA DB 20 DUP (20H)   ;从键盘输入的字符
在参数表中，LABEL指令告诉汇编程序定位一个字节边界并且赋地址名PARA_LIST。
因为LABEL不占用空间，PARA_LIST和MAX_LEN指向同一个内存地址。
MAX_LEN定义了键盘字符的最大数（20），ACT_LEN为操作填入实际输入的字符数提供了空间，KB_DATA为字符保留了20个字节空间。
对这些字段你可以使用任何一个有效的名字。
为了请求键盘输入，要在AH中设置功能0AH，在DX中装入参数表地址（在上例中是PARA_LIST），并发出INT 21H指令：
MOV AH,0AH   ;请求键盘输入
LEA DX,PARA_LIST   ;装入参数表地址
INT 21H   ;调用中断服务
INT操作等待用户输入字符并检测输入字符数是否超过最大数20。
此操作回送每个字符到屏幕上光标所在的位置，并右移光标。用户按<Enter>键作为键盘输入结束的信号。
这个操作也传送回车符（0DH）到输入区KB_DATA，但不把它记入实际长度。若键入一个名字，如Wilson+<Enter>，参数表显示如下：
20         6         w   i   l   s   o   n   #
14H      06H                                 0DH
该操作把输入名字的长度06H送入参数表的第二个字节，即例子中命名的ACT_LEN。
回车字符（0DH）在KB_DATA+6中（这里#号就表示这个字符，因为0DH没有可打印的符号）。
给出的最大字符长度20包括了0DH，用户最多只能敲入19个字符。
此操作能接收退格并作出退格动作，但是不把它加入字符数。除了退格，此操作不接收多于最大字符数的字符。
在前面的例子中，如果一名用户键入20个字符却没有按回车，该操作就会使扬声器发出“嘀”的声音，在此刻它只接收回车符。
虽然这个操作对输入数据是很有用的，但它无法使用扩展的功能键，如F1、Home、PgUp和Arrows。
如果能够预料用户会按动它们中的一个，请使用INT 16H或INT 21H的功能01H，这将在第10章中详细讲述。
8.6.1程序：接收并显示名字
图8-2的程序要求用户键入一个名字，然后在屏幕中央显示这个名字，并使扬声器发声。
.MODEL SMALL
.STACK 512
.DATA
PARLIST LABEL BYTE
MAXNLEN DB 20
ACTULEN DB ?
KBNAME DB 28 DUP (20H)
PROMPT DB 'Name?','$'
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
CALL Q10CLEAR
A20:MOV DX,0000
CALL Q20CURSOR
CALL B10INPUT
CALL Q10CLEAR
CMP BYTE PTR ACTULEN,00H
JE A30
CALL C10CENTER
CALL D10DISPLY
JMP A20
A30:MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10INPUT PROC NEAR
PUSH AX
PUSH DX
MOV AH,09H
LEA DX,PROMPT
INY 21H
MOV AH,0AH
LEA DX,PARLIST
INT 21H
POP DX
POP AX
RET
B10INPUT ENDP
C10CENTER PROC NEAR
PUSH BX
PUSH DX
MOV BX,0
MOV BL,ACTULEN
MOV KBNAME[BX],07H
MOV KBNAME[BX+1],'$'
MOV DL,ACTULEN
SHR DL,1
NEG DL
ADD DL,40
MOV DH,12
CALL Q20CURSOR
POP DX
POP BX
RET
C10CENTER ENDP
D10DISPLY PROC NEAR
PUSH AX
PUSH DX
MOV AH,09H
LEA DX,KBNAME
INT 21H
POP DX
POP AX
RET
D10DISPLY ENDP
Q10CLEAR PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,0600H
MOV BH,07H
MOV CX,0000H
MOV DX,184FH
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
Q10CLEAR ENDP
Q20CURSOR PROC NEAR
PUSH AX
PUSH BX
MOV AH,02H
MOV BH,00H
INT 10H
POP BX
POP AX
RET
Q20CURSOR ENDP
END A10MAIN
如果用户敲入Dana Wilson，程序执行如下：
1.长度11除2：11/2=5，忽略余数。
2.从40中减去这个值：40-5=35。
在C10CENTER中，SHR指令把长度值11向右移一位，相当于长度除以2：字节00001011成为00000101（即5）。
NEG指令把符号变反，使+5（05H）变成-5（FBH）。ADD加40，在DL中得到起始位置的列号35。因为光标设置在12行、35列，名字就显示在第12行、第35列开始的屏幕位置上。
注意C10CENTER在紧接着名字的输入区插入响铃符（07H）：
MOVZX BX,ACTULEN   ;用07H替换0DH
MOV KBNAME[BX],07H
MOVZX设置BX为已键入的字符数。在MOV指令中，[BX]作为一个变址寄存器用于扩大寻址范围。
MOV指令把BX中的长度与KBNAME的地址组合，并把07H传送到计算出来的地址中去。因为长度为11，指令在名字后面的KBNAME+11单元插入07H（替代回车符）。
C10CENTER中的指令
MOV KBNAME[BX+1],'$'   ;设置显示定界符
在07H之后插入一个'$'，这样INT 21H的功能09H就能显示名字并使扬声器发声。
过程C10CENTER、D10DISPLY 和Q20CURSOR 通过注释来说明寄存器的用途。
实际上这些过程应当PUSH和POP所用寄存器的内容。
8.6.2附加的编程练习
这一节介绍几个很有用的技术。
1.用回车键作为回答信号。图8-2的程序连续地接收和显示名字，直到用户按动了<回车>才作为对一个提示的回答。
INT 21H的功能0AH接收按键，并在参数表中插入长度00H，如下所示：
20         0         #
14H      00H    0DH
如果是串的长度为0，程序就确定输入结束，程序A10MAIN通过指令CMP BYTE PTR ACTULEN,00H表明了这个判断过程。
2.清除回车符。可能为不同的目的输入字符，例如打一份报告，存入一个表格，或写入磁盘。对这些用途，可能必须用空格（20H）来取代回车符，
无论它在KBNAME的什么位置。含有输入数据实际长度的字段ACTULEN提供了回车符的相对位置。
例如，若ACTULEN含有11，那么回车符就在KBNAME+11的位置。可以传送这个长度给BX，以标定KBNAME中地址，如下所示：
MOVZX BX,ACTULEN
MOV KBNAME[BX],20H
MOVZX指令设置BX长度为11。MOV指令把一个空格符（20H）传送给第一个操作数指定的地址：KBNAME的地址加上BX的内容，即KBNAME+11。
3.清除键盘输入区。键入的每个字符都会取代输入区中先前的内容，并且保留在那里直到其他的字符取代了它们。我们来看下面的连续输入：
输入参数表（十六进制制
1.Monroe 14H 06H M o n r o e 0DH
2.Franklin 14H 08H F r a n k l i n 0DH
3.Adams 14H 05H A d a m s 0DH i n 0DH
第一个名字Monroe只需要6个字节。第二个名字Franklin全部替代了较短的名字Monroe。但是因为第三个名字Adams比Franklin短，
它只替代了Frank，回车符代替了l，剩余的两个字母（“in”）仍然保留在Adams之后。可以预先清除KBNAME再提示输入名字，如下所示：
MOV CX,20
MOV SI,0
L10:MOV BYTE PTR KBNAME[SI],20H
INC SI
LOOP L10
可以用DI或BX代替SI。如果程序传送两个空白符组成的一个字，则只需要10次循环。
然而因为KBNAME已经定义为DB（字节），若使用WORD和PTR（pointer）操作数，则不必考虑它的长度，如下所示：
MOV CX,10
LEA SI,KBNAME
L10:MOV WORD PTR [SI],2020H
ADD SI,2
LOOP L10
在L10的MOV指令可解释为：“传送一个空白字给SI指向的存储器单元”。
这个例子使用LEA指令来初始化要清除的KBNAME，并对L10的MOV指令使用了不同的方法，不能编写如下的指令：
MOV WORD PTR [KBNAME],2020H   ;第一个操作数是非法的
清除输入区解决了短名字之后仍保留先前数据的问题。为了更快地处理，也可以只清除紧接着输入名字右面的区域。
8.6.3用于屏幕显示的控制字符
使显示更加有效的一种方法是利用回车、换行和Tab控制符，可以用它们的ASCII码或十六进制值来编码，如下所示：
控制字符         ASCII码         16进制数         对光标的影响
回车                  13                  0DH             重新回到屏幕左边的位置
换行                  10                  0AH             前进到下一行
Tab                   09                  09H             前进到下一个Tab位置停止
在显示输出或接收键盘输入的任何时候，都可使用控制字符来处理光标。
下例在显示一个字符串REPTITLE的内容后，紧接其后的回车（13）和换行（10）设置光标到下一行。
利用EQU命令重新定义控制符能增强程序的可读性：
CR EQU 13   ;或EQU 0DH
LF EQU 10   ;或EQU 0AH
TAB EQU 09   ;或EQU 09H
REPTITLE DB TAB,'Annual Rainfall Statistics',CR,LF,'$'
MOV AH,09H
LEA DX,REPTITLE
INT 21H
8.7屏幕显示的INT 21H功能02H
INT 21H的功能02H用于显示单字符。在DL中装入在当前光标位置上要显示的字符，然后请求INT 21H。Tab、回车和换行的动作照常，该操作自动前移光标。指令如下：
MOV AH,02H
MOV DL,CHAR
INT 21H
下面的例子说明了如何利用这个中断服务来显示一串字符。要显示的字符串定义在CO_TITLE。该例把CO_TITLE的地址装入DI，其长度装入CX。
为指向每一个连续的字符，循环中包括了DI增1（通过INC指令）。为了控制要显示的字符数，还包括了CX减1（通过LOOP指令）。下面是指令序列：
CO_TITLE DB 'Intertech Corp.',0DH,0AH
...
MOV AH,02H
MOV CX,17
LEA DI,CO_TITLE
L10:MOV DL,[DI]
INT 21H
INC DI
LOOP L10
...
8.8文件代号
本节主要讲解有关屏幕和键盘操作的文件代号的用法。文件代号是对应于特定设备的一个简单的数字，以下的标准文件代号是事先设置好的，不需要再定义：
文件代号         设备
00                  输入设备，通常是键盘（CON），可以重定向
01                  输出设备，通常是显示器（CON），可以重定向
02                  错误输出设备，一般为显示器（CON），不能重定向
03                  辅助设备（AUX）
04                  打印设备（LPT1或PRN）
如上所示，键盘的文件代号是00，屏幕显示的文件代号是01。磁盘设备的文件代号（包含在17章）必须由程序来设置。
也可以利用这些中断服务把输入输出重定向到其他设备，重定向的特性我们这里没有涉及到。
读文件（3FH号功能调用）
功能：读文件。
入口参数：BX=文件号（柄）。
CX=读入字节数。
DS:DX=准备存放所读数据的缓冲区的首地址。
出口参数：CF=0表示成功，AX=实际读到的字节数。
CF=1表示失败，AX=错误代码。
说明：（1）通常情况下，实际读到的字节数与欲读入的字节数相同，除非不够读。
（2）缓冲区应保证能容下所读到的数据。
（3）文件应以读或读写方式打开。
（4）读文件后，文件指针将定位到读出字节之后的第一个字节处。
写文件（40H号功能调用）
功能：写文件。
入口参数：BX=文件号（柄）；
CX=写盘字节数；
DS:DX=存放写数据的缓冲区的首地址。
出口参数：CF=0表示成功，AX=实际写出的字节数。
CF=1表示失败，AX=错误代码。
说明：（1）通常情况下，实际写出的字节数与欲写盘的字节数相同，除非磁盘满。
（2）文件应以写或读写方式打开。
（3）写文件后，文件指针将定位到写入字节之后的第一个字节处。
8.9屏幕显示的INT 21H功能40H
INT21H的功能40H利用文件代号来处理显示操作。为了请求这个中断服务，要设置以下寄存器：
AH=40H
CX=要显示的字符数
BX=文件代号01
DX=显示区的地址
若INT操作成功，则把写入的字节数传送给AX，并清除进位标志（可以测试出来）。
若INT操作不成功，则置进位标志为1，并在AX中返回一个错误代码：
05H=拒绝存取（无效的或未连接的设备），或06H=无效文件代号。
由于AX中既可能包含字节的长度又可能包含错误代码，所以确定出错条件的唯一办法就是测试进位标志。
通常情况下不会发生显示出错：
JC error_routine   ;测试显示错误
该操作对控制字符07H（嘀嘀声）、08H（退格）、0AH（换行）和0DH（回车）产生的动作就像INT 21H的功能09H一样。下面的指令说明40H的功能：
PROMPT DB ‘Part number?',0DH,0AH
MOV AH,40H
MOV BX,01H
MOV CX,14
LEA DX,PROMPT
INT 21H
练习：使用功能40H在屏幕上显示
让我们利用DEBUG来检验使用文件代号显示名字的内部作用。装载DEBUG，当出现提示符时，敲入A 100，并在偏移地址100H
（记住DEBUG认定输入的数字都是十六进制格式的）开始键入下面的汇编语句（不要键入最左边的数字）：
100   MOV AH,40
102   MOV BX,01
105   MOV CX,xx（以16进制插入名字的长度）
108   MOV DX,10F
10B   INT 21H
10D   JMP 100
10F   DB 'x----x'（插入你的名字）
指令设置AH以请求一次显示中断，并在DX中设置偏移地址10FH―DB定义的单元中含有你的名字。
键入指令后，按<Enter>。如果要反汇编程序，使用U命令（U 100,10F），要跟踪执行，按下R，然后反复使用T命令。
当运行到INT 21，用P（Proceed）命令执行中断，直到JMP指令，此时在屏幕上应该显示出你的名字了。
8.10键盘输入的INT 21H功能 3FH
INT 21H的功能3FH利用文件代号来请求键盘输入，虽然这是有些笨拙的操作。装载下面的寄存器：
AX=3FH
CX=要接收的最大字符数
BX=文件代号00
DX=输入字符区的地址
若INT操作成功，则清除进位标志（这可以测试出来），并设置AX为输入的字符数。
发生不成功的INT操作可能是因为使用了无效的文件代号；此时该操作置进位标志为1，并在AX中插入一个错误代码：
05H=拒绝存取（对一个无效设备或未连接的设备），或06H=无效文件代号。
因为AX中既可能是字符的长度又可能是错误代码，所以确定出错条件的唯一办法就是测试进位标志，虽然键盘出错的机会很少。
类似INT 21H的功能0AH，功能3FH也能对退格起作用，但是对扩展功能键如F1、Home和PageUp却不起作用，因此极大地限制了其有效性。
以下的指令说明了功能3FH的用法：
KBINPUT DB 20 DUP (20H)
MOV AH,3FH
MOV BX,00H
MOV CX,20
LEA DX,KBINFUT
INT 21H
INT操作等待你输入字符，但不幸的是它不能检测字符数是否超过了CX中的最大数（本例中是20）。
按下回车键（0DH）表示输入结束。例如，输入字符“Intertech Corp”，则传送下列字符给KBINPUT：
Intertech Corp 0DH 0AH
输入字符后面紧接着回车符（0DH）和换行符（0AH），回车是你键入的，而换行不是。
由于这个特点，你定义的最大字符数和输入区的长度应提供这两个额外字符的空间。如果键入的字符少于最大数，在输入字符后面的存储器单元仍然保留先前的内容。
若INT操作成功，则清除进位标志并将AX设置为传送的字符数。在前面的例子中，这个数是14+2（回车和换行符）。
因此，程序可以利用AX的值确定实际键入的字符数。虽然这个返回值对键入YES和NO时所起的作用不大，但是对键入像姓名这样的不定长度字符时，返回值是很有用的。
如果键入的字符数超过了CX中的最大数，操作实际上接受了全部字符。再看下面一种情况，CX中的最大字符数是08，而用户键入字符“PC Exchange”。
该操作将前8个字符“PC Excha”放入输入区，后面没有回车和换行，AX设置为长度8。现在我们看到，执行下一条INT操作没有直接从键盘接受名字，
因为在缓冲区仍保留有先前的字符串。于是“nge”及紧跟着的回车和换行传送到输入区，并将AX置为05。若操作都“正常”则清除进位标志：
第1个INT:         PC Excha AX=08
第2个INT:         nge,0DH,0AH AX=05
程序可以知道用户是否键入了“有效的”字符数：（a）AX中的返回值小于CX中的数，或（b）AX中的返回值等于CX中的数，并且输入区最后两个字符是0DH和0AH。
如果这两个条件都不符合，则必须发出另外的INT指令来接收其余的字符。这样做之后，你可能会感到在CX中指定最大长度是多么的重要。
练习：利用功能3FH键入数据
在这里的DEBUG练习中可以观察到使用INT 21H的功能3FH键入数据的效果。程序允许键入最多12个字符，包括一个回车符和一个换行符。
装入DEBUG，出现提示符时，键入A 100，从100H单元开始输入下面的指令（不要输入左边的数字）：
100   MOV AH,3F
102   MOV BX,00
105   MOV CX,0C
108   MOV DX,10F
10B   INT 21
10D   JMP 100
10F   DB 20 20 20 20 20 20 20 20 20 20 20 20
输入完指令再按回车键。程序设置AH和BX以请求键盘输入，并在CX中插入最大字符长度。
程序还在DX中设置偏移地址10FH―这是DB的地址，输入的字符就从这里开始存放。
试发出U命令（U 100,10F）反汇编程序。用R命令和多次的T命令跟踪4条MOV指令的执行。
在地址10BH，用P命令来执行中断，该中断操作等待你键入字符及紧接着的回车。
检查AX和进位标志的内容，并用D DS:10F命令显示存储器中的输入字符。可以连续循环执行这个过程。
8.11要点
处理屏幕显示，传输数据到视频显示区的中断。
INT 10H指令是传输控制给BIOS的显示操作。常用的两个操作是功能02H（设置光标）和06H（滚动屏幕）。
当使用INT 21H的功能09H来显示时，紧接着显示区要定义一个定界符（$）。丢失定界符会在屏幕上引起意想不到的结果。
INT 21H键盘输入功能0AH请求一个参数表。第一个字节存放最大字符数，第二个字节填入实际字符数。
文件代号是一个对应特定设备的数。对于文件代号从00到04这些数是预置的，但是其余的文件代号可以由程序来设置。
用INT 21H功能40H来显示，在BX中置文件代号01。
用INT 21H功能3FH来接收键盘输入，在BX中置文件代号00。该操作在输入区的键入字符之后插入回车和换行符，但是不检验字符是否超出了指定的最大数。
8.12习题
8-1.在一个80列的屏幕上，下列位置的16进制地址是什么？（a）屏幕底部最右边的位置，（b）屏幕顶部最左边的位置。
(24，79），(0，0）
184FH，0000H
8-2.写指令把光标设置在第12行，第24列。
MOV AH,02H
MOV BH,0
MOV DH,12
MOV DL,24
INT 10H
8-3.写指令将从第08行，第0列开始的位置清屏，使用彩色属性71H。
MOV AH,06H
MOV AL,0
MOV BH,71H
MOV CH,8
MOV CL,0
MOV DH,24
MOV DL,79
INT 10H
8-4.定义数据项并用INT 21H的功能09H来显示一个信息"What is the date(mm/dd/yy)?"，并在显示信息后发出嘀声。
STR_MESSAGE DB 'What is the date(mm/dd/yy)?',07H,'$'
...
MOV AH,09H
LEA DX,STR_MESSAGE
INT 21H
8-5.定义数据项，并用INT 21H的功能0AH按照8-4题的格式来接收键盘输入。
PARLIST LABEL BYTE
MAXNLEN DB 20
ACTULEN DB ?
KBDATE DB 28 DUP (20H)
...
MOV AH,0AH
LEA DX,PARLIST
INT 21H
8-6.某节的标题“Clearing the Input Area”定义为KBNAME，说明如何将这个键盘输入区清除为空（blank）。再把本例修改为只清除紧接着输入名字右边的字符。
KBNAME DB 'Clearing the Input Area'
...
MOV CX,23
MOV SI,0
L10:MOV BYTE PTR KBNAME[SI],20H
INC SI
LOOP L10
...
MOV BX,0
MOV BL,ACTULEN
MOV KBNAME[BX],20H
INC BX
MOV CX,23
SUB CX,BX
L10:MOV BYTE PTR KBNAME[BX],20H
INC BX
LOOP L10
...
8-7.按下列要求修改图8-2的程序：
（a）允许名字的最大字符数为25；（b）取代12行，把光标设置在第7行；（c）取代清屏，只清除0到7行，操作中使用属性16H；
（d）在每一个子过程的开始入栈保存所用的寄存器，在退出之前把它们出栈。汇编、连接并测试程序。
.MODEL SMALL
.STACK 512
.DATA
PARLIST LABEL BYTE
MAXNLEN DB 25
ACTULEN DB ?
KBNAME DB 28 DUP (20H)
PROMPT DB 'Name:','$'
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
CALL Q10CLEAR
A20:MOV DX,0000
CALL Q20CURSOR
CALL B10INPUT
CALL Q10CLEAR
CMP BYTE PTR ACTULEN,00H
JE A30
CALL C10CENTER
CALL D10DISPLY
JMP A20
A30:MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10INPUT PROC NEAR
PUSH AX
PUSH DX
MOV AH,09H
LEA DX,PROMPT
INT 21H
MOV AH,0AH
LEA DX,PARLIST
INT 21H
POP DX
POP AX
RET
B10INPUT ENDP
C10CENTER PROC NEAR
PUSH BX
PUSH DX
MOV BX,0
MOV BL,ACTULEN
MOV KBNAME[BX],07H
MOV KBNAME[BX+1],'$'
MOV DL,ACTULEN
SHR DL,1
NEG DL
ADD DL,40
MOV DH,7
CALL Q20CURSOR
POP DX
POP BX
RET
C10CENTER ENDP
D10DISPLY PROC NEAR
PUSH AX
PUSH DX
MOV AH,09H
LEA DX,KBNAME
INT 21H
POP DX
POP AX
RET
D10DISPLY ENDP
Q10CLEAR PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,0600H
MOV BH,16H
MOV CX,0000H
MOV DX,074FH
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
Q10CLEAR ENDP
Q20CURSOR PROC NEAR
PUSH AX
PUSH BX
MOV AH,02H
MOV BH,00H
INT 10H
POP BX
POP AX
RET
Q20CURSOR ENDP
END A10MAIN
8-8.写出下列设备的文件代号：（a）打印机，（b）键盘输入，（c）常用屏幕显示。
04，00，01
文件代号         设备
00                  输入设备，通常是键盘（CON），可以重定向
01                  输出设备，通常是显示器（CON），可以重定向
02                  错误输出设备，一般为显示器（CON），不能重定向
03                  辅助设备（AUX）
04                  打印设备（LPT1或PRN）
8-9.定义数据项，并使用INT 21H的功能40H来显示信息“What is the date(mm/dd/yy)?”紧接着信息的是回车，换行和“嘀”声。
STR_MESSAGE DB 'What is the date(mm/dd/yy)?',0DH,0AH,07H
...
MOV AH,40H
MOV BX,01H
MOV CX,30
LEA DX,STR_MESSAGE
INT 21H
8-10.在一个程序中，INT 21H的功能3FH已经设置了进位标志，并在AX中返回06H，引起这个错误的原因可能是什么？
06H=无效文件代号
8-11.定义数据项，并利用INT 21H功能3FH，按照8-9题的格式接收键盘输入。
KBDATE DB 28 DUP (20H)
MOV AH,3FH
MOV BX,00H
MOV CX,20
LEA DX,KBDATE
INT 21H
8-12.修改8-7题，使用INT 21H的功能3FH和40H来输入和显示。汇编、连接并测试程序。
.MODEL SMALL
.STACK 512
.DATA
PARLIST LABEL BYTE
MAXNLEN DB 25
ACTULEN DB ?
KBNAME DB 28 DUP (20H)
PROMPT DB 'Name:','$'
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
CALL Q10CLEAR
A20:MOV DX,0000
CALL Q20CURSOR
CALL B10INPUT
CALL Q10CLEAR
CMP BYTE PTR ACTULEN,02H
JE A30
CALL C10CENTER
CALL D10DISPLY
JMP A20
A30:MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10INPUT PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AH,09H
LEA DX,PROMPT
INT 21H
MOV AH,3FH
MOV BX,00H
MOV CX,25
LEA DX,KBNAME
INT 21H
MOV ACTULEN,AL
POP DX
POP CX
POP BX
POP AX
RET
B10INPUT ENDP
C10CENTER PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV BX,0
MOV BL,ACTULEN
MOV KBNAME[BX],07H
MOV DL,ACTULEN
SHR DL,1
NEG DL
ADD DL,40
MOV DH,7
CALL Q20CURSOR
POP DX
POP CX
POP BX
POP AX
RET
C10CENTER ENDP
D10DISPLY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AH,40H
MOV BX,01H
MOV CX,0
MOV CL,ACTULEN
INC CX
LEA DX,KBNAME
INT 21H
POP DX
POP CX
POP BX
POP AX
RET
D10DISPLY ENDP
Q10CLEAR PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,0600H
MOV BH,16H
MOV CX,0000H
MOV DX,074FH
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
Q10CLEAR ENDP
Q20CURSOR PROC NEAR
PUSH AX
PUSH BX
MOV AH,02H
MOV BH,00H
INT 10H
POP BX
POP AX
RET
Q20CURSOR ENDP
END A10MAIN
第9章视频系统
9.1引言
9.2视频系统的构成
9.3视频方式
9.4属性
9.5BIOS INT 10H 操作
9.6使用图形方式
9.7直接视频显示
9.8用于方框和菜单的ASCII字符
9.9要点
9.10习题
目的：介绍卷屏，反相显示，设置显示方式和属性以及使用图形等屏幕处理的高级特性。
9.1引言
本章将在第8章的基础上进一步介绍有关视频操作的内容。
第一节描述了视频系统的组成：监视器，视频显示区和视频控制器。
第二节解释说明了一些视频特性，如显示方式、属性以及页等。最主要的一节是关于BIOS视频操作INT 10H的，其中描述了很多功能，
包括设置显示方式、设置光标、滚动屏幕、显示字符和设置属性等。
最后一小节介绍了一些用于显示图形的功能，以及直接视频显示和设计菜单框。
本章包括了以下BIOS INT 10H的中断服务：
00H   设置显示方式                  0BH   设置彩色调色板
01H   设置光标大小                  0CH   写像素
02H   设置光标位置                  0DH   读像素
03H   返回光标状态                  0EH   打字方式写
05H   选择活动页                     0FH   取当前显示方式
06H   上卷屏幕                        10H   存取调色板寄存器
07H   下卷屏幕                        11H   存取字符发生器
08H   读字符/属性                   12H   选择可选例程
09H   显示字符/属性                13H   显示字符串
0AH   显示字符                        1BH   返回视频信息

INT 10H 00H: Set Video Mode
INT 10H 01H: Set Cursor Shape & Size
INT 10H 02H: Set Cursor Position
INT 10H 03H: Query Cursor Position and Size
INT 10H 04H: Query Light Pen
INT 10H 05H: Select Video Page
INT 10H 06H: Scroll Up / Clear Screen Rectangle
INT 10H 07H: Scroll Down / Clear Screen Rectangle
INT 10H 08H: Read Character/Attribute at Cursor Location
INT 10H 09H: Write Character/Attribute to Cursor Location
INT 10H 0aH: Write Character to Cursor Location
INT 10H 0bH: Select Graphics Palette or Text Border Color
INT 10H 0cH: Write Graphics Pixel
INT 10H 0dH: Read Graphics Pixel
INT 10H 0eH: Write Character as TTY
INT 10H 0fH: Query Current Video Info
INT 10H 13H: AT/EGA/VGA String Display Functions
INT 10H 1300H: Display String
INT 10H 1301H: Display String and Update Cursor
INT 10H 1302H: Display Character/Attribute Cells
INT 10H 1303H: Display Char/Attr Cells & Update Cursor

INT 10H 1aH: Set or Query Display Combination Code
INT 10H 1bH: Get VGA Functionality and State Info
9.2视频系统的构成
流行的（或曾经流行的）视频适配器包括MDA（monochrome display adapter）、CGA（color graphics adapter）、EGA（enhanced graphics adapter）和VGA
（video graphics array）。VGA及其超VGA的后继型号取代了CGA和EGA视频适配器。因为VGA系统的流行，本书只对它的特性进行说明。
视频系统的基本组成是监视器、视频显示区、视频BIOS以及视频控制器。其他集成的装置包括字符发生器、模式控制器、视频信号发生器和属性解码器。
                                                          视频控制器-------------
                                                                  |                          |水平和垂直定时
来自程序的数据->视频显示区-数据->字符发生器-字符->视频信号发生器<-定时寻址-模式控制器
                                                                                           ^
                                             -属性->属性解码器------------|
图9-1表明了它们之间的关系。
1.监视器。监视器的屏幕由一组称作光栅的细密的水平线组成。每条线包含上百个称作像素的点，它由3个荧光点组成，每个点对应一个三原色：红、绿和蓝。
3个电子束激活像素的3种颜色。电子束从屏幕的左上角开始连续地从左到右扫描每一行，改变电子束的强度来调整像素的亮度和颜色。
红、绿、蓝及其亮度的组合，形成了各种颜色和阴影。
2.视频显示区。程序中的数据―对文本方式是字符码，对图形方式是像素值―传送到RAM中的视频显示区（或缓冲区），既可以通过INT操作，
也可以通过直接传送的方法。
数据最终在屏幕上显示出来之前，要经过相当复杂的转换。视频区的起始地址取决于视频适配器的类型和所选择的显示方式。
处理屏幕显示的中断直接将数据传输到这个区域。下面是几个主要的视频方式所对应的起始段地址：
A000:[0]   用于文本方式下的字形描述器以及高分辨率图形显示方式0DH到13H。
B000:[0]   单色文本方式07H。
B800:[0]   文本和图形方式00H到06H。
视频电路连续不断地扫描视频区中的数据，因此屏幕也不断地刷新。视频区中的数据可以是ASCII文本（包括字母数字的）或图形格式。
在文本方式下，视频区的每个字符需要两个字节：一个字节是字符，紧接着是一个决定字符颜色和亮度的属性字节。
在图形方式下，视频区包含有一组决定每个像素颜色的位。
视频显示区允许按页存储数据。一页存储一个整屏的数据，页编号从0到7。页号0是默认的，文本方式是从视频显示区的B800[0]开始。
1页从B900[0]开始，2页在BA00[0]，3页在BB00[0]，以此类推。
尽管一次只能显示一页，但你也可以对存储器中的任何页格式化。在文本方式下，要在屏靠上显示的每个字符需要两个存储器字节―一个字节存放字符，
第二个字节存放它的属性。以这种方法存储，对一个80列和25行的满页字符需要80×25×2=4000字节。
实际分配给每一页的存储器单元数是4K字节，即4096字节，这样一个存储块在紧接着每页后面都有96个字节未用。
3.视频控制器。视频控制器产生水平和垂直定时信号。它也保留一个指示视频显示区当前位置的计数器并对它增量。
该计数器告诉视频电路当前要存取、解码并送到监视器的数据。控制器必须与定时信号同步传输数据。
紧接着水平扫描之后，控制器发出一个垂直同步信号，使监视器执行从屏幕顶部左角开始的垂直扫描。
执行过水平和垂直扫描后，在屏幕的四周形成了一个边界（过扫描区）。视频控制器的其他任务有处理光标的大小和位置，并选择要显示的页。
控制器也有一定数量的寄存器，程序可对这些寄存器的内容进行读写。
如图9-1所示的ASCII字符（或字母数字）发生器将来自视频显示区的ASCII代码转换成组成字符的点阵，
属性解码器将来自视频显示区的属性字节转化为决定字符颜色的信号。
4.视频BIOS。视频BIOS对视频适配器来说起到一个接口的作用，它包含像设置光标和显示字符这样的例程。视频RAM BIOS支持两个视频数据区：
（1）40:[49H]包含当前显示方式，列数以及视频显示区大小等数据。
（2）40:[84H]包含行数和字符高度等数据。
40:0049   1  Current active video mode.  See Video Modes and INT 10H.
40:0084   1  EGA text rows-1  (maximum valid row value)
关于视频BIOS的详细说明请见第24章。VGA适配器的视频 ROM BIOS例程起始于C000:[0]。
AH  Std BIOS Services
00H set video mode
01H set cursor size/shape
02H set cursor position
03H query cursor position & size
04H read light pen
05H select active display page
06H scroll window up (or cls)
07H scroll window down (or cls)
08H read character/attribute
09H write character/attribute
0aH write character
0bH select color palette/border
0cH write graphics pixel dot
0dH read graphics pixel dot
0eH write character as TTY
0fH read video mode

AL  Type     Format   Cell  Colors        Adapter  Addr  Monitor
0  text     40x25     8x8* 16/8 (shades) CGA,EGA  b800  Composite
1  text     40x25     8x8* 16/8          CGA,EGA  b800  Comp,RGB,Enh
2  text     80x25     8x8* 16/8 (shades) CGA,EGA  b800  Composite
3  text     80x25     8x8* 16/8          CGA,EGA  b800  Comp,RGB,Enh
4  graphic  320x200   8x8  4             CGA,EGA  b800  Comp,RGB,Enh
5  graphic  320x200   8x8  4 (shades)    CGA,EGA  b800  Composite
6  graphic  640x200   8x8  2             CGA,EGA  b800  Comp,RGB,Enh
7  text     80x25    9x14* 3 (b/w/bold)  MDA,EGA  b000  TTL Mono
8,9,0aH  PCjr modes
0bH,0cH  (reserved; internal to EGA BIOS)
0dH graphic  320x200   8x8  16            EGA,VGA  a000  Enh,Anlg
0eH graphic  640x200   8x8  16            EGA,VGA  a000  Enh,Anlg
0fH graphic  640x350  8x14  3 (b/w/bold)  EGA,VGA  a000  Enh,Anlg,Mono
10H graphic  640x350  8x14  4 or 16       EGA,VGA  a000  Enh,Anlg
11H graphic  640x480  8x16  2             VGA      a000  Anlg
12H graphic  640x480  8x16  16            VGA      a000  Anlg
13H graphic  640x480  8x16  256           VGA      a000  Anlg
9.3视频方式
视频方式确定文本或图形、彩色或单色、屏幕分辨率以及颜色数等显示要素，BIOS INT10H的功能00H就是当前执行程序用来初始化显示方式，
或在文本方式和图形方式之间进行切换。设置显示方式也能清屏。例如，显示方式3提供的是25行×80列、彩色文本方式和720×400点阵的屏幕分辨率。
也可以使用INT 10H的功能0FH，在AL中返回当前显示方式。
这两种功能在后面都会讲到。
文本（或字母数字）方式用于显示256个ASCII字符。除彩色方式不支持下划线属性外，彩色和单色的处理方式相类似。
下表列出的是通用文本方式，左边是显示方式的编号：
显示方式         行×列         类型         显示区         页         分辨率         颜色数
00                  25×40         彩色         B800         0-7         360×400         16
01                  25×40         彩色         B800         0-7         360×400         16
02                  25×80         彩色         B800         0-3         720×400         16
03                  25×80         彩色         B800         0-3         720×400         16
07                  25×80         单色         B000         0            720×400             
文本方式00和01：40列格式；虽然最初是为CGA设计的，但是在VGA系统上也可以工作，而且是完全等同的。
文本方式02和03：80列格式；虽然最初是为CGA设计的，但是在VGA系统上也可以工作，而且是完全等同的。
文本方式07（单色）：标准的单色方式。
图形方式将在后面的“使用图形方式”一节中介绍。
9.4属性
文本方式中的属性字节决定每一个显示字符的特性。当程序设置了一个属性时，它将保持这种设置，也就是说，之后所显示的字符全部都具有相同的属性，
直到另一个操作改变了属性。使用INT 10H功能可以产生一个屏幕属性并且执行一些动作，如上卷或下卷、读属性或字符、显示属性或字符等。
用DEBUG命令D B800:0观察视频显示区，可以看到1字节的字符之后，紧接着的是1字节的属性。
属性字节格式如下：
背景                  前景
BL R G B           I R G B
7   6  5 4           3 2 1 0
字母R、G和B表示对应位分别是红、绿和蓝，每种颜色都是这三原色合成的。
位7（BL）设置闪烁（可能无效）
位6-4确定字符的背景颜色
位3（I）设置正常亮度（若为0）或高亮度（若为1）
位2-0确定字符的前景颜色
背景可以显示8种颜色中的一种，前景能显示16种颜色中的一种。闪烁和亮度只应用于前景，但是可以利用INT 10H的功能10H使闪烁特性无效，并使前景显示16种颜色。
边界也可以选择16种颜色中的一种。
在属性字节中可以将3个基本视频颜色红（R）、绿（G）和蓝（B）组合形成8种颜色（包括黑色和白色），设置亮度（下列表格中的I）总共可形成16种颜色。
颜色         I   R   G   B   HEX   颜色         I   R   G   B   HEX
黑            0   0   0   0    0       灰            1   0   0   0    8       
蓝            0   0   0   1    1       浅蓝         1   0   0   1    9       
绿            0   0   1   0    2       浅绿         1   0   1   0    A       
青            0   0   1   1    3       浅青         1   0   1   1    B       
红            0   1   0   0    4       浅红         1   1   0   0    C       
品红         0   1   0   1    5       浅品红      1   1   0   1    D       
棕            0   1   1   0    6       黄            1   1   1   0    E       
白            0   1   1   1    7       亮白         1   1   1   1    F       
如果背景颜色和前景颜色是相同的，显示的字符是不可见的。你也可以使用属性字节让前景字符闪烁。
视频系统实现闪烁的方法是：大约每两秒钟就用背景的颜色来代替前景的颜色，这样使正常字符和空白字符交替地显示。
下表是一些典型的属性，BL的意思是闪烁：
背景         前景         BL   R   G   B   I   R   G   B   HEX
黑           蓝              0     0    0   0   0  0   0    1    01
蓝           红              0     0    0   1   0  1   0    0    14
绿           青              0     0    1    0  0   0   1   1     23
白           浅品红       0     1    1    1   1  1    0   1    7D
绿           灰 闪烁      1     0    1    0  1   0    0   0    A8
对单色监视器，除了位0是设置下划线属性外，属性字节的用法和彩色监视器一样。为了指定属性，可以如下例组合各个位：
正常显示（黑，白）0000 0111（07H）
反相显示（白，黑）0111 0000（70H）
属性字节4位的值与控制器的彩色平面使能寄存器（Color Plane Enable register）0-3位中的一位有关系，彩色平面使能寄存器依次指定16个调色板寄存器中的一个，
而调色板寄存器的0-5位与6个RGB信号（3个正常信号和3个强信号）有关。调色板寄存器中的位值指定256个DAC（数模转换）颜色寄存器中的一个，
颜色寄存器确定显示的颜色。
为每个字符选择属性就可以生成各种颜色。也可以修改任一个或所有调色板寄存器中默认的颜色，这可以通过后面要讲到的INT 10H的功能10H完成。
属性保持其设置直到另外的操作改变了它。设置属性的INT 10H功能（后面将会解释）有：
06H上卷屏幕
07H下卷屏幕
09H 显示字符及属性
13H 显示字符串
下例是使用INT 10H操作的功能09H在蓝色背景下显示12个黄色的、闪烁的星号：
MOV AH,09H
MOV AL,'*'
MOV BH,00H
MOV BL,9EH
MOV CX,12
INT 10H
测试通过的完整程序如下
.MODEL TINY
.CODE
ORG 100H
A10MAIN PROC NEAR
MOV AH,09H
MOV AL,'*'
MOV BH,00H
MOV BL,9EH
MOV CX,12
INT 10H
MOV AX,4C00H
INT 21H
A10MAIN ENDP
END A10MAIN
你可以利用DEBUG来检验这个例子，并尝试用其他颜色的组合。
9.5BIOS INT 10H操作
INT10H支持很多服务例程（通过AH中的功能码选用）来完成视频操作。为了得到返回值，INT操作要保存BX、CX、DX、DI、SI、DS、ES和BP的内容。
一些功能还可以返回或设置在0040:nn的BIOS视频数据区某些字段中的某些位，这些将在第24章中讲到。
INT 10H总是试图执行你放在它那里的任何程序，而且不返回状态代码或错误标志。
所以要特别小心选择INT 10H中合适的功能代码；虽然你不能因此引起任何永久性的损害，但是一个错误可能引起屏幕一片空白，这样你就不得不重新启动系统。
下面几节将描述INT 10H功能。
9.5.1INT 10H的功能00H：设置显示方式
这个功能的目的是设置显示方式。在AH中装入功能代码（00H），并在AL中装入所要求的显示方式。
下例为在任何类型的彩色监视器上设置标准彩色文本的显示方式：
MOV AH,00H   ;请求设置显示方式
MOV AL,03H   ;标准彩色文本
INT 10H   ;调用中断服务
该操作没有返回值。它能清屏，也可以不用这个功能而是采用MOV AL,83H将显示方式的7位设置为1。
9.5.2INT 10H的功能01H：设置光标大小
光标不是ASCII字符集中的字符，它只存在于文本方式中。视频控制器使用专门的INT 10H操作处理光标大小和位置。
彩色VGA默认的光标大小是顶部为13，底部为14（对单色显示是6：7）。功能01H垂直地调整光标大小，设置如下的寄存器：
CH（位4-0）=光标顶部（扫描线开始位置）
CL（位4-0）=光标底部（扫描线结束位置）
下面的代码将光标放大到最大尺寸（0：14）：
MOV AH,01H   ;请求设置光标大小功能
MOV CH,0   ;开始的扫描行
MOV CL,14   ;结束的扫描行
INT 10H   ;调用中断服务
该操作没有返回值，现在光标是一个闪烁的实心长方块。你可以在规定的范围内调整光标的大小，例如04：08，03：10等等。
把大小值设置为20H将看不见光标：MOV CX,20H。
光标保持这些属性直到另外的操作改变了它们。
9.5.3INT 10H的功能02H：设置光标位置
该操作在文本方式或图形方式下，按照行：列坐标在屏幕上的任何位置设置光标（功能13H也设置光标）。
该操作要设置这些寄存器：BH=页号（默认页号为0），DH=行，DL=列。下例在第12行，第30列，0页设置光标：
MOV AH,02H   ;请求设置光标
MOV BH,0   ;页号0（正常的）
MOV DH,12   ;第12行
MOV DL,30   ;第30列
INT 10H；调用中断服务
每页的光标位置都独立于其他页的光标。该操作没有返回值。虽然在图形方式下光标是看不见的，你仍然可以设置它。
9.5.4INT 10H的功能03H：返回光标状态
在文本方式或图形方式下，使用功能03H可以确定光标所在行、列以及大小，特别是在程序临时使用屏幕的情况下，就必须保存和重新设置原先的屏幕。
就像功能02H一样，在BH中设置页号：
MOV AH,03H   ;请求读光标位置
MOV BH,0   ;页号0（正常）
INT 10H   ;调用中断服务
该操作不改变AX和BX并返回以下的值：
CH=开始的扫描行
CL=结束的扫描行
DH=行
DL=列
下面的例子使用功能03H来读光标并确定它的位置和大小，然后使用功能02H前移光标到屏幕上的下一列：
MOV AH,03H   ;请求读光标位置
MOV BH,0   ;0页
MOV AH,02H   ;请求设置光标
INC DL
INT 10H   ;调用中断服务
9.5.5INT 10H的功能05H：选择活动页
在文本或图形方式下，功能05H用来选择要显示的页。你可以建立不同的页并要求在这些页之间切换。
该操作就是一个简单的功能请求，没有返回值：
MOV AH,05H   ;请求选择活动页
MOV AL,page   ;页号
INT 10H   ;调用中断服务
9.5.6INT 10H的功能06H：上卷屏幕
在文本或图形方式下，该操作在屏幕的指定区域（活动显示页）执行向上卷动若千行的功能。正显示的行卷动出屏幕顶部，空白行出现在屏幕底部。
你已经使用过第8章介绍的功能06H，它设置AL为0使得整个屏幕上卷，其效果是清屏。在AL中设置一个非0的值将引起上卷若干行。设置下列寄存器：
AL=上卷行数（上卷全屏为0）
BH=属性值或像素值
CX=起始行：列
DX=结束行：列
下例在文本方式下设置彩色属性并将全屏上卷一行：
MOV AX,0601H   ;请求上卷一行（文本方式）
MOV BH,61H   ;棕色背景，蓝色前景
MOV CX,0000H   ;从00:00到
MOV DX,184FH   ;24:79（全屏）
INT 10H   ;调用中断服务
该操作没有返回值。上卷一行的标准方法如下：
1.设置光标的行位置，定义一个有名称的项，例如ROW，并把它初始化为0。
2.显示一行并把光标设置到下一行。
3.测试ROW是否接近屏幕底部（CMP ROW,22）。
4.如果已接近底部，则卷动一行，并用ROW的值来设置光标，然后把ROW清0。
5.如果还未接近底部，ROW增量（INC ROW）。
CX:DX寄存器允许卷动屏幕的任何部分。要注意随着CX:DX中的距离来调整AL的值，特别是涉及到部分屏幕时。
下面的指令序列建立了一个7行×30列的窗口（使用它自己的属性），窗口坐标为左上角12：25，右上角12：54，左下角18：25，右下角18：54：
MOV AX,0607H   ;请求卷动7行（文本方式）
MOV BH,30H   ;青色背景，黑色前景
MOV CX,0C19H   ;第12行，第25列
MOV DX,1236H   ;第18行，第54列（窗口）
INT 10H
这个例子指定了上卷7行，这个值与12行到18行所包括的距离是相同的，因此只有这个窗口被清屏。
这是一个最常见的做法，建立一个窗口，上卷（或清除）它所有的行，也可以说是连续的一次上卷一行。
因为窗口的属性保持它的设置直到另一个操作改变了这个属性，因此，你可以同时对不同的窗口设置不同的属性。
在图形方式下，在BH中设置像素值而不是属性。下例设置若干行为红色：
MOV AX,060FH   ;请求卷动15行（图形方式）
MOV BH,0100B   ;像素值
MOV CX,0A00H   ;从第10行，第0列
MOV DX,184FH   ;第24行，第79列
INT 10H   ;调用中断服务
9.5.7INT 10H的功能07H：下卷屏幕
在文本和图形方式下，下卷屏幕使得屏幕底部的行卷出，而在顶部出现空白行。除了该操作是下卷外，它所做的工作与上卷功能06H一样。设置下列寄存器：
AL=行数（下卷全屏为00）
BH=属性值或像素值
CX=起始行：列
DX=结束行：列
9.5.8INT 10H的功能08H：读光标位置的字符和属性
功能08H能在文本方式和图形方式下从视频显示区读出字符和它的属性。光标的位置决定了要读出的字符。
在BH中设置页号，如下所示：
MOV AH,08H   ;请求读字符/属性
MOV BH,0   ;页号0（正常）
INT 10H   ;调用中断服务
该操作将字符传送到AL，属性传送到AH。在图形方式下，该操作返回00H说明读出的是非ASCII字符。
因为该操作一次只读一个字符，所以必须编写一个循环代码来连续地读字符。
9.5.9INT 10H的功能09H：在光标位置显示字符和属性
这个很有用的操作按照给定的属性显示一定数量的字符。光标的位置决定了字符显示在什么地方。设置这些寄存器：
AL=ASCII字符
BL=属性或像素值
BH=页号
CX=计数值
CX中的计数值指定了该操作重复显示AL中字符的次数。
下例在文本方式下设置彩色属性，并显示60次“笑脸”（01H）：
MOV AH,09H   ;请求显示（文本方式）
MOV AL,01H   ;要显示的笑脸
MOV BH,0   ;页号0
MOV BL,16H   ;蓝色背景，棕色前景
MOV CX,60
INT 10H   ;调用中断服务
该操作不前移光标，也不对响铃（Bell）、回车、换行或Tab符产生反应，而是试图把它们当作ASCII字符来显示。
在文本方式下，当显示超过了最右边一列，操作自动地继续在下一行的0列开始显示。
对图形方式，使用BL定义前景颜色。如果第7位是0，定义的颜色代替已有的像素颜色；如果第7位是1，定义的颜色与它们组合（异或）。
下例在图形方式下显示10个心形符：
MOV AH,09H   ;请求显示（图形方式）
MOV AL,03H   ;心形符（要显示的字符）
MOV BH,0   ;页号0
MOV BL,04H
MOV CX,10
INT 10H   ;调用中断服务
显示不同字符的串请见功能13H。
9.5.10INT 10H的功能0AH：在光标位置显示字符
功能0AH和09H唯一的区别是：功能9H设置属性，而功能0AH使用当前的属性值。
下面是功能0AH的代码：
MOV AH,0AH   ;请求显示
MOV AL,char：要显示的字符
MoV BH,page   ;页号（0=正常）
MOV BL,value   ;像素值（仅限图形方式）
MOV CX,repetition   ;字符重复次数
INT 10H   ;调用中断服务
该操作没有返回值。
9.5.11INT 10H的功能0BH：设置彩色调色板
在图形方式下利用这个功能来设置调色板。BH中的值（00或01）确定BL的用途：
BH=00 选择背景颜色，在BL的0-3位含有颜色值（16种颜色之一）：
MOV AH,0BH
MOV BH,00H
MOV BL,04H   ;红色（选项是00-0FH）
INT 10H   ;调用中断服务
BH=01 选择图形的调色板，BL含有调色板（0或1）：
MOV AH,0BH   ;请求彩色
MOV BH,01H   ;选择调色板
MOV BL,00H   ;调色板0（绿，红，棕）
INT 10H
该操作在颜色选择寄存器中存储颜色值，并修改BIOS视频显示区40：[66]中的调色板值。
一旦设置了调色板，它将保持这个设置，但是当你改变调色板时，整个屏幕就会改变颜色。
9.5.12INT 10H的功能0CH：写像素点
功能0CH用来在图形方式下显示所选择的颜色（背景和调色板）。设置这些寄存器：
AL=像素的颜色
BH=页号
CX=列
DX=行
列号或行号的最小值是0，最大值取决于显示方式。下例将像素设置在第200列，第50行：
MOV AH,0CH   ;请求写像素点
MOV AL,03H   ;像素颜色
MOV BH,0   ;页号0
MOV CX,200   ;水平x-坐标（列）
MOV DX,50   ;垂直y-坐标（行）
INT 10H   ;调用中断服务
一种例外情况使AL的值成为像素的行值：在图形方式下除04功能外，设置AL的7位为1会引起AL的值与视频显示区中的值进行异或操作。
9.5.13INT 10H的功能0DH：读像素点
这个操作与功能0CH相反，它读取一个像素点以确定它的颜色。在BH中设置页号，CX中设置列号，DX中设置行号。
列号和行号的最小值是0，最大值取决于显示方式：
MOV AH,0DH   ;请求读像素点
MOV BH,0
MOV CX,80   ;水平x-坐标
MOV DX,110   ;垂直y-坐标
INT 10H   ;调用中断服务
该操作在AL中返回像素值。
9.5.14INT 10H的功能0EH：以打字方式显示
在文本和图形方式下，该操作把监视器当作一个终端来完成简单的显示，用法如下：
MOV AH,0EH   ;请求显示
MoV AL,char   ;要显示的字符
MOV BH,0   ;页号0
MOV BL,color   ;前景颜色（图形方式）
INT 10H
退格（08H）、响铃（07H）、回车（0DH）和换行（0AH）是屏幕显示格式的命令，但是Tab（09H）不起作用。
该操作自动地前移光标，自动换行到下一行显示字符，自动卷屏并保持当前的屏幕属性。该操作没有返回值。
9.5.15INT 10H的功能0FH：取当前显示方式
可以使用这个功能来确定当前显示方式。下面是一个例子：
MOV AH,0FH
INT 10H
CMP AL,03H
JE ...
该操作从BIOS视频数据区返回这些值：
AL=当前显示方式
AH=屏幕列数
BH=活动显示页
9.5.16程序：显示ASCII字符集
图8-1的程序使用INT 21H的功能09H来显示ASCII字符集，但是它不能显示退格、响铃、回车和换行等控制符。
图9-2是修改后的程序，它使用INT 10H来显示全部的字符集，所使用的功能如下：
0FH   取当前显示方式并保存它。
00H   本程序设置显示方式03，在退出程序之前恢复原先的显示方式。
08H   为了用功能06H清屏，先读出当前光标位置的属性。
06H   上卷屏幕以清除整个屏幕，使用刚才读出来的属性。同时建立一个16行的，棕色前景和蓝色背景的窗口来显示字符。
02H   设置光标的初始位置，并为每个要显示的字符前移光标。
0AH   在当前光标位置上显示每个字符，包括控制字符。
要显示的字符在一个16列和16行的栅格内。编写这个程序和本书的其他程序一样，要求清晰而不是处理速度。
你可以修改这个程序使它运行的更快，例如，处理行、列以及ASCII字符值使用寄存器。
因为INT 10H只破坏AX的内容，所以不必再装入其他寄存器的值。
然而要使这个程序明显地加快运行速度是可以的，但程序要损失一些清晰度。
.MODEL SMALL
.STACK 512
.DATA
CHAR_CTR DB 0
COL DB 24
ROW DB 4
MODE DB ?
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
CALL B10MODE
CALL C10CLEAR
A20:CALL D10CURSOR
CALL E10DISPLY
CMP BYTE PTR CHAR_CTR,0FFH
JE A30
INC BYTE PTR CHAR_CTR
ADD BYTE PTR COL,2
CMP BYTE PTR COL,56
JNE A20
INC BYTE PTR ROW
MOV BYTE PTR COL,24
JMP A20
A30:MOV AH,10H
INT 16H
MOV AH,00H
MOV AL,MODE
INT 10H
MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10MODE PROC NEAR
MOV AH,0FH
INT 10H
MOV MODE,AL
MOV AH,00H
MOV AL,03H
INT 10H
RET
B10MODE ENDP
C10CLEAR PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AH,08H
INT 10H
MOV BH,AH
MOV AX,0600H
MOV CX,0000H
MOV DX,184FH
INT 10H
MOV AX,0610H
MOV BH,16H
MOV CX,0418H
MOV DX,1336H
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
C10CLEAR ENDP
D10CURSOR PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AH,02H
MOV BH,0
MOV DH,ROW
MOV DL,COL
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
D10CURSOR ENDP
E10DISPLY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AH,0AH
MOV AL,CHAR_CTR
MOV BH,0
MOV CX,1
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
E10DISPLY ENDP
END A10MAIN
9.5.17INT 10H的功能10H：存取调色板寄存器和视频DAC
这个操作提供了若干个有关读取和修改调色板寄存器、过扫描（边界）寄存器以及视频DAC的功能。在AL中装入子功能以指定一个执行例程。
1.子功能00H：修改调色板寄存器。
通过选择16个调色板寄存器中的一个可以改变显示的颜色，在BH中装入颜色值，在BL中装入调色板寄存器编号（00-0FH）：
MOV AX,1000H   ;请求修改调色板寄存器
MOV BH,02H
MOV BL,01H
INT 10H   ;调用中断服务
2.子功能01H：修改边界颜色。默认的边界颜色是黑色。为了改变边界颜色，在BH中放入新的颜色并请求这个操作：
MOV AX,1001H   ;请求修改边界颜色
MOV BH,02H
INT 10H
3.子功能03H：选择背景亮度。该操作可以允许或禁止闪烁属性，在BL中装入代码（00H=禁止，01H=允许）。
这个操作存取属性控制器的方式控制寄存器。由于禁止闪烁，背景颜色可选用所有的16个调色板寄存器而不是8个调色板寄存器。
MOV AX,1003H
MOV BL,00H
INT 10H   ;调用中断服务
4.子功能07H：读调色板寄存器。该操作允许将确定的颜色码保存在16个调色板寄存器中的任何一个中。BL中是请求的寄存器号：
MOV AX,1007H   ;请求调色板寄存器中的颜色码
MOV BL,register
INT 10H   ;调用中断服务
该操作在BH中返回颜色码。参见子功能09H。
5.子功能08H：读过扫描寄存器。该操作返回过扫描（边界）寄存器中的当前的颜色码：
MOV AX,1008H   ;读过扫描寄存器
INT 10H
该操作在BH中返回颜色码。
6.子功能09H：读调色板寄存器值表。该操作返回所有当前的调色板和过扫描寄存器的值，并把它们存入一个17字节的表中。
你可以定义这个表并把它的地址送入ES:DX。下例假定ES已包含有适当的段地址：
REGTABLE DB 17 DUP (?)
MOV AX,1009H   ;读调色板寄存器值
LEA DX,REGTABLE   ;放入表中（ES:DX）
INT 10H   ;调用中断服务
该操作把调色板寄存器的内容返回到前16个字节中，过扫描寄存器放入第17个字节中。
典型的默认值是00 01 02 03 04 05 14 07 38 39 3A 3B 3C 3D 3E 3F 00。这最后一个值00表示边界颜色是黑色。
7.子功能10H：修改DAC颜色寄存器。视频DAC（digital-to-analog converter）包含有256个3字节的颜色寄存器：
00-0FH 默认的CGA彩色系列
10-1FH 增加亮度的灰度色标
20-67H 3组中的第1组；高亮度蓝、红、绿
68-AFH 3组中的第2组：中亮度蓝、红、绿
B0-F7H 3组中的第3组：低亮度蓝、红、绿
F8-FFH 黑色
在20、68和B0的3组，每组都由按饱和度递减顺序排列的3种颜色组成。子功能10H能用颜色值修改任一个DAC寄存器：
MOV AX,1010H   ;修改DAC颜色寄存器
MOV BX,register   ;DAC寄存器号
MOV CH,green   ;绿的颜色值
MOV CL,blue   ;蓝的颜色值
MOV DH,red   ;红的颜色值
INT 10H
该操作只使用颜色码的低6位
8.子功能12H：修改DAC寄存器组。该操作能用颜色值修改一组DAC寄存器。
定义一个颜色表（每个寄存器3字节分别对应红、绿和蓝），并把它的地址送入ES:DX。下例假定ES已含有适当的段地址：
DACTABLE DB nn DUP (?)   ;表（每个寄存器3字节）
MOV AX,1012H   ;修改DAC寄存器组
MOV BX,register   ;组内第一个DAC寄存器
MOV CX,number   ;组内DAC寄存器数
LEA DX,DACTABLE   ;放入表中（ES:DX）
INT 10H
9.子功能15H：读视频DAC颜色寄存器。子功能15H能读取任一个DAC寄存器：
MOV AX,1015H   ;读视DAC颜色寄存器
MOV BX,register   ;DAC寄存器号
INT 10H   ;调用中断服务
该操作在CH中返回绿色码，在CL中返回蓝色码，在DH中返回红色码，
10.子功能17H：读DAC寄存器组。该操作能读取一组 DAC寄存器（最多256个）存入一个表中
（对应红、绿、蓝每个寄存器3字节），表地址在ES；DX中。下例假定ES已含有适当的段地址：
DACTABLE DB nn DUP (?)   ;表（每个寄存器3字节）
MOV AX,1017H   ;读一组DAC寄存器
MOV BX,register   ;组内第一个DAC寄存器
MOV CX,number   ;组内DAC寄存器数
LEA DX,DACTABLE   ;表（ES:DX）
INT 10H   ;调用中断服务
能够看到表中的返回值，如00 00 00（奇存器0），00 00 2A（寄存器1），00 2A 00（寄存器2），依此类推。
11.子功能1BH：对DAC寄存器组执行灰度定标。该操作能对一组视频DAC寄存器执行灰度定标：
MOV AX,101BH；执行灰度定标
MOV BX,register   ;组内第一个DAC寄存器
MOV CX,number   ;组内DAC寄存器数
INT 10H   ;调用中断服务
设置BX=0和CX=10H来做个试验，可看到灰度定标的效果。
9.5.18INT 10H的功能11H：存取字符发生器
这个操作支持与文本和图形字符发生器有关的若干子功能，这些功能可以用来改变显示字符的尺寸和形状。下面的图表列出了12个有关的子功能：
                                         用户定义表         字符尺寸         字符尺寸         字符尺寸
                                                                   8*14               8*8                8*16
装入基于文本的字符         00H                    01H                02H                04H
装入基于文本的字符         10H                    11H                12H                14H
和程序视频控制器
装入基于图形的字符         21H                     22H               23H                24H
1.子功能00H，10H及21H。这些操作所包括的用户定义字符是本书范围之外的内容。
2.子功能01H，02H及04H。这些操作支持3种预定义尺寸的基于文本的字符。
3.子功能11H，12H及14H（默认值）。这些操作分别与00H、01H和04H类似，但是也可对视频控制器重新编程以处理字符矩阵的高度。
使用这些功能要在BL中装入字符发生器表的编码。下例装入8×8基于文本的字符：
MOV AX,1112H   ;装入8×8文本字符
MOV BL,0   ;表编码0-7
INT 10H
该操作能使屏幕显示43行的8×8大小的字符。
4.子功能22H，23H及24H。这些操作支持基于图形的字符。
对这些功能，在BL中要指出每屏的字符行数，这里1=14行，2=25行，3=43行，0=DL中给定的每屏字符行数：
MOV AX,1123H   ;装入8×8图形字符
MOV BL,code   ;0，1，2或3
MOV DL,number   ;当BL=0时的字符行数
INT 10H   ;调用中断服务
5.子功能03H：选择显示字符定义表。在BL中装入一个位串。根据串属性（亮度）的位3的值：
如果为0，位0、1和4指出使用8个256字符表中的一个。
如果为1，位2、3和5指出要使用的字符表。
6.子功能30H：读字符发生器数据。为了取得有关当前字符发生器的数据，把下列代码之一装入BH：
0 INT 1FH向量的内容
1 INT 43H向量的内容
2 BIOS 8×14字符表的地址
3 BIOS S×8字符表前一半的地址
4 BIOS8×8字符表后一半的地址
5 BIOS9×14交替字符表的地址
6 BIOS 8×16字符表的地址
7 BIOS 9×16交替字符表的地址
该操作返问这些值：CX=字符点阵的高度，DL=行数-1（典型的是18H），ES:BP=字符定义表的地址。
你可以利用DEBUG（文本方式）来显示每个选项：
MOV AX,1130H   ;请求字符发生器信息
MOV BH,0   ;代码0，1，2，...，7
INT 10H   ;调用中断服务
INC BH   ;下一个DAC寄存器
JMP 100   ;重复
用DEBUG的D命令来显示传送到ES:BP的段地址：偏移地址，如D ES:偏移地址。
9.5.19INT 10H的功能12H：选择可选视频例程
该操作支持许多子功能，子功能编码在BL中：
子功能10H：返回视频结构信息。该操作返回：
BH=视频类别（0为彩色，1为单色）
BL=视频RAM容量（0=64K，1=128K，2=192K，3=256K+）
CH=适配器位
CL=结构开关设置
子功能30H：为文本方式选择扫描线。在文本方式的0、1、2、3和7方式下，可利用这个操作来改变扫描线的垂直分辨率。
在AL中装入扫描线数：0=200，1=350，2=400。然后用功能00H设置显示方式：
MOV AX,1202H   ;请求选择400行
MOV BL,30H   ;扫描线
INT 10H   ;调用中断服务
MOV AX,0003H   ;设置文本方式03（720×400）
INT 10H   ;调用中断服务
其他子功能包括允许和禁止灰度求和、光标仿真和恢复控制。
9.5.20INT 10H的功能13H：显示字符串
这是一个功能强大的操作，它在文本或图形方式下显示任意长度的字符串，并带有设置属性和移动光标的选项。
在ES:BP中装入显示串的段地址：偏移地址。该操作对退格、响铃、回车和换行等控制字符起作用，但对Tab不起作用。
MOV AH,13H   ;请求显示串
MOV AL,subfunction   ;00，01，02，或03（见下面的解释）
MOV BH,page
MOV BL,attribute   ;屏幕属性
LEA BP,address   ;串地址在ES:BP
MOV CX,length   ;串长度
MOV DH,row   ;屏幕行
MOV DL,column   ;屏幕列
INT 10H   ;调用中断服务
设置在AL中的4个子功能是：
00 显示串和属性；不前移光标
01 显示串和属性；前移光标
02 显示字符及其属性；不前移光标
03 显示字符及其属性；前移光标
子功能02和03要求显示串的每个字符之后紧接着一个属性字节。这个特点对显示带有混合属性的数据非常方便，并且可以直接从视频显示区显示。
在图形方式下，设置BL的7位为1，可使串值与视频区的值进行XOR（异或）操作。
9.5.21程序：设置属性和卷屏
图9-3的程序从键盘接收并在屏幕上显示名字。为了使显示更加有趣，用反相显示（白底蓝字）提示符，接收并正常显示（蓝底白字）名字，
这样在同一行的70列右调整为反相显示，格式如下：
Name?Mark Twain...Mark Twain
0列                                       70列
程序由以下几个子程序组成：
A10MAIN提供主要的逻辑功能，即接收任意数量的键盘输入以及使用INT 10H的功能10H来禁止闪烁属性。
B10PROMPT为用户显示提示符以接收名字。
C10INPUT用INT 21H的功能0AH接收键盘输入。
D10NAME计算起始列使得输入的名字在显示时是右调整的。
调用E10DISPLY向下显示直到屏幕的23行，然后每增加一个提示符就上卷一行。
E10DISPLY使用INT 10H的功能13H来设置光标并显示输入的名字。
Q10SCROLL处理屏幕的卷动，设置屏幕背景为灰色（1000B），它是在禁止闪烁的情况下工作的。
.MODEL SMALL
.STACK 512
.DATA
PARLIST LABEL BYTE
MAX_LEN DB 20
ACT_LEN DB ?
KB_NAME DB 28 DUP (20H)
LEFT_COL EQU 51
BOTT_SCRN EQU 23
ATTRIB DB 00H
COL DB 05H
ROW DB 00H
PROMPT DB 'Name: '
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
MOV AX,1003H
MOV BL,00H
INT 10H
MOV AL,00H
CALL Q10SCROLL
A20:MOV BYTE PTR COL,05H
CALL B10PROMPT
CALL C10INPUT
CMP BYTE PTR ACT_LEN,00H
JE A30
CALL D10NAME
JMP A20
A30:MOV AL,00H
CALL Q10SCROLL
MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10PROMPT PROC NEAR
MOV BYTE PTR ATTRIB,71H
LEA BP,PROMPT
MOV CX,06H
CALL E10DISPLY
RET
B10PROMPT ENDP
C10INPUT PROC NEAR
MOV AH,0AH
LEA DX,PARLIST
INT 21H
RET
C10INPUT ENDP
D10NAME PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AL,MAX_LEN
SUB AL,ACT_LEN
ADD AL,LEFT_COL
MOV COL,AL
MOV BYTE PTR ATTRIB,17H
LEA BP,KB_NAME
MOV CX,0
MOV CL,ACT_LEN
CALL E10DISPLY
CMP BYTE PTR ROW,BOTT_SCRN
JAE D30
INC BYTE PTR ROW
JMP D90
D30:MOV AL,01H
CALL Q10SCROLL
D90:POP DX
POP CX
POP BX
POP AX
RET
D10NAME ENDP
E10DISPLY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AH,13H
MOV AL,01H
MOV BH,00H
MOV BL,ATTRIB
MOV DH,ROW
MOV DL,COL
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
E10DISPLY ENDP
Q10SCROLL PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AH,06H
MOV BH,86H
MOV CX,0000H
MOV DX,184FH
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
Q10SCROLL ENDP
END A10MAIN
9.5.22 INT 10H的功能1AH：视频显示的组合
该操作支持许多与组合视频子系统（例如，彩色和单色显视器）有关的子功能。这些讨论超出了本书的范围。
9.5.23INT 10H的功能1BH：返回视频BIOS信息
对于这个操作，你要为动态信息定义一个64字节的缓冲区，并将缓冲区的地址送入ES:DI。在DEBUG中，该操作的代码如下：
MOV AH,1B   ;请求视频BTOS信息
MOV BX,0   ;0为实现类型
MOV DI,110   ;动态信息的偏移地址（ES:DI）
INT 10   ;调用中断服务
JMP 100
该操作返回下列动态信息（本例中，地址为ES:110）：
偏移地址         字长         说明
00H                  双字         静态功能表的地址（见下面）
04H                  字节         当前显示方式
05H                  字            屏幕列数（5000H=80）
07H                  字            当前视频缓冲区大小（0010H=4096）
09H                  字            当前视频缓冲区起始地址
0BH                  数组        16字节数组，保存8页的光标列：行
1BH                  字节        光标结束扫描行
1CH                  字节        光标开始扫描行
1DH                  字节        当前显示页
1EH                  字            CRTC地址寄存器端口
20H                  字节         显示方式寄存器的当前设置
21H                  字节         当前彩色调色板
22H                  字节         当前屏幕行号（19H=25）
23H                  字            字符扫描行高度（1000H=16）
25H                  多字节      活动的和不活动的显示组合码
27H                  字            当前显示颜色数
29H                  字节         显示页数
2AH                  字节         扫描线（0-200，1=350，2-400，3=480）
2BH                  多字节      正常/高亮度的文本字符表
2DH                  字节         位0-5指示允许/禁止条件
31H                  字节         可用的视频存储器（3=256K+）
32H                  字节         位0-5指示活动/非活动条件
静态功能表的起始地址指向一个16字节的静态功能表。例如，内容为8839 00C0意味着偏移地址为3988H，段地址为C000H，
这可以利用DEBUG来观察表，命令为D C000:3988。
偏移地址         字长         说明
00H               字节         位0=1说明支持方式0，以此类推
01H               字节         位0=1说明支持方式8，以此类推
02H               字节         位0=1说明支持方式10H，以此类推
07H               字节         位=1，若为文本方式支持的扫描行（位0为200行，位1为350行，位2为400行）
08H               字节         可显示文本字符集的最大数
09H               字节         文本字符定义表的数目
0AH               字节         位0-3指示不同的视频存储器容量
9.5.24INT 10H的功能1CH：保存和恢复视频状态
该操作支持返回缓冲区大小、保存请求的状态和恢复请求的状态等3个子功能。关于该操作的讨论超出了本书的范围。
9.6使用图形方式
图形方式利用像素（picture elements或pels）来产生彩色图案。在前面我们已经知道文本方式下的属性由4位背景色和4位前景色组成。
视频系统以一种类似的，但是又与显示方式相关的方法来分辨像素，这种方法可以用1到8位来表示一个像素。
尽管光标仍可以设置，但设置图形方式将使光标消失。下面是通用的图形方式：
显示方式         类型         显示区         页         分辨率         彩色
04H                彩色         B800            8         320×200         4
05H                彩色         B800            8         320×200         4
06H                彩色         B800            8         640×200         2
0DH               彩色         B800            8         320×200         16
0EH                彩色         A000            4         640×200         16
0FH                单色         A000            2         640×350         1
10H                彩色         A000            2         640×350         16
11H                彩色         A000            1         640×480         2
12H                彩色         A000            1         640×480         16
13H                彩色         A000            1         320×200         256
图形方式04H和05H。为了向上兼容，最初的CGA方式也用于VGA。一个字节表示4个像素（每个像素两位）。两位可同时提供22，即4种不同的颜色。
图形方式06H。为了向上兼容，最初的CGA方式用于VGA。一个字节表示8个像素（每个像素一位），同时可以提供两种颜色。
图形方式0DH、0EH和10H。为了向上兼容，最初的EGA方式也用于VGA。在16色图形方式下，每个屏幕字符是一个8×8的像素矩阵。
视频显示区用32字节的数据来表示像素值，也就是说，每像素4位×8×8=256位=32字节。
图形方式0FH。为了向上兼容，最初的EGA单色方式也用于VGA。
图形方式11H和12H。它们是专门为VGA设计的。这些方式在操作上与方式0DH和0EH类似；在技术上，方式11H只需要一个位图来表示一个屏幕的像素。
然而，在位图中11H可存取到两种调色板颜色，方式12H可存取到16种调色板颜色。
图形方式13H。它们是专门为VGA设计的。这种方式也使用像素位图，但是每个像素由视频位图的一个字节来表示。8位提供2的8次方，即256种不同的颜色。
使用BIOS INT 10H的功能00H来设置图形方式，如下例所示：
MOV AH,00H   ;请求设置方式
MOV AL,0DH
INT 10H
在图形方式下，ROM只包含了第一个（底部）128ASCII字符的点阵图。INT 1FH提供可访问的1K的存储区，其中定义了顶部的128个ASCII字符，每个字符8字节。
9.6.1程序：使用图形方式的功能
图9-4的程序使用的图形方式功能如下：
0FH 取得并保存原先设定的显示方式。
00H 设置图形方式12H。
0BH 请求一个彩色调色板
06H 卷动屏幕并设置5行为黄色。
13H 设置光标和属性并显示一串字符。
0AH 显示一个字符并重复若干次。
在程序末尾等待用户按动一个键，然后重新设置为原来的显示方式。
.MODEL SMALL
.STACK 512
.DATA
STRING DB '1234567890'
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
MOV AH,0FH
INT 10H
PUSH AX
CALL B10MODE
CALL C10SCROLL
CALL D10STRING
CALL E10DISPLY
MOV AH,10H
INT 16H
POP AX
MOV AH,00H
INT 10H
MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10MODE PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AH,00H
MOV AL,12H
INT 10H
MOV AH,0BH
MOV BH,00H
MOV BL,07H
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
B10MODE ENDP
C10SCROLL PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,0605H
MOV BH,0EH
MOV CX,0000H
MOV DX,044FH
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
C10SCROLL ENDP
D10STRING PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,1301H
MOV BX,0021H
LEA BP,STRING
MOV CX,10
MOV DX,0815H
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
D10STRING ENDP
E10DISPLY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,0A01H
MOV BH,00H
MOV BL,04H
MOV CX,10
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
E10DISPLY ENDP
END A10MAIN
9.6.2像素举例
作为一个简单的例子，显示方式04H提供了200行的320个像素。在这种方式下，每个字节表示4个像素（即每个像素两位），编号为0-3，如下所示：
字节：c1 c0   c1 c0   c1 c0   c1 c0
像素：0         1         2         3
在任何给定的时间，有4种可用的颜色，编号为0-3。局限为4种颜色是因为2位像素值只提供4种位组合：00，01，10和11。
你可以设置像素值00来选择16种可用颜色之一作为背景色。
颜色                  颜色
黑    0000             灰      1000
蓝    0001             浅蓝   1001
绿    0010             浅绿   1010
青    0011             浅青   1011
红    0100             浅红   1100
品红 0101          浅品红   1101
棕    0110               黄     1110
灰白 0111              白     1111
对于方式04H，调色板0由前景的绿色、红色和棕色组成，调色板1由前景的青色、品红和白色组成。
使用INT10H的功能0BH来选择一种调色板和背景色。如果选择背景色为黄色及调色板0，则可用的颜色是黄、绿、红和棕。
一个由像素值10101010组成的字节显示为全红。如果选择背景色为蓝色及调色板1，则可用的颜色为蓝、青、品红和白，
那么一个由像素值00011011组成的字节显示蓝、青、品红和白色。
9.6.3程序：显示图形像素
图9-5的程序包括了以下INT 10H功能显示图形：
0FH=取得原始的显示方式
00H=设置图形方式12H
0BH=选择背景色为绿色
0CH=在640列，480行显示点
实际的显示窗口为210行，512列（从第64列到第576列）。注意行和列是针对点来说的，而不是对字符。
.MODEL SMALL
.STACK 512
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
MOV AH,0FH
INT 10H
PUSH AX
CALL B10MODE
CALL C10DISPLY
MOV AH,10H
INT 16H
POP AX
MOV AH,00H
INT 10H
MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10MODE PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,0012H
INT 10H
MOV AH,0BH
MOV BX,0007H
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
B10MODE ENDP
C10DISPLY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV BX,0000H
MOV CX,64
MOV DX,70
C20:MOV AH,0CH
MOV AL,BL
INT 10H
INC CX
CMP CX,576
JNE C20
MOV CX,64
INC BL
INC DX
CMP DX,280
JNE C20
POP DX
POP CX
POP BX
POP AX
RET
C10DISPLY ENDP
END A10MAIN
程序增加每一行的颜色值（即位值0000变为0001，等等），因为只用到最右边的4位，所以这些颜色每16行重复显示一次。
显示从屏幕左边的64列开始到屏幕右边的64列结束。
在程序末尾等待用户按动一个键，然后重新设置为最初的显示方式。你可以将程序修改为其他的图形方式。
9.7直接视频显示
由于对某些应用来说，视频显示经过操作系统和BIOS可能会明显地变慢。显示文本和图形字符最快的方法是直接将它们传输到相应的视频显示区。
例如，对显示方式03（彩色文本），0页在视频区的地址是B800[0]H。每个字符需要两个存储器字节，一个字节存储字符，紧接着的另一个字节存储它的属性。
一屏的大小为80列和25行，则一页在视频区占用80*25*2=4000字节。
视频显示区中的头两个字节表示的屏幕位置是00行和00列，偏移地址为F9EH和F9FH的两个字节表示24行和79列的屏幕位置。
简单移动一个字符：属性到活动页的视频区，屏幕上立即显现出字符。可以用DEBUG命令来检验这个特性。
首先，用命令D B800:0来显示在B800[0]H的视频区。在屏幕上显示出来的是当时你键入的命令，通常是含有20 07H（空字符，黑色背景和白色前景）的一组字节。
注意，DEBUG和你的输入会竞争同一个显示区和屏幕位置。
尝试改变屏幕显示，使用这些命令在顶部行和底部行用不同的属性（25、36和47）来显示笑脸（01、02和03）：
E B800:0000 01 25 02 36 03 47
E B800:0F90 01 25 02 3603 47
图9-6的程序给出一个直接传输数据到视频显示区B900[0]H的例子，该地址是1页而不是默认的0页。
程序使用SEGMENT AT把视频显示区定义为VIDEO_SEG，实际上是作为一个虚拟段。在这个段的开始用VID_AREA确定1页的地址。
.MODEL SMALL
.STACK 512
VIDEO_SEG SEGMENT AT 0B900H
VID_AREA DB 1000H DUP (?)
VIDEO_SEG ENDS
.CODE
A10MAIN PROC FAR
MOV AX,VIDEO_SEG
MOV ES,AX
ASSUME ES:VIDEO_SEG
MOV AH,0FH
INT 10H
PUSH AX
PUSH BX
MOV AX,0003H
INT 10H
MOV AX,0501H
INT 10H
CALL B10DISPLY
MOV AH,10H
INT 16H
MOV AH,05H
POP BX
MOV AL,BH
INT 10H
POP AX
MOV AH,00H
INT 10H
MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10DISPLY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
MOV AL,41H
MOV AH,01H
MOV DI,820
B20:MOV CX,60
B30:MOV WORD PTR ES:[DI],AX
ADD DI,2
LOOP B30
INC AH
INC AL
ADD DI,40
CMP AL,51H
JNE B20
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
B10DISPLY ENDP
END A10MAIN
该程序在第5行到第20行，第10列到第69列显示字符。第一行显示一串字符A（41H），属性为01H，第二行显示一串字符B（42H），属性为02H，
以此类推，每行的字符和属性值都加1。
程序根据在视频区定位偏移地址的规则来设立视频显示区页的起始位置：
偏移地址=[(行×80)+列]*2
那么对于第5行，第10列的起始位置是[(5×80)+10]×2=410×2=820。
显示一行之后，程序在显示区前移40个位置作为下一行的开始，并到达字母Q（51H）时结束。
1页的视频显示段定义为VIDEO_SEG，页定义为VID_AREA。程序设置ES为VIDEO_SEG段的段寄存器。
在程序开始，保存当前显示方式和当前页，然后设置方式03和01页。
在子程序B10DISPLY中，AX初始化为开始显示的字符和属性，视频显示区的起始偏移地址在DI中。
指令MOV WORD PTR ES:[DI],AX传送AL的内容（字符）到显示区的第一个字节，AH的内容（属性）传送到第二个字节。
LOOP程序执行这条指令在屏幕上显示字符：属性60次。然后增量字符：属性，DI加40，20为当前行结束，20用来确定下一行的开始（在这个屏幕上，每行10列）。
程序又重复显示下一行的字符。
完成显示后，程序等待用户按动一个键，恢复初始的显示方式和页号。
9.8用于方框和菜单的ASCll字符
在扩展的ASCII字符128-255（80H-FFH）中有许多是用来显示提示符、菜单和标识语的专用字符，如图9-7所示。
下例用INT 10H的功能09H来画一条25个位置长的水平实线：
MOV AH,09H   ;请求显示
MOV AL,0C4H   ;单实线
MOV BH,00H   ;页号0
MOV BL,1EH   ;蓝色背景，棕色前景
MOV CX,25   ;重复25次
INT 10H   ;调用中断服务
要记住，虽然功能09H显示一串字符，但它不能前移光标。
显示一个方框最简单的方法是在数据段中定义并显示整个数据区。下面的例子在一个单实线框中定义了一个菜单：
MENU DB 0DAH,17 DUP (0C4H),0BFH
DB 0B3H,'Add records      ',0B3H
DB 0B3H,'Delete record    ',0B3H
DB 0B3H,'Enter orders     ',0B3H
DB 0B3H,'Print report     ',0B3H
DB 0B3H 'Update accounts  ',0B3H
DB 0B3H,'View records     ',0B3H
DB 0C0H 17 DUP (0C4H),0D9H,LF
下一章中的图10-1和图10-2举例说明了一个类似的双线框菜单，并在方框的右边和底边加上“打点”符形成阴影。
9.9要点
视频屏幕上的水平线（光栅）含有成百个点（像素），它们由红、绿和蓝三原色合成的荧光点组成。
视频显示区的数据存储在相邻的页面上。默认的页是0页，但是可以选择任何其他的显示页。它的地址取决于当前的显示方式。
显示控制器的任务包括产生水平和垂直信号、跟踪视频显示区中的当前数据、监视器的水平和垂直扫描、处理光标以及选择当前页。
过扫描在屏幕上产生一个边界（过扫描区）。
文本方式的属性字节提供闪烁、反相显示、高亮度以及选择颜色的RGB位。
BIOS INT10H提供设置显示方式、设置光标位置、滚动屏幕、选择彩色调色板、显示字符等功能。
在屏幕上向下显示行的程序可以调用INT 10H的功能06H在显示到达底部时上卷屏幕。
一个像素（或图素）由指定的位组成，其位数取决于图形适配器和分辨率。
图形方式04和05允许选择4种颜色，其中一种颜色是16种可用颜色之一，其他3种颜色来白调色板。
显示屏幕字符（文本或图形方式）最快的方法是直接把它们传送到视频显示区。
9.10习题
9-1.（a）屏幕上水平线的名称是什么？（b）线上的点的名称是什么？
（c）这些点由三原色合成的荧光点组成，这三原色是什么？
监视器的屏幕由一组称作光栅的细密的水平线组成。每条线包含上百个称作像素的点，它由3个荧光点组成，每个点对应一个三原色：红、绿和蓝。
3个电子束激活像素的3种颜色。电子束从屏幕的左上角开始连续地从左到右扫描每一行，改变电子束的强度来调整像素的亮度和颜色。
红、绿、蓝及其亮度的组合，形成了各种颜色和阴影。
9-2.以下方式的视频显示区的地址是什么？（a）显示方式00H-06H，（B）单色文本方式，（c）显示方式0DH-13H。
显示方式         行×列         类型         显示区         页         分辨率         颜色数
00                  25×40         彩色         B800         0-7         360×400         16
01                  25×40         彩色         B800         0-7         360×400         16
02                  25×80         彩色         B800         0-3         720×400         16
03                  25×80         彩色         B800         0-3         720×400         16
07                  25×80         单色         B000         0            720×400             
显示方式         类型         显示区         页         分辨率         彩色
04H                彩色         B800            8         320×200         4
05H                彩色         B800            8         320×200         4
06H                彩色         B800            8         640×200         2
0DH               彩色         B800            8         320×200         16
0EH                彩色         A000            4         640×200         16
0FH                单色         A000            2         640×350         1
10H                彩色         A000            2         640×350         16
11H                彩色         A000            1         640×480         2
12H                彩色         A000            1         640×480         16
13H                彩色         A000            1         320×200         256
9-3.指出视频控制器的4项任务。
产生水平和垂直信号、跟踪视频显示区中的当前数据、监视器的水平和垂直扫描、处理光标以及选择当前页。
视频控制器产生水平和垂直定时信号。它也保留一个指示视频显示区当前位置的计数器并对它增量。
该计数器告诉视频电路当前要存取、解码并送到监视器的数据。控制器必须与定时信号同步传输数据。
紧接着水平扫描之后，控制器发出一个垂直同步信号，使监视器执行从屏幕顶部左角开始的垂直扫描。
执行过水平和垂直扫描后，在屏幕的四周形成了一个边界（过扫描区）。视频控制器的其他任务有处理光标的大小和位置，并选择要显示的页。
控制器也有一定数量的寄存器，程序可对这些寄存器的内容进行读写。
9-4.（a）视频BIOS的两处地址是什么？（b）它们都包含些什么？
视频BIOS对视频适配器来说起到一个接口的作用，它包含像设置光标和显示字符这样的例程。视频RAM BIOS支持两个视频数据区：
（1）40:[49H]包含当前显示方式，列数以及视频显示区大小等数据。
（2）40:[84H]包含行数和字符高度等数据。
9-5.为显示方式03提供页号、分辨率和颜色数。
显示方式         行×列         类型         显示区         页         分辨率         颜色数
03                  25×80         彩色         B800         0-3         720×400         16
页号0是默认的，文本方式是从视频显示区的B800[0]开始，1页从B900[0]开始，2页在BA00[0]，3页在BB00[0]，以此类推。
在文本方式下，要在屏幕上显示的每个字符需要两个存储器字节，一个字节存放字符，第二个字节存放它的属性。
以这种方法存储，对一个80列和25行的满页字符需要80×25×2=4000字节。
实际分配给每一页的存储器单元数是4K字节，即4096字节，这样一个存储块在紧接着每页后面都有96个字节未用。
9-6.为下列显示提供二进制的属性：（a）黄底棕字，（b）品红底青字，（c）白底绿字，闪烁。
INT 10H的功能10H 子功能03H：选择背景亮度。该操作可以允许或禁止闪烁属性，在BL中装入代码（00H=禁止，01H=允许）。
这个操作存取属性控制器的方式控制寄存器。由于禁止闪烁，背景颜色可选用所有的16个调色板寄存器而不是8个调色板寄存器。
MOV AX,1003H
MOV BL,00H
INT 10H
1110 0110 = E6H
0101 0011 = 53H
1111 0010 = F2H
颜色                  颜色
黑    0000             灰      1000
蓝    0001             浅蓝   1001
绿    0010             浅绿   1010
青    0011             浅青   1011
红    0100             浅红   1100
品红 0101          浅品红   1101
棕    0110               黄     1110
灰白 0111              亮白  1111
位7（BL）设置闪烁
位6-4确定字符的背景颜色
位3（I）设置正常亮度（若为0）或高亮度（若为1）
位2-0确定字符的前景颜色
9-7.解释说明通用的属性字节是如何限制可用颜色数的。
文本方式中的属性字节决定每一个显示字符的特性。当程序设置了一个属性时，它将保持这种设置，直到另一个操作改变了属性。
属性字节格式如下：
背景                  前景
BL R G B           I R G B
7   6  5 4           3 2 1 0
字母R、G和B表示对应位分别是红、绿和蓝，每种颜色都是这三原色合成的。
位7（BL）设置闪烁（可能无效）
位6-4确定字符的背景颜色
位3（I）设置正常亮度（若为0）或高亮度（若为1）
位2-0确定字符的前景颜色
背景可以显示8种颜色中的一种，前景能显示16种颜色中的一种。闪烁和亮度只应用于前景，但是可以利用INT 10H的功能10H使闪烁特性无效，
并使背景也可以选择16种颜色中的一种。
在属性字节中可以将3个基本视频颜色红（R）、绿（G）和蓝（B）组合形成8种颜色（包括黑色和白色），设置亮度（下列表格中的I）总共可形成16种颜色。
颜色         I   R   G   B   HEX   颜色         I   R   G   B   HEX
黑            0   0   0   0    0       灰            1   0   0   0    8       
蓝            0   0   0   1    1       浅蓝         1   0   0   1    9       
绿            0   0   1   0    2       浅绿         1   0   1   0    A       
青            0   0   1   1    3       浅青         1   0   1   1    B       
红            0   1   0   0    4       浅红         1   1   0   0    C       
品红         0   1   0   1    5       浅品红      1   1   0   1    D       
棕            0   1   1   0    6       黄            1   1   1   0    E       
白            0   1   1   1    7       亮白         1   1   1   1    F       
属性字节4位的值指定16个调色板寄存器中的一个，调色板寄存器中的位值指定256个颜色寄存器中的一个，颜色寄存器确定显示的颜色。
调色板只有图片的颜色小于等于256色的时候才有,16位高彩和24位、32位真彩是没有调色板的。
调色板是为了节约空间所用的，相当于一个索引。
让我们来看看下面的例子。
有一个长宽各为200个象素，颜色数为16色的彩色图，每一个象素都用R、G、B三个分量表示。因为每个分量有256个级别，要用8位(bit)，即一个字节(byte)来表示，
所以每个象素需要用3个字节。整个图象要用200×200×3，约120k字节。
因为是一个16色图，也就是说这幅图中最多只有16种颜色，我们可以用一个表：表中的每一行记录一种颜色的R、G、B值。
这样当我们表示一个象素的颜色时，只需要指出该颜色是在第几行，即该颜色在表中的索引值。
举个例子，如果表的第0行为255，0，0(红色)，那么当某个象素为红色时，只需要标明0即可。
让我们再来计算一下：16种状态可以用4位(bit)表示，所以一个象素要用半个字节。整个图象要用200×200×0.5，约20k字节，
再加上表占用的字节为3×16=48字节。整个占用的字节数约为前面的1/6。
这张R、G、B的表，就是我们常说的调色板，另一种叫法是颜色查找表，似乎更确切一些。
程序必须将想要显示的颜色正确地设置到调色板中，这样才能显示出预期的颜色。
使用调色板的一个好处是不必改变视频内存中的值，只需改变调色板的颜色项就可快速地改变一幅图象的颜色或灰度。
VGA/EGA是当前最流行的图形显示卡，它比CGA有了效大的改进，不仅提高了屏幕的分辨率，也增加了色彩，EGA所能提供的颜色为64种，
但最多只能同时在屏幕上显示出其中任意16种，这是因为EGA上有一组16个颜色寄存器，被称为调色板。
由系统或用户从这64种颜色中选择最多16种填入这16个寄存器中，16个颜色寄存器分别用0～15来表示，在显示只读存储器RAM中存放的是颜色寄存器代号。
显示时先从显示RAM中取出颜色值，即寄存器代号，再由寄存器代号查到相应的寄存器，并取出其中颜色值加以显示。
虽然显示RAM中使用同一个寄存器号（或叫颜色值），但在这个寄存器中存储不同的值，那么在屏幕上显示出不同的颜色，因此，这16个颜色寄存器起到了调色的作用。
颜色寄存器表示的是一种逻辑颜色，可以从64种物理颜色中随意取出16种放入颜色寄存器中，通过调用这些寄存器来显示所选中的颜色，
另外需要说明一点，0号寄存器存放的颜色值为背景色，改变了0号寄存器中的值，则背景色随之改变 
9-8.编写下面的程序：（a）设置80列彩色屏幕的文本方式；（b）设置光标大小起始于扫描行4，结束于扫描行10；（c）在第5行，第20列设置光标。
MOV AH,00H   ;请求设置显示方式
MOV AL,03H   ;标准彩色文本
INT 10H   ;调用中断服务

MOV AH,01H   ;请求设置光标大小功能
MOV CH,4   ;开始的扫描行
MOV CL,10   ;结束的扫描行
INT 10H   ;调用中断服务

MOV AH,02H   ;请求设置光标
MOV BH,0   ;页号0（正常的）
MOV DH,5   ;第5行
MOV DL,20   ;第20列
INT 10H；调用中断服务
9-9.编写下面的程序：（a）上卷屏幕12行并设置蓝色背景和白色前景；（b）用1/2打点符（B1H）显示40个闪烁的“点”并设置为白色背景和红色前景。
MOV AX,060CH   ;请求上卷十二行（文本方式）
MOV BH,17H   ;蓝色背景，白色前景
MOV CX,0000H   ;从00:00到
MOV DX,184FH   ;24:79（全屏）
INT 10H   ;调用中断服务

MOV AH,09H   ;请求显示（文本方式）
MOV AL,0B1H   ;要显示的打点符
MOV BH,0   ;页号0
MOV BL,F4H   ;白色背景，红色前景 闪烁
MOV CX,40
INT 10H   ;调用中断服务
9-10.编写下面的程序：（a）设置活动页3；（b）取当前的光标状态；（c）取当前显示方式。
MOV AH,05H   ;请求选择活动页
MOV AL,3   ;页号
INT 10H   ;调用中断服务

MOV AH,03H   ;请求读光标位置
MOV BH,0   ;页号0（正常）
INT 10H   ;调用中断服务
该操作不改变AX和BX并返回以下的值：
CH=开始的扫描行
CL=结束的扫描行
DH=行
DL=列

MOV AH,0FH
INT 10H
该操作从BIOS视频数据区返回这些值：
AL=当前显示方式
AH=屏幕列数
BH=活动显示页
9-11.编写指令来显示：（a）蓝色背景黄色心形符（03H），（b）红色背景上的10个白色星号（2AH）。
MOV AH,09H   ;请求显示（文本方式）
MOV AL,03H   ;要显示的心形符
MOV BH,0   ;页号0
MOV BL,1EH   ;蓝色背景，黄色前景
MOV CX,1
INT 10H   ;调用中断服务

MOV AH,09H   ;请求显示（文本方式）
MOV AL,2AH   ;要显示的星号
MOV BH,0   ;页号0
MOV BL,47H   ;红色背景，白色前景
MOV CX,10
INT 10H   ;调用中断服务
9-12.编写一个程序，用INT 21H的功能0AH从键盘上接收数据，用INT 10H的功能13H来显示字符。
清屏，设置屏幕颜色为灰底绿字，设置边界颜色为蓝色，以及初始化光标为0行2列。颜色可以是变化的，反相显示或响铃。
从光标当前的位置开始接收键盘输入的数据。然后设置光标在78列，以反序（反向）从右到左显示输入的数据。
行增量到下一行，往下显示数据直到24行，然后开始上卷。程序应能接受任意多的输入，当无数据输入时按下回车键结束。
编写一个简短的包括主要逻辑功能的程序以及一系列的调用子程序。
.MODEL SMALL
.STACK 512
.DATA
PARLIST LABEL BYTE
MAX_LEN DB 20
ACT_LEN DB ?
KB_NAME DB 28 DUP (20H)
ATTRIB DB 00H
COL DB 02H
ROW DB 00H
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
MOV AX,1003H
MOV BL,00H
INT 10H
MOV AX,1001H
MOV BH,01H
INT 10H
MOV AL,00H
CALL Q10SCROLL
A20:CALL C10INPUT
CMP BYTE PTR ACT_LEN,00H
JE A30
CALL D10NAME
JMP A20
A30:MOV AL,00H
CALL Q10SCROLL
MOV AX,4C00H
INT 21H
A10MAIN ENDP
C10INPUT PROC NEAR
MOV BYTE PTR COL,02H
MOV AH,02H
MOV BH,00H
MOV DH,ROW
MOV DL,COL
INT 10H
MOV AH,0AH
LEA DX,PARLIST
INT 21H
CMP BYTE PTR ROW,24
JAE C30
INC BYTE PTR ROW
JMP C90
C30:MOV AL,01H
CALL Q10SCROLL
C90:RET
C10INPUT ENDP
D10NAME PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AL,78
SUB AL,ACT_LEN
MOV COL,AL
MOV BYTE PTR ATTRIB,17H
LEA BP,KB_NAME
MOV CX,0
MOV CL,ACT_LEN
CALL E10DISPLY
CMP BYTE PTR ROW,24
JAE D30
INC BYTE PTR ROW
JMP D90
D30:MOV AL,01H
CALL Q10SCROLL
D90:POP DX
POP CX
POP BX
POP AX
RET
D10NAME ENDP
E10DISPLY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AH,13H
MOV AL,01H
MOV BH,00H
MOV BL,ATTRIB
MOV DH,ROW
MOV DL,COL
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
E10DISPLY ENDP
Q10SCROLL PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AH,06H
MOV BH,82H
MOV CX,0000H
MOV DX,184FH
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
Q10SCROLL ENDP
END A10MAIN
9-13.编写指令：（a）改变调色板寄存器2的颜色为白色，（b）改变屏幕边界的颜色为蓝色，
（c）禁止闪烁属性，（d）将256个DAC寄存器都读入一个表中。
在BH中装入颜色值，在BL中装入调色板寄存器编号（00-0FH）：
MOV AX,1000H   ;请求修改调色板寄存器
MOV BH,07H
MOV BL,02H
INT 10H   ;调用中断服务

在BH中放入新的颜色
MOV AX,1001H   ;请求修改边界颜色
MOV BH,01H
INT 10H

在BL中装入代码（00H=禁止，01H=允许）。
MOV AX,1003H
MOV BL,00H
INT 10H   ;调用中断服务

DACTABLE DB 768 DUP (?)   ;表（每个寄存器3字节）
MOV AX,1017H   ;读一组DAC寄存器
MOV BX,0   ;组内第一个DAC寄存器
MOV CX,256   ;组内DAC寄存器数
LEA DX,DACTABLE   ;表（ES:DX）ES是DACTABLE对应的段
INT 10H   ;调用中断服务
9-14.编写指令来改变字符的大小（a）基于文本方式的字符为8×16，（b）基于图形方式的字符为8×14，有25个字符行。
1101H EGA/VGA (load ROM 8x14 font)
1102H EGA/VGA (load ROM 8x8 font)
1104H     VGA (load ROM 8x16 font)

1111H EGA/VGA (load and activate ROM 8x14 font)
1112H EGA/VGA (load and activate ROM 8x8 font)
1114H     VGA (load and activate ROM 8x16 font)

1122H     VGA (ROM 8x14 font for graphics modes)
1123H     VGA (ROM 8x8 font for graphics modes)
1124H     VGA (ROM 8x16 font for graphics modes)

MOV AX,1114H   ;装入8×16文本字符
MOV BL,0   ;字符发生器表的编码0-7
INT 10H

MOV AX,1122H   ;装入8×14图形字符
MOV BL,2   ;每屏的字符行数，1=14行，2=25行，3=43行，0=DL中给定的每屏字符行数
INT 10H   ;调用中断服务
9-15.编写指令将视频BIOS的信息取到一个名为VID_BIOS_TBL的64字节的表中。
VID_BIOS_TBL DB 64 DUP (?)
...
ES为VID_BIOS_TBL对应的段
...
MOV AH,1BH
MOV BX,0
LEA DI,VID_BIOS_TBL
INT 10H
9-16.编写指令设置图形方式的分辨率：（a）320×200，4种颜色，（b）640×200，（C）640×480，16种颜色。
MOV AH,00H
MOV AL,04H
INT 10H

MOV AH,00H
MOV AL,06H
INT 10H

MOV AH,00H
MOV AL,12H
INT 10H
显示方式         类型         显示区         页         分辨率         彩色
04H                彩色         B800            8         320×200         4
05H                彩色         B800            8         320×200         4
06H                彩色         B800            8         640×200         2
0DH               彩色         B800            8         320×200         16
0EH                彩色         A000            4         640×200         16
0FH                单色         A000            2         640×350         1
10H                彩色         A000            2         640×350         16
11H                彩色         A000            1         640×480         2
12H                彩色         A000            1         640×480         16
13H                彩色         A000            1         320×200         256
9-17.编写指令在图形方式下选择背景为红色。
BH=00 选择背景颜色，在BL的0-3位含有颜色值（16种颜色之一）：
MOV AH,0BH
MOV BH,00H
MOV BL,04H   ;红色（选项是00-0FH）
INT 10H   ;调用中断服务
9-18.编写指令在图形方式下从第142行，第264列读一个点。
在BH中设置页号，CX中设置列号，DX中设置行号。
MOV AH,0DH   ;请求读像素点
MOV BH,0   ;页号0
MOV CX,264   ;水平x-坐标（列）
MOV DX,142   ;垂直y-坐标（行）
INT 10H   ;调用中断服务
该操作在AL中返回像素值。
9-19.修改图9-5的程序使之提供下列条件：（a）背景为蓝色，（0）行起始于50，结束于400，（c）列起始于72，结束于568。
.MODEL SMALL
.STACK 512
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
MOV AH,0FH
INT 10H
PUSH AX
CALL B10MODE
CALL C10DISPLY
MOV AH,10H
INT 16H
POP AX
MOV AH,00H
INT 10H
MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10MODE PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,0012H
INT 10H
MOV AH,0BH
MOV BX,0001H
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
B10MODE ENDP
C10DISPLY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV BX,0000H
MOV CX,72
MOV DX,50
C20:MOV AH,0CH
MOV AL,BL
INT 10H
INC CX
CMP CX,568
JNE C20
MOV CX,72
INC BL
INC DX
CMP DX,400
JNE C20
POP DX
POP CX
POP BX
POP AX
RET
C10DISPLY ENDP
END A10MAIN
9-20.在9-19题改写程序的基础上，再将程序修改为：每次显示一个列位置上的（代替行）图形点，也就是说，在屏幕上向下显示点，然后前移到下一列，以此类推。
.MODEL SMALL
.STACK 512
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
MOV AH,0FH
INT 10H
PUSH AX
CALL B10MODE
CALL C10DISPLY
MOV AH,10H
INT 16H
POP AX
MOV AH,00H
INT 10H
MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10MODE PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,0012H
INT 10H
MOV AH,0BH
MOV BX,0001H
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
B10MODE ENDP
C10DISPLY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV BX,0000H
MOV CX,72
MOV DX,50
C20:MOV AH,0CH
MOV AL,BL
INT 10H
INC DX
CMP DX,400
JNE C20
MOV DX,50
INC BL
INC CX
CMP CX,568
JNE C20
POP DX
POP CX
POP BX
POP AX
RET
C10DISPLY ENDP
END A10MAIN
第10章键盘操作
10.1引音
10.2BIOS键盘数据区
10.3键盘输入的INT21H操作
10.4键盘输入的INT16H操作
10.5扩展功能键和扫描码
10.6BIOSINT09H和键盘缓冲区
10.7要点
10.8习题
目的：介绍键盘操作以及键盘输入的高级特性，包括shift键的状态，键盘缓冲区和扫描码。
10.1引言
本章介绍了许多处理键盘输入的操作，其中有些操作具有专门的用途。在这些操作中，INT 21H的功能0AH（已包括在第9章）和INT 16H（包括在本章中）
将提供所需要的几乎是全部的键盘操作。
本章中的其他问题还包括键盘 shift 状态字节、扫描码以及键盘缓冲区。在BIOS键盘数据区中的shift状态字节能够使程序确定诸如Ctrl、Shift或Alt等键是否已被按下。
扫描码是分配给键盘上每一个键的唯一号码，它能使系统识别按键的来源，也能使程序检验按动的键是否是扩展功能键，如Home、PageUp或Arrow。
键盘缓冲区提供存储器空间，以便在程序实际请求输入之前打印预先准备的内容。
本章所包括的操作如下：
INT 21H功能                           INT 16H功能
07H 直接键盘输入，无回显      03H 设置打字速率
08H 键盘输入，无回显             05H 键盘写入缓冲区
0AH 缓冲键盘输入                   10H 读键盘字符
0BH 检验键盘状态                    11H 确定字符是否存在
0CH 清除缓冲区，调用函数      12H 返回键盘Shift状态
1.带回显键盘输入（1号功能调用）功能：从标准输入设备上读一字符，并将该字符回显在标准输出设备上。
通常情况下，标准输入设备就是键盘，标准输出设备就是屏幕。如果键盘无字符可读，则一直等待到有字符可读（即按键）。
入口参数：无。
出口参数：AL=读到字符的代码（ASCII码）。
说明：如果读到的字符是Ctrl+C或Ctrl+Break，则结束程序。
2.不带回显键盘输入（8号功能调用）除读到的输入字符不在屏幕上显示外，同1号功能调用。
3.直接键盘输入（7号功能调用）功能：从标准输入上读一字符。通常情况下，标准输入就是键盘。
如果键盘无字符可读，则一直等待到有字符可读（即按键）。
入口参数：无。
出口参数：AL=读到字符的代码。
说明：（1）不检查读到的字符是否是Ctrl+C或Ctrl+Break。
（2）不回显读到的字符。
4.显示输出（2号功能调用）功能：向标准输出设备写一字符。通常情况下，标准输出设备就是屏幕。
入口参数：DL=要输出的字符（ASCII码）。
出口参数：无。
说明：在显示输出时检查是否按Ctrl+C或Ctrl+Break键，如是则结束程序。
5.直接控制台输入输出（6号功能调用）功能：直接控制台输入输出。
通常情况下，控制台输入就是键盘输入，控制台输出就是屏幕输出。
入口参数：若DL=0FFH，表示输入；否则表示输出，DL=输出字符代码。
出口参数：输入时，ZF=1表示无字符可读；ZF=0表示读到字符，AL=输入字符代码；输出时，无。
说明：（1）在输入时，如无字符可读，并不等待。
（2）不检查Ctrl+C或Ctrl+Break键。
（3）在读到字符时也不回显。
（4）在输入时，如果AL=0，表示用户曾按过一个扩展键，在下一次调用该功能时返回扩展键的扫描码。
（5）在输出时，不解释制表符等特殊控制符。
6.显示字符串（9号功能调用）功能：在标准输出上显示一个字符串。通常情况下，标准输出就是屏幕。
入口参数：DS:DX=需要输出字符串的首地址，字符串以字符'$'为结束标志。
出口参数：无。
说明：在显示输出时检查是否按Ctrl+C或Ctrl+Break键，如是则结束程序。
7.输入字符串（0AH号功能调用）
会把当前输入的内容回显在标准输出设备上
功能：从标准输入上读一个字符串。通常情况下，标准输入就是键盘。
入口参数：DS:DX=缓冲区首地址。
出口参数：接收到的输入字符串在缓冲区中。
说明：（1）缓冲区第一字节置为缓冲区最大容量，可认为是入口参数；
缓冲区第二字节存放实际读入的字符数（不包括回车符），可认为是出口参数的一部分；第三字节开始存放接受的字符串。
（2）字符串以回车键结束，回车符是接受到的字符串的最后一个字符。也就是0DH 回车，不包含0AH 换行
（3）如果输入的字符数超过缓冲区所能容纳的最大字符数，则随后的输入字符被丢弃并且响铃，直到遇回车键为止。
（4）如果在输入时按Ctrl+C或Ctrl+Break键，则结束程序。
8.取键盘输入状态（0BH号功能调用）功能：判别在标准输入设备上是否有字符可读。
入口参数：无。
出口参数：AL=0，表示无字符可读；AL=0FFH，表示有字符可读。
说明：检查是否按Ctrl+C或Ctrl+Break键，如遇这种键，则程序结束。
9.清除输入缓冲区后再输入（0CH号功能调用）
功能：清除输入缓冲区，然后再执行某个输入功能。
入口参数：AL=清除输入缓冲区后要执行的功能号。
出口参数：决定于清除输入缓冲区后执行的功能。
说明：清除缓冲区后执行的功能应是01H、06H、07H、08H或0AH，如不是这样，则不输入。
例如：若AL=0，则在清除输入缓冲区后，没有进一步的处理。

INT 16H 00H: Read (Wait for) Next Keystroke
INT 16H 01H: Query Keyboard Status / Preview Key
INT 16H 02H: Query Keyboard Shift Status
INT 16H 03H: Set Keyboard Typematic Rate and Delay
INT 16H 05H: Store Keystroke Data
INT 16H 10H: Read Extended Keyboard Input
INT 16H 11H: Query Extended Keyboard Status / Preview Key
INT 16H 12H: Query Extended Keyboard Shift Status
键盘提供3种基本类型的键：
1.标准字符，由字母A到Z，数字0到9，以及诸如%、$和#等字符。
2.扩展功能键，包括：
程序功能键，如F1和Shift+F1
带触发开关NumLock键的数字键盘上的键：Home、End、Arrows、Del、Ins、PageUp和PageDown以及它们在扩展键盘上的复制键。
Alt+字母及Alt+程序功能键
3.专用键Alt、Ctrl和Shift，它们通常与其他键如CapsLock、NumLock和ScrollLock等联合工作以指定一个条件。
BIOS不把这些按键作为ASCII字符传送给程序，而是通过修改它们在BIOS键盘数据区中的Shift状态字节的当前状态，来进行不同的处理。
最初的PC机有83个键，它经历了一次缺乏远见的设计，结果使所谓的数字键盘的键执行两个动作。
这样数字与Home、End、Arrows、Del、Ins、PageUp和PageDown 键共用，NumLock键在它们之间来回触发。
为了解决由这种设计带来的问题，设计者为Windows生产了一种有101个键以及后来的104个键的增强型键盘。
在增加的18个键中，只有F11和F12提供了新功能，其余的还是复制原来键盘上键的功能。
0040：17单元存储键盘状态字节，该字节记录了控制键和切换键的状态。
键盘状态字节各位记录的信息如下。
0：右shift状态，置1表示按下右shift键；
1：左shift状态，置1表示按下左shift键；
2：Ctrl状态，置1表示按下Ctrl键；
3：Alt状态，置1表示按下Alt键；
4：ScrollLock状态，置1表示Scroll指示灯亮；
5：NumLock状态，置1表示小键盘输入的是数字；
6：CapsLock状态，置1表示输入大写字母；
7：Insert状态，置1表示处于删除态。
INT 16H 02H returns one byte in the AL register
01H alpha-shift (right side) DOWN
02H alpha-shift (left side) DOWN
04H Ctrl-shift (either side) DOWN
08H Alt-shift  (either side) DOWN
10H ScrollLock state
20H NumLock state
40H CapsLock state
80H Insert state
INT 16H 12H returns 16 bits in the AX register. 
0001H alpha-shift (right side) DOWN
0002H alpha-shift (left side) DOWN
0004H Ctrl-shift (either side) DOWN
0008H Alt-shift  (either side) DOWN
0010H ScrollLock state
0020H NumLock state
0040H CapsLock state
0080H Insert state
0100H Ctrl-shift (left side) DOWN
0200H Alt-shift (left side) DOWN
0400H Ctrl-shift (right side) DOWN
0800H Alt-shift (right side) DOWN
1000H ScrollLock DOWN
2000H NumLock DOWN
4000H CapsLock DOWN
8000H SysReq DOWN

The byte at 0040:0018 is somewhat different from than that returned in AH by INT 16H 12H
01H Ctrl-shift (left side) DOWN
02H Alt-shift (left side) DOWN
04H SysReq DOWN
08H hold/pause state
10H ScrollLock DOWN
20H NumLock DOWN
40H CapsLock DOWN
80H Insert DOWN
10.2BIOS键盘数据区
BIOS数据区在存储器低地址端的段40[0]H，该区包含有很多有用的数据项。其中包括指示控制键当前状态的两个键盘数据区。
键盘数据区1含有两个字节，第一个字节在40：17H，它的各位置为1表示下列含义：
位                  作用                  位         作用
7         Ingert状态变换            3         按动左右Alt键
6         CapsLock状态变换       2         按动左右Ctrl键
5         NumLock状态变换      1         按动左shift键
4         Scroll Lock状态变换     0         按动右shift键
可以使用INT 16H的功能02H（后面会讲到）来检验这些值。“按动”的意思是用户现在正按住键，释放键使BIOS清除这个位的值。
键盘数据区1的第二个字节在40：18H，它的各位设置为1表示下列含义：
位                  作用                  位         作用
7         按动Insert                   3         Ctrl/Numlock（Pause）状态变换
6         按动CapsLock             2         按动SysReq键
5         按动NumLock             1         按动左Alt键
4        按动Scroll Lock            0         按动左Ctrl键
你可以测试这些位，例如，是否按下了Crl键或Alt键，或者这两个键都按下了。
40:0080   2  AT PS/2 keyboard buffer offset start address (usually 001eH)
40:0082   2                                                     end address  (usually 003eH)
40:001e  32  Keyboard buffer.  BIOS stores keystrokes here (head and tail point to addresses from 0040:001eH to 0040:003dH inclusive)
40:0096   1  AT Keyboard flag bit 4=1 (10H) if 101-key keyboard is attached
在40：80H的键盘数据区2用于作键盘缓冲区，后面要讲到这个内容。键盘数据区3驻留在40：96H。当位4为1指示安装了增强型键盘。
键盘数据区的详细讲述可在第24章中找到。
练习：检查Shift状态。装入DEBUG观察按下Ctrl、Alt和Shift键时对Shift状态字节的影响。键入D 40:17来查看两个状态字节的内容。
按下CapsLock、NumLock以及Scroll Lock，再键入D 40:17来查看两个状态字节的内容。
在40:17H的字节应当显示70H（0111 0000），在40:18H的字节可能是00H。在40:96H的字节（位4）显示增强型键盘存在（1）或不存在（0）。
试着改变在40：17H的状态字节中的内容――敲入E 40:17 00。如果键盘的Lock键的指示器是亮着的，那么它们应当是关闭的。
现在再试着敲入E 40:17 70来打开它们。你可以尝试各种组合，虽然当按下Ctrl键或Alt键的时候，敲入一个有效的DEBUG命令是困难的。
键入Q退出DEBUG。
键盘缓冲区
在40：1EH地址的BIOS数据区包含有一块键盘缓冲区，它允许在程序请求键盘输入之前最多键入15个字符。
当你按动一个键时，键盘的处理器自动地产生键的扫描码（它是分配给键唯一的号码）并请求调用BIOS INT 09H。
简单地说，INT 09H例程从键盘取得扫描码，把它转换为ASCII字符，并传送到键盘缓冲区。
随后，INT 16H（最低级的键盘操作）从缓冲区读字符并把它传送给程序。程序不需要请求INT 09H，因为当按动一个键时，处理器会自动执行它。
后面一节详细介绍了INT 09H和键盘缓冲区。
10.3键盘输入的INT 21H操作
本节包括了各种处理键盘输入的INT 21H服务例程。所有这些操作需要AH中放入功能码，并且只接收一个输入字符。
在下面的讨论中，术语“响应Ctrl+Break的请求”的意思是：
如果用户按下Ctrl+Break或Ctrl+C键，系统将终止程序。
10.3.1INT 21H的功能01H：键盘输人有回显
该操作从键盘缓冲区接收一个字符，如果没有输入字符，则等待键盘输入：
MOV AH,01H   ;请求键盘输入
INT 21H
该操作在AL中返回两个状态码之一。
AL=非0的值，说明输入了一个标准的ASCII字符（如字母或数字），并且在屏幕上回显。
AL=0，说明用户已经按动了一个扩展功能键，如Home或F1，AH仍然保留原来的功能码。
这个操作处理扩展功能键不是很巧妙，它试图在屏幕上回显扩展功能键。
为了在AL中获得功能键的扫描码，必须立即重复一次INT 21H操作。本操作也响应Ctrl+Break的请求。
10.3.2INT 21H的功能07H：直接键盘输入无回显
该操作除了输入的字符不在屏幕上回显以及不响应Ctrl+Break的请求外，其工作类似于功能01H。它一般用来键入一个不显现的密码。
10.3.3INT 21H的功能08H：键盘输人无回显
该操作除了输入的字符不在屏幕上回显之外，其工作类似于功能01H。
10.3.4INT 21H的功能0AH：缓冲键盘输人
这个操作已经在第9章详细介绍过了。但是由于它不能接收扩展功能键而局限了它的性能。
10.3.5INT 21H的功能0BH：检验键盘状态
如果键盘缓冲区的输入字符是可用的，该操作在AL中返回FFH；如果没有字符是可用的，返回00H。
注意，这个操作不期待用户按动一个键，它只是简单地检验缓冲区。
10.3.6INT 21H的功能0CH：清空键盘缓冲区并调用子功能
你可以利用这个操作与功能01H、06H、07H、08H或0AH联合工作。在AL中装入所要求的功能：
MOV AH,0CH   ;请求键盘功能
MoV AL,function   ;所要求的子功能
INT 21H
该操作清除键盘缓冲区，执行AL中的功能，并根据功能的要求接收（或等待）一个字符。
这个操作能用于不允许用户提前键入的程序。
10.4键盘输入的INT 16H操作
INT 16H是软件开发人员广泛使用的基本BIOS键盘操作，该操作根据装入AH的功能码提供下面的一些服务例程。
AH    03H
AL    05H
BH    delay code
BL    typematic rate code
Returns: (none)
Info: This sets how soon the keyboard hardware will begin repeating a key and how fast each repeat should occur.
BL delay code:  00H = 250 ms
01H = 500 ms
02H = 750 ms
03H = 1000 ms (1 second)
else (reserved)
BH repeat code: 00H = 30   repeats per second
01H = 26.7 repeats per second
02H = 24   repeats per second
03H = 21.8 repeats per second
...
1fH = 2    repeats per second
10.4.1INT 16H的功能03H：设置打字重复速率
当你按下一个键超过1/2秒时，键盘进入打字模式并自动地重复这个字符。为了改变速率，可以使用如下的功能：
MOV AH,03H   ;设置打字重复速率
MOV AL,05H；请求子功能
MOV BH,repeat_delay   ;起动之前的延迟
MOV BL,repeat_rate   ;重复速度
INT 16H
BH中的repeat_delay值是0=1/4秒，1=1/2秒（就认值），2=3/4秒，3=1秒。
BL中的repeat_rate值的范围是0（最快）到31（最慢）。
10.4.2INT 16H的功能05H：键盘写
该操作允许程序在键盘缓冲区中插入字符，就好象用户按了键一样。ASCII字符装入CL，它的扫描码装入CH。
该操作允许输入字符到缓冲区，直到缓冲区满。如果缓冲区己满，操作设置进位标志和AL为1。
AH    05H
CH    scan code to store
CL    ASCII character code or extended ASCII keystroke
Returns: AL    0=successfully stored
1=not stored (no room in buffer)
10.4.3INT 16H的功能10H：读键盘字符
这个标准的键盘操作为输入字符检验键盘缓冲区。如果键盘缓冲区没有字符存在，它一直等待用户按动一个键。
如果有字符存在，该操作将字符码传送到AL，字符的扫描码传送到AH。
如果按动的字符是一个扩展功能键，如Home或F1，AL中的字符码是00H。
对于增强型的键盘，F11和F12也在AL中返回00H，但是其他的较新的（复制）控制键，如Home和PageUp，则返回E0H。
下面是3种可能：
按键                           AH                  AL
正常的ASCII字符       扫描码              ASCII字符码
扩展功能键                扫描码             00H
扩展复制控制键         扫描码             E0H
程序可以通过测试AL为00H或E0H来判断是否按动了扩展功能码：
MOV AH,10H   ;请求BIOS键盘输入
INT 16H
CMP AL,00H   ;扩展功能键?
JE exit   ;是，则退出
CMP AL,0E0H   ;扩展控制键
JE exit   ;是，则退出
因为这个操作在屏幕上不回显字符，所以程序必须请求一个屏幕显示操作，以达到显示按键的目的。
10.4.4INT16H的功能11H：确定字符是否存在
如果键盘缓冲区存在一个输入字符，该操作清除零标志位，并把字符传送给AL，扫描码传送给AH；输入字符仍保留在缓冲区。
如果键盘缓冲区没有字符，操作设置零标志位并且不等待输入。
注意，该操作提供了一个向前看的特性，因为字符保留在键盘缓冲区，一直要到功能10H来读取它。
10.4.5INT 16H的功能12H：返回键盘 Shift状态
该操作传送BIOS数据区1中地址为40：17H的键盘状态字节到AL，传送40：18H字节到AH。
下面的例子测试AL以判断是否按动了左Shift键（位1）或右Shift键（位0）：
MOV AH,12H   ;请求Shift状态
INT 16H   ;调用中断服务
AND AL,00000011B   ;按动左或右shift键？
JZ exit
...
对AH中的状态字节，各位为1的含义如下：
7         按动SysReg           3   按动右Alt
6         按动Caps Lock       2   按动右Ctr1
5         按动Num Lock      1   按动左Alt
4         按动Scroll Lock      0   按动左Ctrl
键盘练习。这里是一个测试功能12H的简单的DEBUG练习。在DEBUG下，输入命令A 100并键入下列指令：
MOV AH,12
INT 16
JMP 100
确定Lock键都是关闭的。键入命令R、T和P，现在AL应当含有00H。
下一步打开NumLock、CapsLock和ScrollLock键，再重复这3条指令。这时，AL中反映键盘状态的值应当是70H（01110000）。
再关闭Lock键并重复这些指令，但是这次按动P键后停止。当按<回车>时按下CapsLock，AH和AL都应当含有40H（01000000）。
检验Insert键，它的作用像一个触发键。试验用其他组合，然而有一些像Alt+Enter的组合不工作。
INT 16H 12H returns 16 bits in the AX register. 
0001H alpha-shift (right side) DOWN
0002H alpha-shift (left side) DOWN
0004H Ctrl-shift (either side) DOWN
0008H Alt-shift  (either side) DOWN
0010H ScrollLock state
0020H NumLock state
0040H CapsLock state
0080H Insert state
0100H Ctrl-shift (left side) DOWN
0200H Alt-shift (left side) DOWN
0400H Ctrl-shift (right side) DOWN
0800H Alt-shift (right side) DOWN
1000H ScrollLock DOWN
2000H NumLock DOWN
4000H CapsLock DOWN
8000H SysReq DOWN
10.5扩展功能键和扫描码
扩展功能键如F1或Home是请求一个动作而不是传输字符码。在系统设计中没有规定这些键一定要执行一个专门的动作。
作为程序员，你要确定它们的动作，例如按动Home键就将光标设置在屏幕的左上角；
按动End键就将光标设置在屏幕上文本的末尾。你也可以很容易地对这些键编程，使它们执行完全无关的操作。
每个键都有一个设定好的扫描码，从Esc的01开始（参见附录F，一个完整的扫描码表）。
字母         NORMAL         SHIFT         CTRL         ALT
a和A         1E 61               IE 41         1E 01         1E 00
b和B         30 62               30 42        30 02         30 00
c和C         2E 63               2E 43        2E 03          2E 00
d和D         20 64              20 44        20 04          20 00
e和E         12 65               12 45       12 05           12 00
f和F          21 66               21 46       21 06           21 00
g和G        22 67               22 47       22 07           22 00
h和H        23 68               23 48       23 08           23 00
i和I           17 69               17 49       17 09           17 00
j和J           24 6A              24 4A      24 0A           24 00
k和K         25 6B               25 4B      25 0B           25 00
l和L           26 6C              26 4C      26 0C           26 00
m和M       32 6D              32 4D     32 0D           32 00
n和N        31 6E               31 4E      31 0E            31 00
o和O        18 6F               18 4F      18 0F            18 00
p和P         19 70               19 50      19 10           19 00
q和Q         10 71              10 51       10 11           10 00
r和R          13 72               13 52       13 12          13 00
s和S          1F 73               1F 53       1F 13           1F 00
t和T          14 74                14 54      14 14           14 00
u和U         16 75               16 55       16 15           16 00
V和V          2F 76               2F 56       2F 16           2F 00
w和W        11 77               11 57       11 17           11 00
x和X          2D 78               2D 58      2D 18           2D 00
y和Y          15 79               15 59       15 19            15 00
z和Z          2C 7A               2C 5A      2C 1A           2C 00
Spacebar  39 20                39 20       39 20           39 20
F1             3B 00               54 00        5E 00            68 00
F2             3C 00               55 00        5F 00            69 00
F3             3D 00               56 00        60 00            6A 00
F4             3E 00                57 00        61 00            6B 00
F5             3F 00                58 00        62 00            6C 00
F6             40 00                59 00        63 00            6D 00
F7             41 00                5A 00        64 00            6E 00
F8             42 00                5B 00        65 00            6F 00
F9             43 00                5C 00        66 00            70 00
F10           44 00                5D 00        67 00            71 00
F11           85 00                87 00        89 00             8B 00
F12           86 00                88 00        8A 00            8C 00
Ins and 0  52 00                52 30        92 00
End and 1 4F 00                4F 31        75 00             00 01
下箭头 and 2 50 00           50 32        91 00              00 02
PgDn and 3 51 00             51 33        76 00             00 03
左箭头 and 4 4B 00           4B 34        73 00              00 04
5（键区）  4C 00               4C 35       8F 00               00 05
右箭头 and 6 4D 00           4D 36       74 00               00 06
Home and 7 47 00            47 37        77 00              00 07
上箭头 and 8 48 00            48 38       8D 00              00 08
PgUp and 9  49 00            49 39       84  00              00 09
+(灰键)         4E 00            4E 2B       90 00                4E 00
-(灰键)          4A 00            4A 2D      8E 00                4A 00
Del and .      53 00             53 2E       93 00
*(灰键)          37 2A            37 2A       96 00                37 00
`和~             29 60             29 7E                                 29 00
1和!              02 31             02 21                                78 00
2和@            03 32             03 40      03 00                 79 00
3和#             04 33              04 23                               7A 00
4和$             05 34              05 24                               7B 00
5和%            06 35              06 25                               7C 00
6和^             07 36              07 5E      07 1E                7D 00
7和&            08 37               08 26                              7E  00
8和*              09 38              09 2A                              7F  00
9和(              0A 39              0A 38                              80  00
0和)              0B 30              0B 29                               81  00
-和_              0C 2D             0C 5F      0C 1F                82  00
=和+            0D 3D            0D 2B                               83  00
Esc               01 1B              01 1B      01 1B                01 00
Backspace   0E 08              0E 08       0E 7F                0E  00
Tab             0F 09              0F 00       94 00                A5  00
Enter          1C 0D              1C 0D      1C 0A               1C  00
[和{             1A 5B              1A 7B       1A 1B               1A  00
]和}             1B 5D              1B 7D       1B  1D              1B  00
;和:              27 3B               27 3A                                27 00
'和"             28  27              28  22                                28  00
\和|             2B  5C              2B  7C      2B 1C                2B  00
,和<            33  2C              33  3C                                33  00
.和>            34  2E               34  3E                                34  00
/和?            35  2F                35  3F                               35  00
斜线(/)        E0  2F                E0  2F      95 00                A4  00
Del             53  E0                53  E0      93 E0                A3  00
下箭头        50  E0                50  E0      91 E0                A0  00
End             4F E0                4F  E0      75 E0                 9F  00
Enter          E0 0D                E0  0D     E0  0A                A6  00
Home         47 E0                47  E0      77  E0                97  00
Ins              52 E0                 52 E0      92  E0                A2  00
左箭头        4B E0                 4B E0      73  E0                9B  00
PageDown 51 E0                51 E0       76  E0                A1  00
PageUp      49 E0                49 E0       84  E0                99  00
右箭头         4D E0               4D E0      74  E0                9D  00
上箭头         48 E0                48 E0      8D  E0                98  00
尽管BIOS不会将其送入键盘缓冲区，以下的控制键也有定义好的扫描码：
CapsLock         3A
Shift（右）       36
NumLock         45
Alt                    38
ScrollLock         46
Ctrl                   1D
Shift（左）       2A
PrtScreen         37
依靠这些扫描码，程序可以确定任何按键的来源。例如，程序可以利用INT 16H的功能10H来请求输入一个字符。
操作以两个方法之一来响应，这根据按动的是一个字符键还是一个扩展功能键而定。
对于一个字符键，如字母A，操作传送两项值到AX：
AH=字母A的扫描码 1EH AL=字母A的ASCII码（41H）
对有些字符键盘上有两个键，如-、+和*。
例如，按动星号键，AL中设置字符码2AH，AH中是两个扫描码之一，这取决于按动的是哪一个键：
09H是数字8上面的星号，37H是数字键盘旁边的星号。
下例测试扫描码来确定是哪个星号被按动：
CMP AL,2AH   ;星号?
JNE exit1
CMP AH,09H   ;是数字8键上的扫描码?
JE exit2   ;是，则退出
如果按动了扩展功能键，如Del键，则操作传送这样两个值给AX：
AH=Del的扫描码53H AL=00H（数字键盘上的Del），或E0H（增强型键盘上的复制键）
执行INT 16H操作（以及某些INT 21H操作）之后，你可以测试AL。
如果它含有00H或E0H，则是对扩展功能键的中断请求，否则操作将传送一个字符码。
下例是测试扩展功能键的指令：
MOV AH,10H   ;请求键盘输入
INT 16H
CMP AL,00H   ;扩展功能键?
JE exit
CMP AL,0E0H   ;扩展功能键?
JE exit
在下一个例子中，若按动了Home键（扫描码为47H），光标则设置为第0行，第0列：
MOV AH,10H   ;请求键盘输入
INT 16H   ;调用中断服务
CMP AL,00H   ;扩展功能键?
JE L30；是，则跳转
CMP AL,0E0H   ;扩展功能键?
JNE exit
L30:CMP AH,47H   ;Home的扫描码?
JNE exit   ;不是，则退出
MOV AH,02H   ;请求设置光标
MOV BH,00H
MOV DX,0000H   ;在00：00
INT 10H   ;调用中断服务
功能键F1-F10产生的扫描码为3BH-44H，后面的F11和F12产生85H和86H。
下例测试功能键F10：
CMP AH,44H   ;功能键F10?
JE exit   ;是，则退出
1.键盘练习。下面的DEBUG练习检测了键入不同的字符所产生的影响。使用命令A 100来键入这些指令：
MOV AH,10
INT 16
JMP 100
使用P（Proceed）命令来执行INT操作。输入各种常用字符与Shift和Ctrl组合，
将AH（扫描码）和AL（字符码）中的结果与附录F的表比较，然后继续下一个练习。
2.键入全部ASCII字符集。整个ASCII字符集由256个字符组成，字符码从0到255（FFH）。
它们中许多是标准的可显示字符，ASCII码从20H（空格）到7EH（波折号~）。
由于键盘的限制，256个ASCII字符的大多数都不能在键盘上表示出来。
但是你可以按下Alt键来输入从01到255的任何一个ASCII码，并可在数字键盘上输入适当的代码作为十进制数。
系统把你输入的值存储在键盘缓冲区的两个字节中：第一个字节是产生的ASCII字符码，第二个字节是0。
例如，ALt+001 传送的是01H，Alt+255传送的是FFH。
仍然在DEBUG下，用DEBUG的A命令来检验输入不同数据的结果。并对照附录B的完整的ASCII码表。检验AX中的返回值
程序：从菜单中选择
下一个程序显示一个带阴影的菜单。有关解释在第9章，图示在图10-1。
菜单是定义在数据段中的双线框：8行，19个阴影符（0DBH）。用户按动上箭头或下箭头以及回车键来选择菜单中的一项。
对图10-2程序中过程的解释如下：
A10MAIN 调用Q10CLEAR清除屏幕，调用B10MENU显示菜单和提示符，调用D10DISPLY设置第一个菜单项为反相显示，
调用C10INPUT接收键盘输入。
B10MENU显示全部的菜单选择项。它首先使用INT 10H的功能09H来显示阴影框，
然后使用INT 10H的功能13H显示菜单（在数据段定义为MENU，在阴影框的上方，但偏移一行和一列）。
再一次使用功能13H来显示菜单下面的提示信息。
C10INPUT用INT 16H的功能10H来输入：下箭头下移菜单，上箭头上移菜单，回车键接受菜单项，Esc退出，
并忽略输入的其他键。程序使光标是可迥绕的，这样可以尝试一下移动光标将菜单的第一行移动到最后一行，反之亦然。
该程序也调用D10DISPLY 来重新设置先前的菜单为正常显示，而新的（被选择的）菜单是反相显示的。
D10DISPLY根据已提供的属性（正常显示或反相显示）用INT 10H的功能13H来显示当前所选择的菜单项。
Q10CLEAR清除整个屏幕，设置蓝色前景和棕色背景。
.MODEL SMALL
.STACK 512
.DATA
TOPROW EQU 08
BOTROW EQU 15
LEFCOL EQU 26
ATTRIB DB ?
ROW DB 00
SHADOW DB 19 DUP (0DBH)
MENU DB 0C9H,17 DUP (0CDH),0BBH
DB 0BAH,'Add records      ',0BAH
DB 0BAH,'Delete records   ',0BAH
DB 0BAH,'Enter orders     ',0BAH
DB 0BAH,'Print report     ',0BAH
DB 0BAH,'Update accounts  ',0BAH
DB 0BAH,'View records     ',0BAH
DB 0C8H,17 DUP (0CDH),0BCH
PROMPT DB 'To select an item,Use <Up/Down Arrow>'
                DB '  and press <Enter>.'
                DB 0DH,0AH,'Press <Esc> to exit.'
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
CALL Q10CLEAR
A20:CALL B10MENU
MOV BYTE PTR ROW,TOPROW+1
MOV BYTE PTR ATTRIB,16H
CALL D10DISPLY
CALL C10INPUT
CMP AL,1BH
JNE A20
CALL Q10CLEAR
MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10MENU PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV AX,1301H
MOV BX,0060H
LEA BP,SHADOW
MOV CX,19
MOV DH,TOPROW+1
MOV DL,LEFCOL+1
B20:INT 10H
MOV AX,1301H
MOV CX,19
MOV DL,LEFCOL+1
INC DH
CMP DH,BOTROW+2
JNE B20
MOV BYTE PTR ATTRIB,71H
MOV AX,1301H
MOV BH,00H
MOV BL,ATTRIB
LEA BP,MENU
MOV CX,19
MOV DH,TOPROW
MOV DL,LEFCOL
B30:INT 10H
ADD BP,19
MOV AX,1301H
MOV CX,19
MOV DL,LEFCOL
INC DH
CMP DH,BOTROW+1
JNE B30
MOV AX,1301H
MOV BH,00H
MOV BL,ATTRIB
LEA BP,PROMPT
MOV CX,79
MOV DH,BOTROW+4
MOV DL,00H
INT 10H
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
B10MENU ENDP
C10INPUT PROC NEAR
PUSH BX
PUSH CX
PUSH DX
C20:MOV AH,10H
INT 16H
CMP AH,50H
JE C30
CMP AH,48H
JE C40
CMP AL,0DH
JE C90
CMP AL,1BH
JE C90
JMP C20
C30:MOV BYTE PTR ATTRIB,71H
CALL D10DISPLY
INC BYTE PTR ROW
CMP BYTE PTR ROW,BOTROW-1
JBE C50
MOV BYTE PTR ROW,TOPROW+1
JMP C50
C40:MOV BYTE PTR ATTRIB,71H
CALL D10DISPLY
DEC BYTE PTR ROW
CMP BYTE PTR ROW,TOPROW+1
JAE C50
MOV BYTE PTR ROW,BOTROW-1
C50:MOV BYTE PTR ATTRIB,17H
CALL D10DISPLY
JMP C20
C90:POP DX
POP CX
POP BX
RET
C10INPUT ENDP
D10DISPLY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV AX,0
MOV AL,ROW
SUB AL,TOPROW
MOV DI,19
MUL DI
LEA SI,MENU+1
ADD SI,AX
MOV AX,1301H
MOV BH,00H
MOV BL,ATTRIB
MOV BP,SI
MOV CX,17
MOV DH,ROW
MOV DL,LEFCOL+1
INT 10H
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
D10DISPLY ENDP
Q10CLEAR PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,0600H
MOV BH,61H
MOV CX,0000H
MOV DX,184FH
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
Q10CLEAR ENDP
END A10MAIN
这个程序以一个较为简单的方式分析了菜单选择，对应每个选择项整个程序会执行相应的例程。为了更好地理解这个程序，汇编、测试并扩充它。
10.6BIOS INT 09H和键盘缓冲区
键盘有一个8位的Intel 8048处理器，用来判断按下键和释放键，根据这些被按动的键，键盘将其代码送到系统板上另一个8位的处理器Intel 8042。
当按动一个键时，键盘的处理器产生键的扫描码并请求INT 09H。这个中断（在中断向量表的36地址）是指向ROM BIOS中的一个中断处理例程。
这个中断程序从端口96（60H）发出一个输入请求：IN AL,60H。这个BIOS例程读取打描码，
并为了获得相关的ASCII字符（如果有的话）与输入的一个扫描码表进行比较。
该例程将扫描码和相关的ASCII字符组合在一起并传送到键盘缓冲区的两个字节中。图10-3说明了这个过程。
值得注意的是，INT 09H处理键盘数据区中的40：17H、40：18H和40：96H单元的Shift、Alt和Ctrl的状态字节。
虽然按动这些键产生INT 09H调用，该中断例程设置状态字节的相应位，但不传送任何字符到键盘缓冲区。
INT 09H也不处理未定义的按键组合，例如Ctrl+/。
当按动一个键时，键盘处理器自动地产生它的扫描码，并请求INT 09H中断。
当你在1/2秒内放开这个键，它产生第二个扫描码（第一个扫描码的值加上10000000B=80H，即置最高位为1），
并发出另一个INT 09H中断。这第二个扫描码告诉中断例程你已经释放了这个键。
如果你按一个键超过1/2秒，则键盘处理为打字，也就是说，它将自动地重复这个键的操作。
键盘缓冲区需要一个地址（缓冲区的头地址）来告诉INT 16H例程从什么地方读下一个字符，
还需要另一个地址（缓冲区的末尾地址）告诉INT 09H在什么地方存储下一个字符。
40:001a   2  Addr of keyboard buffer head (keystroke at that addr is next)
40:001c   2  Address of keyboard buffer tail
40:001e  32  Keyboard buffer.  BIOS stores keystrokes here (head and tail point to addresses from 041eH to 043dH inclusive).
这两个地址分别是键盘数据区1的偏移地址0040:001AH和0040:001CH。下面说明缓冲区的内容：
地址                  解释
0040:001AH   当前缓冲区的头地址，INT 16H从下一个字节获得字符并送给程序的AX中。
0040:001CH   当前缓冲区的末尾地址，INT 09H将键盘输入的字符存入下一个字节。
0040:001EH   键盘缓冲区的起始地址。该缓冲区包含有16个字（32字节），虽然它还可以更长，缓冲区保存输入的键盘字符及其相应的扫描码。
随后INT 16H将读取每个字符和它的扫描码，然后把它们传送给程序。每个字符和它的扫描码需要2个字节。
当用户键入一个字符，INT 09H前移缓冲区的尾指针。当INT 16H读一个字符时前移头指针。
这样头指针不断地紧跟着尾指针，处理就是循环的。当缓冲区为空时（INT16H已经读取了全部的存储字符），头指针和尾指针指向同一个地址。
在下面的例子中，头指针和尾指针都初始化为0040:001EH。然后键入字符'abc<Enter>'，INT 09H将它们存储在如下地址：
'a'在缓冲区的0040:001EH，它的扫描码1EH在0040:001FH；
'b'在缓冲区的0040:0020H，它的扫描码30H在0040:0021H；
'c'在缓冲区的0040:0022H，它的扫描码2H在0040:0023H；
Enter在0040:0024H，它的扫描码E0H在0040:0025H；
这时，INT 09H前移尾指针到0040:0026H：
程序第一次发出INT 16H，该操作读取“a”及其扫描码，并前移头指针到0040:0020H。一旦程序发出了4次INT 16H，它就读出了全部字符并前移头指针到0040:0026H。
因为尾指针和头指针已经指向同一个地址，所以缓冲区为空。
当键入15个字符，缓冲区就满了，尾指针直接移到了头指针之后。
为了看到这种情况，假设你现在键入了‘fghijklmnopqrs<Enter>'。INT 09H从尾指针所在的0040:0026H字节开始存储字符，循环存储‘<Enter>’在0040:0022H。
现在尾指针前移到0040:0024H，直接在头指针的0040:0026H之后：
这时，INT 09H不再接收任何键入的字符，虽然缓冲区能保存16个字符，但它确实最多只接收了15个字符。
（你能说出这是为什么吗？如果INT09H又接受了一个字符，尾指针将移到和头指针相同的地址，INT 16H将会错误地认定缓冲区是空的。）
Shift、Ctrl和At键
INT 09H也能处理BIOS数据区中40：17H、40：18H和40：96H的键盘状态字节。当按动Shift、Ctrl或Alt键时，BIOS例程设置相应的位为1，
当释放键时，它又清除这些位为0。
要注意的是仅按动一个控制键是不满足INT 16H的要求的，必须按下控制键的同时又按下另一个键，这才会引起一次有效的键盘输入，如Shift+A，Ctrl+F1等（见附录F）。
键盘状态字节反映了控制键的作用。程序可以依靠INT 16H的功能12H来判断是否按动了某一个控制键。
图10-4的程序说明了如何存取和测试在40：17H的状态字节。作为一个惯例，最好通过编程练习，用BIOS中断来存取BIOS数据区，
但是这个程序展示了许多汇编语言的技巧。程序包含有下面几个过程：
A10MAIN等待用户按键。按动回车键通知程序结束，如果不是回车键，程序发出INT 16H的功能12H来取得键盘状态。
如果与一个有效的键一起按动了Shift、Ctrl或Alt键中的一个键，则程序调用B10DISPLY。
B10DISPLY显示按动的控制键的相应信息。
.MODEL SMALL
.STACK 512
.DATA
BIODATA SEGMENT AT 40H
ORG 17H
KBSTATE DB ?
BIODATA ENDS
CR EQU 0DH
LF EQU 0AH
ALTKEY DB 'Alt key pressed  ',CR,LF
CTRLKEY DB 'Ctrl key pressed ',CR,LF
SHIFTKEY DB 'Shift key pressed',CR,LF
.CODE
A10MAIN PROC FAR
MOV AX,BIODATA
MOV ES,AX
A20:MOV AH,10H
INT 16H
CMP AL,0DH
JE A90
MOV BL,ES:KBSTATE
TEST BL,00000011B
JZ A30
LEA BP,SHIFTKEY
CALL D10DISPLY
A30:TEST BL,00000100B
JZ A40
LEA BP,CTRLKEY
CALL D10DISPLY
A40:TEST BL,00001000B
JZ A20
LEA BP,ALTKEY
CALL D10DISPLY
JMP A20
A90:MOV AX,4C00H
INT 21H
A10MAIN ENDP
D10DISPLY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH ES
MOV AX,@data
MOV ES,AX
MOV AX,1301H
MOV BX,0016H
MOV CX,17
MOV DX,1008H
INT 10H
POP ES
POP DX
POP CX
POP BX
POP AX
RET
D10DISPLY ENDP
END A10MAIN
你可以修改这个程序，最好是测试位于40：18H的键盘状态字节。
10.7要点
在BIOS键盘数据区的40：17H和40：18H的Shift状态字节指出如Ctrl、Alt、Shift、CapsLock、NumLock和ScrollLock等键的当前状态。
INT 21H键盘操作提供了在屏幕上回显或不回显、认可或忽略Ctrl+Break以及接收扫描码等多种服务例程。
INT 16H的功能10H提供了从键盘缓冲区接收字符的基本BIOS键盘操作。对字符键，操作传送字符码给AL，键的扫描码给AH。
对于一个扩展功能键，该操作传送00H或E0H给AL，键的扫描码给AH。
扫描码是分配给每一个键的唯一的号码，它能使BIOS识别按键的来源，也能使程序对扩展功能键如Home、PageUp和Arrow等进行检验。
BIOS键盘数据区的40：1EH包含有键盘缓冲区，它允许程序请求输入之前键入最多15个字符。
按下一个键使得键盘处理器产生键的扫描码，并请求INT 09H。释放一个键使其产生第二个扫描码（第一个扫描码加上10000000B=80H，即将其最左边1位置为1），
以通知INT 09H键已经释放。
BIOS INT 09H从键盘取得一个扫描码。该操作用这个扫描码产生一个对应的ASCII字符码，并传送到键盘缓冲区。BIOS也可以设置Ctrl、Alt和Shift键的状态。
10.8习题
10-1.（a）键盘Shift状态的第一个字节在BIOS数据区中的地址是什么？
（b）值00000010的意思是什么？（c）值00001100的意思是什么？
0040:0017H，按下左shift键，按下Ctrl键和Alt键
0040：17单元存储键盘状态字节，该字节记录了控制键和切换键的状态。
键盘状态字节各位记录的信息如下。
0：右shift状态，置1表示按下右shift键；
1：左shift状态，置1表示按下左shift键；
2：Ctrl状态，置1表示按下Ctrl键；
3：Alt状态，置1表示按下Alt键；
4：ScrollLock状态，置1表示Scroll指示灯亮；
5：NumLock状态，置1表示小键盘输入的是数字；
6：CapsLock状态，置1表示输入大写字母；
7：Insert状态，置1表示处于删除态。

INT 16H 12H returns 16 bits in the AX register. 
0001H alpha-shift (right side) DOWN
0002H alpha-shift (left side) DOWN
0004H Ctrl-shift (either side) DOWN
0008H Alt-shift  (either side) DOWN
0010H ScrollLock state
0020H NumLock state
0040H CapsLock state
0080H Insert state
0100H Ctrl-shift (left side) DOWN
0200H Alt-shift (left side) DOWN
0400H Ctrl-shift (right side) DOWN
0800H Alt-shift (right side) DOWN
1000H ScrollLock DOWN
2000H NumLock DOWN
4000H CapsLock DOWN
8000H SysReq DOWN
10-2.描述下列INT 21H键盘输入功能的特性：（a）01H，（b）07H，（c）08H，（（d）0AH。
带回显键盘输入（1号功能调用）功能：从标准输入设备上读一字符，并将该字符回显在标准输出设备上。
通常情况下，标准输入设备就是键盘，标准输出设备就是屏幕。如果键盘无字符可读，则一直等待到有字符可读（即按键）。
入口参数：无。
出口参数：AL=读到字符的代码（ASCII码）。
说明：如果读到的字符是Ctrl+C或Ctrl+Break，则结束程序。
不带回显键盘输入（8号功能调用）除读到的输入字符不在屏幕上显示外，同1号功能调用。
直接键盘输入（7号功能调用）功能：从标准输入上读一字符。通常情况下，标准输入就是键盘。
如果键盘无字符可读，则一直等待到有字符可读（即按键）。
入口参数：无。
出口参数：AL=读到字符的代码。
说明：（1）不检查读到的字符是否是Ctrl+C或Ctrl+Break。
（2）不回显读到的字符。
输入字符串（0AH号功能调用）
会把当前输入的内容回显在标准输出设备上
功能：从标准输入上读一个字符串。通常情况下，标准输入就是键盘。
入口参数：DS:DX=缓冲区首地址。
出口参数：接收到的输入字符串在缓冲区中。
说明：（1）缓冲区第一字节置为缓冲区最大容量，可认为是入口参数；
缓冲区第二字节存放实际读入的字符数（不包括回车符），可认为是出口参数的一部分；第三字节开始存放接受的字符串。
（2）字符串以回车键结束，回车符是接受到的字符串的最后一个字符。也就是0DH 回车，不包含0AH 换行
（3）如果输入的字符数超过缓冲区所能容纳的最大字符数，则随后的输入字符被丢弃并且响铃，直到遇回车键为止。
（4）如果在输入时按Ctrl+C或Ctrl+Break键，则结束程序。
10-3.解释INT 16H的功能11H与功能10H的不同。
INT 16H的功能10H：读键盘输入字符
如果键盘缓冲区没有字符存在，它一直等待用户按动一个键。
如果有字符存在，该操作将字符码传送到AL，字符的扫描码传送到AH。
如果按动的字符是一个扩展功能键，如Home或F1，AL中的字符码是00H。
对于增强型的键盘，F11和F12也在AL中返回00H，但是其他的较新的（复制）控制键，如Home和PageUp，则返回E0H。
下面是3种可能：
按键                           AH                  AL
正常的ASCII字符       扫描码              ASCII字符码
扩展功能键                扫描码             00H
扩展复制控制键         扫描码             E0H
这个操作在屏幕上不回显字符。
INT16H的功能11H：确定字符是否存在
如果键盘缓冲区存在一个输入字符，该操作清除零标志位，并把字符传送给AL，扫描码传送给AH；输入字符仍保留在缓冲区。
如果键盘缓冲区没有字符，操作设置零标志位并且不等待输入。
10-4.提供下列按键的扫描码：（a）End，（b）PageUp，（c）Arrow，（d）功能键F6。
End     4F
PgUp  49
PgDn  51
上箭头 48
下箭头 50
左箭头 4B
右箭头 4D
F6      40
10-5.利用DEBUG来测试输入键的效果。为了输入汇编语句，敲入A 100并键入下列指令：
MOV AH,10
INT 16
JMP 100
用U 100,104来反汇编程序，用P命令来使DEBUG执行INT指令。执行停止，等待输入。
按下一个键并检测AH和AL。继续输入各种不同的键。按下Q退出DEBUG。
10-6.编写指令用INT 16H的功能10H来接收按键，如果是PageDown，设置光标到第0列，第24行。
MOV AH,10H
INT 16H
CMP AH,50H
JNZ exit
MOV AH,02H
MOV BH,00H
MOV DH,18H
MOV DL,00H
INT 10H
exit:
...
10-7.修改图10-2的程序以提供下列功能：（a）将全阴影修改为3/4打点符（B2H）。
（b）初始化清屏后，显示一个提示符，请用户按动F1显示菜单屏幕。
（c）当按动了F1，显示菜单。
（d）允许用户通过按下每项的第一个字符（大写或小写）来选择菜单项。
（e）执行对一项的请求，显示反映这个特殊选择的信息，如“Procedure to Delete Records.”。
（f）在菜单的最后一行加上一项“Exit from program”，允许用户结束处理过程。必须修改过程B10MENU来处理另一行的显示。
.MODEL SMALL
.STACK 512
.DATA
TOPROW EQU 08
BOTROW EQU 16
LEFCOL EQU 26
ATTRIB DB ?
ROW DB 00
SHADOW DB 19 DUP (0B2H)
MENU DB 0C9H,17 DUP (0CDH),0BBH
DB 0BAH,'Add records      ',0BAH
DB 0BAH,'Delete records   ',0BAH
DB 0BAH,'Enter orders     ',0BAH
DB 0BAH,'Print report     ',0BAH
DB 0BAH,'Update accounts  ',0BAH
DB 0BAH,'View records     ',0BAH
DB 0BAH,'Exit from program',0BAH
DB 0C8H,17 DUP (0CDH),0BCH
PROMPT DB 'To select an item,Use <Up/Down Arrow>'
                DB '  and press <Enter>.'
                DB 0DH,0AH,'Press <Esc> to exit.'
PROMPT_MENU DB 'Press <F1> to Display Menu.'
PROMPT_ADD DB 'Procedure to Add Records.       '
PROMPT_DELETE DB 'Procedure to Delete Records.    '
PROMPT_ENTER DB 'Procedure to Enter Orders.      '
PROMPT_PRINT DB 'Procedure to Print Report.      '
PROMPT_UPDATE DB 'Procedure to Update accounts.   '
PROMPT_VIEW DB 'Procedure to View Records.      '
PROMPT_BLANK DB 32 DUP (20H)
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
CALL Q10CLEAR
MOV AX,1301H
MOV BH,00H
MOV BL,71H
LEA BP,PROMPT_MENU
MOV CX,27
MOV DH,BOTROW+4
MOV DL,00H
INT 10H
A50:MOV AH,10H
INT 16H
CMP AH,3BH
JNZ A50
A20:CALL B10MENU
MOV BYTE PTR ROW,TOPROW+1
MOV BYTE PTR ATTRIB,16H
CALL D10DISPLY
CALL C10INPUT
CMP AL,1BH
JNE A20
CALL Q10CLEAR
MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10MENU PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV AX,1301H
MOV BX,0060H
LEA BP,SHADOW
MOV CX,19
MOV DH,TOPROW+1
MOV DL,LEFCOL+1
B20:INT 10H
MOV AX,1301H
MOV CX,19
MOV DL,LEFCOL+1
INC DH
CMP DH,BOTROW+2
JNE B20
MOV BYTE PTR ATTRIB,71H
MOV AX,1301H
MOV BH,00H
MOV BL,ATTRIB
LEA BP,MENU
MOV CX,19
MOV DH,TOPROW
MOV DL,LEFCOL
B30:INT 10H
ADD BP,19
MOV AX,1301H
MOV CX,19
MOV DL,LEFCOL
INC DH
CMP DH,BOTROW+1
JNE B30
MOV AX,1301H
MOV BH,00H
MOV BL,ATTRIB
LEA BP,PROMPT
MOV CX,79
MOV DH,BOTROW+4
MOV DL,00H
INT 10H
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
B10MENU ENDP
C10INPUT PROC NEAR
PUSH BX
PUSH CX
PUSH DX
C20:MOV AH,10H
INT 16H
CMP AH,50H
JE C30
CMP AH,48H
JE C40
CMP AH,1EH
JE C60A
CMP AH,20H
JE C60D
CMP AH,12H
JE C60E
CMP AH,19H
JE C60P
CMP AH,16H
JE C60U
CMP AH,2FH
JE C60V
CMP AL,0DH
JE C80
CMP AL,1BH
JE C90
JMP C20
C30:MOV BYTE PTR ATTRIB,71H
CALL D10DISPLY
INC BYTE PTR ROW
CMP BYTE PTR ROW,BOTROW-1
JBE C50
MOV BYTE PTR ROW,TOPROW+1
JMP C50
C40:MOV BYTE PTR ATTRIB,71H
CALL D10DISPLY
DEC BYTE PTR ROW
CMP BYTE PTR ROW,TOPROW+1
JAE C50
MOV BYTE PTR ROW,BOTROW-1
JMP C50
C60A:MOV BYTE PTR ATTRIB,71H
CALL D10DISPLY
MOV BYTE PTR ROW,TOPROW+1
JMP C50
C60D:MOV BYTE PTR ATTRIB,71H
CALL D10DISPLY
MOV BYTE PTR ROW,TOPROW+2
JMP C50
C60E:MOV BYTE PTR ATTRIB,71H
CALL D10DISPLY
MOV BYTE PTR ROW,TOPROW+3
JMP C50
C60P:MOV BYTE PTR ATTRIB,71H
CALL D10DISPLY
MOV BYTE PTR ROW,TOPROW+4
JMP C50
C60U:MOV BYTE PTR ATTRIB,71H
CALL D10DISPLY
MOV BYTE PTR ROW,TOPROW+5
JMP C50
C60V:MOV BYTE PTR ATTRIB,71H
CALL D10DISPLY
MOV BYTE PTR ROW,TOPROW+6
JMP C50
C50:MOV BYTE PTR ATTRIB,17H
CALL D10DISPLY
JMP C20
C80:CMP BYTE PTR ROW,TOPROW+1
JE C80A
CMP BYTE PTR ROW,TOPROW+2
JE C80D
CMP BYTE PTR ROW,TOPROW+3
JE C80E
CMP BYTE PTR ROW,TOPROW+4
JE C80P
CMP BYTE PTR ROW,TOPROW+5
JE C80U
CMP BYTE PTR ROW,TOPROW+6
JE C80V
CMP BYTE PTR ROW,TOPROW+7
JE C80EXIT
JMP C20
C80A:MOV AX,1301H
MOV BH,00H
MOV BL,71H
LEA BP,PROMPT_ADD
MOV CX,32
MOV DH,BOTROW+3
MOV DL,LEFCOL
INT 10H
push dx
mov dx,5000h
call delay
pop dx
MOV AX,1301H
MOV BH,00H
MOV BL,61H
LEA BP,PROMPT_BLANK
MOV CX,32
MOV DH,BOTROW+3
MOV DL,LEFCOL
INT 10H
JMP C20
C80D:MOV AX,1301H
MOV BH,00H
MOV BL,71H
LEA BP,PROMPT_DELETE
MOV CX,32
MOV DH,BOTROW+3
MOV DL,LEFCOL
INT 10H
push dx
mov dx,5000h
call delay
pop dx
MOV AX,1301H
MOV BH,00H
MOV BL,61H
LEA BP,PROMPT_BLANK
MOV CX,32
MOV DH,BOTROW+3
MOV DL,LEFCOL
INT 10H
JMP C20
C80E:MOV AX,1301H
MOV BH,00H
MOV BL,71H
LEA BP,PROMPT_ENTER
MOV CX,32
MOV DH,BOTROW+3
MOV DL,LEFCOL
INT 10H
push dx
mov dx,5000h
call delay
pop dx
MOV AX,1301H
MOV BH,00H
MOV BL,61H
LEA BP,PROMPT_BLANK
MOV CX,32
MOV DH,BOTROW+3
MOV DL,LEFCOL
INT 10H
JMP C20
C80P:MOV AX,1301H
MOV BH,00H
MOV BL,71H
LEA BP,PROMPT_PRINT
MOV CX,32
MOV DH,BOTROW+3
MOV DL,LEFCOL
INT 10H
push dx
mov dx,5000h
call delay
pop dx
MOV AX,1301H
MOV BH,00H
MOV BL,61H
LEA BP,PROMPT_BLANK
MOV CX,32
MOV DH,BOTROW+3
MOV DL,LEFCOL
INT 10H
JMP C20
C80U:MOV AX,1301H
MOV BH,00H
MOV BL,71H
LEA BP,PROMPT_UPDATE
MOV CX,32
MOV DH,BOTROW+3
MOV DL,LEFCOL
INT 10H
push dx
mov dx,5000h
call delay
pop dx
MOV AX,1301H
MOV BH,00H
MOV BL,61H
LEA BP,PROMPT_BLANK
MOV CX,32
MOV DH,BOTROW+3
MOV DL,LEFCOL
INT 10H
JMP C20
C80V:MOV AX,1301H
MOV BH,00H
MOV BL,71H
LEA BP,PROMPT_VIEW
MOV CX,32
MOV DH,BOTROW+3
MOV DL,LEFCOL
INT 10H
push dx
mov dx,5000h
call delay
pop dx
MOV AX,1301H
MOV BH,00H
MOV BL,61H
LEA BP,PROMPT_BLANK
MOV CX,32
MOV DH,BOTROW+3
MOV DL,LEFCOL
INT 10H
JMP C20
C80EXIT:MOV AL,1BH
C90:POP DX
POP CX
POP BX
RET
C10INPUT ENDP
D10DISPLY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV AX,0
MOV AL,ROW
SUB AL,TOPROW
MOV DI,19
MUL DI
LEA SI,MENU+1
ADD SI,AX
MOV AX,1301H
MOV BH,00H
MOV BL,ATTRIB
MOV BP,SI
MOV CX,17
MOV DH,ROW
MOV DL,LEFCOL+1
INT 10H
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
D10DISPLY ENDP
Q10CLEAR PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,0600H
MOV BH,61H
MOV CX,0000H
MOV DX,184FH
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
Q10CLEAR ENDP
DELAY PROC NEAR
push ax
push dx
mov ax,0
delay_s:sub ax,1
sbb dx,0
cmp ax,0
jne delay_s
cmp dx,0
jne delay_s
pop dx
pop ax
ret
DELAY ENDP
END A10MAIN
10-8.在什么情况下会产生INT 09H的操作？
键盘有一个8位的Intel 8048处理器，用来判断按下键和释放键，当按动一个键时，键盘处理器自动地产生它的扫描码，并请求INT 09H中断。
当你在1/2秒内放开这个键，它产生第二个扫描码（第一个扫描码的值加上10000000B=80H，即置最高位为1），
并发出另一个INT 09H中断。这第二个扫描码告诉中断例程你已经释放了这个键。
如果你按一个键超过1/2秒，则键盘处理为打字，也就是说，它将自动地重复这个键的操作。
10-9.用简单的术语来解释INT 09H处理Alt和Ctrl键与处理标准键盘的键的不同之处。
标准键盘的键
INT 09H从端口60H读取扫描码，与一个扫描码表进行比较，获得对应的ASCII字符，
将扫描码和相关的ASCII字符组合在一起，传送到键盘缓冲区的两个字节中。
Shift、Ctrl和Alt键
INT 09H修改BIOS数据区中的键盘状态字节（0040:0017H、0040:0018H），不传送任何字符到键盘缓冲区。
当按动Shift、Ctrl或Alt键时，INT 09H设置键盘状态字节的相应位为1，当释放键时，它又清除这些位为0。
10-10.（a）键盘缓冲区在BIOS存储器中的地址是什么？（b）缓冲区的大小是多少字节？（c）缓冲区能够包含多少键盘字符？
地址                  解释
0040:001AH   当前缓冲区的头地址，INT 16H从下一个字节获得字符并送给程序的AX中。
0040:001CH   当前缓冲区的末尾地址，INT 09H将键盘输入的字符存入下一个字节。
0040:001EH   键盘缓冲区的起始地址。该缓冲区包含有16个字（32字节），缓冲区保存输入的键盘字符及其相应的扫描码。
当用户键入一个字符，INT 09H前移缓冲区的尾指针。当INT 16H读一个字符时前移头指针。
这样头指针不断地紧跟着尾指针，处理就是循环的。当缓冲区为空时，头指针和尾指针指向同一个地址。
当键入15个字符，缓冲区就满了，尾指针直接移到了头指针之后。
虽然缓冲区能保存16个字符，但它确实最多只接收了15个字符。
如果INT 09H又接受了一个字符，尾指针将移到和头指针相同的地址，INT 16H将会错误地认定缓冲区是空的。
10-11.解释在键盘缓冲区发生下列情况所带来的影响：（a）尾指针的地址紧跟着头指针。（b）头指针的地址和尾指针的地址相同。
缓冲区满了 INT 09H无法把新键入的字符保存到键盘缓冲区中
缓冲区为空 INT 16H无法从键盘缓冲区中读取到键入的字符
10-12.按下列要求修改图10-4的程序：（a）传送键盘Shift 状态的第二个字节的内容到BH。（b）测试按动左Alt和左Ctrl键，并显示适当的信息。
.MODEL SMALL
.STACK 512
.DATA
BIODATA SEGMENT AT 40H
ORG 17H
KBSTATE DB ?
KBSTATEH DB ?
BIODATA ENDS
CR EQU 0DH
LF EQU 0AH
ALTKEY DB 'Alt key pressed  ',CR,LF
CTRLKEY DB 'Ctrl key pressed ',CR,LF
SHIFTKEY DB 'Shift key pressed',CR,LF
LEFTALT DB 'Left Alt pressed ',CR,LF
LEFTCTRL DB 'Left Ctrl pressed',CR,LF
STR_BLANK DB 80 DUP (20H)
.CODE
A10MAIN PROC FAR
MOV AX,BIODATA
MOV ES,AX
A20:MOV AH,10H
INT 16H
CMP AL,0DH
JE A90
LEA BP,STR_BLANK
MOV BX,0006H
MOV CX,80
MOV DX,1000H
CALL D10DISPLY
LEA BP,STR_BLANK
MOV BX,0006H
MOV CX,80
MOV DX,1100H
CALL D10DISPLY
MOV BH,ES:KBSTATEH
MOV BL,ES:KBSTATE
MOV DI,BX
TEST BL,00000011B
JZ A30
LEA BP,SHIFTKEY
MOV BX,0016H
MOV CX,17
MOV DX,1008H
CALL D10DISPLY
A30:MOV BX,DI
TEST BL,00000100B
JZ A40
LEA BP,CTRLKEY
MOV BX,0016H
MOV CX,17
MOV DX,101BH
CALL D10DISPLY
A40:MOV BX,DI
TEST BL,00001000B
JZ A50
LEA BP,ALTKEY
MOV BX,0016H
MOV CX,17
MOV DX,102EH
CALL D10DISPLY
A50:MOV BX,DI
TEST BH,00000001B
JZ A60
LEA BP,LEFTCTRL
MOV BX,0016H
MOV CX,17
MOV DX,111BH
CALL D10DISPLY
A60:MOV BX,DI
TEST BH,00000010B
JZ A70
LEA BP,LEFTALT
MOV BX,0016H
MOV CX,17
MOV DX,112EH
CALL D10DISPLY
A70:JMP A20
A90:MOV AX,4C00H
INT 21H
A10MAIN ENDP
D10DISPLY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH ES
MOV AX,@data
MOV ES,AX
MOV AX,1301H
INT 10H
POP ES
POP DX
POP CX
POP BX
POP AX
RET
D10DISPLY ENDP
END A10MAIN
第四部分数据操作
第11章处理串数据
11.1引言
11.2串操作的特点
11.3MOVS：串传送指令
11.4LODS：从串取指令
11.5STOS；存入串指令
11.6程序：使用LODS和STOS编辑数据
11.7CMPS：串比较指令
11.8SCAS：串扫描指令
11.9串指令的另种编码
11.10复制种模式
11.11要点
11.12习题
目的：说明用于处理串数据的专用指令
11.1引言
到本章为止，已提供的指令所处理的数据都是只按一个字节、字或双字定义的，但是，我们经常需要传送和比较超过这些长度的数据字段。
例如，你可能要比较货名或名字，目的是把它们排序成升序序列。这种类型的项称为串数据，并且可以是字符或数字格式。汇编语言为处理串数据提供以下串指令：
MOVS 把一个字节、字或双字从存储器的一个单元传送到另一个单元。
LODS 从存储器取一个字节送到AL，取一个字送到AX，或取个双字送到EAX。
STOS 把AL，AX，或EAX的内容存入存储器。
CMPS 比较在存储器中的字节、字或双字的项。
SCAS 把AL，AX，或EAX的内容和存储器中的一个项的内容进行比较。
一种相关联的指令前缀REP使串指令重复执行，使它可以按指定的次数处理任意数量的字节、字或双字。
另外两条串指令INS和OUTS将在第24章介绍。
11.2串操作的特点
每条串指令有字节、字和双字形式来做重复处理，并且成对使用ES:DI或DS:SI寄存器。
因此，你可以对具有奇数字节的串选择字节操作，而对于具有偶数字节的串选择字操作。
使用字和双字操作可以提供更快的处理速度。
串指令希望DI和SI寄存器包含有效的偏移地址，用它去引用存储器中的字节。
SI通常和DS（数据段）联系在一起成为DS:SI，而DI总是和ES（附加段）联系在一起成为ES:DI。
由于这个原因，MOVS、STOS、CMPS和SCAS通常要求.EXE程序初始化ES，但这不是必须的，它可以用DS中的同样的地址：
MOV AX,@data
MOV DS,AX
MOV ES,AX
操作         基本指令         隐含操作数         字节操作         字操作         双字操作
Move       MOVS            ES:DI,DS:SI         MOVSB         MOVSW      MOVSD
Load        LODS               AX,DS:SI            LODSB          LODSW       LODSD
Store       STOS              ES:DI,AX             STOSB           STOSW       STOSD
Compare CMPS            DS:SI,ES:DI          CMPSB          CMPSW       CMPSD
Scan        SCAS             ES:DI,AX              SCASB           SCASW        SCASD
正如图11-1所示，基本上有两种方法用来编写串指令：
（1）第2列表示的是每个操作的基本格式，这种格式使用在第3列中列出的隐含操作数。
（如果你编一条MOVS指令，会包括一些操作数，比如MOVS BYTE1,BYTE2，其中操作数的定义指明传送的长度）。
后面“串指令的另一种编码”一节会更详细地讨论这个格式。
（2）第二种编写串指令的方法是标准的做法，如第4、第5和第6列所示。
把操作数地址装入DI和SI中，并编写不带操作数的指令，例如：
LEA DI,BYTE2   ;BYTE2的地址（ES:DI）
LEA SI,BYTE1   ;BYTE1的地址（DS:SI）
MOVSB   ;把BYTE1传送到BYTE2
REP：重复串前缀
REP前缀直接放在串指令的前面，如REP MOVSB，它根据你在CX中设置的初始计数值重复地执行。
REP执行串指令，CX减1，并且重复这一操作直到CX中的计数值为零为止。用这种方法，实际上可以处理任意长度的串。
方向标志（DF）决定重复操作的方向：
从左到右的处理，使用CLD把DF清除为0。
从右到左的处理，使用STD把DF置成1。
在以下的例子中，假设DS和ES都是用数据段地址初始化了的，如前所示，
REP MOVSB操作把SEND_STR的20个字节复制到RECV_STR：
SEND_STR DB 20 DUP ('*')   ;发送字段
RECV_STR DB 20 DUP (20H)   ;接收字段
CLD   ;清除方向标志
MOV CX,20   ;初始化为20个字节
LEA DI,RECV_STR   ;接收地址（ES:DI）
LEA SI,SEND_STR   ;发送地址（DS:SI）
REP MOVSB   ;把 SEND_STR复制到RECV_STR
MOVS，LODS，以及STOS总是完全重复指定的次数。
但是，CMPS和SCAS则是做比较并设置状态标志，以至操作能在找到指定条件后立即结束。
为此目的，CMPS和SCAS使用REP的变种如下：
REP：重复该操作直到CX减到零为止。
REPE或REPZ：当零标志（ZF）指出相等/为零时，重复该操作；当ZF指出不相等不为零或CX减到零时，停止重复。
REPNE 或REPNZ：当ZF指出不相等/不为零时，重复该操作；当ZF指出相等/为零或当CX减到零时，停止重复。
下面各节要详细分析各种串操作。
11.3MOVS：串传送指令
MOVSB，MOVSW，以及MOVSD和REP前缀组合在一起，并且长度在CX中，可以传送指定数量的字符。
段：偏移寄存器对于接收串，是ES:DI；对于发送串，是DS:SI。
因此，在.EXE程序的起点，一定要把ES和DS一起初始化，并且在执行MOVS以前，也要初始化DI和SI。
根据方向标志，MOVS使DI和SI对于字节是加1或减1，对于字是加2或减2，对于双字则是加4或减4。
下面的例子说明12个字的传送：
MOV CX,12   ;字数
LEA DI,RECV_STR   ;RECV_STR的地址（ES:DI）
LEA SI,SEND_STR   ;SEND_STR的地址（DS:SI）
CLD
REP MOVSW   ;传送12个字
等效于REP MOVSW操作的指令是：
JCXZ L40   ;若CX最初为零则绕过
L30:MOV AX,DS:[SI]   ;从SEND_STR取字
MOV ES:[DI],AX   ;把字存入RECV_STR
ADD DI,2   ;为下个字增量
ADD SI,2
LOOP L30
L40:
...
在较早的时候，图6-2已说明了9字节字段的传送，为此目的，该程序也可以使用MOVSB。
在图11-2的部分程序中，ES是被初始化的，这是由MOVS指令所要求的。
该程序使用MOVSB传送12个字节的字段STRING1到STRING2，每次一个字节。第一条指令CLD清除方向标志，
使MOVSB从左到右处理数据。在开始执行时，方向标志通常是0，这里CLD的编码是作为一种预防措施。
MOV指令用12（STRING1和STRING2的长度）初始化CX，两条LEA指令是把STRING1和STRING2的偏移地址分别装入SI和DI。
现在REP MOVSB完成以下操作：
把STRING1的最左边字节（按DS:SI寻址）传送到STRING2的最左边字节（按ES:DI寻址）；
为下一个右边的字节将DI和SI加1；
CX减1；
重复这一操作12次，直到CX变成0为止。
由于方向标志是0并且MOVSB使DI与SI加1，所以每次迭代处理右边一个字节，如STRING1+1到STRING2+1，等等。
在执行结束时，CX的内容是0，DI的内容是 STRING2+12的地址，而SI的内容是STRINGl+12的地址，
二者都包含超过名字末尾的一个字节（即指向串所定义的数据项后的第一个字节）。
为了从右到左地处理，要把方向标志置成1。然后MOVSB使DI和SI减1，但为了正确地传送内容，
你必须用STRING1+11初始化SI，用STRING2+11初始化DI。
接下去的程序使用MOVSW从STRING2到STRING3传送6个字。
在执行结束时，CX是0，DI是STRING3+12的地址，SI则是STRING2+12的地址。
因为MOVSW使DI和SI加2，该操作只要求重复6次。
为了从右到左处理过程，要置方向标志，并用STRING1+10初始化SI，用STRING2+10初始化DI。
STRING1 DB 'Interstellar'
STRING2 DB 12 DUP (20H)
STRING3 DB 12 DUP (20H)
MOV AX,@data
MOV DS,AX
MOV ES,AX
CLD
MOV CX,12
LEA DI,STRING2
LEA SI,STRING1
REP MOVSB
CLD
MOV CX,6
LEA DI,STRING3
LEA SI,STRING2
REP MOVSW
11.4LODS：从串取指令
LODS简单地从存储器取一个字节装入AL，取一个字装入AX，取一个双字装入EAX。
尽管可以不考虑SI，但存储器地址还是受DS:SI寄存器支配的。
根据方向标志，该操作使SI加1或减1（对于字节），加2或减2（对于字），加4或减4（对于双字）。
因为一个LODS操作填满了寄存器，所以没有什么实际理由要在它前面使用REP前缀。
对于大多数用途，简单的MOV指令已经可以满足要求。
但是MOV产生3个字节的机器码；而LODS却只产生一个字节的机器码，尽管你必须初始化SI。
你可以使用LODS，每次一个字节、一个字或一个双字步进地通过一个串，对一个特殊的字符进行逐次地检查。
等效于LODSB的指令是：
MOV AL,DS:[SI]   ;把字节传送到AL
INC SI   ;为下一个字节增1
下面的例子定义一个名为STRING1的12字节的字段和名为STRING2的另一个12字节的字段，
STRING1包含的值为“Interstellar”。目的是以相反的顺序把STRING1的字节传送到STRING2，
使得STRING2含有“ralletsretnl”。LODSB每次从STRING1取一个字节送入AL，而MOV [DI],AL则把该字节传送到STRING2，
方向是从右到左。
STRING1 DB 'Interstellar'
STRING2 DB 12 DUP (20H)
CLD
MOV CX,12
LEA SI,STRING1
LEA DI,STRING2+11
L20:LODS
MOV ES:[DI],AL
DEC DI
LOOP L20
...
11.5STOS：存入串指令
STOS把AL、AX或EAX的内容存入存储器中的一个字节、个字或一个双字。
存储器地址总是受ES:DI支配的。根据方向标志，STOS使DI加1或减1（对于字节），
加2或减2（对于字），加4或减4（对于双字）。
带REP前缀的STOS的实际用法是把数据区初始化为任意指定值，比如把一个区域清除成为空白。
把字节、字或双字的数量设置在CX中，等效于REP STOSB的指令是：
JCXZ L30   ;若CX为零则转移
L20:MOV ES:[DI],AL   ;AL存入存储器
INC/DEC DI   ;增量或减量（设置标志）
LOOP L20   ;CX减量并重复
L30:
...
在以下的例子中，STOSW指令重复6次把含有2020H（空白）的字存储到STRING1中。
该操作把AL存入第一个字节，而把AH存入下一个字节（即相反顺序）。
最后，所有 STRING1都是空白，CX是0，而DI则是STRING1+12的地址。
CLD
MOV AX,2020H
MOV CX,6
LEA DI,STRING1
REP STOSW
11.6程序：使用LODS和STOS编辑数据
图11-3的程序说明LODS和STOS两条指令的用法，其目的是允许用户编辑字符串。
为了减少所需时间与复杂性，所以这是一个梗概的编辑程序。基本上，程序是显示一个30个字符的字符串。过程实现如下：
A10MAIN初始化可寻址性（addresability），调用Q30DISPLY显示串，
并且调用B10KEYBRD请求键盘字符。当用户按<Esc>键时，程序结束。
.MODEL SMALL
.STACK 512
.DATA
INDENT EQU 24
LEFTLIM EQU 0
RIGHTLIM EQU 29
NOCHARS EQU 30
COL DB 0
ROW DB 10
DATASTR DB 'abcdefghijklmno'
                 DB 'pqrstuvwxyzABCD',20H
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
CALL Q10CLEAR
CALL Q20CURSOR
CALL Q30DISPLY
A30:CALL Q20CURSOR
CALL B10KEYBRD
CMP AH,01H
JNE A30
CALL Q10CLEAR
MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10KEYBRD PROC NEAR
MOV AH,10H
INT 16H
CMP AL,00H
JE B20
CMP AL,0E0H
JE B20
CALL H10CHARS
JMP B90
B20:CMP AH,4DH
JNE B30
CALL C10RTARRW
JMP B90
B30:CMP AH,4BH
JNE B40
CALL D10LFARRW
JMP B90
B40:CMP AH,53H
JNE B50
CALL E10DELETE
JMP B90
B50:CMP AH,47H
JNE B60
CALL F10HOME
JMP B90
B60:CMP AH,4FH
JNE B90
CALL G10END
JMP B90
B90:RET
B10KEYBRD ENDP
C10RTARRW PROC NEAR
CMP BYTE PTR COL,RIGHTLIM
JAE C20
INC BYTE PTR COL
JMP C90
C20:CALL F10HOME
C90:RET
C10RTARRW ENDP
D10LFARRW PROC NEAR
CMP BYTE PTR COL,LEFTLIM
JBE D20
DEC BYTE PTR COL
JMP D90
D20:CALL G10END
D90:RET
D10LFARRW ENDP
E10DELETE PROC NEAR
PUSHF
MOV BX,0
MOV BL,COL
PUSH BX
LEA DI,[DATASTR+BX]
LEA SI,[DATASTR+BX+1]
CLD
E20:LODSB
STOSB
CALL Q40DISCHR
INC BYTE PTR COL
CALL Q20CURSOR
CMP BYTE PTR COL,RIGHTLIM
JBE E20
POP BX
MOV COL,BL
POPF
RET
E10DELETE ENDP
F10HOME PROC NEAR
MOV BYTE PTR COL,LEFTLIM
CALL Q20CURSOR
RET
F10HOME ENDP
G10END PROC NEAR
MOV BYTE PTR COL,RIGHTLIM
CALL Q20CURSOR
RET
G10END ENDP
H10CHARS PROC NEAR
CMP AL,20H
JB H90
CMP AL,7EH
JA H90
MOV BX,0
MOV BL,COL
LEA DI,DATASTR
MOV [DI+BX],AL
CALL Q40DISCHR
CMP BYTE PTR COL,RIGHTLIM
JAE H90
INC BYTE PTR COL
H90:RET
H10CHARS ENDP
Q10CLEAR PROC NEAR
MOV AX,0600H
MOV BH,61H
MOV CX,0000H
MOV DX,184FH
INT 10H
RET
Q10CLEAR ENDP
Q20CURSOR PROC NEAR
MOV AH,02H
MOV BH,00H
MOV DH,ROW
MOV DL,COL
ADD DL,INDENT
INT 10H
RET
Q20CURSOR ENDP
Q30DISPLY PROC NEAR
MOV AX,1301H
MOV BX,0016H
LEA BP,DATASTR
MOV CX,NOCHARS+1
MOV DH,ROW
MOV DL,COL
ADD DL,INDENT
INT 10H
RET
Q30DISPLY ENDP
Q40DISCHR PROC NEAR
MOV AH,0AH
MOV BH,00H
MOV CX,1
INT 10H
RET
Q40DISCHR ENDP
END A10MAIN
B10KEYBRD接受键盘字符：如果按<RightArrow>键，则调用C10RTARRW；如果按<LeftArrow>键，则调用D10LFARRW；
如果按<Del>键，则调用E10DELETE；如果按<Home>键，则调用F10HOME；如果按<End>键，则调用G10END；否则，对于所有其他字符调用H10CHARS。
C10RTARRW向右移动光标；如果光标已经在最右边了，那就调用F10HOME。
D10LFARRW向左移动光标；如果光标已经在最左边了，那就调用G10END。
E10DELETE用当前字符右边的一个字符来取代当前字符，并且左移所有其他右边的字符。右边最远的字符用一个空格填补。
F10HOME把光标设置在最左边。
G10END把光标设置在最右边。
H10CHARS绕过任一个低于20H或高于7EH的字符；
如果按<Home>键，则把光标置向左边；如果按<End>键，则把光标置向右边；其他情况下，取代在串和屏幕上的字符。
改进这一程序的一些方法包括：
在方框的窗口内显示串。
使<lns>成为一个开关键，以便字符能够取代（像现在所做的那样）或插入（把右边的字符向右挤）。
这类程序有一个复杂的问题，就是要保证你修改的文本与屏幕上的数据一致。你可能要去做把数据直接传送到视频显示区的实验。
11.7CMPS：串比较指令
CMPS比较一个存储单元（按DS:SI寻址）的内容和另一个存储单元（按ES:DI寻址）的内容。
根据方向标志，CMPS使SI和D1加1或减1（对于字节），加2或减2（对于字），以及加4或减4（对于双字）。
在进行了成功地比较或当REP使CX减到0时，操作结束。根据比较的结果，该操作设置AF，CF，OF，PF，SF，以及ZF标志（如果有的话）。
当CMPS和REPnn前缀相组合时，并且长度是在CX中，它可以比较任意长度的串。
3个CMPS操作对于字节是CMPSB，对于字是CMPSW，对于双字是CMPSD。
注意，CMP是操作数2比较操作数1，而CMPS则是操作数1比较操作数2。另外，CMPS提供的是字母数字的比较，即按ASCII值进行比较。
该操作不适于代数比较，因为它们是由带符号的数字值组成的。
考虑比较包含“Jean”和“Joan”的两个串。从左到右进行比较，每次一个字节，结果如下：
J:J相等
e:o不相等（e是低的）
a:a相等
n:n相等
完整的4个字节的比较是随着“n”和“n”的比较而结束的（相等）。
现在由于两个名字是不相同的，所以在两个不同的字符之间做比较时，操作就应该立刻结束。
为此目的，REP的变种REPE（相等时重复）只要所做的是两个相等字符之间的比较，操作就重复进行，或者直到CX减到0为止。
重复单个字节比较的编码是REPE CMPSB。
下面是使用CMPSB的两个例子。第一个例子比较STRING1和STRING2，它们包含相同的12个字节值。
因此，CMPSB操作要为完整的12个字节而继续下去。
在执行结束时，CX的内容是0，DI的内容是STRING2+12的地址，SI的内容是STRING1+12的地址，符号标志是正的，
并且零标志指明相等/零。
STRING1 DB 'Interstellar'
STRING2 DB 'Interstellar'
STRlNG3 DB 12 DUP (20H)
CLD
MOV CX,12
LEA DI STRING2
LEA SI,STRING1
REPE CMPSB
JNE exit
...
第二个例子比较STRING2和STRING3，它们含有不同的值。CMPSB操作在比较第一个字节之后就结束，
并且结果形成高于/不等于条件：CX的内容是11，DI的内容是STRING3+1的地址，SI的内容是STRING2+1的地址，
符号标志是正的，并且零标志指明不相等。
CLD
MOV CX,12   ;为12字节初始化
LEA DI,STRING3
LEA SI,STRING2
REPE CMPSB   ;比较STRING2,STRING3
JE exit
...
警告！这些例子使用CMPSB每次一个字节地比较数据。如果你使用CMPSW每次以字为单位比较数据，
那么你就必须把CX初始化为5，但那是不成问题的。当对字进行比较时，CMPSW把字节顺序反向。
例如，让我们比较名字SAMUEL和ARNOLD。对于开始比较的字，不是对SA和AR进行比较，而是对AS和RA的比较。
因此，不是名字SAMUEL所代表的高于值，而是错误地比较成低于值。
CMPSW只有所比较的字段是被定义为DW，DD，或DQ的无符号数值数据时（即按相反字节顺序存放的数据），才能正确地工作。
同样，较短的串值应当用空白填满它右边的位置。
11.8SCAS：串扫描指令
SCAS和CMPS不同，SCAS是为一个指定值扫描一个串。为此目的，SCAS把一个存储单元的内容（按ES:DI寻址）和AL，AX，
或EAX的内容进行比较。根据方向标志，SCAS也要DI加1或减1（对于字节），加2或减2（对于字），以及加4或减4（对于双字）。
在一次成功地比较或当REP把CX减到零时，操作结束。SCAS根据比较的结果，置AF，CF，OF，PF，SF以及ZF标志。
当SCAS与REPnn前缀相结合并且CX中是串长时，实际上SCAS可以扫描任意长度的串。
3种SCAS操作是SCASB（对于字节），SCASW（对于字），以及SCASD（对于双字）。
SCAS特别适用于文本编辑，在那种场合下，程序必须要扫描标点符号，比如句号、冒号和空格等等。
下面是为小写字母r扫描STRING1的例子。因为SCASB操作在比较不相等或直到CX为0之前是连续扫描的，
所以在这种情况下使用操作REPNE SCASB：
STRING1 DB 'Interstellar'
CLD
MOV AL,'r'
MOV CX,12
LEA DI,STRING1
REPNE SCASB
JE exit
...
当扫描在STRING1中的串“Interstellar”时，SCASB在第5次比较时发现了匹配的情况。
使用DEBUG去跟踪指令，是在REP SCASB操作执行结束时，这一情况才被揭示。
这时，零标志是0，CX减到7，而DI则加了5（DI在过了相匹配字符的实际单元后，增加了1个字节）。
对于字操作，SCASW为一个值扫描存储器中的一个串，那个值与AX寄存器的字相匹配。
如果使用LODSW或MOV把一个字传送到AX，那么第一个字节应该在AL中，而第二个字节是在AH中。
因为SCASW是按相反顺序比较字节的，所以操作正确进行。
例：使用扫描与替换
你有可能希望用另一个字符替换一个特定的字符，例如，要清除诸如来自一个文档中的小段和页的结束符号等编辑字符。
下面的例子是为一个星号（*）扫描 TESTDATA，并且用一个空格替换这个星号。
如果SCASB判明了一个星号，它便结束操作。TESTDATA在TESTDATA+5处包含一个星号，在那里插入空格，
尽管SCASB已使DI增加到TESTDATA+6。
DI减1，[DI-1]为插入空格替换字符提供了正确的地址。
DATALEN EQU 13
TESTDATA DB 'Extra*innings'
CLD
MOV AL,'*'
MOV CX,DATALEN
LEA DI,TESTDATA
REPNE SCASB
JNE exit
MOV BYTE PTR [DI-1],20H
11.9串指令的另一种编码
正如以前所讨论的，如果串指令是明确地带后缀B、W或D进行编码的（比如MOVSB、MOVSW或MOVSD），
则汇编程序会采用正确的长度并且不需要操作数。
你还可以使用串操作的基本指令格式。对于像MOVS这样的指令，它没有后缀去指明是字节、字或双字，
那么操作数就必须指明长度。例如，如果是CHAR1和CHAR2都定义为DB，
则指令REP MOVS CHAR1,CHAR2的意思就是重复地传送从CHAR2开始的字节到开始于CHAR1的字节。
另外一种格式允许你明确地指定段寄存器和使用PTR伪操作。
如果你把CHAR1和CHAR2的地址装入DI和SI寄存器，那么就可以把MOVS指令编写成
LEA DI,CHAR2
LEA SI,CHAR1
REP MOV BYTE PTR ES:[DI],DS:[SI]
很少有程序会被编成这样，并且在这里说明这些格式也仅仅是作为一种资料而已。
11.10复制一种模式
STOS 指令对于用指定的字节、字、或双字的值去设置一个区域是有用的。但是，对于超过这些长度而去重复一种模式来说，
可以使用作了局部修改的MOVS。假定希望建立一个以下模式的显示行：
 |***| |***| |***| |***| |***| ...
你不需要重复定义整个模式，而只需要紧靠在显示行之前定义前6个字节。下面是一些指令：
PATTERN DB '|****|'
DISPAREA DB 42 DUP (?)
CLD
MOV CX,21
LEA DI,DISPAREA
LEA SI,PATTERN
REP MOVSW
在执行时，MOVSW把PATTERN的第一个字(|*）传送到DISPAREA的第一个字，然后传送第一个字（**）和第三个字（*|）：
在这时，DI包含DISPAREA+6的地址，而SI包含PATTERN+6的地址，这也是和DISPAREA-样的地址。
现在，操作自动地复制这种模式，把DISPAREA的第一个字传送到DISPAREA+6，把DISPAREA+2传送到DISPAREA+8，
把DISPAREA+4传送到DISPAREA+10，以此类推。最后，该模式一直复制到DISPAREA的末端：
你可以使用这一技术任意次地复制一种模式。该模式本身可以是任意长，但必须紧靠在目的字段的前面。
11.11要点
对于串指令MOVS，STOS，CMPS，以及SCAS，EXE程序必须初始化ES寄存器。
串指令使用后缀B、W或D去处理字节串、字串或双字串。
方向标志控制处理所要求的方向：清除标志为从左到右的方向，设置标志（STD）为从右到左的方向。
对于MOVS，DI和SI控制操作数寻址，而对于CMPS，SI和DI则是控制寻址。
CX必须包含初始值，以便REP去处理指定数量的字节、字或双字。
对于正常的处理，REP是和MOVS与STOS起使用的，而条件REP（REPE或REPNE）是和CMPS与SCAS一起使用的。
CMPSW和SCASW操作在被比较的字中，字节顺序是反的。
为了从右到左处理，是从字段的最右边的字节开始寻址的。
例如，如果命名为COTITLE的字段是10个字节长，那么对于处理字节，LEA装入地址是COTITLE+9。
对于处理字，装入地址是COTITLE+8，这是因为串操作最初是访问COTITLE+8和COTITLE+9。
11.12习题
11-1.串操作采用了与ES:DI或DS:SI寄存器有关的操作数。请指出用于以下串操作的寄存器：
（a）MOVS（操作数1和操作数2），（b）LODS（操作数1），（c）CMPS（操作数1和操作数2），（d）STOS（操作数2）。
ES:[DI]、DS:[SI]，AL、DS:[SI]，ES:[DI]、DS:[SI]，AL、ES:[DI]
11-2.对于属于REP MOVSB一类的串操作（a）如何设置重复次数？（b）如何设置从右到左的处理？
MOV CX,6，STD
11-3.本章给出了与以下一些带REP前缀的指令等效的指令：（a）MOVSB，（b）LODSB，（c）STOSB。
对于以上每种情况，请提供处理字的等效代码。
MOV CX,12   ;字数
LEA DI,RECV_STR   ;RECV_STR的地址（ES:DI）
LEA SI,SEND_STR   ;SEND_STR的地址（DS:SI）
CLD
REP MOVSW   ;传送12个字
等效于REP MOVSW操作的指令是：
MOV CX,12
LEA DI,RECV_STR
LEA SI,SEND_STR
L30:MOV AX,DS:[SI]   ;从SEND_STR取字
MOV ES:[DI],AX   ;把字存入RECV_STR
ADD DI,2   ;为下个字增量
ADD SI,2
LOOP L30

CLD
LODSW
等效于LODSW的指令是：
MOV AX,DS:[SI]
ADD SI,2

CLD
MOV AX,2020H
MOV CX,6
LEA DI,STRING1
REP STOSW
等效于REP STOSW操作的指令是：
MOV AX,2020H
MOV CX,6
LEA DI,STRING1
L20:MOV ES:[DI],AX
ADD DI,2
LOOP L20
11-4.修改图11-2的程序，改变MOVSB和MOVSW操作从右到左传送数据。使用调试程序跟踪整个过程，并注意数据段和寄存器的内容。
STRING1 DB 'Interstellar'
STRING2 DB 12 DUP (20H)
STRING3 DB 12 DUP (20H)
MOV AX,@data
MOV DS,AX
MOV ES,AX
STD
MOV CX,12
LEA DI,STRING2+11
LEA SI,STRING1+11
REP MOVSB
STD
MOV CX,6
LEA DI,STRING3+10
LEA SI,STRING2+10
REP MOVSW
11-5.以下各条指令要测试什么条件：（a）REPNE CMPSW，（b）REPE SCASW。
比较ES:[DI]、DS:[SI]指向的字，如果不相等且CX不为0，则继续重复下一次比较，如果相等或CX为0，则停止比较
比较AX、ES:[DI]指向的字，如果相等且CX不为0，则继续重复下一次比较，如果不相等或CX为0，则停止比较
11-6.使用下面的数据定义并按（a）到（f）的要求编写不相关的串操作指令：
BUS_TITLE DB 'Computer Wizards'
WORK_SPACE DB 16 DUP (20H)
（a）从左到右，把BUS_TITLE传送到WORK_SPACE。
DS、ES分别为BUS_TITLE、WORK_SPACE对应的段
CLD
MOV CX,16
LEA SI,BUS_TITLE
LEA DI,WORK_SPACE
REP MOVSB
（b）从右到左，把BUS_TITLE传送到WORK_SPACE。
DS、ES分别为BUS_TITLE、WORK_SPACE对应的段
STD
MOV CX,16
LEA SI,BUS_TITLE+15
LEA DI,WORK_SPACE+15
REP MOVSB
（c）把BUS_TITLE的第四个和第五个字节装入AX。
DS为BUS_TITLE对应的段
CLD
LEA SI,BUS_TITLE+3
LODSW
（d）把始于WORK_SPACE+12的字符存入AX。
DS为WORK_SPACE对应的段
CLD
LEA SI,WORK_SPACE+12
LODSW
ES为WORK_SPACE对应的段
CLD
LEA DI,WORK_SPACE+12
STOSW
（e）比较BUS_TITLE和WORK_SPACE。
DS、ES分别为BUS_TITLE、WORK_SPACE对应的段
CLD
MOV CX,16
LEA SI,BUS_TITLE
LEA DI,WORK_SPACE
REPE CMPSB
JE Label
...
Label:
...
（f）为第一个空格字符扫描BUS_TITLE，如果找到的话，把它传送到CH。
ES为BUS_TITLE对应的段
CLD
MOV CX,16
LEA DI,BUS_TITLE
MOV AL,20H
REPNE SCASB
JNE Label
MOV CH,ES:[DI-1]
...
Label:
...
11-7.修改在“SCAS：串扫描指令”一节的程序段，使该操作为字符对st而去扫描STRING1。
STRING1的检查发现st没有作为一个字出现，就像下面：/In/te/rs/te/ll/ar/那样。
两种可能解决的方案是：（a）使用SCASW两次，第一个SCASW从STRING1开始，而第二个SCASW则是从STRING1+1开始；
（b）或使用SCASB并在找到s时，比较紧跟它后面的字节是不是t。
ES为STRING1对应的段
STRING1 DB 'Interstellar'
CLD
MOV AL,'s'
MOV AH,'t'
MOV CX,6
LEA DI,STRING1
REPNE SCASW
JE Label
CLD
MOV AL,'s'
MOV AH,'t'
MOV CX,6
LEA DI,STRING1+1
REPNE SCASW
JE Label
...
Label:
...

ES为STRING1对应的段
STRING1 DB 'Interstellar'
CLD
MOV AL,'s'
MOV AH,'t'
MOV CX,12
LEA DI,STRING1
L20:REPNE SCASB
JNE Label_NotFind
CMP AH,ES:[DI]
JE Label_Find
JMP L20
...
Label_NotFind:
...
Label_Find:
...
11-8.定义含有十六进制值C9CDCDCDBB的一个5字节字段。用MOVSB把这一字段复制12次成为一个60个字节的区域，
并显示其结果。
DS、ES分别为PATTERN、DISPAREA对应的段
PATTERN DB 0C9H,0CDH,0CDH,0CDH,0BBH
DISPAREA DB 60 DUP (?)
CLD
MOV CX,60
LEA DI,DISPAREA
LEA SI,PATTERN
REP MOVSB

MOV AX,1301H
MOV BX,0016H
LEA BP,DISPAREA
MOV CX,60
MOV DH,ROW
MOV DL,COL
INT 10H
11-9.按以下要求编程序。用串“Computer Tech”定义NAME1，并用13个空格定义NAME2。
使用LODSB从左到右去取NAME1中的每个字符。然后使用STOSB把每个所取到的字符从右到左存入NAME2，
使NAME2所包含的串是按相反顺序的。为这一过程清除和设置方向标志，汇编这个程序并测试它。
.MODEL SMALL
.STACK 512
.DATA
NAME1 DB 'Computer Tech'
NAME2 DB 13 DUP (20H)
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
PUSHF
MOV CX,13
LEA SI,NAME1
LEA DI,NAME2+12
A20:CLD
LODSB
STD
STOSB
LOOP A20
POPF
MOV AX,1301H
MOV BX,0016H
LEA BP,NAME1
MOV CX,13
MOV DH,10
MOV DL,26
INT 10H
MOV AX,1301H
MOV BX,0016H
LEA BP,NAME2
MOV CX,13
MOV DH,11
MOV DL,26
INT 10H
MOV AX,4C00H
INT 21H
A10MAIN ENDP
END A10MAIN
11-10.修改图11-3去检查Ins键。如果它是关断的，则所输入的字符把现有的字符覆盖掉；
如果它是接通的，则插入该字符，使其右边的字符都从左向右挤，
最右边的字符被删除。汇编并测试这一程序。
.MODEL SMALL
.STACK 512
.DATA
KBSTATE DB ?
KBSTATEH DB ?
INDENT EQU 24
LEFTLIM EQU 0
RIGHTLIM EQU 29
NOCHARS EQU 30
COL DB 0
ROW DB 10
DATASTR DB 'abcdefghijklmno'
                 DB 'pqrstuvwxyzABCD',20H
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
CALL Q10CLEAR
CALL Q20CURSOR
CALL Q30DISPLY
A30:CALL Q20CURSOR
MOV AH,12H
INT 16H
MOV KBSTATE,AL
MOV KBSTATEH,AH
CALL B10KEYBRD
CMP AH,01H
JNE A30
CALL Q10CLEAR
MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10KEYBRD PROC NEAR
MOV AH,10H
INT 16H
CMP AL,00H
JE B20
CMP AL,0E0H
JE B20
CALL H10CHARS
JMP B90
B20:CMP AH,4DH
JNE B30
CALL C10RTARRW
JMP B90
B30:CMP AH,4BH
JNE B40
CALL D10LFARRW
JMP B90
B40:CMP AH,53H
JNE B50
CALL E10DELETE
JMP B90
B50:CMP AH,47H
JNE B60
CALL F10HOME
JMP B90
B60:CMP AH,4FH
JNE B90
CALL G10END
JMP B90
B90:RET
B10KEYBRD ENDP
C10RTARRW PROC NEAR
CMP BYTE PTR COL,RIGHTLIM
JAE C20
INC BYTE PTR COL
JMP C90
C20:CALL F10HOME
C90:RET
C10RTARRW ENDP
D10LFARRW PROC NEAR
CMP BYTE PTR COL,LEFTLIM
JBE D20
DEC BYTE PTR COL
JMP D90
D20:CALL G10END
D90:RET
D10LFARRW ENDP
E10DELETE PROC NEAR
PUSHF
PUSH AX
MOV BX,0
MOV BL,COL
PUSH BX
LEA DI,[DATASTR+BX]
LEA SI,[DATASTR+BX+1]
CLD
E20:LODSB
STOSB
CALL Q40DISCHR
INC BYTE PTR COL
CALL Q20CURSOR
CMP BYTE PTR COL,RIGHTLIM
JBE E20
POP BX
MOV COL,BL
POP AX
POPF
RET
E10DELETE ENDP
F10HOME PROC NEAR
MOV BYTE PTR COL,LEFTLIM
CALL Q20CURSOR
RET
F10HOME ENDP
G10END PROC NEAR
MOV BYTE PTR COL,RIGHTLIM
CALL Q20CURSOR
RET
G10END ENDP
H10CHARS PROC NEAR
CMP AL,20H
JB H90
CMP AL,7EH
JA H90
TEST BYTE PTR KBSTATE,80H
JZ H20
CMP BYTE PTR COL,RIGHTLIM
JAE H20
PUSHF
MOV BX,0
MOV BL,COL
PUSH BX
PUSH AX
MOV AH,COL
CALL G10END
MOV BX,0
MOV BL,RIGHTLIM-1
LEA DI,[DATASTR+BX+1]
LEA SI,[DATASTR+BX]
STD
H30:LODSB
STOSB
CALL Q40DISCHR
DEC BYTE PTR COL
CALL Q20CURSOR
CMP AH,BYTE PTR COL
JB H30
POP AX
MOV ES:[DI],AL
CALL Q40DISCHR
POP BX
MOV COL,BL
CMP BYTE PTR COL,RIGHTLIM
JAE H40
INC BYTE PTR COL
H40:POPF
JMP H90
H20:MOV BX,0
MOV BL,COL
LEA DI,DATASTR
MOV [DI+BX],AL
CALL Q40DISCHR
CMP BYTE PTR COL,RIGHTLIM
JAE H90
INC BYTE PTR COL
H90:RET
H10CHARS ENDP
Q10CLEAR PROC NEAR
PUSH AX
MOV AX,0600H
MOV BH,61H
MOV CX,0000H
MOV DX,184FH
INT 10H
POP AX
RET
Q10CLEAR ENDP
Q20CURSOR PROC NEAR
PUSH AX
MOV AH,02H
MOV BH,00H
MOV DH,ROW
MOV DL,COL
ADD DL,INDENT
INT 10H
POP AX
RET
Q20CURSOR ENDP
Q30DISPLY PROC NEAR
PUSH AX
MOV AX,1301H
MOV BX,0016H
LEA BP,DATASTR
MOV CX,NOCHARS+1
MOV DH,ROW
MOV DL,COL
ADD DL,INDENT
INT 10H
POP AX
RET
Q30DISPLY ENDP
Q40DISCHR PROC NEAR
PUSH AX
MOV AH,0AH
MOV BH,00H
MOV CX,1
INT 10H
POP AX
RET
Q40DISCHR ENDP
END A10MAIN
第12章算术运算I：处理二进制数据
12.1引言
12.2处理无符号与带符号的二进制数据
12.3二进制数据的加法与减法
12.4二进制数据乘法
12.5二进制数据除法
12.6数值数据处理器
12.7要点
12.8习题
目的：介绍二进制数据的加法，减法，乘法与除法的要求
12.1引言
这一章涉及加法，减法，乘法，除法，以及无符号与带符号数值数据的使用，
还包括许多例子和对于在计算机算术运算领域里粗心大意的朋友所犯各种错误的警告。
第13章会涉及到一些特殊的要求，包括二进制与ASCII数据格式之间的转换。
虽然我们习惯于做十进制（基数为10）格式的算术运算，
但微计算机却只能做二进制（基数为2）算术运算。本章所要说明的指令是：
ADC         带进位加法         IDIV         带符号数除法
ADD         加法                   IMUL        带符号数乘法
CBW        字节转换为字      MUL         无符号数乘法
CDQ        双字转换为四字   NEG         求反
CWD       字转换为双字       SBB          带借位减法
CWDE    字转换为扩展双字 SUB          减法
DIV         无符号数除法
12.2处理无符号与带符号的二进制数据
某些数值字段，例如用户编号和日期是无符号的，某些带符号的数值字段，例如用户该付的差额，温度的读数可能包含正值或负值。
其他的带符号数值字段，例如产品价格和圆周率π=3.1415926535...永远都被认定为正值。
下面的表给出与寄存器宽度相匹配的无符号和带符号数据的最大值：
格式                  字节         字                  双字
无符号               255         65535         4294967295
带符号               127         32767         2147483647
对于无符号数据，所有位都用作数据位；对于带符号数据，最左边的位是符号位。
但是注意，ADD和SUB指令是不区分无符号和带符号数据的，的确是简单地对各位做加法和减法。
下面的例了说明2个二进制数的加法，这些值可以表示为无符号数和带符号数。
上面的数左边有为1的位，对于无符号数据，这些位表示249，而对于带符号数据，这些位表示-7。
该加法使溢出（OF）或进位（CF）标志均置0：
249=256-7=255-6=F9H=-7
F9H+02H=FBH=-5
对于无符号与带符号数据来说，二进制加法的结果是一样的。
但是，在无符号字段中的这些位表示的是十进制的251，而在带符号的字段中，它们表示十进制-5。
实际上，一个字段的内容是任何你打算让它们表示的内容，并且必须对它们进行相应的处理。
1.算术进位。算术操作把符号位所产生的（结果0或1）传送到进位标志。
如果该符号位是1，则实际是把进位标志置成1。若无符号数据中产生了进位，其运算结果是无效的。
以下是产生进位的加法举例：
FDH+05H=102H
FCH+05H=101H
对于无符号数据的操作是无效的，原因在于数据位的进位输出，而对于带符号数据的操作则是有效的。
2.算术溢出。当符号位有进位输入而又没有进位输出，或者进位输出不是由进位输入产生时，算术操作将把溢出标志置成1。
如果溢出是发生在带符号数据中，则运算结果就是无效的（因为溢出进入了符号位）。以下是产生溢出的加法举例：
79H+0BH=84H
加法操作可以同时把进位标志与溢出标志都置成1。
在下面的例子中，进位使得无符号数据的操作是无效的，而溢出则使带符号数据的操作是无效的：
F6H+89H=17FH
所有这一切的结论是：必须弄清楚程序将要处理的数的大小，并要相应地定义与处理这些数字字段。
12.3二进制数据的加法与减法
ADD和SUB指令按照字节、字和双字的大小执行简单的二进制数据的加法和减法。格式是：
[label:] ADD/SUB register,register
[label:] ADD/SUB memory,register
[label:] ADD/SUB register,memory
[label:] ADD/SUB register,immediate
[label:] ADD/SUB memory,immediate
ADD或SUB操作设置或清除溢出与进位标志，正如上一节所讨论的，跟其他大多数指令一样，没有直接的存储器到存储器的操作。
如第1章所述，负的二进制数是用二进制补码来表示的，它是把正数按位求反再加1而形成的。
下面自解释性的ADD与SUB举例是处理字节值和字值的。
BYTE1 DB 24H
WORD1 DW 4000H
MOV CL,BYTE1   ;处理字节：
MOV DL,40H
ADD CL,DL   ;寄存器到寄存器
SUB CL,20H   ;从寄存器减去立即数
ADD BYTE PTR BYTE1,BL   ;寄存器到存储器
MOV CX,WORD1   ;处理字：
MOV DX,2000H
SUB CX,DX   ;从寄存器减去寄存器
SUB CX,0124H   ;从寄存器减去立即数
ADD WORD PTR WORD1,DX   ;寄存器加到存储器
12.3.1溢出
溢出在算术操作，尤其在带符号数据算术操作方面，是值得关注的一件事。
由于一个字节只提供一个符号位和7个数据位（从-128到+127），所以算术操作容易超过1个字节寄存器的容量。
而当AL寄存器中的和超过它的容量时，可能会产生意外的后果。
例如，如果AL的内容是60H，那么指令ADD AL,20H在AL中产生的和是80H。
在进行2个正的值相加时，你可能预想这个和是个正的值，但是该操作因为溢出而设置了溢出标志并使符号标志成为负的。
为什么呢？因为80H或二进制1000000这个值是个负数，而不是+128，其和是-128。
问题在于：对于和而言，AL太小了，该和应该是在整个AX中，如下一节所述。
12.3.2字节扩展为字
上一节说明了20H和在AL中的60H相加如何产生了不正确的和，一个较好的解决办法是在AX中执行算术运算。
为此目的，要用到的指令是CBW（把字节转换为字），它会自动地扩展AL的符号位（0或1）到整个AH。
注意，CBW没有操作数，它只限于使用AX。
在下一个例子中，CBW把在AL中的符号位（0）扩展到整个AH，在AX中产生0060H，
然后该例子把20H加到AX（不是加到AL）并且在AX中产生正确的结果：0080H或+128：
MOV AL,60H
CBW
ADD AX,0020H
这个例子的数值结果和上一个例子的结果是一样的，但是在AX中的加法不会把它当作溢出或负数来处理。
另外，即使AX中的整个字允许1个符号位和15个数据位，但AX对值的限制还是-32768到+32767。
其他把字节转换成字的指令是MOVZX（对于无符号数据）和MOVSX（对于带符号数据），像以下这样使用：
MOVZX CX,BYTEVAL   ;字节在CL中，零在CH中
MOVSX WORDVAL,DL   ;字节送到字中，用符号位填充高位字节
12.3.3字扩展为双字
CWD（字转换为双字）指令用于把一个带符号的数的字扩展为双字，方法是把AX的符号位复制到整个DX。
注意，CWD是没有操作数的，它只限于使用DX:AX。这里是一个例子：
MOV AX,WORD   ;把字传送到AX
CWD
CWDE（字转换为扩展的双字）指令用于把一个带符号数的字扩展为双字，方法是把AX的符号位复制到整个EAX。
这里是一个例子：
MOV AX,WORD1   ;把字传送到AX
CWDE   ;把字扩展到EAX
MOVZX和MOVSX也可以把字转换成双字：
MOVZX ECX,WORDVAL   ;字在CX中，用零填充ECX的高位字
MOVSX DBLWORD,DX   ;字在DBLWORD中，用符号位填充其高位字
CDQ（双字转换为四字）指令用于把带符号数的双字扩展成四字，方法是把EAX的符号位复制到EDX。
注意，CDQ是没有操作数的，因而它只限于使用EDX:EAX。这里是一个例子：
MOV EAX,DBLWORD   ;把双字传送到EAX
CDQ   ;把双字扩展到EDX:EAX
12.3.4实现双字值的算术运算
正如我们已经看到的，大的数值可能超过一个字的容量，而需要多字的容量。
在多字运算方面，一个需要考虑的问题是：相反的字节顺序和相反的字顺序。
回想一下，汇编程序自动地把所定义的数值字的内容转换成按相反字节顺序排列，例如0134H的定义是按3401H存放的。
下面的例子是双字值的相加与存放：
DBLWORD1 DD 0123BC62H
DBLWORD2 DD 0012553AH
DBLWORD3 DD 0
MOV ECX,DBLWORD1
ADD EAX,DBLWORD2
MOV DBLWORD3,EAX
汇编程序自动地按相反字节（和字）顺序排列所定义的数据。
但对于某些应用场合，数据可能被定义成字值。对于在上一例子中所定义的DBLWORD1来说，
必须把字按相邻相反的次序来定义：
DW 0BC62H
DW 0123H
然后汇编程序把这些定义按相反字节顺序转换为62BC 2301，现在就适合于作双字算术运算了。
下面考察一下对这些值执行算术运算的两种方法。第一种是简单的和专用的，而第二种则是比较复杂的和通用的。
下面是该例子所使用的数据：
WORD1A DW 0BC62H
WORD1B DW 0123H
WORD2A DW 553AH
WORD2B DW 0012H
WORD3A DW ?
WORD3B DW ?
实际上，程序是要把如下值相加：
WORD1B:WORD1A 0123 BC62H
+
WORD2B:WORD2A 0012 553AH
=
WORD3B:WORD3A 0136 119CH
由于在存储器中是按相反字节顺序的，程序用相邻的但又是相反的字，分别来定义值：BC62 0123和553A 0012。
然后，汇编程序把这些双字值按相反字节顺序存放在存储器中：
WORD1A和WORD1B：62 BC 23 01
WORD2A和WORD2B：3A 55 12 00
第一个例子是把第一对字（WORD1A和WORD1B）和第二对字（WORD2A和WORD2B）相加，
并把和存放在第三对字（WORD3A和WORD3B）中：
MOV AX,WORD1A
ADD AX,WORD2A
MOV WORD3A,AX
MOV AX,WORD1B
ADC AX,WORD2B
MOV WORD3B,AX
该例子首先把WORD2A加到AX中的WORD1A（低阶部分）上，并把和存放在WORD3A中。
下一步是把WORD2B及上一次加法的进位一起加到AX中的WORD1B（高阶部分）上，然后把和存放在WORD3B中。
让我们仔细观察一下这些操作：第一组MOV和ADD操作在AX中的字节是相反顺序的，并且使最左边的字相加（先加低阶字）：
WORD1A:BC62H
+
WORD2A:553AH
总计（1）119CH（9C11被存放在WORD3A中）
由于WORD1A加WORD2A的和超过了AX的容量，产生进位，置进位标志为1。
接下来右边的字相加，但这次是用ADC（带进位加）代替ADD。
ADC把2个值相加，因为进位标志置1，所以和要加1（在加高阶字时要用ADC，以便计入低阶字相加所产生的进位。）：
WORD1B 0123H
+
WORD2B 0012H
加上进位 0001H
总计0136H（按3601H存放在WORD3B中）
利用调试程序去跟踪该算术运算展示在AX中的和，在WORD3A中是相反字节顺序值9C11H，以及在WORD3B中是3601H。
第二个例子提供了一个比较复杂的方法把任意长度值相加，这里相加的还是以前一样的字对：
WORD1A:WORD1B和WORD2A:WORD2B：
CLC   ;清除进位标志
MOV CX,2   ;设置循环计数
LEA SI,WORD1A
LEA DI,WORD2A
LEA BX,WORD3A
L20:MOV AX,[SI]
ADC AX,[DI]
MOV [BX],AX
INC SI
INC SI
INC DI
INC DI
INC BX
INC BX
LOOP L20
...
该例子用SI、DI和BX分别作为WORD1A、WORD2A和WORD3A的地址的变址寄存器。
对于每个要相加的字对都要经过所有指令循环一次，在这种情况下，是两次。
第一次循环把最左边的字相加，而第二次循环则是把最右边的字相加。
由于第二个循环是向右处理字的，所以在SI、DI和BX中的地址要加2。
两条INC指令对于每个寄存器执行这一操作。使用INC（而不是ADD）的一个良好理由是：
指令ADD reg,2将清除进位标志，并且会产生一个不正确的答案；相反，INC不影响进位标志。
由于循环，所以只有一条加法指令ADC。在开始时，CLC（清除进位）指令确保进位标志最初是被清除的。
在WORD3A、WORD3B和AX中的结果和前面的例子是一样的。
为了按这种方法工作，必须（1）定义的字是彼此相邻的，（2）把CX初始化为要相加的字数，以及（3）从左到右处理字。
对于多字减法，与ADC相当的指令是SBB（带借位减法）。用SBB简单地取代ADC。这里是ADC和SBB的格式：
[label:]ADC/SBB register,register
[label:]ADC/SBB memory,register
[label:]ADC/SBB register,memory
[label:]ADC/SBB register,immediate
[label:]ADC/SBB memory,immediate
对于四字相加，使用前面所述对于多字相加的技术，定义2个相邻的双字对，并使用ECX寄存器。
12.4二进制数据乘法
对于乘法，MUL（乘）指令用于处理无符号数据，而IMUL（整数乘）则用于处理带符号数据。
两条指令都影响进位标志和溢出标志。作为程序员，应该全面控制所处理的数据格式，而且有选择合适的乘法指令的责任。
MUL和基本的IMUL的格式是：
[label:] MUL/IMUL register/memory
乘法操作是字节乘字节，字乘字或双字乘双字。IMUL提供3种附加格式，它们包含双字和立即操作数，这在下一节将会涉及到。
12.4.1字节乘字节
对于2个一字节值相乘，被乘数在AL寄存器中，而乘数是在存储器或另一个寄存器中的一个字节。
对于指令MUL DL，该操作是用DL的内容去乘AL的内容，所产生的乘积在AX中。该操作可能覆盖已经在AH中的任何数据。
12.4.2字乘字
对于2个一字值相乘，被乘数放在AX，乘数是在存储器或另一个寄存器中的一个字。
对于指令MUL DX，该操作是用DX的内容去乘AX的内容。所产生的乘积是一个双字，
需要两个奇存器：高位（最左边）部分在DX中，低位（最右边）部分在AX中。该操作可能覆盖已在DX中的任何数据。
12.4.3双字乘双字
对于2个双字值相乘，被乘数在EAX，乘数是在存储器或另一个寄存器中，所产生的乘积在EDX:EAX对中。
该操作可能覆盖已在EDX中的任何数据。
12.4.4字段大小
MUL或MUL的操作数只引用乘数，由它决定字段大小。指令设定被乘数是在AL，AX，或EAX中，这取决于乘数的大小。
在以下的例子中，乘数是一个寄存器中的字节、字或双字：
MUL CL
MUL BX
MUL EBX
在下面的例子中，乘数是在存储器中定义的：
BYTE1 DB ?
WORD1 DW ?
DWORD1 DD ?
MUL BYTE1
MUL WORD1
MUL DWORD1
12.4.5无符号数乘法：MUL
MUL指令的用途是进行无符号数据相乘。以下程序片段给出4个使用MUL的例子，数据定义如下：
BYTE1 DB 80H
BYTE2 DB 40H
WORD1 DW 8000H
WORD2 DW 2000H
DWORD1 DD 00018402H
DWORD2 DD 00012501H
例1 40H乘80H。在AX中的乘积是2000H（8192）：
MOV AL,BYTE1
MUL BYTE PTR BYTE2
乘积在AX中
例2 在DX:AX对中产生1000 0000H：
MOV AX,WORD1
MUL WORD PTR WORD2
乘积在DX:AX中
例3 字和字节相乘并要求把BYTE1扩展成一个字：
MOVZX AX,BYTE1
MUL WORD1
乘积在DX:AX中
由于值是被假定为无符号的，所以该例子认为在AH中的位是0。
（这里使用CBW可能引发的问题是，AL最左边的位可能是1，并且在AH中扩展为1的位会导致一个较大的无符号的值）。
在DX:AX中的积是00400000H。
例4使用EAX进行双字相乘：
MOV EAX,DWORD1
MUL DWORD PTR DWORD2
在EDX:EAX中的值是0000 0001 BC17 CE02H。
12.4.6带符号数乘法：IMUL
IMUL指令的用途是进行带符号数据的相乘。以下的程序片段表示的和刚给出的4个例子是一样的，只是用IMUL替代了MUL。
例1 80H（一个负数）乘以40H（一个正数）：
MOV AL,BYTE1
IMUL BYTE PTR BYTE2
在AX中的乘积是E000H。使用同样的数据时，MUL产生的乘积是2000H，所以可以看出使用MUL和使用IMUL的区别。
MUL把80H当成+128，而IMUL则把80H当成-128。
-128乘+64的乘积是-8192H，等于E000H
（尝试一下把E000H转换成位，这些位求反，加1，再加上位的权值）。
2000H->DFFFH+1->E000H
1000 0000H->EFFF FFFFH+1->F000 0000H
例2 8000H（一个负值）乘以2000H（一个正值）。在DX:AX中的乘积是F000 0000H，这是MUL所产生的乘积的负值：
MOV AX,WORD1
IMUL WORD PTR WORD2
乘积在DX:AX中
FF80H*8000H=7FC0 0000H->803F FFFFH +1 ->8040 0000H->0040 0000H
例3首先把BYTE1扩展为AX中的一个字。因为已假定该值是带符号数，
所以例子使用MOVSX把最左边的符号位扩展到AH:AL（AL=80H），变成在AX中的FF80H。
由于乘数WORD1也是负的，所以乘积应该是正的。并且在DX:AX中它确实是正的0040 0000H，
和MUL2个无符号数相乘的结果是一样的。
MOVSX AX,BYTE1
IMUL WORD PTR WORD1
乘积在DX:AX中
例4使用EAX进行双字相乘。乘积在EDX:EAX中，其值为0000 0001 BC17 CE02H：
MOV EAX,DWORD1
IMUL DWORD PTR DWORD2
实际上，如果被乘数与乘数有相同的符号位，那么MUL和IMUL就产生相同的乘积。
但如果被乘数与乘数符号位不相同，则MUL产生一个正的乘积，而IMUL产生一个负的乘积。
结论是：程序必须要知道数据的格式并使用相应的指令。
试一下用调试程序去跟踪全部例子。
12.4.7其他IMUL格式
80286和80386处理器引入了3种MUL格式，提供立即操作数以及产生乘积在AX以外的寄存器中。
可以把它们用于无符号数和带符号数的乘法，因为结果是一样的。
IMUL DST,SRC
IMUL DST,SRC1,SRC2
上述第一种格式是将目的操作数DST与源操作数SRC相乘，结果送到目的操作数DST中；
第二种格式是将SRC1与SRC2相乘，结果送目的操作数DST中。
这些值必须都是同样长度的：16位或32位。以下是它们的格式：
16位立即数 [label:] IMUL register,immediate
32位立即数 [label:] IMUL register,memory,immediate
16/32位 [label:] IMUL register,register/memory
1.16位立即数IMUL操作。
第一个操作数（寄存器）包含被乘数，而第二个操作数（立即值）是乘数，所产生的乘积在第一个操作数中。
超出寄存器的乘积使进位标志和溢出标志被置1。
2.32位立即数IMUL操作。在双字格式下，这一格式有3个操作数。第二个操作数（存储器）包含被乘数，第三个操作数（立即值）包含乘数，
所产生的乘积在第一个操作数（寄存器）中。
3.16/32位IMUL操作。第一个操作数（寄存器）包含被乘数，第二个操作数（寄存器/存储器）包含乘数，所产生的乘积放在第一个操作数中。
下面是这3种IMUL指令的例子：
.386

IMUL DX,25
IMUL ECX,MULTCAND,25
IMUL BX,CX
IMUL EBX,EDX
IMUL EBX,DWORDVAL
12.4.8执行双字乘法
一般的乘法包括字节乘字节，字乘字，双字乘双字。正如我们已经见到的，字的最大带符号值是+32767。
80386之前的处理器处理更大值的相乘要包括一些附加的步骤。这些处理器所用的方法是每个字分别相乘，
然后再把每个乘积相加。这样的例子是值得研究的，因为这一技术可以用于双字寄存器，如EAX。
下面的例子是4位的十进制数乘以2个数位的数：
1365*12=16380
如果只进行2个数位的数相乘是怎样的呢？可以将13和65分别乘以12，就像这样：
13*12=156，65*12=780
接下来，把两个乘积相加：但请记住，由于13是在百的位置，它的乘积实际上是15600：
15600（13×12×100）+780（65×12）=16380
汇编语言程序可以使用同样的技术，除非数据是由十六进制格式的字（4个数位）组成的。
下一节探讨双字与字相乘及双字与双字相乘的一些要求。
1.双字乘以字。下面的程序片段是一个双字乘以字。被乘数MULTCAN分别由2个字3206H和2521H组成。
定义2个DW代替定义DD的原因是为了便于MOV指令的寻址，该MOV指令是把字传送到AX的。
该值按相反字节顺序定义，并且汇编程序是按相反字节顺序存放每个字的。
因此，MULTCAN被定义的值是3206 2521H，按21 25 06 32H存放。
MULTCAN DW 2521H
DW 3206H
MULTPLR DW 6400H
PRODUCT DW 0,0,0
乘数MULTPLR的内容是6400H。为所产生的乘积提供了3个字的字段PRODUCT。
第一个MUL操作是把MULTPLR和MULTCAN左边的字相乘，乘积是十六进制的0E80 E400H，
存放在PRODUCT+2和PRODUCT中：
MOV AX,MULTCAN
MUL MULTPLR
MOV PRODUCT,AX
MOV PRODUCT+2,DX
第二个MUL是把MULTPLR和MULTCAN右边的字相乘，乘积是138A 5800H。
MOV AX,MULTCAN+2
MUL MULTPLR
ADD PRODUCT+2,AX
ADC PRODUCT+4,DX
最后，该例子把两个乘积相加，如以下这样：
乘积1：0000 0E80 E400
+
乘积2：138A 5800
总计 138A 6680 E400
由于第一个ADD可能产生进位，所以第二个加法是ADC（带进位加）。
数值数据是按相反字节格式存放的，所以PRODUCT的内容实际上是00 E4 80 66 8A 13。
该例行程序要求PRODUCT的第一个字最初包含零。
2.双字乘以双字。在DX:AX中的2个双字相乘包括做4次乘法：
字2×字2
+
字2×字1
+
字1×字2
+
字1×字1
把在DX和AX中的每个乘积加到最后乘积的适当的字上。以下的程序片断给出一个例子。
MULTCAND包含3206 2521H，MULTPLER包含6400 0A26H，而PRODUCT提供了4个字：
MULTCAND DW 2521H
DW 3206H
MULTPLER DW 0A26H
DW 6400H
PRODUCT DW 0,0,0,0
虽然逻辑上是类似于字和双字相乘，但这个问题还需要一个附加的特性。
在ADD/ADC对之后是另一个ADC，它把0加到PRODUCT上。第一个ADC本身可能产生进位，后续的指令会把它清除，
因此，第二个ADC如果没有进位就加0，有进位就加1。最后的ADD/ADC对不需要附加的ADC，
因为PRODUCT对于最终所得到的答案是足够大的，所以没有进位。
MOV AX,MULTCAND
MUL MULTPLER
MOV PRODUCT+0,AX
MOV PRODUCT+2,DX
MOV AX,MULTCAND
MUL MULTPLER+2
ADD PRODUCT+2,AX
ADC PRODUCT+4,DX
ADC PRODUCT+6,0
MOV AX,MULTCAND+2
MUL MULTPLER
ADD PRODUCT+2,AX
ADC PRODUCT+4,DX
ADC PRODUCT+6,0
MOV AX,MULUTCAND+2
MUL MULTPLER+2
ADD PRODUCT+4,AX
ADC PRODUCT+6,DX
最后的乘积是138A 687C 8E5C CCE6，以相反的字节顺序存放在PRODUCT中。试一试使用调试程序去跟踪整个例子。
12.4.9用移位做乘法
对于乘以2的幂（2，4，8等等）的情况，左移必要的位数可以提高处理速度。
在以下不相关的例子中，被乘数是在第一个操作数中，而CL的内容是2：
乘以2（左移1次）：SHL AX,1
乘以4（左移2次）：SHL DX,CL
乘以8（左移3次）：SHL WORDVAL,3
下面的例行程序可用于在DX:AX对中的双字值的左移。虽然指定移4位，但它可以适应于其他值：
SHL DX,4   ;DX左移4位
MOV BL,AH   ;把AH存入BL
SHL AX,4   ;AX左移4位
SHR BL,4   ;BL右移4位
OR DL,BL   ;从BL往DL中插入4位
在移出有效数位之前，一定要进行检查。
12.5二进制数据除法
对于除法，DIV（除法）指令处理无符号数据，IDIV（整数除法）处理带符号数据。要选择适当的除法指令进行操作。
DIV/IDIV的格式是：
[label:] DIV/IDIV register/memory
基本的除法操作是字除以字节，双字除以字，以及四字除以双字。
1.字除以字节。为了用字节去除字，把被除数在AX中，除数是在存储器或另一寄存器中的一个字节。
该操作把余数存放在AH中，而把商存放在AL中。
注意，1字节的商是很小的，如果是无符号数，则最大值是+255（FFH）；如果是带符号数，则最大值是+127（7FH）。
2.双字除以字。为了用字去除双字，被除数在DX:AX中，除数是在存储器或另一寄存器中的一个字。
该操作把余数存放在DX中，把商存放在AX中。
一个字的商允许的最大值对于无符号数是65535（FFFFH），对于带符号数则是+32767（7FFFH）。
3.四字除以双字。对于双字去除四字，被除数是在EDX:EAX中，除数是在存储器或另一寄存器中的一个双字。
该操作把余数存放在EDX中，而商放在EAX中。
4.字段大小。DIV/IDIV的操作数引用除数，它决定字段的大小。在下面的DIV例子中，除数是在寄存器中的字节、字或双字。
DIV CL
DIV CX
DIV EBX
在下面的DIV例子中，除数是定义在存储器中的：
BYTE1 DB ?
WORD1 DW ?
DWORD1 DD ?
DIV BYTE1
DIV WORD1
DIV DWORD1
5.余数。13除以3的结果是4 1/3，其中商是4，余数是1。
注意，计算器（以及高级程序设计语言）将提供一个4.333的商，它是由一个整数部分（4）和小数部分（.333）组成的。
值1/3和.333是小数，而1是个余数。
12.5.1使用DIV做无符号数除法
DIV指令用于做无符号数的除法。以下程序片断给出4个DIV的例子：字除以字节，字节除以字节，双字除以字，以及字除以字。
下面是例子所用的数据：
BYTE1 DB 80H
BYTE2 DB 16H
WORD1 DW 2000H
WORD2 DW 0010H
WORD3 DW 1000H
例1是2000H（8192）除以80H（128）。在AH中的余数是00H，而在AL中的商是40H（64）：
MOV AX,WORD1
DIV BYTE PTR BYTE1
余数：商在AH:AL中
例2要求把BYTE1扩展成一个字，因为该值被假定是无符号数，所以例子假设AH的各位都是0。
在AH中的余数是12H，而商在AL中是05H。128/22=5,18=05H,12H
MOVZX AX,BYTE1
DIV BYTE PTR BYTE2
余数：商在AH:AL中
在例3中，在DX中的余数是1000H，而在AX中的商是0080H。0010 1000H/2000H=0080H,1000H
MOV DX,WORD2
MOV AX,WORD3
DIV WORD1
余数：商在DX:AX中
例4首先把WORD1扩展成在DX中的双字。相除以后，在DX中的余数是0000H，在AX中的商是0002H：
MOV AX,WORD1
SUB DX,DX
DIV WORD3
余数：商在DX:AX中
12.5.2使用IDIV做带符号数除法
IDIV指令是用于做带符号数据的除法。以下程序片断表示的是和上面给出的4个例子同样的例子，但用IDIV取代DIV。
例1是2000H（正数）除以80H（负数）。在AH中的余数是00H，在AL中的商是C0H（-64）
（使用同样的数据，DIV产生+64的商）：
MOV AX,WORD1
IDIV BYTE PTR BYTE1
40H->BFH+1=C0H
余数：商在AH:AL中
在例2中，商是FB（-5）而余数是EEH（-18）：
MOVZX AX,BYTE1
IDIV BYTE2
-128/22=-5,-18
05H->FAH+1=FBH
12H->EDH+1=EEH
余数：商在AH:AL中
在例3中，商是0080H（128）），而余数是1000H（4096）：
MOV DX,WORD2
MOV AX,WORD3
IDIV WORD1
在例4中，商是0002H，而余数是0000H：
MOV AX,WORD1
IDIV WORD3
余数：商在DX:AX中
例3与例4和用DIV做时的答案是一样的。实际上，如果被除数与除数的符号位相同，那么DIV和IDIV就会产生同样的结果。
但是，如果被除数与除数的符号位不同，则DIV产生个正的商，而IDIV则产生一个负的商。
下面的例子说明四字除以双字的情况。商是DC5CH（56412）：
DBLWD1 DD 0
DBLWD2 DD 225648
DBLWD3 DD 4
MOV EDX,DBLWD1
MOV EAX,DBLWD2
IDIV DBLWD3
余数；商在EDX:EAX中
试用调试程序跟踪这些例子。
12.5.3溢出与中断
DIV和IDIV操作都假定商比原先的被除数小才是有意义的。因此，操作可能容易产生溢出，这时，会发生中断，
产生不可预知的结果。例如，除以0会引起中断，但是除以1会产生一个与被除数相同的商，也会引起一次中断。
这是一个有用的规则：如果除数是一个字节，那么它的值必须大于被除数左边的字节（AH）；
如果除数是一个字，那么它的值必须大于被除数左边的字（DX）；
如果除数是一个双字，它的值就必须大于被除数左边的双字（EDX）。
下面的指令用1作为除数，虽然其他值可能也是适用的：
012A/1=(01)2A,0
0001 402B/1=(0001)402B,0
0000 0002 1054 2EB4/1=(0000 0002)1054 2EB4,0
在每种情况下，商都超出了它的可用空间。通常的做法是在DIV或IDIV操作之前做一次测试，如以下2个例子所示。
在例1中，DIVRBYTE是1字节的除数，被除数在AX中：
CMP AH,DIVRBYTE
JNB L20
DIV DIVRBYTE
在例2中，DIVRDWD是双字的除数，而被除数是在EDX:EAX中：
CMP EDX,DIVRDWD
JNB L30
DIV DIVRDWD
对于IDIV，逻辑上必须说明一个事实，就是被除数或除数可能是负的。
由于除数的绝对值必须是两个当中较小的一个，所以可以使用NEG指令把一个负值临时设置成正的，并在相除之后再恢复其符号。
12.5.4用减法做除法
对于一个除数而言，如果商太大了，可以使用连续减的方法实现除法。
也就是说，从被除数中减去除数，商的值加1，并且继续做减法直到被除数小于除数为止。
在下面的例子中，被除数在AX中，除数在BX中，而商则扩展到CX中：
SUB CX,CX
L20:CMP AX,BX
JB L30
SUB AX,BX
INC CX
JMP L20
商在CX中，余数在AX中
在例行程序结束时，CX的内容是商，而AX的内容是余数。如果被除数在DX:AX中，那么例行程序看来像是这样：
SUB CX,CX
L20:CMP DX,0
JNE L30
CMP AX,BX
JB L40
L30:SUB AX,BX
SBB DX,0
INC CX
JMP L20
L40:
...
商在CX中，余数在AX中
注意，一个非常大的商和一个小的除数可能造成以牺牲处理时间为代价的数千次循环。
12.5.5用移位做除法
对于除以2的幂（2，4，8等等）的情况，右移所要求的位数可以加快处理速度。
以下不相关的例子假定被除数在BX中，而CL含有2：
SHR BX,1   ;除以2
SHR BX,CL   ;除以4
SHR BX,3   ;除以8
下面的例行程序可以用于右移在DX:AX中的双字值。虽然指定的是移4位，但可以适用于其他值：
SHR AX,4
MOV BL,DL
SHR DX,4
SHL BL,4
OR AH,BL
12.5.6符号变反
NEG（负）指令将二进制值的符号变反，由正的变成负的，反之亦然。
实际上，NEG将各位求反，就像NOT样，然后加1，成为二进制补码表示法。NEG的格式是
[label:] NEG register/memory
这里是一些不相关的例子：
NEG CL
NEG BX
NEG EDX
NEG BINVAL
在DX:AX中的32位值的符号变反包括较多的步骤。NEG不能同时对DX:AX起作用，
而对于2个寄存器都使用NEG会对它们都加1，这是无效的。
取而代之的，是使用NOT把各位变反，并且使用ADD和ADC去加1，成为二进制补码：
NOT DX
NOT AX
ADD AX,1
ADC DX,0
剩下的一个次要的问题是：按照程序本身定义的二进制数据或在一个外部文件中已经采用二进制格式的数据，
来实现算术运算是一件非常好的事。但是，从键盘输入到程序中的数据都是按ASCII格式的。
尽管ASCII数据适合于显示和打印，但对于算术运算，还需要专门地调整――这是下一章要讨论的课题。
12.6数值数据处理器
这一节提供的是对数值处理器的一般介绍，完整地讨论已经超出了本书的范围。
Intel数值数据处理器，或协处理器为了实现取幂（乘方）、对数与三角这样一些操作而有其自己的指令系统和浮点硬件。
8个80位的浮点寄存器可以表示的数值能达到10的400次方，并且执行起来要比正规的处理器快得多。
协处理器包含8个80位的寄存器R1-R8，采用下面的格式：
S                  阶                  有效数
79         78         64         63         0
每个寄存器都有一个相关联的2位标记来指明它的状态：
00 包含一个有效数         10 包含一个无效数
01 包含一个零值            11 为空
协处理器识别7种类型的数值数据：
1.字整数：16位二进制数据。
S                  数
15         14         0
2.短整数：32位二进制数据。
S                  数
31         30         0
3.长整数：64位二进制数据。
S                  数
63         62         0
4.短实数：32位浮点数据。
S                  阶                  有效数
31         30         23         22         0
5.长实数：64位浮点数据。
S                  阶                  有效数
63         62         52         51         0
6.临时实数：80位浮点数据。
S                  阶                  有效数
79         78         64         63         0
7.压缩十进制数。18个有效的十进制数字。
S                  阶                  有效数
79         78         72         71         0
18*4=72
类型1，2和3是通用二进制补码格式，类型4，5和6表示浮点数，类型7包含18个4位十进制数字。
这些格式中的任何一种可以从存储器装入到协处理器的寄存器中，并且可以把寄存器的内容存入到存储器中。
但是，关于它的计算，协处理器要把它在寄存器中的所有格式转换成临时实数。数据在存储器中的存放是按相反字节顺序的。
协处理器需要一个专门的操作把数值数据发送到协处理器，在那里完成操作并回送结果。
12.7要点
对于1字节累加器最大的带符号值是+127和-128。
对于多字加法，使用ADC计算任何来自前面ADD的进位。如果操作是在一个循环中完成的，则使用CLC去清除进位标志。
MUL用于无符号数据，IMUL用于带符号数据。
对于MUL，如果乘数是按字节定义的，那么被乘数是AL；如果乘数是一个字，则被乘数是AX；如果乘数是双字，被乘数就是EAX。
左移指令（SHL或SAL）可以用来乘以2的幂。
DIV用于无符号数据，IDIV用于带符号数据。
对于除法，如果除数被定义为字节，则被除数就是AX；如果除数是字，则被除数就是DX:AX；如果除数是双字，则被除数是EDX:EAX。
如果除数是一个字节，那么该除数必须大于AH的内容；如果除数是一个字，就必须大于DX的内容：或者如果除数是一个双字，就必须大于EDX的内容。
右移指令可以用于除以2的幂的操作，SHR用于无符号数，而SAR用于带符号数。
12.8习题
12-1.对于无符号和带符号数据，它们的最大值是多少？（a）一个字节，（b）一个字，（c）一个双字。
0~255，-128~+127
0-65535，-32768~+32767
0-4294967295，-2147483648~+2147483647
格式                  字节         字                  双字
无符号               255         65535         4294967295
带符号               127         32767         2147483647
对于无符号数据，所有位都用作数据位；对于带符号数据，最左边的位是符号位。
12-2.按照算术操作的结果来区分进位与溢出。
进位标志CF主要用于反映运算是否产生进位或借位。
如果运算结果的最高位（字操作时的第15位或字节操作时的第7位）产生一个进位或借位，则CF被置1，否则CF被清0。
在进行多字节数的加减运算时，要使用到该标志；在比较无符号数的大小时，要使用到该标志。
移位指令也把操作数的最高位或最低位移入CF。移位指令和CF的配合，可实现操作数之间的位传送。

溢出标志OF用于反映有符号数加减运算是否引起溢出。如运算结果超出了8位或16位有符号数的表示范围，
即在字节运算时大于127或小于-128，在字运算时大于32767或小于-32768，称为溢出。如果溢出，则OF被置1，否则OF被清0。
要特别注意，溢出标志与进位标志是两个不同性质的标志，不能混淆。

对于无符号数运算，CPU用CF位来记录是否产生了进位；
对于有符号数运算，CPU用OF位来记录是否产生了溢出，
当然，还要用SF位来记录结果的符号。
12-3.对于以下二进制加法，表示出二进制的和以及其作为带符号与无符号十进制数的情况，并给出溢出与进位标志的设置：
（a）0001 0011（b）0101 0110（c）1101 0101（d）1101 1011
         0011 1000         0011 1001         0101 1010         1101 0110
         0100 1011         1000 1111       10010 1111       11011 0001
         4BH=75             8FH=143        1 2FH=47          1 B1H=177
                +75                     -113                 +47                    -79
         CF=0,OF=0       CF=0,OF=1      CF=1,OF=0       CF=1,OF=0
F6H+89H=17FH
CF=1,OF=1
12-4.“实现双字值的算术运算”一节包含2个把字对（第一个是WORD1A）相加的程序片断。
修改这2个例子，使得它们用3个字对取代2个字对进行相加。定义附加的字为WORD3A和WORD3B并把老的WORD3A和WORD3B改成WORD4A和WORD4B。
WORD1A DW 0BC62H
WORD1B DW 0123H
WORD2A DW 553AH
WORD2B DW 0012H
WORD3A DW 1234H
WORD3B DW 5678H
WORD4A DW ?
WORD4B DW ?

MOV AX,WORD1A
ADD AX,WORD2A
MOV WORD4A,AX
MOV AX,WORD1B
ADC AX,WORD2B
MOV WORD4B,AX

MOV AX,WORD4A
ADD AX,WORD3A
MOV WORD4A,AX
MOV AX,WORD4B
ADC AX,WORD3B
MOV WORD4B,AX

CLC
MOV CX,2
LEA SI,WORD1A
LEA DI,WORD2A
LEA BX,WORD4A
L20:MOV AX,[SI]
ADC AX,[DI]
MOV [BX],AX
INC SI
INC SI
INC DI
INC DI
INC BX
INC BX
LOOP L20

CLC
MOV CX,2
LEA SI,WORD4A
LEA DI,WORD3A
LEA BX,WORD4A
L30:MOV AX,[SI]
ADC AX,[DI]
MOV [BX],AX
INC SI
INC SI
INC DI
INC DI
INC BX
INC BX
LOOP L30
对于12-5题到12-8题，引用以下数据，按相反顺序正确定义字：
BIN_AMT1 DW 0147H
DW 139AH
BIN_AMT2 DW 02B3H
DW 2D41H
CAL_AMT DW 0
DW 0
DW 0
DW 0
12-5.编写指令完成下列相加操作：（a）字BIN_AMT1加到字BIN_AMT2，（b）起始于BIN_AMT1的双字加到BIN_AMT2处的双字。
MOV AX,BIN_AMT2
ADD AX,BIN_AMT1
MOV BIN_AMT2,AX

MOV AX,BIN_AMT2
MOV DX,BIN_AMT2+2
ADD AX,BIN_AMT1
ADC DX,BIN_AMT1+2
MOV BIN_AMT2,AX
MOV BIN_AMT2+2,DX
12-6.解释以下相关指令的作用：
STC
MOV BX,BIN_AMT1
ADC BX,BIN_AMT2
BX=字BIN_AMT1+字BIN_AMT2+1
12.7.编写指令做以下乘法（MUL）：（a）字BIN_AMT1乘以字BIN_AMT2，
（b)起始于BIN_AMT1的双字乘以字BIN_AMT2。乘积存入CAL_AMT。
MOV AX,BIN_AMT1
MUL WORD PTR BIN_AMT2
MOV EAX,BIN_AMT1
MOV EBX,0
MOV BX,BIN_AMT2
MUL EBX
MOV DWORD PTR CAL_AMT,EAX
MOV DWORD PTR CAL_AMT+4,EDX
12-8.编写指令做以下除法（DIV）：（a）字BIN_AMT1除以24H，（b）起始于BIN_AMT1的双字除以字BIN_AMT2。
商存入CAL_AMT。
MOV AX,BIN_AMT1
MOV BL,24H
DIV BL

MOV DX,BIN_AMT1+2
MOV AX,BIN_AMT1
MOV BX,BIN_AMT2
DIV BX
MOV CAL_AMT,AX
12-9.除零以外的什么除数会造成溢出错？
如果除数是一个字节，那么它的值必须大于AH，如果小于AH，则商有可能溢出；
如果除数是一个字，那么它的值必须大于DX，如果小于DX，则商有可能溢出；
如果除数是一个双字，它的值就必须大于EDX，如果小于EDX，则商有可能溢出。
12-10.参考“用移位做乘法”一节中把DX:AX对左移4位的例子。修改该例子为左移2位。
SHL DX,2   ;DX左移2位
MOV BL,AH   ;把AH存入BL
SHL AX,2   ;AX左移2位
SHR BL,6   ;BL右移2位
OR DL,BL   ;从BL往DL中插入2位
12-11.参考“用移位做除法”中把DX:AX对右移4位的例子。修改该例子为右移2位。
SHR AX,2
MOV BL,DL
SHR DX,2
SHL BL,6
OR AH,BL
第13章算术运算II：处理ASCII和BCD数据
13.1引言
13.2十进制格式的数据
13.3处理ASCII数据.
13.4处理压缩的BCD数据
13.5ASCII数据转换成二进制格式
13.6二进制数据转换成ASCI格式
13.7乘积的移位与舍入
13.8要点
13.9习题
目的：研究ASCII与BCD数据格式，实现这些格式的算术运算，以及这些格式与二进制格式之间的转换。
13.1引言
在计算机上进行算术运算的自然数据格式是二进制。正如我们在第12章所见到的那样，只要是程序本身定义的数据，二进制格式是不会发生什么大问题的。
但是，程序必须处理的大量数据，并不都是采用二进制格式。例如，从键盘输入程序的数值数据是以10为基数的ASCII字符格式。
类似地，在屏幕上显示的数字值也是ASCll格式。
一种相近的数值格式―二进制编码的十进制数，又称二-十进制数会偶然用到，并且以非压缩与压缩的形式出现。
PC提供许多便于简单算术运算与两种格式之间转换的指令。本章也会涉及有关把ASCII数据转换成二进制格式以便完成算术运算的技术，
以及为了观察而把二进制结果反过来转换成ASCII格式的技术。在本章末尾的程序中，综合了第1章到第12所涉及的许多资料。
在如C那样的高级语言中，编译程序是要解决小数点（十进制或二进制的）问题的。但是，计算机和汇编程序都不能识别在一个运算字段中的小数点，
所以汇编语言程序员就必须说明它的位置。
本章所介绍的指令是：
AAA 加法后的ASCII调整         AAD 除法的ASCII调整
AAS 减法后的ASCII调整         DAA 加法后的十进制调整
AAM 乘法后的ASCII调整        DAS 减法后的十进制调整
13.2十进制格式的数据
到现在为止，程序举例都是以二进制与ASCII格式来处理数字值的。处理器还支持二-十进制（BCD）格式，
它允许进行一些受限制的算术操作。BCD格式的两种用法是：
1.允许不损失精度的数的正常舍入，这一特性对于处理美元和美分时特别有用
（表示美元和美分的二进制数的舍入可能造成精度的损失）。
2.对于完成从键盘输入的小值的算术运算，或者对于在屏幕或打印机上的输出来说，BCD是个比较简单的格式。
BCD数字由4位组成，表示十进制数字0到9：
二进制         BCD数字         二进制         BCD数字
0000               0                 0101               5
0001               1                 0110               6
0010               2                 0111               7
0011               3                 1000               8
0100               4                 1001               9
可以按非压缩的或压缩的形式存放BCD数字：
（1）非压缩的BCD包含在每个字节较低（最右边）4位中的单个BCD数位，较高的4位是0。
注意，虽然ASCII格式的数据在某种意义上也是“非压缩的”，但是不那样叫它。
（2）压缩的BCD包含2个BCD数位：一个是较高的4位，一个是较低的4位。
这种格式通常用于使用数值协处理器的算术运算，由DT伪操作定义成10个字节。
下面是用3种格式表示十进制数1527的例子：
ASCII                  4字节         31 35 32 37
非压缩的BCD      4字节         01 05 02 07
压缩的BCD         2字节          15 27
处理器每次一个数位地完成ASCII和BCD值的运算。必须使用专门的指令来做两种格式之间的转换。
AAA
这条指令对在AL中的和（由两个未压缩的BCD码相加后的结果）进行调整，产生一个未组合的BCD码。
调整方法如下：
（1）如AL中的低4位在0~9之间，且AF为0，则转（3）；
（2）如AL中的低4位在A~F之间，或AF为1，则AL<-(AL)+6，AH<-(AH)+1，且AF位置1；
（3）清除AL的高4位；
（4）AF位的值送CF位。
该指令影响标志AF和CF，对其他标志均无定义。

AAS
这条指令对在AL中的差（由两个未压缩的BCD码相减后的结果）进行调整，产生一个未组合的BCD码。
调整方法如下：
（1）如AL中的低4位在0~9之间，且AF为0，则转（3）；
（2）如AL中的低4位在A~F之间，或AF为1，则AL<-(AL)-6，AH<-(AH)-1，且AF位置1；
（3）清除AL的高4位；
（4）AF位的值送CF位。
该指令影响标志AF和CF，对其他标志均无定义。

AAM
这条指令对在AL中的积（由两个未压缩的BCD码相乘MUL所得的的结果）进行调整，产生两个未压缩的BCD码。
调整方法如下：
把AL中的值除以10，商放在AH中，余数放在AL中。该指令影响标志SF，ZF和PF，对其他标志无影响。

AAD
该指令和其他调整指令的使用次序上不同，其他调整指令均安排在有关算术运算指令后，而这条指令应安排在除运算指令之前。
它的功能是：把存放在寄存器AH（高位十进制数）及存放在寄存器AL中的两位未压缩的BCD码，调整为一个二进制数，存放在寄存器AL中。
调整的方法如下：
AL=AH*10+(AL)
AH=0
由于采用上述调整方法，存放在AL和AH中的未压缩的BCD的高四位应为0。
该指令影响标志SF，ZF和PF，对其他标志无影响。
13.3处理ASCII数据
由于从键盘输入的数据是ASCII格式，所以输入的十进制值如1234在存储器中的表示是31 32 33 34H。
执行ASCII值算术运算的指令包括AAA和AAS：
[label:] AAA   ;加法后的ASCII调整
[label:] AAS   ;减法后的ASCII调整
这些指令被编码成没有操作数并自动调整AX寄存器中的ASCII值。
调整的结果是由ASCII值表示一个非压缩的基数为10的数，而处理器要执行的是基数为2的算术运算。
13.3.1ASCII数相加
研究下面ASCII数相加的3个例子的结果：
例1 35H+32H=67H
例2 38H+34H=6CH
例3 39H+39H=72H
在例1中，尽管最左边的数位是需要校正的，但最右边的数位的7是正确的和。
在例2中由于进位由十进制变成了十六进制数位，因此6CH不是正确的ASCII和。
由于进位是从个位到十位位置，所以例3是不正确的。
为了校正一个ASCII和，AAA操作检查AL寄存器最右边的十六进制数位。
如果数位在A与F之间或辅助进位标志（AF）是1，则该操作就把6加到AL上，把1加到AH上，
并且把进位标志（CF）和辅助进位标志都置成1。
在所有情况下，AAA都要把AL最左边的十六进制数位清除为零。
（为什么加6？因为那是十六进制（16）和十进制（10）之间的差）。
让我们看看AAA是如何处理前面的3个例子的。假设ASCII数是在AL和BL中，指令是：
ADD AL,BL   ;加ASCII数
AAA   ;对ASCII加进行调整
例1.35H与32H的和是67H。AAA检查最右边的数位（7）。因为它不在A与F之间，也没有设置AF标志，
所以AAA简单地把最左边的数位（6）清除为0。
例2.38H与34H的和是6CH。由于最右边的数位（C）是在A与F之间，AAA执行以下操作：
6CH+6->72H->02H CF=1 AF=1 AH=1
例3.39H与39H的和是72H。虽然最右边的数位（2）不是在A与F之间，但由于进位是进到十位位置，所以AF标志被置成1。
AAA完成以下操作：
72H+6->78H->08H CF=1 AF=1 AH=1
这些和00 06、01 02和01 08是技术上的BCD数。为了恢复ASCII表示，在AH与AL的最左边的十六进制数位中简单地插入3：
OR AX,3030H   ;把BCD转换成ASCII
对于1个字节的ASCII数相加来说，这一切都是非常好的。但是，多字节的ASCII数相加就需要一个循环，
该循环从右到左（低阶位到高阶位）进行处理，并把进位计算在内。图13-1中的部分程序是把2个3字节的ASCII数
（ASCVALUEI和ASCVALUE2）相加，并产生4字节的和ASCTOTAL。注意以下几点：
起点的CLC指令把CF标志置成0。
其后的A20处，MOVZX指令把相继的ASCII字符装入AL。由于其后的AAA可能要向AH加1，所以MOVZX还要清除AH，
它会存在于下一个循环里。注意，使用XOR或SUB来清除AH会改变CF标志。
ADC用于做加法，因为它能自动地把任何进位从AL加到AH。
MOV按ASCTOTAL的相继字节存放每一个ASCII"和"。
当循环完成时，程序把AH（包含最后的00或01）传送到ASCTOTAL的最左边的字节。
最后，ASCTOTAL是01 02 07 02H。为了在每个字节中插入ASCII 3，程序步进地通过ASCTOTAL，
并用30H去OR（或）每个字节。结果是31 32 37 32H，即十进制的1272，在结束之前程序会把它显示出来。
ASCVALUE1 DB '548'
ASCVALUE2 DB '724'
ASCTOTAL DB '0000'
...
CLC
LEA SI,ASCVALUE1+2
LEA DI,ASCVALUE2+2
LEA BX,ASCTOTAL+3
MOV CX,3
A20:MOV AX,0
MOV AL,DS:[SI]
ADC AL,DS:[DI]
AAA
MOV DS:[BX],AL
DEC SI
DEC DI
DEC BX
LOOP A20
MOV DS:[BX],AH
LEA BX,ASCTOTAL+3
MOV CX,4
A30:OR BYTE PTR DS:[BX],30H
DEC BX
LOOP A30
MOV AX,1300H
MOV BX,0031H
LEA BP,ASCTOTAL
MOV CX,4
MOV DX,0824H
INT 10H
...
程序在AAA之后没有用OR去插入最左边的3，因为OR要设置进位标志并会改变ADC指令的结果。
一个解决方案是通过标志寄存器进栈（PUSH）来保存标志的设置，执行OR，然后把标志出栈（POPF）以恢复标志的设置：
ADC AL,DS:[DI]
AAA
PUSHF
OR AL,30H
POPF
MOV DS:[BX],AL
13.3.2ASCII数相减
AAS指令的工作非常像AAA。AAS检查AL的最右边的十六进制数位（4位）。
如果该数位在A到F之间或辅助进位为1，则该操作从AL中减去6，从AH中减去1，
并且设置辅助进位标志（AF）和进位标志（CF）为1。在任何情况下，AAS都要清除AL最左边的十六进制数位。
以下两个例子假定ASCVALUE1是39H，ASCVALUE2是35H。
第一个例子是从ASCVALUE1（39H）中减去ASCVALUE2（35H）。
AAS不需要进行调整，因为最右边的十六进制数位是小于十六进制A的：
MOV AL,ASCVALUE1
SUB AL,ASCVALUE2
AAS
OR AL,30H
39H-35H->04H->34H
第二个例子是从ASCVALUE2（35H）中减去ASCVALUE1（39H）。
由于结果的最右边数位是十六进制的C，所以AAS从AL中减去6，从AH中减去1，并设置AF和CF标志：
MOV AL,ASCVALUE2
SUB AL,ASCVALUE1
AAS
假设AH=00H
35H-39H=FCH
00FCH->FF06H AH=AH-1 CF=1 AF=1
相当于15-9=6
答案应该是-4，即FF06H，它是个十的补码，即十进制-10+6=-4。
13.3.3ASCII数相乘
ASCII数的乘法和除法首先需要把它们转换成非压缩的BCD格式（高4位为0），
然后可以使用AAM和AAD指令直接地去执行非压缩的BCD数的算术运算：
[label:] AAM   ;乘法之后的ASCII调整
[label:] AAD   ;除法之前的ASCII调整
AAM 指令校正在AX寄存器中相乘的ASCII数据的结果。
但是，必须首先清除每个字节最左边的十六进制数位3，从而把该值转换成非压缩的BCD，
使AAM实际地校正BCD数据（不是ASCII数据）。
例如，ASCIl数31 32 33 34H变成01 02 03 04H成为非压缩的BCD。
还有，由于每次只是调整一个字节，所以可以只乘1字节字段并必须在一个循环中重复执行该操作。
只使用MUL（无符号乘法）操作（不是IMUL操作）。
AAM把AL除以10（0AH）并把商存放到AH，把余数存放到AL。
例如，假设AL包含ASCII 35H，CL包含39H。以下的代码是把AL的内容乘以CL并把结果转换成ASCII格式：
AL=35H CL=39H
AND CL,0FH
AND AL,0FH
MUL CL
AAM
OR AX,3030H
MUL操作在AX中产生002DH（45）。AAM把这个值除以0AH，产生的商04在AH，而余数05在AL。
然后OR指令把非压缩的BCD值转换成ASCII格式。
图13-2的部分程序描述的是4字节ASCII被乘数与1字节ASCII乘数的相乘。
因为AAM只能适于1字节操作，所以程序要每次一个字节地步进地从右到左经过被乘数。
最后，非压缩的BCD乘积是01 08 09 01 05，在循环到A30处转换成正确的ASCII格式31 38 39 31 35，即十进制的18915。
在结束处理之前，程序显示这个乘积。
如果乘数大于一个字节，那么你必须还要提供另外一个循环，该循环步进地经过乘数。
在那种情况下，把ASCII数据转换成二进制格式可能更为简单。下一节会涉及这一问题。
MULTCAND DB '3783'
MULTPLER DB '5'
ASCPROD DB 5 DUP (0)
...
MOV CX,4
LEA SI,MULTCAND+3
LEA DI,ASCPROD+4
AND MULTPLER,0FH
A20:MOV AL,DS:[SI]
AND AL,0FH
MUL BYTE PTR MULTPLER
AAM
ADD AL,DS:[DI]
AAA
MOV DS:[DI],AL
DEC DI
MOV DS:[DI],AH
DEC SI
LOOP A20
LEA BX,ASCPROD+4
MOV CX,5
A30:OR BYTE PTR DS:[BX],30H
DEC BX
L0OP A30
MOV AX,1300H
MOV BX,0031H
LEA BP,ASCPROD
MOV CX,5
MOV DX,0824H
INT 10H
...
13.3.4ASCII数相除
AAD指令在除法之前提供对于ASCII被除数的校正。正如AAM一样，首先要从ASCII字节中清除最左边的些3，产生非压缩的BCD格式。
AAD允许2字节的被除数放在AX中。除数可以是只有单字节的01到09。
假定AX是ASCII值28（32 38H），CL是除数ASCII 7（37H）。以下各指令实现调整与除法：
AND CL,0FH
AND AX,0F0FH
AAD
DIV CL
AAD使AH乘以10（0AH），把乘积20（14H）加到AL上，并且清除AH。结果001CH是十进制28的十六进制表示。
图13-3中的部分程序是1字节的除数去除4字节被除数的除法。程序从左到右步进地经过被除数。
LODSB从DIVIDEND中取一个字节到AL（通过SI）中，而STOSB把来自AL的字节存入ASCQUOT（通过DI）。
余数仍保留在AH中，使得AAD能在AL中调整它。最后，非压缩的BCD格式的商是00 09 02 04，而在AH中的余数是02。
程序把商转换成ASCII格式的30 39 32 34（这次是从左到右），并显示ASCII商0 9 2 4。
如果除数大于一个字节，那么你就必须还要提供另一个循环，步进地经过除数。
还有更好的办法，见后面的“ASCII数据转换成二进制格式”一节。
DIVIDEND DB '3698'
DIVISOR DB '4'
ASCQUOT DB 4 DUP (0),'$'
...
MOV CX,4
SUB AH,AH
AND BYTE PTR DIVISOR,0FH
LEA SI,DIVIDEND
LEA DI,ASCQUOT
A20:LODSB
AND AL,0FH
AAD
DIV BYTE PTR DIVISOR
STOSB
LOOP A20
LEA BX,ASCQUOT
MOV CX,4
A30:OR BYTE PTR DS:[BX],30H
INC BX
LOOP A30
MOV AH,09H
LEA DX,ASCQUOT
INT 21H
...
DAA
这条指令对在AL中的和（由两个压缩的BCD码相加后的结果）进行调整，产生一个压缩的BCD码。
调整方法如下：
（1）如AL中的低4位在A~F之间，或AF为1，则AL<-(AL)+6，且AF位置1；
（2）如AL中的高4位在A~F之间，或CF为1，则AL<-(AL)+60H，且CF位置1。
该指令影响标志AF，CF，PF，SF和ZF，但不影响标志OF。

DAS
这条指令对在AL中的差（由两个压缩的BCD码相减后的结果）进行调整，产生一个压缩的BCD码。
调整方法如下：
（1）如AL中的低4位在A~F之间，或AF为1，则AL<-(AL)-6，且AF位置1；
（2）如AL中的高4位在A~F之间，或CF为1，则AL<-(AL)-60H，且CF位置1。
该指令影响标志AF，CF，PF，SF和ZF，但不影响标志OF。
13.4处理压缩的BCD数据
在前面ASCII除法的例子中，商是00 09 02 04。如果压缩这个值，只保留每个字节右边的数位，结果就成了0924，
而现在是压缩的BCD格式。可以使用2条十进制调整指令DAA和DAS对压缩的BCD数据实现加法和减法：
[label:] DAA   ;加法后的十进制调整
[label:] DAS   ;减法后的十进制调整
DAA校正在AL中的2个压缩的BCD值相加的结果，而DAS校正它们相减的结果。
再次提醒：你必须每次一个字节（两个数位）地处理BCD字段。
在AL中的BCD和是由2个4位的数位组成的。
如果最右边数位的值超过9或AF标志被置1，那么DAA向AL加6并把AF置1。
如果现在AL中的值超过99H或CF被置1，那么DAA向AL加60H并把CF置1。
否则，它清除AF和CF。以下的例子将说明这一过程。
考虑BCD值05 78 36和06 94 27相加。由于CF标志被清除为0，所以开始把在AL中的最右边一对数位相加，即36+27：
36+27=63  36H+27H=5DH
5DH+06->63H AF=1
78+94=172 78H+94H=10CH
10CH+06->112H AF=1
112H+60H->172H CF=1
05+06=11 05H+06H=0BH
11+1=12  0BH+1=0CH
0CH+06->12H
现在，BCD的和正确地存放为12 72 63。
图13-4中的部分程序说明上述BCD加法的例子。
过程B10CONVRT把ASCII值ASCVALUE1和ASCVALUE2分别转换成压缩的BCD值BCDVALUE1和BCDVALUE2。
从右到左进行的处理可以和从左到右一样的容易。另外，处理字比处理字节更容易，
这是因为需要2个ASCII字节去产生一个压缩的BCD字节。但是，使用字要求ASCII字段的字节数为偶数。
该程序完成3次循环把压缩的BCD数加到BCDSUM上。最后的和是00 12 72 63H，它是可以用DEBUG来核定的。
把BCD和转换成ASCII并显示它是一个有用的练习。
ASCVALUE1 DB '057836'
ASCVALUE2 DB '069427'
BCDVALUE1 DB '000'
BCDVALUE2 DB '000'
BCDSUM DB 4 DUP (0),'$'
...
LEA SI,ASCVALUE1+4
LEA DI,BCDVALUE1+2
CALL B10CONVRT
LEA SI,ASCVALUE2+4
LEA DI,BCDVALUE2+2
CALL B10CONVRT

XOR AH,AH
LEA SI,BCDVALUE1+2
LEA DI,BCDVALUE2+2
LEA BX,BCDSUM+3
MOV CX,3
CLC
A20:MOV AL,DS:[SI]
ADC AL,DS:[DI]
DAA
MOV DS:[BX],AL
DEC SI
DEC DI
DEC BX
LOOP A20
MOV AL,0
ADC AL,0
DAA
MOV DS:[BX],AL
LEA BX,BCDSUM
MOV CX,4
A30:OR BYTE PTR DS:[BX],30H
INC BX
LOOP A30
MOV AH,09H
LEA DX,BCDSUM
INT 21H
...
B10CONVRT PROC NEAR
MOV CX,3
B20:MOV AX,DS:[SI]
XCHG AH,AL
SHL AL,4
SHL AX,4
MOV DS:[DI],AH
DEC SI
DEC SI
DEC DI
LOOP B20
RET
B10CONVRT ENDP
13.5ASCII数据转换成二进制格式
按ASCII或BCD格式完成算术运算只适于短字段。对于大多数算术运算来说，把这样的数转换成二进制格式将更为实用。
实际上，从ASCII直接转换成二进制比从ASCII转换到BCD再转换成二进制要更加容易。
从ASCII格式转换成二进制是基于这样的事实：ASCII数是以10为基数的，而计算机执行算术运算是以2为基数的。
下面是这一过程：
1.由ASCII字段的最右边字节开始，并从右到左进行处理。
2.从每个ASCII字节左边的十六进制数位中去掉3，形成一个压缩的BCD数。
3.第一个（最右边的）BCD数位乘以1，第二个数位乘以10（0AH），第三个乘以100（64H），以此类推，并计算乘积的总和。
以下例子是把ASCII数3569从右到左转换成二进制数：
9*1=9                        09H
6*10=60                    3CH
5*100=500              01F4H
3*1000=3000          0BB8H
              3569          0DF1H
试检查一下和0DF1H，实际上它等于十进制的3569。
在下一例子中，部分程序把ASCIl数3569转换成它的二进制等效值：
ASCLENTH EQU 4
ASCVALUE DB '3569'
BINVALUE DW 0
MULTFACT DW 1
...
MOV BX,10
MOV CX,ASCLENTH
LEA SI,ASCVALUE+3
L10:MOV AL,DS:[SI]
AND AX,000FH
MUL WORD PTR MULTFACT
ADD WORD PTR BINVALUE,AX
MOV AX,MULTFACT
MUL BX
MOV MULTFACT,AX
DEC SI
LOOP L10
LEA指令初始化ASCII字段的最右边字节的地址，把ASCVALUE+3放在SI中。
在L10处的指令把ASCII字节传送到AL，即MOV AL,DS:[SI]。
该操作使用ASCVALUE+3的地址把ASCVALUE最右边的字节复制到AL中。循环的每次迭代都使SI减1，并访问左边的下一个字节。
循环对于ASCVALUE的4个字节中每一个进行重复。还有，每次送代MULTFACT乘以10（0AH），
给出的乘数是1，10，100，以及1000。最后，BINVALUE包含正确的二进制值F10DH，是以相反字节顺序排列的。
在下一节中的程序是反过来把二进制值转换成十进制格式。
13.6二进制数据转换成ASCII格式
为了打印或显示二进制算术运算的结果，首先必须把它转换成ASCII格式。该操作是把前述的步骤反过来进行：
取代乘法的是重复地用10（0AH）去除二进制数，直到商小于10。每个余数（只能是0到9）相继地产生ASCII数。
作为一个例子，让我们把ODF1H反过来转换成十进制格式：
0DF1H / 0AH = 164H,9
0164H/0AH = 23H,6
23H/0AH=03H,5
由于商（3）现在小于除数（0AH），所以操作完成。
从右到左的余数和最后的商一起形成BCD结果：3569。
剩下的所有事情是把这些数字与ASCII 3一起存入存储器中，成为33 35 36 39。
以下的例子是把二进制数0DF1H转换为ASCII格式：
ASCVALUE DB 4 DUP (20H)
BINVALUE DW 0DF1H
...
MOV CX,10
LEA SI,ASCVALUE+3
MOV AX,BINVALUE
L20:CMP AX,CX
JB L30
XOR DX,DX
DIV CX
OR DL,30H
MOV DS:[SI],DL
DEC SI
JMP L20
L30:OR AL,30H
MOV DS:[SI],AL
...
该例子是把二进制数相继地除以10（0AH），直到剩下的商小于10为止，
并以ASCII格式存放所产生的十六进制数位为33 35 36 39。你可能发现复制这个程序并步进地跟踪它的执行是有用的。
13.7乘积的移位与舍入
假设一个乘积有3个十进制小数位，而必须舍入它，并且使它减少到2个十进制小数位。
例如，如果乘积是17.385，在最右边的（不希望有的）十进制小数位置上加5，并右移一个数位：
17.385+0.005=17.390=17.39
如果（a）乘积是17.3855，加50并移2个数位，并且如果（b）乘积是17.38555，加500并移3个数位：
17.3855+0.0050=17.3905=17.39
17.38555+0.00500=17.39055=17.39
进一步说，有6个十进制小数位的数需要加5000并且要移4个数位，以此类推。
现在，由于计算机通常都是处理二进制数据，17,385表示为43E9H。43E9H加5得到43EEH或十进制格式的17390。
到此为止，一切良好。但是，移一个二进制数位结果形成21F7H或8695，确实，简单的移位使该值减半。
43EEH右移1位=21F7H
你需要等效于右移一个十进制数位的移位。可以用把被舍入的进制值除以10（或hex0A）的办法完成这种移位：
hex 43EE除以hex0A=06CBH。把06CBH转换成十进制数得到1739。
现在，在正确的位置上正好插入十进制的小数点，并且你可以显示这个被舍入的移位的值为17.39。
用这一方法，可以舍入与移位任何二进制数。对于3个十进制小数位的，是加5并除以10；
对于4个十进制小数位的，是加50再除以100。也许你已经注意到了一种模式：舍入因子（5，50，500等等）
总是移位因子值（10，100，1000等等）的一半。
当然，二进制数中的小数点是隐含的，并且实际上是不出现的。
程序：ASCII与二进制数据之间的转换
在图13-5中的程序允许用户输入量和速率，并显示所计算的值。
例如，量可以是千瓦小时或加仑。为简洁起见，程序省略了某些出错检查，不然这些检查是应该包括在内的。
另外，每个过程都指明了所用的寄存器，而不是让它们进栈和出栈。这些过程如下：
A10MAIN处理初始化并为输入数据与计算值调用过程。
B10INPUT从键盘接受ASCII格式的量和速率，这些值可以包含十进制的小数点。
C10QTY初始化从ASCII量到二进制的转换。
D10RATE初始化从ASCII速率到二进制的转换。
E10MULT实现乘法，并对具有3个或更多十进制小数位的任何乘积进行舍入与移位。
F10PROD插入十进制小数点，确定最右边的位置，以便开始存放ASCII字符，并且把二进制的乘积转换成ASCII值。
.MODEL SMALL
.STACK 512
.DATA
LEFTCOL EQU 28
RIGHTCOL EQU 63
TOPROW EQU 10
BOTROW EQU 14
QTYPARAM LABEL BYTE
MAXQLEN DB 6
ACTQLEN DB ?
QTYFLD DB 16 DUP (?)
RATEPAR LABEL BYTE
MAXRLEN DB 6
ACTRLEN DB ?
RATEFLD DB 16 DUP (?)
PROMPT1 DB 'Quantity:       '
PROMPT2 DB 'Rate:           '
PROMPT3 DB 'Product = '
ASCPROD DB 16 DUP (30H)
PROMPT4 DB 'Press any key to continue or Esc to quit'
ADJUST DW ?
BINPROD DW 0
BINQTY DW 0
BINRATE DW 0
COL DB 0
ROW DB 0
DECIND DB 0
MULT10 DW 1
NODECIMS DW 0
SHIFT DW ?
TENWD DW 10
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
MOV AX,0003H
INT 10H
A20:CALL Q10WINDOW
CALL B10INPUT
CALL C10QTY
CALL D10RATE
CALL E10MULT
CALL F10PROD
CALL G10FORMAT
CALL H10PAUSE
CMP AL,1BH
JNE A20
MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10INPUT PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV BYTE PTR ROW,TOPROW+1
MOV BYTE PTR COL,LEFTCOL+3
LEA BP,PROMPT1
MOV CX,16
CALL K10DISPLY
MOV AH,0AH
LEA DX,QTYPARAM
INT 21H
MOV BYTE PTR COL,LEFTCOL+3
INC BYTE PTR ROW
LEA BP,PROMPT2
MOV CX,16
CALL K10DISPLY
MOV AH,0AH
LEA DX,RATEPAR
INT 21H
INC BYTE PTR ROW
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
B10INPUT ENDP
C10QTY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV WORD PTR NODECIMS,0
MOV CX,0
MOV CL,ACTQLEN
LEA SI,QTYFLD-1
ADD SI,CX
CALL J10ASCBIN
MOV AX,BINPROD
MOV BINQTY,AX
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
C10QTY ENDP
D10RATE PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV CX,0
MOV CL,ACTRLEN
LEA SI,RATEFLD-1
ADD SI,CX
CALL J10ASCBIN
MOV AX,BINPROD
MOV BINRATE,AX
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
D10RATE ENDP
E10MULT PROC NEAR
MOV CX,16
LEA DI,ASCPROD
MOV AL,30H
CLD
REP STOSB
MOV WORD PTR SHIFT,10
MOV WORD PTR ADJUST,0
MOV BP,10
MOV CX,NODECIMS
CMP CL,4
JA E40
SUB CX,2
JLE E30
MOV WORD PTR NODECIMS,2
MOV AX,1
E20:MUL BP
LOOP E20
MOV WORD PTR SHIFT,AX
SHR AX,1
MOV WORD PTR ADJUST,AX
E30:MOV AX,BINQTY
MUL WORD PTR BINRATE
ADD AX,ADJUST
ADC DX,0
CMP WORD PTR ADJUST,0
JZ E80
JMP E50
E40:XOR AX,AX
JMP E70
E50:MOV CX,WORD PTR SHIFT
CALL DIVDW
JMP E80
E70:XOR DX,DX
E80:RET
E10MULT ENDP
F10PROD PROC NEAR
LEA SI,ASCPROD+11
MOV BYTE PTR DS:[SI],'.'
ADD SI,NODECIMS
F30:CMP BYTE PTR DS:[SI],'.'
JNE F40
DEC SI
F40:CMP DX,0
JNZ F50
CMP AX,0
JZ F60
F50:MOV CX,TENWD
CALL DIVDW
OR CL,30H
MOV DS:[SI],CL
DEC SI
JMP F30
F60:RET
F10PROD ENDP
G10FORMAT PROC NEAR
MOV BYTE PTR COL,LEFTCOL+3
MOV CX,16
LEA SI,ASCPROD
G20:CMP BYTE PTR DS:[SI],30H
JNE G30
MOV BYTE PTR DS:[SI],20H
INC SI
LOOP G20
G30:LEA BP,PROMPT3
MOV CX,26
CALL K10DISPLY
RET
G10FORMAT ENDP
H10PAUSE PROC NEAR
MOV BYTE PTR COL,20
MOV BYTE PTR ROW,22
LEA BP,PROMPT4
MOV CX,40
CALL K10DISPLY
MOV AH,10H
INT 16H
RET
H10PAUSE ENDP
J10ASCBIN PROC NEAR
MOV WORD PTR MULT10,1
MOV WORD PTR BINPROD,0
MOV BYTE PTR DECIND,0
XOR BX,BX
MOV BP,10
J20:MOV AL,DS:[SI]
CMP AL,'.'
JNE J30
MOV BYTE PTR DECIND,1
JMP J40
J30:AND AX,000FH
MUL WORD PTR MULT10
ADD WORD PTR BINPROD,AX
MOV AX,MULT10
MUL BP
MOV WORD PTR MULT10,AX
CMP BYTE PTR DECIND,0
JNZ J40
INC BX
J40:DEC SI
LOOP J20
CMP BYTE PTR DECIND,0
JZ J90
ADD WORD PTR NODECIMS,BX
J90:RET
J10ASCBIN ENDP
K10DISPLY PROC NEAR
MOV AX,1301H
MOV BX,0016H
MOV DH,ROW
MOV DL,COL
INT 10H
RET
K10DISPLY ENDP
Q10WINDOW PROC NEAR
MOV AX,0605H
MOV BH,16H
MOV CH,TOPROW
MOV CL,LEFTCOL
MOV DH,BOTROW
MOV DL,RIGHTCOL
INT 10H
RET
Q10WINDOW ENDP
DIVDW PROC NEAR
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
END A10MAIN
G10FORMAT把导前的零清除为空白，并调用K10DISPLY显示该值。
H10PAUSE提示键盘输入。（在通知程序中止处理而结束时，按<Esc>键。）
J10ASCBIN把ASCII转换成二进制（量和速率的公用例行程序），并在输入的数据中确定十进制小数位的数量。
K10DISPLY 在屏幕上显示数据。
Q10WINDOW在屏幕中部开一个窗口，用来显示量、速率和值。
1.限制。这个程序的一个限制是：在量和速率中的十进制小数位的总数必须是6或小于6。
另外一个限制是乘积的大小。假定量和速率的十进制小数位的总数超过6，或假定乘积超过约655350，
那么程序就要把乘积清除为0。实际上，程序会打印警告信息或包含了克服这些限制的过程。
2.出错检查。程序是为用户而不是为程序员设计的，它不仅会产生一些警告信息，而且应该确认量和速率的有效性。
仅有的有效字符是0到9和一个十进制的小数点。对于任何其他字符，程序都将显示一个信息并重新显示输入提示符。
在这点上，XALT是非常有用的指令，在第14章会涉及到它。
在练习中，用所有可能的条件严格地测试你的程序，比如零值，非常大的值和非常小的值，以及负值。
3.负值。某些应用会包括负值，特别是对于一些反向的和修正的输入。你可以允许负的符号跟在一个值的后面，比如12.34-，
或在值的前面，如-12.34，然后程序在转换成二进制期间可以对这个负的符号进行检查。
另一方面，你可能想留下二进制数的正值，再简单地设置一个指示符去记录该值是负。
当该算术运算完成时，假如需要的话，该程序可以把一个负的符号插入到ASCII字段的左边或右边去。
为了使二进制数成为负值，照例要把ASCII输入转换成二进制（见在第12章中有关改变二进制字段符号的“符号变反”一节），
并且注意使用IMUL和IDIV去处理带符号数据。对于负数的舍入，是用减5代替加5。
13.8要点
ASCII字段要求每个字符一个字节。对于一个数字字段，最右边半个字节是数字，而最左边半个字节是3。
把ASCII数最左边的一些3清除为0，则把该字段转换成非压缩的二-十进制（BCD）格式。
压缩ASCII字符成每个字节2个数位，则把该字段转换成压缩的二-十进制（BCD）数据。
在ASCII加法之后，用AAA来调整答案；在ASCII减法之后，用AAS来调整答案。
在ASCII乘法之前，被乘数和乘数应该用把最左边的十六进制3清除为0的办法转换成非压缩的BCD。
乘法之后，用AAM来调整乘积。
在ASCII除法之前，被除数与除数应该用清除最左边十六进制3的办法转换成非压缩的BCD，而AAD则用于调整被除数。
对于大多数算术运算来说，ASCII数应该转换成二进制。用于这一目的的有效ASCII字符是30H到39H，十进制的小数点，
以及有可能的负的符号。
13.9习题
13-1.假设BX的内容是ASCII 9（0039H），而DX的内容是ASCII 5（0035H）。说明以下不相关操作的结果：
（a）ADD BX,0034H（b)ADD BX,DX（c）SUB BX,DX（d）SUB BX,000CH
         AAA                        AAA                    AAS                    AAS
006DH->0103H CF=1
006EH->0104H CF=1
0004H CF=0
002DH->FF 07H CF=1
13-2.使用十六进制表示法把十进制值4127表示成以下格式：
（a）ASCII，（b）非压缩的BCD，（c）压缩的BCD。
4127=101FH
34 31 32 37H
04 01 02 07H
41 27H
13-3.一个名为BCDVAL的非压缩BCD字段的内容是01 06 08 03H。
编写一个循环，使该字段的内容成为正确的ASCII 31 36 38 33H。
假设BCDVAL对应的段为DS
...
LEA SI,BCDVAL
MOV CX,4
L20:MOV AL,DS:[SI]
OR AL,30H
MOV DS:[SI],AL
INC SI
LOOP L20
...
13-4.名为ASCVAL1的字段的内容是ASCII十进制值174，而另一个名为ASCVAL2字段的内容是ASCII4。
编写指令进行ASCII数相乘，并把乘积存放在ASCPROD中。
ASCVAL1 DB '174'
ASCVAL2 DB '4'
ASCPROD DB 5 DUP (0)
...
MOV CX,3
LEA SI,ASCVAL1+2
LEA DI,ASCPROD+4
AND ASCVAL2,0FH
A20:MOV AL,DS:[SI]
AND AL,0FH
MUL BYTE PTR ASCVAL2
AAM
ADD AL,DS:[DI]
AAA
MOV DS:[DI],AL
DEC DI
MOV DS:[DI],AH
DEC SI
LOOP A20
LEA BX,ASCPROD+4
MOV CX,5
A30:OR BYTE PTR DS:[BX],30H
DEC BX
L0OP A30
...
13-5.使用如13-4题同样的字段，把ASCVAL1除以ASCVAL2并把商存放在ASCQUOT中。
ASCVAL1 DB '174'
ASCVAL2 DB '4'
ASCQUOT DB 4 DUP (0)
...
MOV CX,3
SUB AH,AH
AND BYTE PTR ASCVAL2,0FH
LEA SI,ASCVAL1
LEA DI,ASCQUOT
A20:LODSB
AND AL,0FH
AAD
DIV BYTE PTR ASCVAL2
STOSB
LOOP A20
LEA BX,ASCQUOT
MOV CX,4
A30:OR BYTE PTR DS:[BX],30H
INC BX
LOOP A30
...
13-6.对以下操作提供手工计算：（a）把ASCII十进制值29765转换成二进制值，并以十六进制格式表示其结果；
（b）反过来再把十六进制值转换成ASCII值。
ASCLENTH EQU 5
ASCVALUE DB '29765'
BINVALUE DW 0
MULTFACT DW 1
...
MOV BX,10
MOV CX,ASCLENTH
LEA SI,ASCVALUE+4
L10:MOV AL,DS:[SI]
AND AX,000FH
MUL WORD PTR MULTFACT
ADD WORD PTR BINVALUE,AX
MOV AX,MULTFACT
MUL BX
MOV MULTFACT,AX
DEC SI
LOOP L10

5 = 0005H
65 = 0041H
765 = 02FDH
9765 = 2625H
29765 = 7445H

ASCVALUE DB 5 DUP (20H)
BINVALUE DW 7445H
...
MOV CX,10
LEA SI,ASCVALUE+4
MOV AX,BINVALUE
L20:CMP AX,0
JZ L30
XOR DX,DX
DIV CX
OR DL,30H
MOV DS:[SI],DL
DEC SI
JMP L20
L30:
...
13-7.编写并测试一个程序：（a）在EAX，EBX，ECX和EDX中插入二进制值，（b）以ASCII格式显示每个寄存器的值。
PUTCH显示单个ASCII字符
HTOASC把一个十六进制数转为一个ASCII字符
AHTOASC把一个字节转为两个ASCII字符，分别在AH、AL
DAHTOASC显示一个字节，要显示的字节放在AL
DHTOASC显示一个字，要显示的字放在AX
DDHTOASC显示一个双字，要显示的双字放在DX、AX
显示EAX
PUSH EAX
SHR EAX,16
MOV DX,AX
POP EAX
CALL DDHTOASC
显示EBX
MOV AX,BX
PUSH EBX
SHR EBX,16
MOV DX,BX
POP EBX
CALL DDHTOASC
显示ECX
MOV AX,CX
PUSH ECX
SHR ECX,16
MOV DX,CX
POP ECX
CALL DDHTOASC
显示EDX
PUSH EDX
MOV AX,DX
SHR EDX,16
CALL DDHTOASC
POP EDX

PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
HTOASC PROC
AND AL,0FH
ADD AL,90H
DAA
ADC AL,40H
DAA
RET
HTOASC ENDP
AHTOASC PROC
MOV AH,AL
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
CALL HTOASC
XCHG AH,AL
CALL HTOASC
RET
AHTOASC ENDP
DAHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DAHTOASC ENDP
DHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH AX
XCHG AH,AL
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DHTOASC ENDP
DDHTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH AX
MOV AL,DH
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
MOV AL,DL
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
PUSH AX
XCHG AH,AL
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP AX
CALL AHTOASC
PUSH AX
MOV AL,AH
CALL PUTCH
POP AX
CALL PUTCH
POP DX
POP CX
POP BX
POP AX
RET
DDHTOASC ENDP
13-8.编写并测试一个程序：（a）从键盘接受2个数字值，（b）把2个ASCII值转换成二进制格式，（c）二进制值相加，（d）把二进制和转换成ASCII格式，
（e）显示ASCII和。要考虑到任何成对的数的输入。为指明不再输入数据，用户只需按<Enter>键。
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
GET_BUF DB 128 DUP (0)
MESS_FORMAT DB 'Please choose arithmetic format[0 ADD,1 SUB,2 MUL,3 DIV]:','$'
MESS_DECSTR1 DB 'Please input DEC string1:','$'
MESS_DECSTR2 DB 'Please input DEC string2:','$'
num1_d dw 0
num1_a dw 0
num2_d dw 0
num2_a dw 0
res_dx dw 0
res_cx dw 0
res_bx dw 0
res_ax dw 0
num_dx dw 0
num_cx dw 0
num_bx dw 0
num_ax dw 0
val_dx dw 0
val_cx dw 0
val_bx dw 0
val_ax dw 0
mul_table dd 1,10,100,1000,10000,100000,1000000,10000000,100000000
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG
START:MOV AX,DSEG
MOV DS,AX
CALL CONVERT
MOV AH,4CH
INT 21H
ISDEC PROC
CMP AL,'0'
JB ISDEC_NODEC
CMP AL,'9'
JA ISDEC_NODEC
CLC
JMP ISDEC_OK
ISDEC_NODEC:STC
ISDEC_OK:RET
ISDEC ENDP
ISFMT PROC
CMP AL,'0'
JB ISFMT_NOFMT
CMP AL,'3'
JA ISFMT_NOFMT
CLC
JMP ISFMT_OK
ISFMT_NOFMT:STC
ISFMT_OK:RET
ISFMT ENDP
ATOBIN PROC
SUB AL,30H
CMP AL,9
JBE ATOBIN_OK
SUB AL,7
CMP AL,15
JBE ATOBIN_OK
SUB AL,20H
ATOBIN_OK:RET
ATOBIN ENDP
DTOBIN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DI,SI
ADD DI,CX
DEC DI
MOV BP,0
MOV VAL_AX,0
MOV VAL_DX,0
DTOBIN_FORJ:CMP DI,SI
JB DTOBIN_OK
MOV AL,DS:[DI]
CALL ATOBIN
MOV AH,0
MOV BX,AX
MOV AX,0
MOV DX,WORD PTR MUL_TABLE[BP]
MOV CX,WORD PTR MUL_TABLE[BP+2]
CALL MULDW
ADD VAL_AX,AX
ADC VAL_DX,BX
DTOBIN_NEXTJ:DEC DI
INC BP
INC BP
INC BP
INC BP
JMP DTOBIN_FORJ
DTOBIN_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOBIN ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRD PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRD1:CALL GETCH
CMP AL,CR
JZ GETSTRD5
CMP AL,BACKSPACE
JNZ GETSTRD4
CMP BX,0
JZ GETSTRD2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRD1
GETSTRD2:CALL BELL
JMP GETSTRD1
GETSTRD4:CMP BX,9
JZ GETSTRD2
CALL ISDEC
JC GETSTRD2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRD1
GETSTRD5:CMP BX,1
JB GETSTRD2
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRD_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRD ENDP
GETSTRF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRF1:CALL GETCH
CMP AL,CR
JZ GETSTRF5
CMP AL,BACKSPACE
JNZ GETSTRF4
CMP BX,0
JZ GETSTRF2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRF1
GETSTRF2:CALL BELL
JMP GETSTRF1
GETSTRF4:CMP BX,1
JZ GETSTRF2
CALL ISFMT
JC GETSTRF2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRF1
GETSTRF5:CMP BX,1
JB GETSTRF2
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRF_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRF ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
MULDW PROC
MOV NUM_AX,AX
MOV NUM_BX,BX
MOV NUM_CX,CX
MOV NUM_DX,DX
MOV AX,NUM_AX
MOV BX,NUM_CX
MUL BX
MOV RES_DX,DX
MOV RES_CX,AX
MOV AX,NUM_BX
MOV BX,NUM_DX
MUL BX
MOV RES_BX,DX
MOV RES_AX,AX
MOV AX,NUM_AX
MOV BX,NUM_DX
MUL BX
ADD AX,RES_BX
ADC WORD PTR RES_CX,0
ADC WORD PTR RES_DX,0
ADD DX,RES_CX
ADC WORD PTR RES_DX,0
MOV RES_CX,DX
MOV RES_BX,AX
MOV AX,NUM_BX
MOV BX,NUM_CX
MUL BX
ADD AX,RES_BX
ADC WORD PTR RES_CX,0
ADC WORD PTR RES_DX,0
ADD DX,RES_CX
ADC WORD PTR RES_DX,0
MOV RES_CX,DX
MOV RES_BX,AX
MOV DX,RES_DX
MOV CX,RES_CX
MOV BX,RES_BX
MOV AX,RES_AX
RET
MULDW ENDP
DIVDD PROC
MOV NUM_DX,DX
MOV NUM_CX,CX
MOV NUM_BX,BX
MOV NUM_AX,AX
MOV RES_BX,DI
MOV RES_AX,SI
XOR AX,AX
MOV VAL_DX,AX
MOV VAL_CX,AX
MOV VAL_BX,AX
MOV VAL_AX,AX
MOV RES_DX,AX
MOV RES_CX,AX
XOR CX,CX
DIVDD_FORJ1:CMP CX,64
JAE DIVDD_FINISHJ1
CLC
RCL NUM_AX,1
RCL NUM_BX,1
RCL NUM_CX,1
RCL NUM_DX,1
RCL RES_CX,1
RCL RES_DX,1
PUSHF
POP BX
MOV AX,RES_CX
MOV DX,RES_DX
SUB AX,RES_AX
SBB DX,RES_BX
PUSHF
TEST BL,01H
JNZ DIVDD_A1
POPF
JNC DIVDD_A2
JMP DIVDD_B1
DIVDD_A1:POPF
DIVDD_A2:MOV RES_CX,AX
MOV RES_DX,DX
STC
RCL VAL_AX,1
RCL VAL_BX,1
RCL VAL_CX,1
RCL VAL_DX,1
JMP DIVDD_NEXTJ1
DIVDD_B1:CLC
RCL VAL_AX,1
RCL VAL_BX,1
RCL VAL_CX,1
RCL VAL_DX,1
DIVDD_NEXTJ1:INC CX
JMP DIVDD_FORJ1
DIVDD_FINISHJ1:MOV DX,VAL_DX
MOV CX,VAL_CX
MOV BX,VAL_BX
MOV AX,VAL_AX
MOV DI,RES_DX
MOV SI,RES_CX
RET
DIVDD ENDP
ABSOLU PROC
PUSH BX
mov bx,dx
and bx,8000h
cmp bx,0
jz absolu_ok
not dx
not ax
add ax,1
adc dx,0
absolu_ok:POP BX
RET
ABSOLU ENDP
DTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
CMP DX,0
JNZ DTOASC1
CMP AX,0
JNZ DTOASC1
MOV AL,'0'
CALL PUTCH
JMP DTOASC_OK
DTOASC1:mov di,0
divide_asc:mov cx,dx
jcxz finish_s_asc
divide_s_asc:mov cx,0AH
call divdw
inc di
push cx
jmp divide_asc
finish_s_asc:mov cx,ax
jcxz finish_asc
jmp divide_s_asc
finish_asc:mov cx,di
jcxz DTOASC_OK
string_asc:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string_asc
DTOASC_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOASC ENDP
DDTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CMP DX,0
JNZ DDTOASC1
CMP CX,0
JNZ DDTOASC1
CMP BX,0
JNZ DDTOASC1
CMP AX,0
JNZ DDTOASC1
MOV AL,'0'
CALL PUTCH
JMP DDTOASC_OK
DDTOASC1:mov bp,0
divide_ddtoasc:cmp dx,0
jz finish_s_ddtoasc1
divide_s_ddtoasc:mov di,0
mov si,10
call divdd
inc bp
push si
jmp divide_ddtoasc
finish_s_ddtoasc1:cmp cx,0
jz finish_s_ddtoasc2
jmp divide_s_ddtoasc
finish_s_ddtoasc2:cmp bx,0
jz finish_s_ddtoasc3
jmp divide_s_ddtoasc
finish_s_ddtoasc3:cmp ax,0
jz finish_ddtoasc
jmp divide_s_ddtoasc
finish_ddtoasc:mov cx,bp
jcxz DDTOASC_OK
string_ddtoasc:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string_ddtoasc
DDTOASC_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DDTOASC ENDP
CONVERT PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DX,OFFSET MESS_DECSTR1
CALL DISPMESS
MOV DI,OFFSET GET_BUF
CALL GETSTRD
MOV SI,OFFSET GET_BUF
ADD SI,2
MOV CX,WORD PTR GET_BUF
SUB CX,2
CALL DTOBIN
MOV DX,VAL_DX
MOV AX,VAL_AX
MOV NUM1_D,DX
MOV NUM1_A,AX
MOV DX,OFFSET MESS_DECSTR2
CALL DISPMESS
MOV DI,OFFSET GET_BUF
CALL GETSTRD
MOV SI,OFFSET GET_BUF
ADD SI,2
MOV CX,WORD PTR GET_BUF
SUB CX,2
CALL DTOBIN
MOV DX,VAL_DX
MOV AX,VAL_AX
MOV NUM2_D,DX
MOV NUM2_A,AX
MOV DX,OFFSET MESS_FORMAT
CALL DISPMESS
MOV DI,OFFSET GET_BUF
CALL GETSTRF
MOV SI,OFFSET GET_BUF
ADD SI,2
MOV AL,DS:[SI]
CMP AL,'0'
JZ CONVERT_ADD
CMP AL,'1'
JZ CONVERT_SUB
CMP AL,'2'
JZ CONVERT_MUL
CMP AL,'3'
JZ CONVERT_DIV
JMP CONVERT_OK
CONVERT_ADD:MOV AX,NUM1_A
MOV DX,NUM1_D
ADD AX,NUM2_A
ADC DX,NUM2_D
CALL DTOASC
CALL NEWLINE
JMP CONVERT_OK
CONVERT_SUB:MOV AX,NUM1_A
MOV DX,NUM1_D
SUB AX,NUM2_A
SBB DX,NUM2_D
JNC CONVERT_SUB1
PUSH AX
MOV AL,'-'
CALL PUTCH
POP AX
CALL ABSOLU
CONVERT_SUB1:CALL DTOASC
CALL NEWLINE
JMP CONVERT_OK
CONVERT_MUL:MOV AX,NUM1_D
MOV BX,NUM1_A
MOV CX,NUM2_D
MOV DX,NUM2_A
CALL MULDW
CALL DDTOASC
CALL NEWLINE
JMP CONVERT_OK
CONVERT_DIV:MOV DX,0
MOV CX,0
MOV BX,NUM1_D
MOV AX,NUM1_A
MOV DI,NUM2_D
MOV SI,NUM2_A
CALL DIVDD
CALL DDTOASC
CALL NEWLINE
MOV DX,DI
MOV AX,SI
CALL DTOASC
CALL NEWLINE
CONVERT_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
CONVERT ENDP
CSEG ENDS
END START
第14章定义与处理表格
14.1引言
14.2定义表格
14.3表格项目的直接寻址
14.4查找表格
14.5XLAT（换码）指令
14.6表格项目排序
14.7地址表
14.8二维数组
14.9要点
14.10习题
目的：说明对定义表格的要求，实现对表格的查找，以及表格项目的排序。
14.1引言
许多程序都需要应用一些表格或数组，它们包含这样一些数据，如名字、货名、量和速率等。
本章从定义某些常用的表格开始，然后再涉及全程查找它们的方法。
有关查找表格的技术易受定义表格所用方法的制约，并且许多定义与查找表格的方法可能并不是这里所给出那些方法。
表格的定义和使用，基本上和已经学过的应用有关。其他通用特性是排序的使用。
排序是重新排列表格中的数据顺序，以及地址表与展开表的使用。
在本章中，介绍的唯一指令是XLAT（换码）。
14.2定义表格
为了便于对表格进行全程查找，大多数表格都按一致的样式，它的每个项目是按同样的格式（字或数字），
同样的长度定义，并且按升序或降序来排列。
在本书中，常用的表格是堆栈的定义，它是一个64个未初始化字的表格，其中名字STACK指向该表的第一个字，
如STACK DW 64 DUP (?)。
下面两个表格 MONTH_TBL和CUST_TBL分别初始化字符和数字值。
MONTH_TBL定义月份的字母缩写，而CUST_TBL则是定义一个用户编号表：
MONTH_TBL DB 'Jan','Feb','Mar',...,'Dec'
CUST_TBL DB 205,208,209,212,215,224,...
MONTH_TBL表中的所有项目都是3个字符。但是，尽管CUST_TBL的所有项目是按3个数字定义的，
汇编程序还是把十进制数转换成二进制格式，而且其值不能超过255，因为它们是按每个数一个字节存放的。
表格还可以包含数字与字符的混合形式，这只要与它们的定义相符合就行。
在以下的库存品项目的表格中，每个数字项目（库存品号）是2个数位（一个字节），
而每个字符项目（库存品名称）是9个字节：
STOCK_TBL DB 12,'Computer '
                    DB 14,'Paper    '
                    DB 17,'Diskettes'
...
紧跟着名称“Paper”后的4个点表示的是将有空格存在；也就是说，它们不是点，而是紧跟名称的空格。
为清楚起见，可以把每个表格项目对，写在单独的一行上：
STOCK_TBL DB 12,'Computer '
                    DB 14,'Paper    '
                    DB 17,'Diskettes'
...
下个例子定义有100个项目的表格，每个项目被初始化为15个空白（总共是1500个字节）：
STOCK_TBL DB 100 DUP (15 DUP (20H))
程序可以使用这个表格去存放多达100个值，这些值是内部产生的，或者使用这个表格去存放多达100个项目的内容，
它们是从键盘接受的或是从磁盘文件读出的。
在实际情况下，许多程序是表格驱动的。也就是说，表格是作为磁盘文件存放的，任意多的程序可以要求去处理它。
为此目的，程序可以从磁盘把一个表格文件读入到按用途定义的一个“空”表格中。
有关这一做法的原因在于，表格内容随时都可能改变。如果每个程序都定义它自己的表格，
那么任何改变都要求重新定义表格并重新汇编该程序。
由于表格文件在磁盘上，所以对于表格的改变可以简单地只牵涉到改变文件的内容。第17章给出一个表格文件的例子。
类型（TYPE）、长度（LENGTH）与规模（SIZE）操作符
汇编程序提供许多专门的操作符，你会发现它们是很有用的。
操作符TYPE返回变量或标号的类型，类型用数值表示，常见类型和对应的数值
规定如下：
字节（BYTE）变量              1
字（WORD）变量              2
双字（DWORD）变量        4
近（NEAR）标号               -1
远（FAR）标号                  -2
由上述表示关系可见，变量的类型值是对应类型的变量项所占用的字节数，而标号的类型值却没有实际的物理意义。
操作符LENGTH返回利用DUP定义的数组中元素的个数，即重复操作符DUP前的count值。
如果变量定义语句中没有使用DUP，则总返回1。如果嵌套使用了DUP，则只返回最外层的重复数。
操作符SIZE返回用DUP定义的数组占用的字节数，可按下式计算：
SIZE 变量=（LENGTH变量）*（TYPE变量）例如：
例如，表格长度随时可能改变，而可能不得不修改程序去说明新的定义，并要加上例行程序去检查表格的结束。
使用TYPE、LENGTH和SIZE操作符，可能有助于减少那些必须改变的指令数。
考虑这个有12字表格的定义：
RAIN_TBL DW 12 DUP (?)   ;有12个字的表格
程序可以使用TYPE操作符去确定定义（在这种情况下是DW），LENGTH操作符去确定DUP因子（12），而用SIZE操作符确定字节数（12×2=24）。
以下例子说明这3个操作符：
MOV AX,TYPE RA1N_TBL   ;AX=0002H
MOV BX,LENGTH RAIN_TBL   ;BX=000CH
MOV CX,SIZE RAIN_TBL ;CX=0018H
可以用LENGTH和SIZE的值返回去结束一个表格的查找或排序。
例如，如果SI寄存器包含查找的增量偏移地址，那就可以使用
CMP SI,SIZE RATN_TBL
测试这个偏移值。
第25章会详细讨论TYPE，LENGTH和SIZE操作符，现在让我们来研究一下在程序中使用表格的不同方法。
14.3表格项目的直接寻址
假设用户输入一个数字月份（比如03），而程序把它转换成字母格式――在这种情况下就是March（3月）。
例行程序实现这一转换要包括定义一个字母月份表，全部项是等长的。
每个项目的长度应该是最长的名字September（9月）的长度，格式是：
MONTH_TBL DB 'January  '
                      DB 'February '
                      DB 'March    '
                      DB 'April    '
                      DB 'May      '
                      DB 'June     '
                      DB 'July     '
                      DB 'August   '
                      DB 'September'
                      DB 'October  '
                      DB 'November '
                      DB 'December '
项目'January  '在MONTH_TBL+0处，'February '在MONTH_TBL+9处，'March    '在MONTH_TBL+18处，
以此类推。假设用户键入3（对于March），程序要在表格中对它定位。
该程序必须按以下步骤执行：
1.把月份项目从ASCII 33转换成二进制3。
2.从这个数中减去1：3-1=2（由于月份1在MONTH_TBL+0处）。
3.这个新的数乘以9（每个项目的长度）：2×9=18。
4.把这个乘积（18）加到MONTH_TBL的地址上，该结果就是所要求项目的地址：
MONTH_TBL+18，'March    '从这里开始。
这一技术称为直接表格寻址。由于算法直接计算所要求的表格地址，所以不必要在表格中定义数字的月份，
并且程序也不必要连续地全程查找该表格。
14.3.1直接寻址，例1：月份表
在图14-1中的部分程序提供一个按月份名直接访问表格的例子。该程序假定12（December）
作为输入，并把月份从ASCII转换成二进制格式（按照已在第13章讨论过的转换方法）：
LEN_ENTRY EQU 9
MONTH_IN DB '12'
MONTH_TBL DB 'January  '
                      DB 'February '
                      DB 'March    '
                      DB 'April    '
                      DB 'May      '
                      DB 'June     '
                      DB 'July     '
                      DB 'August   '
                      DB 'September'
                      DB 'October  '
                      DB 'November '
                      DB 'December '
...
XOR WORD PTR MONTH_IN,3030H
MOV AL,MONTH_IN
MOV AH,10
MUL AH
ADD AL,MONTH_IN+1
DEC AL
MOV AH,LEN_ENTRY
MUL AH
LEA BP,MONTH_TBL
ADD BP,AX

MOV AX,1301H
MOV BX,0016H
MOV CX,LEN_ENTRY
MOV DX,0812H
INT 10H
...
初始输入月份（'12'）=3132H
XOR 3030H = 0102H
月份左边字节乘以10=0AH
加上月份右边的字节=0CH（十进制的12）
该程序确定在表格中的月份的实际位置：
从在AX中的月份里减1=000BH（十进制11）
乘以9（项目的长度）=0063H（十进制99）
加上表格的地址=MONTH_TBL+63H
改进这一程序的一种方法是从键盘接受数字月份，并核实那个值是包括在01和12之间的。
MOV AH,2AH
INT 21H
CX    year (1980 to 2099)
DH    month (1 to 12)
DL    day (1 to 31)
AL    day of the week (0=Sun, 1=Mon,...6=Sat)
MOV AH,2CH
CH    hour (0 to 23)
CL    minutes (0 to 59)
DH    seconds (0 to 59)
DL    hundredths of a second (0 to 99) 百分之一秒
当前日期的获取是调用21H号中断处理程序的2AH号功能完成的
当前时间的获取是调用21H号中断处理程序的2CH号功能完成的。
14.3.2直接寻址，例2：月份的日期表
在图14-2中的部分程序从系统中取回今天的日期并加以显示。INT 21H功能2AH提供以下二进制值：
AL=星期（其中星期日=0）DH=月（01-12）
CX=年（本程序未用）        DL=日（01-31）
该程序用这些返回值以"Wednesday"，"September"，以及"12"的形式去显示字母表示的星期几和月份。
为此，程序定义一个名为DAYS_TBL的从Sunday开始的星期的表格，以及名为MONTH_TBL的从January开始的月份的表格。
在DAYS_TBL和MONTH_TBL中的项目是9个字节长，每个说明的右边用空白填入。
该程序把星期乘以9（在DAYS_TBL中每个项目的长度）。乘积是表中的一个偏移值，
例如Sunday是在DAYS_TBL+0处，Monday是在DAYS_TBL+9处，以此类推。日期是直接从表格显示的。
该程序使月份减1，例如，使月份01变成MONTH_TBL中的项0。
然后它再把月份乘以9（在MONTH_TBL中每个项目的长度），程序直接从表格显示月份。
该程序将月中的日除以10，把它从二进制转换成ASCII格式。由于日的最大值是31，所以商与余数可能各自仅为一个数位
（例如，31被10除得到一个3的商和一个余数1）。
程序显示2个字符中的每一个，包括小于10的日期的前导0（删除前导0，会使程序有少量的改变）。
尽管直接表格寻址是非常有效的，但它工作得最好的情况是当项目是按照顺序的，
并且是按可预测的次序排列的时候。因此对于按这样的次序：01，02，03，…，或106，107，108，…，
以至于05，10，15，…，它是能良好地工作的。但是，只有少数应用才能提供这么整齐排列的表格值。
下一节要研究的表格的值是按顺序的，但并不是按可预测的次序。
LEN_ENTRY EQU 9
DAYOFMON DW 0
SAVEDAY DB ?
SAVEMON DB ?
TEN DB 10
ROW DB 10
COLUMN DB 30
DAYS_TBL DB 'Sunday   '
                 DB 'Monday   '
                 DB 'Tuesday  '
                 DB 'Wednesday'
                 DB 'Thursday '
                 DB 'Friday   '
                 DB 'Saturday '
MONTH_TBL DB 'January  '
                      DB 'February '
                      DB 'March    '
                      DB 'April    '
                      DB 'May      '
                      DB 'June     '
                      DB 'July     '
                      DB 'August   '
                      DB 'September'
                      DB 'October  '
                      DB 'November '
                      DB 'December '
...
MOV AH,2AH
INT 21H
MOV BYTE PTR SAVEMON,DH
MOV BYTE PTR SAVEDAY,DL
MOV AH,LEN_ENTRY
MUL AH
LEA BP,DAYS_TBL
ADD BP,AX
MOV CX,LEN_ENTRY
CALL B10DISPLY

MOV AL,SAVEMON
DEC AL
MOV AH,LEN_ENTRY
MUL AH
LEA BP,MONTH_TBL
ADD BP,AX
MOV CX,LEN_ENTRY
CALL B10DISPLY

MOV AX,0
MOV AL,SAVEDAY
DIV BYTE PTR TEN
OR AX,3030H
MOV WORD PTR DAYOFMON,AX
LEA BP,DAYOFMON
MOV CX,2
CALL B10DISPLY
...
B10DISPLY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,1301H
MOV BX,0016H
MOV DH,ROW
MOV DL,COLUMN
INT 10H
INC BYTE PTR ROW
POP DX
POP CX
POP BX
POP AX
RET
B10DISPLY ENDP
14.4查找表格
某些表格是由没有明显模式的独特的编号组成的。典型的例子是库存品项的表格，它的编号是不按顺序的，
比如034，038，041，139，以及145。另一类表格，例如收入税表，包含值的范围。
以下几节研究这些类型的表格，以及对查找它们的要求。
14.4.1具有独特项目的表格
大多数商业库存品项的编号通常都是不按顺序的。更确切地说，它们往往根据类型分组，这些类型多半有前导数，
用以指明设备或用具，或者指明它是存放在某个部门的。还有，某些项会随时从库存品中删除并加进另一些项。
作为一个例子，让我们定义一个表格，它具有库存品号及其相关的说明。
这些可以按单独的表格加以定义，比如
STOCK_NO DB '05','10','12',...
STOCK_DESC DB 'Excavators','Lifters   ','Presses   ',...
查找中的每一步都使第一个表格的地址加2（在STOCK_NO中每个项目的长度），
而第二个表格的地址加10（在STOCK_DESC中每个项目的长度）。或者，过程可以保持所执行的循环次数的计数值，
在找到与某一个关键库存号相匹配时，把该计数值乘以10，再利用这个乘积作为STOCK_DESC的地址偏移值。
另一方面，把库存品号和说明定义在同一表格中可能比较清楚，每对项目有一行：
STOCK_TBL DB '05','Excavators'
                    DB '10','Lifters   '
                    DB '12','Presses   '
...
图14-3的部分程序用6对库存品号与说明定义这个表格。
查找例行程序开始把输入的库存品号STOCK_IN的第一个字节和在表格中库存品号的第一个字节进行比较。
比较结果可能是低，高或相等。
1.低于。如果第一或第二个字节的比较结果是低于，则程序确定该库存品号不在表格内，
并在A40处显示一个出错信息（未编码）。例如，程序把输入库存品项01和表格项05作比较：
第一个字节是相等的，但由于第二个字节是低于，所以程序确定该项不在表格中。
2.高于。如果第一个字节或第二个字节的比较结果是高于，则程序继续查找。
为了把输入库存品项和在表格中的下一个库存品项进行比较，程序要使SI中包含的表格地址增量。
例如，程序比较输入库品项06和表格项05，第一个字节是相等的，但第二个字节是高于，
所以它把输入的项和表格中的下一个项相比较：库存品项06和表格项10。
第一个字节是低于，所以程序确定该项目不在表格中。
3.等于。如果第一个字书和第二个字节是相等的，那么可以找到库存品号。
例如，程序比较输入库存品项10和表格项05。第一个字节是高于，所以它比较输入库存品项和表格中的下一项；
库存品项10和表格项10，由于第一个字节是相等的，并且第二个学省也是相等的，所以程序找到了该项目，
在A50处直接显示来自表格的说明。
循环查找6次比较的最大值。如果循环次数超过6，那么便能知道库存品号不在表格中。
表格还可以定义单价。用户键入库存品号和销量。程序可以将表格中的库存品项定位，
计算销售总额（销量乘以单价），并显示说明和销售总额。
在图14-3中，库存品号是2个字符，而说明是10个字符。程序设计的细节由于项目数与项目长度的不同会有所变化。
例如，为比较3字节的字段，可以使用REPE CMPSB，尽管REPE包括LOOP时已使用过的CX寄存器。
LEN_STKNO EQU 2
LEN_DESCR EQU 10
STOCKN_IN DB '12'
STOCK_TBL DB '05','Excavators'
                    DB '10','Lifters   '
                    DB '12','Presses   '
                    DB '15','Valves    '
                    DB '12','Processors'
                    DB '12','Pumps     '
MOV CX,6
LEA SI,STOCK_TBL
A20:MOV AL,STOCKN_IN
CMP AL,DS:[SI]
JNE A30
MOV AL,STOCKN_IN+1
CMP AL,[SI+1]
JE A50
A30:JB A40
ADD SI,LEN_STKNO
ADD SI,LEN_DESCR
LOOP A20
A40:
...
;显示不在表格中对应的出错信息
JMP A90
A50:INC SI
INC SI
MOV BP,SI
MOV AX,1301H
MOV BX,0061H
MOV CX,LEN_DESCR
MOV DX,0812H
INT 10H
A90:
...
14.4.2带范围的表格
所得税提供-一个带范围值的表格的典型例子。考虑以下应纳税收入，税率和调节系数的假想表格：
应纳税收入                  税率                  调节系数
0-1000.00                   0.10                  000.00
1000.01-2500.00        0.15                  050.00
2500.01-4250.00        0.18                  125.00
4250.01-6000.00        0.20                  260.00
6000.01及更高            0.23                  390.00
在这个税表中，税率随应纳税收入的增加而增加。调节系数对于我们计算的高税率的税进行补偿，而低税率则适用于较低收入水平。
应纳税收入的项目包括每一等级的最高收入：
TVATBL DD 100000,10,00000
              DD 250000,15,05000
              DD 425000,18,12500
              DD 600000,20,26000
              DD 999999,23,39000
为实现该表格的查找，程序要把纳税人的实际应纳税收入和从表格第一项开始的值进行比较，并根据比较的结果做以下事情：
高于：还没有找到，为表格中的下一项增量。
低于或等于：找到了，使用相应的税率和调节系数。
按（应纳税收入×表中的税率），即调节系数来计算扣除的税额。
注意，表格中最后一项是最大值（999999），在这总能正确地强制结束查找。
14.4.3使用串比较查找表格
REPE CMPS对于项目编号有2个或更多字符长的比较是有用的。
图14-4的部分程序定义了STOCK_TBL，但这次库存品号被修改成了3字节。
在表格中的最后一项是库存品项'999'（最大可能的库存品号），它强制结束查找。
该程序使用了循环强制结束查找，但REPE使CX不能用于LOOP。
查找例行程序把STOCKN_IN（任意定义为123）和每个表格项目进行比较，如下所示：
'123'>'035' 
'123'>'038'
'123'>'049'
'123'>'102'
'123'='123'

LEN_STKNO EQU 3
LEN_DESCR EQU 10
STOCKN_IN DB '123'
STOCK_TBL DB '035','Excavators'
                    DB '038','Lifters   '
                    DB '049','Presses   '
                    DB '102','Valves    '
                    DB '123','Processors'
                    DB '127','Pumps     '
                    DB '999',10 DUP (20H)
CLD
LEA DI,STOCK_TBL
A20:MOV CX,LEN_STKNO
LEA SI,STOCKN_IN
REPE CMPSB
JE A30
JB A40
ADD DI,CX
ADD DI,LEN_DESCR
JMP A20
A30:MOV BP,DI
MOV AX,1301H
MOV BX,0061H
MOV CX,LEN_DESCR
MOV DX,0812H
INT 10H
JMP A90
A40:
...
;显示不在表格中对应的出错信息
JMP A90
A90:
...
程序首先初始化DI为STOCK_TBL的偏移地址（003），CX初始化为每个库存品项的长度（03），
SI初始化为STOCKN_IN的偏移地址（000）。只要被比较的字节包含相等的值，
CMPSB操作就进行字节与字节的比较，并且DI与SI为下一对字节而自动增量。
第一个表格项目的比较（123：035）是在第一个字节后用高于的比较结束的，DI是004，SI是001，
而CX是02。
对于第二个表格项目的比较，DI应当是010H，而SI应当是000H，
对SI的校正是简单地重新装入STOCKN_IN的地址。然而，为了校正在DI中的表格项目的地址，
增量取决于比较是结束于1个、2个还是3个字节之后。CX包含剩下的末比较的字节数，在这种情况下是02。
加CX的值，再加上库存品说明的长度（以前被比较的库存品项目的说明）给出下个表格项目的偏移值，
如下所示：
004H+02H=006H
006H+00AH=010H
由于CX包含剩下的未比较的字节数（如果有的话），所以对于所有情况来说，运算还在进行，
直到1次、2次或3次比较之后结束。在相等比较时，CX是00，而DI已经增加到了所要求说明的地址。
程序直接显示来自表格的说明。
14.4.4具有可变长度项目的表格
定义一个具有可变长度项目的表格是可能的。专门的定界符字符（如00H）可以跟在每个表格项目的后面，
而FFH可以标记表格的结束。SCAS指令适用于定界符的扫描。但必须保证在项目内没有包含定界符的位配置，
例如，一个算术的二进制总数计算可能包含任何可能的位配置，包括00H和FFH。
14.5XLAT(换码)指令
XLAT指令把一个字节的位配置转换成另一个预先定义的配置。
例如，使用XLAT验证数据项的内容或者加密数据。XLAT的格式是
[label:] XLAT   ;没有操作数
为了使用XLAT，需要定义一个换码表，它由全部256种可能的字符构成。
XLAT要求表格的地址在BX中，而被转换的字节是在AL中。
下面的例子是把ASCII数0-9转换成EBCDIC格式，它适用于IBM大型计算机。
由于ASCII格式表示的0-9是30-39，而用EBCDIC表示是F0-F9，可以使用OR操作进行这种转换。
但是，可以任意地把ASCII负的符号'-'（2D）和十进制小数点'.'（2E）转换为EBCDIC（分别是60和4B），
并且所有其他字符都是空格（在EBCDIC格式里它是40H）。
在换码表中，EBCDIC码是按ASCII位置定义的，即EBCDIC字符是在ASCII单元里，
而EBCDIC负的符号、十进制小数点和空格是在另一些单元里。由于数0是ASCII30H，
所以EBCDIC数是从表格的30H或十进制48单元开始的：
XLAT_TBL DB 45 DUP (40H)
DB 60,4BH
DB 40H
DB 0F0H,0F1H,0F2H,0F3H,0F4H
DB 0F5H,0F6H,0F7H,0F8H,0F9H
DB 198 DUP (40H)
注意：在XLAT_TBL中的第一个DB定义45个字节，它的地址是XLAT_TBL+00到XLAT_TBL+44。
第二个DB定义的数据从XLAT_TBL+45开始，以此类推。
XLAT使用AL的值作为偏移地址，实际上，BX包含的是表格的起始地址，而AL包含的是表格内的偏移值。
例如，如果AL值是00，那么表格地址将是XLAT_TBL+0（XLAT_TBL的第一个字节是40H）。
XLAT会用来自表格的40H取代AL中的00。如果AL值是32H（十进制50），那么表格地址是XLAT_TBL+50，
这一单元包含F2（EBCDIC的2），会被XLAT插入到AL中。
下面的程序片断是经过6字节ASCII字段ASC_NO的循环，用XLAT_TBL把这个字段转换成EBCDIC格式。
最初，ASC_NO的内容是-31.5 跟着一个空格或是十六进制的2D 33 31 2E 35 20。
在循环结束时，EBC_NO的内容是十六进制的60 F3 F1 4B F5 40，可以借助于DEBUG加以验证。
ASC_NO DB '-31.5 '
EBC_NO DB 6 DUP (20H)
LEA SI,ASC_NO
LEA DI,EBC_NO
MOV CX,6
LEA BX,XLAT_TBL
CLD
L10:LODSB
XLAT
STOSB
LOOP L10
程序：显示十六进制与ASCII字符
在图14-5中的部分程序显示全部256个十六进制值（00-FF），包括大多数与它们相关的ASCII符号，
例如ASCII符号S及其十六进制表示：53。完整的显示是以16乘16矩阵形式出现在屏幕上的：
00 01......0F
......
F0 F1......FF
如图8-1所示，显示ASCII字符不会产生严重问题。但是，显示ASCII值的十六进制表示就要复杂一些。
例如，必须把00H转换成3030H，01H转换成3031H，以此类推。这就是说，01H要作为2个字符'01'来显示。
ROW DB 02H
DISPROW DB 16 DUP (5 DUP (20H))
HEXCTR DB 00H
XLATAB DB 30H,31H,32H,33H,34H,35H,36H,37H,38H,39H
              DB 41H,42H,43H,44H,45H,46H
...
CALL Q10CLEAR
LEA SI,DISPROW
A20:CALL B10HEX
CALL C10DISPLY
CMP BYTE PTR HEXCTR,0FFH
JE A90
INC BYTE PTR HEXCTR
JMP A20
...
A90:
...
B10HEX PROC NEAR
MOV AX,0
MOV AL,HEXCTR
SHR AX,4
LEA BX,XLATAB
XLAT
MOV DS:[SI],AL
MOV AL,HEXCTR
AND AL,0FH
XLAT
MOV DS:[SI+1],AL
RET
B10HEX ENDP
C10DISPLY PROC NEAR
MOV AL,HEXCTR
MOV DS:[SI+3],AL
CMP AL,07H
JB C20
CMP AL,10H
JAE C20
MOV BYTE PTR DS:[SI+3],20H
C20:ADD SI,5
LEA DI,DISPROW+80
CMP DI,SI
JNE C90
MOV AX,1300H
MOV BX,0031H
LEA BP,DISPROW
MOV CX,80
MOV DH,ROW
MOV DL,0
INT 10H
INC BYTE PTR ROW
LEA SI,DISPROW
C90:RET
C10DISPLY ENDP
Q10CLEAR PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,0600H
MOV BH,07H
MOV CX,0000H
MOV DX,184FH
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
Q10CLEAR ENDP
测试通过的完整程序如下
.MODEL SMALL
.STACK 512
.DATA
ROW DB 02H
DISPROW DB 16 DUP (5 DUP (20H))
HEXCTR DB 00H
XLATAB DB 30H,31H,32H,33H,34H,35H,36H,37H,38H,39H
              DB 41H,42H,43H,44H,45H,46H
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
CALL Q10CLEAR
LEA SI,DISPROW
A20:CALL B10HEX
CALL C10DISPLY
CMP BYTE PTR HEXCTR,0FFH
JE A90
INC BYTE PTR HEXCTR
JMP A20
A90:MOV AH,10H
INT 16H
MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10HEX PROC NEAR
MOV AX,0
MOV AL,HEXCTR
SHR AX,1
SHR AX,1
SHR AX,1
SHR AX,1
LEA BX,XLATAB
XLAT
MOV DS:[SI],AL
MOV AL,HEXCTR
AND AL,0FH
XLAT
MOV DS:[SI+1],AL
RET
B10HEX ENDP
C10DISPLY PROC NEAR
MOV AL,HEXCTR
MOV DS:[SI+3],AL
CMP AL,07H
JB C20
CMP AL,10H
JAE C20
MOV BYTE PTR DS:[SI+3],20H
C20:ADD SI,5
LEA DI,DISPROW+80
CMP DI,SI
JNE C90
MOV AX,1300H
MOV BX,0031H
LEA BP,DISPROW
MOV CX,80
MOV DH,ROW
MOV DL,0
INT 10H
INC BYTE PTR ROW
LEA SI,DISPROW
C90:RET
C10DISPLY ENDP
Q10CLEAR PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,0600H
MOV BH,07H
MOV CX,0000H
MOV DX,184FH
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
Q10CLEAR ENDP
END A10MAIN
程序最初用00H定义HEXCTR，并使256个ASCII字符的每一个依次加1。
过程B10HEX把HEXCTR分割为它的2个十六进制数位。
例如，HEXCTR的内容是4FH，例行程序将抽取一个十六进制的4，由XLAT用于转换。返回到AL的值是34H。
然后例行程序再抽取F并把它转换为46H。结果34 46H在屏幕上显示成4F。
过程C10DISPLY把非ASCII字符转换成空格。由于INT 10H功能13H能对退格（Backspace）和其他控制字符起作用，
所以程序把它们改成空格。过程显示一个16字符的整行，并在显示第16行之后结束。
有许多方法把十六进制数字转换为ASCII字符，例如，可以用移位与比较。
14.6表格项目排序
有的应用场合需要把表格中的数据按照升序或降序的顺序进行排序。
例如，用户可能想要一个按升序序列的库存品说明表，或另一个按降序序列的销售代理商总销售额表。
有许多表格排序例行程序，它们各不相同，有的处理速度相对较慢，但程序清晰；有的处理速度快，但难于理解。
在这一节中所提供的例行程序效率是相当高的，并且适用于大多数表格的排序。
对表格进行排序的一般方法是把表格的项目与紧跟其后的项目进行比较。如果比较结果是高于，则交换该项目。
继续利用这种方法，项目1与项目2相比较，项目2与项目3相比较，以此类推，直到表格的末端，其中进行交换是必须做的。
要是进行了任意次交换，还要从表格的起点重复完整的处理，再一次进行项目1与项目2的比较，以此类推。
在任何时候，假如进行了整个表格的处理而没有做过一次交换，那么就知道表格已经完成了排序。
在以下的伪代码中，SWAP是一个项，它指明是进行了交换（YES）还是没有进行交换（NO）。
L10：初始化表格中最后一个项目的地址
L20：将SWAP设置成NO
初始化表格起点的地址
L30：表格项目>下一个项目吗？
是：交换项目
设置SWAP为YES
为表格中的下一项目增量
是在表格的末尾吗？
否：转移到L30
是：SWAP=YES吗？
是：转移到L20（重复排序）
否：结束排序
图14-6中的程序允许用户键入来自键盘的多达30个的人名，程序把它们存入名为NAMETABLE的表格中。它包括了以下过程：
A10MAIN调用B10ENTER接收来自键盘的人名，调用C10STORE把人名存入表格中，并且当键入所有人名时，
调用D10SORT和F10NAMES。
B10ENTER提示用户键入一个人名，接收它，并用空格填充它的右边。当键入所有人名时，用户只要按回车键，不带人名。
C10STORE将每个人名逐次地存入表格中。
D10SORT和E10XCHNG将人名的表格按升序序列排序。
F10NAMES显示已排序了的表格。
注意，表格项目全部是20个字节的固定长度，对可变长度数据进行排序的例行程序会更为复杂。
.MODEL SMALL
.STACK 512
.DATA
LEN_NAME EQU 20
ENDADDR DW ?
MESSG1 DB 'Name: '
NAMECTR DB 0
NAMESAVE DB 20 DUP (?)
NAME_TBL DB 30 DUP (20 DUP (20H))
ROW DB 0
SWAPPED DB 0
NAMEPAR LABEL BYTE
MAXNLEN DB 21
NAMELEN DB ?
NAMEFLD DB 32 DUP (20H)
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
CLD
CALL Q10CLEAR
LEA DI,NAME_TBL
A20:CALL B10ENTER
CMP BYTE PTR NAMELEN,0
JE A30
CMP BYTE PTR NAMECTR,30
JE A30
CALL C10STORE
JMP A20
A30:CALL Q10CLEAR
CMP BYTE PTR NAMECTR,1
JB A90
JE A80
CALL D10SORT
CALL F10NAMES
JMP A90
A80:CALL F10NAMES
JMP A90
A90:MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10ENTER PROC NEAR
LEA BP,MESSG1
MOV CX,6
CALL G10DISPLY
INC BYTE PTR ROW
MOV AH,0AH
LEA DX,NAMEPAR
INT 21H
MOV BX,0
MOV BL,NAMELEN
MOV CX,0
MOV CL,MAXNLEN
SUB CX,BX
B20:MOV BYTE PTR NAMEFLD[BX],20H
INC BX
LOOP B20
RET
B10ENTER ENDP
C10STORE PROC NEAR
INC BYTE PTR NAMECTR
CLD
LEA SI,NAMEFLD
MOV CX,LEN_NAME
REP MOVSB
RET
C10STORE ENDP
D10SORT PROC NEAR
SUB DI,40
MOV WORD PTR ENDADDR,DI
D20:MOV BYTE PTR SWAPPED,0
LEA SI,NAME_TBL
D30:MOV CX,LEN_NAME
MOV DI,SI
ADD DI,LEN_NAME
MOV AX,DI
MOV BX,SI
CLD
REPE CMPSB
JBE D40
CALL E10XCHNG
D40:MOV SI,AX
CMP SI,WORD PTR ENDADDR
JBE D30
CMP BYTE PTR SWAPPED,0
JNZ D20
RET
D10SORT ENDP
E10XCHNG PROC NEAR
MOV CX,LEN_NAME
LEA DI,NAMESAVE
MOV SI,BX
CLD
REP MOVSB
MOV CX,LEN_NAME
MOV DI,BX
REP MOVSB
MOV CX,LEN_NAME
LEA SI,NAMESAVE
REP MOVSB
MOV BYTE PTR SWAPPED,1
RET
E10XCHNG ENDP
F10NAMES PROC NEAR
MOV BYTE PTR ROW,0
LEA BP,NAME_TBL
F20:MOV CX,LEN_NAME
CALL G10DISPLY
INC BYTE PTR ROW
ADD BP,LEN_NAME
DEC BYTE PTR NAMECTR
JNZ F20
RET
F10NAMES ENDP
G10DISPLY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,1301H
MOV BX,0016H
MOV DH,ROW
MOV DL,10
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
G10DISPLY ENDP
Q10CLEAR PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,0600H
MOV BH,61H
MOV CX,0000H
MOV DX,184FH
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
Q10CLEAR ENDP
END A10MAIN
14.7地址表
程序可能必须测试许多相关的条件，每个条件要求转移到另一个例行程序。
例如，考虑下面测试代码1，2，3，4等等的程序片断，假设代码是在名为CODE的数据项中。
处理代码的一般方法是相继地比较每个代码：
CODE DB ?
...
CMP BYTE PTR CODE,1
JE CODE1_RTNE
CMP BYTE PTR CODE,2
JE CODE2_RTNE
CMP BYTE PTR CODE,3
JE CODE3_RTNE
采用这种方法，出错的可能性很大，因为需要与正确的代码去匹配，并转移到正确的例行程序。
较为巧妙的解决方案需要一个如下所示的地址表：
ADDRTBL DW CODE1_RTNE
                 DW CODE2_RTNE
                 DW CODE3_RTNE
                 DW CODE4_RTNE
                 DW CODE5_RTNE
...
MOV BX,0
MOV BL,CODE
DEC BX
SHL BX,1
JMP WORD PTR DS:[ADDRTBL+BX]   ;用地址表转移
这个例子把代码传送到BX并把BX减1。然后该值加倍，使得0还是0，1变成2，2变成4，以此类推。
这个加倍的值提供的是表格内的偏移值：ADDRTBL+0是第一个地址（对于代码1），
ADDRTBL+2是第二个地址（对于代码2），ADDRTBL+4是第三个地址，以此类推。
JMP指令的操作数[ADDRTBL+BX]形成一个基于表格起始地址加上表格内偏移值的间接地址。
然后，操作直接转移到相应的例行程序。
这个例子还可以在JMP的位置使用CALL指令，其中表格地址是过程名：
CALL WORD PTR [ADDRTBL+BX]
在这个例子中的一个重要约束是，代码只可以是十六进制值1到最大，任何其他值都可能导致灾难性的后果，
因此程序应当检查这种可能性。
14.8二维数组
二维数组由y行与x列组成，如下面例子所示的3行5列：
                  0         1         2         3         4         列
         0
行      1
         2
该数组格式是[row,column]，并包含3×5=15个单元或元素。
在存储器中，每一行数据可以看成是一维数组，即每行依次跟着另一行。但是，把数组看成是二维的是有帮助的，
它可以定义成以下这样：
DATA_ARRAY DW 3 DUP (5 DUP (?))
访问在该数组中的一个元素，比如[2，3（即2行3列），包括下面一些步骤：
1.行乘以列中的元素数：2×5=10。
2.加上列：10+3=13
在这种情况下，所需要的元素是第13个（其中行与列都从0开始）。
注意，在表中的元素是字，但寻址是基于字节的，所以对于行与列的值分别加倍为20与6是必要的。
第13个元素是在第26个字节并可以用基址：变址寻址进行访问，就像下面这样：
MOV BX,20
MOV DI,6
ADD WORD PTR DATA_ARRAY[BX+DI],AX
但是，编一个程序时，难得知道确切的元素地址，因为行与列的值通常是计算得来的结果。
某些时候，把数组看成一维的是比较简单的，如下面例子中要把DATA_ARRAY的每个元素都置成0：
MOV CX,15   ;元素数
MOV BX,0   ;第一个元素的偏移值
L10:MOV WORD PTR DATA_ARRAY[BX],0   ;清除一个元素
ADD BX,2   ;数组中的下一个字
LOOP L10   ;重复15次
展开表运算
这一节涉及的是实现展开表（Spreadsheet）运算的技术。在简单的术语中，展开表是由水平与垂直单元组成的二维数组。
行的单元总数在右边（最后一列），列的单元总数横穿过底边（最后一行）。
图14-7的程序定义一个展开表，并实现单元的水平相加与垂直相加。为了便于说明，该表格有意小一些并包含预先定义的值。
表格包含5行的字，每行有6列，第5行与第6列是总单元数。
程序完成行的水平相加，首先把一行中的每个单元从左到右相加，加到行的总数中。进到下一行并重复水平相加，
直到所有行都相加完为止。垂直相加遵循同样的方法，可以通过对指令及其注释的分析，更好地理解这种方法。
水平相加可以把每行作为一维来处理，而垂直相加可以把每一列作为一维来处理。
.MODEL SMALL
.STACK 512
.DATA
SPRD_TBL DW 05,03,06,04,10,00
                 DW 04,05,01,09,06,00
                 DW 06,02,00,10,11,00
                 DW 10,07,03,05,02,00
                 DW 00,00,00,00,00,00
COUNT DB ?
COLS EQU 12
ROWS EQU 10
NOCOLS EQU 6
NOROWS EQU 5
COLTOT EQU (NOCOLS * (NOROWS -1)) * 2
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
CALL B10HORZL
CALL C10VERTL
MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10HORZL PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV BYTE PTR COUNT,NOROWS-1
LEA DI,SPRD_TBL
LEA SI,SPRD_TBL
ADD SI,ROWS
B10:MOV CX,NOCOLS-1
B20:MOV AX,[DI]
ADD [SI],AX
ADD DI,2
LOOP B20
ADD DI,2
ADD SI,COLS
DEC BYTE PTR COUNT
JNZ B10
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
B10HORZL ENDP
C10VERTL PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV BYTE PTR COUNT,NOCOLS-1
MOV BX,0
LEA SI,[SPRD_TBL+COLTOT]
C10:LEA DI,SPRD_TBL
ADD DI,BX
MOV CX,NOROWS-1
C20:MOV AX,[DI]
ADD [SI],AX
ADD DI,COLS
LOOP C20
ADD BX,2
ADD SI,2
DEC BYTE PTR COUNT
JNZ C10
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
C10VERTL ENDP
END A10MAIN
14.9要点
对于大多数用途来说，表格所含的相关项目具有相同的长度和数据格式。
表格是建立在它的数据格式基础之上的，例如，项目可能是字符或数字，典型的是每个项目长度一样。
如果表格经常改变，或者几个程序引用该表格，那么表格可以放在磁盘上。
一个作修改的程序可以处理对表格的修改。因此，任何程序都可以从磁盘取表格，而程序并不需要改变。
在直接表格寻址条件下，程序计算表格项目的地址并直接访问该项目。
当查找一个表格时，程序要把一个数据项和表格中的每个项目相继地进行比较，直到发现符合（找到）为止。
SCASW和CMPSW认定字所包含的字节是按相反顺序排列的。
XLAT指令便于把数据从一种格式转换成另一种格式。
14.10习题
14-1.说明用直接寻址与用查找处理表格之间的区别。
直接表格寻址，算法直接计算所要求的表格地址，程序不必要连续地查找该表格。
某些表格是由没有明显模式的独特的不按顺序的编号组成的。查找程序需要连续地查找该表格。
14-2.定义一个名为ANNUAL_TBL有365个字的表格，初始化为（a）对字符数据是空格，（b）对二进制数据是零。
ANNUAL_TBL DB 365 DUP (20H)
ANNUAL_TBL DB 365 DUP (0)
14-3.分别定义3个有联系的表格，它们包含以下数据：（a）ASCII的项目编号04，07，14，17，以及24，
（b）项目说明：DVDs，receivers，modems，keyboards，以及disketes，（c）
项目的价格：22.20，95.75，47.45，49.35，以及12.95。
ASC_TBL DB '04','07','14','17','24'
DESC_TBL DB 'DVDs     '
                 DB 'receivers'
                 DB 'moderns  '
                 DB 'keyboards'
                 DB 'diskettes'
PRICE_TBL DB '22.20','95.75','47.45','49.35','12.95'
14-4.修改14-3题，使所有数据都在同一张表中。对于第一个项目，把它的编号和说明定义在第1行中，
而它的价格定义在第2行中：对于第二个项目，把它们定义在第3行和第4行，以此类推。
DATA_TBL DB '04','DVDs     '
                  DB '22.20'
                  DB '07','receivers'
                  DB '95.75'
                  DB '14','moderns  '
                  DB '47.45'
                  DB '17','keyboards'
                  DB '49.35'
                  DB '24','diskettes'
                  DB '12.95'
14-5.修改图14-1，使之采用数字（ASCII）格式接受来自键盘的月份。如果输入是有效的
（01-12），定位并显示字母表示的月份；否则，显示出错信息。允许任何数量的键盘输入，当用户只用回车键回答提示符时，结束处理。
LEN_ENTRY EQU 9
MONTH_IN DB '12'
MONTH_TBL DB 'January  '
                      DB 'February '
                      DB 'March    '
                      DB 'April    '
                      DB 'May      '
                      DB 'June     '
                      DB 'July     '
                      DB 'August   '
                      DB 'September'
                      DB 'October  '
                      DB 'November '
                      DB 'December '
...
XOR WORD PTR MONTH_IN,3030H
MOV AL,MONTH_IN
MOV AH,10
MUL AH
ADD AL,MONTH_IN+1
DEC AL
MOV AH,LEN_ENTRY
MUL AH
LEA BP,MONTH_TBL
ADD BP,AX

MOV AX,1301H
MOV BX,0016H
MOV CX,LEN_ENTRY
MOV DX,0812H
INT 10H
...
测试通过的完整程序如下
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
GET_BUF DB 128 DUP (0)
MESS_MONTH DB 'Please input month(01-12):'
MESS_ERROR DB 'input month error!'
res_dx dw 0
res_cx dw 0
res_bx dw 0
res_ax dw 0
num_dx dw 0
num_cx dw 0
num_bx dw 0
num_ax dw 0
val_dx dw 0
val_cx dw 0
val_bx dw 0
val_ax dw 0
mul_table dd 1,10,100,1000,10000,100000,1000000,10000000,100000000
LEN_ENTRY EQU 9
MONTH_TBL DB 'January  '
                      DB 'February '
                      DB 'March    '
                      DB 'April    '
                      DB 'May      '
                      DB 'June     '
                      DB 'July     '
                      DB 'August   '
                      DB 'September'
                      DB 'October  '
                      DB 'November '
                      DB 'December '
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG,ES:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV ES,AX
CALL CONVERT
MOV AH,4CH
INT 21H
ISDEC PROC
CMP AL,'0'
JB ISDEC_NODEC
CMP AL,'9'
JA ISDEC_NODEC
CLC
JMP ISDEC_OK
ISDEC_NODEC:STC
ISDEC_OK:RET
ISDEC ENDP
ATOBIN PROC
SUB AL,30H
CMP AL,9
JBE ATOBIN_OK
SUB AL,7
CMP AL,15
JBE ATOBIN_OK
SUB AL,20H
ATOBIN_OK:RET
ATOBIN ENDP
DTOBIN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DI,SI
ADD DI,CX
DEC DI
MOV BP,0
MOV VAL_AX,0
MOV VAL_DX,0
DTOBIN_FORJ:CMP DI,SI
JB DTOBIN_OK
MOV AL,DS:[DI]
CALL ATOBIN
MOV AH,0
MOV BX,AX
MOV AX,0
MOV DX,WORD PTR MUL_TABLE[BP]
MOV CX,WORD PTR MUL_TABLE[BP+2]
CALL MULDW
ADD VAL_AX,AX
ADC VAL_DX,BX
DTOBIN_NEXTJ:DEC DI
INC BP
INC BP
INC BP
INC BP
JMP DTOBIN_FORJ
DTOBIN_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOBIN ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRD PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRD1:CALL GETCH
CMP AL,CR
JZ GETSTRD5
CMP AL,BACKSPACE
JNZ GETSTRD4
CMP BX,0
JZ GETSTRD2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRD1
GETSTRD2:CALL BELL
JMP GETSTRD1
GETSTRD4:CMP BX,2
JZ GETSTRD2
CALL ISDEC
JC GETSTRD2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRD1
GETSTRD5:
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRD_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRD ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
MULDW PROC
MOV NUM_AX,AX
MOV NUM_BX,BX
MOV NUM_CX,CX
MOV NUM_DX,DX
MOV AX,NUM_AX
MOV BX,NUM_CX
MUL BX
MOV RES_DX,DX
MOV RES_CX,AX
MOV AX,NUM_BX
MOV BX,NUM_DX
MUL BX
MOV RES_BX,DX
MOV RES_AX,AX
MOV AX,NUM_AX
MOV BX,NUM_DX
MUL BX
ADD AX,RES_BX
ADC WORD PTR RES_CX,0
ADC WORD PTR RES_DX,0
ADD DX,RES_CX
ADC WORD PTR RES_DX,0
MOV RES_CX,DX
MOV RES_BX,AX
MOV AX,NUM_BX
MOV BX,NUM_CX
MUL BX
ADD AX,RES_BX
ADC WORD PTR RES_CX,0
ADC WORD PTR RES_DX,0
ADD DX,RES_CX
ADC WORD PTR RES_DX,0
MOV RES_CX,DX
MOV RES_BX,AX
MOV DX,RES_DX
MOV CX,RES_CX
MOV BX,RES_BX
MOV AX,RES_AX
RET
MULDW ENDP
DIVDD PROC
MOV NUM_DX,DX
MOV NUM_CX,CX
MOV NUM_BX,BX
MOV NUM_AX,AX
MOV RES_BX,DI
MOV RES_AX,SI
XOR AX,AX
MOV VAL_DX,AX
MOV VAL_CX,AX
MOV VAL_BX,AX
MOV VAL_AX,AX
MOV RES_DX,AX
MOV RES_CX,AX
XOR CX,CX
DIVDD_FORJ1:CMP CX,64
JAE DIVDD_FINISHJ1
CLC
RCL NUM_AX,1
RCL NUM_BX,1
RCL NUM_CX,1
RCL NUM_DX,1
RCL RES_CX,1
RCL RES_DX,1
PUSHF
POP BX
MOV AX,RES_CX
MOV DX,RES_DX
SUB AX,RES_AX
SBB DX,RES_BX
PUSHF
TEST BL,01H
JNZ DIVDD_A1
POPF
JNC DIVDD_A2
JMP DIVDD_B1
DIVDD_A1:POPF
DIVDD_A2:MOV RES_CX,AX
MOV RES_DX,DX
STC
RCL VAL_AX,1
RCL VAL_BX,1
RCL VAL_CX,1
RCL VAL_DX,1
JMP DIVDD_NEXTJ1
DIVDD_B1:CLC
RCL VAL_AX,1
RCL VAL_BX,1
RCL VAL_CX,1
RCL VAL_DX,1
DIVDD_NEXTJ1:INC CX
JMP DIVDD_FORJ1
DIVDD_FINISHJ1:MOV DX,VAL_DX
MOV CX,VAL_CX
MOV BX,VAL_BX
MOV AX,VAL_AX
MOV DI,RES_DX
MOV SI,RES_CX
RET
DIVDD ENDP
ABSOLU PROC
PUSH BX
mov bx,dx
and bx,8000h
cmp bx,0
jz absolu_ok
not dx
not ax
add ax,1
adc dx,0
absolu_ok:POP BX
RET
ABSOLU ENDP
DTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
CMP DX,0
JNZ DTOASC1
CMP AX,0
JNZ DTOASC1
MOV AL,'0'
CALL PUTCH
JMP DTOASC_OK
DTOASC1:mov di,0
divide_asc:mov cx,dx
jcxz finish_s_asc
divide_s_asc:mov cx,0AH
call divdw
inc di
push cx
jmp divide_asc
finish_s_asc:mov cx,ax
jcxz finish_asc
jmp divide_s_asc
finish_asc:mov cx,di
jcxz DTOASC_OK
string_asc:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string_asc
DTOASC_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOASC ENDP
DDTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CMP DX,0
JNZ DDTOASC1
CMP CX,0
JNZ DDTOASC1
CMP BX,0
JNZ DDTOASC1
CMP AX,0
JNZ DDTOASC1
MOV AL,'0'
CALL PUTCH
JMP DDTOASC_OK
DDTOASC1:mov bp,0
divide_ddtoasc:cmp dx,0
jz finish_s_ddtoasc1
divide_s_ddtoasc:mov di,0
mov si,10
call divdd
inc bp
push si
jmp divide_ddtoasc
finish_s_ddtoasc1:cmp cx,0
jz finish_s_ddtoasc2
jmp divide_s_ddtoasc
finish_s_ddtoasc2:cmp bx,0
jz finish_s_ddtoasc3
jmp divide_s_ddtoasc
finish_s_ddtoasc3:cmp ax,0
jz finish_ddtoasc
jmp divide_s_ddtoasc
finish_ddtoasc:mov cx,bp
jcxz DDTOASC_OK
string_ddtoasc:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string_ddtoasc
DDTOASC_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DDTOASC ENDP
CONVERT PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CONVERT_A10:CALL Q10CLEAR
MOV BP,OFFSET MESS_MONTH
MOV CX,26
MOV DH,10
MOV DL,10
CALL G10DISPLY
MOV DI,OFFSET GET_BUF
CALL GETSTRD
MOV SI,OFFSET GET_BUF
ADD SI,2
MOV CX,WORD PTR GET_BUF
SUB CX,2
CMP CX,0
JE CONVERT_OK
CALL DTOBIN
MOV DX,VAL_DX
MOV AX,VAL_AX
CMP AX,1
JB CONVERT_A20
CMP AX,12
JA CONVERT_A20
DEC AL
MOV AH,LEN_ENTRY
MUL AH
LEA BP,MONTH_TBL
ADD BP,AX
MOV CX,LEN_ENTRY
MOV DX,0812H
CALL G10DISPLY
push dx
mov dx,9000h
call delay
pop dx
JMP CONVERT_A10
CONVERT_A20:
MOV BP,OFFSET MESS_ERROR
MOV CX,18
MOV DH,12
MOV DL,39
CALL G10DISPLY
push dx
mov dx,9000h
call delay
pop dx
JMP CONVERT_A10
CONVERT_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
CONVERT ENDP
G10DISPLY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,1301H
MOV BX,0016H
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
G10DISPLY ENDP
Q10CLEAR PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,0600H
MOV BH,61H
MOV CX,0000H
MOV DX,184FH
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
Q10CLEAR ENDP
DELAY PROC NEAR
push ax
push dx
mov ax,0
delay_s:sub ax,1
sbb dx,0
cmp ax,0
jne delay_s
cmp dx,0
jne delay_s
pop dx
pop ax
ret
DELAY ENDP
CSEG ENDS
END START
14-6.编一个程序，允许用户从键盘输入项目编号和数量。
使用14-4题定义的表格并包括一个查找例行程序，该程序用输入项目编号把它定位在表格中。从表中提取说明与价格。
LEN_STKNO EQU 2
LEN_DESCR EQU 9
LEN_RATE EQU 5
STOCK_TBL DB '04','DVDs     ','22.20'
                  DB '07','receivers','95.75'
                  DB '14','moderns  ','47.45'
                  DB '17','keyboards','49.35'
                  DB '24','diskettes','12.95'
                  DB '99',14 DUP (20H)
计算每次销售的值（数量×价格），并在屏幕上显示说明和值。当用户只用回车键回答提示符时，结束处理。
测试通过的完整程序如下
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
GET_BUF DB 128 DUP (0)
MESS_STKNO DB 'Please input stock no:'
MESS_QTYNO DB 'Please input quantity:'
MESS_ERROR DB 'input error!'
MESS_NOTFIND DB 'not find!   '
res_dx dw 0
res_cx dw 0
res_bx dw 0
res_ax dw 0
num_dx dw 0
num_cx dw 0
num_bx dw 0
num_ax dw 0
val_dx dw 0
val_cx dw 0
val_bx dw 0
val_ax dw 0
val_di dw 0
mul_table dd 1,10,100,1000,10000,100000,1000000,10000000,100000000
LEN_STKNO EQU 2
LEN_DESCR EQU 9
LEN_RATE EQU 5
STOCK_TBL DB '04','DVDs     ','22.20'
                  DB '07','receivers','95.75'
                  DB '14','moderns  ','47.45'
                  DB '17','keyboards','49.35'
                  DB '24','diskettes','12.95'
                  DB '99',14 DUP (20H)
ASCPROD DB 16 DUP (30H)
BINPROD DW 0
BINQTY DW 0
BINRATE DW 0
DECIND DB 0
MULT10 DW 1
NODECIMS DW 0
ADJUST DW ?
SHIFT DW ?
TENWD DW 10
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG,ES:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV ES,AX
CALL CONVERT
MOV AH,4CH
INT 21H
ISDEC PROC
CMP AL,'0'
JB ISDEC_NODEC
CMP AL,'9'
JA ISDEC_NODEC
CLC
JMP ISDEC_OK
ISDEC_NODEC:STC
ISDEC_OK:RET
ISDEC ENDP
ATOBIN PROC
SUB AL,30H
CMP AL,9
JBE ATOBIN_OK
SUB AL,7
CMP AL,15
JBE ATOBIN_OK
SUB AL,20H
ATOBIN_OK:RET
ATOBIN ENDP
DTOBIN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DI,SI
ADD DI,CX
DEC DI
MOV BP,0
MOV VAL_AX,0
MOV VAL_DX,0
DTOBIN_FORJ:CMP DI,SI
JB DTOBIN_OK
MOV AL,DS:[DI]
CALL ATOBIN
MOV AH,0
MOV BX,AX
MOV AX,0
MOV DX,WORD PTR MUL_TABLE[BP]
MOV CX,WORD PTR MUL_TABLE[BP+2]
CALL MULDW
ADD VAL_AX,AX
ADC VAL_DX,BX
DTOBIN_NEXTJ:DEC DI
INC BP
INC BP
INC BP
INC BP
JMP DTOBIN_FORJ
DTOBIN_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOBIN ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRD PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRD1:CALL GETCH
CMP AL,CR
JZ GETSTRD5
CMP AL,BACKSPACE
JNZ GETSTRD4
CMP BX,0
JZ GETSTRD2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRD1
GETSTRD2:CALL BELL
JMP GETSTRD1
GETSTRD4:CMP BX,4
JZ GETSTRD2
CALL ISDEC
JC GETSTRD2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRD1
GETSTRD5:
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRD_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRD ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
MULDW PROC
MOV NUM_AX,AX
MOV NUM_BX,BX
MOV NUM_CX,CX
MOV NUM_DX,DX
MOV AX,NUM_AX
MOV BX,NUM_CX
MUL BX
MOV RES_DX,DX
MOV RES_CX,AX
MOV AX,NUM_BX
MOV BX,NUM_DX
MUL BX
MOV RES_BX,DX
MOV RES_AX,AX
MOV AX,NUM_AX
MOV BX,NUM_DX
MUL BX
ADD AX,RES_BX
ADC WORD PTR RES_CX,0
ADC WORD PTR RES_DX,0
ADD DX,RES_CX
ADC WORD PTR RES_DX,0
MOV RES_CX,DX
MOV RES_BX,AX
MOV AX,NUM_BX
MOV BX,NUM_CX
MUL BX
ADD AX,RES_BX
ADC WORD PTR RES_CX,0
ADC WORD PTR RES_DX,0
ADD DX,RES_CX
ADC WORD PTR RES_DX,0
MOV RES_CX,DX
MOV RES_BX,AX
MOV DX,RES_DX
MOV CX,RES_CX
MOV BX,RES_BX
MOV AX,RES_AX
RET
MULDW ENDP
DIVDD PROC
MOV NUM_DX,DX
MOV NUM_CX,CX
MOV NUM_BX,BX
MOV NUM_AX,AX
MOV RES_BX,DI
MOV RES_AX,SI
XOR AX,AX
MOV VAL_DX,AX
MOV VAL_CX,AX
MOV VAL_BX,AX
MOV VAL_AX,AX
MOV RES_DX,AX
MOV RES_CX,AX
XOR CX,CX
DIVDD_FORJ1:CMP CX,64
JAE DIVDD_FINISHJ1
CLC
RCL NUM_AX,1
RCL NUM_BX,1
RCL NUM_CX,1
RCL NUM_DX,1
RCL RES_CX,1
RCL RES_DX,1
PUSHF
POP BX
MOV AX,RES_CX
MOV DX,RES_DX
SUB AX,RES_AX
SBB DX,RES_BX
PUSHF
TEST BL,01H
JNZ DIVDD_A1
POPF
JNC DIVDD_A2
JMP DIVDD_B1
DIVDD_A1:POPF
DIVDD_A2:MOV RES_CX,AX
MOV RES_DX,DX
STC
RCL VAL_AX,1
RCL VAL_BX,1
RCL VAL_CX,1
RCL VAL_DX,1
JMP DIVDD_NEXTJ1
DIVDD_B1:CLC
RCL VAL_AX,1
RCL VAL_BX,1
RCL VAL_CX,1
RCL VAL_DX,1
DIVDD_NEXTJ1:INC CX
JMP DIVDD_FORJ1
DIVDD_FINISHJ1:MOV DX,VAL_DX
MOV CX,VAL_CX
MOV BX,VAL_BX
MOV AX,VAL_AX
MOV DI,RES_DX
MOV SI,RES_CX
RET
DIVDD ENDP
ABSOLU PROC
PUSH BX
mov bx,dx
and bx,8000h
cmp bx,0
jz absolu_ok
not dx
not ax
add ax,1
adc dx,0
absolu_ok:POP BX
RET
ABSOLU ENDP
DTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
CMP DX,0
JNZ DTOASC1
CMP AX,0
JNZ DTOASC1
MOV AL,'0'
CALL PUTCH
JMP DTOASC_OK
DTOASC1:mov di,0
divide_asc:mov cx,dx
jcxz finish_s_asc
divide_s_asc:mov cx,0AH
call divdw
inc di
push cx
jmp divide_asc
finish_s_asc:mov cx,ax
jcxz finish_asc
jmp divide_s_asc
finish_asc:mov cx,di
jcxz DTOASC_OK
string_asc:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string_asc
DTOASC_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOASC ENDP
DDTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CMP DX,0
JNZ DDTOASC1
CMP CX,0
JNZ DDTOASC1
CMP BX,0
JNZ DDTOASC1
CMP AX,0
JNZ DDTOASC1
MOV AL,'0'
CALL PUTCH
JMP DDTOASC_OK
DDTOASC1:mov bp,0
divide_ddtoasc:cmp dx,0
jz finish_s_ddtoasc1
divide_s_ddtoasc:mov di,0
mov si,10
call divdd
inc bp
push si
jmp divide_ddtoasc
finish_s_ddtoasc1:cmp cx,0
jz finish_s_ddtoasc2
jmp divide_s_ddtoasc
finish_s_ddtoasc2:cmp bx,0
jz finish_s_ddtoasc3
jmp divide_s_ddtoasc
finish_s_ddtoasc3:cmp ax,0
jz finish_ddtoasc
jmp divide_s_ddtoasc
finish_ddtoasc:mov cx,bp
jcxz DDTOASC_OK
string_ddtoasc:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string_ddtoasc
DDTOASC_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DDTOASC ENDP
CONVERT PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CONVERT_A10:CALL Q10CLEAR
MOV BP,OFFSET MESS_STKNO
MOV CX,22
MOV DH,10
MOV DL,10
CALL G10DISPLY
MOV DI,OFFSET GET_BUF
CALL GETSTRD
MOV SI,OFFSET GET_BUF
ADD SI,2
MOV CX,WORD PTR GET_BUF
SUB CX,2
CMP CX,0
JE CONVERT_OK
CMP CX,LEN_STKNO
JNE CONVERT_A20
CLD
LEA DI,STOCK_TBL
CONVERT_S20:MOV CX,LEN_STKNO
MOV SI,OFFSET GET_BUF
ADD SI,2
REPE CMPSB
JE CONVERT_S30
JB CONVERT_S40
ADD DI,CX
ADD DI,LEN_DESCR
ADD DI,LEN_RATE
JMP CONVERT_S20
CONVERT_S30:MOV WORD PTR VAL_DI,DI
MOV BP,DI
MOV AX,1301H
MOV BX,0061H
MOV CX,LEN_DESCR
MOV DX,0812H
INT 10H
MOV BP,OFFSET MESS_QTYNO
MOV CX,22
MOV DH,11
MOV DL,10
CALL G10DISPLY
MOV DI,OFFSET GET_BUF
CALL GETSTRD
MOV SI,OFFSET GET_BUF
ADD SI,2
MOV CX,WORD PTR GET_BUF
SUB CX,2
CMP CX,0
JE CONVERT_A20
CALL DTOBIN
MOV DX,VAL_DX
MOV AX,VAL_AX
MOV BINQTY,AX
MOV WORD PTR NODECIMS,0
MOV CX,0
MOV CL,LEN_RATE
MOV SI,WORD PTR VAL_DI
ADD SI,LEN_DESCR
ADD SI,CX
DEC SI
CALL J10ASCBIN
MOV AX,BINPROD
MOV BINRATE,AX
CALL E10MULT
CALL F10PROD
CALL G10FORMAT
JMP CONVERT_S90
CONVERT_S40:
MOV BP,OFFSET MESS_NOTFIND
MOV CX,12
MOV DH,12
MOV DL,39
CALL G10DISPLY
JMP CONVERT_S90
CONVERT_S90:
push dx
mov dx,9000h
call delay
pop dx
JMP CONVERT_A10
CONVERT_A20:
MOV BP,OFFSET MESS_ERROR
MOV CX,12
MOV DH,12
MOV DL,39
CALL G10DISPLY
push dx
mov dx,9000h
call delay
pop dx
JMP CONVERT_A10
CONVERT_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
CONVERT ENDP
G10DISPLY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,1301H
MOV BX,0016H
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
G10DISPLY ENDP
Q10CLEAR PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,0600H
MOV BH,61H
MOV CX,0000H
MOV DX,184FH
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
Q10CLEAR ENDP
DELAY PROC NEAR
push ax
push dx
mov ax,0
delay_s:sub ax,1
sbb dx,0
cmp ax,0
jne delay_s
cmp dx,0
jne delay_s
pop dx
pop ax
ret
DELAY ENDP
E10MULT PROC NEAR
MOV CX,16
LEA DI,ASCPROD
MOV AL,30H
CLD
REP STOSB
MOV WORD PTR SHIFT,10
MOV WORD PTR ADJUST,0
MOV BP,10
MOV CX,NODECIMS
CMP CL,4
JA E40
SUB CX,2
JLE E30
MOV WORD PTR NODECIMS,2
MOV AX,1
E20:MUL BP
LOOP E20
MOV WORD PTR SHIFT,AX
SHR AX,1
MOV WORD PTR ADJUST,AX
E30:MOV AX,BINQTY
MUL WORD PTR BINRATE
ADD AX,ADJUST
ADC DX,0
CMP WORD PTR ADJUST,0
JZ E80
JMP E50
E40:XOR AX,AX
JMP E70
E50:MOV CX,WORD PTR SHIFT
CALL DIVDW
JMP E80
E70:XOR DX,DX
E80:RET
E10MULT ENDP
F10PROD PROC NEAR
LEA SI,ASCPROD+11
MOV BYTE PTR DS:[SI],'.'
ADD SI,NODECIMS
F30:CMP BYTE PTR DS:[SI],'.'
JNE F40
DEC SI
F40:CMP DX,0
JNZ F50
CMP AX,0
JZ F60
F50:MOV CX,TENWD
CALL DIVDW
OR CL,30H
MOV DS:[SI],CL
DEC SI
JMP F30
F60:RET
F10PROD ENDP
G10FORMAT PROC NEAR
MOV CX,16
LEA SI,ASCPROD
G20:CMP BYTE PTR DS:[SI],30H
JNE G30
MOV BYTE PTR DS:[SI],20H
INC SI
LOOP G20
G30:LEA BP,ASCPROD
MOV CX,16
MOV DX,0912H
CALL G10DISPLY
RET
G10FORMAT ENDP
J10ASCBIN PROC NEAR
MOV WORD PTR MULT10,1
MOV WORD PTR BINPROD,0
MOV BYTE PTR DECIND,0
XOR BX,BX
MOV BP,10
J20:MOV AL,DS:[SI]
CMP AL,'.'
JNE J30
MOV BYTE PTR DECIND,1
JMP J40
J30:AND AX,000FH
MUL WORD PTR MULT10
ADD WORD PTR BINPROD,AX
MOV AX,MULT10
MUL BP
MOV WORD PTR MULT10,AX
CMP BYTE PTR DECIND,0
JNZ J40
INC BX
J40:DEC SI
LOOP J20
CMP BYTE PTR DECIND,0
JZ J90
ADD WORD PTR NODECIMS,BX
J90:RET
J10ASCBIN ENDP
CSEG ENDS
END START
14-7.使用14-3题定义的说明表，编写一个程序（a）把该表的内容传送到另外一个（空的）表，（b）将这一新表的内容技升序排列，
（c）按屏幕上相连续的行显示每个说明。提供卷动的屏幕。
测试通过的完整程序如下
.MODEL SMALL
.STACK 512
.DATA
LEN_NAME EQU 16
ENDADDR DW ?
NAMECTR DB 5
NAMESAVE DB 16 DUP (?)
NAME_TBL DB 30 DUP (16 DUP (20H))
ROW DB 0
SWAPPED DB 0
LEN_STKNO EQU 2
LEN_DESCR EQU 9
LEN_RATE EQU 5
STOCK_TBL DB '04','DVDs     ','22.20'
                  DB '07','receivers','95.75'
                  DB '14','moderns  ','47.45'
                  DB '17','keyboards','49.35'
                  DB '24','diskettes','12.95'
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
CLD
LEA SI,STOCK_TBL
LEA DI,NAME_TBL
MOV CX,80
CALL MEMCOPY
CALL Q10CLEAR
CALL D10SORT
CALL F10NAMES
MOV AX,4C00H
INT 21H
A10MAIN ENDP
D10SORT PROC NEAR
MOV AX,0
MOV AL,NAMECTR
MOV AH,LEN_NAME
MUL AH
LEA DI,NAME_TBL
ADD DI,AX
SUB DI,32
MOV WORD PTR ENDADDR,DI
D20:MOV BYTE PTR SWAPPED,0
LEA SI,NAME_TBL
D30:MOV CX,LEN_NAME
MOV DI,SI
ADD DI,LEN_NAME
MOV AX,DI
MOV BX,SI
CLD
ADD SI,LEN_STKNO
ADD DI,LEN_STKNO
MOV CX,LEN_DESCR
REPE CMPSB
JBE D40
CALL E10XCHNG
D40:MOV SI,AX
CMP SI,WORD PTR ENDADDR
JBE D30
CMP BYTE PTR SWAPPED,0
JNZ D20
RET
D10SORT ENDP
E10XCHNG PROC NEAR
MOV CX,LEN_NAME
LEA DI,NAMESAVE
MOV SI,BX
CLD
REP MOVSB
MOV CX,LEN_NAME
MOV DI,BX
REP MOVSB
MOV CX,LEN_NAME
LEA SI,NAMESAVE
REP MOVSB
MOV BYTE PTR SWAPPED,1
RET
E10XCHNG ENDP
F10NAMES PROC NEAR
MOV BYTE PTR ROW,0
LEA BP,NAME_TBL
F20:MOV CX,LEN_NAME
CALL G10DISPLY
INC BYTE PTR ROW
ADD BP,LEN_NAME
DEC BYTE PTR NAMECTR
JNZ F20
RET
F10NAMES ENDP
G10DISPLY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,1301H
MOV BX,0016H
MOV DH,ROW
MOV DL,10
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
G10DISPLY ENDP
Q10CLEAR PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,0600H
MOV BH,61H
MOV CX,0000H
MOV DX,184FH
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
Q10CLEAR ENDP
MEMCOPY PROC NEAR
PUSHF
PUSH CX
PUSH SI
PUSH DI
CLD
TEST SI,1
JZ MEMCOPY_1
MOVSB
DEC CX
MEMCOPY_1:SHR CX,1
REP MOVSW
JNC MEMCOPY_OK
MOVSB
MEMCOPY_OK:POP DI
POP SI
POP CX
POPF
RET
MEMCOPY ENDP
END A10MAIN
14-8.在“XLAT指令”一节中的程序片断把ASCII字符转换成EBCDIC格式。
修改该例子，进行相反的处理把EBCDIC数据转换成ASCII格式。
EBCDIC字符要转换的是负的符号（60H），十进制小数点（4BH），数0-9（F0H-F9H），以及所有其他字符转换成空格。
对于数据，使用EBCDIC的十六进制字符串F0 F0 F1 F2 4B F5 F0 60（定义成0F0H，0F1H等等），
把它转换成ASCII格式并加以显示。该十六进制结果应当是30 30 31 32 2E 35 30 2D。
'0012.50-'
测试通过的完整程序如下
.MODEL SMALL
.STACK 512
.DATA
XLAT_TBL DB 75 DUP (20H)
DB 2EH
DB 20 DUP (20H)
DB 2DH
DB 143 DUP (20H)
DB 30H,31H,32H,33H,34H
DB 35H,36H,37H,38H,39H
DB 6 DUP (20H)
ASC_NO DB 8 DUP (20H)
EBC_NO DB 0F0H,0F0H,0F1H,0F2H,4BH,0F5H,0F0H,60H
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
CLD
LEA SI,EBC_NO
LEA DI,ASC_NO
MOV CX,8
LEA BX,XLAT_TBL
L10:LODSB
XLAT
STOSB
LOOP L10
CALL Q10CLEAR
LEA BP,ASC_NO
MOV CX,8
MOV DX,0812H
CALL G10DISPLY
MOV AX,4C00H
INT 21H
A10MAIN ENDP
G10DISPLY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,1301H
MOV BX,0016H
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
G10DISPLY ENDP
Q10CLEAR PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,0600H
MOV BH,61H
MOV CX,0000H
MOV DX,184FH
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
Q10CLEAR ENDP
END A10MAIN
14-9.编写一个程序，为数据提供简单的加密。定义一个名为CRYPTDATA的80字节的数据区，它包含任何ASCII数据。
安排一个转换表把数据转换成有点随机的形式，如A变成M，B变成R，C变成X，如此等等。
提供全部256种可能的字节值。安排第二个转换表，按相反的方式（解密）处理该数据。
程序应当完成以下动作：（a）在一行中显示CRYPTDATA的原始内容，
（b）加密CRYPTDATA并在第二行显示加密后数据，
（c）解密CRPYTDATA并在第三行显示解密后的数据（它应该和第一行内容相同）。
测试通过的完整程序如下
.MODEL SMALL
.STACK 512
.DATA
CRYPT_TBL DB 00H,01H,02H,03H,04H,05H,06H,07H,08H,09H,0AH,0BH,0CH,0DH,0EH,0FH
                   DB 10H,11H,12H,13H,14H,15H,16H,17H,18H,19H,1AH,1BH,1CH,1DH,1EH,1FH
                   DB 20H,21H,22H,23H,24H,25H,26H,27H,28H,29H,2AH,2BH,2CH,2DH,2EH,2FH
                   DB 40H,41H,42H,43H,44H,45H,46H,47H,48H,49H,4AH,4BH,4CH,4DH,4EH,4FH
                   DB 30H,31H,32H,33H,34H,35H,36H,37H,38H,39H,3AH,3BH,3CH,3DH,3EH,3FH
                   DB 50H,51H,52H,53H,54H,55H,56H,57H,58H,59H,5AH,5BH,5CH,5DH,5EH,5FH
                   DB 60H,61H,62H,63H,64H,65H,66H,67H,68H,69H,6AH,6BH,6CH,6DH,6EH,6FH
                   DB 70H,71H,72H,73H,74H,75H,76H,77H,78H,79H,7AH,7BH,7CH,7DH,7EH,7FH
                   DB 80H,81H,82H,83H,84H,85H,86H,87H,88H,89H,8AH,8BH,8CH,8DH,8EH,8FH
                   DB 90H,91H,92H,93H,94H,95H,96H,97H,98H,99H,9AH,9BH,9CH,9DH,9EH,9FH
                   DB 0A0H,0A1H,0A2H,0A3H,0A4H,0A5H,0A6H,0A7H,0A8H,0A9H,0AAH,0ABH,0ACH,0ADH,0AEH,0AFH
                   DB 0B0H,0B1H,0B2H,0B3H,0B4H,0B5H,0B6H,0B7H,0B8H,0B9H,0BAH,0BBH,0BCH,0BDH,0BEH,0BFH
                   DB 0C0H,0C1H,0C2H,0C3H,0C4H,0C5H,0C6H,0C7H,0C8H,0C9H,0CAH,0CBH,0CCH,0CDH,0CEH,0CFH
                   DB 0D0H,0D1H,0D2H,0D3H,0D4H,0D5H,0D6H,0D7H,0D8H,0D9H,0DAH,0DBH,0DCH,0DDH,0DEH,0DFH
                   DB 0E0H,0E1H,0E2H,0E3H,0E4H,0E5H,0E6H,0E7H,0E8H,0E9H,0EAH,0EBH,0ECH,0EDH,0EEH,0EFH
                   DB 0F0H,0F1H,0F2H,0F3H,0F4H,0F5H,0F6H,0F7H,0F8H,0F9H,0FAH,0FBH,0FCH,0FDH,0FEH,0FFH
DECRYPT_TBL DB 00H,01H,02H,03H,04H,05H,06H,07H,08H,09H,0AH,0BH,0CH,0DH,0EH,0FH
                   DB 10H,11H,12H,13H,14H,15H,16H,17H,18H,19H,1AH,1BH,1CH,1DH,1EH,1FH
                   DB 20H,21H,22H,23H,24H,25H,26H,27H,28H,29H,2AH,2BH,2CH,2DH,2EH,2FH
                   DB 40H,41H,42H,43H,44H,45H,46H,47H,48H,49H,4AH,4BH,4CH,4DH,4EH,4FH
                   DB 30H,31H,32H,33H,34H,35H,36H,37H,38H,39H,3AH,3BH,3CH,3DH,3EH,3FH
                   DB 50H,51H,52H,53H,54H,55H,56H,57H,58H,59H,5AH,5BH,5CH,5DH,5EH,5FH
                   DB 60H,61H,62H,63H,64H,65H,66H,67H,68H,69H,6AH,6BH,6CH,6DH,6EH,6FH
                   DB 70H,71H,72H,73H,74H,75H,76H,77H,78H,79H,7AH,7BH,7CH,7DH,7EH,7FH
                   DB 80H,81H,82H,83H,84H,85H,86H,87H,88H,89H,8AH,8BH,8CH,8DH,8EH,8FH
                   DB 90H,91H,92H,93H,94H,95H,96H,97H,98H,99H,9AH,9BH,9CH,9DH,9EH,9FH
                   DB 0A0H,0A1H,0A2H,0A3H,0A4H,0A5H,0A6H,0A7H,0A8H,0A9H,0AAH,0ABH,0ACH,0ADH,0AEH,0AFH
                   DB 0B0H,0B1H,0B2H,0B3H,0B4H,0B5H,0B6H,0B7H,0B8H,0B9H,0BAH,0BBH,0BCH,0BDH,0BEH,0BFH
                   DB 0C0H,0C1H,0C2H,0C3H,0C4H,0C5H,0C6H,0C7H,0C8H,0C9H,0CAH,0CBH,0CCH,0CDH,0CEH,0CFH
                   DB 0D0H,0D1H,0D2H,0D3H,0D4H,0D5H,0D6H,0D7H,0D8H,0D9H,0DAH,0DBH,0DCH,0DDH,0DEH,0DFH
                   DB 0E0H,0E1H,0E2H,0E3H,0E4H,0E5H,0E6H,0E7H,0E8H,0E9H,0EAH,0EBH,0ECH,0EDH,0EEH,0EFH
                   DB 0F0H,0F1H,0F2H,0F3H,0F4H,0F5H,0F6H,0F7H,0F8H,0F9H,0FAH,0FBH,0FCH,0FDH,0FEH,0FFH
ASCIIDATA DB '0123456789',30 DUP (20H),'@ABCDEFGHI',30 DUP (20H)
CRYPTDATA DB 80 DUP (0)
DECRYPTDATA DB 80 DUP (0)
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
CLD
LEA SI,ASCIIDATA
LEA DI,CRYPTDATA
MOV CX,80
LEA BX,CRYPT_TBL
L10:LODSB
XLAT
STOSB
LOOP L10
CLD
LEA SI,CRYPTDATA
LEA DI,DECRYPTDATA
MOV CX,80
LEA BX,DECRYPT_TBL
L20:LODSB
XLAT
STOSB
LOOP L20
CALL Q10CLEAR
LEA BP,ASCIIDATA
MOV CX,80
MOV DX,0812H
CALL G10DISPLY
LEA BP,CRYPTDATA
MOV CX,80
MOV DX,0912H
CALL G10DISPLY
LEA BP,DECRYPTDATA
MOV CX,80
MOV DX,0A12H
CALL G10DISPLY
MOV AX,4C00H
INT 21H
A10MAIN ENDP
G10DISPLY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,1301H
MOV BX,0016H
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
G10DISPLY ENDP
Q10CLEAR PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,0600H
MOV BH,61H
MOV CX,0000H
MOV DX,184FH
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
Q10CLEAR ENDP
END A10MAIN
14-10.修改图14-7中的程序（二维表格），使之把每行的右边的总数相加（垂直地），并把每列的底部的总数相加（水平地）。
把每行的右边的总数相加（垂直地）
...
LEA SI,[SPRD_TBL+COLTOT]
LEA DI,SPRD_TBL
ADD DI,10
ADD SI,10
MOV CX,NOROWS-1
S20:MOV AX,[DI]
ADD [SI],AX
ADD DI,COLS
LOOP S20
...
把每列的底部的总数相加（水平地）
...
LEA DI,[SPRD_TBL+COLTOT]
LEA SI,[SPRD_TBL+COLTOT]
ADD SI,10
MOV CX,NOCOLS-1
S30:MOV AX,[DI]
ADD [SI],AX
ADD DI,2
LOOP S30
...
第五部分高级输入/输出
第15章使用鼠标的设备
15.1引言
15.2基本的鼠标操作
15.3程序：显示鼠标位置
15.4更高级的鼠标操作
15.5程序：按菜单使用鼠标
15.6要点
15.7习题
目的：描述使用鼠标的程序设计要求
15.1引言
这一章描述了鼠标的使用：初始化鼠标，显示、隐藏鼠标指针，设置指针的位置和范围，和获取鼠标按键的信息。
两个程序举例说明了鼠标处理的使用。鼠标处理只介绍一条新指令INT 33H。
鼠标是一个通用的指示设备，它由一个统称为设备驱动程序的软件接口来控制，
这个驱动程序一般由CONFIG.SYS或AUTOEXEC.BAT文件的一个项来安装。必须安装这个驱动程序，
这样一个程序才可以识别并响应鼠标的动作。
下面是一些基本的鼠标定义：
像素：屏幕上最小的可寻址的元素。例如，对文本方式03，每字节有8个像素。
鼠标指针：在文本方式下，指针是一个反相显示的闪烁的方块；在图形方式下，指针是一个箭头。
Mickcy：测量鼠标移动的单位，约等于1/200英寸。
Mickey计数：鼠标球横向或纵向滚动的mickey的数量。鼠标驱动器用mickey来计算指针在屏幕上移动的像素数。
阈值速度：阈值速度以每秒mickey为单位，鼠标必须在屏幕上以双倍速度移动指针。
默认的阀值速度是每秒64mickeys。
程序中的所有鼠标操作都是由标准的INT 33H功能来执行的，其格式为：
MOV AX,function   ;请求鼠标功能
...   ;参数（如果有的话）
INT 33H   ;调用鼠标驱动程序
注意，不像其他的INT操作使用AH寄存器，INT 33H的功能号被装入整个的AX寄存器。
程序发出的第一条鼠标指令应当是功能00H，它仅仅初始化鼠标驱动器和程序之间的接口。
典型的用法是，在程序开始只需发出一次这个命令。紧接着功能00H，程序应当执行功能01H，它使鼠标指针出现在屏幕上。
随后，可以在鼠标操作的范围内选择其他功能。
INT 33H 0000H: Reset/Query Installed State
INT 33H 0001H: Show Mouse Pointer
INT 33H 0002H: Hide Mouse Pointer
INT 33H 0003H: Query Position / Button Status
INT 33H 0004H: Set Mouse Pointer Position
INT 33H 0005H: Query Button-Pressed Counter
INT 33H 0006H: Query Button-Released Counter
INT 33H 0007H: Set Horizontal Range
INT 33H 0008H: Set Vertical Range
INT 33H 0009H: Set Graphics Pointer Shape
INT 33H 000aH: Set Text Pointer Mask
INT 33H 000bH: Query Motion Distance
INT 33H 000cH: Set Mouse Event Handler
INT 33H 000dH: Enable Lightpen Emulation
INT 33H 000eH: Disable Lightpen Emulation
INT 33H 000fH: Set Pointer Speed
INT 33H 0010H: Set Exclusion Area
INT 33H 0013H: Set Speed-Doubling Threshold
INT 33H 0014H: Exchange Mouse Event Handler
INT 33H 0015H: Query Size of Mouse Status Buffer
INT 33H 0016H: Save Mouse Status
INT 33H 0017H: Restore Mouse Status
INT 33H 0018H: Set Alternate Event Handler
INT 33H 0019H: Query User Alternate Event Handler
INT 33H 001aH: Set Mouse Sensitivity
INT 33H 001bH: Query Mouse Sensitivity
INT 33H 001cH: Set Inport Mouse Interrupt Rate
INT 33H 001dH: Set Mouse Display Page
INT 33H 001eH: Query Mouse Display Page
INT 33H 001fH: Deactivate Mouse Driver
INT 33H 0020H: Reenable Mouse Driver
INT 33H 0021H: Reset Mouse Driver
INT 33H 0024H: Query Mouse Type/Driver Version/IRQ#
以下是可用到的INT33H的鼠标功能，其中有一些是经常要用到的：
00H初始化鼠标
01H显示鼠标指针
02H隐藏鼠标指针
03H获取按键状态和指针位置
04H设置指针位置
05H获取点击按键信息
06H获取释放按键信息
07H设置指针水平界限
08H设置指针垂直界限
09H设置图形指针类型
0AH设置文本指针类型
0BH读取鼠标移动计数器
0CH为鼠标事件安装中断处理程序
0DH打开光笔仿真
0EH关闭光笔仿真
0FH设置mickey与像素的比率
10H设置指针禁止区
13H设置倍速阈值
14H调动鼠标事件中断
15H获取鼠标驱动器状态的缓冲区大小
16H保存鼠标驱动器状态
17H恢复鼠标驱动器状态
18H安装鼠标事件的可选处理器
19H获取可选处理器的地址
1AH设置鼠标灵敏度
1BH获取鼠标灵敏度
1CH设置鼠标中断速率
1DH选择指针的显示页
1EH获取指针的显示页
1FH禁止鼠标驱动器
20H允许鼠标驱动器
21H重置鼠标驱动器
22H设置鼠标驱动器信息的语种23H获取语种数
24H获取鼠标信息
15.2基本的鼠标操作
以下几节描述了使用鼠标的程序所需要的基本INT 33H操作。
1.功能00H：初始化鼠标。这是一个程序为处理一个鼠标并只需执行一次的第一个命令。
功能00H装入AX，不带其他的输入参数，然后执行INT 33H。此操作返回这些值：
AX=0000H，如果没有可用的鼠标支持程序；或AX=FFFFH，如果支持程序是可用的
BX=鼠标按键的数量，如果支持程序是可用的
如果鼠标支持程序是可用的，该操作初始化鼠标的步骤如下：
设置鼠标指针到屏幕中央
如果鼠标指针是可见的，则隐蔽鼠标指针
设置鼠标指针的显示页为零
根据屏幕显示方式设置鼠标指针：文本方式为矩形及反相彩色，图形方式为箭头
设置mickey与像素的比率，水平比率=8：8，垂直比率=16：8
设置指针的水平和垂直界限的最小值和最大值
设置倍速阀值为每秒64mickeys，该值可以改变。
2.功能01H：显示鼠标指针。这个操作在功能00H后使用，它使鼠标指针显示在屏幕上。
这个操作不需要输入参数，也没有返回值。
鼠标驱动器保存一个指针标志以确定是否显示指针。如果标志是0则显示指针，是其他值则隐蔽指针。
这个值初始化为-1，功能01H递增这个标志为0，这样指针就被显示。（参见功能02H。）
3.功能02H：隐蔽鼠标指针。标准的做法是在程序执行的最后调用这个功能以隐蔽指针。
这个操作不需要输入参数，也不返回任何值。
当指针标志包含一个0时显示指针，当为其他值时隐蔽指针。这个功能递减指针标志从0到-1，使指针被隐蔽。
4.功能03H：获取按键状态和指针位置。这个功能不需要输入参数，返回有关鼠标的信息如下：
BX=按键的状态，根据位的位置确定如下：
Bit0 左键（0=未按，1=按下）
Bit1 右键（0=未按，1=按下）
Bit2 中键（0=未按，1=按下）
Bit 3至15为保留内部使用
CX=水平（x）坐标
DX=垂直（y）坐标
水平和垂直坐标在像素项中表示，即使在文本方式下也这样（显示方式03为每字节8个像素）。
这些值通常在指针的最小值和最大值界限之内。
5.功能04H：设置指针位置。这个操作设置鼠标在屏幕上的水平和垂直坐标
（位置的值在像素项中一对显示方式03为每字节8个像素）：
MOV AX,0004H   ;请求设置鼠标指针
MOV CX,horizontal   ;水平位置
MOV DX,vertical   ;垂直位置
INT 33H   ;调用鼠标驱动程序
如果指针超出了最小和最大的界限，此操作会做出必要的调整，在新位置设置指针。
15.3程序：显示鼠标位置
图15-1的程序说明了基本鼠标操作。在用户移动鼠标，而不是按鼠标的时候，它显示指针的水平和垂直坐标。主要过程如下：
A10MAIN初始化程序，调用B10INITZ，C10POINTR，D10CONVRT和E10DISPLY。
当用户按动左键，程序使用功能02H隐蔽指针并结束处理。
B10INITZ调用INT 33H的功能00H初始化鼠标（或指示没有鼠标驱动程序），并且调用功能01H显示鼠标指针。
如果用户按动了左键，C10POINTR调用功能03H检测并退出。如果没有按键，
程序将水平和垂直坐标从像素值转换为二进制数（把这个值右移3位，相当于除8）。
如果位置和先前检测到的一样，例行程序重复调用功能03H；如果位置变化了，控制返回到调用程序。
D10CONVRT将水平和垂直的屏幕位置的二进制值转换为可显示的ASCII字符。
注意每字节有8个像素，在屏幕上第79列（最右边的位置）返回的水平值是79×8=632。
程序把水平值除以8以得到最大值，在这个例子中是79。因此，这个转换确保返回值是在0到79之内。
E10DISPLY在屏幕中心显示水平与垂直坐标，如X=col，Y=row。
.MODEL SMALL
.STACK 512
.DATA
LEN_DATA EQU 14
XCOORD DW 0
YCOORD DW 0
ASCVAL DW ?
DISPDATA LABEL BYTE
XMSG DB 'X = '
XASCII DW ?
DB 20H,20H
YMSG DB 'Y = '
YASCII DW ?
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
CALL Q10CLEAR
CALL B10INITZ
CMP AX,0000H
JE A90
A20:CALL C10POINTR
CMP BX,0001H
JE A80
MOV AX,XCOORD
CALL D10CONVRT
MOV AX,ASCVAL
MOV XASCII,AX
MOV AX,YCOORD
CALL D10CONVRT
MOV AX,ASCVAL
MOV YASCII,AX
CALL E10DISPLY
JMP A20
A80:MOV AX,0002H
INT 33H
A90:CALL Q10CLEAR
MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10INITZ PROC NEAR
MOV AX,0000H
INT 33H
CMP AX,0000H
JE B90
MOV AX,0001H
INT 33H
B90:RET
B10INITZ ENDP
C10POINTR PROC NEAR
C20:MOV AX,0003H
INT 33H
CMP BX,00000001B
JE C90
SHR CX,1
SHR CX,1
SHR CX,1
SHR DX,1
SHR DX,1
SHR DX,1
CMP CX,XCOORD
JNE C30
CMP DX,YCOORD
JE C20
C30:MOV XCOORD,CX
MOV YCOORD,DX
C90:RET
C10POINTR ENDP
D10CONVRT PROC NEAR
MOV WORD PTR ASCVAL,2020H
MOV CX,10
LEA SI,ASCVAL+1
CMP AX,CX
JB D20
DIV CL
OR AH,30H
MOV DS:[SI],AH
DEC SI
D20:OR AL,30H
MOV DS:[SI],AL
RET
D10CONVRT ENDP
E10DISPLY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,1300H
MOV BX,0031H
LEA BP,DISPDATA
MOV CX,LEN_DATA
MOV DX,0020H
INT 10H
POP DX
POP CX
POP BX
POP AX
RET 
E10DISPLY ENDP
Q10CLEAR PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,0600H
MOV BH,30H
MOV CX,0000H
MOV DX,184FH
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
Q10CLEAR ENDP
END A10MAIN
改进这个程序的一个方法是调用功能0CH来设置中断处理程序。
用这种方法，只要鼠标是激活的，在鼠标中断处理程序中自动包括了所需要的指令。
15.4更高级的鼠标操作
这一节包含了其余的鼠标操作，下一节提供了另一个程序例子。
1.功能05H：获取点击按键信息。这个功能返回点击按键的信息。设置BX为按键编号，
0=左键，1=右键，2=中键：
MOV AX,0005H
MOV BX,button_no   ;按键号
INT 33H   ;调用鼠标驱动程序
这个操作返回按键的未按/按下的状态、点击次数和所请求按键的位置：
AX=按键的状态，根据位的位置确定键，如下：
Bit0 左键（0=未按，1=按下）
Bit1 右键（0=未按，1=按下）
Bit2 中键（0=未按，1=按下）
Bit3-15保留内部使用
BX=点击按键计数器
CX=最后一次点击的水平（x）坐标（像素值）
DX=最后一次点击的垂直（y）坐标（像素值）
该操作重置点击按键计数器为0。
2.功能06H：获取释放键信息。这个功能返回按键释放的信息。设置BX按键号
（0=左键，1=右键，2=中键）：
MOV AX,0006H   ;请求释放键信息
MOV BX,button_no   ;按键号
INT 33H   ;调用鼠标驱动程序
这个操作返回所有按键的未按/按下的状态、释放次数和所请求的按键的位置：
・AX=按键的状态，根据位的位置确定键，如下：
Bit0 左键（0=未按，1=按下）
Bit1 右键（0=未按，1=按下）
Bit2 中键（0=未按，1=按下）
Bit3-15保留内部使用
BX=释放键计数器
CX=最后一次释放键的水平（x）坐标（像素值）
DX=最后一次释放键的垂直（y）坐标（像素值）
操作重置释放键计数器为0。
3.功能07H：设置指针水平界限。这个操作设置指针的最小和最大的水平界限（像素值）：
MOV AX,0007H   ;请求设置水平界限
MOV CX,minimum   ;最小界限
MOV DX,maximum   ;最大界限
INT 33H   ;调用鼠标驱动程序
如果最小值大于最大值，该操作随意交换这两个值。
如果指针超出了定义的区域，该操作把它移回到区域内。参见功能08H和10H。
4.功能08H：设置指针垂直界限。这个操作设置指针的最小和最大的垂直界限（像素值）：
MOV AX,0008H   ;请求设置垂直界限
MOV CX,minimum   ;最小界限
MOV DX,maximum   ;最大界限
INT 33H   ;调用鼠标驱动程序
如果最小值大于最大值，该操作任意交换这两个值。如果指针超出了定义区域，该操作把它移回到区域内。参见功能07H和10H。
5.功能0BH：读取鼠标移动计数器。这个操作返回自最后一次请求这个功能以来的水平和垂直的mickey数
（在-32768到+32767范围内）。返回值是：
CX=水平计数（一个正值表示移动到右边，负值表示移动到左边）
DX=垂直计数（一个正值表示向下移动，负值表示向上移动）
6.功能0CH：安装鼠标事件的中断处理程序。程序可能需要在鼠标发生关联的动作（或事件）时自动响应。
功能0CH的目的是提供一个事件处理程序，借此鼠标软件来中断程序并调用事件处理程序，
执行它所请求的功能并在完成任务的时候返回到程序的执行点（断点）。
CX装入一个事件屏蔽码，以指出处理程序响应哪一种事件，ES:DX装入中断处理程序的段地址：偏移地址：
MOV AX,000CH   ;请求中断处理程序
MOV CX,mask   ;事件屏蔽码
LEA DX,handler   ;处理程序地址（ES:DX）
CX    event mask (events which you want sent to your handler)
bit 0 = mouse movement           (CX | 01H)
bit 1 = left button pressed      (CX | 02H)
bit 2 = left button released     (CX | 04H)
bit 3 = right button pressed     (CX | 08H)
bit 4 = right button released    (CX | 10H)
bit 5 = center button pressed    (CX | 20H)
bit 6 = center button released   (CX | 40H)
All events:      CX = 007fH
Disable handler: CX = 0000H
ES:DX address of your event handler code
定义事件屏蔽码的各位设置要求如下：
0=移动的鼠标指针   4=释放右键
1=点击左键   5=点击中键
2=释放左键   6=释放中键
3=点击右键   7-15=保留，定义为0
定义中断处理程序为一个FAR过程。鼠标驱动程序使用一个远程调用进入中断处理程序，并设置如下寄存器：
AX=定义的事件屏蔽码，只有在条件发生时才设置的那些位
BX=按键状态（如果已设置，位0代表左键按下，位1代表右键按下，位2代表中键按下）
CX=水平坐标（x）
DX=垂直坐标（y）
SI=最后的垂直mickey数
DI=最后的水平mickey数
DS=鼠标驱动程序的数据段
在进入中断处理程序的入口处，把所有的寄存器都入栈保存，并将DS初始化为数据段的地址。
在处理程序中，只能使用BIOS中断，而不能用DOS中断。退出时，所有寄存器都出栈。
7.功能10H：设置指针禁止区域。这个操作定义了一个不显示指针的屏幕区域：
MOV AX,0010H：请求设置禁区
MOV CX,upleft_x   ;左上角x坐标
MOV DX,upleft_y   ;左上角y坐标
MOV SI,lowright_x   ;右下角x坐标
MOV DI,lowright_y   ;右下角y坐标
INT 33H   ;调用鼠标驱动程序
用不同的参数重新调用这个函数，或新调用函数00H或01H来替换禁区。
8.功能13H：设置倍速阈值。这个操作设置阀值速度，指针以双倍于它的速度在屏幕上移动。
在DX中装入新的值（默认值是每秒64mickey）。（参见功能1AH）
9.功能1AH：设置鼠标灵敏度。灵敏度与指针移动之前鼠标必须移动的mickey数有关。
这个功能按照每8个像素的mickey数来设置水平的和垂直的鼠标移动量，以及使指针以双倍的速度在屏幕上移动的阀值速度，
（参见功能0FH，13H和1BH）：
MOV AX,001AH   ;请求设置鼠标灵敏度
MOV BX,horizontal   ;水平mickey数（默认值=8）
MOV CX,Vertical   ;垂真mickey数（默认值=16）
MOV DX,threshold   ;阀值速度（默认值=64）
INT 33H   ;调用鼠标驱动程序
10.功能1BH：获取鼠标灵敏度。这个操作根据每8个像素的mickey数来返回水平的和垂直的鼠标移动量，以及阀值速度，
指针在屏幕上以其双倍的速度来移动。（参见功能1AH，返回的寄存器及相应值）
11.功能1DH：选择指针的显示页。视频显示页用INT 10H的功能05H设置。
对于鼠标操作，在BX中设置页号，并调用这个函数。
12.功能1EH：获取指针的显示页。这个操作在BX中返回当前的视频显示页。
13.功能24H：获取鼠标信息。这个操作返回有关已安装鼠标的版本和类型信息：
BH=主版本号
BL=子版本号
CH=鼠标类型（1=总线鼠标，2=串口鼠标）
15.5程序：按菜单使用鼠标
在前面图10-2的程序使用了光标键从菜单里选择一项。图15-2的程序是类似的，但是现在允许用户在菜单上上下移动鼠标指针，
并通过点击左键选中一个入口项。同样的，现在在菜单最下面有一项是“Exit Program”。主要的过程如下：
A10MAIN 调用B10INITZ初始化鼠标，调用C10MENU显示菜单，调用E10DISPLY来高亮度显示当前菜单项，
调用D10POINTR响应鼠标的动作，并且当用户请求“Exit Program”时，结束处理。
B10INITZ初始化鼠标，显示指针，并且为指针区域设置水平和垂直界限。
C10MENU显示全部菜单选项。
D10POINTR检验是否点击左键，如果点击，调用E10DISPLY设置原先的菜单项为正常显示并把选择项设置成反相显示。
E10DISPLY按照给定的属性显示菜单项。
.MODEL SMALL
.STACK 512
.DATA
TOPROW EQU 08
BOTROW EQU 16
LEFTCOL EQU 26
LEN_LINE EQU 19
ATTRIB DB ?
COL DB 00
ROW DB 00
SHADOW DB 19 DUP (0DBH)
MENU DB 0C9H,17 DUP (0CDH),0BBH
DB 0BAH,'Add records      ',0BAH
DB 0BAH,'Delete records   ',0BAH
DB 0BAH,'Enter orders     ',0BAH
DB 0BAH,'Print report     ',0BAH
DB 0BAH,'Update accounts  ',0BAH
DB 0BAH,'View records     ',0BAH
DB 0BAH,'Exit program     ',0BAH
DB 0C8H,17 DUP (0CDH),0BCH
PROMPT DB 'To select an item,press left button of mouse pointer.'
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
CALL Q10CLEAR
CALL B10INITZ
CMP AX,0000H
JE A90
CALL C10MENU
A20:MOV ROW,TOPROW+1
MOV BYTE PTR ATTRIB,16H
CALL E10DISPLY
CALL D10POINTR
CMP DX,BOTROW-1
JNE A20
MOV AX,02H
INT 33H
CALL Q10CLEAR
A90:MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10INITZ PROC NEAR
MOV AX,0000H
INT 33H
CMP AX,0000H
JE B90
MOV AX,0001H
INT 33H
MOV AX,0004H
MOV CX,256
MOV DX,108
INT 33H
MOV AX,0007H
MOV CX,LEFTCOL+1
MOV DX,LEFTCOL+17
SHL CX,1
SHL CX,1
SHL CX,1
SHL DX,1
SHL DX,1
SHL DX,1
INT 33H
MOV AX,0008H
MOV CX,TOPROW+1
MOV DX,BOTROW-1
SHL CX,1
SHL CX,1
SHL CX,1
SHL DX,1
SHL DX,1
SHL DX,1
INT 33H
B90:RET
B10INITZ ENDP
C10MENU PROC NEAR
MOV AX,1301H
MOV BX,0060H
LEA BP,SHADOW
MOV CX,LEN_LINE
MOV DH,TOPROW+1
MOV DL,LEFTCOL+1
C20:INT 10H
MOV AX,1301H
MOV CX,LEN_LINE
MOV DL,LEFTCOL+1
INC DH
CMP DH,BOTROW+2
JNE C20
MOV BYTE PTR ATTRIB,71H
MOV AX,1301H
MOV BH,00H
MOV BL,ATTRIB
LEA BP,MENU
MOV CX,LEN_LINE
MOV DH,TOPROW
MOV DL,LEFTCOL
C30:INT 10H
ADD BP,LEN_LINE
MOV AX,1301H
MOV CX,LEN_LINE
MOV DL,LEFTCOL
INC DH
CMP DH,BOTROW+1
JNE C30
MOV AX,1301H
MOV BH,00H
MOV BL,ATTRIB
LEA BP,PROMPT
MOV CX,53
MOV DH,BOTROW+4
MOV DL,15
INT 10H
RET
C10MENU ENDP
D10POINTR PROC NEAR
D20:MOV AX,0003H
INT 33H
CMP BX,00000001B
JNE D20
SHR DX,1
SHR DX,1
SHR DX,1
CMP DX,BOTROW-1
JE D90
PUSH DX
MOV BYTE PTR ATTRIB,71H
CALL E10DISPLY
POP DX
MOV BYTE PTR ROW,DL
MOV BYTE PTR ATTRIB,17H
CALL E10DISPLY
JMP D20
D90:RET
D10POINTR ENDP
E10DISPLY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV AX,0
MOV AL,ROW
SUB AX,TOPROW
MOV BP,LEN_LINE
MUL BP
LEA SI,MENU+1
ADD SI,AX
MOV AX,1301H
MOV BH,00H
MOV BL,ATTRIB
MOV BP,SI
MOV CX,LEN_LINE-2
MOV DH,ROW
MOV DL,LEFTCOL+1
INT 10H
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
E10DISPLY ENDP
Q10CLEAR PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,0600H
MOV BH,61H
MOV CX,0000H
MOV DX,184FH
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
Q10CLEAR ENDP
END A10MAIN
15.6要点
在文本方式下，鼠标指针为反相显示的闪烁方块；在图形方式下，指针为一个箭头。
鼠标操作使用INT 33H，功能码装在AX中。
执行的第一个鼠标操作应当是INT33H的功能0000H，它初始化鼠标驱动程序。
请求NT33H的功能01H显示鼠标指针，功能03H获得按键状态，功能04H获取指针位置，功能05H获取按键点击信息，功能06H获取释放键信息。
鼠标位置的水平和垂直坐标用像素值来表示。
15.7习题
15-1.解释术语：（a）mickey，（b）mickey 计数，（c）鼠标指针。
鼠标指针：在文本方式下，指针是一个反相显示的闪烁的方块；在图形方式下，指针是一个箭头。
Mickcy：测量鼠标移动的单位，约等于1/200英寸。
Mickey计数：鼠标球横向或纵向滚动的mickey的数量。鼠标驱动器用mickey来计算指针在屏幕上移动的像素数。
15-2.为下列每个鼠标操作提供INT33H功能：
（a）隐蔽鼠标指针  MOV AX,0002H
（b）获取按键点击信息 MOV AX,0005H
（c）设置指针位置 MOV AX,0004H
（d）安装鼠标事件中断处理程序 MOV AX,000CH
（e）获取释放键信息 MOV AX,0006H
（f）读取鼠标移动计数器 MOV AX,000BH
功能00H：初始化鼠标。这是一个程序为处理一个鼠标并只需执行一次的第一个命令。
功能00H装入AX，不带其他的输入参数，然后执行INT 33H。此操作返回这些值：
AX=0000H，如果没有可用的鼠标支持程序；或AX=FFFFH，如果支持程序是可用的
BX=鼠标按键的数量，如果支持程序是可用的
如果鼠标支持程序是可用的，该操作初始化鼠标的步骤如下：
设置鼠标指针到屏幕中央
如果鼠标指针是可见的，则隐蔽鼠标指针
设置鼠标指针的显示页为零
根据屏幕显示方式设置鼠标指针：文本方式为矩形及反相彩色，图形方式为箭头
设置mickey与像素的比率，水平比率=8：8，垂直比率=16：8
设置指针的水平和垂直界限的最小值和最大值
设置倍速阀值为每秒64mickeys，该值可以改变。
功能01H：显示鼠标指针。这个操作在功能00H后使用，它使鼠标指针显示在屏幕上。
这个操作不需要输入参数，也没有返回值。
鼠标驱动器保存一个指针标志以确定是否显示指针。如果标志是0则显示指针，是其他值则隐蔽指针。
这个值初始化为-1，功能01H递增这个标志为0，这样指针就被显示。（参见功能02H。）
功能02H：隐蔽鼠标指针。标准的做法是在程序执行的最后调用这个功能以隐蔽指针。
这个操作不需要输入参数，也不返回任何值。
当指针标志包含一个0时显示指针，当为其他值时隐蔽指针。这个功能递减指针标志从0到-1，使指针被隐蔽。
功能03H：获取按键状态和指针位置。这个功能不需要输入参数，返回有关鼠标的信息如下：
BX=按键的状态，根据位的位置确定如下：
Bit0 左键（0=未按，1=按下）
Bit1 右键（0=未按，1=按下）
Bit2 中键（0=未按，1=按下）
Bit 3至15为保留内部使用
CX=水平（x）坐标
DX=垂直（y）坐标
水平和垂直坐标在像素项中表示，即使在文本方式下也这样（显示方式03为每字节8个像素）。
这些值通常在指针的最小值和最大值界限之内。
功能04H：设置指针位置。这个操作设置鼠标在屏幕上的水平和垂直坐标
（位置的值在像素项中一对显示方式03为每字节8个像素）：
MOV AX,0004H   ;请求设置鼠标指针
MOV CX,horizontal   ;水平位置
MOV DX,vertical   ;垂直位置
INT 33H   ;调用鼠标驱动程序
如果指针超出了最小和最大的界限，此操作会做出必要的调整，在新位置设置指针。
功能05H：获取点击按键信息。这个功能返回点击按键的信息。设置BX为按键编号，
0=左键，1=右键，2=中键：
MOV AX,0005H
MOV BX,button_no   ;按键号
INT 33H   ;调用鼠标驱动程序
这个操作返回按键的未按/按下的状态、点击次数和所请求按键的位置：
AX=按键的状态，根据位的位置确定键，如下：
Bit0 左键（0=未按，1=按下）
Bit1 右键（0=未按，1=按下）
Bit2 中键（0=未按，1=按下）
Bit3-15保留内部使用
BX=点击按键计数器
CX=最后一次点击的水平（x）坐标（像素值）
DX=最后一次点击的垂直（y）坐标（像素值）
该操作重置点击按键计数器为0。
功能06H：获取释放键信息。这个功能返回按键释放的信息。设置BX按键号
（0=左键，1=右键，2=中键）：
MOV AX,0006H   ;请求释放键信息
MOV BX,button_no   ;按键号
INT 33H   ;调用鼠标驱动程序
这个操作返回所有按键的未按/按下的状态、释放次数和所请求的按键的位置：
AX=按键的状态，根据位的位置确定键，如下：
Bit0 左键（0=未按，1=按下）
Bit1 右键（0=未按，1=按下）
Bit2 中键（0=未按，1=按下）
Bit3-15保留内部使用
BX=释放键计数器
CX=最后一次释放键的水平（x）坐标（像素值）
DX=最后一次释放键的垂直（y）坐标（像素值）
操作重置释放键计数器为0。
功能07H：设置指针水平界限。这个操作设置指针的最小和最大的水平界限（像素值）：
MOV AX,0007H   ;请求设置水平界限
MOV CX,minimum   ;最小界限
MOV DX,maximum   ;最大界限
INT 33H   ;调用鼠标驱动程序
如果最小值大于最大值，该操作随意交换这两个值。
如果指针超出了定义的区域，该操作把它移回到区域内。参见功能08H和10H。
功能08H：设置指针垂直界限。这个操作设置指针的最小和最大的垂直界限（像素值）：
MOV AX,0008H   ;请求设置垂直界限
MOV CX,minimum   ;最小界限
MOV DX,maximum   ;最大界限
INT 33H   ;调用鼠标驱动程序
如果最小值大于最大值，该操作任意交换这两个值。如果指针超出了定义区域，该操作把它移回到区域内。参见功能07H和10H。
功能0BH：读取鼠标移动计数器。这个操作返回自最后一次请求这个功能以来的水平和垂直的mickey数
（在-32768到+32767范围内）。返回值是：
CX=水平计数（一个正值表示移动到右边，负值表示移动到左边）
DX=垂直计数（一个正值表示向下移动，负值表示向上移动）
功能0CH：安装鼠标事件的中断处理程序。程序可能需要在鼠标发生关联的动作（或事件）时自动响应。
功能0CH的目的是提供一个事件处理程序，借此鼠标软件来中断程序并调用事件处理程序，
执行它所请求的功能并在完成任务的时候返回到程序的执行点（断点）。
CX装入一个事件屏蔽码，以指出处理程序响应哪一种事件，ES:DX装入中断处理程序的段地址：偏移地址：
MOV AX,000CH   ;请求中断处理程序
MOV CX,mask   ;事件屏蔽码
LEA DX,handler   ;处理程序地址（ES:DX）
CX    event mask (events which you want sent to your handler)
bit 0 = mouse movement           (CX | 01H)
bit 1 = left button pressed      (CX | 02H)
bit 2 = left button released     (CX | 04H)
bit 3 = right button pressed     (CX | 08H)
bit 4 = right button released    (CX | 10H)
bit 5 = center button pressed    (CX | 20H)
bit 6 = center button released   (CX | 40H)
All events:      CX = 007fH
Disable handler: CX = 0000H
ES:DX address of your event handler code
定义事件屏蔽码的各位设置要求如下：
0=移动的鼠标指针   4=释放右键
1=点击左键   5=点击中键
2=释放左键   6=释放中键
3=点击右键   7-15=保留，定义为0
定义中断处理程序为一个FAR过程。鼠标驱动程序使用一个远程调用进入中断处理程序，并设置如下寄存器：
AX=定义的事件屏蔽码，只有在条件发生时才设置的那些位
BX=按键状态（如果已设置，位0代表左键按下，位1代表右键按下，位2代表中键按下）
CX=水平坐标（x）
DX=垂直坐标（y）
SI=最后的垂直mickey数
DI=最后的水平mickey数
DS=鼠标驱动程序的数据段
在进入中断处理程序的入口处，把所有的寄存器都入栈保存，并将DS初始化为数据段的地址。
在处理程序中，只能使用BIOS中断，而不能用DOS中断。退出时，所有寄存器都出栈。
功能10H：设置指针禁止区域。这个操作定义了一个不显示指针的屏幕区域：
MOV AX,0010H：请求设置禁区
MOV CX,upleft_x   ;左上角x坐标
MOV DX,upleft_y   ;左上角y坐标
MOV SI,lowright_x   ;右下角x坐标
MOV DI,lowright_y   ;右下角y坐标
INT 33H   ;调用鼠标驱动程序
用不同的参数重新调用这个函数，或新调用函数00H或01H来替换禁区。
功能13H：设置倍速阈值。这个操作设置阀值速度，指针以双倍于它的速度在屏幕上移动。
在DX中装入新的值（默认值是每秒64mickey）。（参见功能1AH）
功能1AH：设置鼠标灵敏度。灵敏度与指针移动之前鼠标必须移动的mickey数有关。
这个功能按照每8个像素的mickey数来设置水平的和垂直的鼠标移动量，以及使指针以双倍的速度在屏幕上移动的阀值速度，
（参见功能0FH，13H和1BH）：
MOV AX,001AH   ;请求设置鼠标灵敏度
MOV BX,horizontal   ;水平mickey数（默认值=8）
MOV CX,Vertical   ;垂真mickey数（默认值=16）
MOV DX,threshold   ;阀值速度（默认值=64）
INT 33H   ;调用鼠标驱动程序
功能1BH：获取鼠标灵敏度。这个操作根据每8个像素的mickey数来返回水平的和垂直的鼠标移动量，以及阀值速度，
指针在屏幕上以其双倍的速度来移动。（参见功能1AH，返回的寄存器及相应值）
功能1DH：选择指针的显示页。视频显示页用INT 10H的功能05H设置。
对于鼠标操作，在BX中设置页号，并调用这个函数。
功能1EH：获取指针的显示页。这个操作在BX中返回当前的视频显示页。
功能24H：获取鼠标信息。这个操作返回有关已安装鼠标的版本和类型信息：
BH=主版本号
BL=子版本号
CH=鼠标类型（1=总线鼠标，2=串口鼠标）
15-3.解释鼠标指针标志的用途。
鼠标驱动器保存一个指针标志以确定是否显示指针。如果标志是0则显示指针，是其他值则隐蔽指针。
这个值初始化为-1，功能01H递增这个标志为0，这样指针就被显示。
功能02H递减指针标志从0到-1，使指针被隐蔽。
15-4.按下列要求编写指令：
（a）初始化鼠标 MOV AX,0000H
（b）显示鼠标指针 MOV AX,0001H
（c）获取鼠标信息 MOV AX,0024H
（d）在中间一列的第22行设置鼠标指针 MOV AX,0004H
（e）获取鼠标灵敏度 MOV AX,001BH
（f）获取按键状态和指针位置 MOV AX,0003H
（g）隐蔽鼠标指针 MOV AX,0002H
15-5.结合问题15-4中的要求，编写完整的程序。并在DEBUG下运行程序，虽然有时DEBUG会使指针滚动出屏幕。
.MODEL SMALL
.STACK 512
.DATA
LEN_DATA EQU 14
XCOORD DW 0
YCOORD DW 0
ASCVAL DW ?
DISPDATA LABEL BYTE
XMSG DB 'X = '
XASCII DW ?
DB 20H,20H
YMSG DB 'Y = '
YASCII DW ?
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
CALL Q10CLEAR
CALL B10INITZ
CMP AX,0000H
JE A90
A20:CALL C10POINTR
CMP BX,0001H
JE A80
MOV AX,XCOORD
CALL D10CONVRT
MOV AX,ASCVAL
MOV XASCII,AX
MOV AX,YCOORD
CALL D10CONVRT
MOV AX,ASCVAL
MOV YASCII,AX
CALL E10DISPLY
JMP A20
A80:MOV AX,0002H
INT 33H
A90:CALL Q10CLEAR
MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10INITZ PROC NEAR
MOV AX,0000H
INT 33H
CMP AX,0000H
JE B90
MOV AX,0001H
INT 33H
MOV AX,0004H
MOV CX,288
MOV DX,176
INT 33H
B90:RET
B10INITZ ENDP
C10POINTR PROC NEAR
C20:MOV AX,0003H
INT 33H
CMP BX,00000001B
JE C90
SHR CX,1
SHR CX,1
SHR CX,1
SHR DX,1
SHR DX,1
SHR DX,1
CMP CX,XCOORD
JNE C30
CMP DX,YCOORD
JE C20
C30:MOV XCOORD,CX
MOV YCOORD,DX
C90:RET
C10POINTR ENDP
D10CONVRT PROC NEAR
MOV WORD PTR ASCVAL,2020H
MOV CX,10
LEA SI,ASCVAL+1
CMP AX,CX
JB D20
DIV CL
OR AH,30H
MOV DS:[SI],AH
DEC SI
D20:OR AL,30H
MOV DS:[SI],AL
RET
D10CONVRT ENDP
E10DISPLY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,1300H
MOV BX,0031H
LEA BP,DISPDATA
MOV CX,LEN_DATA
MOV DX,0020H
INT 10H
POP DX
POP CX
POP BX
POP AX
RET 
E10DISPLY ENDP
Q10CLEAR PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,0600H
MOV BH,30H
MOV CX,0000H
MOV DX,184FH
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
Q10CLEAR ENDP
END A10MAIN
15-6.编写指令，设置指针禁区为（a）左上角：x=40，y=40，（b）右下角：x=160，y=80。
MOV AX,0010H   ;请求设置禁区
MOV CX,40   ;左上角x坐标
MOV DX,40   ;左上角y坐标
MOV SI,160   ;右下角x坐标
MOV DI,80   ;右下角y坐标
INT 33H   ;调用鼠标驱动程序
第16章磁盘存储I：组织方式
16.1引言
16.2磁盘存储设备的特征
16.3磁盘系统区和数据区
16.4引导记录
16.5日录
16.6文件分配表
16.7处理磁盘文件
16.8重点
16.9习题
目的：分析硬盘及软盘存储的基本格式、引导记录、目录和文件分配表。
16.1引言
一个专业的程序员必须熟悉磁盘组织的技术细节，特别是在开发检测软盘、硬盘和CD-ROM内容的实用程序时尤其如此。
本章解释了磁道、扇区和柱面的概念，并且给出了一些常用设备的容量，还介绍了磁盘起始区中的重要数据记录的组织，
包括引导记录（帮助把操作系统从磁盘装入到内存）、目录（包含了文件名、位置和每个文件在磁盘上的状态）和
文件分配表（或FAT，为文件分配磁盘空间）。
本文在需要提及硬磁盘和软磁盘的地方都使用通用术语磁盘。
16.2磁盘存储设备的特征
为了处理磁盘上的记录，必须熟悉一些术语和磁盘组织的特征。
一个软磁盘有两面（或表面），而硬盘在一个轴上包含有许多双面磁盘。
16.2.1磁道和扇区
硬磁盘或软磁盘的每面都包含许多同心的磁道，从最外面的磁道以00开始编号，
每个磁道格式化为512字节的可以存储数据的扇区。
软磁盘和硬磁盘设备都由一个控制器控制运转，控制器处理读写头在磁盘表面上的位置，以及在磁盘与存储器之间的数据传输。
每个磁盘表面都有一个读写头。对于软磁盘和硬磁盘，一个读或写操作的请求都会导致磁盘驱动控制器把读写头（如必要的话）
移动到所要求的磁道上。然后控制器等待旋转面上所要求的扇区到达读写头下面，这时发生读或写操作。
例如，对于一次读操作，当扇区经过读写头时，控制器就读取扇区上的每一位。
图16-1说明了这些特征。硬盘和软盘驱动器主要在两点上不同。对于硬盘，读写头正好悬在磁盘表面上，不总是与盘面接触，
而对于软盘，读写头实际上一直接触着盘面。另外硬盘设备总在旋转，而软磁盘设备在每次读/写操作时都要启动和停止。
16.2.2柱面
柱面是每个软盘或硬盘表面上同一编号的磁道在垂直方向上的集合。
因此柱面0就是每个盘面上所有编号为0的磁道的集合，柱面1是所有编号为1的磁道的集合，依此类推。
对于一个软盘来说，柱面0由盘面1的磁道0和盘面2的磁道0组成；柱面1由盘面1的磁道1和盘面2的磁道1组成；
依此类推。盘面的编号和读写头的编号是相同的，例如，读写头1访问盘面1上的数据。
当写文件时，控制器在一个柱面的所有磁道上填写，然后把读写头前移到下个柱面。
例如，系统填写软盘柱面0（盘面1和盘面2上磁道0的所有扇区），然后前移到盘面1的柱面1上。
可见对盘面（读写头）、磁道和扇区的定位都是通过编号来进行的，盘面和磁道从0开始编号，
但是扇区可能用下面两种方法之来编号：
1.物理分区法，每个磁道上的扇区从1开始编号，这样磁盘上的第一个扇区就编址为柱面0，读写头/盘面0，扇区1，
下一个扇区编址为柱而0，磁头/盘面0，扇区2，依此类推。
2.相对分区法，扇区是相对于磁盘的起始位置来编号的，所以磁盘上在柱面0、轨道0上的第1个扇区被编址为相对扇区0，
下一个为相对扇区1，直到磁盘的最后一个扇区。
不同的磁盘操作可能使用不同的方法，这取决于执行何种访问方式。
16.2.3磁盘控制器
位于处理器和磁盘驱动器之间的磁盘控制器处理它们之间所有的通信。控制器接收来自处理器的数据并转换成驱动器可用的格式。
例如，处理器会发出一个请求，数据来自一个指定的柱面一头一扇区。
控制器的任务是提供一个适当的命令去移动取数臂到所要求的柱面，选择读写头，并当数据到达读写头后从扇区接收数据。
当控制器工作时，处理器对其他任务而言是空闲的。在这种方式下；控制器一次只处理一位。
然而，控制器也可以执行更快的I/O，这时数据完全不通过处理器，直接和存储器传输数据，
这种传输大量数据的方式称为直接存储器存取（DMA）。
为了这个目的，处理器给控制器提供读或写的命令、存储器中I/O缓冲区的地址、要传输数据的扇区号、柱面号、磁头以及
起始扇区。用这种方法，处理器必须等待直到DMA完成，因为同时间只能有一个部件使用存储器通道。
有两个因素影响数据传输速率，即磁盘驱动器传递数据到计算机的速度：存取时间和旋转速率。
1.存取（或寻找）时间与磁头到达所要求的柱面/磁道的移动速度有关。
对于顺序处理，读写头最多移动一个柱面；对于随机处理，读写头可以移动多个柱面。
2.旋转速率决定了所要求的扇区到达磁头的时间以及从扇区传输数据到计算机存储器的时间。
当然这个操作的平均时间有一半是在旋转，这被认为是等待时间。
对于旋转速率为6000rpm的情况，每秒的速度是6000/60=100转数。旋转一周需要1/100秒，相当于10毫秒，
因此等待时间为5毫秒。
16.2.4簇
簇是一组扇区，系统将簇当作存储空间的单位。一个簇的大小总是2的乘方，比如1，2，4或8个扇区。
对于支持每簇一个扇区的软盘驱动器，扇区和簇是一样的。每簇两个扇区的磁盘组织如下：
sector,sector   sector,sector   sector,sector
每簇4个扇区的磁盘组织如下：
sector,sector,sector,sector   sector,sector,sector,sector
硬盘驱动器可以被分成几个分区，每个分区通过驱动器号来识别，第一个分区是C。
硬盘上的FAT（文件分配表）有两种类型，FAT16和FAT32，根据以下规则来确定一个硬盘簇的大小：
FAT16                                             FAT32
分区         簇大小         扇区数         分区         簇大小         扇区数
<128MB   2KB            4          260MB-8GB   4KB              8
128-255MB   4KB       8          8GB-16GB      8KB            16
256-511MB   8KB      16         166B-32GB   16KB            32
512-1023MB  16KB   32         大于32GB      32KB            64
1024-2047MB 32KB  64
一个文件开始于一个簇的边界，并至少需要一簇，即使文件只占用了其中的一个扇区。
一个400字节的文件（足够小，可以放在一个扇区中）存储在每簇64扇区的磁盘，占用了64×512=32768字节的存储量，
尽管实际上只有一个扇区含有数据。未使用的（和目前不可使用的）磁盘空间被认为是分散的。
对于每个文件，FAT按升序存储它的簇，尽管文件可能会被分成碎片保存，例如，分别在簇8，9，10，14，17和18中保存。
一个簇也可以从一个磁道交迭到另一个磁道。
磁盘容量。这里是两种3.5''磁盘的存储容量：
存储容量         磁道数/面（柱面）         扇区数/道         字节数/扇区         双面总字节         扇区/簇
720KB                  80                              9                           512                  737280              2
1.44MB                80                             18                          512                 1474560             1
对于硬盘，容量通常随着驱动器和分区变化。确定柱面、每个磁道的扇区数或读写头等一些很有用的操作，
包括INT 21H功能1FH和440DH的子功能60H，这些都会在第18章中介绍。
16.3磁盘系统区和数据区
保留某些扇区的目的是为了提供磁盘上有关文件的信息。软盘和硬盘的组织因它们的容量而不同。
硬盘和一些软盘格式化为自引导的―也就是说，它们在接通电源或者用户按下了Ctrl+Alt+Del键时可以自行启动。
磁盘的组织一般由系统区以及紧接着的数据区组成，磁盘其余的空间都是数据区。
16.3.1系统区
系统区是磁盘上的第一个区，从最外面的磁道开始，即0面，0磁道，1扇区。系统区存放系统存储和维护的信息，
例如每个文件存储在磁盘上的起始位置等。系统区的3个组成部分是（1）引导记录，（2）文件分配表（FAT），（3）目录。
系统区和数据区的组织如下：
引导记录,FAT,目录         系统文件,用户文件...
系统区                           数据区
下面的表给出了3.5''磁盘设备的组织结构，说明了引导记录、FAT和目录的开始和结束的扇区号。
扇区由相对扇区号识别，相对扇区0就是柱面0，轨道0，扇区1，也就是设备上的第一个扇区（早先在“柱面”那一节解释过）：
设备         引导记录         FAT         目录         扇区数/簇
720KB         0                 1-6            7-13           2
1.44MB       0                 1-18        19-32           1
对于硬盘来说，引导记录和FAT的位置通常和软盘的一样，而FAT的大小和目录的位置是随着设备不同而变化的。
一张格式化的软盘包含以下信息（按照起始的物理和相对扇区）：
720K（9扇区/磁道）                                                      1.44MB（18扇区/磁道）
文件         柱面         盘面         扇区         相对扇区         柱面         盘面         扇区         相对扇区
引导记录      0            0            1                  0                  0               0              1               0
FAT1           0            0            2                  1                  0               0              2               1
FAT2           0            0            5                  4                  0               0              11              10
目录             0            0            8                 7                  0               1              2               19
数据区         0            1            6                  14                0               1              16              33
在720K软盘上的数据文件开始于柱面0、盘面1、扇区6-9。
系统存储下一个记录就在柱面1、盘面0，然后在柱面1、盘面1，接着在柱面2、盘面0，以此类推。
在前移到下一个柱面之前，在相对的两个盘面上填写数据的特性减少了磁盘读写头的移动，这种方法既用于软盘也用于硬盘。
16.3.2数据区
在可引导磁盘或软盘的数据区以IO.SYS和MSDOS.SYS两个系统文件开始。
当用FORMAT /S格式化磁盘时，DOS就把它的系统文件复制到数据区的第一个扇区。
用户文件紧跟着系统文件，或者在没有系统文件的情况下从数据区的起始位置开始。
下一节解释引导记录、目录和FAT。
16.4引导记录
引导记录包含了把系统文件（如果存在）从磁盘载入（或“导入”）存储器的指令。
所有格式化的磁盘都包含一个引导记录，即使系统文件没有存储在磁盘上。引导记录包含了下面以偏移地址为序的信息：
00H   跳转到引导记录中偏移地址为3EH的自引导程序
03H   创建引导程序时的名字或DOS版本号
0BH   每扇区的字节数，通常为200H（512）
0DH   每簇的扇区数（1、2、4或8）
0EH   保留的扇区数
10H   FAT的备份数（1或2）
11H   根目录的入口数
13H   容量小于32MB的磁盘扇区数
15H   媒体描述符字节（和FAT的第一个字节相同，以后会解释）
16H   FAT的扇区数
18H   每个磁道的扇区数
1AH   读写头数（盘面或盘表面）
1CH   隐藏扇区数
1EH   系统保留
20H   扇区总数，如果容量大于32MB
24H   物理驱动器数（软盘：A=0；硬盘：80H=驱动器C，等等）
25H   系统保留
26H   扩展引导扇区标记（包含29H）
27H   卷ID
2BH   卷标
36H   系统保留
3EH-1FFH   自引导程序的超始地点
16.5目录
磁盘上的所有文件从一个簇的边界开始，也就是这个簇的第一个扇区。对于每一个文件，
系统建立了个32字节（20H）的目录项来描述文件的名字、创建日期、文件大小以及文件起始簇的位置。目录项的格式如下：
字节                  目的
00H-07H         文件名，在创建文件的程序中定义。第一个字节也可以表明文件的状态：
                           00H文件从未使用过
                           05H文件名的第一个字符实际上是E5H
                           2EH文件是个子目录
                           E5H文件已被删除
08H-0AH         文件扩展名，例如EXE或ASM
0BH                  文件属性，定义文件类型（注意，一个文件可以有多个属性）：
                           00H正常属性文件
                           01H只能被读出的文件（只读文件）
                           02H隐藏文件，目录搜索不显示
                           04H系统文件，目录搜索不显示
                           08H卷标（如果这是个卷标记录，标签本身也在文件名和扩展名的字段中）
                           10H子目录
                           20H存档文件，表明从最后一次更新后文件是否修改过。
                           （例如，代码07H说明系统文件（04H）是只读的（01H）和隐藏的（02H）。）
0CH-15H      系统保留
16H-17H      时间，文件创建或最后一次修改的时间：以二进制格式存储16位，如hhhhhmmmmmmsssss。
18H-19H      日期，文件创建或最后一次修改的日期，以二进制格式存储16位，如yyyyyyymmmmddddd。
                     年为000-119（1980作为起始点），月为01-12，日为01-31。
1AH-1BH      文件起始簇。其编号与目录的最后两个扇区有关。如果没有系统文件，第一个数据文件从相对簇002开始。
                     实际的盘面、磁道和簇取决于磁盘容量。一个为零的项说明文件没有给它空间分配。
                     文件大小，以字节计数。写文件后，系统计算并保存文件的大小
1CH-1FH      在这个字段中。
对于在目录中超过一个字节的数字字段，数据按字节以反序存储。
16.6文件分配表
FAT的目的是为文件分配磁盘空间。FAT包含有磁盘上每个簇的入口项。当创建一个新文件或修改一个已存在的文件时，
系统根据磁盘上文件的位置修改相关的FAT入口项。FAT开始于扇区2，紧接着是引导记录。
对一个簇由4个扇区组成的磁盘，相同编号的FAT入口可以访问4次，这和一簇一个扇区的磁盘的数据量一样。
因此，使用多扇区的簇减少了FAT的入口数，并且能使系统访问一个更大的磁盘存储空间。
最初的设计者提供了FAT的两个拷贝（FAT1和FAT2），大概是因为若FAT1被破坏可以使用FAT2。
但是，虽然仍保留着FAT2，但它却从未起作用。前面“磁盘系统区和数据区”一节在FAT存储要求中包括了FAT1和FAT2。
本书中其他所有讨论都涉及到FAT1。
16.6.1FAT的第一个人口项
FAT的第一个字节为媒体描述符，它指出设备类型（类似于引导记录中的字节15H）如下：
F0H 3.5''，双面，18扇区/磁道（1.44MB）和3.5''，双面，36扇区/磁道（2.88MB）
F8H 硬盘（包括RAM磁盘）
F9H 3.5''，双面，9扇区/磁道（720KB）和5.25''，双面，15扇区/磁道（1.2MB）
注意，F0H和F9H分别指定了两种不同的磁盘格式。
16.6.2FAT的第二个入口项
对于支持12位FAT入口的软盘FAT，第二个入口项含有FFFFH；对于支持16位FAT入口的硬盘，第二个入口项含有FFFFFFH。
头两个入口项如下：
1.44MB diskette F0 FF FF......
Hard disk            F8 FF FF FF......
正如已经描述过的，磁盘的第一个字段是引导记录，紧跟的是FAT和目录，接着就是数据区。入口项图示如下：
簇0,簇1                  簇2,簇3,...,簇n
目录区                  数据区
你可能希望数据区就在簇的起始点，然而，头两个簇（0和1）指向了目录，这样存储数据文件的数据区就起始于簇2。
16.6.3FAT的指针入口项
在头两个FAT入口项之后的是指针入口项，它涉及到数据区的每个簇。目录（在1AH-1BH）包含文件第一个簇的位置，
并且FAT包含了每个后继簇的指针入口链。
软盘的入口项长度是3位十六进制数（1+1/2字节，或12位），对于硬盘是4位十六进制数（两字节，或16位）。
Windows也提供了32位的FAT入口项。每个FAT指针入口项根据以下格式指出特定簇的用法：
12位         16位         说明
000         0000         基准簇目前未使用
nnn         nnnn         与文件下一簇相关的簇号
FF0-FF6   FFF0-FFF6   保留簇
FF7         FFF7         不能用（坏磁道）
FFF         FFFF         文件最后一簇
对于1.44MB软盘（12位FAT）的前两个入口项包含F0F和FFF，分别表示簇0和簇1：
FAT入口项         F0F   FFF......
相对簇                  0   1         2         3         4          5         6......End
开始的F0表示双面、9扇区（1.44MB）的软盘，随后是FFFFH。术语“相对簇”的含义是，
例如，FAT的第三个指针入口项指向相对簇2，第四个入口项指向相对簇3，依此类推。
在某种意义上，前两个FAT入口项（相对簇0和1）指向目录的最后两个簇，它们已经被分配在簇的开始，
目录指出文件的大小和起始簇。
目录包含每个文件的起始簇号以及指向下一簇位置的FAT指针入口链，正因为有指针链，才使文件得以连续。
含有（F）FFFH的指针入口项表示为文件的最后一簇。
FAT入口项举例。以下的例子应该能帮助阐明FAT的结构。假设磁盘只包含一个文件，名字叫TEMPSTAT.FIL，
它全部存储在簇2、3和4。这个文件的目录入口项包含文件名TEMPSTAT，扩展名FIL，00H表明是个正常属性文件，
创建日期，0002H是文件第一个相对簇的位置，以及表示文件字节大小的入口项。
12位的FAT入口项表示如下，除了有一对字节应当是反序的：
FAT入口项         F0F   FFF   003      004      FFF
相对簇                  0   1         2         3         4          5         6......End
一个程序把TEMPSTAT.FIL连续地从磁盘读到存储器，系统按以下步骤执行：
对于第一簇，搜索磁盘目录寻找文件名为TEMPSTAT、扩展名为FIL的文件，
从目录获取文件的第一个相对簇（2）的位置，并且传递其内容（来自扇区的数据）到主存储器中的程序。
对于下一簇，访问用相对簇2表示的FAT指针入口项。从上图可知，这个入口项包含003，这说明文件在相对簇3上继续。
系统传递这一簇的内容到程序。
对于最后一簇，访问用相对簇3表示的FAT指针入口项。这个入口项包含004，说明文件在相对簇4上继续。
系统传递这个簇上的内容到程序。
相对簇4的FAT入口项包含FFFH，指出没有簇分配给文件了。系统现在从簇2、3和4上传递了所有文件的数据。
我们已经了解了FAT入口项工作的原理，现在再看它们如何以反序字节来工作的，这里需要一点灵活性。
16.6.4处理12位FAT人口项
下面是与刚才介绍过的TEMPSTAT.FIL相同的一个例子，不过现在使用的是反序字节的指针入口项。这个文件的12位FAT如下：
FAT入口项：F0F FFF 034 000 FF0 Fxx
相对簇           0    1     2     3     4    5
但是现在需要辨识这些入口项，因为它们是根据相对字节而不是簇来表示的：
FAT入口项：F0 FF FF 03 40 00 FF 0F...
相对字节       0   1   2   3   4   5   6   7
下面是访问簇的步骤：
为了处理第一个FAT入口项，2（文件的第一个簇记录在目录中）乘1.5（FAT入口项的长度）得到3。
（程序中乘3并右移一位。）存取FAT中字节3和4中的字。这两个字节包含03 40，反序时是4003。
因为簇2是个偶数，使用后3位数字，所以003是文件的第二簇。
对于第三簇，簇号3乘1.5得4。存取FAT中的字节4和5。这些字节包含4000，当反序时为0040。
因为簇3为一个奇数，使用前3位数字，所以004是文件的第三簇。
对于第四簇，簇4乘1.5得6。存取FAT中的字节6和7。这些字节包含FF 0F，当反序时，是0FFF。因为簇4是一个偶数，
使用后3位数字FFF，它说明这是最后的入口项。
16.6.5处理16位的FAT人口项
先前已经提到，硬盘FAT的第一个字节包含有媒体描述符。这个字节之后是FFFFFFH，正如下表中所表示的。
FAT指针入口项是16位字长，并且开始于字3和字4，它表示为簇2。
目录入口项提供了文件的起始簇。虽然每个入口项的字节是反序排列的，从每个FAT入口项确定的簇号是简单的。
作为一个16位FAT入口项的例子，假设一个指定硬盘上唯一的一个文件占用了4个簇（每簇4个扇区，总共16个扇区）。
根据目录知道，文件从簇2开始。每个FAT指针入口项是一个完整的字，所以反序的字节只包括一个入口项。
这里是指针入口项以反序字节排列的FAT：
FAT入口项：F8 FF FF FF 03 00 04 00 05 00 FFFF...
相对簇：       0        1       2       3         4       5
相对簇2的FAT入口项为0300，反序后为下一个簇0003。相对簇3的FAT入口项为0400，反序后是下个簇0004。
用保留的入口链这种方式继续直到5号簇。指针入口项FFFFH指向文件尾。32位入口项的FAT使用反序字节排列的双字。
如果程序要确定安装的磁盘类型，它可以直接检查引导扇区的媒体描述符或使用INT 21H的功能36H。
16.6.6练习：检测FAT
让我们使用DEBUG来检测磁盘FAT。这个练习需要一张容量为1.44MB的格式化了的空白3.5”软盘，而且上面没有拷贝系统文件。
复制两个文件到磁盘上，第一个文件要大于512字节、小于1024字节，以占用2个扇区，建议用A04ASM1.ASM。
第二个文件要大于1536字节且小于2048字节，以占用4个扇区，建议用A09DRVID.ASM。
由于文件从偏移地址100H开始存储，因此可以用下列方法定位记录：
1.引导记录在起始地址100H。
2.FAT在引导记录扇区之后：100H+200H（1扇区，512或200H字节）=300H。
3.目录在FAT之后：300H+[18（12H）扇区×200H]=2700H
首先把软盘插入驱动器A。装入DEBUG并键入L（load）命令（附录E有更完全的解释）：
L 100 0 0 30（对于驱动器B，使用L 100 1 0 30）
L命令的入口项是：
100H是DEBUG段的起始偏移地址，数据将从这里读入。
第一个0意味着使用驱动器A。
第二个0意味着从相对扇区0开始读数据。
30表示从30H（48）扇区读取数据。
键入命令D 100开始显示。现在可以检测磁盘的引导记录、目录和FAT。
引导记录。引导记录的一些字段为：
段偏移地址103H中是建立FAT时的DOS版本。
偏移地址10BH中是每扇区的字节数（0002H反序字节为0200H，或512字节）。
偏移地址115H是该磁盘的媒体描述符F0H。再检验其他字段。
目录。检测目录，键入命令D 2700：
在偏移地址2700H包含第一个文件的文件名，A04ASM1.ASM。
在偏移地址271AH中给出这个文件的起始簇号（0200或0002）。
在偏移地址271CH-271FH中给出文件的大小（27030000或327H字节）。
偏移地址2720H开始是第二个文件A10DRVID.ASM的入口项。注意，273AH显示了它的起始簇为0400或0004。
文件大小为673H字节。
3.FAT。检测FAT，键入命令D 300，将显示：
FAT入口：F0 FF FF 03 F0 FF 05 60 00 07 F0 FF...
相对字节：0   1   2   3   4   5   6   7   8   9  10  11
F0是媒体描述符。
字节1和字节2中的FFFF是第二个字段的内容。
从字节3开始的指针入口项可以分析如下：
对于第一个文件，2（根据目录得知它的第一簇）乘1.5得到相应字节3。访问FAT的偏移字节3和4，它包含03F0，
取反序字节得到F003。因为簇2是个偶数，使用最后3位数字003，这是系列中的下一簇。
簇3×1.5是4，相应字节4和5包含F0FF，取反序字节为FF F0。因为簇3是个奇数，使用头3个数字FFF，这表示文件结束。
这样就知道文件驻留在簇2和簇3中了。
对于第二个文件，第一簇是4：
簇                  FAT偏移         FAT值         
4*1.5=6        6,7                   60 05         偶         005
5*1.5=7        7,8                   00 60         奇         006
6*1.5=9        9,10                 F0 07         偶         007
7*1.5=10      10,11               FF F0         奇          FFF
FFF表示数据结束。
INT 21H给程序提供了一些支持服务例程以访问目录和FAT的信息，包括功能47H（获取当前目录），有关说明在第18章。
16.7处理磁盘文件
数据以文件的形式存储在磁盘上，就像你已经存储的程序一样。虽然没有限制保存在文件中的数据的类型，
但是一个典型的用户文件由客户记录、库存供应或姓名地址表组成。每个记录包含了有关详细的客户信息或项目清单信息。
在文件里，所有记录通常（但不是必须）有相同的长度和格式。一个记录包含一个或多个提供有关记录信息的字段。
例如，对一个客户文件的记录，可以包含比如客户号，姓名，地址和应付款这些字段。记录按客户号升序排列。
处理硬盘上的文件和软盘上的文件大致相同，对于两者，你必须提供一个路径名来存取子目录中的文件。
有许多的特殊中断服务支持磁盘输入/输出。一个程序写（或建立）一个文件首先使系统在目录里生成一个入口项。
当所有文件的记录写完，程序关闭文件，这样系统就可以完成文件大小的目录入口项。
程序读一个文件首先要打开文件以确保它是存在的。一旦程序读完全部记录，应当关闭这个文件，使它对其他程序也是可用的。
由于目录的设计，你可以顺序处理（连续的一个记录接着一个记录）磁盘文件的记录，也可以随机处理
（在文件范围内按要求检索记录）磁盘文件的记录。
最高级磁盘处理是通过INT 21H，借助于目录和记录的“分块”、“解块”来支持磁盘处理。
这种方法在连接到BIOS之前执行了一些预备处理。第17章涉及到INT21H的写和读磁盘文件操作的用法。
第18章讨论了各种支持目录和磁盘文件的操作。
最低级磁盘处理是通过BIOS中断13H，其包括了磁道和扇区号的直接寻址，这将在第19章中讲到。
16.8重点
软盘或硬盘的每面都包含了许多同心的磁道，磁道号从00开始。每个磁道格式化为512字节的扇区，扇区号从1开始。
柱面是每个盘面上所有相同编号磁道的集合。
程序可以通过柱面-读写头或相对扇区号来定位一个扇区。
簇是一组扇区，系统把簇看作是存储空间的单位。簇的大小总是2的乘方，比如1、2、4或8扇区。
无论文件大小如何，所有文件都起始于一个簇的边界并且至少需要一个簇。
引导记录包含把系统文件从磁盘载入（或“导入”）到内存的指令。
目录包含磁盘上每个文件的入口项，并且指出文件名、扩展名、文件属性、时间、日期、起始扇区和文件大小。
文件分配表（FAT）用来为文件分配磁盘空间。FAT起始于扇区2，紧跟在引导记录之后，
并且为目录中的每个文件包含了每个簇的一个入口项。
16.9习题
16-1.一个标准扇区有多少字节？
一个扇区有512字节
16-2.什么是柱面？
一个软盘有两面，而硬盘在一个轴上包含有许多双面磁盘。
硬盘或软盘的每面都包含许多同心的磁道，从最外面的磁道以00开始编号。
柱面是每个软盘或硬盘表面上同一编号的磁道在垂直方向上的集合。
因此柱面0就是每个盘面上所有编号为0的磁道的集合，柱面1是所有编号为1的磁道的集合，依此类推。
16-3.磁盘控制器的用途是什么？
磁盘控制器处理CPU和磁盘驱动器之间所有的通信。控制器接收来自处理器的数据并转换成驱动器可用的格式。
控制器处理读写头在磁盘表面上的位置，以及在磁盘与存储器之间的数据传输。
16-4.（a）什么是簇？（）簇的用途是什么？（c）每簇大小分别为1、2、4或8扇区的磁盘空间（以字节为单位）是多少？
簇是一组扇区，系统将簇当作存储空间的单位。一个簇的大小总是2的乘方，比如1，2，4或8个扇区。
两种软盘的存储容量：
存储容量         磁道数/面（柱面）         扇区数/道         字节数/扇区         双面总字节         扇区/簇
720KB                  80                              9                           512                  737280              2
1.44MB                80                             18                          512                 1474560             1
硬盘上的FAT（文件分配表）有两种类型，FAT16和FAT32，根据以下规则来确定一个硬盘簇的大小：
FAT16                                             FAT32
分区         簇大小         扇区数         分区         簇大小         扇区数
<128MB   2KB            4          260MB-8GB   4KB              8
128-255MB   4KB       8          8GB-16GB      8KB            16
256-511MB   8KB      16         166B-32GB   16KB            32
512-1023MB  16KB   32         大于32GB      32KB            64
1024-2047MB 32KB  64
一个文件开始于一个簇的边界，并至少需要一簇，即使文件只占用了其中的一个扇区。
16-5.用柱面数、每磁道的扇区数和每扇区的字节数说明怎样计算以下软盘的容量：
（a）3.5"，720K软盘（b）3.5"，1.44MB软盘。
512*9*80*2=737280
512*18*80*2=1474560
16-6.磁盘系统区的3部分是什么？
磁盘的组织一般由系统区以及紧接着的数据区组成，磁盘其余的空间都是数据区。
系统区是磁盘上的第一个区，从最外面的磁道开始，即0面，0磁道，1扇区。
系统区存放系统存储和维护的信息，例如每个文件存储在磁盘上的起始位置等。
系统区的3个组成部分是（1）引导记录，（2）文件分配表（FAT），（3）目录。
16-7.（a）引导记录的目的是什么？（b）引导记录位于什么地方？（c）如何利用它来确定每个磁道的扇区数？
引导记录包含了把系统文件（如果存在）从磁盘载入（或“导入”）存储器的指令。
所有格式化的磁盘都包含一个引导记录，即使系统文件没有存储在磁盘上。
一张格式化的软盘包含以下信息（按照起始的物理和相对扇区）：
720K（9扇区/磁道）                                                      1.44MB（18扇区/磁道）
文件         柱面         盘面         扇区         相对扇区         柱面         盘面         扇区         相对扇区
引导记录      0            0            1                  0                  0               0              1               0
FAT1           0            0            2                  1                  0               0              2               1
FAT2           0            0            5                  4                  0               0              11              10
目录             0            0            8                 7                  0               1              2               19
数据区         0            1            6                  14                0               1              16              33
引导记录开始于柱面0、盘面0、扇区1。
引导记录包含了下面以偏移地址为序的信息：
18H   每个磁道的扇区数
16-8.目录如何指示一个被删除的文件？
对于每一个文件，系统建立了个32字节（20H）的目录项来描述文件的名字、创建日期、文件大小以及文件起始簇的位置。目录项的格式如下：
字节                  目的
00H-07H         文件名，在创建文件的程序中定义。第一个字节也可以表明文件的状态：
                           00H文件从未使用过
                           05H文件名的第一个字符实际上是E5H
                           2EH文件是个子目录
                           E5H文件已被删除
16-9.目录中对于（a）普通文件，（b）只读文件，（c）系统文件，（d）卷标，（e）只读隐藏文件的指示是什么？
0BH                  文件属性，定义文件类型（注意，一个文件可以有多个属性）：
                           00H正常属性文件
                           01H只能被读出的文件（只读文件）
                           02H隐藏文件，目录搜索不显示
                           04H系统文件，目录搜索不显示
                           08H卷标（如果这是个卷标记录，标签本身也在文件名和扩展名的字段中）
                           10H子目录
                           20H存档文件，表明从最后一次更新后文件是否修改过。
                           （例如，代码07H说明系统文件（04H）是只读的（01H）和隐藏的（02H）。）
16-10.当使用FORMAT/S格式化磁盘时，对软盘或硬盘的附加作用是什么？
在可引导磁盘或软盘的数据区以IO.SYS和MSDOS.SYS两个系统文件开始。
当用FORMAT /S格式化磁盘时，DOS就把它的系统文件复制到数据区的第一个扇区。
用户文件紧跟着系统文件，或者在没有系统文件的情况下从数据区的起始位置开始。
16-11.假定有一个大小为2259（十进制）字节的文件。（a）系统把文件大小存储在什么地方？（b）用十六进制形式表示文件大小是多少？
当系统存储文件时，显示这个值。（c）这个文件需要多少扇区？
对于每一个文件，系统建立了个32字节（20H）的目录项来描述文件的名字、创建日期、文件大小以及文件起始簇的位置。目录项的格式如下：
字节                  目的
1CH-1FH      文件大小，以字节计数。写文件后，系统计算并保存文件的大小在这个字段中。
2259=08D3H
2259/512=5个扇区
磁盘上的所有文件从一个簇的边界开始，也就是这个簇的第一个扇区。
如果一个簇对应8个扇区，则需要一个簇。如果一个簇对应4个扇区，则需要2个簇。如果一个簇对应2个扇区，则需要3个簇。
16-12.FAT在什么地方，以及如何指出它所驻留的设备为（a）硬盘，（b）3.5"，720K软磁盘，（c）3.5"，1.44MB软磁盘？
一张格式化的软盘包含以下信息（按照起始的物理和相对扇区）：
720K（9扇区/磁道）                                                      1.44MB（18扇区/磁道）
文件         柱面         盘面         扇区         相对扇区         柱面         盘面         扇区         相对扇区
引导记录      0            0            1                  0                  0               0              1               0
FAT1           0            0            2                  1                  0               0              2               1
FAT2           0            0            5                  4                  0               0              11              10
目录             0            0            8                 7                  0               1              2               19
数据区         0            1            6                  14                0               1              16              33
FAT开始于柱面0、盘面0、扇区2
FAT的第一个字节为媒体描述符，它指出设备类型（类似于引导记录中的字节15H）如下：
F0H 3.5''，双面，18扇区/磁道（1.44MB）和3.5''，双面，36扇区/磁道（2.88MB）
F8H 硬盘（包括RAM磁盘）
F9H 3.5''，双面，9扇区/磁道（720KB）和5.25''，双面，15扇区/磁道（1.2MB）
注意，F0H和F9H分别指定了两种不同的磁盘格式。
16-13.FAT如何指示12位入口项和16位入口项？
在头两个FAT入口项之后的是指针入口项，它涉及到数据区的每个簇。目录（在1AH-1BH）包含文件第一个簇的位置，
并且FAT包含了每个后继簇的指针入口链。
软盘的入口项长度是3位十六进制数（1+1/2字节，或12位），对于硬盘是4位十六进制数（两字节，或16位）。
每个FAT指针入口项根据以下格式指出特定簇的用法：
12位         16位         说明
000         0000         基准簇目前未使用
nnn         nnnn         与文件下一簇相关的簇号
FF0-FF6   FFF0-FFF6   保留簇
FF7         FFF7         不能用（坏磁道）
FFF         FFFF         文件最后一簇
一个程序把TEMPSTAT.FIL连续地从磁盘读到存储器，系统按以下步骤执行：
对于第一簇，搜索磁盘目录寻找文件名为TEMPSTAT、扩展名为FIL的文件，
从目录获取文件的第一个相对簇（2）的位置，并且传递其内容（来自扇区的数据）到主存储器中的程序。
对于下一簇，访问用相对簇2表示的FAT指针入口项。从上图可知，这个入口项包含003，这说明文件在相对簇3上继续。
系统传递这一簇的内容到程序。
对于最后一簇，访问用相对簇3表示的FAT指针入口项。这个入口项包含004，说明文件在相对簇4上继续。
系统传递这个簇上的内容到程序。
相对簇4的FAT入口项包含FFFH，指出没有簇分配给文件了。系统现在从簇2、3和4上传递了所有文件的数据。
第17章磁盘存储Ⅱ：写文件和读文件
17.1引言
17.2 ASCIZ串
17.3文件代号
17.4错误返回码
17.5文件指针
17.6建立磁盘文件
17.7读磁盘文件
17.8随机处理
17.9要点
17.10习题
目的：介绍文件代号的使用以及顺序和随机读写磁盘文件的操作。
17.1引言
本章介绍了写磁盘文件和读磁盘文件的中断服务，第18章介绍支持处理磁盘驱动器、目录和文件的各种服务请求。
其中有许多磁盘操作包括了用ASCIIZ串来识别驱动器、路径和文件名；连续存取文件的文件代号；
专门用来识别错误的返回码。
本章虽然不要求新的汇编语言指令，但是介绍了下面一些处理磁盘文件的INT 21H服务例程：
3CH   建文件         3FH   读记录
3DH   打开文件     40H   写记录
3EH   关闭文件      42H   移动文件指针
这里要注意，术语“簇”表示一组扇区，它含有一个或多个数据区，这取决于设备。
17.2ASCIIZ串
当要用到许多磁盘处理的扩展服务例程时，首先要给系统提供一个ASCIIZ串的地址，
ASCIIZ串包含文件规范：磁盘驱动器的位置、目录路径和文件名（都为可选项和内部省略符），
紧接着是一个十六进制的0字节。这个串的最大长度是128字节。
下例定义了一个驱动器和文件名：
PATHNAM1 DB 'C:\A17RANRD.ASM',00H
这个例子定义了驱动器、子目录和文件名：
PATHNAM2 DB 'C:\UTILITY\A17RANRD.EXE',00H
串中的后斜线也可以是前斜线，它起到路径分隔符的作用。十六进制的0字节用来结束串。
对于一个请求ASCIIZ串的中断服务，要把它的偏移地址装入DX寄存器，例如：LEA DX,PATHNAM1。
17.3文件代号
正如在第8章讨论的，可以对某一个标准设备直接使用文件代号：
00=输入设备，01=输出设备，02=错误输出设备，03=辅助设备，04=打印机。
其他I/O服务例程包括使用文件代号存取文件的操作，对这些操作，必须从系统请求文件代号。
对一个磁盘文件必须先要打开，这和对键盘或屏幕传输数据不一样，系统必须通过目录和FAT中的入口来寻址磁盘文件，
还要修改这些入口。与程序有关的每个文件在执行时必须分配到一个属于它自己的唯一的文件代号。
当为了输入打开一个文件或为了输出建立一个文件时，系统就传递出一个文件代号。
这些操作包括使用ASCIIZ串和INT21H的功能3CH或3DH。返回在AX中的文件代号是有唯一性的一个字长的数码，
你要把这个文件代号保存在一个字数据项中，在以后请求存取文件时就使用这个文件代号。
一般情况下，第一个返回的文件代号是05，第二个是06，以此类推。
PSP含有一个默认的文件代号表，它提供了近20个文件代号（这是对打开文件的一一种象征性的限制），
可以用INT 21H的功能67H来扩大这个限度，这在第23章中解释。
17.4错误返回码
磁盘的文件代号操作通过进位标志和AX寄存器传递出一个完成的状态。若操作成功，则清除进位标志为0，
并执行其他相关的功能。如操作不成功，则设置进位标志为1，并根据操作在AX中返回一个错误码。
图17-1列出了错误码01-36，其他的代码与网络有关。
如果这些错误码还不够，INT59H提供了有关错误的附加的信息（参见第18章）。
01   非法功能号   20   未知单元
02   文件未发现   21   驱动器未准备好
03   路径未找到   22   未知命令
04   打开的文件太多   23   CRC数据错
05   拒绝存取            24   请求指令长度错
06   非法文件代号     25   搜索错
07   内存控制块被破坏   26   未知的介质类型
08   内存不足                 27   未发现扇区
09   无效存储块地址      28   打印机纸出界
10   无效环境                29   写故障
11   非法格式               30   读故障
12   非法存取代码        31   一般性失败
13   无效数据               32   共享违例
15   指定的设备无效     33   锁违例
16   试图删除目录        34   非法磁盘更换
17   设备不一致           35   FCB无效
18   已没有文件           36   共享缓冲区溢出
19   磁盘写保护
图17-1主要的磁盘错误返回码
17.5文件指针
系统为正在处理的程序的每个文件保留了一个单独的文件指针。
建立和打开文件操作把文件指针的值初始化为0，即文件的起始位置。文件指针对文件内当前的偏移地址不断地进行计算。
每个读/写操作都会使系统通过传输的字节数对文件指针增量，然后文件指针就指向要存取的下一个记录的位置。
文件指针对顺序和随机处理都很方便。对记录的随机处理，程序可以使用INT 21H的功能42H（在后面一节中要讲到）
把文件指针设置到文件的任何位置。
下面几节包括了建立磁盘文件、写磁盘文件和关闭磁盘文件的中断请求。
1.建立文件（3CH号功能调用）
功能：建立文件（创建新的，或刷新老的文件）。
入口参数：DS:DX=代表文件名的字符串的首地址。
CX=文件属性。
出口参数：CF=0表示成功，AX=文件号（柄）。
CF=1表示失败，AX=错误代码。
说明：（1）可指定的文件属性如下：
00H普通
01H只读
02H隐含
04H系统
（2）创建文件成功后，文件长度定为0。
2.打开文件（3DH号功能调用）
功能：打开文件。
入口参数：DS:DX=代表文件名的字符串的首地址。
AL=存取方式。
出口参数：CF=0表示成功，AX=文件号（柄）。
CF=1表示失败，AX=错误代码。
说明：（1）存取方式规定如下：
00H只读方式
01H只写方式
02H读写方式
（2）打开文件成功后，文件指针定位于开始的第一个字节（偏移0）处。
3.读文件（3FH号功能调用）
功能：读文件。
入口参数：BX=文件号（柄）。
CX=读入字节数。
DS:DX=准备存放所读数据的缓冲区的首地址。
出口参数：CF=0表示成功，AX=实际读到的字节数。
CF=1表示失败，AX=错误代码。
说明：（1）通常情况下，实际读到的字节数与欲读入的字节数相同，除非不够读。
（2）缓冲区应保证能容下所读到的数据。
（3）文件应以读或读写方式打开。
（4）读文件后，文件指针将定位到读出字节之后的第一个字节处。
4.写文件（40H号功能调用）
功能：写文件。
入口参数：BX=文件号（柄）；
CX=写盘字节数；
DS:DX=存放写数据的缓冲区的首地址。
出口参数：CF=0表示成功，AX=实际写出的字节数。
CF=1表示失败，AX=错误代码。
说明：（1）通常情况下，实际写出的字节数与欲写盘的字节数相同，除非磁盘满。
（2）文件应以写或读写方式打开。
（3）写文件后，文件指针将定位到写入字节之后的第一个字节处。
5.关闭文件（3EH号功能调用）
功能：关闭文件。
入口参数：BX=文件号（柄）。
出口参数：CF=0表示成功。
CF=1表示失败。
说明：文件号是打开该文件时系统所给定的文件号。
6.移动文件读写指针（42H号功能调用）
功能：移动文件（读写）指针。
入口参数：BX=文件号（柄）。
CX:DX=移动位移量。
AL=移动方式。
出口参数：CF=0表示成功，此时，DX:AX=移动后文件指针值。
CF=1表示失败，此时，（AX）=1表示无效的移动方式，（AX）=6表示无效的文件号。
说明：（1）文件指针值（双字）是以文件首字节为0计算的。
（2）移动方式和表示的意义如下：
00H 移动后文件指针值=0（文件头）+移动位移量
01H =当前文件指针值+移动位移量
02H =文件长（文件尾）+移动位移量
（3）在第一种移动方式中，移动位移量总是正的。
（4）在后两种移动方式中，移动位移量可正可负。
（5）该子功能不考虑文件指针是否超出文件范围。
7.删除文件（41H号功能调用）
功能：删除文件。
入口参数：DS:DX=代表文件名的字符串首地址。
出口参数：CF=0表示成功；
CF=1表示失败，AX=错误代码。
说明：只能删除一个普通文件。
17.6建立磁盘文件
写磁盘的过程如下：
1.用ASCIIZ串从系统得到文件代号；
2.用INT 21H的功能3CH建立文件的目录入口；
3.用INT 21H的功能40H写文件记录；
4.最后，用INT 21H的功能3EH关闭文件。
DOS Fn 3cH: Create a File via Handle
DOS Fn 3dH: Open a File via Handle
DOS Fn 3eH: Close a File Handle
DOS Fn 3fH: Read from File via Handle
DOS Fn 40H: Write to File via Handle
DOS Fn 41H: Delete File
DOS Fn 42H: Set File Pointer
00H正常属性文件
01H只能被读出的文件（只读文件）
02H隐藏文件，目录搜索不显示
04H系统文件，目录搜索不显示
17.6.1INT 21H的功能3CH：建立文件
建立一个新文件或用相同的名字重写一个旧文件时，首先要使用INT 21H的功能3CH。
把请求的文件属性装入CX（第16章中已介绍过），ASCIIZ串的地址装入DX（新文件在磁盘上的位置）。
下例在驱动器C建立个属性为0的正常文件：
PATHNAM1 DB 'C:\ACCOUNTS.FIL',00H
FILHAND1 DW ?
...
MOV AH,3CH   ;请求建立文件
MOV CX,0   ;正常属性
LEA DX,PATHNAM1   ;ASCIIZ串
INT 21H   ;调用中断服务例程
JC error   ;出错时的特定动作
MOV FILHAND1,AX   ;保存文件代号到一个字中
...
error:
...
对一个有效的操作，系统用给定的属性建立一个目录入口，清除进位标志，并在AX中设置文件代号。
以后存取文件都使用这个文件代号。打开指定文件的同时，把文件指针设置为0（文件的开始），这时就可以写文件了。
如果文件在指定的路径上已经存在，该操作将文件长度置为0，使新文件对旧文件进行重写。
对于错误的情况，操作设置进位标志，并在AX中返回错误码；03、04或05（见图17.1）。
错误码05说明目录满了或者涉及到的文件名具有只读的属性，首先应当检验进位标志。
例如，建一个文件时可能给AX传送的文件代号是05，这很容易与拒绝存取的错误码05相混淆，
有关建立文件的服务是INT 21H的功能5AH和5BH，这些内容将在第18章介绍。
17.6.2INT21H的功能40H：写记录
INT21H的功能40H用于在磁盘上写记录。在BX中装入保存的文件代号。CX中是要写入的字节数，DX中是输出区的地址。
下例使用文件代号完成从建文件操作到写入DSKAREA中的256字节的记录：
FILHAND1 DW ?   ;文件代号
DSKAREA DB 256 DUP (20H)   ;输出区
...
MOV AH,40H   ;请求写记录
MOV BX,FILHAND1   ;文件代号
MOV CX,256   ;记录长度
LEA DX,DSKAREA   ;输出区地址
INT 21H   ;调用中断服务例程
JC error1
CMP AX,256   ;全部字节写完?
JNE error2   ;未完，则出错
...
error1:
...
error2:
...
一次有效的操作将把记录写到磁盘上、对文件指针增量、清除进位标志、并设置AX为实际写入的字节数。
一个已写满的磁盘可能会使实际写入的字节数和要求写入的字节数不同，但是因为系统没有把这种情况作为一个错误报告，
因此程序必须测试AX中的返回值。非法操作将设置进位标志为1，并返回给AX错误码05（拒绝存取）或06（非法文件代号）。
17.6.3INT 21H的功能3EH：关闭文件
完成写磁盘文件后，程序必须将这个文件关闭。在BX装入文件代号，并调用INT 21H的功能3EH：
MOV AH,3EH   ;请求关文件
MOV BX,FILHAND1   ;文件代号
INT 21H   ;调用中断服务例程
JC error   ;测试错误
成功的关闭操作将仍在内存缓冲区中的剩余记录写入磁盘，并用日期和文件大小修改FAT和目录。
不成功的操作将设置进位标志，AX中的返回码只可能是错误码06（非法文件代号）。
17.6.4程序：建立一个磁盘文件
图17-2的程序建立一个由用户键入姓名的文件。它的主要过程如下：
A10MAIN调用B10CREATE，C10PROC，如果输入结束调用E10CLOSE。
B10CREATE用INT 21H的功能3CH建立文件，并将文件代号保存在一个数据项FILEHAND中。
C10PROC从键盘接收输入，并把姓名之后剩余的输入区清0，
D10WRITE利用INT 21H的功能40H写记录。
E10CLOSE利用INT 21H的功能3EH在处理结束时关闭文件以建立相应的目录入口。
F10DISPLY在屏幕上显示数据。
.MODEL SMALL
.STACK 512
.DATA
NAMEPAR LABEL BYTE
MAXLEN DB 30
NAMELEN DB ?
NAMEREC DB 30 DUP (20H),0DH,0AH
ERRCODE DB 0
FILEHAND DW ?
PATHNAME DB 'C:\NAMEFILE.DAT',0
PROMPT DB 'Name: '
OPENMSG DB '*** Open error  ***'
WRITEMSG DB '*** Write error ***'
ROW DB 0
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
MOV AX,0003H
INT 10H
CALL B10CREATE
CMP BYTE PTR ERRCODE,00H
JNZ A90
A20:CALL C10PROC
CMP BYTE PTR NAMELEN,0
JNE A20
CALL E10CLOSE
A90:MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10CREATE PROC NEAR
MOV AH,3CH
MOV CX,0
LEA DX,PATHNAME
INT 21H
JC B20
MOV FILEHAND,AX
JMP B90
B20:LEA BP,OPENMSG
MOV CX,19
CALL F10DISPLY
MOV BYTE PTR ERRCODE,01H
B90:RET
B10CREATE ENDP
C10PROC PROC NEAR
LEA BP,PROMPT
MOV CX,6
CALL F10DISPLY
MOV AH,0AH
LEA DX,NAMEPAR
INT 21H
CMP BYTE PTR NAMELEN,0
JE C90
MOV AL,20H
MOV CX,0
MOV CL,NAMELEN
LEA DI,NAMEREC
ADD DI,CX
NEG CX
MOV DX,0
MOV DL,MAXLEN
ADD CX,DX
REP STOSB
CALL D10WRITE
C90:RET
C10PROC ENDP
D10WRITE PROC NEAR
MOV AH,40H
MOV BX,FILEHAND
MOV CX,0
MOV CL,MAXLEN
ADD CX,2
LEA DX,NAMEREC
INT 21H
JNC D20
LEA BP,WRITEMSG
MOV CX,19
CALL F10DISPLY
MOV BYTE PTR ERRCODE,01H
MOV BYTE PTR NAMELEN,0
D20:RET
D10WRITE ENDP
E10CLOSE PROC NEAR
MOV BYTE PTR NAMEREC,1AH
CALL D10WRITE
MOV AH,3EH
MOV BX,FILEHAND
INT 21H
RET
E10CLOSE ENDP
F10DISPLY PROC NEAR
MOV AX,1301H
MOV BX,0016H
MOV DH,ROW
MOV DL,00H
INT 10H
INC BYTE PTR ROW
RET
F10DISPLY ENDP
END A10MAIN
输入区是30个字节，紧接着的两个字节是回车符（0DH）和换行符（0AH），总共32个字节。
程序将32字节作为一个固定长度的记录来写入。可以省略回车/换行符，但是如果想对文件中的记录分类则必须包括它们，
因为SORT程序需要用回车/换行符来表示每个记录的结束。
要注意两点：（1）在每个记录之后包括回车符/换行符只是为了分类更方便，否则可以省略它们。
（2）每个记录可以是可变长度的格式，一直到姓名结束，这需要编写一些另外的程序，在后面可以看到。
17.7读磁盘文件
这一节包括了利用文件代号打开和读磁盘文件的请求。读磁盘文件的过程如下：
1.利用ASCIIZ串从系统获取文件代号：
2.利用INT 21H的功能3DH打开文件；
3.利用INT 21H的功能3FH从文件中读记录；
4.最后，用INT 21H的功能3EH关闭文件。
17.7.1INT 21H的功能3DH：打开文件
读文件的程序必须首先用INT 21H的功能3DH来打开文件。这个操作通过已实际存在的文件名来检查文件，
如果存在，对程序是可用的。在DX中装入所请求的ASCIIZ串的地址，在AL中装入一个8位的存取代码：
位0-2
000=只读
001=只写
010=读写
位3保留
位4-6共享方式
位7继承标志
存取方式规定如下：
00H只读方式
01H只写方式
02H读写方式
读文件之前，程序应当用功能3DH来打开文件，而不是用功能3CH建立文件。下例为读而打开个文件：
FILHAND DW ?   ;文件代号
...
MOV AH,3DH   ;请求打开文件
MOV AL,00H   ;只读
LEA DX,PATHNM1   ;ASCIIZ串
INT 21H：调用中断服务例程
JC error
MOV FILHAND,AX   ;保存文件代号
...
error:
...
如果指定名字的文件存在，该操作设置记录长度为1（这点你可以不考虑），确定它的属性，设置文件指针为0（文件的开始），
清除进位标志，在AX中返回文件代号。以后对这个文件的所有存取操作都使用这个文件代号。
如果文件不存在，该操作置进位标志为1，并在AX中返回错误码：02、03、04、05或12（见图17-1）。
一定要先检查进位标志。例如，建一个文件，正好传送给AX的文件代号是05，这很容易与拒绝存取的错误代码05相混淆。
程序可以通过滚动屏幕来修改。
17.7.2INT 21H的功能3FH：读记录
INT 21H的功能3FH用于读磁盘记录。在BX中放入文件代号，CX中放入要读的字节数，DX中放入输入区的地址。
下例用前面的例子得到的文件代号来读一个512字节的记录：
FILHAND DW ?   ;文件代号
INAREA DB 512 DUP (20H)
...
MOV AH,3FH   ;请求读记录
MOV BX,FILHAND   ;文件代号
MOV CX,512   ;记录长度
LEA DX,INAREA   ;输入区地址
INT 21H   ;调用中断服务例程
JC error
CMP AX,0   ;读出0字节?
JE endfile   ;是，文件结束
...
endfile:
...
error:
...
一次有效的操作将读出的记录传送给程序，清除进位标志，并设置AX为实际读出的字节数。
AX为0说明试图从文件尾读记录，这是一个警告而不是一个错误。
一次非法的读操作设置进位标志，并给AX返回错误码05（拒绝存取）或06（非法的文件代号）。
因为系统限制一次打开的文件数，所以程序在连续读一定数量文件之后应立即关闭它们。
17.7.3程序：顺序读磁盘文件
图17-3的程序读取已由图17-2的程序建立的文件，并用DOS命令SORT来分类。
对这个例子，将NAMEFILE.DAT中的记录按升序分类存入NAMEFILE.SRT，其命令为：
SORT n:<NAMEFILE.DAT> NAMEFILE.SRT
（SORT处理NAMEFILE.DAT文件成为NAMEFILE.SRT）。
下面是主要的过程：
A10MAIN 调用B10OPEN、C10READ、D10DISPLY，在程序末尾关闭文件，并结束处理。
B10OPEN用INT 21H的功能3DH打开文件，并保存文件代号。
C10READ调用INT 21H的功能3FH，它利用获取的文件代号来读记录。
D10DISPLY显示记录并前移光标。
.MODEL SMALL
.STACK 512
.DATA
RECD_LEN EQU 32
ENDCODE DB 00H
FILEHAND DW ?
RECAREA DB 32 DUP (20H)
OPENMSG DB '*** Open error ***'
PATHNAME DB 'C:\NAMEFILE.SRT',0
READMSG DB '*** Read error ***'
ROW DB 0
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
MOV AL,00H
CALL Q10SCROLL
CALL B10OPEN
CMP BYTE PTR ENDCODE,00H
JNZ A90
A20:CALL C10READ
CMP BYTE PTR ENDCODE,00H
JNZ A80
LEA BP,RECAREA
MOV CX,RECD_LEN
CALL D10DISPLY
JMP A20
A80:MOV AH,3EH
MOV BX,FILEHAND
INT 21H
A90:MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10OPEN PROC NEAR
MOV AH,3DH
MOV AL,00H
LEA DX,PATHNAME
INT 21H
JC B20
MOV FILEHAND,AX
JMP B90
B20:LEA BP,OPENMSG
MOV CX,18
CALL D10DISPLY
MOV BYTE PTR ENDCODE,01H
B90:RET
B10OPEN ENDP
C10READ PROC NEAR
MOV AH,3FH
MOV BX,FILEHAND
MOV CX,RECD_LEN
LEA DX,RECAREA
INT 21H
JC C20
CMP AX,0
JE C30
CMP BYTE PTR RECAREA,1AH
JE C30
JMP C90
C20:LEA BP,READMSG
MOV CX,18
CALL D10DISPLY
C30:MOV BYTE PTR ENDCODE,01H
C90:RET
C10READ ENDP
D10DISPLY PROC NEAR
MOV AX,1301H
MOV BX,0016H
MOV DH,ROW
MOV DL,10
INT 10H
CMP BYTE PTR ROW,23
JAE D80
INC BYTE PTR ROW
JMP D90
D80:MOV AL,01H
CALL Q10SCROLL
D90:RET
D10DISPLY ENDP
Q10SCROLL PROC NEAR
MOV AH,06H
MOV BH,1EH
MOV CX,0000H
MOV DX,184FH
INT 10H
RET
Q10SCROLL ENDP
END A10MAIN
17.8随机处理
前面关于顺序处理磁盘文件的讨论对建立一个文件、打印文件内容以及改变几个小文件已经足够了。
然而许多应用要求对一个文件存取特定的记录，如顾客或库存零件的信息。
为了用新的数据修改一个文件，限定顺序处理的程序可能要读出文件中的每个记录，一直到找出所需要的记录为止。
例如，为了要存取文件中第300个记录，顺序处理可能在传送第300个记录之前要读出它前面的299个记录
（虽然系统可以从指定的记录号开始）。
解决的办法是使用随机处理方法，它可以使一个程序直接存取文件中的任何一个指定的记录。
虽然程序顺序地建立了一个文件，但它可以顺序地或随机地存取记录。
当程序随机地请求一个记录时，读操作利用目录来定位记录所在的扇区，并把整个扇区从磁盘读到缓冲区，
然后把所需要的记录传送给程序。
在下一个例子中，记录的长度是128个字节，一个扇区有4个记录。随机请求21号记录使下列4个记录从扇区中读入缓冲区：
记录#20 记录#21 记录#22 记录#23
当程序随机地请求下一个记录，如23号记录，操作先检查缓冲区。如果记录已经在缓冲区了，它就直接被传送给程序；
如果程序请求的记录号不在缓冲区中，则操作又用目录来定位含有这个记录的扇区，并把整个扇区读入缓冲区，
然后把这个记录传送给程序。在这种情况下，请求的随机记录号在文件中是靠近的，那么磁盘存取操作也只会有很少的几次。
17.8.1INT 21H的功能42H：移动文件指针
打开操作把文件指针初始化为0，接着的顺序读和写操作对文件指针增量以处理每个记录。
可以使用42H功能（移动文件指针）把文件指针设置到文件内的任何地方，然后使用其他的服务例程随机地检索或更新记录。
为了请求功能42H，在BX中设置文件代号，在CX:DX中设置所要求的字节的偏移量。
对于最大为65535字节的偏移量，CX设置为0，DX设置为偏移值。还要在AL中设置方法代码，
方法代码告诉操作从文件的哪一点开始计算偏移量：
00从文件开始计算偏移量。
01从文件指针的当前位置计算偏移量，文件指针可以在文件内的任何地方，包括文件的开始。
02从文件尾计算偏移量。可以用这个方法编码把记录位置增加到文件尾。或者把CX：DX清为0，
然后用方法代码02来确定文件的大小。
说明：（1）文件指针值（双字）是以文件首字节为0计算的。
（2）移动方式和表示的意义如下：
00H 移动后文件指针值=0（文件头）+移动位移量
01H =当前文件指针值+移动位移量
02H =文件长（文件尾）+移动位移量
（3）在第一种移动方式中，移动位移量总是正的。
（4）在后两种移动方式中，移动位移量可正可负。
（5）该子功能不考虑文件指针是否超出文件范围。
下例从文件开始把指针移动1024字节：
MOV AH,42H   ;重定位指针
MOV AL,00H   ;从文件首开始
MOV BX,HANDLE1   ;设置文件代号
MOV CX,0000H   ;偏移量高位部分
MOV DX,1024   ;偏移量低位部分
INT 21H   ;调用中断服务例程
JC error
对于有效的操作将清除进位标志，并把新的指针地址传送给DX:AX。
程序可以利用这个地址来执行读或写操作以便随机地处理文件。
对于无效的操作，设置进位标志，并在AX中返回错误码01（非法方法代码）或06（非法文件代号）。
17.8.2程序：随机读磁盘文件
图17-4的程序读取图17-2建立的文件。键入文件范围内的一个记录号，就可以请求要在屏幕上显示的任一个文件记录。
如果文件包括24个记录，那么有效的记录号是01到24。
从键盘输入的记录号是ASCII格式的，在这种情况下应当只是一位数字或两位数字。
程序的组织如下：
A10MAIN 调用B10OPEN、C10RECNO、D10READ和E10DISPLY，当用户没有更多的请求时结束。
B10OPEN打开文件并获得文件代号。
C10RECNO从键盘接收记录号，并检查它在参数表中的长度。在下一节中有详细描述。
D10READ利用功能42H和相对于RECINDX的位置来设置文件指针，并发出3FH功能调用，将所要求的记录送入程序的IOAREA。
E10DISPLY 显示检索到的记录。
记录号的长度有3种可能：00=请求数字的处理结束，01=请求一位数字存入AL，02=请求2位数字存入AX。
子程序必须将ASCII数转换为二进制。由于这个数存在AX中，所以用AAD指令就可处理这个问题，
例如，假定输入的记录号是ASCII码的14，那么AX中就是3134：
用AND指令将这个值转换为0104；
用AAD指令进一步将它转换为000E（14）；
用DEC指令减1（因为系统确认文件是从0地址开始）得到000D（13）；
用SHL指令左移5位，相当于乘以32（文件中记录的长度），这样得到1A0（416），
保存在RECINDX字段中。
对程序应当进行改进的地方是确认输入的记录号（01-24）。
.MODEL SMALL
.STACK 512
.DATA
BOTT_ROW EQU 22
RECD_LEN EQU 32
FILEHAND DW ?
RECINDEX DW ?
ERRCODE DB 00H
PROMPT DB 'Record number: '
RECAREA DB 32 DUP (20H)
PATHNAME DB 'C:\NAMEFILE.SRT',0
OPENMSG DB '*** Open error ***'
READMSG DB '*** Read error ***'
ROW DB 0
COL DB 10
RECDPAR LABEL BYTE
MAXLEN DB 3
ACTLEN DB ?
RECDNO DB 6 DUP (20H)
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
MOV AL,00H
CALL Q10SCROLL
CALL B10OPEN
CMP BYTE PTR ERRCODE,00H
JNZ A90
A20:MOV BYTE PTR COL,10
CALL C10RECNO
CMP BYTE PTR ACTLEN,0
JE A90
CALL D10READ
CMP BYTE PTR ERRCODE,00H
JNZ A90
LEA BP,RECAREA
MOV CX,RECD_LEN
CALL E10DISPLY
CMP BYTE PTR ROW,BOTT_ROW
JAE A30
INC BYTE PTR ROW
JMP A20
A30:MOV AL,01H
CALL Q10SCROLL
JMP A20
A90:MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10OPEN PROC NEAR
MOV AX,3D00H
LEA DX,PATHNAME
INT 21H
JC B20
MOV FILEHAND,AX
JMP B90
B20:MOV BYTE PTR ERRCODE,01H
LEA BP,OPENMSG
MOV CX,18
CALL E10DISPLY
B90:RET
B10OPEN ENDP
C10RECNO PROC NEAR
LEA BP,PROMPT
MOV CX,15
CALL E10DISPLY
MOV AH,0AH
LEA DX,RECDPAR
INT 21H
CMP BYTE PTR ACTLEN,1
JB C40
JA C20
XOR AH,AH
MOV AL,RECDNO
JMP C30
C20:MOV AH,RECDNO
MOV AL,RECDNO+1
C30:AND AX,0F0FH
AAD
DEC AX
SHL AX,1
SHL AX,1
SHL AX,1
SHL AX,1
SHL AX,1
MOV RECINDEX,AX
C40:MOV BYTE PTR COL,30
RET
C10RECNO ENDP
D10READ PROC NEAR
MOV AH,42H
MOV AL,00H
MOV BX,FILEHAND
MOV CX,0
MOV DX,RECINDEX
INT 21H
JC D20
MOV AH,3FH
MOV BX,FILEHAND
MOV CX,RECD_LEN
LEA DX,RECAREA
INT 21H
JC D20
CMP BYTE PTR RECAREA,1AH
JE D30
JMP D90
D20:LEA BP,READMSG
MOV CX,18
CALL E10DISPLY
D30:MOV BYTE PTR ERRCODE,01H
D90:RET
D10READ ENDP
E10DISPLY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,1301H
MOV BX,0016H
MOV DH,ROW
MOV DL,COL
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
E10DISPLY ENDP
Q10SCROLL PROC NEAR
MOV AH,06H
MOV BH,1EH
MOV CX,0000H
MOV DX,184FH
INT 10H
RET
Q10SCROLL ENDP
END A10MAIN
17.8.3程序：读一个ASCII文件
前面的例子建立了文件并读取它们，你可能也想处理一个由编辑程序或字处理程序建立的ASCII文件。
这时必须了解目录和FAT的组织以及系统在扇区存储数据的方法。
例如，.ASM文件中的数据严格地按照键入的方式存储，包括Tab（09H）、回车（0DH）和换行（0AH）等字符。
为了节省磁盘空间，一行上的空格，包括前面讲到的Tab符或Spaces，直到遇到一个回车符，
这些在屏幕上直接出现的空格就不存储了。下面是从键盘输入的一条指令：
<Tab>MOV<Tab>AH,09<Enter>
对这个ASCII数据用十六进制表示为：
09 4D 4F 56 09 41 48 2C 30 39 0D 0A
这里十六进制的09是Tab，0D是回车，0A是换行。
当编辑程序或字处理程序读文件时，Tab、回车和换行符自动地调整屏幕上的光标。
现在来分析图17-5的程序，它读取并显示文件A17RDRAN.ASM（图17-3的程序），每次读取一个扇区，
程序显示每一行直到出现回车/换行符。
A10MAIN调用B10OPEN C10READ来读第一扇区以及D10XFER，并在程序最后关闭文件。
B10OPEN打开文件，保存文件代号，确定文件的大小（根据AX中文件大小的低位部分）。
C10READ把一个扇区的数据全部读到SECTOR。
D10XFER从扇区把数据传输到一个显示行，调用E10DISPLY来显示，调用C10READ读下一个扇区，
如此连续处理一直到文件尾。这个过程将在本节后面详细描述。
E10DISPLY显示包括换行符在内的显示行的数据，一直显示到换行符。因为ASCII文件中的行是可变长度格式的，
所以必须在显示之前扫描到每行的行尾（屏幕操作INT 10H的功能13H对Tab符不起作用，但可以用一个循环显示它们）。
F10ERROR为磁盘错误显示一条信息。
.MODEL SMALL
.STACK 512
.DATA
DISPAREA DB 80 DUP (20H)
ENDCODE DW 0000H
FILESIZE DW 0
FILEHAND DW 0
OPENMSG DB '*** Open error ***'
PATHNAME DB 'D:\T525.ASM',0
ROW DB 0
SECTOR DB 512 DUP (20H)
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
MOV AX,0003H
INT 10H
CALL B10OPEN
CMP BYTE PTR ENDCODE,00H
JNE A90
CALL C10READ
CMP WORD PTR ENDCODE,0
JE A80
CALL D10XFER
A80:MOV AH,3EH
MOV BX,FILEHAND
INT 21H
A90:MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10OPEN PROC NEAR
MOV AX,3D00H
LEA DX,PATHNAME
INT 21H
JNC B20
CALL F10ERROR
JMP B90
B20:MOV FILEHAND,AX
MOV AX,4202H
MOV BX,FILEHAND
MOV CX,0
MOV DX,0
INT 21H
MOV FILESIZE,AX
MOV AX,4200H
MOV BX,FILEHAND
MOV CX,0
MOV DX,0
INT 21H
B90:RET
B10OPEN ENDP
C10READ PROC NEAR
MOV AH,3FH
MOV BX,FILEHAND
MOV CX,512
LEA DX,SECTOR
INT 21H
MOV ENDCODE,AX
RET
C10READ ENDP
D10XFER PROC NEAR
CLD
LEA SI,SECTOR
D20:LEA DI,DISPAREA
D30:LEA DX,SECTOR+512
CMP SI,DX
JNE D40
CALL C10READ
CMP WORD PTR ENDCODE,0
JE D80
LEA SI,SECTOR
D40:LEA DX,DISPAREA+80
CMP DI,DX
JB D50
CALL E10DISPLY
LEA DI,DISPAREA
D50:LODSB
STOSB
DEC WORD PTR FILESIZE
JZ D80
CMP AL,0AH
JNE D30
CALL E10DISPLY
JMP D20
D80:CALL E10DISPLY
D90:RET
D10XFER ENDP
E10DISPLY PROC NEAR
MOV AX,1301H
MOV BX,0061H
LEA BP,DISPAREA
LEA CX,DISPAREA
NEG CX
ADD CX,DI
MOV DH,ROW
MOV DL,0
INT 10H
CMP BYTE PTR ROW,23
JAE E20
INC BYTE PTR ROW
JMP E90
E20:MOV BYTE PTR ROW,0
MOV AH,10H
INT 16H
MOV AX,0003H
INT 10H
E90:RET
E10DISPLY ENDP
F10ERROR PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,1301H
MOV BX,0031H
LEA BP,OPENMSG
MOV CX,18
MOV DX,1020H
INT 10H
MOV BYTE PTR ENDCODE,01H
POP DX
POP CX
POP BX
POP AX
RET
F10ERROR ENDP
END A10MAIN
过程E10DISPLY从SECTOR一次传输一个字节到DISPAREA，要显示的字符都存放在这里。
必须检查扇区末尾（为了读下一个扇区）并显示区的末尾。对常规的ASCII文件，如.ASM文件，每一行都是相当的短并且也是用回车/换行符来结束。
非ASCII文件，如.EXE和.OBJ文件没有行，那么程序必须检查DISPAREA的末尾，以避免把数据移进下面的区域。
这个程序只设计为显示ASCII文件，测试DISPAREA的末尾是为了防止意外的文件类型出现。检测的步骤如下：
1.初始化SECTOR和DISPAREA的地址。
2.如果在SECTOR的末尾，则读下一个扇区。如果在文件尾，则退出；否则初始化SECTOR的地址。
3.如果在DISPAREA的末尾，显示这行并初始化DISPAREA。
4.从SECTOR获取一个字符并把它存入DISPAREA。
5.如果所有字符都已经处理，退出。
6.如果字符是换行（0AH），显示这行并转向第2步；否则转向第3步。
尝试在DEBUG下对一个适当的驱动器号和ASCII文件来运行这个程序。
每次磁盘输入之后，显示输入区的内容，并且观察记录是如何被格式化的，加强这个程序的功能，可以提示用户键入文件名和扩展名，并用DX:AX来保存文件大小。
17.9要点
许多INT 21H的磁盘服务例程都涉及到一个ASCIIZ串，它是由目录路径和紧接着的一个十六进制的0字节组成。
当出错时，许多磁盘功能设置进位标志，并在AX中返回一个错误码。
系统为正在处理的程序的每个文件保留一个文件指针。建立和打开操作设置文件指针的值为0，即文件的开始位置。读和写操作使文件指针前移。
INT 21H的功能3CH用于在写记录之前建立一个文件，功能3DH在读文件之前打开这个文件。这两个操作都返回文件代号，
程序在以后存取文件时都要使用这个文件代号。
程序在完成写文件操作后，应当关闭文件，这样系统才可以修改目录。
INT21H的功能42H（移动文件指针）用于随机检索和更新磁盘记录。
17.10习题
17-1.下列情况的错误返回码是什么？（a）拒绝存取，（b）文件未发现。（c）磁盘写保护（d）非法功能号
01   非法功能号 
02   文件未发现 
05   拒绝存取
19   磁盘写保护
17-2.为驱动器C上的文件MONITOR.FIL定义一个名为ASCSTRING的ASCIIZ串。
ASCSTRING DB 'C:\MONITOR.FIL',00H
17-3.对17.2题的文件编写指令：（a）建立一个正常属性的文件，如果有效，则保存文件代号，
（b）利用文件代号把一条100字节的记录写入文件，（c）关闭文件。
PATHNAM1 DB 'C:\MONITOR.FIL',00H
FILHAND1 DW ?
...
MOV AH,3CH   ;请求建立文件
MOV CX,0   ;正常属性
LEA DX,PATHNAM1   ;ASCIIZ串
INT 21H   ;调用中断服务例程
JC error   ;出错时的特定动作
MOV FILHAND1,AX   ;保存文件代号到一个字中
...
error:
...

FILHAND1 DW ?   ;文件代号
DSKAREA DB 256 DUP (20H)   ;输出区
...
MOV AH,40H   ;请求写记录
MOV BX,FILHAND1   ;文件代号
MOV CX,100   ;记录长度
LEA DX,DSKAREA   ;输出区地址
INT 21H   ;调用中断服务例程
JC error1
CMP AX,100   ;全部字节写完?
JNE error2   ;未完，则出错
...
error1:
...
error2:
...

MOV AH,3EH   ;请求关文件
MOV BX,FILHAND1   ;文件代号
INT 21H   ;调用中断服务例程
JC error   ;测试错误
...
error:
...
17-4.修改图17-5的程序，使用户在键盘上可以键入文件名，程序依此来定位文件并显示文件的内容。准备任意个请求并要求只按下回车，程序即开始处理一直到结束。
测试通过的完整程序如下
.MODEL SMALL
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
.STACK 512
.DATA
DISPAREA DB 80 DUP (20H)
ENDCODE DW 0000H
FILESIZE DW 0
FILEHAND DW 0
OPENMSG DB '*** Open error ***'
FNAME_SRC DB 128 DUP (0)
MESS_FNSRC DB 'Please input source filename:','$'
ROW DB 0
SECTOR DB 512 DUP (20H)
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
MOV DX,OFFSET MESS_FNSRC
CALL DISPMESS
MOV DI,OFFSET FNAME_SRC
CALL GETSTRFN
MOV AX,0003H
INT 10H
CALL B10OPEN
CMP BYTE PTR ENDCODE,00H
JNE A90
CALL C10READ
CMP WORD PTR ENDCODE,0
JE A80
CALL D10XFER
A80:MOV AH,3EH
MOV BX,FILEHAND
INT 21H
A90:MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10OPEN PROC NEAR
MOV AX,3D00H
LEA DX,FNAME_SRC+2
INT 21H
JNC B20
CALL F10ERROR
JMP B90
B20:MOV FILEHAND,AX
MOV AX,4202H
MOV BX,FILEHAND
MOV CX,0
MOV DX,0
INT 21H
MOV FILESIZE,AX
MOV AX,4200H
MOV BX,FILEHAND
MOV CX,0
MOV DX,0
INT 21H
B90:RET
B10OPEN ENDP
C10READ PROC NEAR
MOV AH,3FH
MOV BX,FILEHAND
MOV CX,512
LEA DX,SECTOR
INT 21H
MOV ENDCODE,AX
RET
C10READ ENDP
D10XFER PROC NEAR
CLD
LEA SI,SECTOR
D20:LEA DI,DISPAREA
D30:LEA DX,SECTOR+512
CMP SI,DX
JNE D40
CALL C10READ
CMP WORD PTR ENDCODE,0
JE D80
LEA SI,SECTOR
D40:LEA DX,DISPAREA+80
CMP DI,DX
JB D50
CALL E10DISPLY
LEA DI,DISPAREA
D50:LODSB
STOSB
DEC WORD PTR FILESIZE
JZ D80
CMP AL,0AH
JNE D30
CALL E10DISPLY
JMP D20
D80:CALL E10DISPLY
D90:RET
D10XFER ENDP
E10DISPLY PROC NEAR
MOV AX,1301H
MOV BX,0061H
LEA BP,DISPAREA
LEA CX,DISPAREA
NEG CX
ADD CX,DI
MOV DH,ROW
MOV DL,0
INT 10H
CMP BYTE PTR ROW,23
JAE E20
INC BYTE PTR ROW
JMP E90
E20:MOV BYTE PTR ROW,0
MOV AH,10H
INT 16H
MOV AX,0003H
INT 10H
E90:RET
E10DISPLY ENDP
F10ERROR PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,1301H
MOV BX,0031H
LEA BP,OPENMSG
MOV CX,18
MOV DX,1020H
INT 10H
MOV BYTE PTR ENDCODE,01H
POP DX
POP CX
POP BX
POP AX
RET
F10ERROR ENDP
ISFNM PROC
CMP AL,2BH
JB ISFNM_NOFNM
CMP AL,3BH
JA ISFNM_NODEC1
CLC
JMP ISFNM_OK
ISFNM_NODEC1:CMP AL,41H
JB ISFNM_NOFNM
CMP AL,5FH
JA ISFNM_NODEC2
CLC
JMP ISFNM_OK
ISFNM_NODEC2:CMP AL,61H
JB ISFNM_NOFNM
CMP AL,7AH
JA ISFNM_NOFNM
CLC
JMP ISFNM_OK
ISFNM_NOFNM:STC
ISFNM_OK:RET
ISFNM ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRFN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRFN1:CALL GETCH
CMP AL,CR
JZ GETSTRFN5
CMP AL,BACKSPACE
JNZ GETSTRFN4
CMP BX,0
JZ GETSTRFN2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRFN1
GETSTRFN2:CALL BELL
JMP GETSTRFN1
GETSTRFN4:CMP BX,78
JZ GETSTRFN2
CALL ISFNM
JC GETSTRFN2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRFN1
GETSTRFN5:CMP BX,1
JB GETSTRFN2
MOV AL,0
MOV [BX][DI+2],AL
INC BX
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRFN_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRFN ENDP
END A10MAIN
17-5.编写程序，允许用户键入零件号（3个字符）、零件种类（12个字符）以及单价（xxx.xx）。
程序要建立一个磁盘文件，其中的记录含有这些信息。记住要将单价从ASCII码转换为二进制数。下面是输入数据的例子：
零件号         零件名         单价         零件号         零件名         单价
023         Assemblers    00525         122         Lifters         12320
024         Linkages        00630         124         Processors  12535
027         Compilers      00725         127         Labelers      01560
049         Compressors   01020       232         Bailers         07345
114         Extractors        11750       237         Grinders      09760
117         Haulers            01530       999                            00000
测试通过的完整程序如下
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
FNAME_DST DB 128 DUP (0)
GET_BUF DB 128 DUP (0)
DIS_BUF DB 128 DUP (0)
MESS_FNDST DB 'Please input destination filename:','$'
MESS_STOCKNO DB 'Please input stock no:','$'
MESS_STOCKNM DB 'Please input stock name:','$'
MESS_STOCKRT DB 'Please input stock rate:','$'
HANDLE_DST DW 0
MESS_CREAERR DB 'Can not create file',07H,'$'
MESS_WRITERR DB 'Writing error',07H,'$'
res_dx dw 0
res_cx dw 0
res_bx dw 0
res_ax dw 0
num_dx dw 0
num_cx dw 0
num_bx dw 0
num_ax dw 0
val_dx dw 0
val_cx dw 0
val_bx dw 0
val_ax dw 0
mul_table dd 1,10,100,1000,10000,100000,1000000,10000000,100000000
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG,ES:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV ES,AX
CALL CMPFILE
MOV AH,4CH
INT 21H
ISFNM PROC
CMP AL,2BH
JB ISFNM_NOFNM
CMP AL,3BH
JA ISFNM_NODEC1
CLC
JMP ISFNM_OK
ISFNM_NODEC1:CMP AL,41H
JB ISFNM_NOFNM
CMP AL,5FH
JA ISFNM_NODEC2
CLC
JMP ISFNM_OK
ISFNM_NODEC2:CMP AL,61H
JB ISFNM_NOFNM
CMP AL,7AH
JA ISFNM_NOFNM
CLC
JMP ISFNM_OK
ISFNM_NOFNM:STC
ISFNM_OK:RET
ISFNM ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRFN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRFN1:CALL GETCH
CMP AL,CR
JZ GETSTRFN5
CMP AL,BACKSPACE
JNZ GETSTRFN4
CMP BX,0
JZ GETSTRFN2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRFN1
GETSTRFN2:CALL BELL
JMP GETSTRFN1
GETSTRFN4:CMP BX,78
JZ GETSTRFN2
CALL ISFNM
JC GETSTRFN2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRFN1
GETSTRFN5:CMP BX,1
JB GETSTRFN2
MOV AL,0
MOV [BX][DI+2],AL
INC BX
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRFN_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRFN ENDP
ISDEC PROC
CMP AL,'0'
JB ISDEC_NODEC
CMP AL,'9'
JA ISDEC_NODEC
CLC
JMP ISDEC_OK
ISDEC_NODEC:STC
ISDEC_OK:RET
ISDEC ENDP
ATOBIN PROC
SUB AL,30H
CMP AL,9
JBE ATOBIN_OK
SUB AL,7
CMP AL,15
JBE ATOBIN_OK
SUB AL,20H
ATOBIN_OK:RET
ATOBIN ENDP
DTOBIN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DI,SI
ADD DI,CX
DEC DI
MOV BP,0
MOV VAL_AX,0
MOV VAL_DX,0
DTOBIN_FORJ:CMP DI,SI
JB DTOBIN_OK
MOV AL,DS:[DI]
CALL ATOBIN
MOV AH,0
MOV BX,AX
MOV AX,0
MOV DX,WORD PTR MUL_TABLE[BP]
MOV CX,WORD PTR MUL_TABLE[BP+2]
CALL MULDW
ADD VAL_AX,AX
ADC VAL_DX,BX
DTOBIN_NEXTJ:DEC DI
INC BP
INC BP
INC BP
INC BP
JMP DTOBIN_FORJ
DTOBIN_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOBIN ENDP
GETSTRD PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRD1:CALL GETCH
CMP AL,CR
JZ GETSTRD5
CMP AL,BACKSPACE
JNZ GETSTRD4
CMP BX,0
JZ GETSTRD2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRD1
GETSTRD2:CALL BELL
JMP GETSTRD1
GETSTRD4:CMP BX,5
JZ GETSTRD2
CALL ISDEC
JC GETSTRD2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRD1
GETSTRD5:
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRD_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRD ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
MULDW PROC
MOV NUM_AX,AX
MOV NUM_BX,BX
MOV NUM_CX,CX
MOV NUM_DX,DX
MOV AX,NUM_AX
MOV BX,NUM_CX
MUL BX
MOV RES_DX,DX
MOV RES_CX,AX
MOV AX,NUM_BX
MOV BX,NUM_DX
MUL BX
MOV RES_BX,DX
MOV RES_AX,AX
MOV AX,NUM_AX
MOV BX,NUM_DX
MUL BX
ADD AX,RES_BX
ADC WORD PTR RES_CX,0
ADC WORD PTR RES_DX,0
ADD DX,RES_CX
ADC WORD PTR RES_DX,0
MOV RES_CX,DX
MOV RES_BX,AX
MOV AX,NUM_BX
MOV BX,NUM_CX
MUL BX
ADD AX,RES_BX
ADC WORD PTR RES_CX,0
ADC WORD PTR RES_DX,0
ADD DX,RES_CX
ADC WORD PTR RES_DX,0
MOV RES_CX,DX
MOV RES_BX,AX
MOV DX,RES_DX
MOV CX,RES_CX
MOV BX,RES_BX
MOV AX,RES_AX
RET
MULDW ENDP
DIVDD PROC
MOV NUM_DX,DX
MOV NUM_CX,CX
MOV NUM_BX,BX
MOV NUM_AX,AX
MOV RES_BX,DI
MOV RES_AX,SI
XOR AX,AX
MOV VAL_DX,AX
MOV VAL_CX,AX
MOV VAL_BX,AX
MOV VAL_AX,AX
MOV RES_DX,AX
MOV RES_CX,AX
XOR CX,CX
DIVDD_FORJ1:CMP CX,64
JAE DIVDD_FINISHJ1
CLC
RCL NUM_AX,1
RCL NUM_BX,1
RCL NUM_CX,1
RCL NUM_DX,1
RCL RES_CX,1
RCL RES_DX,1
PUSHF
POP BX
MOV AX,RES_CX
MOV DX,RES_DX
SUB AX,RES_AX
SBB DX,RES_BX
PUSHF
TEST BL,01H
JNZ DIVDD_A1
POPF
JNC DIVDD_A2
JMP DIVDD_B1
DIVDD_A1:POPF
DIVDD_A2:MOV RES_CX,AX
MOV RES_DX,DX
STC
RCL VAL_AX,1
RCL VAL_BX,1
RCL VAL_CX,1
RCL VAL_DX,1
JMP DIVDD_NEXTJ1
DIVDD_B1:CLC
RCL VAL_AX,1
RCL VAL_BX,1
RCL VAL_CX,1
RCL VAL_DX,1
DIVDD_NEXTJ1:INC CX
JMP DIVDD_FORJ1
DIVDD_FINISHJ1:MOV DX,VAL_DX
MOV CX,VAL_CX
MOV BX,VAL_BX
MOV AX,VAL_AX
MOV DI,RES_DX
MOV SI,RES_CX
RET
DIVDD ENDP
ISASC PROC
CMP AL,20H
JB ISASC_NOASC
CMP AL,7EH
JA ISASC_NOASC
CLC
JMP ISASC_OK
ISASC_NOASC:STC
ISASC_OK:RET
ISASC ENDP
GETSTRASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRASC1:CALL GETCH
CMP AL,CR
JZ GETSTRASC5
CMP AL,BACKSPACE
JNZ GETSTRASC4
CMP BX,0
JZ GETSTRASC2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRASC1
GETSTRASC2:CALL BELL
JMP GETSTRASC1
GETSTRASC4:CMP BX,12
JZ GETSTRASC2
CALL ISASC
JC GETSTRASC2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRASC1
GETSTRASC5:
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRASC_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRASC ENDP
DTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
CMP DX,0
JNZ DTOASC1
CMP AX,0
JNZ DTOASC1
MOV AL,'0'
CALL PUTCH
JMP DTOASC_OK
DTOASC1:mov di,0
divide_asc:mov cx,dx
jcxz finish_s_asc
divide_s_asc:mov cx,0AH
call divdw
inc di
push cx
jmp divide_asc
finish_s_asc:mov cx,ax
jcxz finish_asc
jmp divide_s_asc
finish_asc:mov cx,di
jcxz DTOASC_OK
string_asc:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string_asc
DTOASC_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOASC ENDP
DDTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CMP DX,0
JNZ DDTOASC1
CMP CX,0
JNZ DDTOASC1
CMP BX,0
JNZ DDTOASC1
CMP AX,0
JNZ DDTOASC1
MOV AL,'0'
CALL PUTCH
JMP DDTOASC_OK
DDTOASC1:mov bp,0
divide_ddtoasc:cmp dx,0
jz finish_s_ddtoasc1
divide_s_ddtoasc:mov di,0
mov si,10
call divdd
inc bp
push si
jmp divide_ddtoasc
finish_s_ddtoasc1:cmp cx,0
jz finish_s_ddtoasc2
jmp divide_s_ddtoasc
finish_s_ddtoasc2:cmp bx,0
jz finish_s_ddtoasc3
jmp divide_s_ddtoasc
finish_s_ddtoasc3:cmp ax,0
jz finish_ddtoasc
jmp divide_s_ddtoasc
finish_ddtoasc:mov cx,bp
jcxz DDTOASC_OK
string_ddtoasc:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string_ddtoasc
DDTOASC_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DDTOASC ENDP
CLEARDISBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
CLD
MOV AL,20H
LEA DI,DIS_BUF
MOV CX,128
REP STOSB
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
CLEARDISBUF ENDP
CMPFILE PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DX,OFFSET MESS_FNDST
CALL DISPMESS
MOV DI,OFFSET FNAME_DST
CALL GETSTRFN
MOV DX,OFFSET FNAME_DST
ADD DX,2
MOV CX,0
MOV AH,3CH
INT 21H
JNC CMPFILE_CREAOKDST
CMPFILE_CREAERRDST:MOV DX,OFFSET MESS_CREAERR
CALL DISPMESS
JMP CMPFILE_OK
CMPFILE_CREAOKDST:MOV HANDLE_DST,AX
CMPFILE_RWBUF:CALL CLEARDISBUF
MOV DX,OFFSET MESS_STOCKNO
CALL DISPMESS
MOV DI,OFFSET GET_BUF
CALL GETSTRD
MOV SI,OFFSET GET_BUF
ADD SI,2
MOV CX,WORD PTR GET_BUF
SUB CX,2
CMP CX,0
JE CMPFILE_RWFINISH
CLD
LEA DI,DIS_BUF
REP MOVSB
MOV DX,OFFSET MESS_STOCKRT
CALL DISPMESS
MOV DI,OFFSET GET_BUF
CALL GETSTRD
MOV SI,OFFSET GET_BUF
ADD SI,2
MOV CX,WORD PTR GET_BUF
SUB CX,2
CMP CX,0
JE CMPFILE_RWFINISH
CALL DTOBIN
MOV AX,VAL_AX
LEA DI,DIS_BUF+40
MOV ES:[DI],AX
MOV DX,OFFSET MESS_STOCKNM
CALL DISPMESS
MOV DI,OFFSET GET_BUF
CALL GETSTRASC
MOV SI,OFFSET GET_BUF
ADD SI,2
MOV CX,WORD PTR GET_BUF
SUB CX,2
CMP CX,0
JE CMPFILE_WRITEDISBUF
CLD
LEA DI,DIS_BUF+20
REP MOVSB
CMPFILE_WRITEDISBUF:MOV CX,60
MOV BX,HANDLE_DST
MOV DX,OFFSET DIS_BUF
MOV AH,40H
INT 21H
JC CMPFILE_WRITERR
JMP CMPFILE_RWBUF
CMPFILE_WRITERR:MOV DX,OFFSET MESS_WRITERR
CALL DISPMESS
JMP CMPFILE_RWFINISH
CMPFILE_RWFINISH:
MOV BX,HANDLE_DST
MOV AH,3EH
INT 21H
CMPFILE_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
CMPFILE ENDP
CSEG ENDS
END START
17-6.编写程序，显示17-5题建立的文件的内容。程序必须将价格的二进制值转换为ASCII格式。
测试通过的完整程序如下
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
FNAME_SRC DB 128 DUP (0)
STR_BLANK DB 80 DUP (20H)
GET_BUF DB 128 DUP (0)
DIS_BUF DB 128 DUP (0)
DIS_LEN DW 0
MESS_FNSRC DB 'Please input source filename:','$'
MESS_STOCKNO DB 'Please input stock no:','$'
MESS_STOCKNM DB 'Please input stock name:','$'
MESS_STOCKRT DB 'Please input stock rate:','$'
HANDLE_SRC DW 0
MESS_CREAERR DB 'Can not create file',07H,'$'
MESS_WRITERR DB 'Writing error',07H,'$'
MESS_OPENERR DB 'Can not open file',07H,'$'
MESS_READERR DB 'Reading error',07h,'$'
res_dx dw 0
res_cx dw 0
res_bx dw 0
res_ax dw 0
num_dx dw 0
num_cx dw 0
num_bx dw 0
num_ax dw 0
val_dx dw 0
val_cx dw 0
val_bx dw 0
val_ax dw 0
mul_table dd 1,10,100,1000,10000,100000,1000000,10000000,100000000
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG,ES:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV ES,AX
CALL CMPFILE
MOV AH,4CH
INT 21H
ISFNM PROC
CMP AL,2BH
JB ISFNM_NOFNM
CMP AL,3BH
JA ISFNM_NODEC1
CLC
JMP ISFNM_OK
ISFNM_NODEC1:CMP AL,41H
JB ISFNM_NOFNM
CMP AL,5FH
JA ISFNM_NODEC2
CLC
JMP ISFNM_OK
ISFNM_NODEC2:CMP AL,61H
JB ISFNM_NOFNM
CMP AL,7AH
JA ISFNM_NOFNM
CLC
JMP ISFNM_OK
ISFNM_NOFNM:STC
ISFNM_OK:RET
ISFNM ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRFN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRFN1:CALL GETCH
CMP AL,CR
JZ GETSTRFN5
CMP AL,BACKSPACE
JNZ GETSTRFN4
CMP BX,0
JZ GETSTRFN2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRFN1
GETSTRFN2:CALL BELL
JMP GETSTRFN1
GETSTRFN4:CMP BX,78
JZ GETSTRFN2
CALL ISFNM
JC GETSTRFN2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRFN1
GETSTRFN5:CMP BX,1
JB GETSTRFN2
MOV AL,0
MOV [BX][DI+2],AL
INC BX
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRFN_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRFN ENDP
ISDEC PROC
CMP AL,'0'
JB ISDEC_NODEC
CMP AL,'9'
JA ISDEC_NODEC
CLC
JMP ISDEC_OK
ISDEC_NODEC:STC
ISDEC_OK:RET
ISDEC ENDP
ATOBIN PROC
SUB AL,30H
CMP AL,9
JBE ATOBIN_OK
SUB AL,7
CMP AL,15
JBE ATOBIN_OK
SUB AL,20H
ATOBIN_OK:RET
ATOBIN ENDP
DTOBIN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DI,SI
ADD DI,CX
DEC DI
MOV BP,0
MOV VAL_AX,0
MOV VAL_DX,0
DTOBIN_FORJ:CMP DI,SI
JB DTOBIN_OK
MOV AL,DS:[DI]
CALL ATOBIN
MOV AH,0
MOV BX,AX
MOV AX,0
MOV DX,WORD PTR MUL_TABLE[BP]
MOV CX,WORD PTR MUL_TABLE[BP+2]
CALL MULDW
ADD VAL_AX,AX
ADC VAL_DX,BX
DTOBIN_NEXTJ:DEC DI
INC BP
INC BP
INC BP
INC BP
JMP DTOBIN_FORJ
DTOBIN_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOBIN ENDP
GETSTRD PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRD1:CALL GETCH
CMP AL,CR
JZ GETSTRD5
CMP AL,BACKSPACE
JNZ GETSTRD4
CMP BX,0
JZ GETSTRD2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRD1
GETSTRD2:CALL BELL
JMP GETSTRD1
GETSTRD4:CMP BX,5
JZ GETSTRD2
CALL ISDEC
JC GETSTRD2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRD1
GETSTRD5:
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRD_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRD ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
MULDW PROC
MOV NUM_AX,AX
MOV NUM_BX,BX
MOV NUM_CX,CX
MOV NUM_DX,DX
MOV AX,NUM_AX
MOV BX,NUM_CX
MUL BX
MOV RES_DX,DX
MOV RES_CX,AX
MOV AX,NUM_BX
MOV BX,NUM_DX
MUL BX
MOV RES_BX,DX
MOV RES_AX,AX
MOV AX,NUM_AX
MOV BX,NUM_DX
MUL BX
ADD AX,RES_BX
ADC WORD PTR RES_CX,0
ADC WORD PTR RES_DX,0
ADD DX,RES_CX
ADC WORD PTR RES_DX,0
MOV RES_CX,DX
MOV RES_BX,AX
MOV AX,NUM_BX
MOV BX,NUM_CX
MUL BX
ADD AX,RES_BX
ADC WORD PTR RES_CX,0
ADC WORD PTR RES_DX,0
ADD DX,RES_CX
ADC WORD PTR RES_DX,0
MOV RES_CX,DX
MOV RES_BX,AX
MOV DX,RES_DX
MOV CX,RES_CX
MOV BX,RES_BX
MOV AX,RES_AX
RET
MULDW ENDP
DIVDD PROC
MOV NUM_DX,DX
MOV NUM_CX,CX
MOV NUM_BX,BX
MOV NUM_AX,AX
MOV RES_BX,DI
MOV RES_AX,SI
XOR AX,AX
MOV VAL_DX,AX
MOV VAL_CX,AX
MOV VAL_BX,AX
MOV VAL_AX,AX
MOV RES_DX,AX
MOV RES_CX,AX
XOR CX,CX
DIVDD_FORJ1:CMP CX,64
JAE DIVDD_FINISHJ1
CLC
RCL NUM_AX,1
RCL NUM_BX,1
RCL NUM_CX,1
RCL NUM_DX,1
RCL RES_CX,1
RCL RES_DX,1
PUSHF
POP BX
MOV AX,RES_CX
MOV DX,RES_DX
SUB AX,RES_AX
SBB DX,RES_BX
PUSHF
TEST BL,01H
JNZ DIVDD_A1
POPF
JNC DIVDD_A2
JMP DIVDD_B1
DIVDD_A1:POPF
DIVDD_A2:MOV RES_CX,AX
MOV RES_DX,DX
STC
RCL VAL_AX,1
RCL VAL_BX,1
RCL VAL_CX,1
RCL VAL_DX,1
JMP DIVDD_NEXTJ1
DIVDD_B1:CLC
RCL VAL_AX,1
RCL VAL_BX,1
RCL VAL_CX,1
RCL VAL_DX,1
DIVDD_NEXTJ1:INC CX
JMP DIVDD_FORJ1
DIVDD_FINISHJ1:MOV DX,VAL_DX
MOV CX,VAL_CX
MOV BX,VAL_BX
MOV AX,VAL_AX
MOV DI,RES_DX
MOV SI,RES_CX
RET
DIVDD ENDP
ISASC PROC
CMP AL,20H
JB ISASC_NOASC
CMP AL,7EH
JA ISASC_NOASC
CLC
JMP ISASC_OK
ISASC_NOASC:STC
ISASC_OK:RET
ISASC ENDP
GETSTRASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRASC1:CALL GETCH
CMP AL,CR
JZ GETSTRASC5
CMP AL,BACKSPACE
JNZ GETSTRASC4
CMP BX,0
JZ GETSTRASC2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRASC1
GETSTRASC2:CALL BELL
JMP GETSTRASC1
GETSTRASC4:CMP BX,12
JZ GETSTRASC2
CALL ISASC
JC GETSTRASC2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRASC1
GETSTRASC5:
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRASC_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRASC ENDP
DTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
CMP DX,0
JNZ DTOASC1
CMP AX,0
JNZ DTOASC1
MOV AL,'0'
CALL PUTCH
JMP DTOASC_OK
DTOASC1:mov di,0
divide_asc:mov cx,dx
jcxz finish_s_asc
divide_s_asc:mov cx,0AH
call divdw
inc di
push cx
jmp divide_asc
finish_s_asc:mov cx,ax
jcxz finish_asc
jmp divide_s_asc
finish_asc:mov cx,di
jcxz DTOASC_OK
string_asc:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string_asc
DTOASC_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOASC ENDP
DDTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CMP DX,0
JNZ DDTOASC1
CMP CX,0
JNZ DDTOASC1
CMP BX,0
JNZ DDTOASC1
CMP AX,0
JNZ DDTOASC1
MOV AL,'0'
CALL PUTCH
JMP DDTOASC_OK
DDTOASC1:mov bp,0
divide_ddtoasc:cmp dx,0
jz finish_s_ddtoasc1
divide_s_ddtoasc:mov di,0
mov si,10
call divdd
inc bp
push si
jmp divide_ddtoasc
finish_s_ddtoasc1:cmp cx,0
jz finish_s_ddtoasc2
jmp divide_s_ddtoasc
finish_s_ddtoasc2:cmp bx,0
jz finish_s_ddtoasc3
jmp divide_s_ddtoasc
finish_s_ddtoasc3:cmp ax,0
jz finish_ddtoasc
jmp divide_s_ddtoasc
finish_ddtoasc:mov cx,bp
jcxz DDTOASC_OK
string_ddtoasc:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string_ddtoasc
DDTOASC_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DDTOASC ENDP
CLEARDISBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
CLD
MOV AL,20H
LEA DI,DIS_BUF
MOV CX,128
REP STOSB
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
CLEARDISBUF ENDP
CMPFILE PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DX,OFFSET MESS_FNSRC
CALL DISPMESS
MOV DI,OFFSET FNAME_SRC
CALL GETSTRFN
MOV DX,OFFSET FNAME_SRC
ADD DX,2
MOV AX,3D00H
INT 21H
JNC CMPFILE_OPENOKSRC
CMPFILE_OPENERRSRC:MOV DX,OFFSET MESS_OPENERR
CALL DISPMESS
JMP CMPFILE_OK
CMPFILE_OPENOKSRC:MOV HANDLE_SRC,AX
MOV AX,0003H
INT 10H
CMPFILE_RWBUF:CALL CLEARDISBUF
MOV DX,OFFSET DIS_BUF
MOV CX,60
MOV BX,HANDLE_SRC
MOV AH,3FH
INT 21H
JC CMPFILE_READERR
CMP AX,0
JZ CMPFILE_RWFINISH
LEA SI,DIS_BUF+40
MOV DX,0
MOV AX,DS:[SI]
MOV WORD PTR DIS_LEN,40
CALL DTOBUF
LEA SI,DIS_BUF
MOV CX,60
CLD
CMPFILE_S_DISBUF:LODSB
CALL PUTCH
LOOP CMPFILE_S_DISBUF
CALL NEWLINE
JMP CMPFILE_RWBUF
CMPFILE_READERR:MOV DX,OFFSET MESS_READERR
CALL DISPMESS
JMP CMPFILE_RWFINISH
CMPFILE_RWFINISH:
MOV BX,HANDLE_SRC
MOV AH,3EH
INT 21H
CMPFILE_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
CMPFILE ENDP
DTOBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CMP DX,0
JNZ DTOBUF1
CMP AX,0
JNZ DTOBUF1
MOV SI,WORD PTR DIS_LEN
MOV BYTE PTR DIS_BUF[SI],'0'
INC SI
MOV WORD PTR DIS_LEN,SI
JMP DTOBUF_OK
DTOBUF1:MOV SI,WORD PTR DIS_LEN
mov bp,0
divide_dtobuf:cmp dx,0
jz finish_s_dtobuf1
divide_s_dtobuf:mov cx,10
call divdw
inc bp
push cx
jmp divide_dtobuf
finish_s_dtobuf1:cmp ax,0
jz finish_dtobuf
jmp divide_s_dtobuf
finish_dtobuf:mov cx,bp
jcxz DTOBUF_OK
string_dtobuf:pop bx
add bx,30h
MOV BYTE PTR DIS_BUF[SI],BL
INC SI
loop string_dtobuf
MOV WORD PTR DIS_LEN,SI
MOV CX,16
SUB CX,BP
MOV SI,OFFSET STR_BLANK
CALL STRTOBUF
DTOBUF_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOBUF ENDP
STRTOBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
JCXZ STRTOBUF_OK
MOV DI,SI
MOV BX,WORD PTR DIS_LEN
MOV BP,0
STRTOBUF_FORI1:CMP BP,CX
JAE STRTOBUF_FINISHI1
MOV AL,DS:[DI]
MOV BYTE PTR DIS_BUF[BX],AL
INC BX
STRTOBUF_NEXTI1:INC BP
INC DI
JMP STRTOBUF_FORI1
STRTOBUF_FINISHI1:MOV WORD PTR DIS_LEN,BX
STRTOBUF_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
STRTOBUF ENDP
CSEG ENDS
END START
17-7.利用17-5题建立的文件按下列要求编写程序：
（a）把记录全部读入到内存的一个表中，（b）请求一个用户键入零件号和总量，（c）按零件号搜索表，
（d）如果找到零件号，则用单价表来计算零件的价格（总量×单价），（e）显示零件名和价格。允许键盘请求任何零件号。
测试通过的完整程序如下
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
FNAME_SRC DB 128 DUP (0)
STR_BLANK DB 80 DUP (20H)
GET_BUF DB 128 DUP (0)
DIS_BUF DB 128 DUP (0)
DIS_LEN DW 0
MESS_FNSRC DB 'Please input source filename:','$'
MESS_STOCKNO DB 'Please input stock no:','$'
MESS_STOCKNM DB 'Please input stock name:','$'
MESS_STOCKRT DB 'Please input stock rate:','$'
HANDLE_SRC DW 0
MESS_CREAERR DB 'Can not create file',07H,'$'
MESS_WRITERR DB 'Writing error',07H,'$'
MESS_OPENERR DB 'Can not open file',07H,'$'
MESS_READERR DB 'Reading error',07h,'$'
res_dx dw 0
res_cx dw 0
res_bx dw 0
res_ax dw 0
num_dx dw 0
num_cx dw 0
num_bx dw 0
num_ax dw 0
val_dx dw 0
val_cx dw 0
val_bx dw 0
val_ax dw 0
val_di dw 0
mul_table dd 1,10,100,1000,10000,100000,1000000,10000000,100000000
MESS_STKNO DB 'Please input stock no:'
MESS_QTYNO DB 'Please input quantity:'
MESS_ERROR DB 'input error!'
MESS_NOTFIND DB 'not find!   '
LEN_STKNO EQU 3
LEN_DESCR EQU 12
LEN_RATE EQU 5
LEN_RECD EQU 60
STOCK_TBL DB 30 DUP (60 DUP (20H))
ASCPROD DB 16 DUP (30H)
BINPROD DW 0
BINQTY DW 0
BINRATE DW 0
DECIND DB 0
MULT10 DW 1
NODECIMS DW 0
ADJUST DW ?
SHIFT DW ?
TENWD DW 10
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG,ES:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV ES,AX
CALL CMPFILE
MOV AH,4CH
INT 21H
ISFNM PROC
CMP AL,2BH
JB ISFNM_NOFNM
CMP AL,3BH
JA ISFNM_NODEC1
CLC
JMP ISFNM_OK
ISFNM_NODEC1:CMP AL,41H
JB ISFNM_NOFNM
CMP AL,5FH
JA ISFNM_NODEC2
CLC
JMP ISFNM_OK
ISFNM_NODEC2:CMP AL,61H
JB ISFNM_NOFNM
CMP AL,7AH
JA ISFNM_NOFNM
CLC
JMP ISFNM_OK
ISFNM_NOFNM:STC
ISFNM_OK:RET
ISFNM ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRFN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRFN1:CALL GETCH
CMP AL,CR
JZ GETSTRFN5
CMP AL,BACKSPACE
JNZ GETSTRFN4
CMP BX,0
JZ GETSTRFN2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRFN1
GETSTRFN2:CALL BELL
JMP GETSTRFN1
GETSTRFN4:CMP BX,78
JZ GETSTRFN2
CALL ISFNM
JC GETSTRFN2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRFN1
GETSTRFN5:CMP BX,1
JB GETSTRFN2
MOV AL,0
MOV [BX][DI+2],AL
INC BX
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRFN_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRFN ENDP
ISDEC PROC
CMP AL,'0'
JB ISDEC_NODEC
CMP AL,'9'
JA ISDEC_NODEC
CLC
JMP ISDEC_OK
ISDEC_NODEC:STC
ISDEC_OK:RET
ISDEC ENDP
ATOBIN PROC
SUB AL,30H
CMP AL,9
JBE ATOBIN_OK
SUB AL,7
CMP AL,15
JBE ATOBIN_OK
SUB AL,20H
ATOBIN_OK:RET
ATOBIN ENDP
DTOBIN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DI,SI
ADD DI,CX
DEC DI
MOV BP,0
MOV VAL_AX,0
MOV VAL_DX,0
DTOBIN_FORJ:CMP DI,SI
JB DTOBIN_OK
MOV AL,DS:[DI]
CALL ATOBIN
MOV AH,0
MOV BX,AX
MOV AX,0
MOV DX,WORD PTR MUL_TABLE[BP]
MOV CX,WORD PTR MUL_TABLE[BP+2]
CALL MULDW
ADD VAL_AX,AX
ADC VAL_DX,BX
DTOBIN_NEXTJ:DEC DI
INC BP
INC BP
INC BP
INC BP
JMP DTOBIN_FORJ
DTOBIN_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOBIN ENDP
GETSTRD PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRD1:CALL GETCH
CMP AL,CR
JZ GETSTRD5
CMP AL,BACKSPACE
JNZ GETSTRD4
CMP BX,0
JZ GETSTRD2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRD1
GETSTRD2:CALL BELL
JMP GETSTRD1
GETSTRD4:CMP BX,5
JZ GETSTRD2
CALL ISDEC
JC GETSTRD2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRD1
GETSTRD5:
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRD_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRD ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
MULDW PROC
MOV NUM_AX,AX
MOV NUM_BX,BX
MOV NUM_CX,CX
MOV NUM_DX,DX
MOV AX,NUM_AX
MOV BX,NUM_CX
MUL BX
MOV RES_DX,DX
MOV RES_CX,AX
MOV AX,NUM_BX
MOV BX,NUM_DX
MUL BX
MOV RES_BX,DX
MOV RES_AX,AX
MOV AX,NUM_AX
MOV BX,NUM_DX
MUL BX
ADD AX,RES_BX
ADC WORD PTR RES_CX,0
ADC WORD PTR RES_DX,0
ADD DX,RES_CX
ADC WORD PTR RES_DX,0
MOV RES_CX,DX
MOV RES_BX,AX
MOV AX,NUM_BX
MOV BX,NUM_CX
MUL BX
ADD AX,RES_BX
ADC WORD PTR RES_CX,0
ADC WORD PTR RES_DX,0
ADD DX,RES_CX
ADC WORD PTR RES_DX,0
MOV RES_CX,DX
MOV RES_BX,AX
MOV DX,RES_DX
MOV CX,RES_CX
MOV BX,RES_BX
MOV AX,RES_AX
RET
MULDW ENDP
DIVDD PROC
MOV NUM_DX,DX
MOV NUM_CX,CX
MOV NUM_BX,BX
MOV NUM_AX,AX
MOV RES_BX,DI
MOV RES_AX,SI
XOR AX,AX
MOV VAL_DX,AX
MOV VAL_CX,AX
MOV VAL_BX,AX
MOV VAL_AX,AX
MOV RES_DX,AX
MOV RES_CX,AX
XOR CX,CX
DIVDD_FORJ1:CMP CX,64
JAE DIVDD_FINISHJ1
CLC
RCL NUM_AX,1
RCL NUM_BX,1
RCL NUM_CX,1
RCL NUM_DX,1
RCL RES_CX,1
RCL RES_DX,1
PUSHF
POP BX
MOV AX,RES_CX
MOV DX,RES_DX
SUB AX,RES_AX
SBB DX,RES_BX
PUSHF
TEST BL,01H
JNZ DIVDD_A1
POPF
JNC DIVDD_A2
JMP DIVDD_B1
DIVDD_A1:POPF
DIVDD_A2:MOV RES_CX,AX
MOV RES_DX,DX
STC
RCL VAL_AX,1
RCL VAL_BX,1
RCL VAL_CX,1
RCL VAL_DX,1
JMP DIVDD_NEXTJ1
DIVDD_B1:CLC
RCL VAL_AX,1
RCL VAL_BX,1
RCL VAL_CX,1
RCL VAL_DX,1
DIVDD_NEXTJ1:INC CX
JMP DIVDD_FORJ1
DIVDD_FINISHJ1:MOV DX,VAL_DX
MOV CX,VAL_CX
MOV BX,VAL_BX
MOV AX,VAL_AX
MOV DI,RES_DX
MOV SI,RES_CX
RET
DIVDD ENDP
ISASC PROC
CMP AL,20H
JB ISASC_NOASC
CMP AL,7EH
JA ISASC_NOASC
CLC
JMP ISASC_OK
ISASC_NOASC:STC
ISASC_OK:RET
ISASC ENDP
GETSTRASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRASC1:CALL GETCH
CMP AL,CR
JZ GETSTRASC5
CMP AL,BACKSPACE
JNZ GETSTRASC4
CMP BX,0
JZ GETSTRASC2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRASC1
GETSTRASC2:CALL BELL
JMP GETSTRASC1
GETSTRASC4:CMP BX,12
JZ GETSTRASC2
CALL ISASC
JC GETSTRASC2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRASC1
GETSTRASC5:
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRASC_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRASC ENDP
DTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
CMP DX,0
JNZ DTOASC1
CMP AX,0
JNZ DTOASC1
MOV AL,'0'
CALL PUTCH
JMP DTOASC_OK
DTOASC1:mov di,0
divide_asc:mov cx,dx
jcxz finish_s_asc
divide_s_asc:mov cx,0AH
call divdw
inc di
push cx
jmp divide_asc
finish_s_asc:mov cx,ax
jcxz finish_asc
jmp divide_s_asc
finish_asc:mov cx,di
jcxz DTOASC_OK
string_asc:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string_asc
DTOASC_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOASC ENDP
DDTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CMP DX,0
JNZ DDTOASC1
CMP CX,0
JNZ DDTOASC1
CMP BX,0
JNZ DDTOASC1
CMP AX,0
JNZ DDTOASC1
MOV AL,'0'
CALL PUTCH
JMP DDTOASC_OK
DDTOASC1:mov bp,0
divide_ddtoasc:cmp dx,0
jz finish_s_ddtoasc1
divide_s_ddtoasc:mov di,0
mov si,10
call divdd
inc bp
push si
jmp divide_ddtoasc
finish_s_ddtoasc1:cmp cx,0
jz finish_s_ddtoasc2
jmp divide_s_ddtoasc
finish_s_ddtoasc2:cmp bx,0
jz finish_s_ddtoasc3
jmp divide_s_ddtoasc
finish_s_ddtoasc3:cmp ax,0
jz finish_ddtoasc
jmp divide_s_ddtoasc
finish_ddtoasc:mov cx,bp
jcxz DDTOASC_OK
string_ddtoasc:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string_ddtoasc
DDTOASC_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DDTOASC ENDP
CLEARDISBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
CLD
MOV AL,20H
LEA DI,DIS_BUF
MOV CX,128
REP STOSB
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
CLEARDISBUF ENDP
CMPFILE PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DX,OFFSET MESS_FNSRC
CALL DISPMESS
MOV DI,OFFSET FNAME_SRC
CALL GETSTRFN
MOV DX,OFFSET FNAME_SRC
ADD DX,2
MOV AX,3D00H
INT 21H
JNC CMPFILE_OPENOKSRC
CMPFILE_OPENERRSRC:MOV DX,OFFSET MESS_OPENERR
CALL DISPMESS
JMP CMPFILE_OK
CMPFILE_OPENOKSRC:MOV HANDLE_SRC,AX
MOV AX,0003H
INT 10H
LEA BP,STOCK_TBL
CMPFILE_RWBUF:MOV DX,BP
MOV CX,60
MOV BX,HANDLE_SRC
MOV AH,3FH
INT 21H
JC CMPFILE_READERR
CMP AX,0
JZ CMPFILE_RWFINISHFIND
ADD BP,60
JMP CMPFILE_RWBUF
CMPFILE_RWFINISHFIND:MOV BX,HANDLE_SRC
MOV AH,3EH
INT 21H
CMPFILE_A10:CALL Q10CLEAR
MOV BP,OFFSET MESS_STKNO
MOV CX,22
MOV DH,10
MOV DL,10
CALL G10DISPLY
MOV DI,OFFSET GET_BUF
CALL GETSTRD
MOV SI,OFFSET GET_BUF
ADD SI,2
MOV CX,WORD PTR GET_BUF
SUB CX,2
CMP CX,0
JE CMPFILE_OK
CMP CX,LEN_STKNO
JNE CMPFILE_A20
CLD
LEA DI,STOCK_TBL
CMPFILE_S20:MOV CX,LEN_STKNO
MOV SI,OFFSET GET_BUF
ADD SI,2
REPE CMPSB
JE CMPFILE_S30
JB CMPFILE_S40
ADD DI,CX
ADD DI,57
JMP CMPFILE_S20
CMPFILE_S30:MOV WORD PTR VAL_DI,DI
MOV BP,DI
ADD BP,17
MOV AX,1301H
MOV BX,0061H
MOV CX,LEN_DESCR
MOV DX,0812H
INT 10H
MOV BP,OFFSET MESS_QTYNO
MOV CX,22
MOV DH,11
MOV DL,10
CALL G10DISPLY
MOV DI,OFFSET GET_BUF
CALL GETSTRD
MOV SI,OFFSET GET_BUF
ADD SI,2
MOV CX,WORD PTR GET_BUF
SUB CX,2
CMP CX,0
JE CMPFILE_A20
CALL DTOBIN
MOV DX,VAL_DX
MOV AX,VAL_AX
MOV BINQTY,AX
MOV WORD PTR NODECIMS,2
MOV SI,WORD PTR VAL_DI
ADD SI,17
ADD SI,20
MOV AX,DS:[SI]
MOV BINRATE,AX
CALL E10MULT
CALL F10PROD
CALL G10FORMAT
JMP CMPFILE_S90
CMPFILE_S40:
MOV BP,OFFSET MESS_NOTFIND
MOV CX,12
MOV DH,12
MOV DL,39
CALL G10DISPLY
JMP CMPFILE_S90
CMPFILE_S90:
push dx
mov dx,9000h
call delay
pop dx
JMP CMPFILE_A10
CMPFILE_A20:
MOV BP,OFFSET MESS_ERROR
MOV CX,12
MOV DH,12
MOV DL,39
CALL G10DISPLY
push dx
mov dx,9000h
call delay
pop dx
JMP CMPFILE_A10
CMPFILE_READERR:MOV DX,OFFSET MESS_READERR
CALL DISPMESS
JMP CMPFILE_RWFINISH
CMPFILE_RWFINISH:
MOV BX,HANDLE_SRC
MOV AH,3EH
INT 21H
CMPFILE_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
CMPFILE ENDP
DTOBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CMP DX,0
JNZ DTOBUF1
CMP AX,0
JNZ DTOBUF1
MOV SI,WORD PTR DIS_LEN
MOV BYTE PTR DIS_BUF[SI],'0'
INC SI
MOV WORD PTR DIS_LEN,SI
JMP DTOBUF_OK
DTOBUF1:MOV SI,WORD PTR DIS_LEN
mov bp,0
divide_dtobuf:cmp dx,0
jz finish_s_dtobuf1
divide_s_dtobuf:mov cx,10
call divdw
inc bp
push cx
jmp divide_dtobuf
finish_s_dtobuf1:cmp ax,0
jz finish_dtobuf
jmp divide_s_dtobuf
finish_dtobuf:mov cx,bp
jcxz DTOBUF_OK
string_dtobuf:pop bx
add bx,30h
MOV BYTE PTR DIS_BUF[SI],BL
INC SI
loop string_dtobuf
MOV WORD PTR DIS_LEN,SI
MOV CX,16
SUB CX,BP
MOV SI,OFFSET STR_BLANK
CALL STRTOBUF
DTOBUF_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOBUF ENDP
STRTOBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
JCXZ STRTOBUF_OK
MOV DI,SI
MOV BX,WORD PTR DIS_LEN
MOV BP,0
STRTOBUF_FORI1:CMP BP,CX
JAE STRTOBUF_FINISHI1
MOV AL,DS:[DI]
MOV BYTE PTR DIS_BUF[BX],AL
INC BX
STRTOBUF_NEXTI1:INC BP
INC DI
JMP STRTOBUF_FORI1
STRTOBUF_FINISHI1:MOV WORD PTR DIS_LEN,BX
STRTOBUF_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
STRTOBUF ENDP
G10DISPLY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,1301H
MOV BX,0016H
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
G10DISPLY ENDP
Q10CLEAR PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,0600H
MOV BH,61H
MOV CX,0000H
MOV DX,184FH
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
Q10CLEAR ENDP
DELAY PROC NEAR
push ax
push dx
mov ax,0
delay_s:sub ax,1
sbb dx,0
cmp ax,0
jne delay_s
cmp dx,0
jne delay_s
pop dx
pop ax
ret
DELAY ENDP
E10MULT PROC NEAR
MOV CX,16
LEA DI,ASCPROD
MOV AL,30H
CLD
REP STOSB
MOV WORD PTR SHIFT,10
MOV WORD PTR ADJUST,0
MOV BP,10
MOV CX,NODECIMS
CMP CL,4
JA E40
SUB CX,2
JLE E30
MOV WORD PTR NODECIMS,2
MOV AX,1
E20:MUL BP
LOOP E20
MOV WORD PTR SHIFT,AX
SHR AX,1
MOV WORD PTR ADJUST,AX
E30:MOV AX,BINQTY
MUL WORD PTR BINRATE
ADD AX,ADJUST
ADC DX,0
CMP WORD PTR ADJUST,0
JZ E80
JMP E50
E40:XOR AX,AX
JMP E70
E50:MOV CX,WORD PTR SHIFT
CALL DIVDW
JMP E80
E70:XOR DX,DX
E80:RET
E10MULT ENDP
F10PROD PROC NEAR
LEA SI,ASCPROD+11
MOV BYTE PTR DS:[SI],'.'
ADD SI,NODECIMS
F30:CMP BYTE PTR DS:[SI],'.'
JNE F40
DEC SI
F40:CMP DX,0
JNZ F50
CMP AX,0
JZ F60
F50:MOV CX,TENWD
CALL DIVDW
OR CL,30H
MOV DS:[SI],CL
DEC SI
JMP F30
F60:RET
F10PROD ENDP
G10FORMAT PROC NEAR
MOV CX,16
LEA SI,ASCPROD
G20:CMP BYTE PTR DS:[SI],30H
JNE G30
MOV BYTE PTR DS:[SI],20H
INC SI
LOOP G20
G30:LEA BP,ASCPROD
MOV CX,16
MOV DX,0912H
CALL G10DISPLY
RET
G10FORMAT ENDP
J10ASCBIN PROC NEAR
MOV WORD PTR MULT10,1
MOV WORD PTR BINPROD,0
MOV BYTE PTR DECIND,0
XOR BX,BX
MOV BP,10
J20:MOV AL,DS:[SI]
CMP AL,'.'
JNE J30
MOV BYTE PTR DECIND,1
JMP J40
J30:AND AX,000FH
MUL WORD PTR MULT10
ADD WORD PTR BINPROD,AX
MOV AX,MULT10
MUL BP
MOV WORD PTR MULT10,AX
CMP BYTE PTR DECIND,0
JNZ J40
INC BX
J40:DEC SI
LOOP J20
CMP BYTE PTR DECIND,0
JZ J90
ADD WORD PTR NODECIMS,BX
J90:RET
J10ASCBIN ENDP
CSEG ENDS
END START
17-8.一个文件由100个记录组成，每个记录的长度为256字节。编写指令设置文件指针指向（a）文件开始，（b）第20个记录，（c）文件末尾。
MOV AH,42H   ;重定位指针
MOV AL,00H   ;从文件首开始
MOV BX,HANDLE1   ;设置文件代号
MOV CX,0000H   ;偏移量高位部分
MOV DX,0000H   ;偏移量低位部分
INT 21H   ;调用中断服务例程
JC error
...
error:
...

19*256=4864=1300H
MOV AH,42H   ;重定位指针
MOV AL,00H   ;从文件首开始
MOV BX,HANDLE1   ;设置文件代号
MOV CX,0000H   ;偏移量高位部分
MOV DX,1300H   ;偏移量低位部分
INT 21H   ;调用中断服务例程
JC error
...
error:
...

MOV AH,42H   ;重定位指针
MOV AL,02H   ;从文件尾开始
MOV BX,HANDLE1   ;设置文件代号
MOV CX,0000H   ;偏移量高位部分
MOV DX,0000H   ;偏移量低位部分
INT 21H   ;调用中断服务例程
JC error
...
error:
...
17-9.编写指令代码，为一个程序确定文件的大小。
FILESIZE DD 0
...
MOV AX,4202H
MOV BX,FILEHAND
MOV CX,0
MOV DX,0
INT 21H
MOV WORD PTR FILESIZE,AX
MOV WORD PTR FILESIZE+2,DX
...
17-10.修改17-6题的程序，使它能随机处理磁盘文件。定义有效的零件号及其偏移值的表。请求用户键入零件号，程序在表中查找到这个零件号。
用表中的偏移值来计算文件中的偏移值，并用INT21H的功能42H来设置文件指针。
显示零件名和单价。请求用户输入出售的数量，然后计算并显示出售的总价格（总量×单价）。
测试通过的完整程序如下
CR = 0DH
LF = 0AH
BACKSPACE = 08H
BELLCH = 07H
SSEG SEGMENT PARA STACK
DW 256 DUP (?)
SSEG ENDS
DSEG SEGMENT
FNAME_SRC DB 128 DUP (0)
STR_BLANK DB 80 DUP (20H)
GET_BUF DB 128 DUP (0)
DIS_BUF DB 128 DUP (0)
DIS_LEN DW 0
MESS_FNSRC DB 'Please input source filename:','$'
MESS_STOCKNO DB 'Please input stock no:','$'
MESS_STOCKNM DB 'Please input stock name:','$'
MESS_STOCKRT DB 'Please input stock rate:','$'
HANDLE_SRC DW 0
MESS_CREAERR DB 'Can not create file',07H,'$'
MESS_WRITERR DB 'Writing error',07H,'$'
MESS_OPENERR DB 'Can not open file',07H,'$'
MESS_READERR DB 'Reading error',07h,'$'
res_dx dw 0
res_cx dw 0
res_bx dw 0
res_ax dw 0
num_dx dw 0
num_cx dw 0
num_bx dw 0
num_ax dw 0
val_dx dw 0
val_cx dw 0
val_bx dw 0
val_ax dw 0
val_di dw 0
mul_table dd 1,10,100,1000,10000,100000,1000000,10000000,100000000
MESS_STKNO DB 'Please input stock no:'
MESS_QTYNO DB 'Please input quantity:'
MESS_ERROR DB 'input error!'
MESS_NOTFIND DB 'not find!   '
LEN_STKNO EQU 3
LEN_DESCR EQU 12
LEN_RATE EQU 5
LEN_RECD EQU 60
LEN_OFFSET EQU 7
STOCK_TBL DB 30 DUP (60 DUP (20H))
ASCPROD DB 16 DUP (30H)
BINPROD DW 0
BINQTY DW 0
BINRATE DW 0
DECIND DB 0
MULT10 DW 1
NODECIMS DW 0
ADJUST DW ?
SHIFT DW ?
TENWD DW 10
OFFSET_TBL DB '023'
                     DD 0
                     DB '024'
                     DD 60
                     DB '027'
                     DD 120
                     DB '049'
                     DD 180
                     DB '114'
                     DD 240
                     DB '117'
                     DD 300
                     DB '122'
                     DD 360
                     DB '124'
                     DD 420
                     DB '127'
                     DD 480
                     DB '232'
                     DD 540
                     DB '237'
                     DD 600
                     DB '999'
                     DD 660
DSEG ENDS
CSEG SEGMENT
ASSUME CS:CSEG,DS:DSEG,ES:DSEG
START:MOV AX,DSEG
MOV DS,AX
MOV ES,AX
CALL CMPFILE
MOV AH,4CH
INT 21H
ISFNM PROC
CMP AL,2BH
JB ISFNM_NOFNM
CMP AL,3BH
JA ISFNM_NODEC1
CLC
JMP ISFNM_OK
ISFNM_NODEC1:CMP AL,41H
JB ISFNM_NOFNM
CMP AL,5FH
JA ISFNM_NODEC2
CLC
JMP ISFNM_OK
ISFNM_NODEC2:CMP AL,61H
JB ISFNM_NOFNM
CMP AL,7AH
JA ISFNM_NOFNM
CLC
JMP ISFNM_OK
ISFNM_NOFNM:STC
ISFNM_OK:RET
ISFNM ENDP
NEWLINE PROC
PUSH AX
PUSH DX
MOV DL,0DH
MOV AH,2
INT 21H
MOV DL,0AH
MOV AH,2
INT 21H
POP DX
POP AX
RET
NEWLINE ENDP
PUTCH PROC
PUSH AX
PUSH DX
MOV DL,AL
MOV AH,2
INT 21H
POP DX
POP AX
RET
PUTCH ENDP
DISPMESS PROC
PUSH AX
MOV AH,9
INT 21H
POP AX
RET
DISPMESS ENDP
BELL PROC
PUSH AX
MOV AL,BELLCH
CALL PUTCH
POP AX
RET
BELL ENDP
GETCH PROC
MOV AH,8
INT 21H
RET
GETCH ENDP
GETSTRFN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRFN1:CALL GETCH
CMP AL,CR
JZ GETSTRFN5
CMP AL,BACKSPACE
JNZ GETSTRFN4
CMP BX,0
JZ GETSTRFN2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRFN1
GETSTRFN2:CALL BELL
JMP GETSTRFN1
GETSTRFN4:CMP BX,78
JZ GETSTRFN2
CALL ISFNM
JC GETSTRFN2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRFN1
GETSTRFN5:CMP BX,1
JB GETSTRFN2
MOV AL,0
MOV [BX][DI+2],AL
INC BX
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRFN_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRFN ENDP
ISDEC PROC
CMP AL,'0'
JB ISDEC_NODEC
CMP AL,'9'
JA ISDEC_NODEC
CLC
JMP ISDEC_OK
ISDEC_NODEC:STC
ISDEC_OK:RET
ISDEC ENDP
ATOBIN PROC
SUB AL,30H
CMP AL,9
JBE ATOBIN_OK
SUB AL,7
CMP AL,15
JBE ATOBIN_OK
SUB AL,20H
ATOBIN_OK:RET
ATOBIN ENDP
DTOBIN PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DI,SI
ADD DI,CX
DEC DI
MOV BP,0
MOV VAL_AX,0
MOV VAL_DX,0
DTOBIN_FORJ:CMP DI,SI
JB DTOBIN_OK
MOV AL,DS:[DI]
CALL ATOBIN
MOV AH,0
MOV BX,AX
MOV AX,0
MOV DX,WORD PTR MUL_TABLE[BP]
MOV CX,WORD PTR MUL_TABLE[BP+2]
CALL MULDW
ADD VAL_AX,AX
ADC VAL_DX,BX
DTOBIN_NEXTJ:DEC DI
INC BP
INC BP
INC BP
INC BP
JMP DTOBIN_FORJ
DTOBIN_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOBIN ENDP
GETSTRD PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRD1:CALL GETCH
CMP AL,CR
JZ GETSTRD5
CMP AL,BACKSPACE
JNZ GETSTRD4
CMP BX,0
JZ GETSTRD2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRD1
GETSTRD2:CALL BELL
JMP GETSTRD1
GETSTRD4:CMP BX,5
JZ GETSTRD2
CALL ISDEC
JC GETSTRD2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRD1
GETSTRD5:
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRD_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRD ENDP
DIVDW PROC
push bx
mov bx,ax
mov ax,dx
mov dx,0
div cx
push ax
mov ax,bx
div cx
mov cx,dx
pop dx
pop bx
ret
DIVDW ENDP
MULDW PROC
MOV NUM_AX,AX
MOV NUM_BX,BX
MOV NUM_CX,CX
MOV NUM_DX,DX
MOV AX,NUM_AX
MOV BX,NUM_CX
MUL BX
MOV RES_DX,DX
MOV RES_CX,AX
MOV AX,NUM_BX
MOV BX,NUM_DX
MUL BX
MOV RES_BX,DX
MOV RES_AX,AX
MOV AX,NUM_AX
MOV BX,NUM_DX
MUL BX
ADD AX,RES_BX
ADC WORD PTR RES_CX,0
ADC WORD PTR RES_DX,0
ADD DX,RES_CX
ADC WORD PTR RES_DX,0
MOV RES_CX,DX
MOV RES_BX,AX
MOV AX,NUM_BX
MOV BX,NUM_CX
MUL BX
ADD AX,RES_BX
ADC WORD PTR RES_CX,0
ADC WORD PTR RES_DX,0
ADD DX,RES_CX
ADC WORD PTR RES_DX,0
MOV RES_CX,DX
MOV RES_BX,AX
MOV DX,RES_DX
MOV CX,RES_CX
MOV BX,RES_BX
MOV AX,RES_AX
RET
MULDW ENDP
DIVDD PROC
MOV NUM_DX,DX
MOV NUM_CX,CX
MOV NUM_BX,BX
MOV NUM_AX,AX
MOV RES_BX,DI
MOV RES_AX,SI
XOR AX,AX
MOV VAL_DX,AX
MOV VAL_CX,AX
MOV VAL_BX,AX
MOV VAL_AX,AX
MOV RES_DX,AX
MOV RES_CX,AX
XOR CX,CX
DIVDD_FORJ1:CMP CX,64
JAE DIVDD_FINISHJ1
CLC
RCL NUM_AX,1
RCL NUM_BX,1
RCL NUM_CX,1
RCL NUM_DX,1
RCL RES_CX,1
RCL RES_DX,1
PUSHF
POP BX
MOV AX,RES_CX
MOV DX,RES_DX
SUB AX,RES_AX
SBB DX,RES_BX
PUSHF
TEST BL,01H
JNZ DIVDD_A1
POPF
JNC DIVDD_A2
JMP DIVDD_B1
DIVDD_A1:POPF
DIVDD_A2:MOV RES_CX,AX
MOV RES_DX,DX
STC
RCL VAL_AX,1
RCL VAL_BX,1
RCL VAL_CX,1
RCL VAL_DX,1
JMP DIVDD_NEXTJ1
DIVDD_B1:CLC
RCL VAL_AX,1
RCL VAL_BX,1
RCL VAL_CX,1
RCL VAL_DX,1
DIVDD_NEXTJ1:INC CX
JMP DIVDD_FORJ1
DIVDD_FINISHJ1:MOV DX,VAL_DX
MOV CX,VAL_CX
MOV BX,VAL_BX
MOV AX,VAL_AX
MOV DI,RES_DX
MOV SI,RES_CX
RET
DIVDD ENDP
ISASC PROC
CMP AL,20H
JB ISASC_NOASC
CMP AL,7EH
JA ISASC_NOASC
CLC
JMP ISASC_OK
ISASC_NOASC:STC
ISASC_OK:RET
ISASC ENDP
GETSTRASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DI
MOV WORD PTR [DI],0
MOV BX,0
GETSTRASC1:CALL GETCH
CMP AL,CR
JZ GETSTRASC5
CMP AL,BACKSPACE
JNZ GETSTRASC4
CMP BX,0
JZ GETSTRASC2
DEC BX
CALL PUTCH
MOV AL,20H
CALL PUTCH
MOV AL,BACKSPACE
CALL PUTCH
JMP GETSTRASC1
GETSTRASC2:CALL BELL
JMP GETSTRASC1
GETSTRASC4:CMP BX,12
JZ GETSTRASC2
CALL ISASC
JC GETSTRASC2
MOV [BX][DI+2],AL
INC BX
CALL PUTCH
JMP GETSTRASC1
GETSTRASC5:
MOV AL,CR
MOV [BX][DI+2],AL
INC BX
MOV AL,LF
MOV [BX][DI+2],AL
INC BX
CALL NEWLINE
MOV WORD PTR [DI],BX
GETSTRASC_OK:
POP DI
POP DX
POP CX
POP BX
POP AX
RET
GETSTRASC ENDP
DTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
CMP DX,0
JNZ DTOASC1
CMP AX,0
JNZ DTOASC1
MOV AL,'0'
CALL PUTCH
JMP DTOASC_OK
DTOASC1:mov di,0
divide_asc:mov cx,dx
jcxz finish_s_asc
divide_s_asc:mov cx,0AH
call divdw
inc di
push cx
jmp divide_asc
finish_s_asc:mov cx,ax
jcxz finish_asc
jmp divide_s_asc
finish_asc:mov cx,di
jcxz DTOASC_OK
string_asc:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string_asc
DTOASC_OK:POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOASC ENDP
DDTOASC PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CMP DX,0
JNZ DDTOASC1
CMP CX,0
JNZ DDTOASC1
CMP BX,0
JNZ DDTOASC1
CMP AX,0
JNZ DDTOASC1
MOV AL,'0'
CALL PUTCH
JMP DDTOASC_OK
DDTOASC1:mov bp,0
divide_ddtoasc:cmp dx,0
jz finish_s_ddtoasc1
divide_s_ddtoasc:mov di,0
mov si,10
call divdd
inc bp
push si
jmp divide_ddtoasc
finish_s_ddtoasc1:cmp cx,0
jz finish_s_ddtoasc2
jmp divide_s_ddtoasc
finish_s_ddtoasc2:cmp bx,0
jz finish_s_ddtoasc3
jmp divide_s_ddtoasc
finish_s_ddtoasc3:cmp ax,0
jz finish_ddtoasc
jmp divide_s_ddtoasc
finish_ddtoasc:mov cx,bp
jcxz DDTOASC_OK
string_ddtoasc:pop bx
add bx,30h
mov al,bl
CALL PUTCH
loop string_ddtoasc
DDTOASC_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DDTOASC ENDP
CLEARDISBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
CLD
MOV AL,20H
LEA DI,DIS_BUF
MOV CX,128
REP STOSB
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
CLEARDISBUF ENDP
CMPFILE PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
MOV DX,OFFSET MESS_FNSRC
CALL DISPMESS
MOV DI,OFFSET FNAME_SRC
CALL GETSTRFN
MOV DX,OFFSET FNAME_SRC
ADD DX,2
MOV AX,3D00H
INT 21H
JNC CMPFILE_OPENOKSRC
CMPFILE_OPENERRSRC:MOV DX,OFFSET MESS_OPENERR
CALL DISPMESS
JMP CMPFILE_OK
CMPFILE_OPENOKSRC:MOV HANDLE_SRC,AX
MOV AX,0003H
INT 10H
CMPFILE_A10:CALL Q10CLEAR
MOV BP,OFFSET MESS_STKNO
MOV CX,22
MOV DH,10
MOV DL,10
CALL G10DISPLY
MOV DI,OFFSET GET_BUF
CALL GETSTRD
MOV SI,OFFSET GET_BUF
ADD SI,2
MOV CX,WORD PTR GET_BUF
SUB CX,2
CMP CX,0
JE CMPFILE_RWFINISH
CMP CX,LEN_STKNO
JNE CMPFILE_A20
CLD
LEA DI,OFFSET_TBL
CMPFILE_S20:MOV CX,LEN_STKNO
MOV SI,OFFSET GET_BUF
ADD SI,2
REPE CMPSB
JE CMPFILE_S30
JB CMPFILE_S40
ADD DI,CX
ADD DI,4
JMP CMPFILE_S20
CMPFILE_S30:MOV WORD PTR VAL_DI,DI
MOV DX,ES:[DI]
MOV CX,ES:[DI+2]
MOV AH,42H
MOV AL,00H
MOV BX,HANDLE_SRC
INT 21H
JC CMPFILE_READERR
CALL CLEARDISBUF
MOV DX,OFFSET DIS_BUF
MOV CX,60
MOV BX,HANDLE_SRC
MOV AH,3FH
INT 21H
JC CMPFILE_READERR
CMP AX,0
JZ CMPFILE_RWFINISH
LEA BP,DIS_BUF+20
MOV AX,1301H
MOV BX,0061H
MOV CX,LEN_DESCR
MOV DX,0812H
INT 10H
MOV BP,OFFSET MESS_QTYNO
MOV CX,22
MOV DH,11
MOV DL,10
CALL G10DISPLY
MOV DI,OFFSET GET_BUF
CALL GETSTRD
MOV SI,OFFSET GET_BUF
ADD SI,2
MOV CX,WORD PTR GET_BUF
SUB CX,2
CMP CX,0
JE CMPFILE_A20
CALL DTOBIN
MOV DX,VAL_DX
MOV AX,VAL_AX
MOV BINQTY,AX
MOV WORD PTR NODECIMS,2
LEA SI,DIS_BUF+40
MOV AX,DS:[SI]
MOV BINRATE,AX
CALL E10MULT
CALL F10PROD
CALL G10FORMAT
JMP CMPFILE_S90
CMPFILE_S40:
MOV BP,OFFSET MESS_NOTFIND
MOV CX,12
MOV DH,12
MOV DL,39
CALL G10DISPLY
JMP CMPFILE_S90
CMPFILE_S90:
push dx
mov dx,9000h
call delay
pop dx
JMP CMPFILE_A10
CMPFILE_A20:
MOV BP,OFFSET MESS_ERROR
MOV CX,12
MOV DH,12
MOV DL,39
CALL G10DISPLY
push dx
mov dx,9000h
call delay
pop dx
JMP CMPFILE_A10
CMPFILE_READERR:MOV DX,OFFSET MESS_READERR
CALL DISPMESS
JMP CMPFILE_RWFINISH
CMPFILE_RWFINISH:
MOV BX,HANDLE_SRC
MOV AH,3EH
INT 21H
CMPFILE_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
CMPFILE ENDP
DTOBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
CMP DX,0
JNZ DTOBUF1
CMP AX,0
JNZ DTOBUF1
MOV SI,WORD PTR DIS_LEN
MOV BYTE PTR DIS_BUF[SI],'0'
INC SI
MOV WORD PTR DIS_LEN,SI
JMP DTOBUF_OK
DTOBUF1:MOV SI,WORD PTR DIS_LEN
mov bp,0
divide_dtobuf:cmp dx,0
jz finish_s_dtobuf1
divide_s_dtobuf:mov cx,10
call divdw
inc bp
push cx
jmp divide_dtobuf
finish_s_dtobuf1:cmp ax,0
jz finish_dtobuf
jmp divide_s_dtobuf
finish_dtobuf:mov cx,bp
jcxz DTOBUF_OK
string_dtobuf:pop bx
add bx,30h
MOV BYTE PTR DIS_BUF[SI],BL
INC SI
loop string_dtobuf
MOV WORD PTR DIS_LEN,SI
MOV CX,16
SUB CX,BP
MOV SI,OFFSET STR_BLANK
CALL STRTOBUF
DTOBUF_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
DTOBUF ENDP
STRTOBUF PROC
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
JCXZ STRTOBUF_OK
MOV DI,SI
MOV BX,WORD PTR DIS_LEN
MOV BP,0
STRTOBUF_FORI1:CMP BP,CX
JAE STRTOBUF_FINISHI1
MOV AL,DS:[DI]
MOV BYTE PTR DIS_BUF[BX],AL
INC BX
STRTOBUF_NEXTI1:INC BP
INC DI
JMP STRTOBUF_FORI1
STRTOBUF_FINISHI1:MOV WORD PTR DIS_LEN,BX
STRTOBUF_OK:POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
STRTOBUF ENDP
G10DISPLY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,1301H
MOV BX,0016H
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
G10DISPLY ENDP
Q10CLEAR PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,0600H
MOV BH,61H
MOV CX,0000H
MOV DX,184FH
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
Q10CLEAR ENDP
DELAY PROC NEAR
push ax
push dx
mov ax,0
delay_s:sub ax,1
sbb dx,0
cmp ax,0
jne delay_s
cmp dx,0
jne delay_s
pop dx
pop ax
ret
DELAY ENDP
E10MULT PROC NEAR
MOV CX,16
LEA DI,ASCPROD
MOV AL,30H
CLD
REP STOSB
MOV WORD PTR SHIFT,10
MOV WORD PTR ADJUST,0
MOV BP,10
MOV CX,NODECIMS
CMP CL,4
JA E40
SUB CX,2
JLE E30
MOV WORD PTR NODECIMS,2
MOV AX,1
E20:MUL BP
LOOP E20
MOV WORD PTR SHIFT,AX
SHR AX,1
MOV WORD PTR ADJUST,AX
E30:MOV AX,BINQTY
MUL WORD PTR BINRATE
ADD AX,ADJUST
ADC DX,0
CMP WORD PTR ADJUST,0
JZ E80
JMP E50
E40:XOR AX,AX
JMP E70
E50:MOV CX,WORD PTR SHIFT
CALL DIVDW
JMP E80
E70:XOR DX,DX
E80:RET
E10MULT ENDP
F10PROD PROC NEAR
LEA SI,ASCPROD+11
MOV BYTE PTR DS:[SI],'.'
ADD SI,NODECIMS
F30:CMP BYTE PTR DS:[SI],'.'
JNE F40
DEC SI
F40:CMP DX,0
JNZ F50
CMP AX,0
JZ F60
F50:MOV CX,TENWD
CALL DIVDW
OR CL,30H
MOV DS:[SI],CL
DEC SI
JMP F30
F60:RET
F10PROD ENDP
G10FORMAT PROC NEAR
MOV CX,16
LEA SI,ASCPROD
G20:CMP BYTE PTR DS:[SI],30H
JNE G30
MOV BYTE PTR DS:[SI],20H
INC SI
LOOP G20
G30:LEA BP,ASCPROD
MOV CX,16
MOV DX,0912H
CALL G10DISPLY
RET
G10FORMAT ENDP
J10ASCBIN PROC NEAR
MOV WORD PTR MULT10,1
MOV WORD PTR BINPROD,0
MOV BYTE PTR DECIND,0
XOR BX,BX
MOV BP,10
J20:MOV AL,DS:[SI]
CMP AL,'.'
JNE J30
MOV BYTE PTR DECIND,1
JMP J40
J30:AND AX,000FH
MUL WORD PTR MULT10
ADD WORD PTR BINPROD,AX
MOV AX,MULT10
MUL BP
MOV WORD PTR MULT10,AX
CMP BYTE PTR DECIND,0
JNZ J40
INC BX
J40:DEC SI
LOOP J20
CMP BYTE PTR DECIND,0
JZ J90
ADD WORD PTR NODECIMS,BX
J90:RET
J10ASCBIN ENDP
CSEG ENDS
END START
第18章磁盘存储III：支持磁盘和文件的INT 21H功能
18.1引言
18.2处理磁盘驱动器的操作
18.3处理目录和FAT的操作
18.4处理磁盘文件的操作
18.5要点
18.6习题
目的：检验支持使用磁盘驱动器和文件处理的各种INT 21H操作
18.1引言
这一章中将介绍一系列的有用操作，这些内容组织成3个部分：磁盘驱动器处理，目录和FAT处理，以及磁盘文件处理。
在每个部分中，将以功能码的顺序来描述它们的功能。
处理磁盘驱动器的操作：
0DH：重置磁盘驱动器
0EH：选择默认驱动器
19H：获取默认驱动器
1FH：获取默认驱动器参数块（DPB）
2EH：设置/重置磁盘检验
32H：获取驱动器参数块（DPB）
36H：获取空闲磁盘空间的信息
4400H：获取设备信息
4401H：设置设备信息
4404H：从驱动器中读取控制数据
4405H：写控制数据到驱动器
4406H：检查输入状态
4407H：检查输出状态
4408H：确定设备媒体是否可移动
440DH子功能码41H：写磁盘扇区
440DH子功能码61H：读磁盘扇区
440DH子功能码42H：格式化磁道
440DH子功能码46H：设置媒体ID
440DH子功能码60H：获取设备的参数
440DH子功能码66H：获取媒体ID
440DH子功能码68H：判断媒体类型
54H：获取校验状态
59H：获取扩展错误

处理磁盘文件的操作：
1AH：设置磁盘传输地址
29H：解析文件名
41H：删除文件
43H：获取/设置文件属性
45H，46H：复制文件代号
4EH，4FH：查找匹配文件
56H：文件重命名
57H：获取/设置文件日期/时间
5AH，5BH；创建临时/新文件

处理目录和FAT的操作：
39H：创建子目录
3AH：删除子目录
3BH：改变当前目录
47H：获取当前目录
本章引用的错误代码参见图17-1中的列表。
18.2处理磁盘驱动器的操作
18.2.1INT 21H的功能0DH：重置磁盘驱动器
一般来说，关闭一个文件将导致写入所有剩余记录和更新目录的操作。
在特殊环境下，例如在程序执行步骤之间或者在错误条件下，程序可以使用功能0DH来重置磁盘驱动器：
MOV AH,0DH   ;重置磁盘请求
INT 21H   ;调用中断服务
重置操作将清空所有文件缓冲区，并重置读写头到柱面0。此操作不关闭文件，并且无返回值。
18.2.2INT 21H的功能0EH：选择默认驱动器
0EH功能的主要目的是选择一个驱动器作为当前默认驱动器。
使用时，在DL中设置驱动器号，0=驱动器A，1=驱动器B，以此类推：
MOV AH,0EH   ;请求设置默认
MOV DL,02H   ;驱动器C
INT 21H   ;调用中断服务
此操作传递驱动器号（所有类型，包括RAM磁盘）到AL。
DL    drive number (0=A, 1=B, etc.) to become the default disk                                                                  
Returns: AL    total number of system drives
Info: The drive identified in DL becomes the current DOS default drive
(if it is a valid drive number).
Error test; use DOS Fn 19H (Get CurDisk) to make sure it worked.
Notes:   The return value in AL is number of drives of any type,
including hard disks and 'logical' and phantom drives (such as
drive B: in a 1-floppy system).
  The return value is simply a count of valid drive IDs--not an
indication of which drive IDs are valid.
因为最小的系统至少要求有两个逻辑驱动器A和B，所以，对个单驱动器系统该操作返回的值为02。
（使用INT 11H确定实际驱动器号。）
18.2.3INT21H的功能19H：获取默认驱动器
此功能确定默认的磁盘驱动器：
MOV AH,19H   ;缺省驱动器请求
INT 21H   ;调用中断服务
此操作在AL中返回驱动器号，0=A，1=B，以此类推。
从默认驱动器访问文件时，可以直接将驱动器号传送给程序，尽管有些磁盘操作假定1=驱动器A，2=驱动器B。
18.2.4INT 21H的功能1FH：获取默认驱动器参数块（DPB）
驱动器参数块（DPB）是一块数据区，包含下列驱动器数据结构的底层信息：
偏移量   大小   内容
00H      字节   驱动器号（0=A，以此类推）
01H      字节   驱动器逻辑单元
02H      字      扇区字节大小
04H      字节   每簇的扇区数减1
05H      字节   每簇扇区数（2的幂）
06H      字      FAT第一个相对扇区
08H      字节   FAT的拷贝号
09H      字      根目录入口号
0BH      字      第一簇的第一个相对扇区
0DH      字      最高簇号加1
0FH      字      每个FAT占用的扇区
11H      字      目录的第一个相对扇区
13H      双字   安装设备驱动程序的地址
17H      字节   媒体描述符
18H      字节   访问标志（0表示磁盘被访问）
19H      双字   指向下一个参数块的指针
1DH      字      最后分配的簇
1FH      字      空闲簇号
一个有效操作将AL清零并且在DS:BX中返回一个指向默认驱动器的DPB的地址。
对错误操作，AL设置为FFH。使用此功能前要将DS寄存器入栈，使用DS访问DBP后要将其出栈。参见功能32H。
18.2.5INT 21的功能2EH：设置/重置磁盘验证
这个操作允许程序检验磁盘写操作，即数据是否正确写入。
此操作设置一个开关，告诉系统检验磁盘控制器的循坏冗余校验（CRC，一种奇偶校验）。
在AL中装入00关闭检验，01设置检验。开关的设置一直保持到另一个操作来改变它。例如：
MOV AH,2EH   ;请求检验（或者MOV AX,2E01H）
MOV AL,01H   ;设置检验开启
INT 21H   ;调用中断服务
此操作不返回任何值。随后系统回应一个无效写操作。
因为磁盘驱动器很少记录错误数据和确认一些延迟原因，所以这个操作对记录的数据在特别临界的情况下最有用。
一个相关的功能是54H，它返回校验开关的当前设置。
18.2.6INT 21H的功能32H：获取驱动器参数块（DPB）
为了获取DPB，要在DX中装入驱动器号（0=默认，1=A，以此类推）。
（参见功能1FH ，除非是要求一个特殊的驱动器，这一功能是同样的。）
18.2.7INT21H的功能36H：获取空闲磁盘空间的信息
此功能传递有关磁盘设备空间的信息。在DL中装入驱动盘号（0=默认，1=A，2=B，以此类推）：
MOV AH,36H   ;请求空闲磁盘空间
MOV DL,0   ;默认驱动器
INT 21H   ;调用中断服务
一个成功的操作返回如下信息：AX=每簇的扇区数；BX=可用簇数；CX=每个扇区字节数；DX=磁盘分区的总簇数。
AX，CX和DX的值提供了分区的容量。对于一个无效的设备号，此操作将在AX中返回FFFFH。
这个操作不设置也不清除进位标志。
18.2.8INT 21H的功能44H：设备的I/O控制
这些将要详细阐述的服务IOCTL在程序和开放设备之间交流信息。
使用这一功能时，在AL中装入子功能参数来请求许多功能中的一种。
一个有效操作将进位标志清零。若出错，例如非法文件代号，将设置CF，并在AX中返回一个标准错误代码。
主要的IOCTL子功能如下所示。
1.INT 21H的功能4400H：获取设备信息。这一操作返回关于文件或设备的信息：
MOV AX,4400H   ;设备信息要求
MOV BX,handle   ;文件或设备的文件代号
INT 21H   ;调用中断服务
有效操作将进位标志清零，并在DX中返回一个值，DX的位7=0时表示文件代号指向文件，位7=1表示文件代号指向设备。
其他位对文件或设备所具有的含义如下：
文件（位7=0）：
0-5驱动器号（0=A，1=B，…）
6 1=文件未写
设备（位7=1）：
0 标准控制台输入   4 专用设备
1 标准控制台输出   5 0=ASCII模式，1=二进制模式
2 空设备                 6 对于输入，0=结束返回的文件
3 时钟设备
若出错，将设置进位标志，并且在AX中返回代码01，05或06。
2.INT21H的功能4401H：设置设备信息。这一操作设置设备信息，同功能4400H。
使用时，在BX中装入文件代号，在DL的位0~7进行位设置。若出错，将设置CF，并且在AX中返回代码01，05，06或0DH。
3.INT21H的功能4404H：从驱动器中读取控制数据。这一操作从块设备驱动器（磁盘驱动器）中读取控制数据。
使用时，在BL中装入驱动器号（0=默认，1=A，…），CX中为所要读取的字节数，DX中为数据区的地址。
操作成功时，在AX中返回的是传输的字节数。若出错，将设置CF，并且在AX中返回代码01，05或0DH。
4.INT21H的功能4405H：写控制数据到驱动器。这一操作写控制数据到块设备驱动器。
除了设置有些不同，其他与功能4404H相同。
5.INT21H的功能4406H：检查输入状态。这个服务例程检查文件或设备是否准备好输入。
在BX中装入文件代号。操作有效时，在AL中返回下列中的一个参数：
设备：00H=未准备好，FFH=准备好
文件：00H=到达EOF，FFH=未到EOF
若出错，将设置CF，并且在AX中返回01，05或06。
6.INT21H的功能4407H：检查输出状态。这个服务例程确定一个文件或设备是否准备好输出。
操作有效时，在AL中返回下列代码：
设备：00H=未准备好，FFH=准备好
文件：00H=未准备好，FFH=准备好
若出错，将设置CF，并且在AX中返回01，05或06。
7.INT21H的功能4408H：确定设备媒体是否可移动。这一服务例程确定设备是否包含可移动的媒体，例如软磁盘。
使用时，在BL中装入驱动器号（0=默认，1=A，.…）。操作成功时，CF清零，并且在AX中返回如下一个代码：
00H=可移动设备，01H=固定设备。
若出错，将设置CF，并且在AX中返回01或0FH（无效驱动器号）。
8.INT21H的功能440DH，子功能码41H：写磁盘扇区。
这一操作将缓冲区的数据写入磁盘的一个或多个扇区。使用时，加载如下寄存器：
MOV AX,440DH   ;请求写磁盘扇区
MOV BX,drive   ;驱动器（0=默认，1=A，）
MOV CH,08H   ;设备种类=08H
MOV CL,41H   ;子功能码=写磁道
LEA DX,devblock   ;设备块地址
INT 21H   ;调用中断服务
在DX中返回的地址以下列格式指向设备块：
devblock LABEL BYTE   ;设备块
specfunc DB 0   ;特定功能（零）
rwhead DW head   ;读写头
rwcyl DW cylinder   ;柱面
rwsectl DW sector   ;起始扇区
rwsects DW number；扇区数
rwbuffer DW buffer   ;缓冲区偏移地址
               DW SEG _DATA   ;数据段地址
入口项rwbufer提供了段：偏移（DS:DX）形式的缓冲区地址，并按字反序存储。
SEG操作符表明定义一个段，在上例定义的数据段为_DATA。
缓冲区表明所要写入的数据区，缓冲区的长度必须是扇区数×512，例如：
WRBUFFER DB 1024 DUP (?)   ;输出缓冲区（2扇区×512）
操作成功，CF清零并且写数据。否则，将设置CF，并且在AX中返回01，02或05。
9.INT21H的功能440DH，子功能码42H：格式化磁道。
使用这一功能格式化磁道，设置如下寄存器：
MOV AX,440DH；请求格式化磁道
MOV BX,drive   ;驱动器（0=默认，1=A.…）
MOV CH,08H   ;设备种类（08）
MOV CL,42H   ;子功能码=格式化磁道
LEA DX,block   ;块地址（DS:DX）
INT 21H   ;调用中断服务
在DX中返回的地址以下列格式指向块：
block LABEL BYTE   ;磁盘信息块：
specfunc DB 0   ;特定功能，代码0
diskhead DW ?   ;磁盘头
cylinder DW ?   ;柱面
tracks DW ?   ;磁道号
操作成功，CF清零并且格式化磁道。否则，将设置CF，并且在AX中返回错误码01，02或05。
10.INT21H的功能440DH，子功能码46H：设置媒体ID。
使用这一功能设置媒体D，要设置如下寄存器：
MOV AX,440DH   ;请求设置媒体ID
MOV BX,drive   ;驱动器（0=默认，1=A，...）
MOV CH,08H   ;设备种类（08）
MOV CL,46H   ;子功能码=设置媒体ID
LEA DX,block   ;块地址（DS:DX）
INT 21H   ;调用中断服务
在DX中返回的地址以下列格式指向媒体块：
block LABEL BYTE   ;媒体块：
infolevel DW 0   ;信息级别=0
serialno DD ??   ;序列号
vol_label DB 11 DUP (?)   ;卷标签
filetype DB 8 DUP (?)   ;FAT类型
入口项filetype包含FAT12或者FAT16的ASCIl值，并以空格结尾。
操作成功，CF清零并且设置ID。否则，将设置CF，并且在AX中返回错误码01，02，或者05。
（见INT21H功能440DH，子功能码66H。）
11.INT21H的功能440DH，子功能码60H：获取设备参数。
使用这一功能得到设备参数，设置如下寄存器：
MOV AX,440DH   ;请求获取设备参数
MOV BX,drive   ;驱动器（0=默认，1=A，…）
MOV CH,08H   ;设备种类（08）
MOV CL,60H   ;子功能码：获取参数
LEA DX,block；块地址（DS:DX）
INT 21H   ;调用中断服务
在DX中返回的地址以下列格式指向设备参数块（DPB）：
specfunct DB ?   ;特定函数（0或1）
devicetype DB ?   ;设备类型
devattrib DW ?   ;设备属性
cylinders DW ?   ;柱面数
mediatype DB ?   ;媒体类型
bytesects DW ?   ;每个扇区字节数
seccluster DB ?   ;每簇扇区数
ressectors DW ?   ;保留扇区数
fats DB ?   ;FAT数
rootentry DW ?   ;根目录入口数
sectors DW ?   ;扇区总数
mediadescs DB ?   ;媒体描述符
fatsectors DW ?   ;每个FAT扇区数
sectrack DW ?   ;每磁道扇区数
heads DW ?   ;读写头数
hiddensect DD ?   ;隐藏扇区数
exsects DD ?   ;扇区字段=0的扇区数
如果specfunct字段为0，信息是关于驱动器中的默认媒体；如果是1，信息是关于当前媒体的。
操作成功，CF清零并且传递数据。否则，将设置CF，并且在AX中返回错误码01，02或05。
12.INT21H的功能440DH，子功能码61H：读磁盘扇区。
此操作从一个或多个扇区中读取数据到磁盘缓冲区。
设置CL为子功能码61H；否则，操作上的技术细节和写扇区的子功能41H相同。后面介绍的图18-1的程序将说明这个功能。
13.INT21H的功能440DH，子功能码66H：获取媒体ID。使用这一功能得到媒体ID：
MOV AX,440DH   ;请求媒体ID
MOV BX,drive   ;驱动器（0=默认，1=A，…）
MOV CH,08H   ;设备种类（08）
MOV CL,66H   ;子功能码=获取媒体ID
LEA DX,block   ;块地址（DS:DX）
INT 21H   ;调用中断服务
在DX中返回的地址以下列格式指向媒体块：
block LABEL BYTE   ;媒体块：
infolevel DW 0   ;信息级别 0
serialno DD ?   ;序列号
vol_label DB 11 DUP (?)   ;卷标签
filetype DB 8 DUP (?)   ;FAT类型
成功的操作进位标志清零并设置ID。filetype字段包含FAT12或者FAT16的ASCII值，并用空格结尾。
否则，此操作设置CF，并且在AX中返回错误码01，02或05。（参见INT21H的功能440DH，子功能码46H。）
14.INT21H的功能440DH，子功能码68H：判断媒体类型。
使用这一功能来请求媒体类型，设置如下寄存器：
MOV AX,440DH   ;请求媒体类型
MOV BX,drive   ;驱动器（0=默认，1=A，…）
MOV CH,08H   ;设备种类（08）
MOV CL,68H   ;子功能码=获得媒体类型
LEA DX,block   ;块地址（DS:DX）
INT 21H   ;调用中断服务
在DX中返回的地址指向一个2字节媒体块来接收数据：
defaultval DB ?   ;01为默认值，02为其他
mediatype DB ? ;02=720K，07=1.44MB，09=2.88MB
操作成功，CF清零并且设置类型。否则，将设置CF，并且在AX中返回错误码01或者05。
功能44H的其他IOCTL操作，即与文件共享的相关操作，这里没有列出。
18.2.9INT21H的功能54H：获取校验状态
这一服务例程确定磁盘写校验标志的状态（参见功能2EH的设置开关）。
此操作在AL中返回00H表示校验关闭，01H表示校验开启。没有出错条件。
18.2.10INT21H的功能59H：获取扩展错误
这一操作提供有关错误的附加信息，这些错误是在执行INT 21H的服务例程，设置CF和INT 21H的错误返回码后获得的。
该操作返回如下：
AX=扩展错误码
BL=建议动作
BH=错误类别
CH=位置
同时，该操作CF清零，并且破坏CL，DI，DS，DX，ES和SI的内容。
在中断前请求的所有寄存器进栈，最后这些寄存器出栈。下面几节要解释这些错误：
AX=扩展错误码。提供大约90个或更多的错误码，00表示前面的INT21H操作没有错误。
BH=错误类别。提供如下信息：
01出错来源，例如存储通道
02临时状态（不是错误），例如一个加锁文件应取消的条件
03缺少适当的授权
04系统软件错，而非此程序错
05硬件失败
06严重系统错误，而非此程序错
07此程序出错，例如不一致请求
08请求条目未找到
09不正确文件或磁盘格式
0A文件或条目上锁
0B磁盘错，如CRC错或者错误盘
OC文件或条目已经存在
OD未知错误类
BL=动作。提供下一步动作的信息：
01重试几次，可能要求用户结束
02先暂停，然后重试几次
03要求用户重新输入正确请求
04关闭文件并终止程序
05立即终止程序，不关闭文件
06忽略错误
07要求用户执行一个动作（如换软盘），然后重试操作
CH=出错位置。提供定位错误的附加信息：
01未知情况，无法帮助
02磁盘存储问题
03网络问题
04串行设备问题
05存储器问题
18.2.11程序：从扇区读数据
图18-1中的程序说明了IOCTL功能44H子功能0DH的子功能码61H的使用。
程序从扇区中读数据到内存缓冲区，并且以十六进制字符对的形式显示每个输入字节，如图15-6所示。
数据段中的块结构RDBLOCK任意指定一个读写头、柱面和起始扇区，这可以根据你自己的意图而改变。
RDBUFFER定义了两个地址：
1.IOBUFFER是输入缓冲区的偏移地址，它提供了一个扇区（512字节）的数据。
2.SEG _DATA使用SEG操作符为IOCTL操作确定数据段地址。
代码段的主要过程是：
A10MAIN调用B10READ，如果操作正确，调用C10CONVRT。
B10READ使用IOCTL操作从扇区读数据到IOBUFFER（测试读是否有效，在程序返回时进行）。
C10CONVRT使用XLAT指令将IOBUFFER中每半个字节转换成一个十六进制字符，并在DISPAREA中顺序存储。
完成这些工作后，调用 D10DISPLY。
D10DISPLY显示DISPAREA中的十六进制字符。INT10H的功能13H在显示到屏幕最右端时自动换行。
一种改进程序的方法是允许用户通过键盘请求任意的起始扇区和扇区数。
Expects: AX    440dH
BX    drive (0=default, 1=A, 2=B, etc.)
CL    61H
CH    08H (device category: block device)
DS:DX addr of an IoctlRdWrtTrackRec identifying the size and disk
location of the block to read and the memory address to
store the data.
Returns: AX    error code  if CF is set to CY
DS:DX the buffer at IoctlRdWrtTrackRec.rwBuffer is filled with the requested data

IoctlRdWrtTrackRec
Offset Size Contents                                                                          
+0     1  rSpclFns     (always 00)
+1     2  wHead        head to read/write
+3     2  wTrack       track (cylinder) to read/write
+5     2  wStartSect   starting sector (0-based; sector 1=0, 2=1...)
+7     2  wSectCnt     sector count (0-based; use 8 for 9-sector track)
+9     4  fpBuff       32-bit addr of buffer containing data to write (440dH 41H) or 
                                         addr to hold data read (440dH 41H)
0dH (13)         size of an IoctlRdWrtTrackRec
Notes: The wStartSect field is relative to the start of the track, for instance, 
to write an entire track on a 9-sector/track diskette,
set wStartSect to 0 and set wSectCnt to 9.
This is the only place I've seen where tracks are not specified 
with their "hardware code" numbers (e.g. 1-9).

devblock LABEL BYTE   ;设备块
specfunc DB 0   ;特定功能（零）
rwhead DW head   ;读写头
rwcyl DW cylinder   ;柱面
rwsectl DW sector   ;起始扇区
rwsects DW number；扇区数
rwbuffer DW buffer   ;缓冲区偏移地址
               DW SEG _DATA   ;数据段地址

.MODEL SMALL
.STACK 512
.DATA
XLATAB DB 30H,31H,32H,33H,34H,35H,36H,37H,38H,39H
              DB 41H,42H,43H,44H,45H,46H
READMSG DB '*** Read error ***'
RDBLOCK DB 0
RDHEAD DW 0
RDCYLDERR DW 0
RDSECTOR DW 12
RDNOSEC DW 1
RDBUFFER DW IOBUFFER
                  DW SEG _DATA
IOBUFFER DB 512 DUP (20H)
DISPAREA DB 1024 DUP (20H)
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
MOV AX,0003H
INT 10H
CALL B10READ
JC A80
CALL C10CONVRT
JMP A90
A80:LEA BP,READMSG
MOV CX,18
CALL D10DISPLY
A90:MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10READ PROC NEAR
MOV AX,440DH
MOV BX,0000H
MOV CH,08H
MOV CL,61H
LEA DX,RDBLOCK
INT 21H
RET
B10READ ENDP
C10CONVRT PROC NEAR
LEA DI,DISPAREA
LEA SI,IOBUFFER
CLD
C20:MOV AL,DS:[SI]
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
LEA BX,XLATAB
XLAT
STOSB
MOV AL,DS:[SI]
AND AL,0FH
XLAT
STOSB
INC SI
LEA BX,IOBUFFER+512
CMP SI,BX
JB C20
LEA BP,DISPAREA
MOV CX,1024
CALL D10DISPLY
RET
C10CONVRT ENDP
D10DISPLY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,1301H
MOV BX,0016H
MOV DX,0500H
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
D10DISPLY ENDP
END A10MAIN
18.3处理目录和FAT的操作
18.3.1INT21H的功能39H：创建子目录
这一服务例程创建子目录，如同系统命令MKDIR。
使用时，在DX中装入含有驱动器和目录路径名的ASCIIZ串的地址：
ASCSTRING DB 'C:\pathname',00H
MOV AH,39H   ;请求创建子目录
LEA DX,ASCSTRING   ;ASCIIZ串地址（DS:DX）
INT 21H   ;调用中断服务
操作有效时CF清零，出错时设置CF，并且在AX中返回03或05。
18.3.2INT21H的功能3AH：删除子目录
这一服务例程删除子目录，如同系统命令RMDIR。注意不能删除当前（活动）目录，或者包含文件的目录。
在DX中装入含有驱动器和目录路径名的ASCIIZ串的地址：
ASCSTRING DB 'C:\pathname',00H
MOV AH,3AH   ;请求删除子目录
LEA DX,ASCSTRING   ;ASCIIZ串地址（DS:DX）
INT 21H   ;调用中断服务
操作有效时CF清零，出错时设置CF并且在AX中返回03，05或10H。
18.3.3INT21H的功能3BH：改变当前目录
这一服务例程改变当前目录到指定目录，如同系统命令CHDIR。
使用时，在DX中装入含有驱动器和目录路径名的ASCIIZ串的地址：
ASCSTRING DB 'C:\pathname',00H
MOV AH,3BH   ;请求改变目录
LEA DX,ASCSTRING   ;ASCIIZ串地址（DS:DX）
INT 21H   ;调用中断服务
操作有效时CF清零，出错时设置CF并且在AX中返回03。
18.3.4INT21H功能的47H：获取当前目录
这一服务例程可以得到任意驱动器的当前目录。使用时，定义一块缓冲区空间，其大小足以能容纳可能最长的路径名（64字节），并且将其地址存入SI。
在DL中装入驱动器号（0=默认，1=A，2=B，..）：
buffer DB 64 DUF (20H)   ;64字节缓冲区空间
MOV AH,47H   ;请求获得目录
MOV DL,drive   ;驱动器号
LEA SI,buffer   ;缓冲区地址（DS:SI）
INT 21H   ;调用中断服务
操作有效时CF清零，并且将当前目录（不是驱动器）的名字以ASCIIZ串的形式传送到缓冲区，
如PCPROGS\TESTDATA，后接1字节00H表示路径名结束。
如果请求的目录是根目录，返回值只是1字节的00H。这样，可以得到当前目录名以便访问子目录下的任何文件。
一个无效的驱动器号将设置CF，并且在AX中返回错误码0FH。
18.3.5INT21H的功能56H：文件或目录重命名
此功能见下一节。
Expects: AH    19H
Returns: AL    DOS current default drive number (0=A, 1=B, etc.)
Info: Returns the drive number of the current DOS default disk.
Notes:   Add 'A' (65H) to AL to obtain a drive letter suitable for use in handle-oriented file operations.

Expects: AH    47H
DL    drive number (0=default, 1=A, etc.)
DS:SI address of a local buffer to hold a pathname (64 bytes)
Returns: AX    error code if CF is set to CY
Info: The buffer starting at DS:SI is filled with an ASCIIZ pathname 
of the current default directory for the drive specified by DL.

The pathname is returned in the form...
d:\path\filename.ext 0 

There is no leading drive letter or leading or trailing
backslash; for instance, if the current default directory is the
root, all you'll get is a null string (DS:[SI] = 0).
18.3.6程序：显示目录
图18-2中的程序说明了前节所描述的两个功能的用法。程序的目的是显示默认的目录。
程序执行以下功能：
使用功能19H在AL中得到默认驱动器，返回驱动器号为0（驱动器A），1（驱动器B），依此类推。
为了将数字调整为相应的字母，程序中简单地加上了41H，这样00变为41H（A），01变为42H（B），依此类推。
在DRIVE字段中存储驱动器对应的字母，后接冒号和斜线（n:\）。
使用功能47H得到当前目录的路径名，存储在PATHNAME中。
扫描查找ASCIIZ串的终止符00H，以确定PATHNAME中路径名的长度。
使用这一长度显示DRIVE和PATHNAME。
结束前等待键盘输入。
.MODEL SMALL
.STACK 512
.DATA
PATH_LEN EQU 64
DRIVE DB 20H,':\'
PATHNAME DB 64 DUP (20H)
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
MOV AX,0003H
INT 10H
MOV AH,19H
INT 21H
ADD AL,41H
MOV DRIVE,AL
MOV AH,47H
MOV DL,0
LEA SI,PATHNAME
INT 21H
MOV AL,00H
MOV CX,PATH_LEN
LEA DI,PATHNAME
CLD
REPNE SCASB
JNE A90
INC CX
NEG CX
ADD CX,PATH_LEN
ADD CX,3
MOV AX,1301H
MOV BX,0016H
LEA BP,DRIVE
MOV DX,0A0CH
INT 10H
A90:MOV AH,10H
INT 16H
MOV AX,4C00H
INT 21H
A10MAIN ENDP
END A10MAIN
18.4处理磁盘文件的操作
这一节描述处理磁盘文件的操作。
18.4.1INT21H的功能1AH：设置磁盘传输地址
磁盘传输地址（DTA）是一个简单的存储区，用来从磁盘接收数据。这一操作主要和功能4EH和4FH一起使用，如下例：
DTA_ADDRESS DB nn DUP (?)
MOV AH,1AH   ;请求设置DTA
LEA DX,DTA_ADDRESS   ;DTA地址
INT 21H   ;调用中断服务
18.4.2INT21H的功能29H：解析文件名
这一服务例程将一个形式为n:filename.ext的文件说明（filespec）的命令行转换成FCB格式。
FCB（File Control Block）是一种不再使用的磁盘存取方法，它已被文件代号法取代。
需要知道的只是FCB是文件说明的格式，它由11个字节组成：
1~8文件名。文件的名字，左对齐，其余用空格补齐。
9~11文件扩展名。左对齐，其余用空格补齐，此功能可以从用户接受一个文件说明，例如复制和删除文件。
使用时，将要解析的文件说明的地址装入SI（用于DS:SI），操作要产生的FCB格式的存储区的地址装入DI（用于ES:DI），
AL中各位的值用来控制解析方法：
MOV AH,29H   ;请求解析文什名
MOV AL,code   ;解折方法
LEA DI,FCBname   ;FCB地址（ES:DI）
LEA SI,filespec   ;文件说明的地址（DS:SI）
INT 21H   ;调用中断服务

Expects: AH    29H
AL    bit-flags to select parsing options (see below)
DS:SI address of source text line to parse
ES:DI address of buffer to hold resulting unopened FCB
                                                                  
Returns: AL    0    if result FCB has no wildcard characters
1    if result FCB does contain wildcards 
0ffH if invalid drive ID in filespec
DS:SI updated: points to the character just past the filename
ES:DI preserved: points to the unopened FCB
                                                                  
Info: Creates an unopened FCB from a text line or command parameter.
The text starting at DS:SI is parsed for a filespec in the format
D:FILENAME.EXT and the buffer at ES:DI is filled in as a
properly-formatted, unopened FCB.

     This Fn is NOT useful for a text line containing a pathname.
Basically, this is a quick way to skip leading spaces, upshift
and remove the dot (.) from a filename input from the keyboard.
It converts * into a series of ?s and it allows you to pre-set a
default in the destination FCB (e.g., extension = "WKS").

The parsing action depends upon these bit flags in AL:
 7 6 5 4 3 2 1 0 
 0 0 0 0         
                  bit                                  mask value
          0: 1=scan off leading separators     (a | 01H)
          1: 1=use FCB drive byte as a default (a | 02H)
          2: 1=use FCB filename as a default   (a | 04H)
          3: 1=use FCB extension as a default  (a | 08H)
解析方法的代码从右到左是：
位   值   动作
0      0   表明文件说明从第一字节开始。
0      1   扫描分隔符（如空格）查找文件说明。
1      0   在生成的FCB中设置驱动器ID字节：未找到驱动器=00，A-01，B=02，以此类推。
1      1   仅当解析的文件说明指定一个驱动器时，才在生成的FCB中改变驱动器ID字节。
             这种情况下，一个FCB可能有它自己默认的驱动器。
2      0   需要时改变FCB中的文件名。
2      1   仅当文件说明中包含有效文件名时，才改变FCB的文件名。
3      0   需要时改变文件扩展名。
3      1   仅当文件说明中包含有效扩展名时，才改变FCB的扩展名。
4~7   0   必须为零。
对于有效数据，功能29H为文件名和扩展名创建一个标准FCB格式，即8字符的文件名，如有必要用空白符填写，
以及3字符的扩展名，如有必要用空白符填写，它们之间没有点（.）。
操作能够识别标准的标点符号，并将通配符*和?转换成一个或多个字符的串。例如，PROG12.*转换为PROG12bb???
（文件名后填入2个空白符，???作为扩展名）。
AL返回下列代码之一：00H=未遇到通配符；01H=已转换通配符；FFH=指定非法的驱动器。
操作结束后，DS:SI含有文件说明解析后第一个字节的地址，ES:DI含有FCB第一个字节的地址。
对一次失败的操作，DI+1的字节为空白符，尽管操作试图转换你输入的任何代码。
为了用文件代号也能使此操作工作，需要进一步编辑，包括删去空白符，并且在文件名和扩展名之间插入句点。
18.4.3INT21H的功能41H：删除文件
此功能从一个程序内删除文件（不包括只读文件）。在DX中装入ASCIIZ串的地址，ASCIIZ串包含设备路径和文件名，
不带有通配符标记：
ASCSTRING DB 'n:\pathname',00H
MOV AH,41H   ;请求删除文件
LEA DX,ASCSTRING   ;ASCIIZ串地址（DS:DX）
INT 21H   ;调用中断服务
有效操作清零CF，目录中的文件名标记为已删除，释放FAT中分配给该文件的磁盘空间。
操作出错，设置CF，并且在AX中返回02，03或05。
18.4.4INT21H的功能43H：获得/设置文件属性
使用此项功能既可以获取也可以设置文件属性。操作要求ASCIIZ串的地址装入DX，ASCIIZ串包含要操作文件的驱动器、路径和
文件名（如果路径未给出，则使用默认目录）。
1.获得文件属性。为了得到文件属性，在AL中装入代码00，如下例所示：
ASCSTRING DB 'n:\pathname',00H
MOV AH,43H
MOV AL,00H
LEA DX,ASCSTRING   ;ASCIIZ串地址（DS:DX）
INT 21H   ;调用中断服务
有效操作CF清零，CH清零，并在CL中返回当前属性：
位   属性
0   只读文件
1   隐藏文件
2   系统文件
3   卷标
4   子目录
5   存档文件
操作出错则设置CF并且在AX中返回代码02或03。
2.设置文件属性。为了设置文件属性，在AL中装入代码01，在CX中装入属性。
可以改变只读、隐藏、系统和存档属性，但不可以改变卷标和子目录。下例设置一个文件为隐藏和存档属性：
MOV AH,43H
MOV AL,01H
MOV CX,0022H   ;隐藏和存档属性
LEA DX,ASCSTRING   ;ASCIIZ串地址（DS:DX）
INT 21H   ;调用中断服务
有效操作CF清零，并且在CX中设置目录入口项的属性。操作出错，设置CF并且在AX中返回代码02，03或05。
18.4.5INT21H的功能45H：复制文件代号
此服务例程的目的是给一个文件多个文件代号。新旧文件代号的使用是相同的，这些代号指向同一个文件、文件指针和缓冲区。
一种用法是请求一个文件代号，并且用这个文件代号去关闭文件。
这一操作导致系统清空缓冲区并更新目录。接着可以使用最初的文件代号继续处理文件。下面是功能45H的例子：
MOV AH,45H   ;请求复制文件代号
MOV BX,handle   ;要复制的当前文件代号
INT 21H   ;调用中断服务
有效操作使CF清零，并且在AX中返回下一个可用的文件代号。
操作出错，设置CF并且在AX中返回错误代码04或06（参见功能46H）。
18.4.6INT21H的功能46H：强迫复制文件代号
此服务例程除了可以分配一个指定的文件代号外，其他与功能46H类似。
使用这一功能可以使输出重定向，例如，到另外一个路径。使用时，在BX中装入初始的文件代号，CX中装入第二个文件代号。
操作成功CF清零。操作出错，设置CF并且在AX中返回错误码04或06。
有些组合可能不工作，例如：代号00总是键盘输入，04是打印机输出，03（辅助设备）不能重定向（见功能45H）。
18.4.7INT21H的功能4EH：查找第一个匹配文件
使用4EH功能开始查找目录中的第一个相关文件，使用4FH功能继续查找同组的下一个相关文件。
需要为操作返回的定位目录入口定义一个43字节的缓冲区，并且在使用这个服务之前使用功能1AH（设置DTA）。
DTA（Disk Tranfer Address）是内存中的一个简单区域，定义这个区域用来从磁盘接收数据。
设置DTA告诉功能4EH要求的数据将传送到何处。
开始查找时，在CX设置将要返回的文件名的属性
只读（位0），隐藏（位1），系统（位2），卷标（位3），目录（位4）或存档（位5），它们可以任意组合。
在DX中装入包含文件说明的ASCIIZ串地址，串中可以包含通配符?和*。例如，对文件说明n:\ASMPROGS\A12*.ASM的
查找请求将导致操作从与串匹配的第一个文件开始查找。如下例：
ASCSTRING DB‘ASCIIZ string',00H
MOV AH,4EH   ;请求第一次匹配
MOV CX,0   ;正常属性
LEA DX,ASCSTRING   ;ASCIIZ串地址（DS:DX）
INT 21H   ;调用中断服务
定位一个匹配文件的操作清除进位标志，并且用下列数据填入43字节（2BH）的DTA：
FILEDTA LABEL BYTE   ;文件DTA
DB 21 DUP (20H)   ;保留为子目录搜索
FILEATTR DB 0   ;文件属性
FILETIME DW 0   ;文件时间
FILEDATE DW 0   ;文件日期
LOWSIZE DW 0   ;文件大小 低位字
HIGHSIZE DW 0   ;文件大小 高位字
FILENAME DB 13 DUP (20H)   ;ASCIIZ串形式的文件名和扩展名，
                                                 ;紧接十六进制00
操作出错，设置CF并且返回代码02，03或12H。
Offset Size Contents
+0     21  reserved     used by DOS in subsequent fn 4fH (find next)
+15H     1  bAttr        file attribute of file that was found
+16H     2  rTime        time created/modified in FileTimeRec format
+18H     2  rDate        date created/modified in FileDateRec format
+1aH     4  lSize        DWORD file size, in bytes
+1eH    13  szFilespec   13-byte max ASCIIZ  filespec: "filename.ext",0
              43               size of a FileInfoRec structure
如果打算接着使用功能4FH，不要改变DTA的内容。
功能4EH的惟一用处是能够确定查询的是文件名还是子目录。
例如，如果返回的属性是10H，则涉及到的是子目录。操作同时也返回文件的大小，这在图23-3中说明。
可以使用功能4EH确定文件的大小，使用功能36H检查写文件的可用空间。
Expects: AH    4eH
DS:DX address of ASCIIZ  filespec to find (wildcards  OK)
CX    file attribute to match
Returns: AX    error code if CF is set to CY
DTA   is filled with a FileInfoRec (if no error)
Info: Searches a single directory for a file matching a specific
wildcard  filespec with a given file attribute and returns file
information into the current DTA.

You may use this to obtain a file's size, time, date, etc.
without needing to open the file.

DS:DX points to an ASCIIZ string in the form...
d:\path\filename.ext0
If the drive or path is omitted, defaults are assumed.

DOS finds the name of the first file on the drive and directory
that matches the filespec and attribute, and places that name and
other information into the DTA, in the form of a FileInfoRec.

Notes: The file attribute is generally used in an inclusive search.
For instance, if you want to look for directories as well as
filenames, attribute bit 4 should be set (attr | 10H).  See
File Attributes for full information.

A typical sequence used to find all matching files in a
directory:

  Use Fn 1aH to set the DTA to a local buffer (or use the
default DTA at PSP offset 80H)
  Set CX=attribute, DS:DX => ASCIIZ wildcard d:\path\filespec
  Invoke Fn 4eH (Find First)
  If CF indicates error, you're all done (no matches)
  Set DS:DX => DTA (or to data you've copied from the DTA after
using Fn 4eH)
  Repeat:
Process the filespec and data at DS:DX
Invoke Fn 4fH (Find Next)
Until error return indicates no match (Carry Flag is set)
18.4.8INT21H的功能4FH：查找下一个匹配文件
使用这一服务例程之前，调用功能4EH开始在一个目录中查找，然后使用功能4FH继续查找：
MOV AH,4FH   ;请求下一个匹配文件
INT 21H   ;调用中断服务
操作成功则CF清零并且在AX中返回代码00（找到文件名）或18（没有更多的文件）。
操作出错，设置CF，并在AX中返回错误码02，03或12H。
功能4EH和4FH将在图18-3中说明。
Expects: AH    4fH
DS:DX address of data from a previous Fn 4eH Find 1st File
                                                                  
Returns: AX    error code if CF is set to CY (i.e., if no more matches)
DTA   is filled with a FileInfoRec (if no error)
                                                                  
Info: Continues a file search begun by a previous call to fn 4eH (find
first file).

DS:DX points to a 43-byte buffer containing information returned by Fn
4eH (find first file) -- either the DTA or a buffer copied from
the DTA.

Use this after a call to Fn 4eH.  The next filename matching the
selected wildcard filespec and file attribute will be copied into
the buffer at DS:DX, along with other information (see
FileInfoRec the layout of the return information and see Fn 4eH
for related details.

Notes: The DS:DX parameter is required for DOS 3.0+.  It enables you to
use recursive searching techniques more easily (for instance to
search an entire directory tree).
18.4.9INT21H的功能56H：重命名文件或目录
这一服务例程在一个程序内重新命名文件或者目录。在DX中装入ASCIIZ串地址，ASCIIZ串包含原来的驱动器、路径和
要重命名的文件名或路径名：在DI（组成 ES:DI）中装入另一个ASCIIZ串地址，这个ASCIIZ串包含新的驱动器、路径和文件名，
不带通配符。如果使用了驱动器号，在两个串中必须相同。因为路径不需要相同，所以操作可以重命名一个文件，
并把它移动到同一驱动器的另一个目录下：
oldstring DB 'n:\oldpath\oldname',00H
newstring DB 'n:\newpath\newname',00H
MOV AH,56H   ;请求重命名文件/目录
LEA DX,oldstring   ;DS:DX
LEA DI,newstrng   ;ES:DI
INT 21H   ;调用中断服务
操作成功则清除进位标志；操作出错，设置CF，并在AX中返回错误码02，03，05或11H。
18.4.10INT21H的功能57H：获取/设置文件日期和时间
这一服务例程能使程序获得或设置一个打开文件的时间和日期。时间和日期的形式如下：
表示时间的位         表示日期的位
0BH~0FH   小时   09H~0FH   年（相对于1980）
05H~0AH   分      05H~08H   月
00H~04H   秒      00H-04H    日
秒是以每两秒增量的0-29之间的数字形式表示。
在AL中装入请求号（0=获取，1=设置），在BX中装入文件代号。
在请求设置日期/时间时，在CX中装入时间，DX中装入日期。下面是一个例子：
MOV AH,57H   ;请求设置文件的日期和时间
MOV AL,01H
MOV BX,handle   ;文件代号
MOV CX,time   ;新的时间（小时 分 秒）
MOV DX,date   ;新的日期（年 月 日）
INT 21H   ;调用中断服务
有效操作清除进位标志；获取操作在CX中返回时间，DX中返回日期，而设置操作改变文件的时间和日期的条目。
无效操作设置CF并且在AX中返回错误码01或06。
18.4.11INT21H的功能5AH：创建临时文件
创建临时文件的程序可以使用这个服务例程，特别是在网络中，其他文件的名字可能并不知道，
而要求程序避免意外地重写这些文件。此操作在路径中创建一个不重名的文件。
在CX中装入所要求的文件属性―只读（位0），隐藏（位1），系统（位2），卷标（位3），目录（位4）或存档（位5），
它们可任意组合。在DX中装入ASCIIZ路径的地址――驱动器（如有必要），子日录（如果存在），反斜线和00H，
后跟13个空字节存储新文件名：
ASCpath DB 'n:\pathname\',00H,13 DUP (20H)
...
MOV AH,5AH   ;请求创建文件
MOV CX,attribute   ;文件属性
LEA DX,ASCpath   ;ASCIIZ串路径
INT 21H   ;调用中断服务
操作成功，清除进位标志，传递文件代号到AX，添加新文件名到一个以00H字节开头的ASCIIZ串。
无效的操作设置CF，并在AX中返回代码03，04或05。
Expects: AH    5aH
DS:DX address of ASCIIZ  path (i.e., d:\path\0)
CX    file attribute
                                                                  
Returns: AX    error code if CF is set to CY
file handle (if no error)
DS:DX (+n) filename has been appended to path
                                                                  
Info: Creates (opens) a file with a unique filename in a specified
directory and returns a handle to that file and its full name.
The DOS command processor uses this function to create the
temporary "piping" files used in I/O redirection.

The pathspec must be ready to receive a filename at its end; that
is, the last character must be a backslash (\) and you must
provide at least 12 bytes at the end of the string.  In summary,
it must be in the form:

"d:\path\",0  (specify drive and path)       ...OR...
"d:",0        (default directory of a drive) ...OR...
"d:\",0       (root directory of a drive)    ...OR...
"",0          (default drive and directory)

Upon return, the string at DS:DX has a unique filename appended
to it and the file is open for read/write Access Mode.

Notes:   DOS builds a filename of hex digits obtained from the current
system date/time.  If the filename already exists, DOS keeps
trying new names until a file can be created.

  The files created ARE NOT really TEMPORARY, and must be deleted
via Fn 41H if you don't want them to clutter up your
directories.

  It is good practice to check the environment for a variable
named TEMP and use its value as the directory for the file.
18.4.12INT21H的功能5BH：创建新文件
此服务例程只创建一个文件名已经不存在的文件，其他方面和功能3CH（创建文件）相同。
当不想重写一个已存在的文件时，可以使用功能5BH。
有效操作清除进位标志，返回文件代号到AX，无效操作（包括找到同名的文件），设置CF并且在AX中返回代码03，04，05或50H。
18.4.13程序：选择性删除文件
图18-3的程序说明了使用功能4EH和4FH寻找目录中所有的文件名，并且使用功能41H删除选择的文件。
程序假定驱动器为D，并由如下过程组成：
A10MAIN 调用B10FIRST、C10NEXT、D10MESSG和E10DELETE。
B10FIRST为调用功能4EH设置DTA，并且在目录中找到第一个匹配的入口。
C10NEXT寻找目录中下一个匹配的入口。
D10MESSG显示文件名，并询问是否要删除它们。
E10DELETE接受回答Y（yes）删除文件，N（no）保留文件，或者回车结束处理，若有请求则删除文件。
作为一种预防措施，可以在测试时使用临时拷贝文件。可以通过添加屏幕滚动来改进程序。
DTA_ADDRESS DB nn DUP (?)
MOV AH,1AH   ;请求设置DTA
LEA DX,DTA_ADDRESS   ;DTA地址
INT 21H   ;调用中断服务

ASCSTRING DB‘ASCIIZ string',00H
MOV AH,4EH   ;请求第一次匹配
MOV CX,0   ;正常属性
LEA DX,ASCSTRING   ;ASCIIZ串地址（DS:DX）
INT 21H   ;调用中断服务
定位一个匹配文件的操作清除进位标志，并且用下列数据填入43字节（2BH）的DTA：
FILEDTA LABEL BYTE   ;文件DTA
DB 21 DUP (20H)   ;保留为子目录搜索
FILEATTR DB 0   ;文件属性
FILETIME DW 0   ;文件时间
FILEDATE DW 0   ;文件日期
LOWSIZE DW 0   ;文件大小 低位字
HIGHSIZE DW 0   ;文件大小 高位字
FILENAME DB 13 DUP (20H)   ;ASCIIZ串形式的文件名和扩展名，
                                                 ;紧接十六进制00
操作出错，设置CF并且返回代码02，03或12H。

MOV AH,4FH   ;请求下一个匹配文件
INT 21H   ;调用中断服务

ASCpath DB 'n:\pathname\',00H,13 DUP (20H)
...
MOV AH,5AH   ;请求创建文件
MOV CX,attribute   ;文件属性
LEA DX,ASCpath   ;ASCIIZ串路径
INT 21H   ;调用中断服务

.MODEL SMALL
.STACK 512
.DATA
MSSG_LEN EQU 32
ROW DB 0
COL DB 10
PATHNAME DB 'D:\tasm53\*.*',00H
DELMSG DB 'Delete? '
ENDMSG DB 'No more directory entries       '
ERRMSG1 DB 'Invalid path/file               '
ERRMSG2 DB 'write-protected disk            '
PROMPT DB 'Y = Delete, N = Keep, Ent = Exit'
DISKAREA DB 43 DUP (20H)
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
MOV AX,0003H
INT 10H
CALL B10FIRST
CMP AX,0000H
JNE A90
MOV CX,MSSG_LEN
LEA BP,PROMPT
CALL F10DISPLY
INC BYTE PTR ROW
A20:CALL D10MESSG
CALL E10DELETE
CMP AL,0FFH
JE A90
INC BYTE PTR ROW
CALL C10NEXT
CMP AX,0000H
JE A20
A90:MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10FIRST PROC NEAR
MOV AH,1AH
LEA DX,DISKAREA
INT 21H
MOV AH,4EH
MOV CX,0
LEA DX,PATHNAME
INT 21H
JNC B90
PUSH AX
MOV CX,MSSG_LEN
LEA BP,ERRMSG1
CALL F10DISPLY
POP AX
B90:RET
B10FIRST ENDP
C10NEXT PROC NEAR
MOV AH,4FH
INT 21H
CMP AX,0000H
JE C90
PUSH AX
MOV CX,MSSG_LEN
LEA BP,ENDMSG
CALL F10DISPLY
POP AX
C90:RET
C10NEXT ENDP
D10MESSG PROC NEAR
MOV BYTE PTR COL,10
LEA BP,DELMSG
MOV CX,8
CALL F10DISPLY
MOV BYTE PTR COL,18
LEA DI,DISKAREA+30
MOV AL,00H
MOV CX,13
CLD
REPNE SCASB
INC CX
NEG CX
ADD CX,13
LEA BP,DISKAREA+30
CALL F10DISPLY
RET
D10MESSG ENDP
E10DELETE PROC NEAR
MOV AH,10H
INT 16H
CMP AL,0DH
JE E80
OR AL,00100000B
CMP AL,'y'
JNE E90
MOV AH,41H
LEA DX,DISKAREA+30
INT 21H
JNC E90
MOV CX,MSSG_LEN
LEA BP,ERRMSG2
CALL F10DISPLY
E80:MOV AL,0FFH
E90:RET
E10DELETE ENDP
F10DISPLY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,1301H
MOV BX,0016H
MOV DH,ROW
MOV DL,COL
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
F10DISPLY ENDP
END A10MAIN
18.5要点
有关处理磁盘驱动器的操作包括对设备的重置、选择默认、获取驱动器信息、获取空闲磁盘空间以及设备的扩展操作I/O控制。
有关处理路径和FAT的操作包括创建子目录、删除了目录、改变当前目录和获得当前目录。
有关处理磁盘文件（除了创建、打开、读和写）包括文件重命名、获得/设置文件属性、寻找匹配文件和获取/设置日期/时间。
18.6习题
使用DEBUG（或其他调试程序）测试下列问题。键入A 100命令和所需要的汇编指令。检查寄存器中返回的值。
18-1.检验下列有关磁盘驱动器的问题：
（a）功能19H确定当前默认驱动器。
MOV AH,19H   ;缺省驱动器请求
INT 21H   ;调用中断服务
此操作在AL中返回驱动器号，0=A，1=B，以此类推。
（b）功能1FH获取有关默认DPB的信息。
Expects: AH    1fH
Returns: AL    0ffh on error, else...
                       0 no error and...
DS:BX address of a Drive Parameter Block for the default drive
                                                                  
Info: Returns a block of information that is useful for applications
and utilities which perform sector-level access of disk drives
supported by device drivers.

This returns the pointer for the current default drive.  
MOV AH,1FH
INT 21H
（c）功能36H确定空闲磁盘空间的数量。
MOV AH,36H   ;请求空闲磁盘空间
MOV DL,0   ;默认驱动器
INT 21H   ;调用中断服务
一个成功的操作返回如下信息：AX=每簇的扇区数；BX=可用簇数；CX=每个扇区字节数；DX=磁盘分区的总簇数。
AX，CX和DX的值提供了分区的容量。对于一个无效的设备号，此操作将在AX中返回FFFFH。
（d）功能4400H获取使用中的设备的信息。
MOV AX,4400H   ;设备信息要求
MOV BX,handle   ;文件或设备的文件代号
INT 21H   ;调用中断服务
有效操作将进位标志清零，并在DX中返回一个值，DX的位7=0时表示文件代号指向文件，位7=1表示文件代号指向设备。
其他位对文件或设备所具有的含义如下：
文件（位7=0）：
0-5驱动器号（0=A，1=B，…）
6 1=文件未写
设备（位7=1）：
0 标准控制台输入   4 专用设备
1 标准控制台输出   5 0=ASCII模式，1=二进制模式
2 空设备                 6 对于输入，0=结束返回的文件
3 时钟设备
若出错，将设置进位标志，并且在AX中返回代码01，05或06。
（e）功能4406H检查输入状态。
MOV AX,4406H
MOV BX,handle
INT 21H   ;调用中断服务
在BX中装入文件代号。操作有效时，在AL中返回下列中的一个参数：
设备：00H=未准备好，FFH=准备好
文件：00H=到达EOF，FFH=未到EOF
若出错，将设置CF，并且在AX中返回01，05或06。
（f）功能4408H确定使用的媒体是否可移动。
这一服务例程确定设备是否包含可移动的媒体，例如软磁盘。
使用时，在BL中装入驱动器号（0=默认，1=A，.…）。操作成功时，CF清零，并且在AX中返回如下一个代码：
00H=可移动设备，01H=固定设备。
若出错，将设置CF，并且在AX中返回01或0FH（无效驱动器号）。
MOV AX,4408H
MOV BL,0
INT 21H
（g）功能440DH子功能码60H获得设备参数。
MOV AX,440DH   ;请求获取设备参数
MOV BX,drive   ;驱动器（0=默认，1=A，…）
MOV CH,08H   ;设备种类（08）
MOV CL,60H   ;子功能码：获取参数
LEA DX,block；块地址（DS:DX）
INT 21H   ;调用中断服务
在DX中返回的地址以下列格式指向设备参数块（DPB）：
specfunct DB ?   ;特定函数（0或1）
devicetype DB ?   ;设备类型
devattrib DW ?   ;设备属性
cylinders DW ?   ;柱面数
mediatype DB ?   ;媒体类型
bytesects DW ?   ;每个扇区字节数
seccluster DB ?   ;每簇扇区数
ressectors DW ?   ;保留扇区数
fats DB ?   ;FAT数
rootentry DW ?   ;根目录入口数
sectors DW ?   ;扇区总数
mediadescs DB ?   ;媒体描述符
fatsectors DW ?   ;每个FAT扇区数
sectrack DW ?   ;每磁道扇区数
heads DW ?   ;读写头数
hiddensect DD ?   ;隐藏扇区数
exsects DD ?   ;扇区字段=0的扇区数
如果specfunct字段为0，信息是关于驱动器中的默认媒体；如果是1，信息是关于当前媒体的。
操作成功，CF清零并且传递数据。否则，将设置CF，并且在AX中返回错误码01，02或05。
（h）功能440DH子功能码66H获得媒体ID。
MOV AX,440DH   ;请求媒体ID
MOV BX,drive   ;驱动器（0=默认，1=A，…）
MOV CH,08H   ;设备种类（08）
MOV CL,66H   ;子功能码=获取媒体ID
LEA DX,block   ;块地址（DS:DX）
INT 21H   ;调用中断服务
在DX中返回的地址以下列格式指向媒体块：
block LABEL BYTE   ;媒体块：
infolevel DW 0   ;信息级别 0
serialno DD ?   ;序列号
vol_label DB 11 DUP (?)   ;卷标签
filetype DB 8 DUP (?)   ;FAT类型
成功的操作进位标志清零并设置ID。filetype字段包含FAT12或者FAT16的ASCII值，并用空格结尾。
否则，此操作设置CF，并且在AX中返回错误码01，02或05。
18-2.检验下列关于目录的问题：
（a）功能39H创建子目录。安全起见，可以创建在软盘上或者RAM盘上。使用任意合法的名字。
（b）功能56H重命名子目录。
（c）功能3AH删除子目录。
ASCSTRING DB 'C:\pathname',00H
MOV AH,39H   ;请求创建子目录
LEA DX,ASCSTRING   ;ASCIIZ串地址（DS:DX）
INT 21H   ;调用中断服务
操作有效时CF清零，出错时设置CF，并且在AX中返回03或05。

ASCSTRING DB 'C:\pathname',00H
MOV AH,3AH   ;请求删除子目录
LEA DX,ASCSTRING   ;ASCIIZ串地址（DS:DX）
INT 21H   ;调用中断服务
操作有效时CF清零，出错时设置CF并且在AX中返回03，05或10H。

oldstring DB 'n:\oldpath\oldname',00H
newstring DB 'n:\newpath\newname',00H
MOV AH,56H   ;请求重命名文件/目录
LEA DX,oldstring   ;DS:DX
LEA DI,newstrng   ;ES:DI
INT 21H   ;调用中断服务
操作成功则清除进位标志；操作出错，设置CF，并在AX中返回错误码02，03，05或11H。
18-3.检验下列有关磁盘文件的问题（在练习中使用文件复本）：
（a）功能43H从软盘上的文件获取属性。
（b）功能56H重命名文件。
（c）功能43H设置属性为隐藏。
（d）功能57H得到文件日期和时间。
（e）功能41H删除文件。
ASCSTRING DB 'n:\pathname',00H
MOV AH,41H   ;请求删除文件
LEA DX,ASCSTRING   ;ASCIIZ串地址（DS:DX）
INT 21H   ;调用中断服务
有效操作清零CF，目录中的文件名标记为已删除，释放FAT中分配给该文件的磁盘空间。
操作出错，设置CF，并且在AX中返回02，03或05。

ASCSTRING DB 'n:\pathname',00H
MOV AH,43H
MOV AL,00H
LEA DX,ASCSTRING   ;ASCIIZ串地址（DS:DX）
INT 21H   ;调用中断服务
有效操作CF清零，CH清零，并在CL中返回当前属性：
位   属性
0   只读文件
1   隐藏文件
2   系统文件
3   卷标
4   子目录
5   存档文件
操作出错则设置CF并且在AX中返回代码02或03。

MOV AH,43H
MOV AL,01H
MOV CX,0022H   ;隐藏和存档属性
LEA DX,ASCSTRING   ;ASCIIZ串地址（DS:DX）
INT 21H   ;调用中断服务
有效操作CF清零，并且在CX中设置目录入口项的属性。操作出错，设置CF并且在AX中返回代码02，03或05。

oldstring DB 'n:\oldpath\oldname',00H
newstring DB 'n:\newpath\newname',00H
MOV AH,56H   ;请求重命名文件/目录
LEA DX,oldstring   ;DS:DX
LEA DI,newstrng   ;ES:DI
INT 21H   ;调用中断服务
操作成功则清除进位标志；操作出错，设置CF，并在AX中返回错误码02，03，05或11H。

时间和日期的形式如下：
表示时间的位         表示日期的位
0BH~0FH   小时   09H~0FH   年（相对于1980）
05H~0AH   分      05H~08H   月
00H~04H   秒      00H-04H    日
秒是以每两秒增量的0-29之间的数字形式表示。
在AL中装入请求号（0=获取，1=设置），在BX中装入文件代号。
在请求设置日期/时间时，在CX中装入时间，DX中装入日期。下面是一个例子：
MOV AH,57H   ;请求设置文件的日期和时间
MOV AL,01H
MOV BX,handle   ;文件代号
MOV CX,time   ;新的时间（小时 分 秒）
MOV DX,date   ;新的日期（年 月 日）
INT 21H   ;调用中断服务
有效操作清除进位标志；获取操作在CX中返回时间，DX中返回日期，而设置操作改变文件的时间和日期的条目。
无效操作设置CF并且在AX中返回错误码01或06。
18-4.在DEBUG下写一个小程序，简单地执行INT21H的功能29H（解析文件名）。
在81H提供文件说明，FCB在5CH，这些单元都在紧接着程序前面的PSP。
输入各种文件说明，如n:ASMPRO1.DOC，ASMPRO2，ASMPRO3.*和n:*.ASM。
每个解析功能执行后，在偏移地址5CH单元检查结果。
Expects: AH    29H
AL    bit-flags to select parsing options (see below)
DS:SI address of source text line to parse
ES:DI address of buffer to hold resulting unopened FCB
                                                                  
Returns: AL    0    if result FCB has no wildcard characters
1    if result FCB does contain wildcards 
0ffH if invalid drive ID in filespec
DS:SI updated: points to the character just past the filename
ES:DI preserved: points to the unopened FCB
                                                                  
Info: Creates an unopened FCB from a text line or command parameter.
The text starting at DS:SI is parsed for a filespec in the format
D:FILENAME.EXT and the buffer at ES:DI is filled in as a
properly-formatted, unopened FCB.

     This Fn is NOT useful for a text line containing a pathname.
Basically, this is a quick way to skip leading spaces, upshift
and remove the dot (.) from a filename input from the keyboard.
It converts * into a series of ?s and it allows you to pre-set a
default in the destination FCB (e.g., extension = "WKS").

The parsing action depends upon these bit flags in AL:
 7 6 5 4 3 2 1 0 
 0 0 0 0         
                  bit                                  mask value
          0: 1=scan off leading separators     (a | 01H)
          1: 1=use FCB drive byte as a default (a | 02H)
          2: 1=use FCB filename as a default   (a | 04H)
          3: 1=use FCB extension as a default  (a | 08H)
MOV AH,29H
MOV AL,0FH
MOV SI,81H
MOV DI,5CH
INT 21H
E DS:81H ... 
第19章磁盘存储IV:INT13H磁盘功能
19.1引言
19.2 BIOS 状态字节
19.3基本的INT13H磁盘操作
19.4其他INT13H磁盘操作
19.5要点
19.6习题
目的：检验使用BIOS INT 13H功能来格式化、检验、读磁盘和写磁盘的基本要求。
19.1引言
在第17和18章中，我们检验了INT 21H的磁盘处理服务例程，也可以使用INT 13H在BIOS级直接处理，
尽管BIOS不提供自动使用FAT、目录或记录的分块和解块功能。BIOS磁盘操作INT 13H处理一个扇区大小的数据，
按实际磁道和扇区号来处理磁盘寻址。INT 13H磁盘操作包括重置、读取、写入、检测和格式化驱动器。
大多数INT 13H操作是为有经验的软件开发者使用的，他们了解错误操作带来的潜在危险。
同时，由于使用的处理器，甚至计算机的型号不同，BIOS版本也可能不同。
本章将讲述INT 13H的下述功能：
00H   重置硬盘/软盘系统         0CH   搜索柱面
01H   读硬盘/软盘状态            0DH   代替磁盘重置
02H   读扇区                           0EH   读扇区缓冲区
03H   写扇区                           0FH   写扇区缓冲区
04H   检测扇区                        15H   获取硬盘/软盘类型
05H   格式化磁道                     16H   改变软盘状态
08H   获取驱动器参数              17H   设置软盘类型
09H   初始化驱动器                 18H   设置格式化的媒体类型
0AH   读扩展扇区缓冲区          19H   停置磁头
0BH   写扩展扇区缓冲区
19.2BIOS状态字节
大多数INT13H功能在成功或失败时清除或设置CF，并且在AH寄存器中返回一个状态码。
BIOS在它的数据区保留每个设备及其状态的信息。如图19-1所示的状态字节反映了
BIOS数据区中的指示器各位的意义，40：41H是软盘驱动器数据区，40：74H是硬盘数据区（详见第24章）。
如果磁盘操作返回一个错误，程序通常的做法是重置磁盘（功能00H），并且重试这个操作3遍。
如果错误仍然出现，程序将显示信息，并给用户更换软盘的机会（如果这样可以解决问题的话）。
代码   状态
00H   无错
01H   错误命令，未被控制器识别
02H   磁盘上的地址标记未找到
03H   试图写保护盘
04H   无效磁道/扇区
05H   重置操作失败
06H   上次访问后软盘移动
07H   驱动器参数错
08H   直接存储器存取（DMA）过速（存取数据太快，无法输入）
09H   DMA超过64K的限制，试图读/写
10H   读盘时遇到坏CRC（指出被破坏数据的错误检查）
20H   控制器失败（硬件山错）
40H   查找操作失败（硬件出错）
80H   设备无响应（软盘：驱动器门打开或无软盘；硬盘：超时）
AAH   驱动器未准备好
BBH   未定义错
CCH   写失效
19.3基本的INT 13H磁盘操作
这节包含基本的INT   13H磁盘操作，每个请求的功能码都存在AH中。
19.3.1INT13H的功能00H：重置磁盘系统
前面讲到的磁盘操作在报告了一个严重错误之后，程序可能使用这个操作。
本操作对软盘或者硬盘控制器执行强制性的重置操作，即下一次访问磁盘时，它首先重置于柱面0。
对于软盘，设置DL为驱动器号（0=驱动器A，等等），
对于硬盘，设置DL为80H或大于80H的值（80H=驱动器C，81H=D，等等），使用功能00H的例子如下：
MOV AH,00H   ;请求重置磁盘
MOV DL,80H   ;磁盘驱动器C
INT 13H   ;调用中断服务
有效操作清除CF；错误操作设置CF，并在AH中返回状态码。与此相关的操作是功能0DH。
19.3.2INT13H的功能01H：读磁盘状态
此操作提供了检查最近一次磁盘操作状态的另一个机会（见图19-1的BIOS状态字节）。
对于软盘，设置DL为通用码（0=驱动器A，等等），
对于硬盘，设置DL为80H或大于80H的值（80H=第一个驱动器，等等）。
此操作在AL中返回状态码，这个状态码在最近一个磁盘操作时已经返回给AH了。
这一操作总是有效的，清除CF并且在AH中返回它自己的状态码00H。
19.3.3INT13H的功能02H：读扇区
这一操作将同一磁道上的指定数量的扇区直接读取到存储器。
注意：柱面/磁道号从0开始，而扇区号从1开始。初始化如下寄存器：
AL   扇区数，最多为一个磁道的扇区数
CH   柱面/磁道号（低8位）
CL   位7~6是柱面/磁道号（高2位）
       位5~0为起始扇区号
DH   读写头/盘面号（对于软盘是0或1）
DL   软盘驱动器号（0=A）或硬盘驱动器号（80H=C）
ES:BX   数据区内I/O缓冲区的地址，数据区应足够大以容纳所有要读取的扇区。
（BX和ES配合使用）下面的例子是读一个扇区到SECTOR的区域：
SRCTOR DB 512 DUP (?)
MOV AH,02H   ;请求读扇区
MOV AL,01H   ;一个扇区
LEA BX,SECTOR   ;输入缓冲区（ES:BX）
MOV CH,05H   ;磁道05
MOV CL,03H   ;扇区03
MOV DH,00H   ;读写头00
MOV DL,00   ;0=驱动器A，80H=C，等等
INT 13H   ;调用中断服务
有效操作清除CF，并在AL中返回操作实际读取的扇区数。保持DS、BX、CX和DX的内容。
操作出错则设置CF，并且AH中返回状态码，重置驱动器（功能00H），然后重试这个操作。
大多数情况下，只指定的一个扇区或者一个磁道上的全部扇区。初始化CH和CL，然后加1顺序读取下一个扇区。
一旦扇区号超过了磁道最大扇区数时，扇区号重置为01，并且在磁盘同一盘面上的磁道号加1，或者对下一盘面的读写头号加1。
测试软盘是否准备好。程序可能发出请求访问一个尚未插入的软盘。标准操作是尝试操作3次后显示信息给用户。
下例是试图使用INT13H的功能02H读一个扇区的数据。
试着使用DEBUG输入指令（但没有语句号或注释），在驱动器A中有磁盘或无磁盘的情况下测试程序代码。
对于已装入软盘的情况，操作应该读出磁盘根目录下的内容，根目录有512（200H）字节，起始位置为DS：200H。程序代码如下：
0100   MOV CX,03   ;循环计数
0103   PUSH CX   ;保存计数
0104   MOV AX,0201   ;请求读一个扇区
0107   MOV BX,0200   ;输入地址
010A   MOV CX,0001   ;磁道和扇区号
010D   MOV DX,0000   ;读写头和驱动器号
0110   INT 13H   ;调用中断服务
0112   POP CX
0113   JNC 118   ;如果没错，退出
0115   CLC
0116   LOOP 103   ;尝试3次
0118   JMP 100   ;再次执行
19.3.4INT13H的功能03H：写扇区
与功能02H相反，此操作从内存写一个特定区域（512字节或512的倍数）到已格式化的指定扇区。
加载寄存器和文件代号的过程同功能02H。一个有效操作清零CF，并传递写入的扇区数到AL，保持DS，BX，CX，DX中的内容。
操作出错，设置CF，在AH中返回状态码，重置驱动器并重试操作。
19.3.5程序：使用INT 13H读扇区
图19-2程序中使用INT 13H从磁盘读数据到存储器。注意，没有打开操作或文件代号。
主要数据区如下：
BEGINADR 包含起始磁道（03）和扇区（01），它们在程序中增量。
ENDADR 包含结束磁道（04）和扇区（01）。
扇区的总数是9（磁道3的）×2（2个盘面）=18。
改进程序的一种方法是给用户提示开始的和结束的磁道和扇区。
SECTOR为要读取的扇区定义一个512字节的数据区。
主要过程如下：
A10MAIN 调用B10ADDR、C10READ和D10DISPLY，读入最后一个请求的扇区后结束。
B10ADDR根据盘面、磁道和扇区计算每个磁盘地址。
当扇区数到达19的时候，程序重新设置扇区为01。
如果盘面是1，程序增加磁道数，然后改变盘面号，从0到1或者从1到0。
这个过程只处理每磁道18个扇区的软盘（因为软盘是双面）。
C10READ从驱动器A读一个扇区到SECTORIN，有效读操作后扇区号加1。
D10DISPLY显示当前读取的扇区的内容（INT 10H的功能13H对回车和换行起作用），并等待用户按任意键继续。
在DEBUG下运行程序，从初始化段寄存器的指令开始跟踪。
对于输入操作，判定开始和结束扇区在FAT中的位置（参见第16章）。
用G（go）命令执行程序，检测FAT和SECTORIN的目录入口项。
程序也能将输入区的ASCII字符转换成对等的十六进制数并且显示出来，正如DEBUG所做的一样（见图14-5程序）。
用这种方法可以检验任意扇区的内容―甚至隐藏的内容，允许用户改变输入数据并将改变后的扇区内容写回磁盘。
SECTOR DB 512 DUP (?)
MOV AH,02H   ;请求读扇区
MOV AL,01H   ;一个扇区
LEA BX,SECTOR   ;输入缓冲区（ES:BX）
MOV CH,05H   ;磁道05
MOV CL,03H   ;扇区03
MOV DH,00H   ;读写头00
MOV DL,00   ;0=驱动器A，80H=C，等等
INT 13H   ;调用中断服务

.MODEL SMALL
.STACK 512
.DATA
BEGINADR DW 0301H
ENDADR DW 0401H
SIDE DB 00H
ENDCODE DB 00H
READMSG DB '*** Read error ***'
SECTORIN DB 512 DUP (20H)
XLATAB DB 30H,31H,32H,33H,34H,35H,36H,37H,38H,39H
              DB 41H,42H,43H,44H,45H,46H
DISPAREA DB 1024 DUP (20H)
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
A20:MOV AX,0003H
INT 10H
CALL B10ADDR
MOV CX,BEGINADR
MOV DX,ENDADR
CMP CX,DX
JE A90
CALL C10READ
CMP BYTE PTR ENDCODE,00H
JNZ A90
CALL E10CONVRT
JMP A20
A90:MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10ADDR PROC NEAR
MOV CX,BEGINADR
CMP CL,19
JNE B90
MOV CL,01H
CMP BYTE PTR SIDE,00H
JE B20
INC CH
B20:XOR BYTE PTR SIDE,01H
MOV BEGINADR,CX
B90:RET
B10ADDR ENDP
C10READ PROC NEAR
MOV AH,02H
MOV AL,01H
LEA BX,SECTORIN
MOV CX,BEGINADR
MOV DH,SIDE
MOV DL,00H
INT 13H
JNC C90
MOV BYTE PTR ENDCODE,01H
LEA BP,READMSG
MOV CX,18
CALL D10DISPLY
C90:INC WORD PTR BEGINADR
RET
C10READ ENDP
E10CONVRT PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH SI
PUSH DI
PUSH BP
LEA DI,DISPAREA
LEA SI,SECTORIN
CLD
E20:MOV AL,DS:[SI]
SHR AL,1
SHR AL,1
SHR AL,1
SHR AL,1
LEA BX,XLATAB
XLAT
STOSB
MOV AL,DS:[SI]
AND AL,0FH
XLAT
STOSB
INC SI
LEA BX,SECTORIN+512
CMP SI,BX
JB E20
LEA BP,DISPAREA
MOV CX,1024
CALL D10DISPLY
POP BP
POP DI
POP SI
POP DX
POP CX
POP BX
POP AX
RET
E10CONVRT ENDP
D10DISPLY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,1301H
MOV BX,0016H
MOV DX,0300H
INT 10H
MOV AH,10H
INT 16H
POP DX
POP CX
POP BX
POP AX
RET
D10DISPLY ENDP
END A10MAIN
当用INT 21H写文件时，在可用的簇中插入记录，这些簇在磁盘中可能不相邻。
由于这个原因，不能期望INT 13H顺序地读出这个文件，但可以访问FAT的入口项来得到下一簇的位置。
19.4其他INT 13H磁盘操作
以下部分描述附加的INT13H磁盘服务例程。
19.4.1INT13H的功能04H：检测扇区
这一操作简单检查指定的可读扇区，并且执行柱面冗余检验（CRC）。
当一个操作写数据到扇区时，磁盘控制器根据设置的位计算CRC校验和，并写入紧接着的扇区。
可以使用功能04H读扇区，重新计算校验和，并与存储的值相比较。
核对数只由重新计算的校验和组成，它不检验扇区内的字节值是否和内存中数据一致。
在写（功能03H）之后可用此功能来确保更可靠的输出，但要花费更多的处理时间。
加载寄存器和功能02H相同，但是由于操作并不检验所写数据，所以不需要设置ES:BX地址。
一个成功的操作清除CF，并在AL中返回实际检测的扇区数，保持DS，BX，CX，DX中的内容。
操作出错设置CF，在AH中返回状态码，并且重置驱动器，重试此操作。
19.4.2INT13H的功能05H：格式化轨迹
读/写操作要求磁道的格式化信息来定位和访问请求的扇区。
这个操作根据4种不同的大小来格式化磁道。在执行此操作之前，要使用功能17H设置软盘类型，使用功能18H设置媒体类型。
为了格式化磁盘，初始化寄存器如下：
AL   要格式化的扇区数
CH   柱面/磁道号（从0开始）
DH   读写头/盘面号（软盘是0或1）
DL   软盘驱动器号（0=A）或硬盘驱动器号（80H=C）
ES:BX   段：偏移地址指向磁道的一组地址字段。对磁道上的每个扇区都有一个4字节的入口项，格式为T/H/S/B：
字节0   T=柱面/磁道号
      1   H-读写头/盘面号
      2   S=扇区号
      3   B=每扇区的字节数（00H=128，01H=256，02H=512，03H=1024）
例如，要格式化磁道03，读写头00，每个扇区512字节，磁道的第一个入口项是0300 0102H，
接着是每个剩余扇区的一个入口项。
该操作清除（如有效）或设置（如无效）进位标志，并在AH中返回状态码。
19.4.3INT13H的功能08H：获取驱动器参数
这个很有用的功能返回有关磁盘驱动器的信息。
在DL中装入驱动器号（软盘：0=A，1=B，硬盘：80H或更大）。成功操作返回如下信息：
BL   软盘类型（01H=360K，02H=1.2M，03H=720K，04H=1.44M）
CH   柱面/磁道号的高位
CL   位7~6=柱面号的高2位
      位5~0=扇区号的高位
DH   读写头号的高位
DL   与控制器连接的驱动器数
ES:DI对于软盘，是11字节的软盘驱动器参数表的段：偏移地址。两个相关的字段是：
偏移地址3给出每个扇区的字节数（00H=128，01H=256，02H=512，03H=1024）
偏移地址4给出每个磁道的扇区数。
操作清除（如有效）或者设置（如无效）进位标志，并在AH中返回状态码。
试使用DEBUG命令D ES：偏移地址（返同在DI中的偏移地址）来显示驱动器参数。
19.4.4INT13H的功能09H：初始化驱动盘
当根据计算机自带的硬盘表启动计算机时，BIOS执行此功能。DL中为驱动器号（80H或更大）。
操作清除（有效）或者设置（无效）进位标志，并在AH中返回状态码。相关操作有BIOS INT 41H和INT 46H。
19.4.5INT13H的功能0AH：读扩展扇区缓冲区
硬盘上的扇区缓冲区包括512字节的数据再加上4个字节的纠错码（ECC），用来检查错误并纠正。
这一功能可以读整个扇区缓冲区，不仅仅是数据区部分。为了读扩展缓冲区，加载如下寄存器：
AL   扇区数（最多为一个驱动器的最大扇区数）
ES:BX   段：偏移量，输入缓冲区的地址
CH   柱面/磁道号
CL   位7~6=柱面号的高2位
       位5~0=扇区号高位
DH   读写头/盘面号
DL   驱动器号（80H或更高）
成功操作在AL中返回传输的扇区数。
操作清除（有效）或者设置（无效）进位标志，并在AH中返回状态码。
19.4.6INT13H的功能0BH：写扩展扇区缓冲区
这一功能和功能0AH相似，但这一功能是把缓冲区的内容（包括ECC码）写到硬盘上。
19.4.7INT13H的功能0CH：搜索磁盘柱面
这一功能可以把硬盘的读写头定位到某一指定的柱面（磁道）上，但不传送任何数据。为了搜索柱面，加载如下寄存器：
CH   柱面/磁道号
CL   位7~6=柱面/磁道号的高2位
       位5~0=扇区号
DH   磁头/盘面号
DL   驱动器号（80H=C）
操作清除（有效）或者设置（无效）CF并且在AH中返回状态码。
19.4.8INT13H的功能0DH：交替磁盘重置
除了只适用于硬盘外，这一操作和功能00H相同。
在DL中设置驱动器号（80H或更大的值）。操作重置读写访问臂到柱面0。
操作清除（有效）或者设置（无效）CF，并在AH中返回状态码。
19.4.9INT13H的功能0EH：读扇区缓冲区
这一操作和功能0AH一样，它只读取512字节的数据区，不读取ECC字节。
19.4.10INT13H的功能0FH：写扇区缓冲区
这一操作和功能0BH一样，它只写512字节的数据区，不写ECC字节。
19.4.11INT13H的功能10H：测试驱动器是否准备好；11H：重新校准硬盘驱动器；12H：诊断ROM；
                                 13H：诊断驱动器；14H：诊断控制器
这些功能执行内部诊断，并将特殊信息报告给BIOS和高级应用程序。
操作清除（有效）或者设置（无效）CF并且在AH中返回状态码。
19.4.12INT13H的功能15H：得到磁盘类型
这功能返回磁盘驱动器的信息。
对于磁盘，在DL中设置驱动盘号（0=A，.…）；对于硬盘，在DL中设置80H或更大的值（80H=C，81H=D，.…）。
有效操作在AH中返回如下代码之一：
00H   当前没有驱动器/磁盘
01H   软盘驱动器不检测换盘
02H   软盘驱动器检测换盘
03H   软盘驱动器
当AH中返回03H时，CX:DX包含了驱动器上硬盘扇区的总数。
操作清除（有效）或设置（无效）进位标志并且在AH中返回状态码。
19.4.13INT13H的功能16H：改变磁盘状态
这一功能为能够检测换盘的系统检测换磁（参见功能15H）。
在DL中设置驱动盘号（0=A，.…）。操作在AH中返回如下代码之一：
00H   没有换磁（CF=0）
01H   无效磁盘参数（CF=1）
06H   换盘（CF=1）
80H   软盘驱动器未准备好（CF=1）
状态01H和80H是错误状态，所以要设置CF，而06H是一种有效状态但也设置 CF一这是容易造成混淆的一个原因。
19.4.14INT13H的功能17H：设置软盘类型
这一操作设置软盘和驱动器的组合。一起使用功能17H和功能05H可以格式化磁盘。
在DL中设置驱动器号（0=A，.….），在AL中加载软盘类型。
软盘类型包括：01H=360K软盘及360K驱动器，02H=360K软盘及1.2M驱动器，03H=1.2M软盘及1.2M驱动器，
04H=720K软盘及720K驱动器，05H=1.44M软盘及1.44M驱动器。
操作清除（有效）或者设置（无效）CF并且在AH中返回状态码。
19.4.15INT13H的功能18H：设置格式化媒体类型
此操作紧挨着功能05H之前执行。为了设置媒体类型，加载如下寄存器：
CH   磁道数（低8位）
CL   磁道数（高2位在位7~6），
       每个磁道的扇区数（位5～0）
DL   驱动器（0=A，...）
有效操作在ES:DI中返回一个指向11字节的磁盘参数表（参见功能08H）。
操作清除（有效）或者设置（无效）CF并且在AH中返回状态码。
19.4.16INT13H的功能19H：停置磁头
较早的磁盘驱动器在关掉系统后，将读写头置于驱动器表而上，所以必须将读写头停置到一个安全区域。
目前的大部分驱动器都可以自动停置磁头。操作要求在DL中加载驱动器号（对于硬盘，80H或更大）。
操作清除（有效）或者设置（无效）CF，并在AH中返问状态码。
19.5要点
BIOS INT13H提供了对磁道和扇区的直接访问。操作包括重置/读磁盘状态，读/写扇区和格式化磁道。
INT13H不能提供自动目录处理，文件结束操作，或记录的分块和解块功能。
检验扇区操作对写数据进行基本检验，这要花费一定的执行时间。
程序在每个INT 13H磁盘操作后要检验状态字节。
19.6习题
19-1.使用BIOSINT13H的两个主要缺点是什么？为什么经常使用INT21H？
BIOS INT 13H不提供自动使用FAT、目录或记录的分块和解块功能。
BIOS INT 13H处理一个扇区大小的数据，按实际磁道和扇区号来处理磁盘寻址。
INT 21H提供许多功能，方便操作文件、目录。
19-2.在什么情况下程序员可以使用INT13H？
如果INT 21H没有提供所需的功能，而BIOS INT 13H提供了，那么可以选择使用BIOS INT 13H。
INT 13H磁盘操作包括重置、读取、写入、检测和格式化驱动器。
大多数INT 13H操作是为有经验的软件开发者使用的，他们了解错误操作带来的潜在危险。
19-3.INT13H操作返回一个状态码。（a）返回的状态码在哪里？（b）代码00H的含义是什么？（c）代码03H的含义是什么？
大多数INT13H功能在成功或失败时清除或设置CF，并且在AH寄存器中返回一个状态码。
代码   状态
00H   无错
03H   试图写保护盘
19-4.INT13H返回错误的标准过程是什么？即如何检验出错，如何处理？
大多数INT13H功能在成功或失败时清除或设置CF，并且在AH寄存器中返回一个状态码。
如果磁盘操作返回一个错误，程序通常的做法是重置磁盘（功能00H），并且重试这个操作3遍。
如果错误仍然出现，程序将显示信息，并给用户更换软盘的机会（如果这样可以解决问题的话）。
19-5.编写重置磁盘控制器的程序。
MOV AH,00H   ;请求重置磁盘
MOV DL,80H   ;磁盘驱动器C
INT 13H   ;调用中断服务
有效操作清除CF；错误操作设置CF，并在AH中返回状态码。
19-6.编写读磁盘状态的程序。
MOV AH,01H   ;读磁盘状态
MOV DL,80H
INT 13H
对于软盘，设置DL为通用码（0=驱动器A，等等），
对于硬盘，设置DL为80H或大于80H的值（80H=第一个驱动器，等等）。
此操作在AL中返回状态码，这个状态码在最近一个磁盘操作时已经返回给AH了。
这一操作总是有效的，清除CF并且在AH中返回它自己的状态码00H。
19-7.使用驱动器A，读写头0，磁道4，扇区6，用INT13H指令编写读4个扇区到数据区SECTORS的程序。
SECTORS DB 4096 DUP (?)
...
MOV AH,02H   ;请求读扇区
MOV AL,04H   ;4个扇区
LEA BX,SECTORS   ;输入缓冲区（ES:BX）
MOV CH,04H   ;磁道04
MOV CL,06H   ;扇区06
MOV DH,00H   ;读写头00
MOV DL,00   ;0=驱动器A，80H=C，等等
INT 13H   ;调用中断服务
...
19-8.使用存储器地址SECTOR，驱动器A，读写头0，磁道6，扇区4，用INT13H指令编写程序写一个扇区。
注意使用备用磁盘来做这个练习。
SECTOR DB 512 DUP (?)
...
MOV AH,03H   ;请求写扇区
MOV AL,01H   ;一个扇区
LEA BX,SECTOR   ;输出缓冲区（ES:BX）
MOV CH,06H   ;磁道06
MOV CL,04H   ;扇区04
MOV DH,00H   ;读写头00
MOV DL,00   ;0=驱动器A，80H=C，等等
INT 13H   ;调用中断服务
...
19-9.在上题中，写操作后，怎样检验是写一个写保护的磁盘？
操作出错，设置CF，在AH中返回状态码
代码   状态
03H   试图写保护盘
19-10.在19-8基础上，编写检验写操作的程序。
SECTOR DB 512 DUP (?)
...
MOV AH,03H   ;请求写扇区
MOV AL,01H   ;一个扇区
LEA BX,SECTOR   ;输出缓冲区（ES:BX）
MOV CH,06H   ;磁道06
MOV CL,04H   ;扇区04
MOV DH,00H   ;读写头00
MOV DL,00   ;0=驱动器A，80H=C，等等
INT 13H   ;调用中断服务
JNC Label1
CMP AH,03H
JNE Error1
...
Error1:
...
Label1:
...
第20章打印程序
20.1引言
20.2普通打印机控制符
20.3INT21H的功能40H：打印字符
20.4专用打印机控制符
20.5BIOS INT 17H打印功能
20.6要点
20.7习题
目的：描述使用各种中断操作进行打印的必要条件。
20.1引言
与屏幕和磁盘处理相比，打印处理显得相对简单，它只包括几个操作，通过INT 21H或者BIOS INT 17H指令完成。
发送给打印机的特殊命令包括：换页、换行、Tab和回车。
打印机必须理解发自处理器的信号，例如，走一页纸，向下换一行，或者换页定位。
处理器也必须理解表示打印机“正忙”或者“缺纸”的信号。
不幸的是，不同类型的打印机对于处理器信号的回应是不同的，而软件专业人员的任务之一就是使程序与这些打印机配接。
本章介绍了用于处理打印机的中断操作如下：
INT 21H功能
40H 打印字符
INT 17H功能
00H 打印字符
01H 初始化端口
02H 获取打印机端口状态
20.2普通打印机控制符
用于控制PC机上使用的普通打印机的标准字符如下：
十进制         十六进制         功能
09               09H               水平Tab
10               0AH               换行（前进一行）
12               0CH               换页（前进到下一页）
13               0DH               回车（回到左页边）
1.水平Tab
水平Tab（09H）控制符使打印机从当前的打印位置前进到下个Tab停止处（如果已设置，通常每8个位置即停）。
该命令只对有此功能的打印机，并且打印机的Tab功能已被设置时有效。
如果打印机没有打印Tab的能力，可以使用一连串的空格字符来代替。
2.换行
换行（0AH）控制符使打印机前进一行，两个连续的换行符可以得到两个空行。
3.换页
当启动打印机时，初始的页决定了每页顶端的开始位置。一页默认的长度是11英寸，按照每英寸6行计算，每页有66行。
处理器和打印机都不会自动检查页的底端。无论在一台激光打印机上使用分页格式还是连续打印格式，
程序员要负责指示打印机开始下页的打印。
为了控制换页，可以在打印的同时计算行数，当达到一页的最大行数（比如60行）时，使用换页（0CH）控制命令，
然后将程序的行计数重新设置为0或1。
打印结束时，传送换行或者换页控制命令强制打印机将仍在缓冲区中的最后一行打印出来。
在打印结束发出的换页符可以保证最后一页送出打印机。
4.回车
回车（0DH）控制字符通常和换行命令一起使用，可将打印机重新置于它最左面的页边。
该字符即为键盘上的<Enter>键或<Return>键，屏幕显示时为CR。
20.3INT 21H的功能40H：打印字符
在关于屏幕处理和磁盘处理的章节中，我们已经用到了文件代号。为了使用INT21H的功能40H打印，需设置下列寄存器：
AH=功能40H
BX=文件代号04
CX=打印的字符数
DX=打印数据的地址
0000H  Standard Input Device  (usually the keyboard)
0001H  Standard Output Device (usually the screen)
0002H  Standard Error Device  (always CON--the screen.  Use for messages)
0003H  Standard AUX Device    (AUX first serial port--COM1)
0004H  Standard Printer       (PRN first parallel printer port--LPT1)
下面的例子从左页边开始打印HEADING数据项中的27个字符。紧接着HEADING正文的回车符（0DH）和换行符（0AH）
使打印机重置到0列并前进一行：
CR EQU 0DH   ;回车
LF EQU 0AH   ;换行
HEADING DB 'Mountain outfitting Corp.',CR,LF
...
MOV AH,40H   ;请求打印
MOV BX,0004H   ;打印机的文件代号04
MOV CX,27   ;发送27个字符
LEA DX,HEADING   ;打印数据的地址
INT 21H   ;请求中断服务
成功的操作将打印正文，清除进位标志，并且在AX中返回打印的字符数。
不成功的操作会设置进位标志，并在AX中返回错误代码05（拒绝存取）或者06（非法文件代号）。
传输数据中的文件尾标记（Ctrl-Z或者1AH）也会终止操作。
下面两种情况会中断试图打印的动作：
1.打印机电源没有打开。系统显示
“Write Fault Error Writing Device PRN”
“Abort Retry Ignore Fail"
2.缺纸或卡纸。系统显示
“Printer out of paper error writing device PRN”
20.3.1程序：具有页溢出处理和标题的打印程序
前面图8-2中的程序从键盘接受名字并在屏幕上显示出来。图20-1中的程序与此相似，不同的是将名字发送给打印机。
打印出来的每一页都包括一个标题，紧接着两个空格，输入姓名的打印格式如下：
List of Customer Names Page 01
Annie Hall
Fanny Hill
Danny Rose
...
该程序对每个打印行计数，当接近一页的底端时，将格式换到下页的顶端。主要的过程如下：
A10MAIN调用B10INPUT和C10PRINT，当用户仅按下回车键时结束处理。
B10INPUT提示输入并且接受从键盘输入的姓名。
C10PRINT调用D10PAGE（如果在页尾）并且打印姓名（其长度取决于键盘输入参数列表中的实际长度）。
D10PAGE前进到新的一页，打印标题，重置行计数，并使页计数增加。
P10OUT处理打印请求。
.MODEL SMALL
.STACK 512
.DATA
NAMEPAR LABEL BYTE
MAXNLEN DB 20
NAMELEN DB ?
NAMEFLD DB 20 DUP (20H)
HEAD_LEN EQU 37
HEADING DB 'List of customer Names       Page'
PAGECTR DB '01',0DH,0AH,0AH
BOTTPAGE EQU 60
FORMFEED DB 0CH
LINEFEED DB 0DH,0AH
LINECTR DB 01H
PROMPT DB 'Name: '
ROW DB 0
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
MOV AX,0003H
INT 10H
MOV AL,00H
CALL Q10SCROLL
CALL D10PAGE
A20:CALL B10INPUT
CMP BYTE PTR NAMELEN,00H
JE A30
CALL C10PRINT
JMP A20
A30:MOV CX,01H
LEA DX,FORMFEED
CALL P10OUT
MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10INPUT PROC NEAR
MOV AX,1301H
MOV BX,0016H
LEA BP,PROMPT
MOV CX,6
MOV DH,ROW
MOV DL,10
INT 10H
MOV AH,0AH
LEA DX,NAMEPAR
INT 21H
CMP BYTE PTR ROW,24
JAE B30
INC BYTE PTR ROW
JMP B90
B30:MOV AL,01H
CALL Q10SCROLL
B90:RET
B10INPUT ENDP
C10PRINT PROC NEAR
CMP BYTE PTR LINECTR,BOTTPAGE
JB C20
CALL D10PAGE
C20:MOV CX,0
MOV CL,NAMELEN
LEA DX,NAMEFLD
CALL P10OUT
MOV CX,02H
LEA DX,LINEFEED
CALL P10OUT
INC BYTE PTR LINECTR
RET
C10PRINT ENDP
D10PAGE PROC NEAR
CMP WORD PTR PAGECTR,3130H
JE D30
MOV CX,01H
LEA DX,FORMFEED
CALL P10OUT
D30:MOV CX,HEAD_LEN
LEA DX,HEADING
CALL P10OUT
MOV BYTE PTR LINECTR,03H
INC BYTE PTR PAGECTR+1
CMP BYTE PTR PAGECTR+1,3AH
JNE D90
MOV BYTE PTR PAGECTR+1,30H
INC BYTE PTR PAGECTR
D90:RET
D10PAGE ENDP
P10OUT PROC NEAR
MOV AH,40H
MOV BX,0004H
INT 21H
RET
P10OUT ENDP
Q10SCROLL PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AH,06H
MOV BH,16H
MOV CX,0000H
MOV DX,184FH
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
Q10SCROLL ENDP
END A10MAIN
在执行的开始，程序必须打印标题，但是不走纸到新的一页。结束时，如果 PAGECTR为其初始值01，D10PAGE跳过换页操作。
PAGECTR被定义为DB '01'，这会产生一个ASCII数字3031H。程序使PAGECTR增1，这样它就逐渐变为3032，3033，以此类推。
这个值直增长到3039都是有效的，此后将变为303A，这会打印出0和冒号。此时，程序将个位数字重置，3AH变为30H，
并且在十位数字上加1，所以，303AH变为3130H，或者十进制数字10。PAGECTR的容量是99。
在每页的结尾打印姓名之前（而不是之后）设置一个检验，以确定在最后一页的标题之下至少有一个名字。
可以通过添加滚动来改进程序。
20.3.2程序：打印ASCII文件并处理Tab
一个通用程序，例如显示系统所执行的程序，在到达下一个可以被8整除的位置之前用空白来代替Tab符（09H）。
这样Tab的终止处可以在位置8，16，24，以此类推，所以在0到7之间的位置都定位到8，而在8到15之间的定位到16，
以此类推。但是，有些打印机对Tab符不起作用。一个打印ASCII文件（例如汇编源文件）的程序，
应该检查每一个传送到打印机的字符。如果字符是Tab，程序应插入空白一直到下一个定位位置。
图20-2的程序要求用户键入一个文件名，并打印该文件的内容。这个程序与图17-3中显示记录的程序相似，
更进一步的处理是，用一段空白代替打印机的Tab终止位置。下面是3个Tab终止位置的例子，
其打印位置是1、9和21，设置下一个Tab位置的逻辑如下：
清除最右边3位，再加8
1->0+8->8
9->8+8->16
21->16+8->24
程序的组织如下：
A10MAIN 调用B10PROMPT，C10OPEN，D10READ和E10XFER。
B10PROMPT要求用户键入文件名。按回车键表示结束。
C10OPEN打开要求的磁盘文件作为输入。如果操作是合法的，程序使用NT21H的功能42H来确定文件的大小
（仅用低位部分，最大为65535字节）。
D10READ从文件读入一个扇区。
E10XFER检查输入的数据，查找扇区尾，文件尾，显示区的结尾，换行和Tab。
这个过程序基本上向打印区发送的都是规则的字符，并且用上述逻辑处理来定位Tab的终止位置。
这个程序通过每个字符处理后存储的文件大小递减1来确定文件的末尾。
P10PRINT打印输出行，并将其清除为空白。
可以修改程序的打印行计数，并且在靠近一页的底端，在60行左右强制换页；
也可以使用一个编辑程序直接将换页符插入到你的ASCII文件中，恰好在一页终止的位置上，就像在一个过程的结尾一样。
通常的方法是按下Alt键和数字键盘上的数字键，例如换页是012。
FILEDTA LABEL BYTE   ;文件DTA
DB 21 DUP (20H)   ;保留为子目录搜索
FILEATTR DB 0   ;文件属性
FILETIME DW 0   ;文件时间
FILEDATE DW 0   ;文件日期
LOWSIZE DW 0   ;文件大小 低位字
HIGHSIZE DW 0   ;文件大小 高位字
FILENAME DB 13 DUP (20H)   ;ASCIIZ串形式的文件名和扩展名，
                                                 ;紧接十六进制00

.MODEL SMALL
.STACK 512
.DATA
NAMEPAR LABEL BYTE
MAXLEN DB 32
NAMELEN DB ?
FILENAME DB 32 DUP (20H)
FILEDTA LABEL BYTE
DB 26 DUP (20H)
FILESIZE DW 0
               DW 0
DB 13 DUP (20H)
PRINT_LEN EQU 120
COUNT DW 0
ENDCODE DW 0
FORMFEED DB 0CH
HANDLE DW 0
OPENMSG DB '*** Open error ***'
PRNTAREA DB 256 DUP (20H)
PROMPT DB 'Name of file: '
ROW DB 0
SECTOR DB 512 DUP (20H)
.CODE
A10MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
MOV AX,0003H
INT 10H
A20:MOV WORD PTR ENDCODE,0
CALL B10PROMPT
CMP BYTE PTR NAMELEN,00H
JE A90
CALL C10OPEN
CMP WORD PTR ENDCODE,0
JNE A20
CALL D10READ
CMP WORD PTR ENDCODE,0
JE A80
CALL E10XFER
A80:MOV AH,3EH
MOV BX,HANDLE
INT 21H
JMP A20
A90:MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10PROMPT PROC NEAR
LEA BP,PROMPT
MOV CX,14
CALL F10DISPLY
MOV AH,0AH
LEA DX,NAMEPAR
INT 21H
MOV BX,0
MOV BL,NAMELEN
MOV FILENAME[BX],00H
RET
B10PROMPT ENDP
C10OPEN PROC NEAR
MOV AX,3D00H
LEA DX,FILENAME
INT 21H
JNC C20
LEA BP,OPENMSG
MOV CX,18
CALL F10DISPLY
MOV WORD PTR ENDCODE,1
JMP C90
C20:MOV HANDLE,AX
MOV AH,1AH
LEA DX,FILEDTA
INT 21H
MOV AH,4EH
MOV CX,0
LEA DX,FILENAME
INT 21H
C90:RET
C10OPEN ENDP
D10READ PROC NEAR
MOV AH,3FH
MOV BX,HANDLE
MOV CX,512
LEA DX,SECTOR
INT 21H
MOV ENDCODE,AX
RET
D10READ ENDP
E10XFER PROC NEAR
CLD
LEA SI,SECTOR
E20:LEA DI,PRNTAREA
MOV WORD PTR COUNT,0
E30:LEA DX,SECTOR+512
CMP SI,DX
JNE E40
CALL D10READ
CMP WORD PTR ENDCODE,0
JE E90
LEA SI,SECTOR
E40:MOV BX,COUNT
CMP BX,PRINT_LEN
JB E50
MOV BYTE PTR ES:[BX][DI],0DH
INC BX
MOV COUNT,BX
MOV BYTE PTR ES:[BX][DI],0AH
INC BX
CALL P10PRINT
LEA DI,PRNTAREA
MOV WORD PTR COUNT,0
E50:LODSB
MOV BX,COUNT
MOV ES:[BX][DI],AL
INC BX
DEC WORD PTR FILESIZE
JZ E90
CMP AL,0AH
JNE E60
CALL P10PRINT
JMP E20
E60:CMP AL,09H
JNE E70
DEC BX
MOV BYTE PTR ES:[BX][DI],20H
AND BX,0FFF8H
ADD BX,8
E70:MOV COUNT,BX
JMP E30
E90:MOV BX,COUNT
MOV BYTE PTR ES:[BX][DI],0CH
CALL P10PRINT
RET
E10XFER ENDP
F10DISPLY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,1301H
MOV BX,0016H
MOV DH,ROW
MOV DL,10H
INT 10H
INC BYTE PTR ROW
POP DX
POP CX
POP BX
POP AX
RET
F10DISPLY ENDP
P10PRINT PROC NEAR
MOV AH,40H
MOV BX,0004H
MOV CX,COUNT
INC CX
LEA DX,PRNTAREA
INT 21H
MOV AL,20H
MOV CX,PRINT_LEN
LEA DI,PRNTAREA
CLD
REP STOSB
RET
P10PRINT ENDP
END A10MAIN
20.4专用打印机控制符
前面的部分描述了基本的打印机控制符：Tab、换行、换页和回车的用法。其他适用于大多数打印机的命令如下：
十进制      十六进制      作用
08            08                退格
11            0B                垂直Tab
14            0E               打开扩展模式
15            0F               打开紧缩模式
18            12               关闭紧缩模式
20            14               关闭扩展模式
一些打印命令需要个Esc符（1BH）在前面：
1B   30   设置行间距为每英寸8行
1B   32   设置行间距为每英寸6行
1B   45   开始加重打印模式
1B   46   结束加重打印模式
可以用两种方式给打印机发送控制符：
1.在数据区定义控制字符。下面的语句设置了紧缩模式，设置每英寸8行，打印标题，并使用了一个回车和换行：
HEADING DB 0FH,1BH,30H,'Mountain Outfitting Corp.',0DH,0AH
2.使用功能40H发送控制字符给打印机：
CONDMODE DB 0FH   ;紧缩模式
MOV AH,40H   ;请求打印
MOV BX,0004H   ;文件代号
MOV CX,1   ;字符数
LEA DX,CONDMOD   ;紧缩模式
INT 21H   ;调用中断服务
接下来的所有字符都以紧缩模式打印，直到程序发送另一条命令重置打印模式。
20.5BIOS INT 17H打印功能
INT17H提供了在BIOS级上打印的功能。合法的打印机端口LPT1、LPT2、LPT3分别是0（默认）、1和2。
INT17H提供的3种功能，在AH寄存器中指定：
1.先调用功能02H，通过一个选定的端口号来确定打印机的状态。
每次试图打印之前进行该状态的测试。如果打印机可用，则执行2。
2.调用功能01H来初始化打印机端口。
3.调用功能00H操作给打印机发送字符。
该操作返回打印机的状态到AH，将一位或更多的位置为1：
位   状态               位   状态
0   超时                  5   缺纸
3   输入/输出错误   6   得到打印机应答
4   选定                  7   空闲
如果打印机已经打开，并准备好打印，该操作返回90H（二进制10010000）：打印机空闲，并且已被选定，这是一种合法的状态。
表示打印机出错是第5位（缺纸）和第3位（输出错）为1。
如果打印机没有打开，该操作返回B0H，或为二进制数10110000，表明“缺纸”。
1.INT17H的功能00H：打印一个字符。这个操作能打印一个字符，并允许请求打印机端口0、1或2。
打印的字符存放于AL中，打印机端口号存放于DX中：
MOV AH,00H   ;请求打印
MOV AL,char   ;要打印的字符
MOV DX,0000H   ;选择打印机端口0
INT 17H   ;调用中断服务
该操作在AH中返回状态码。在实际操作时推荐先使用功能02H检验打印机状态。
2.INT17H的功能01H：初始化打印机端口。
该操作选定一个打印机端口，重置打印机，并将其初始化，以备接受数据。下例选择端口0：
MOV AH,01H   ;请求初始化端口
MOV DX,0000H   ;选择打印机端口0
INT 17H   ;调用中断服务
因为该操作发送一个换页符给打印机，可以用它设置格式到页顶的位置，尽管大多数的打印机在启动时自动设置到页顶位置。
该操作在AH中返回状态码。
3.INT 17H的功能02H：获得打印机端口状态。该操作的目的是确定打印机的状态。
下面以端口0为例：
MOV AH,02H   ;请求读端口
MOV DX,0000H   ;选择打印机端口0
INT 17H   ;调用中断服务
TEST AH,00101001B   ;准备就绪?
JNZ errormsg   ;否，显示信息
该操作返回与功能01H一样的打印机端口状态。当程序运行时，如果打印机开始没有打开，BIOS不能自动返回信息。
程序设计的是需要测试打印机状态，并根据状态进行动作。如果程序不测试状态，唯一的提示就是闪烁光标。
如果在这时打开打印机，一些输出数据将会丢失。所以，在进行任何BIOS打印操作前，要检验端口状态：
如果有错误，显示信息（INT 21H自动执行这个检测，虽然对各种错误返回的信息都是“缺纸”）。
当打印机开关接通时，信息不再显示，并且开始正常打印，而不会丢失数据。
在任何情况下，打印机都可能超出格式或者被不小心关掉电源。如果你写的程序也供别人使用，
在每次试图打印之前都应该包括状态测试（功能02H）。
20.6要点
标准的打印机控制符是水平Tab、回车、换行和换页。
打印完成之后，使用换行或换页命令清除打印机缓冲区。
INT21H的功能40H打印字符串，而BIOS INT 17H一次只能打印一个字符。
如果有打印机错误发生，系统将显示信息，虽然BIOS只返回一个状态码。
当使用BIOS INT17H时，在打印之前用功能02H检测打印机状态。
20.7习题
20-1.提供打印机控制字符：（a）回车，（b）换行，（c）换页，（d）水平Tab。
十进制         十六进制         功能
09               09H               水平Tab
10               0AH               换行（前进一行）
12               0CH               换页（前进到下一页）
13               0DH               回车（回到左页边）
20-2.针对下列要求，使用INT 21H的功能40H编写程序代码：
（a）走纸到下页，（b）定义并且打印你的名字，（c）完成一次回车和换行，并且打印你的街道地址，
（d）完成一次回车和换行，并且打印你的城市和州，（e）走纸。

FORMFEED DB 0CH
LINEFEED DB 0DH,0AH
...
MOV AH,40H
MOV BX,0004H
MOV CX,01H
LEA DX,FORMFEED
INT 21H

CR EQU 0DH   ;回车
LF EQU 0AH   ;换行
HEADING DB 'Mountain outfitting Corp.',CR,LF
...
MOV AH,40H   ;请求打印
MOV BX,0004H   ;打印机的文件代号04
MOV CX,27   ;发送27个字符
LEA DX,HEADING   ;打印数据的地址
INT 21H   ;请求中断服务
20-3.修改题20-2的程序使名字在扩展模式下打印，街道和地址在紧缩模式下打印，城市和州在加重模式下按正常大小打印。
十进制      十六进制      作用
08            08                退格
11            0B                垂直Tab
14            0E               打开扩展模式
15            0F               打开紧缩模式
18            12               关闭紧缩模式
20            14               关闭扩展模式
一些打印命令需要个Esc符（1BH）在前面：
1B   30   设置行间距为每英寸8行
1B   32   设置行间距为每英寸6行
1B   45   开始加重打印模式
1B   46   结束加重打印模式

下面的语句设置了紧缩模式，设置每英寸8行，打印标题，并使用了一个回车和换行：
HEADING DB 0FH,1BH,30H,'Mountain Outfitting Corp.',0DH,0AH

HEADING DB 0EH,'Mountain Outfitting Corp.',14H

HEADING DB 0FH,'Mountain Outfitting Corp.',12H

HEADING DB 1BH,45H,'Mountain Outfitting Corp.',1BH,46H
20-4.修改题20-3的程序，使其完成（b）、（c）、（d）5次。
重复5次
20-5.修改图20-3的程序，使程序能显示打印出的行。
每次打印成功后，显示打印出的行
20-6.定义一个有回车和换页操作的标题行，设置紧缩模式，定义标题（任意名称），然后关闭紧缩模式。
HEADING DB 0FH,'Mountain Outfitting Corp.',12H,0DH,0AH,0CH
20-7.INT17H在AH中返回个打印错误码。下面的代码是什么意思：（a）08H，（b）10H，（c）90H。
位   状态               位   状态
0   超时                  5   缺纸
3   输入/输出错误   6   得到打印机应答
4   选定                  7   空闲

08H 打印输出错误
10H 打印机正忙
90H 打印机空闲
20-8.使用INT17H修改题20-2，包括测试打印机状态。
1.先调用功能02H，选定端口号0，确定打印机的状态。
每次试图打印之前进行该状态的测试。如果打印机可用，则执行2。
2.调用功能01H来初始化打印机端口。
3.调用功能00H操作给打印机发送字符。
第六部分特殊的课题
第21章定义与使用宏
2l.1引言
21.2简单的宏定义
21.3在宏中使用参数
21.4在宏中使用注释
21.5嵌套的宏
21.6宏伪操作
21.7要点
21.8习题
目的：说明宏指令的定义与使用
21.1引言
对于每一条符号指令，汇编程序都会产生一条机器语言指令。另一方面，用高级语言（如C或BASIC）编写的每个语句，
编译程序都会产生许多机器语言指令，关于这一点，可以把高级语言看成是由一组宏语句所组成。
汇编程序便于定义宏；为宏定义一个唯一的名字，同时定义一组汇编语言指令，这些指令是宏产生的。
然后，无论在哪里，当需要编写这一组指令时，就简单地编写宏的名字，而汇编程序会自动地产生所定义的指令。
宏对于以下目的是有用的：
简化并减少重复编码的数量。
减少由于重复编码所造成的错误。
使汇编语言程序更具可读性。
由宏可以实现的功能的例子包括：装入寄存器与执行中断的输入输出操作。ASCII码与二进制数据之间的转换，
多字算术操作，鼠标初始化，以及串处理例行程序等。
可以按目录把宏分类列入库中，库中的宏可以用于每个程序。程序可以一次（比如初始化段地址）或多次
（比如显示数据）使用宏。一个库还可以典型地包含编目的过程。
选择按宏还是按过程来编写一种操作，很大程度取决于这样一些因素：一般地说，宏执行得比较快，因为它不需要调用与返回。
另一方面，过程通常产生较小的程序，因为其编码只出现一次。在一般情况下，
宏是用在程序中不能多次编写且要求相当简单的地方。
这里是宏定义的基本格式：
macroname MACRO [parameter-list]
[instruction]
ENDM
在第一行的MACRO伪操作通知汇编程序跟在它后面的指令直到ENDM是宏定义的一部分。
ENDM伪操作结束宏的定义。MCARO与ENDM之间的指令组成宏定义体。
为了在程序中包含宏，首先要定义它或从宏库中复制它。宏定义出现在所有段的编码之前。
21.2简单的宏定义
首先探讨一下简单的宏定义，它为.EXE程序初始化段寄存器：
INITZ MACRO   ;宏定义
MOV AX,@data
MOV DS,AX
MOV ES,AX
EDNM   ;宏结束
这个宏的名字是INITZ。在宏定义中被引用的数据项―@data，AX，DS，以及ES一必须是在程序的其他地方已经定义的，
否则它们就必须是汇编程序已经知道的。
随后，你就可以在代码段中，在那些需要初始化这些寄存器的地方使用宏指令INITZ。
当汇编程序遇到宏指令INITZ时，要扫描它的符号指令表，并且如果未能找到该项时，检查宏指令。
由于程序包含宏定义INITZ，所以汇编程序要用产生的指令取代宏定义体――宏展开。
一个程序使用宏指令NITZ只有一次，尽管其他的宏被设计成可以使用任意次，并且每次汇编程序都要形成宏展开。
INITZ MACRO
MOV AX,@data
MOV DS,AX
MOV ES,AX
ENDM
FINISH MACRO
MOV AX,4C00H
INT 21H
ENDM
.MODEL SMALL
.STACK 512
.DATA
MESSGE DB 'Test of macro',0DH,0AH,'$'
.CODE
BEGIN PROC FAR
INITZ   宏展开
MOV AX,@data
MOV DS,AX
MOV ES,AX
MOV AH,09H
LEA DX,MESSGE
INT 21H
FINISH   宏展开
MOV AX,4C00H
INT 21H
BEGIN ENDP
END BEGIN
同样，下面是第二个名为FINISH的宏定义，它处理从程序中正常退出：
FINISH MACRO   ;宏定义
MOV AX,4C00H
INT 21H
ENDM
图21-1提供一个汇编程序列表，它定义并使用了INITZ和FINISH。这个特殊的汇编程序版本列出了宏展开，
在每条指令的左边用编号1来指明它是宏指令产生的。
注意，当汇编时，宏定义不能产生任何目标码，产生目标码的是宏展开。
同样地，宏展开不能使像ASSUME或PAGE那样一些在宏定义中编码的伪操作打印出米。
对于只使用一次的宏，几乎没有必要去定义它，但可以把它编入库中，供所有程序使用。
下一节说明如何把宏按目录列入库中，以及如何自动地把它们包括在程序中。
21.3在宏中使用参数
为了使宏更灵活，可以在操作数中定义参数，称为哑元。
下面的名为PROMPT的宏定义是提供给使用INT21H的功能09H去显示信息的：
PROMPT MACRO MESSGE
MOV AH,09H
LEA DX,MESSGE
INT 21H
ENDM
当使用这条宏指令时，必须提供信息（message）名，它所访问的数据区是用一个$符号结束的。
另外，宏可以包含所用寄存器AH和DX进栈与出栈的指令。
在宏定义中的哑元告诉汇编程序把它的名字去和宏定义体中出现的任何相同名字相匹配。
例如，哑元MESSGE在LEA指令中还是一个操作数。假设程序定义名为MESSAGE2的提示符如下所示：
MESSAGE2 DB 'Enter the date as mm/dd/yy','$'
现在想使用宏指令PROMPT显示MESSAGE2。为此，提供名字MESSAGE2作为参数：
PROMPT MESSAGE2
在宏指令中的参数（MESSAGE2）和在原来的宏定义中的哑元（MESSGE）相匹配：
宏定义：PROMPT MACRO MESSGE（哑元）
宏指令：PROMPT               MESSAGE2（参数）
汇编程序已经使原来的宏定义中的哑元和在LEA语句中的操作数相匹配，
用宏定义中的哑元MESSGE来取代宏指令的参数MESSAGE2。
汇编程序用MESSAGE2取代在LEA中出现的MESSGE，并用它取代任何其他地方出现的MESSGE。
宏定义和它的调用表示于图21-2。程序在起点还定义了宏NITZ和FINGSH，并把它们用在代码段中。
哑元可以包含任何有效的名字，包括寄存器名（如CX）。
在定义宏时，可以使用任何数量的哑元，哑元之间用逗号隔开，最多可达一行120列（取决于汇编程序版本）。
汇编程序用宏指令中的参数取代宏定义中的哑元，从左到右，一项对一项。
INITZ MACRO
MOV AX,@data
MOV DS,AX
MOV ES,AX
ENDM
PROMPT MACRO MESSGE
MOV AH,09H
LEA DX,MESSGE
INT 21H
ENDM
FINISH MACRO
MOV AX,4C00H
INT 21H
ENDM
.MODEL SMALL
.STACK 512
.DATA
MESSG1 DB 'Name: ','$'
MESSG2 DB 'Address: ','$'
.CODE
BEGIN PROC FAR
INITZ
PROMPT MESSG1
PROMPT MESSG2
FINISH
BEGIN ENDP
END BEGIN
21.4在宏中使用注释
可以在宏定义中编写注释说明它的用途。分号或COMMENT伪操作指明注释行。以下是使用分号注释的例子：
PFOMPT MACRO MESSGE
;这个宏允许显示信息
MOV AH,09H   ;请求显示
LEA DX,MESSGE   ;提示符
INT 21H
ENDM
由于默认值只列出了产生目标码的指令，所以汇编程序在展开宏定义时，不能自动地显示注释。
为了使注释在展开内出现，使用列表伪操作.LALL（“列出余部”，包括前面的点），放在所要求的宏指令之前：
.LALL
PROMPT MESSAGE1
一个宏定义可以包含许多注释，但可能只要列出某一些而禁止列出另一些。
仍然使用.LALL把它们列出来，但在注释前加上双分号（;;），这样一来，它们就总是不能列出了。
（汇编程序默认的是.XALL，它使列表中只出现生成目标码的指令）。
另一方面，可能不要列出宏展开的任何源码，特别是在程序中宏指令使用多次时更是这样。
在这种情况下，编写列表伪操作.SALL（“全部禁止”），它可以减少所打印程序的大小，
尽管它对所产生的目标程序的大小是没有影响的。
列表伪操作对程序自始至终保持有效，直到遇到另一个列表伪操作为止。
可以把它们放在程序中去使某些宏只列出所生成的目标码（.XALL），某些宏把目标码和注释都列出（LALL），
以及某些宏使目标码和注释都禁止列出（.SALL）。
MASM6.0引入了条目.LISTMACROALL，.LISTMACRO和.NOLISTMACRO，它们分别对应于LALL，.XALL和.SALL。
图21-3中的程序说明了上述特性。该程序包含早先讨论过的宏INITZ，FINISH和PROMPT。
代码段包含列表伪操作.SALL，禁止列出INITZ，FINISH和第一个PROMPT的展开。
对于第二个PROMPT的使用，列表伪操作.LALL使汇编程序列出注释和宏展开。
但请注意，在PROMPT的宏定义中，包含双分号（;;）的注释在宏展开时并没有被列出来。
INITZ MACRO
MOV AX,@data
MOV DS,AX
MOV ES,AX
ENDM
PROMPT MACRO MESSGE
;这一宏显示任何信息
;;数据要求有$分界符
MOV AH,09H
LEA DX,MESSGE
INT 21H
ENDM
FINISH MACRO
MOV AX,4C00H
INT 21H
ENDM
.MODEL SMALL
.STACK 512
.DATA
MESSG1 DB 'Name: ','$'
MESSG2 DB 'Address: ','$'
.CODE
BEGIN PROC FAR
.SALL
INITZ
PROMPT MESSG1
.LALL
PROMPT MESSG2
.SALL
FINISH
BEGIN ENDP
END BEGIN
21.5嵌套的宏
宏定义可以包含对一个或多个其他定义的（嵌套的）宏的引用。考虑以下2个宏定义
SET_CURSOR和DISPLAY：
SET_CURSOR MACRO ROW,COL
MOV AH,02H
MOV BH,0
MOV DH,ROW
MOV DL,COL
INT 10H
ENDM
DISPLAY MACRO MESSGE
MOV AH,09H
LEA DX,MESSGE
INT 21H
ENDM
名为CURS_DISPLAY的第三个宏可以请求 SET_CURSOR和DISPLAY 宏。
CURS_DISPLAY用以下方法为2个嵌套的宏来定义参数：
CURS_DISPLAY MACRO M_ROW,M_COL,MESSGE
PUSH AX
PUSH BX
PUSH CX
PUSH DX
SET_CURSOR M_ROW,M_COL
DISPLAY MESSGE
POP DX
POP CX
POP BX
POP AX
ENDM
可以使用常数、变量或寄存器作为行与列来编写CURS_DISPLAY，如：
CURS_DISPLAY 6,15,ERROR_MSSGE
CURS_DISPLAY ROW,COLUMN,ERROR_MSSGE
CURS_DISPLAY CH,CL,ERROR_MSSGE
21.6宏伪操作
汇编程序支持许多有用的伪操作，包括LOCAL，PUREG，重复，以及条件伪操作。
21.6.1LOCAL（局部）伪操作
某些宏要求数据项和指令标号是在宏定义自身范围内定义的。
但是，如果在同一程序中不止一次地使用这个宏，而汇编程序对每次出现的数据项或标号都要定义的话，
那么重名会使汇编程序产生出错信息。为了确保每次所生成的名字是唯一的，直接在MACRO语句之后编写LOCAL伪操作，
甚至要在注释之前这样做。LOCAL的格式是：
LOCAL localname-1,localname-2,...
图21-4的部分程序说明LOCAL的使用。DIVIDE宏的目的是使用相继减法实现除法。
宏从被除数中减去除数并对商加1，直到被除数小于除数为止。这个宏需要2个标号：
对于循环地址是COMP，对于在完成后退出过程是OUT。
COMP和OUT都定义成LOCAL，并且可以用任何有效的名字。
该程序两次使用DIVIDE。在第一个宏展开中，产生的符号标号对于COMP是??0000，而对于OUT则是??0001。
在第二个宏展开中，符号标号分别是??0002和??0003。用这种方法，这一特性保证在程序中所生成的每个标号都是唯一的。
DIVIDE MACRO DIVIDEND,DIVISOR,QUOTIENT
LOCAL COMP
LOCAL OUT
MOV AX,DIVIDEND
MOV BX,DIVISOR
SUB CX,CX
COMP:CMP AX,BX
JB OUT
SUB AX,BX
INC CX
JMP COMP
OUT:MOV QUOTIENT,CX
ENDM
...
.DATA
DIVDND1 DW 150
DIVSOR1 DW 27
QUOTNT1 DW ?
DIVDND2 DW 265
DIVSOR2 DW 34
QUOTNT2 DW ?
...
.CODE
DIVIDE DIVDND1,DIVSOR1,QUOTNT1
DIVIDE DIVDND2,DIVSOR2,QUOTNT2
...
21.6.2包含在库中的宏
程序设计实际上是定义宏（如INITZ，FINISH和PROMPT），并且可以任意次地使用。
标准的方法是在一个描述性名字（如MACRO.LBY）下面把磁盘库中的宏进行编目。
简单地把所有的宏定义收集到一个或多个存在磁盘上的文件中：
INITZ MACRO
...
ENDM
PROMPT MACRO MESSGE
...
ENDM
可以使用编辑程序或字处理程序编写这个文件，但要保证它是一个未格式化的ASCII文件。
下面的例子假定该文件是在MACRO.LBY名字下存放的。现在程序可以使用任何已编目的宏，而不是在程序的开始编写宏定义，
像以下这样使用一个INCLUDE伪操作：
INCLUDE path:\MACRO.LBY
汇编程序访问名为path:\MACRO.LBY的文件而且把所有已编目的宏定义都包含到此程序中，
虽然你的程序可能只需要它们当中的一部分。汇编的列表将包含宏定义的一个副本，
对于某些汇编程序版本是在.LST文件的第30列用字母C指明的。
对于一个包括两遍扫视操作的汇编程序，可以使用以下语句使INCLUDE只在第1遍扫视期间发生（而不是两遍扫视都发生）：
IF1
INCLUDE path:\MACRO.LBY
ENDIF
IF1和ENDIF是条件伪操作。IF1通知汇编程序只在汇编的第1遍扫视时访问命名的库。ENDIF终止IF逻辑。
宏定义的副本不再出现在列表中――时间与空间上都节省。但是，版本6.0的MASM不需要涉及两遍扫视的伪操作。
INCLUDE的位置并不是要求很严的，但是必须出现在任何引用库项目的宏指令之前。
PURGE（清除）伪操作。INCLUDE语句的执行会使汇编程序把指定库中的所有宏定义都包括在内。
该库包含宏INITZ、FINISH、PROMPT和DIVIDE，但程序只需要INITZ和FINISH，
那么，PURGE伪操作能从当前的汇编中删除不需要的宏 PROMPT和DIVIDE：
IF1
INCLUDE path:\MACRO.LBY
ENDIF
PURGE PROMPT,DIVIDE
...
INITZ
...
FINISH
...
PURGE操作只用于一个程序的汇编，并且对存放在库中的宏没有影响。
21.6.3连接伪操作
表示and的（&）字符通知汇编程序连接文本或符号。在下面的宏中，&符号便于生成MOVSB、MOVSW或MOVSD指令：
STRMOVE MACRO TAG
REP MOVS&TAG
ENDM
用户可以把这条宏指令编写成STRMOVE B，STRMOVE W，或STRMOVE D。然后汇编程序把参数B、W或D和MOVS指令
连接起来，分别产生REP MOVSB、REP MOVSW或REP MOVSD（这个稍显平常的例子是用于说明用途的）。
21.6.4重复伪操作
重复伪操作REPT、IRP和IRPC使汇编程序去重复一个语句块，直到伪操作结束的ENDM语句为止。
（MASM6.0引入的条目是REPEAT、FOR和FORC，分别对应于REPT、IRP和IRPC）
这些伪操作不必包含在宏定义中，但如果它们包含在里边，就要编写一个ENDM去终止每个重复伪操作，
同时编写另一个ENDM去结束MACRO定义。
1.REPT：重复伪操作。
REPT（或REPEAT）伪操作使汇编程序按照表达式项目所规定的次数，一直重复到ENDM的语句块：
LREPT expression（expression：表达式）
第一个例子是产生DEC指令4次：
REP 4
DEC SI
ENDM
第二个例子把N值初始化为0，然后重复产生DB N 5次：
N=0
REPT 5
N=N+1
DB N
ENDM
该操作产生5个DB语句：DB 1，DB 2，DB 3，DB 4和DB 5。
使用REPT可以定义一个表格或部分表格。下一个例子定义宏，该宏使用REPT使扬声器发声5次：
BEEPSPKR MACRO
MOV AH,02H   ;请求输出
MOV DL,07H   ;发声字符
REPT 5   ;重复5次
INT 21H   ;调用中断服务
ENDM   ;结束重复
ENDM   ;结束宏
2.IRP：不定重复伪操作。IRP（或FOR）伪操作使汇编程序重复到ENDM为止的语句块，它的格式是
IRP parameter,<arguments>
...
ENDM
包含在尖括号中的自变量由任意个有效符号组成，包括串、数字或算术常数。
汇编程序用每个自变量的语句替换参数。对于第一个例子，
IRP N,<3,9,17,25,28>
DB N
ENDM
汇编程序产生DB 3，DB 9，DB 17，DB 25，DB 28。
对于第二个例子，IRP REG <AX,BX,CX,DX>
PUSH REG
ENDM
汇编程序为每个指定的寄存器产生一个PUSH语句。
3.IRPC，不定重复字符伪操作。IRPC（或FORC）伪操作使汇编程序重复直到ENDM为止的语句块。其格式是
IRE parameter,string
...
ENDM
（string：字符串）
汇编程序为在串中的每个字符生成一个语句。在下面的例子中，
IRPC N,345678
DW N
ENDM
汇编程序产生DW 3到DW8。
21.6.5条件伪操作
较早的条件伪操作的例子是使用IF1去包含只在汇编第1遍扫视期间的库项目。条件伪操作在宏定义内最有用，
但它并不只限于这种用途。每个IFnn伪操作必须有一个配套的ENDIF去结束所测试的条件。
一个可选的ELSE可以提供另一个动作。条件的处理非常像C语言。下面是IF一类条件伪操作的格式：
IFxx（条件）
...
ELSE
...
ENDIF
遗漏ENDIF会产生出错信息“Undeterminated conditional”（“不确定条件”）。
如果汇编程序发现该条件是真，它就使直到ELSE的条件块生效，或者如果不存在ELSE，则条件块直到ENDIF为止：
如果条件为假，汇编程序将使ELSE之后的条件块生效，如果不存在ELSE，就不产生任何条件块。
下面说明汇编程序是如何处理条件伪操作的：
IF表达式：如果该表达式判断为真（非零值），则汇编在条件块内的语句。
IFE表达式：如果该表达式判断为假（零），则汇编在条件块内的语句。
IF1（无表达式）：如果处理第1遍扫视，则条件块内的语句生效。
IF2（无表达式）：如果处理第2遍扫视，则条件块内的语句生效。
IFDEF符号：如果符号是在程序中定义或表示成EXTRN，则处理在条件块内的语句。
IFNDEF符号：如果符号没有定义或没有表示成EXTRN，则处理在条件块内的语句。
IFB（自变量）：如果自变量是空白，则处理在条件块内的语句。该自变量包含在尖括号中的。
IFNB（自变量）：如果自变量不是空白，则处理在条件块内的语句。该自变量包含在尖括号中的。
IFIDN <arg-1>，<arg-2>：如果自变量相等，则处理在条件块内的语句。自变量都包含在尖括号中的。
IFDIF <arg-1>，<arg-2>：如果自变量不相等，则处理在条件块内的语句。自变量包含在尖括号中的。
IF和IFE可以使用关系操作符EQ（相等），NE（不相等），LT（小于），LE（大于或等于），
GT（大于），以及GE（大于或等于）。例如在语句中：
IF expression1 EQ expression2
下面是使用IFNB（如果不是空白）的简单例子。INT 21H的功能4CH使程序结束处理并传送返回码到AL中。
这个例子是修改前面已用过的FINISH宏来提供一个返回码：
FINISH MACRO RETCODE
MOV AH,4CH
IFNB <RETCODE>
MOV AL,RETCODE
ELSE
MOV AL,00H
ENDIF
INT 21H
ENDM
这里是使用IFNB的另一个例子。标准做法是为一个过程保存寄存器，这些寄存器必须在入口用PUSH指令，
并在出口用POP指令来保存与恢复。寄存器数量与类型随过程的不同而不同。
以下的宏PUSHMAC和POPMAC是处理一个或两个寄存器的，但可以方便地扩展成包括任意数量的寄存器：
PUSHMAC MACRO REG1,REG2
IFNB <REG1>
PUSH REG1
ENDIF
IFNB <REG2>
PUSH REG2
ENDIF
ENDM
POPMAC MACRO REG1,REG2
IFNB <REG1>
POP REG1
ENDIF
IFNB <REG2>
POP REG2
ENDIF
ENDM
该宏可以按这种方法使用：
PUSHMAC AX,BX
POPMAC BX,AX
21.6.6EXITM伪操作
宏定义可以包含条件伪操作，用来测试重要的条件。如果条件为真，则汇编程序使用EXITM伪操作
从任何宏的进一步展开中退出：
IFxx [条件]
...
（无效条件）
EXITM
...
ENDIF
如果汇编程序在宏指令的展开中遇到EXITM，则中止宏展开并在ENDM以后恢复处理。
还可以使用EXITM去结束REPT、IRP和IRPC伪操作，即使包含在宏定义之内的也是一样。
21.6.7使用IF与IFNDEF条件的宏
在图21-5中的部分程序包含了名为DIVIDE的宏定义，它产生一个用相继减法实现除法的例行程序。
用户必须编写带参数的DIVIDE宏指令，这些参数是按被除数、除数和商的次序排列的。
该宏使用IFNDEF检查这些数据项是不是在程序中实际定义的。对于任何没有定义的数据项，
宏要增加一个名为COUNTER的字段（COUNTER可以有任意有效的名字并且是在宏定义之内临时使用的）。
在检查3个参数之后，宏还要检查COUNTER是不是非零：
DIVIDE MACRO DIVIDEND,DIVISOR,QUOTIENT
LOCAL COMP
LOCAL OUT
CNTR = 0
IFNDEF DIVIDEND
CNTR = CNTR + 1
ENDIF
IFNDEF DIVISOR
CNTR = CNTR + 1
ENDIF
IFNDEF QUOTIENT
CNTR = CNTR + 1
ENDIF
IF CNTR
EXITM
ENDIF
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,DIVIDEND
MOV BX,DIVISOR
SUB CX,CX
COMP:CMP AX,BX
JB OUT
SUB AX,BX
INC CX
JMP COMP
OUT:MOV QUOTIENT,CX
POP DX
POP CX
POP BX
POP AX
ENDM
...
.DATA
DIVDEND DW 150
DIVISOR DW 27
QUOTENT DW ?
...
.CODE
...
.LALL
DIVIDE DIVDEND,DIVISOR,QUOTENT
DIVIDE DIDND,DIVISOR,QUOT
...
IF COUNTER
EXITM   ;宏展开结束
ENDIF如果COUNTER已经被设置成非零值，那么汇编程序就产生在上述代码中表明的注释，
并从任何进一步的宏展开中退出（EXITM）。
注意，最初的指令把COUNTER清除为0，而且IFNDEF块也可以只把COUNTER置成1而不是使它增量。
如果条件确实通过了所有测试，那么汇编程序便产生宏展开。
在代码段中，第二个DIVIDE宏指令包含无效的被除数和商并只产生注释。
改进该宏的方法应当是去测试除数是否为非零，以及被除数与除数是否有相同的符号。
为了这些目的，使用汇编指令而不是条件伪操作，因为条件的出现是在程序被执行的时候，而不是在程序被汇编的时候。
21.6.8使用IFIDN条件的宏
图21-6的部分程序包含了名为MOVIF的宏定义，它产生MOVSB或MOVSW，这取决于所提供的参数。
用户必须编写带参数B（字节）或W（字）的宏指令指明MOVS是变成MOVSB，还是变成MOVSW。
在宏定义中，IFIDN的两次出现是
IFIDN <&TAG>,<B>
REP MOVSB
...
ENDIF
IFIDN <&TAG>,<W>
REP MOVSW
...
ENDIF
第一次是，如果编写MOVIF B作为宏指令，则IFIDN产生REP MOVSB；第二次是，如果编写的宏指令是MOVIF W，
那么IFIDN产生REP MOVSW。如果用户没有提供B或W，汇编程序就产生一个注释并默认为MOVSB
（&操作符的正常使用是在连接的情况下）。在代码段中的MOVIF的3个例子是为了测试B，W，以及无效条件的。
不要试图按实际情况去执行该程序，因为DI和SI必须包含用于MOVS指令的适当的值。
坦白地说，这个宏不是很有用，因为其目的在于以一种简单的方法来说明条件伪操作的使用。
但是，现在你应当有能力开发一些属于自己的有意义的宏。
MOVIF MACRO TAG
IFIDN <&TAG>,<B>
REP MOVSB
EXITM
ENDIF
IFIDN <&TAG>,<W>
REP MOVSW
ELSE
REP MOVSB
ENDIF
ENDM
...
.CODE
...
MOVIF B
MOVIF W
MOVIF
...
21.7要点
宏定义要求MACRO伪操作，一个或多个语句的块通称为体，是由宏定义产生的。
ENDM伪操作是结束定义用的。
宏指令是在程序中的宏的使用。宏指令产生的代码是宏展开。
.SALL，.LALL和.XALL伪操作控制在宏展开中产生的注释与目标码的列表。
LOCAL伪操作便于在宏定义内使用名字，并且必须在宏语句之后立即出现。
在宏定义中使用哑元，允许用户更灵活地编写参数。
宏库使已编目的宏可用于其他程序。
条件伪操作使程序能验证宏参数。
21.8习题
21-1.在什么情况下会使用（a）宏，（b）调用过程？
宏对于以下目的是有用的：
简化并减少重复编码的数量。
减少由于重复编码所造成的错误。
使汇编语言程序更具可读性。
一般地说，宏执行得比较快，因为它不需要调用与返回。
另一方面，过程通常产生较小的程序，因为其编码只出现一次。
一般情况下，宏是用在程序中重复且要求简单的地方。
21-2.为一个名为MACARONI的简单宏定义编写第一和最后一行。
MACARONI MACRO
...
ENDM
21-3.说明宏定义体与宏展开之间的区别。
在对源程序汇编时，汇编程序把源程序中的宏指令替换成对应的宏定义体，这称为宏展开或宏扩展。
21-4.什么是哑元？
为了使宏更灵活，可以在宏中定义参数，对应的参数就是哑元。
21-5.为以下语句编写伪操作：（a）只列出产生目标码的指令。（b）禁止宏产生的所有指令。
.XALL
.SALL
21-6.编写两个执行乘法的宏定义：（a）MPYBYTE是产生字节与字节相乘的代码：
（b）MPYWORD是产生字与字相乘的代码。在宏定义中，包括作为哑元的被乘数与乘数。
用一个小程序（它也需要定义所要求的数据字段）测试宏的执行情况。
MPYBYTE MACRO NUM1,NUM2
IFB <NUM1>
EXITM
ELSE
IFB <NUM2>
EXITM
ELSE
IFDIFI <NUM1>,<AL>
MOV AL,NUM1
ENDIF
IFDIFI <NUM2>,<AH>
MOV AH,NUM2
ENDIF
MUL AH
ENDIF
ENDIF
ENDM

MPYWORD MACRO NUM1,NUM2
IFB <NUM1>
EXITM
ELSE
IFB <NUM2>
EXITM
ELSE
IFDIFI <NUM1>,<AX>
MOV AX,NUM1
ENDIF
IFDIFI <NUM2>,<DX>
MOV DX,NUM2
ENDIF
MUL DX
ENDIF
ENDIF
ENDM

MPYBYTE BYTE1,BYTE2
乘积在AX中
MPYWORD WORD1,WORD2
乘积在DX,AX中
21-7.把21-6题所定义的宏存入宏库中。修改程序在汇编第1遍扫视期间去 INCLUDE库的项目。
IF1
INCLUDE path:\MACRO.LBY
ENDIF
21-8.编写一个名为BIOSPRINT的宏，使用INT17H去打印。
该宏应当包括对打印机状态的测试并应提供具有任意长度可任意定义的打印行。
1.先调用功能02H，选定端口号0，确定打印机的状态。
每次试图打印之前进行该状态的测试。如果打印机可用，则执行2。
2.调用功能01H来初始化打印机端口。
3.调用功能00H操作给打印机发送字符。
21-9.修改图21-4中的宏，产生代码能在程序执行时如除数为零.则可以绕过除法。
DIVIDE MACRO DIVIDEND,DIVISOR,QUOTIENT
LOCAL COMP
LOCAL OUT
LOCAL OUTEX
CNTR = 0
IFNDEF DIVIDEND
CNTR = CNTR + 1
ENDIF
IFNDEF DIVISOR
CNTR = CNTR + 1
ENDIF
IFNDEF QUOTIENT
CNTR = CNTR + 1
ENDIF
IF CNTR
EXITM
ENDIF
MOV CX,DIVISOR
JCXZ OUTEX
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,DIVIDEND
MOV BX,DIVISOR
SUB CX,CX
COMP:CMP AX,BX
JB OUT
SUB AX,BX
INC CX
JMP COMP
OUT:MOV QUOTIENT,CX
POP DX
POP CX
POP BX
POP AX
OUTEX:
ENDM
...
.DATA
DIVDEND DW 150
DIVISOR DW 27
QUOTENT DW ?
...
.CODE
...
DIVIDE DIVDEND,DIVISOR,QUOTENT
...
21-10.编写、汇编与测试一个程序，该程序使用名为MPYBYTE、MPYWORD和BIOSPRINT的宏。
（a）定义两个1字节字段和两个1字的字段，并都包含数值数据。（b）使用MPYBYTE 进行1字节字段相乘并使用MPYWORD进行1字字段相乘。
（c）把乘积转换成ASCII格式并使用BIOSPRINT打印。
MPYBYTE BYTE1,BYTE2
乘积在AX中
DX置为0
调用DTOBUF把DX,AX转换成ASCII格式放到PRNTAREA中
使用BIOSPRINT打印
MPYWORD WORD1,WORD2
乘积在DX,AX中
调用DTOBUF把DX,AX转换成ASCII格式放到PRNTAREA中
使用BIOSPRINT打印
21-11.根据给定的要求确定条件伪操作。处理在条件块中的语句仅当（a）自变量是空白，（b）表达式为零，
（c）两个自变量相等，（d）表达式为非零。
IFB 表达式
IFE 表达式
IF 表达式1 EQ 表达式2
IFIDNI 表达式1,表达式2
IF 表达式
第22章连接到子程序
22.1引言
22.2段伪操作.
22.3段内调用.
22.4段间调用.
22.5EXTRN与PUBLIC属性
22.6用EXTRN与PUBLIC作为入口点
22.7代码段定义为PUBLIC
22.8使用简化段伪操作
22.9传送参数到子程序
22.10ENTER与LEAVE指令
22.11C/C++程序与汇编语言程序的连接
22.12要点
22.13习题
目的：阐述汇编，连接，以及执行单个程序的程序设计技术。
22.1引言
到本章为止，所有程序都是由一个独立的汇编模块组成的。但存在这样的可能性：这就是开发一个程序，
它是由一个主程序和一个或多个单独汇编的子程序相连接而组成的。以下是把个程序组织成子程序的原因：
为了语言之间的连接，例如，把易于编码的高级语言和处理效率高的汇编语言组合起来。
为了便于大型项目的开发，在那些项目中，不同的组分别产生各自的模块。
为了在执行期间覆盖程序的各部分，因为程序太大了。
每个程序都是单独汇编的并产生它自己唯一的目标（.OBJ）模块。
然后，连接程序把各目标模块连接成一个组合的可执行（.EXE）模块。
典型的情况是，主程序是一个开始执行的程序，并调用一个或多个子程序。子程序本身又可以调用其他子程序。
图22-1表示的是主程序与3个子程序层次的2个例子。在（a）部分，主程序调用了程序1、2和3。
在（b）部分，主程序调用子程序1和2，并且只有子程序1调用子程序3。
有很多方法用来组织子程序，但这种组织必须能通得过汇编程序和连接程序。
还必须密切注意位置，比如子程序1在哪里调用子程序2，子程序2又在哪里调用子程序3，
而子程序3反过来又在哪里调用子程序1的。这种过程称为递归，这是可以工作的，但如果处理得不小心，
可能造成重大的执行错误。
22.2段伪操作
这一节涉及用于编写SEGMENT伪操作的许多选项。完整的SEGMENT伪操作的格式是
segment-name SEGMENT [align] [combine] ['class']
下面讨论定位（align），组合（combine）、以及类别（class）的类型。
22.2.1定位类型
定位操作符（如果存在的话）通知汇编程序定位已命名的段，使其起始于一个特殊的存储器边界：
BYTE。字节边界，对于要与另一个程序相组合的子程序的段。
WORD。字边界，对于要与另一个程序相组合的子程序的段。
DWORD。双字边界，通常是对于80386及其后继处理器的。
PARA。小段边界（能被16或10H除尽），默认的并且是最常用的，用于主程序和子程序两者的定位。
PAGE。页边界（能被256或100H除尽）。
省略第一段的定位操作符会被默认为PARA。省略后继段的定位操作符也会默认为PARA，如果名字是唯一的话。
假如名字不是唯一的，默认值就是以前所定义同名段的定位类型。
22.2.2组合类型
组合操作符（如果存在的话）通知汇编程序和连接程序是应该把各段组合起来，还是保持它们的独立
（你已经对.EXE程序使用过STACK组合类型）。与本章有关的其他组合类型是NONE，PUBLIC，以及COMMON：
NONE。该段在逻辑上是独立于其他段的，尽管它们可能都是作为物理上相邻的段结束的。
这种类型是所有段伪操作的默认值。
PUBLIC。连接程序把该段和其他所有被定义为PUBLIC并具有相同段名与类别的段组合在一起。
汇编程序从第一段的起点计算偏移值。实际上，组合的段包含许多部分，
每个部分都由SEGMENT伪操作开始并由ENDS结束。PUBLIC类型是简化段伪操作的默认值。
COMMON。如果COMMON段具有同样的名字和类别，连接程序就给它们同样的基地址。
在执行期间，第二段覆盖第一段。最大的段决定公用区的长度。
22.2.3类别的类型
已经用过类别名'Stack'，'Data'和'Code'。可以分配相同的类别名给有关段使汇编程序和连接程序把它们组合成一组。
也就是说，它们是一个接一个地出现的，而不是组合在一个段里，除非组合选项中也有PUBLIC。
类别项目可以包含任何有效的名字（包含在单引号中），尽管对于代码段而言，名字‘Code'才是被推荐使用的。
以下两个不相关的SEGMENT语句产生相同的结果，即一个独立的定位于小段边界的代码段：
CODESEG1 SEGMENT PARA NONE 'Code'
CODESEG2 SEGMENT 'Code'（默认为PARA和NONE）
完整的定义段的伪操作已经在第4章做了说明，但以后各章用的是简化段伪操作。
因为完整的段伪操作在汇编与连接子程序时，可以提供比较严格的控制，所以本章大多数例子都使用它们。
本章与下一章的程序举例说明许多定位，组合与类别的选项。
22.3段内调用
迄今为止，CALL指令还是用于段内调用，也就是说，被调用的过程和调用过程是在同一个代码段中。
如果被调用的过程是定义为或默认为NEAR（即在32K内），则段内调用是近调用。
用存储模型定义为Tiny，Small，以及Compact的程序对于内部过程的调用默认为近调用。
近CALL使IP寄存器进入堆栈，并用目的地址的偏移值取代IP，因此，近CALL所访问的（近）过程是在同一段内的：
CALL nearproc   ;近调用 IP进栈，
...
nearproc PROC NEAR
...
RET/RETN   ;近返回 IP出栈 返回到调用程序
nearproc ENDP
现在考虑一个近的段内CALL语句，由目标码E8 2000组成，其中E8是CALL的操作码，而2000（0020）是
被调用过程的偏移地址。该操作使IP进入堆栈，并把2000存入IP中成为0020。
然后处理器把在CS中的当前段地址和在IP中的偏移值组合起来（CS:IP），以便执行下一条指令。
在从被调用过程退出时，（近）RET使存放在堆栈中的IP出栈并进入IP寄存器中，这样，组合了的段：偏移地址就使
控制返回到跟在CALL后的指令。
正如我们所讨论的，段内转移可以是近的，或者如果要调用的过程是在同一段内，但是按远来定义的，
那么在这种情况下，段内转移也可以是远的。如果RET 是在NEAR过程中出现，它就是近的。
而如果RET是在FAR过程中出现的，那它就是远的。可以把这些指令分别编写成RETN或RETF。
22.4段间调用
如果被调用的过程是按照FAR或EXTRN定义的，则该CALL被归入远调用一类，但是，通常在另一个代码段中却未必是这样。
那些用Medium和Large存储模型定义的程序就默认为远调用。
远CALL首先使CS的内容进栈，并在CS中放入一个新的段地址。然后使IP进栈并在IP中放入一个新的偏移地址
（进栈的CS:IP值提供紧跟在CALL后的指令的地址）。
用这种方法，代码段的地址和偏移地址都是为从被调用过程返回而保留的。对另一个段的调用总是段间的远调用：
CALL farproc   ;远调用 CS和IP进栈
...
farproc PROC FAR
...
RET/RETF   ;远返回 IP和CS出栈 返回到调用程序
farproc ENDP   
考虑一个段间CALL语句，它是由目标码9A 0002 AF04组成的。十六进制的9A是远CALL的操作码，0002（或0200）是
偏移值，而AF04（或04AF）是新的段地址。
该操作使当前的IP进栈并把新的偏移值0002按0200存入IP。接下来使当前CS进栈并把新的段地址AF04按04AF存入CS。
然后，处理器把在CS中的当前段地址和IP中的偏移地址组合起来（CS:IP），成为在被调用的子程序中要执行的
第一条指令的有效地址：
04AF0
+
  0200
=
04CF0
在从被调用的过程退出时，段间（远）RET与CALL操作相反，原来的IP与CS地址都出栈，返回到各自的寄存器中。
现在CS:IP对指向跟在原先的CALL之后的指令地址，在那里继续执行程序。
近CALL与远CALL的主要区别是近CALL只替换IP偏移值，而远CALL则是CS段地址和IP偏移值都要替换。
近RET/RETN和近CALL相关联，而远RET/RETF则是和远CALL相关联。
22.5EXTRN与PUBLIC属性
在图22-2中，主程序（MAINPROG）调用子程序（SUBPROG）。两个模块是分别汇编的，这是对于段间调用的要求。
在MAINPROG中的CALL必须知道SUBPROG存在于MAINPROG之外
（不然的话，汇编程序产生一个出错信息：SUBPROG是个未定义的符号）。
伪操作EXTRN SUBPROG:FAR通知汇编程序任何对于SUBPROG的引用都附带个FAR符号，
在这种情况下，它是在另一个汇编过程中由外部定义的。
由于汇编程序没有办法知道在执行时将是什么地址，所以它在远CALL中产生“空”的目标码操作数
（汇编的.LST清单用0表示偏移值，用短划表示段），其后连接程序会进行填入：
9A 0000 ---- E   ;E-外部的
而在SUBPROG中还要包含PUBLIC伪操作，用来通知汇编程序和连接程序另一模块必须知道SUBPROG的地址。
在稍后的步骤中，当MAINPROG和SUBPROG都成功地汇编成各自的目标模块时，就可以按下面这样连接：
LINK MAINPROG + SUBPROG
连接程序把在一个目标模块中的EXTRN和在其他目标模块中的PUBLIC相匹配，并插入任何所要求的偏移地址，
然后把两个目标模块组合成一个可执行模块。如果不能匹配到引用，则连接程序会提供出错信息，
在打算执行连接的模块之前，应当对它进行监视。
EXTRN SUBPROG:FAR
MAINPROG PROC FAR
...
CALL FAR PTR SUBPROG
...
MAINPROG ENDP
END MAINPROG
...
PUBLIC SUBPROG
SUBPROG PROC FAR
...
RETF
SUBPROG ENDP
22.5.1EXTRN/EXTERN伪操作
EXTRN伪操作通知汇编程序：命名的项（数据项、过程或标号）是在另一个汇编过程中定义的
（MASM6.0引入了条目EXTERN）。它的格式是：
EXTRN Name:type[,...]（name：名字，type：类型）
可以定义一个以上的名字，直到行结束为止或用附加的EXTRN语句编码。
而其他汇编模块又必须定义名字并把它标记为PUBLIC。根据名字的实际定义而确定的类型项目必须是有效的。
ABS指出一个常数值。
BYTE、WORD以及DWORD 指出数据项是一个模块所引用的，而由另一模块所定义的。
NEAR和FAR指出过程或指令标号是一个模块所引用的，而由另一模块所定义的。
用EQU定义一个名字。
22.5.2PUBLIC伪操作
PUBLIC伪操作通知汇编程序和连接程序：在当前汇编中所定义的指定符号的地址，对其他模块是可用的。PUBLIC的格式是：
PUBLIC symbol[,...]（symbol：符号）
可以定义一个以上的符号直到行结束或用附加的PIBLIC语句编码。
该符号项目可以是标号（包括PROC标号），变量，或数字。无效的项目包括寄存器名和定义值大于2个字节的EQU符号。
远过程的调用和EXTRN与PUBLIC的使用会有一点困难，尽管在一个模块中定义的数据要使另一个模块知道需要小心一些。
下一节探讨在程序之间使数据被知道的2种不同方法：使用EXTRN和PUBLIC，以及传送参数。
22.6用EXTRN与PUBLIC作为入口点
在图22-3中的程序由主程序A22MAIN1和子程序A22SUB1组成，它们都使用完整的段定义伪操作。
主程序为堆栈、数据和代码定义段。数据段定义了QTY和PRICE。
代码段把PRICE装入AX，把QTY装入BX，然后调用子程序。
在主程序中的EXTRN指出的子程序入口点是A22SUB1:FAR。
子程序A22SUB1包含PUBLIC语句（在ASSUME之后），该语句使连接程序知道它的名字是作为执行入口点的。
这个子程序简单地进行AX的内容（价格）乘以BX的内容（数量），并求出在DX:AX对中的乘积002E 4000H。
由于子程序没有定义任何数据，所以不需要数据段，子程序是可以设置数据段的，但是只有它自己才能识别这些数据，
子程序使用在SS和SP中的地址，它们是由主程序发送过来的。因此，子程序不能定义堆栈，
因为它所引用的堆栈是在主程序中定义的。由于连接程序要求一个.EXE释序至少要定义一个堆栈，
所以主程序的堆栈就是服务于这一目的的。
现在观察一下每次汇编后的符号表。注意，主程序的符号表把A22SUB1表示成远的和外部的。
子程序的符号表把A22SUB1表示成F（远的）和全局的。
项目全局的意思是指该名字对于A22SUB1以外的其他子程序来说是已知的。
这里是相连接模块的连接映像，它说明在存储器中的程序组织。
注意，有一个堆栈和一个数据段，但两个代码段（每次汇编一个）是在不同的起始地址处，因为它们的组合类型是NONE。
这些段是按顺序出现的，这个顺序就是用LINK命令输入它们时的顺序。
在这个例子中，主程序的代码段（通常是第一个）是从偏移值00090H开始的，而子程序的代码段则是
从偏移值000B0H开始的：
A22MAIN1+A22SUB1
开始         停止         长度         名字         类别
00000H   0007FH   00080H   STACKSEG   STACK
00080H   00083H   00004H   DATASEG   DATA
00090H   000A5H  00016H   CODESEG   CODE
000B0H   000B2H  00003H   CODESEG   CODE

EXTRN A22SUB1:FAR
STACKSEG SEGMENT PARA STACK 'Stack'
DW 64 DUP (?)
STACKSEG ENDS
DATASEG SEGMENT PARA 'Data'
QTY DW 0140H
PRICE DW 2500H
DATASEG ENDS
CODESEG SEGMENT PARA 'Code'
BEGIN PROC FAR
ASSUME CS:CODESEG,DS:DATASEG,SS:STACKSEG
MOV AX,DATASEG
MOV DS,AX
MOV AX,PRICE
MOV BX,QTY
CALL FAR PTR A22SUB1
MOV AX,4C00H
INT 21H
BEGIN ENDP
CODESEG ENDS
END BEGIN
...
CODESG SEGMENT PARA 'Code'
ASSUME CS:CODESG
PUBLIC A22SUB1
A22SUB1 PROC FAR
MUL BX
RETF
A22SUB1 ENDP
CODESG ENDS
对程序执行的跟踪，能揭示出A22MAIN1的CS包含0F20[0]，并且指令CALL A22SUB1产生9A 0000 220F
（段地址值很可能不同）。段间CALL的机器码是9AH。该操作使IP进栈并把0000（CALL的第一个操作数）存入IP。
然后使包含0F20[0]的CS进栈并将0F22[0]（第二个操作数）存入CS
（寄存器内容在这里是按正常而不是相反的字节顺序排列的）。
CS:IP对指向下一条要在0F22[0]加上0000处执行的指令。在0F220处是什么呢？
是A22SUB1的入口点在它的第一条可执行指令处，是可以计算出来的。主程序是由包含0F20[0]的CS开始的。
根据映像，主代码段偏移值开始于偏移值00090H，而子程序偏移值开始于偏移值000B0H，相隔20H个字节。
把主程序的CS值加上20H便提供了子程序代码段的有效地址：
A22MA1N1的CS地址：0F200H
A22MAIN1的大小：00020H
A22SUB1的CS地址：0F220H
装入程序确定这个地址（和我们有的一样）并替代其在CALL中的操作数。
A22SUB1把在AX和BX中的2个值相乘，产牛的乘积在DX:AX中，并完成了一个到A22MAIN1的远返回（RETF）
（因为是对一个远过程的返回）。
22.7代码段定义为PUBLIC
图22-4提供的是图22-3的改型。在主程序中，有一个变化是A22MAIN2，并且子程序也有一个变化是A22SUB2，
它们2个都涉及到代码段的SEGMENT伪操作中PUBLIC的使用：
EXTRN A22SUB2:FAR
STACKSEG SEGMENT PARA STACK 'Stack'
DW 64 DUP (?)
STACKSEG ENDS
DATASEG SEGMENT PARA 'Data'
QTY DW 0140H
PRICE DW 2500H
DATASEG ENDS
CODESEG SEGMENT PARA PUBLIC 'Code'
ASSUVE CS:CODESEG,DS:DATASEG,SS:STACKSEG
BEGIN PROC FAR
MOV AX,DATASEG
MOV DS,AX
MOV AX,PRICE
MOV BX,QTY
CALL FAR PTR A22SUB2
MOV AX,4C00H
INT 21H
BEGIN ENDP
CODESEG ENDS
END BEGIN
...
CODESEG SEGMENT PARA PUBLIC 'Code'
ASSUME CS:CODESEG
PUBLIC A22SUB2
A22SUB2 PROC FAR
MUL BX
RETF
A22SUB2 ENDP
CODESEG ENDS
有意义的结果出现在连接映像和CALL目标码中。在每次汇编后的符号表中，CODESEG的组台类型是PUBLIC，
而在图22-3中是NONE。还有，在连接映像的末端，现在所表示的是只有一个代码段。
事实上两个段有相同的名字（CODESEG），类别（'Code'），以及PUBLIC属性，
使连接程序把两个逻辑的代码段组合成一个物理的代码段。下面是连接映像：
目标模块：A22MAIN2+A22SUB2
开始                  停止                  长度                  名字                  类别
00000H         0007FH         00080H         STACKSEG         STACK
00080H         00083H         00004H         DATASEG         DATA
00090H         000B2H         00023H         CODESEG         CODE
程序入口点在0009：0000
此外，对机器执行的跟踪表明CALL是远的调用，也就是说，虽然CALL是在同一段内，但它是对FAR过程的调用，
其目标码是9A 2000 200F（段地址很可能不同）。这个远CALL把2000H按0020H存入IP中，
并把200FH按0F20[0]存入CS中。因为子程序和主程序一起共享一个公共代码段，所以CS置成同样的起始地址0F20H。
但是A22SUB2的CS：IP现在提供了以下有效地址：
A22MATN2和A22SUB2的CS地址：0F200H
A22SUB2的IP偏移值：0020H
A22S0B2的有效地址：0F220H
因此，子程序的代码段估计是从0F220H开始的。这正确吗？
连接映像没能清楚地指明这一点，但可以从主程序（在偏移值0015H处结束）的列表中去推算这个地址
（列表中表示的是16H，它是下一个可用单元）。由于了程序的代码段是按PARA定义的，所以它开始于小段边界
（能被10H除尽的，使得最右边数位是0）：
0F200+16=0F216->0F210H+10H->0F220H
连接程序把子程序设置在紧跟主程序后的第一个小段边界处，偏移值为00020H。
因此，正如所计算的那样，子程序的代码段是从0F200H加上0020H，即0F220H处开始的。
下一节要探讨用简化段伪操作定义的这同一个程序。
22.8使用简化段伪操作
图22-5表示现在用简化段伪操作定义的以前的程序。图22-4是把代码段定义为PUBLIC，而图22-5默认为PUBLIC，
这样，两个例子都产生一个代码段。但是，简化段伪操作的使用产生了一些重要的差别。
首先，现在段（如映像中所示）是按代码，数据，以及堆栈的顺序重新排列的，尽管这不影响程序的执行。
第二，根据段表与组表，子程序的代码段（_TEXT）定位于字（而不是小段）边界。
.MODEL SMALL
.STACK 64
EXTRN A22SUB3:FAR
.DATA
QTY DW 0140H
PRICE DW 2500H
.CODE
BEGIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV AX,PRICE
MOV BX,QTY
CALL FAR PTR A22SUB3
MOV AX,4C00H
INT 21H
BEGIN ENDP
END BEGIN
...
.MODEL SMALL
.CODE
PUBLIC A22SUB3
A22SUB3 PROC FAR
MUL BX
RETF
A22SUB3 ENDP
对机器执行情况的跟踪表明CALL的目标码是9A 1600 170F（段地址很可能不同）。
这时，新的偏移值是0016H，而段地址是0F17H。因为主程序和子程序共享一个公共代码段，
所以CS设置成同样的起始地址，对于两者都是0F17[0]。可以计算A22SUB3的有效地址如下：
A22MAIN3和A22SUB3的CS地址：0F170H
A22SUB3的IP偏移值：0016H
A22SUB3的有效地址：0F186H
可以从主程序的列表中推算该地址，主程序在偏移值0015H处结束（列表中表明是16H，它是下一个可用单元）。
因为映像表明主代码段是从00000H开始的，跟着0015H的下一个字边界是在00016H，A22SUB3从那里开始，
正确地定位于字边界。下面是连接映像：
目标模块：A22MAIN3+A22SUB3
开始                  停止                  长度                  名字                  类别
00000H         00018H         00019H                  _TEXT              CODE
0001AH         0001DH         00004H                  _DATA            DATA
00020H         0005FH         00040H                  STACK              STACK
程序入口点在0000：0000
22.9传送参数到子程序
使被调用的子程序知道数据的一般方法是传送参数，在这里，程序是通过堆栈帧传送参数的。
在这种情况下，要确保每个PUSH引用的字（或双字）是在存储器或寄存器中。
正如第7章所讨论过的，程序可以用值（实际的数据项）或者用引用（该数据项的地址）来传送参数。
本节给出这两种方法的例子。
堆栈帧是堆栈的一部分，它是调用程序用来传送参数，而被调用的子程序用来取得参数的地方。
被调用的子程序还可以使用堆栈帧作为局部数据的暂存区。BP奇存器起帧指针的作用，而子程序则是BP与SP两个都使用。
22.9.1用值传送参数
在图22-6中，在调用子程序A22SUB4之前，调用程序A22MAIN4使值PRICE和QTY都进入堆栈。
最初，SP包含堆栈的大小80H，每个字进栈，SP要减2。
EXTRN A22SUB4:FAR
STACKSEG SEGMENT PARA STACK 'Stack'
DW 64 DUP (?)
STACKSEG ENDS
DATASEG SEGMENT PARA 'Data'
QTY DW 0140H
PRICE DW 2500H
DATASEG ENDS
CODESEG SEGMENT PARA PUBLIC 'Code'
ASSUME CS:CODESEG,DS:DATASEG,SS:STACKSEG
BEGIN PROC FAR
MOV AX,DATASEG
MOV DS,AX
PUSH WORD PTR PRICE
PUSH WORD PTR QTY
CALL FAR PTR A22SUB4
MOV AX,4C00H
INT 21H
BEGIN ENDP
CODESEG ENDS
END BEGIN
...
CODESEG SEGMENT PARA PUBLIC 'Code'
ASSUME CS:CODESEG
PUBLIC A22SUB4
A22SUB4 PROC FAR
PUSH BP
MOV BP,SP
MOV AX,[BP+8]
MOV BX,[BP+6]
MUL BX
POP BP
RETF 4
A22SUB4 ENDP
CODESEG ENDS
1.第一个PUSH把PRICE（2500H）存放在堆栈帧的偏移值7EH处。
2.第二个PUSH把QTY（0140H）存放在堆栈帧的偏移值7CH处。
3.CALL使CS的内容（对于这次执行，它是0F20H。）进栈到堆栈帧的7AH处。
由于子程序是PUBLIC的，所以连接程序把两个代码段组合起来，而CS的地址对于两个代码段都是一样的。
4.CALL还使IP的内容0012H进栈到堆栈帧的78H处。现在SP包含78H，而堆栈帧表示如下：
7EH 0025
7CH 4001H
7AH 200FH
78H 1200H
被调用程序需要使用BP去取堆栈帧中的参数。它的第一个动作是为调用程序保存BP的内容，所以要使BP进栈。
在这个例子中，BP碰巧包含0，它被PUSH存入堆栈帧的偏移值76H处。
然后，程序把SP的内容（0076H）放入BP，这是因为BP（而不是SP）是作为变址寄存器使用的。
由于BP现在是0076H，所以PRICE是在堆栈的BP+8（偏移值7EH）处，而QTY是在BP+6（偏移值7CH）处。
因为有3个字（6个字节）是在QTY进栈后才进栈的，所以我们知道这些相关的单元。
例行程序分别把PRICE和QTY从堆栈传送到AX和BX，并完成乘法运算。
在返回到调用程序之前，子程序使BP出栈（把0地址回送到BP），SP加2，从76H到78H。
最后的指令RETF是远返回到调用程序，它完成以下操作：
使当时的堆栈帧顶的字（1200H）出栈到IP，并使SP加2，从78H到7AH。
使当时的堆栈帧顶的字（0F20H）出栈到CS，并使SP加2，从7AH到7CH。
由于2个所传送的参数是在偏移值7CH和7EH处，所以返回指令被编码为RETF 4。
立即值4指出所传送参数的字节数（在这种情况下是2个1字参数）。
RETF把出栈值加到SP，把它改正为80H。
实际上，因为在堆栈中的参数已不再需要，所以操作便“丢弃”了它们并正确地返回到调用程序。
注意，虽然POP和RET操作使SP增量，但实际上并不能抹除堆栈的内容。
这里是连接映像：
目标模块：A22MAIN4+A22SUB4
开始                  停止                  长度                  名字                  类别
00000H         0007FH         00080H                  STACKSEG      STACK
00080H         00083H         00004H                  DATASEG       DATA
00090H         000BEH         0002FH                  CODESEG       CODE
程序入门点在0009：0000
22.9.2用引用传送参数
在图2-7中的程序用引用传送参数，在这种情况下，是QTY与PRICE的地址。
在被调用的子程序A22SUB5中的主要区别是把PRICE的地址取到DI中，把QTY的地址取到BX中：
MOV DI,[BP+8]
MOV BX,[BP+6]
然后，使用现在在DI中的地址得到PRICE，存入AX中：
MOV AX,[DI]
并且使用BX中的地址得到QTY，与AX中的PRICE相乘：
MUL WORD PTR [BX]
该程序是另一种自说明性的。
EXTRN A22SUB5:FAR
STACKSEG SECMENT PARA STACK 'Stack'
DW 64 DUP (?)
STACKSEG ENDS
DATASEG SEGMENT PARA 'Data'
QTY DW 0140H
PRICE DW 2500H
DATASEG ENDS
CODESEG SEGMENT PARA PUBLIC 'Code'
ASSUME CS:CODESEG,DS:DATASEG,SS:STACKSEG
BEGIN PROC FAR
MOV AX,DATASEG
MOV DS,AX
LEA CX,PRICE
LEA DX,QTY
PUSH CX
PUSH DX
CALL FAR PTR A22SUB5
MOV AX,4C00H
INT 21H
BEGIN ENDP
CODESEG ENDS
END BEGIN
...
CODESEG SEGMENT PARA PUBLIC 'Code'
ASSUME CS:CODESEG
PUBLIC A22SUB5
A22SUB5 PROC FAR
PUSH BP
MOV BP,SP
MOV DI,[BP+8]
MOV BX,[BP+6]
MOV AX,[DI]
MUL WORD PTR [BX]
POP BP
RETF 4
A22SUB5 ENDP
CODESEG ENDS
22.10ENTER与LEAVE指令
ENTER 指令（由80286引入）是用于为被调用的过程（需要接受传送参数）建立临时堆栈帧的。
LEAVE指令是和ENTER相对应的，用来终止堆栈帧。它们的格式是：
[label:] ENTER size,nest-level（size：大小，nest-level：嵌套层）
[label:] LEAVE [no operand]
大小操作数指定为堆栈帧分配操作数的字节数。虽然堆栈通常是由字或双字组成的，但ENTER允许传送字节大小的参数。
嵌套层操作数指定操作的嵌套层数。对于BASIC，C以及Fortran编译程序来说，层数总是0。
例如，指令ENTER 4,0等效于：
PUSH BP
MOV BP,SP
SUB SP,4
该操作的效果是建立一个堆栈帧，在这个堆栈帧中BP指向其顶部而SP指向底部。
程序在此堆栈帧内传送参数给被调用的过程。
LEVAE指令和ENTER的操作是相反的，终止堆栈帧。LEVAE操作等效于：
MOV SP,BP
POP BP
该操作把SP和BP恢复成原来的值。
在图22-8的程序中，ENTER为把两个参数（行与列）传送给过程SET_CURSOR而建立了一个2字节的堆栈帧。
注意，程序是向堆栈传送参数或从堆栈取出参数，而不是使用PUSH与POP。
注释表示了SP与BP的内容，假定它们分别是从40H与00H开始的。
.MODEL SMALL
.STACK 512
.DATA
ROW EQU 5
COL EQU 8
.CODE
BEGIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX   ;SP=40H BP=0
ENTER 2,0   ;SP=3CH BP=3EH
MOV BYTE PTR [BP-1],ROW
MOV BYTE PTR [BP-2],COL
CALL SET_CURSOR   ;SP=3AH BP=3EH
LEAVE   ;SP=40 BP=0
MOV AX,4C00H
INT 21H
BEGIN ENDP
SET_CURSOR PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AH,02H
MOV BH,0
MOV DH,[BP-1]
MOV DL,[BP-2]
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
SET_CURSOR ENDP
END BEGIN
遵循本章所讨论的通用规则，那么应该连接一个由多于2个汇编模块所组成的程序。但是要留心堆栈的大小：
对于使用许多PUSH与CALL操作的大型程序，定义64个字可能是合理的预防措施。
第23章涉及一些有关管理存储器与执行覆盖程序的重要概念。
第25章提供了段的一些附加特性，包括在同一汇编模块中定义一个以上的代码段或数据段，
以及把它们组合成一个公共段的GROUP的使用。
22.11C/C++程序与汇编语言程序的连接
虽然C/C++程序可以实现许多汇编语言的功能，但还是有不少特性只有汇编语言才能做到：
执行PUSH和POP操作。
访问BP与SP寄存器。
初始化某些段寄存器。
执行时间要求严格的例行程序，比如显示视频图形和实现通过端口的I/O。
以下各节说明C/C++程序与汇编语言模块接口方而的要求。该资料是基于Microsoft C和C++编译程序的。
存储模型。调用程序与被调用的汇编程序必须是用同样的存储模型定义的。
用Tiny，Small和Compact 模型定义的程序产生对外部模块的近调用，它只使IP进栈。
Medium和Large存储模型定义的程序产生远调用，它使IP与CS都进栈。
Flat 模型则是在Windows下按保护模式运行，产生近调用。
汇编.MODEL语句指明C/C++约定，比如.MODEL SMALL,C。
命名约定。汇编模块必须使用和C/C++兼容的有关段与变量的命名约定。
在C/C++程序中的所有外部名字都包含个前导的下划线字符，如_column。
汇编程序引用在C/C++模块中的函数与变量也必须由一个下划线（_）开始。
而且，由于C/C++是对大小写字母敏感的，所以汇编模块对于任何公共的变量名应当使用和C/C++模块同样的字母
（大写或小写）。可以强制汇编程序用以下命令行选项维护大小写字母的敏感性：
/mx Microsoft 5.0和Borland 4.0
/Cx Microsoft 6.0
寄存器。汇编的模块必须保持在BP，SP，CS，DS，SS，DI和SI中的原先的值，即在入口使它们进栈，在出口使它们出栈。
传送参数。传送参数有3种方法：
1.用值。C/C++调用程序传送变量的一个副本在堆栈中。被调用的汇编模块可以修改传送的值，
但不能访问调用程序原来的值。如果有一个以上的参数，CVC++从最右边的参数开始使它们进栈。
2.用近引用。调用程序传送数据项值的偏移地址。被调用的汇编模块假设和调用程序共享同一个数据段。
3.用远引用。调用程序传送段与偏移地址（段在前，然后是偏移地址）。
被调用的汇编模块假设使用与调用程序不同的数据段。被调用的程序可以使用LDS或LES指令来初始化段地址。
C/C++程序传送参数到堆栈中是以和其他语言相反的顺序进行的。例如，考虑语句
Adds(value_1,value_2)
该语句先使value_2，后使value_1进栈，就按那样的次序并调用Adds。在从被调用模块返回时，
C/C++模块（不是汇编模块）使SP增量去丢弃传送的参数。
在被调用的汇编模块中，用于访问2个传送参数的典型过程如下：
PUSH BP
MOV BP,SP
MOV DH,[BP+4]
MOV DL,[BP+6]
...
POP BP
RET
在PUSH BP指令之后，堆栈帧表现为：
value_2 BP+6
value_1 BP+4
返回的IP   BP+2
原先的BP  BP+0
在从被调用的模块返回时，由于由C/C++调用程序承担清除堆栈的责任，所以发出的RET不带立即操作数。
数据类型的兼容性。下表表示C/C++变量的类型和与其等效的汇编程序的变量类型：
C数据类型                  MASM5.x类型                  MASM 6.0类型
char                           DB                                    BYTE
unsigned short/int   DW                                   WORD
int，short                  DW                                   SWORD
unsigned long           DD                                    DWORD
long                           DD                                    SDWORD
回送值。被调用的汇编模块对于任何回送值使用以下寄存器：
C数据类型                           寄存器
char                                    AL
short，near int（16bit）   AX 
short，near int（32bit）   EAX
long，far（16bit）            DX:AX
 long，far（32bit）           EDX:EAX
22.11.1程序举例：C和汇编语言连接
在图22-9中的例子是把一个C程序与一个汇编子程序连接起来，该汇编子程序的唯一目的是设置光标。
C/C++程序通过编译产生.OBJ模块，而汇编程序则通过汇编产生.OBJ模块。
然后，连接程序把这2个.OBJ模块组合成一个.EXE可执行模块。
C程序定义名为temp_row和temp_col的两个项，并接受由键盘输入这些变量的行与列，
该程序定义汇编子程序的名字是set_curs。它发送作为参数的temp_row和temp_col的地址给子程序用于设置光标。
调用子程序并传送参数的C语句是：
void set_curs(int temp_row, int temp_col);
#include <stdio.h>
int main(void)
{
    int temp_row, temp_col;
    printf("Enter cursor row:");
    scanf("%d", &temp_row);
    printf("Enter cursor column:");
    scanf("%d", &temp_col);
    set curs(temp_row, temp col);
    printf("New cursor location\n");
}
;对于C使用small存储模型 近代码 近数据
;使用standard 段名，以及group 为操作
_DATA SEGMENT WORD 'DATA'
ROW EQU [BP+4]
COL EQU [BP+6]
_DATA ENDS
_TEXT SEGMENT BYTE PUBLIC 'CODE'
DGROUP GROUP _DATA,STACK
ASSUME CS:_TEXT,DS:DGROUP,SS:DGROUP
PUBLIC _set_curs
_set_curs PROC NEAR
PUSH BP
MOV BP,SP
MOV AH,02H
MOV BH,0
MOV DH,ROW
MOV DL,COL
INT 10H
POP BP
RET
_set_curs ENDP
_TEXT ENDS
END
进栈的值是调用程序的BP，返回的偏移地址，以及2个被传送参数的地址。
第一个被传送的参数temp_row是在堆栈帧的偏移值04H处按BP+04H被访问。
第二个被传送的参数temp_col是在偏移值06H处按BP+06H被访问。
子程序使用在DX中的行与列由INT10H设置光标。在退出时，子程序使BP出栈。
RET指令把控制传送回调用程序，由调用程序去清除堆栈帧。
这个普通的程序产生一个大于20K字节的模块。编译程序典型地会产生相当大的开销而不管源程序的大小如何。
其他一些C/C++版本不需要遵循这里使用的一些约定。详细资料见编译程序手册，
通常是在由“接口…”或“混合语言…”标题开始的部分。
22.12要点
定位操作符通知汇编程序定位命名的段从特定存储边界开始。
组合操作符通知汇编程序与连接程序是否去组合段或保持它们独立。
分配相同的类别名给相关段会使汇编程序与连接程序把这些段组合在一起。
如果被调用过程是被定义为或默认为NEAR（在32K内），则段内调用是近调用。
如果调用是对于个同一段内远过程，则段内调用也可以是远调用。
段间调用调用在另一段中的过程，并定义为FAR或EXTRN。
在调用子程序的主程序中，入口点被定义为EXTRN；在子程序中，入口点是PUBLIC。
为了把两个代码段连接成一个段，二者必须定义成同样的名字，同样的类别，以及PUBLIC组合类型。
22.13习题
22-1.给出把程序组织成子程序的4个理由。
为了不同程序语言之间的连接，例如，把易于编码的高级程序语言和处理效率高的汇编语言组合起来。
为了便于大型项目的开发，在那些项目中，不同的组分别开发不同的模块。
为了便于维护，为了使程序更健壮。
下面3个问题适用的SEGMENT伪操作的格式是：
segment-name SEGMENT [align] [combine] ['class']
22-2.（a）SEGMENT伪操作的定位选项的默认值是什么？（b）BYTE选项的作用是什么（即汇编程序要做什么动作？）
缺省的定位类型是PARA，即段起始地址位于可用的第一个节（每节为16个字节）的边界处。
定位类型BYTE使得当前段紧接前一段，前后两段间没有空闲单元，所以是最节约的定位类型。
定位类型WORD使得段从偶地址开始，不仅较为节约，而且有利于把数据单元定位在偶地址。
定位类型DWORD常用于80386的32位段。
22-3.（a）SEGMENT伪操作的组合选项的默认值是什么？
NONE
若段定义伪指令SEGMENT语句中没有给出组合类型，就表示不与其它段组合。
（b）为什么要使用PUBLIC选项？
组合类型PUBLIC表示当前段与其它模块中组合类型为PUBLIC的同名段组合成一个段。
组合的先后顺序取决于启动LINK程序时目标模块名排列的次序。组合时仍遵照定位类型进行衔接，即同名段间可能有间隔。
（c）为什么要使用COMMON选项？
组合类型COMMON表示当前段与其它模块中的同名段重叠，即起始地址相同。最终段的长度等于它们中最长的段的长度。
组合类型STACK表示当前段是堆栈段，将与其它模块中组合类型为STACK的堆栈段在连接时以接续的方式组合成一个存储空间更大的堆栈。
22-4.（a）SEGMENT伪操作代码段的类别选项通常是什么？
'CODE'
（b）如果2个段有同样的类别但没有PUBLIC组合选项，结果是什么？
（c）如果2个段有同样的类别，而且都有PUBLIC组合选项，结果是什么？
在同一模块中，如果已用相同的段名定义过段，那么当前这个段就被视为前一个同名段的继续，即同一个段。
组合类型PUBLIC表示当前段与其它模块中组合类型为PUBLIC的同名段组合成一个段。
组合的先后顺序取决于启动LINK程序时目标模块名排列的次序。组合时仍遵照定位类型进行衔接，即同名段间可能有间隔。
组合类型COMMON表示当前段与其它模块中的同名段重叠，即起始地址相同。最终段的长度等于它们中最长的段的长度。
22-5.说明段内调用与段间调用之间的区别。
被调用的过程和调用过程在同一个代码段中，则是段内调用。
如果被调用的过程是定义为或默认为NEAR（即在32K内），则段内调用是近调用。
如果被调用的过程是在同一段内，但是定义为FAR，则段内调用是远调用。
被调用的过程和调用过程不在同一个代码段中，则是段间调用。段间调用都是远调用。
22-6.名为MAINPROG的程序调用一个名为SUBCALC的子程序。（a）MAINPROG中的什么语句通知汇编程序名字SUBCALC是在它自己的汇编之外定义的？
（b）在SUBCALC中的什么语句使它的名字让MAINPROG知道？
EXTRN SUBCALC:FAR
PUBLIC SUBCALC
22-7.在22-6题的基础上编写一个测试程序。在MAINPROG中定义3个DW的数据项：
STOCK_QTY（现有的库存量），UNITCOST，以及STOCKVALUE。MAINPROG把全部3个数据项作为参数传送给 SUBCALC。
SUBCALC随后又用STOCK_QTY 去除STOCKVALUE，并把商存入UNITCOST。注意，SUBCALC回送的计算好的价格完整地放在它的参数中。
EXTRN SUBCALC:FAR
STACKSEG SEGMENT PARA STACK 'Stack'
DW 64 DUP (?)
STACKSEG ENDS
DATASEG SEGMENT PARA 'Data'
STOCK_QTY DW 0100H
STOCKVALUE DW 2500H
UNITCOST DW 0
DATASEG ENDS
CODESEG SEGMENT PARA PUBLIC 'Code'
ASSUME CS:CODESEG,DS:DATASEG,SS:STACKSEG
BEGIN PROC FAR
MOV AX,DATASEG
MOV DS,AX
LEA BX,UNITCOST
PUSH BX
PUSH WORD PTR STOCKVALUE
PUSH WORD PTR STOCK_QTY
CALL FAR PTR SUBCALC
MOV AX,4C00H
INT 21H
BEGIN ENDP
CODESEG ENDS
END BEGIN
...
CODESEG SEGMENT PARA PUBLIC 'Code'
ASSUME CS:CODESEG
PUBLIC SUBCALC
SUBCALC PROC FAR
PUSH BP
MOV BP,SP
MOV BX,[BP+10]
MOV AX,[BP+8]
MOV DX,0
MOV CX,[BP+6]
DIV CX
MOV DS:[BX],AX
POP BP
RETF 6
SUBCALC ENDP
CODESEG ENDS
END
22-8.修改题22-7中的程序，使它为堆栈帧使用ENTER和LEAVE指令。
EXTRN SUBCALC:FAR
STACKSEG SEGMENT PARA STACK 'Stack'
DW 64 DUP (?)
STACKSEG ENDS
DATASEG SEGMENT PARA 'Data'
STOCK_QTY DW 0100H
STOCKVALUE DW 2500H
UNITCOST DW 0
DATASEG ENDS
CODESEG SEGMENT PARA PUBLIC 'Code'
ASSUME CS:CODESEG,DS:DATASEG,SS:STACKSEG
BEGIN PROC FAR
MOV AX,DATASEG
MOV DS,AX
ENTER 6,0
LEA BX,UNITCOST
MOV [BP-2],BX
MOV BX,STOCKVALUE
MOV [BP-4],BX
MOV BX,STOCK_QTY
MOV [BP-6],BX
CALL FAR PTR SUBCALC
LEAVE
MOV AX,4C00H
INT 21H
BEGIN ENDP
CODESEG ENDS
END BEGIN
...
CODESEG SEGMENT PARA PUBLIC 'Code'
ASSUME CS:CODESEG
PUBLIC SUBCALC
SUBCALC PROC FAR
MOV BX,[BP+8]
MOV AX,[BP+6]
MOV DX,0
MOV CX,[BP+4]
DIV CX
MOV DS:[BX],AX
RETF
SUBCALC ENDP
CODESEG ENDS
END
22-9.扩展题22-8使得MAINPROG 接受来自键盘的库存量与值，子程序 SUBBINRY把ASCII量转换成二进制，子程序SUBCALC计算价格，
子程序SUBASCII则把二进制价格转换成ASCII，而主程序MAINPROG显示结果。
使用GETSTRD接收键盘输入，DTOBIN把输入的内容转换成二进制，SUBCALC计算，DTOBUF把二进制转换成ASCII，MAINPROG显示转换好的内容
第23章程序装入与覆盖
23.1引言
23.2程序段前缀
23.3高端存储区
23.4存储器分配策略
23.5程序的装入程序
23.6分配与释放存储器
23.7装入或执行程序功能
23.8程序覆盖
23.9常驻程序
23.10要点
23.11习题
目的：说明系统是如何装入程序与覆盖执行模块的。
23.1引言
本章说明程序段前缀，程序的装入程序，程序的覆盖，以及常驻程序。介绍的操作是INT 2FH的功能4A01H多路中断和
以下一些INT21H的功能：
25H   设置中断向量   4AH   修改分配的存储块
31H   驻留程序          4BH   装入或执行程序
35H   取中断向量      51H   取当前PSP地址
48H   分配存储器      58H   取/置存储器分配策略
49H   释放已分配存储器
23.2程序段前缀
为了执行程序，装入程序把.COM和.EXE程序装入到程序段中，并在段的偏移值00H处建立PSP，
而且在偏移值100H处建立程序本身。PSP包含以下有用的字段，按照相对位置列出如下：
00-01H   INT 20H指令（CD20H）便于返回系统。
02-03H   分配给程序的存储器最后一个小段的段地址，如xxxx0。例如，640K指示为00A0H，意思是A000[0]。
0A-0DH   结束地址（INT 22H的段地址）。
0E-11H   Ctrl+Break 退出地址（INT 23H的段地址）。
12-15H   危急出错退出地址（INT   24H的段地址）。
18-2BH   默认文件处理表。
2C-2DH   程序环境的段地址。
32-33H   文件处理表长度。
34-37H   处理表远指针。
50-51H   调用INT 21H功能（INT 21H和RETF）。
5C-6BH   第一命令行自变量（FCB#1）。
6C-7FH   第二命令行自变量（FCB#2）。
80-FFH   默认DTA（磁盘传输区）的缓冲区。
FCB（文件控制块）是存取磁盘文件的一种陈旧的方法。
在PSP中所用的这一术语简单包含格式化了的文件说明：n:filename.ext，其中filename是8个字节，而ext是3个。
以下几节说明在PSP中的有关字段。
1.PSP18-2BH：默认文件处理表。在20字节的默认文件处理表中的每个字节指向系统表（它定义有关设备或驱动器）
的一个入口。最初，表包含0101010002FF...FF，其中第一个01指的是键盘，第二个01指的是屏幕，等等：
表项目                           处理设备
01         控制台                0 键盘（标准输入）
01         控制台                1 屏幕（标准输出）
01         控制台                2 屏幕（标准错误）
00         COM1                3 辅助的（串行口）
02         LPT1                  4 标准打印机
FF         未分配                5 未分配
通常，在PSP偏移值32H处的字包含表的长度（14H或20），偏移值34H包含了段地址，以IP:CS格式表示，
其中IP是18H（在PSP中的偏移值），CS是PSP的段地址。
需要多于20个打开文件的程序必须释放存储器INT21H的功能4AH），并使用功能67H（设置最大的处理数）：
MOV AH,67H   ;请求更多的处理
MOV BX,count   ;新的数（20到65535）
INT 21H   ;调用中断服务
需要的存储器总量是：每个处理一个字节，使数目恰好达到下一字节小段加16个字节。
该操作在PSP之外建立一个新的处理表，并修改PSP单元32H和34H。无效操作设置进位标志并在AX中设置一个出错码。
2.PSP2C-2DH：环境的段地址。为执行而装入的程序有一个相应的环境，由系统放在存储器中，
从程序段前面的小段边界开始。默认大小是160字节，最大值是32KB。
环境包含这样一些系统命令，如COMSPEC，PATH，PROMPT和SET，它们是能适用于程序的。
3.PSP80-FFH：默认的DTA缓冲区。装入程序用在所要求的程序名（如MASM或COPY）之后键入的完整文本
（如果有的话）来初始化这个区域。第一个字节包含在程序名键入后紧接着按的键（如果有的话）数，
跟着该数的是被键入的字符（如果有的话），而后是来自前一个操作的、留在存储器中的任何无用单元。
以下4个例子将说明DTA的内容与用途。
PSP的偏移80H处含命令行参数的长度（字节数），从PSP的偏移81H开始存放命令行参数。
命令行参数通常以空格符引导，至回车符（0DH）结束。注意，命令行中的重定向符和管道符及有关信息不作为命令行参数送到PSP。
例1：不带操作数的命令。假定要求执行名为CALCIT.EXE的程序，用键入CALCIT<Enter>的办法就可以了。
当程序的装入程序构造PSP时，它建立默认的DTA为00 0D...。第一个字节内容是在名字CALCIT之后键入的字节数，
不包括<Enter>字符。由于除<Enter>以外，没有按别的键，所以数是0。第二个字节是0DH，也就是<Enter>。
例2：带文本操作数的命令。假定想执行一个名为COLOR的程序并传送一个参数“BY”，
该参数通知程序设置前景颜色为蓝（B）色和背景颜色为黄（Y）色。键入程序名后跟参数：COLOR BY。
然后，装入程序把DTA格式化为：
03 20 42 59 0D...
这些字节的意思是：长度为3后跟一个空格，“BY”和0DH（<Enter>）。
除长度外，这个字段正好包含了在程序名COLOR之后所键入的内容。
例3：带文件名操作数的命令。许多程序允许在程序名之后键入文件名。如果键入了，比如DEL A:CALCIT.OBJ<Enter>，
则DTA包含以下内容：
0D 20 41 3A 43 41 4C 43 49 54 2E 4F 42 4A 0D...
A:CAICTT.OBJ
长度13（0DH）后面跟着的正好是键入的内容，包括作为<Enter>的0DH。
例4：带2个文件名操作数的命令。考虑输入个命令后面跟着2个操作数，
比如COPY A:FLLEA.ASM C:FILEB.ASM
装入程序用以下内容设置DTA：
80H DTA：10 20 41 3A 46 49 4C 45 41 2E 41 53 4D 20 等...
A:FTLEA.ASM 等...
DTA包含键入的字符数（10H），空格（20），A:FILEA.ASM C:FILEB.ASM，以及作为<Enter>的0DH。
访问PSP
根据确定的PSP地址，为处理指定的文件或进行专门的操作，可以访问PSP。
为了定位.COM程序的DTA，简单地在BX、DI或SI中设置80H并访问其内容：
MOV SI,80H   ;DTA的地址
CMP BYTE PTR [SI],0   ;检查缓冲区（DS:SI）
JE EXIT   ;零，无数据
但是，.EXE程序不能总是假定它的代码段紧跟在PSP之后。
可以要求INT 21H的功能51H把当前PSP的段地址传送到BX。
Expects: AH    51H
Returns: BX    PSP segment of current process
00H正常属性文件
01H只读文件
02H隐藏文件，目录搜索不显示
04H系统文件，目录搜索不显示
08H卷标
10H子目录
20H存档文件
功能43H：获得/设置文件属性
使用此项功能既可以获取也可以设置文件属性。操作要求ASCIIZ串的地址装入DX，ASCIIZ串包含要操作文件的驱动器、路径和文件名
（如果路径未给出，则使用默认目录）。
1.获得文件属性。为了得到文件属性，在AL中装入代码00，如下例所示：
ASCSTRING DB 'n:\pathname',00H
MOV AH,43H
MOV AL,00H
LEA DX,ASCSTRING   ;ASCIIZ串地址（DS:DX）
INT 21H   ;调用中断服务
有效操作CF清零，CH清零，并在CL中返回当前属性：
位   属性
0   只读文件
1   隐藏文件
2   系统文件
3   卷标
4   子目录
5   存档文件
操作出错则设置CF并且在AX中返回代码02或03。
2.设置文件属性。为了设置文件属性，在AL中装入代码01，在CX中装入属性。
可以改变只读、隐藏、系统和存档属性，但不可以改变卷标和子目录。下例设置一个文件为隐藏和存档属性：
MOV AH,43H
MOV AL,01H
MOV CX,0022H   ;隐藏和存档属性
LEA DX,ASCSTRING   ;ASCIIZ串地址（DS:DX）
INT 21H   ;调用中断服务
有效操作CF清零，并且在CX中设置目录入口项的属性。操作出错，设置CF并且在AX中返回代码02，03或05。
在图23-1的部分程序中，把所要求的文件属性设置成隐藏的（02H）。
用户可以键入后跟文件名的程序名，比如A23ATTRB n:filename.ext。
程序首先确定PSP的地址，接下来要扫描DTA的<Enter>字符，并用一个十六进制零的字节取代它，
建立一个ASCIIZ的串。然后INT 21H的功能43H使用DTA中的ASCIIZ串去改变在目录中的文件属性。
对于更为灵活的程序，用户可以键入目录路径和所要求的文件属性。
PUSH ES
PUSH DS
MOV AH,51H
INT 21H
MOV ES,BX
MOV DS,BX
MOV AL,0DH
MOV CX,21
MOV DI,82H
CLD
REPNZ SCASB
JNZ exit
DEC DI
MOV BYTE PTR ES:[DI],0
MOV AH,43H
MOV AL,01H
MOV CX,0002H
MOV DX,82H
INT 21H
POP DS
POP ES
JC exit
...
exit:
...
A10MAIN ENDP
END A10MAIN
23.3高端存储区
处理器使用许多地址线访问存储器。线号A20可以访问高端存储区（HMA）的64K空间：从FFFF：10H到FFFF:FFFFH，
正好在1兆字节地址上。当处理器在实（8086）模式下运行时，它通常关闭A20线，
以便超出这一限制的那些地址能绕过一圈到存储器的起点。
打开A20线，则允许寻址在HMA中的单元。还可以要求CONFIG.SYS从低端存储器到HMA重新定位系统文件，
从而为用户程序腾出空间。
INT 2FH（多路中断）的服务功能之一是提供对HMA中可用空间的检查（通过功能4A01H）：
MOV AX,4A01H   ;请求HMA中的空间
INT   2FH;调用多路中断
该操作将以下值回送到寄存器中：
BX=在HMA中可用的空闲字节数（如果 COMMAND.COM没有装入到高端，则是零）。
ES:DI=在HMA中第一个空闲字节的地址（如果系统模块没有装入到高端，则是FFFF：FFFF）。
Expects: AX    4A01H
Returns: ES:DI Address of free space in the HMA 
BX    Available HMA space, in bytes
23.4存储器分配策略
INT 21H的功能58H提供许多决定存储器在哪里装入程序的策略。
23.4.1功能5800H：取存储器分配策略
这一操作允许查询存储器分配策略：
MOV AX,5800H   ;请求取策略
INT 21H   ;调用中断服务
该操作清除进位标志，并把策略回送到AX：
00H=最先适合（默认）：从常规存储器最低地址开始查找第一个可用块，块的大小能足够装入程序。
01H=最佳适合：查找在常规存储器中最小的可用块，该块足够装入程序。
02H=最后适合：从常规存储器最高地址开始查找第一个可用块。
40H=最先适合，只是高端：从存储器上部的最低地址开始查找第一个可用块。
41H=最佳适合，只是高端：在存储器的上部查找最小的可用块。
42H=最后适合，只是高端：从存储器上部的最高地址开始查找第一个可用块。
80H=最先适合，高端：从存储器上部的最低地址开始查找第一个可用块。如果没找到，再查找常规存储器。
81H=最佳适合，高端：从存储器上部查找最小可用块。如果没找到，再查找常规存储器。
82H=最后适合，高端：从存储器上部的最高地址开始查找第一个可用块。如果没找到，再查找常规存储器。
最佳与最后适合策略适用于多任务系统，可能会产生一些存储器碎片，
因为各程序是同时运行的，当程序结束处理时，其存储区便释放给系统。
23.4.2功能5801H：设置存储器分配策略
这一操作允许改变存储器分配策略。为了设置策略，把AL置成代码01以及BX置成策略代码。
出错时设置进位标志并回送01（无效功能）到AX。
23.4.3功能5802H：取上部存储器连接
这一操作指明程序是否可以从上部存储区（640K以上）分配存储器。
该操作清除进位标志，并回送以下代码之一到AL：00H的意思是该区未被连接并不能分配，
01H的意思是该区已被连接并可以分配。
23.4.4功能5803H：设置上部存储器连接
该操作可以连接或不连接上部存储区，并且如果该区是被连接的，则可以从它这里分配存储器：
MOV AX,5803H
MOV BX,linkflag
INT 21H
linkflag操作数有以下意义：00H=不连接该区，01H=连接该区。
成功的操作会清除进位标志，并允许程序从它这里分配存储器。
出错时设置进位标志，并回送给AX代码01（CONFIG.SYS不包含DOS=UMB）或07（存储器连接被破坏）。
23.5程序的装入程序
在装入.COM和.EXE程序时，程序的装入程序要在存储器中的程序段的00H单元建立程序段前缀，
并把程序装入到100H。除这一步骤之外，.COM与.EXE的装入与执行步骤是有区别的。
主要区别是，当要把文件存入磁盘时，连接程序要在该.EXE文件中插入一个专门的标题记录，
而装入程序使用这一记录进行装入。
23.5.1.COM程序的装人与执行
在装入.COM程序时，装入程序
在存储器中程序的前面安装PSP。
用PSP的第一个字节地址设置4个段寄存器。
把堆栈指针（SP）设置到64K段的末端，偏移值为FFFEH（或如果段不够大时，则设置到存储器的末端），
并且使一个为零的字进栈。
把指令指针（IP）设置到100H（PSP的大小），并允许控制传送到CS:IP产生的地址处继续进行下去，
那是紧跟PSP后的第一个单元，是程序的第一个字节，而且它应当包含可执行指令。
23.5.2.EXE程序的装人与执行
在连接程序把.EXE模块存入磁盘时，该模块由两部分组成：包含控制与再定位信息的标题记录，以及实际的装入模块。
标题最小值是512个字节，并且如果有许多再定位项，那么还可以更长。
标题包含有关可执行模块大小（它要被装入到存储器中），堆栈的地址，以及要被插入到未完成机器地址的再定位
（或称浮动）偏移值的信息。在下表中，术语块指的是存储器中512个字节的区域：
00-01H十六进制4D5A（‘MZ’）标记一个.EXE文件。
02-03H.EXE文件最后块的字节数。
04-05H包括标题在内的文件大小，以512个字节的块为增量。例如，如果大小是1025，那么这个字段包含2，
字段02-03H包含1。
06-07H再定位表项目数（见1CH）。
08-09H标题大小以16字节（小段）为增量，它帮助装入程序定位跟在标题后面的可执行模块的起点。
最小数是20H（32）（32×16=512字节）。
0A-0BH当程序被装入时，必须驻留在该程序末端上的小段最小计数值。
0C-0DH 高/低装入程序开关。当连接时，要判定为执行而装入的程序是在低的存储器地址（通常），
还是在高的存储器地址。值0000H指的是高的。否则，这个单元所包含的是必须驻留在被装入程序末端上的小段最大计数值。
0E-0FH在可执行模块中堆栈段的偏移地址。
10-11H把堆栈的大小定义为一个偏移值，当传送控制到可执行模块时，装入程序要把此偏移值插入SP。
12-13H检查和的值一在文件中，所有字的和（不考虑溢出）用作可能丢失数据的有效检查。
14-15H偏移值（通常是，但不必须是00H），它是在传送控制给可执行模块时，由装入程序插入IP寄存器的。
16-17H在可执行模块内的代码段的偏移值，由装入程序插入CS的。
该偏移值是相对于其他段的，因此如果代码段是第一个的话，偏移值将为零。
18-19H再定位表的偏移值（见1CH的项）。
1A-1BH覆盖数，其中零（通常是）的意思是.EXE文件包含主程序。
1CH-末端再定位表包含一个可变数的再定位项，如在偏移值06-07H处所指出的。
标题的位置06-07H指明在可执行模块中要被再定位的项目数。
起始于标题1CH的每个再定位项是由2字节的偏移值和2字节的段值组成的。
系统为环境与程序段构造存储块。以下是当装入与初始化.EXE程序时，装入程序的执行步骤：
读出标题的格式化部分进入存储器中。
计算可执行模块的大小（在位置04H处的总文件大小减去在位置08H处的标题的大小），
并在段的起点处把模块读入存储器中。
把再定位表项目读入工作区，并把每个项目的值加到起始段值上。
把DS与ES设置成PSP的段地址。
把SS设置成PSP的地址，加上100H（PSP的大小），加上SS偏移值（在0EH处）。
另外，设置SP为在10H内的值，这是堆栈的大小。
设置CS为PSP地址加100H（PSP的大小），把在标题（在16H处）中的CS偏移值加到CS上。
另外，用在14H处的偏移值设置IP。CS:IP对提供代码段的起始地址，实际上也是程序执行的起始地址。
在上述步骤之后，装入程序结束工作并丢弃.EXE标题。CS与SS是正确设置的，
但该程序必须为它自己的数据段设置DS与ES：
MOV AX,datasegname
MOV DS,AX
MOV ES,AX
23.5.3例：装人.EXE程序
考虑以下连接程序为一个EXE程序产生的连接映像：
开始                           停止                           长度                  名字                  类别
00000H                  0003AH                  003BH         CODESEG                  Code
00040H                  0005AH                  001BH         DATASEG                  Data
00060H                  0007FH                  0020H         STACK                        Stack
程序入口点在0000；0000
映象提供3个段中的每段的相对单元（不是实际的）。（某些系统用名字的字母顺序排列这些段。）
根据映象，代码段（CODESEG）是从00000H开始的一它的相对单元是可执行模块的起点，长度是003BH个字节。
数据段DATASEG是从00040H开始的，长度是001BH。00040H是跟在CODESEG之后定位于小段边界（边界可被10H除尽）
的第一个地址。堆栈段STACK从00060H开始，00060H是跟在DATASEG之后的定位于小段边界的第一个地址。
在程序为执行而被装入之后，DEBUG不能显示标题记录，这是因为装入程序用PSP取代了标题记录。
可以使用DEBUG的L命令从磁盘取一个扇区并用D命令把标题记录显示出米。例如，从CS：100开始，取自驱动器A:（0），
相对扇区3，以及一个扇区（512字节）：
L 100 0 3 1。
我们正检验的程序的标题包含以下相关信息，按十六进制单元（数字数据是按相反字节顺序排列的）表示如下：
00H 十六进制4D5A（“MZ”）。
02H最后一个块的字节数：5B00H（或005BH）。
04H包括标题的文件大小，以512字节的块表示：0200H（0002×512=1024个字节）。
06H跟在标题的格式化部分之后的再定位表的项目数：0100H（即 0001）。
08H标题的大小，以16字节增量：2000H（0020H=32，而32×16=512字节）。
0CH装入低端存储器：FFFFH。
0EH 堆栈段的偏移单元：6000H，或0060H。
10H插入SP的偏移值：2000H，或0020H。
14HIP的偏移值：0000H。
16HCS的偏移值：0000H。
18H再定位表的偏移值：1E00H，或001EH。
当DEBUG装入这一程序时，各寄存器所包含的值如下：
SP=0020 DS=138F ES=138F
SS=13A5 CS=139F IP=0000
对于.EXE模块，装入程序把DS与ES设置成PSP的地址，并把CS、IP、SS和SP设置成来自标题记录的值。
让我们看一下装入程序是如何初始化这些寄存器的。
1.CS:IP寄存器。依照DS寄存器，当程序被装入时，PSP的地址是138F[0]H。
因为PSP是100H字节长，并且代码段是第一个（在偏移值0处），所以代码段是在PSP后紧接着的139F[0]H处。
可以看一看在标题中单元16H处的偏移值，装入程序使用这些值去初始化CS：
PSP的开始地址（见DS）：138F0H
+
PSP的长度：                           100H
+
代码段的偏移值：                       0H
=
代码段的地址：                  139F0H
CS提供了程序代码部分（CODESEG）的起始地址可以使用DEBUG显示命令D CS：0000观察在存储器中的程序的机器码。
除了.LST标记为R的操作数之外，该代码和汇编程序的.LST打印输出的十六进制部分是一样的。
另外，把IP设置成0000H，是来自标题中14H处的偏移值。
2.SS:SP寄存器。装入程序使用在标题（0EH处）中的60H值来设置在SS中的堆栈地址：
PSP的开始地址（见DS）：138F0H 
+
PSP的长度：                           100H
+
堆栈的偏移值                            60H
（见标题中的0EH单元）
=
堆栈地址：                          13A50H
装入程序使用来自标题（在10H处）的20H初始化指向堆栈长度的堆栈指针。
在这个例子中，堆栈被定义为DW 16 DUP (?)，即16个2字节字段=32或20H。SP指向当前栈顶。
3.DS寄存器。装入程序用DS建立PSP的起点在138F[0]。由于标题不包含程序的DS段地址，所以程序必须初始化DS：
0004 B8----R MOV AX,DATASEG
0007 8E D8    MOV DS,AX
汇编程序保留下来未填入的DATASEG的机器地址已经变成标题中再定位表（从1EH处开始）的一个项。
装入程序计算DS地址如下：
CS地址：139F0H
+
数据段的偏移值：40H（见连接映象）
=
DS地址：13A30H
DEBUG显示完成的指令为B8 A313，装入程序把A313装入DS成为13A3。这些值在执行的起点是：
寄存器                  地址                  映象偏移值
CS                        139F[0]H          00H
DS                        13A3[0]H         40H
SS                         13A5[0]H         60H
作为练习，用DEBUG跟踪所连接的.EXE程序，并注意在寄存器中改变的值：
指令                  变化的寄存器
MOV AX,DATASEG   IP AX
MOV DS,AX   IP和DS
MOV ES,AX   IP和ES
DS现在包含数据段的正确地址。试一试使用D DS:0去观察数据段，并使用D SS:0观察堆栈。
23.6分配与释放存储器
INT 21H服务允许分配、释放存储器和修改一个存储区的大小。
你很可能会为常驻程序和为执行装入的其他程序而使用这些服务程序，因为DOS是被设计成单用户环境的，所以一
个程序为了执行而需要装入另一个程序时，必须释放它的一些存储空间。
23.6.1INT21H的功能48H：分配存储器
为了给程序分配存储器，需要功能48H，并且用所需要的小段数设置BX：
MOV AH,48H   ;请求分配存储器
MOV BX,paragraphs   ;小段数
INT 21H   ;调用中断服务
该操作是从第一个存储块开始的，并一步步地经过每块直到按照要求分配了足够大的容间，通常是在存储器的高端。
如操作成功则清除进位标志，并把所分配的存储块的段地址回送到AX中。
如操作不成功则设置进位标志，并把出错码（07=存储块被破坏或08=存储器不足）回送到AX中，
以及向BX回送以小段为单位的最大可用块的大小。
被破坏的存储块是指该操作找到的一个块，该块的第一个字节不是‘M’或‘Z’。
23.6.2INT21H的功能49H：释放已分配的存储器
功能49H释放已分配的存储器，通常用于释放常驻程序。在ES中装入要被返回块的段地址：
MOV AH,49H   ;请求释放已分配的存储器
MOV ES,seg-address   ;块地址（小段的）
INT 21H   ;调用中断服务
Expects: AH    49H
ES    segment address (paragraph) of allocated memory to release
Returns: AX    error code if CF is set to CY
成功的操作会清除进位标志，并在存储块的第二和第三个字节存放00H，意思是它不再使用。
不成功的操作要设置进位标志，并在AX中回送一个出错码（07=存储块被破坏，以及09H=无效的存储块地址）。
23.6.3INT21H的功能4AH：修改已分配的存储块
功能4AH可以增加或减少存储块的大小。用为程序保留的小段数初始化BX，并用PSP的地址初始化ES：
MOV AH,4AH   ;请求修改已分配的存储器
MOV BX,paragraphs   ;小段数
MOV ES,PSP-address   ;PSP的地址
INT 21H   ;调用中断服务
Expects: AH    4aH
ES    segment of an allocated memory block
BX    desired size for the block, in paragraphs (16-byte chunks)
Returns: AX    error code if CF is set to CY
BX    largest block available (if a "grow" request fails)
                                                                  
Info: Changes the size of an existing memory block.
When a program receives control, the 4bH EXEC function has
allocated a memory block starting at the PSP that contains all of
available memory.  To make memory available to EXEC a child
process, shrink the block starting at your PSP paragraph.
程序可以用从PSP的地址中减去最后段的末地址的方法来计算它本身的大小。
如果连接程序按字母顺序重新排列了段，那必须保证使用的是最后一个段。
成功的操作会清除进位标志。不成功的操作要设置进位标志，并在AX中回送一个出错码
（07=存储块被破坏，08=存储器不足，09=无效的存储块地址）。
在BX中，回送最大可能有的大小（如果试图增加大小已经完成的话）。
在ES中的不正确的地址可能造成07的错误。
23.7装入或执行程序功能
现在来探讨如何使得正在执行的程序去装入并执行一个子程序。
功能4BH使一个程序能为了执行而把子程序装入到存储器中。装入这些寄存器：
AL=下列之一的功能码：00H=装入并执行，01H=装入程序，03H=装入覆盖，05H=设置执行状态（本书不涉及）。
ES:BX=参数块的地址。
DS:DX=调用的子程序路径名的地址，是个大写字母的ASCIIZ串。
这里是装入子程序的指令：
MOV AH,4BH   ;请求装入子程序
MOV AL,code   ;功能码（只是装入）
LEA BX,para_block   ;参数块地址
LEA DX,path   ;路径名地址
INT 21H   ;调用中断服务
无效操作设置进位标志，并在AX中回送一个出错码，如同图17-1所说明的那样。
23.7.1AL=00H：装人并执行
这一操作把.EXE或.COM程序装入到存储器，为该程序建立一个程序段前缀，并传送控制给段前缀使它执行。
由于所有寄存器，包括SS都改变了，所以该操作不是针对初学者的。
按照ES:BX寻址的参数块具有以下格式：
偏移值         用途
00H 在PSP+2CH处传送过来的环境块段地址。零地址的意思是被装入的程序继承了原有的环境。
02H 放在PSP+80H处的命令行的双字指针。
06H 传送在PSP+5CH处的FCB#1的双字指针。
0AH 传送在PSP+6CH处的FCB#2的双字指针。
双字指针的形式是偏移值：段地址。
23.7.2AL=01H：装入程序
该操作把.EXE或.COM程序装入存储器，并为此程序建立程序段前缀，但不能传送控制使它执行。
按照ES:BX寻址的参数块有以下格式：
偏移值         用途
00H 在PSP+2CH处传送过来的环境块段地址。如果该地址为零，则被装入的程序继承了原有的环境。
02H 放在PSP+80H处的命令行的双字指针。
06H 传送在PSP+5CH处的FCB#1的双字指针。
0AH 传送在PSP+6CH处的FCB#2的双字指针。
0EH 起始段地址。
12H 起始代码段地址。
双字指针是按偏移值：段的形式来寻址的。
23.7.3AL=03H：装人覆盖
这一操作装入程序或代码块，但不建立PSP或者开始执行程序或块。
因此，所要求的程序可以被覆盖在已在存储器中的全部或一部分程序上。按照ES:BX寻址的参数块有以下格式：
Offset 00H字是被装入文件的段地址。
Offset 02H字用于映像的再定位因子。
出错时要设置进位标志，并在AX中回送一个出错码，已在图17-1中说明过。
Expects: AH    4aH
ES    segment of an allocated memory block
BX    desired size for the block, in paragraphs (16-byte chunks)
Returns: AX    error code if CF is set to CY
BX    largest block available (if a "grow" request fails)
MOV AH,4BH   ;请求装入子程序
MOV AL,code   ;功能码（只是装入）
LEA BX,para_block   ;参数块地址
LEA DX,path   ;路径名地址
INT 21H   ;调用中断服务
23.7.4程序：装入与执行
在图23-2中的程序请求系统对于指定驱动器执行DIR命令。
程序使用功能4AH把它的存储容量要求减少到实际小段大小。
程序使用简化段定义伪操作，并且汇编程序是按代码、数据和堆栈的顺序排列各段。
还要注意，在执行的起点，ES含有PSP的段地址。对于INT 21H的功能4AH中计算程序规模的步骤是：
1.把堆栈段的地址（最后一段）设置在BX中。
2.把堆栈的大小（以小段为单位）加到BX上。
3.从BX中减去PSP的段地址。
其他汇编程序可能按不同顺序排列各段，所以建议在执行这个程序之前先检查一下连接映像。
.MODEL SMALL
.STACK 64
.DATA
PARAREA LABEL BYTE
DW 0
DW OFFSET DIRCOM
DW @data
DW OFFSET FCB1
DW @data
DW OFFSET FCB2
DW @data
DIRCOM DB 11,' /C DIR C: ',0DH,0
FCB1 DB 16 DUP (0)
FCB2 DB 16 DUP (0)
PROGNAME DB 'C:\WINDOWS\system32\command.com',0
.CODE
A10MAIN PROC FAR
MOV AH,4AH
MOV BX,STACK
ADD BX,4
MOV CX,ES
SUB BX,CX
INT 21H
JC A20ERR
MOV AX,@data
MOV DS,AX
MOV ES,AX
MOV AH,4BH
MOV AL,00H
LEA BX,PARAREA
LEA DX,PROGNAME
INT 21H
JC A30ERR
MOV AL,00H
JMP A90XIT
A20ERR:MOV AL,01H
JMP A90XIT
A30ERR:MOV AL,02H
JMP A90XIT
A90XIT:MOV AH,4CH
INT 21H
A10MAIN ENDP
END A10MAIN
INT 21H的功能4BH在AL中具有代码00时，处理COMMAND.COM的装入与执行。
程序显示指定驱动器的目录项。
23.7.5INT21H的功能4DH：取子程序回送值
该操作取回最后一个子程序的回送值，这是该子程序由功能4CH或31H结束时所发送回来的。
这些回送值是：
AH包含子程序的结束方法，其中00H=正常结束，01H=用Ctrl+C结束，02=危急的设备出错，以及03H=由功能31H
（保留程序）结束。
AL包含来自子程序的回送值。
Expects: AX    4b03H
DS:DX address of an ASCIIZ  filespec of the program file to load
ES:BX address of an ExecOverlayRec
Returns: AX    error code if CF is set to CY
ExecParamRec
Offset Size Contents
+0      2  wStartSeg    segment to load the overlay (at offset 0)
+2      2  wReloFactor  Relocation factor
4               length of an ExecOverlayRec

wStartSeg  The segment address at which to load the overlay.  This memory
must be owned by the caller.

wReloFactor  The factor to be added to each segment reference on the load
module during segment fixup.  For .EXE-format overlays, this
is normally the same as wStartSeg.  For .COM files (binary
images that need no fixups), this should be 0.
23.8程序覆盖
图23-3中的程序像图23-2的程序一样，使用同样的服务（4BH），但这次是只把程序装入到存储器而不执行它。
该程序是由主程序A23CALLV和2个子程序A23SUB1和A23SUB2组成。A23CALLV包含以下这些段：
STACK SEGMENT PARA STACK 'Stack1'
DATASEG SEGMENT PARA 'Data1'
CODESEG SEGMENT PARA 'Code1'

EXTRN A23SUB1:FAR
SSEG SEGMENT PARA STACK 'Stack1'
DW 64 DUP (?)
SSEG ENDS
DSEG SEGMENT PARA 'Data1'
PARABLOK LABEL WORD
DW 0
DW 0
FILENAME DB 'D:\A23SUB2.EXE',0
ERRMSG1 DB 'Modify mem error'
ERRMSG2 DB 'Allocate error  '
ERRMSG3 DB 'Seg call error  '
DSEG ENDS
CSEG SEGMENT PARA 'Code1'
ASSUME CS:CSEG,DS:DSEG,SS:SSEG
A10MAIN PROC FAR
MOV AX,DSEG
MOV DS,AX
MOV AX,0003H
INT 10H
CALL FAR PTR A23SUB1
MOV AH,4AH
MOV BX,CS
MOV CX,OFFSET B90END
SHR CX,1
SHR CX,1
SHR CX,1
SHR CX,1
INC CX
ADD BX,CX
MOV CX,ES
SUB BX,CX
INT 21H
JC A20ERROR
MOV AX,DS
MOV ES,AX
MOV AH,48H
MOV BX,40
INT 21H
JC A30ERROR
MOV WORD PTR PARABLOK,AX
MOV AH,4BH
MOV AL,03H
LEA BX,PARABLOK
LEA DX,FILENAME
INT 21H
JC A50ERROR
MOV AX,WORD PTR PARABLOK
MOV WORD PTR PARABLOK+2,AX
MOV WORD PTR PARABLOK,0020H
LEA BX,PARABLOK
CALL DWORD PTR [BX]
JMP A90
A20ERROR:LEA BP,ERRMSG1
CALL B10DISPLY
JMP A90
A30ERROR:LEA BP,ERRMSG2
CALL B10DISPLY
JMP A90
A50ERROR:LEA BP,ERRMSG3
CALL B10DISPLY
JMP A90
A90:MOV AX,4C00H
INT 21H
A10MAIN ENDP
B10DISPLY PROC NEAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
MOV AX,DS
MOV ES,AX
MOV AX,1301H
MOV BX,001EH
MOV CX,16
MOV DX,1510H
INT 10H
POP DX
POP CX
POP BX
POP AX
RET
B10DISPLY ENDP
B90END:NOP
CSEG ENDS
END A10MAIN

DSEG SEGMENT PARA 'Data2'
SUBMSG DB 'Subprogram 1 reporting'
DSEG ENDS
CSEG SEGMENT PARA 'Code2'
ASSUME CS:CSEG,DS:DSEG
PUBLIC A23SUB1
A23SUB1 PROC FAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DS
PUSH ES
MOV AX,DSEG
MOV DS,AX
MOV ES,AX
MOV AX,1301H
MOV BX,001EH
LEA BP,SUBMSG
MOV CX,22
MOV DX,0810H
INT 10H
POP ES
POP DS
POP DX
POP CX
POP BX
POP AX
RET
A23SUB1 ENDP
CSEG ENDS
END

DSEG SEGMENT PARA 'Data'
SUBMSG DB 'Subprogram 2 reporting'
DSEG ENDS
CSEG SEGMENT PARA 'Code'
ASSUME CS:CSEG,DS:DSEG
A23SUB2 PROC FAR
PUSH AX
PUSH BX
PUSH CX
PUSH DX
PUSH DS
PUSH ES
MOV AX,CS
MOV DS,AX
MOV ES,AX
MOV AX,1301H
MOV BX,001EH
LEA BP,SUBMSG
MOV CX,22
MOV DX,1010H
INT 10H
POP ES
POP DS
POP DX
POP CX
POP BX
POP AX
RET
A23SUB2 ENDP
CSEG ENDS
END
A23SUB1是与A23CALLV一起被连接的，而且是被A23CALLV调用的。A23SUB1的段是：
DATASEG SEGMENT PARA 'Data2'
CODESEG SE:GMENT PARA 'Code2'
A23CALLV的段被连接在前面――这是它们的类别名不同的原因：'Data1'，'Data2'，'Code1'，'Code2'等等。
下面是A23CALLV+A23SUB1的连接映像：
开始                  停止                  长度                  名字                  类别
00000H         0007FH         00080H                  STACK         Stack1
00080H         000C2H         00043H                  DATASEG   Data1
000D0H         0015FH         00090H                  CODESEG   Code1
00160H         00175H         00016H                  DATASEG   Data2
00180H         0019DH         0001EH                  CODESEG   Code2
A23SUB2也是被A23CALLV调用的，但分别连接。A23SUB2的段是：
DATASEG SEGMENT PARA 'Data'
CODESEG SEGMENT PARA 'Code'
A23SUB2的连接映像看来是这样（和一个有关没有堆栈的警告在一起）：
开始                  停止                  长度                  名字                  类别
00000H         00015H         00016H                  DATASEG         Data
00020H         0003AH         0001BH                  CODESEG         Code
这个程序与图23-2的不一样，它包含常规的段伪操作，汇编程序保留其原来的顺序。因此代码段有最后的和最高的地址。
当装入程序为执行而把A23CALLV+A23SUB1传送到存储器中时，A23CALLV调用并以正常的方式执行A23SUB1。
远CALL正确地初始化CS、IP，但由于A23SUB1有它自己的数据段，所以它必须使A23CALLV的DS进栈，
并建立自己的DS地址。A23SUB1设置光标，显示信息，使DS出栈，并且返回到A23CALLV。
为了使A23SUB2覆盖在A23SUB1上，A23CALLV必须缩小其本身的存储空间，因为系统已经赋予其全部可用的存储器。
对于INT21H的功能4AH中计算程序大小的步骤是：
1.把代码段的段地址设置在BX中。
2.把代码段的大小（以小段计）加到BX上。
3.从BX中减去PSP的段地址。
然后，INT 21H的功能48H分配存储器提供把A23SUB2装入（覆盖）到A23SUB1顶上的空间，
任意地把它设置成40H个小段。该操作把装入地址回送到AX中，在那里A23CALLV把地址存入PARABLOK，
这是功能4BH所用参数块的第一个字。
功能4BH带有在AL中的代码03时，把A23SUB2装入存储器。注意在数据段中的定义：D:\A23SUB2.EXE,0。
功能4BH引用CS和PARABLOK――第一个字包含被装入并覆盖的段地址，第二个字是个偏移值，在这种情况下是零。
下面的图表有助于更清楚地理解这些步骤：
对于A23SUB2的远CALL要求定义为IP:CS的引用，但PARABLOK是用的CS:IP的形式。
因此CS的值被传送到第二个字，并为IP把20H存入第一个字，这是由于连接映像所表示的值是作为A23SUB2代码段的
偏移值的。下一条指令把PARABLOK的地址装入BX并调用A23SUB2：
LEA BX,PARABLOK
CALL DWORD PTR [BX]
注意，A23CALLV不按在其代码段中的名字引用A23SUB2，因而不需要EXTRN语句来指定A23SUB2。
由于A23SUB2有自己的数据段，所以它首先使DS进栈，并初始化自己的地址。
但是，A23SUB2不是和A23CALLV一起连接的。因此，指令MOV AX,DATASEG只能用DATASEG的偏移地址0[0]H来
设置AX，而不是段地址。我们知道CALL是用第一个段地址设置CS的，（根据连接映像）正好是数据段的地址，
所以把CS复制到DS给出了在DS中的正确地址。注意，如果A23SUB2的代码段与数据段是按不同顺序排列的，
那么相应的编码必须是相反的。
A23SUB2显示信息，使DS出栈，并返回到A23CALLV。
23.9常驻程席
许多程序被设计成在其他程序运行时是常驻在存储器中的，并可以通过一些专用的键击启动它们的服务功能。
在启动其他正常处理程序之前，要先装入常驻程序。它们几乎都是.COM程序并且还称为“结束但保留常驻”（TSR）程序。
编写常驻程序的容易部分是使它常驻。可以用INT21H的功能31H（保留程序）的办法使它退出，来代替正常的结束。
该操作要求把程序的大小放在DX中：
MOV AH,31H   ;请求TSR
MOV DX,prog-size   ;程序的大小
INT 21H   ;调用中断服务程序
当你执行初始化例行程序时，系统留出要常驻程序的存储块，并且是把其后的程序装入到存储器的较高端。
常驻程序不容易编写的部分包括在它常驻以后对它的启动，因为它不属于系统内部像CLS，COPY，以及DIR之类的那种程序。
通常的方法是修改中断向量表，使常驻程序中断所有键击，按指定的键击或组合进行动作，并且继续转到所有其他键击。
结果是，典型的（但不是必要的）常驻程序是由以下各部分组成：
1.重新定义中断向量表中的部分单元。
2.一个初始化过程只在第一次程序运行时执行，并实现以下操作：
用它自己的地址取代中断向量表中的地址，
确定要保留常驻的那部分程序的大小，
使用中断去通知系统结束执行当前程序，并把程序的指定部分保留在存储器中。
3.保留常驻的过程并被启动，例如作专门的键盘输入或定时器时钟那样的操作。
实际上，初始化过程建立了使常驻程序工作的所有条件，而后允许它自己被删除。
常驻程序可以使用2个INT21H功能来访问中断向量表，因为更先进的计算机会有定位于单元0000H为起点的，
表这一点是没有保证的。
23.9.1INT21H的功能35H：取中断向量
为了取回在中断向量表中的特殊中断的地址，用所要求的中断号装入AL：
MOV AH,35H   ;请求取向量
MOV AL,int#   ;中断号
INT 21H   ;调用中断服务
该操作把中断地址以段：偏移值的形式回送到ES:BX。
对于常规存储器，例如对INT 09H地址的请求，要把00H回送到ES，并把24H（36）回送到BX。
23.9.2INT21H的功能25H：设置中断向量
为了设置一个新的中断地址，在AL中装入所要求的中断号和在DX中装入新地址：
MOV AH,25日   ;请求设置中断向量
MOV AL,int#   ;中断号
LEA DX,newaddr   ;中断的新地址
INT 21H   ;调用中断服务
该操作使用一个新地址取代中断现在的地址。
但实际上，当指定的中断发生时，还是连接到常驻程序进行处理，而不是到正常的中断地址。
23.9.3常驻程序举例
在图23-4中的名为A23RESID的常驻程序在按ESC键时会发出嘟嘟声。
程序仅有的实际用途是用可能最简单的方法说明常驻程序的技术细节，使你能尝试其他类型较为有用的程序。
有关常驻程序的以下几点是有意义的：
CODESEG开始了A23RESID的代码段。第一条可执行指令JMP B10INIT越过常驻部分把执行传送到靠近末端的B10INIT。
这个例行程序首先使用CLI防止任何可能碰巧在此时发生的进一步中断。
然后使用INT21H的功能35H确定在中断向量表中的INT09H的地址。该操作把地址回送到ES:BX中，
B10INIT例行程序把它们存入SAVEINT9。接下来，功能25H把程序本身的地址设置到中断向量表的INT09H处，
这一地址即A10TEST，它是常驻程序的入口点。实际上，该程序保留INT09H的地址，并用该程序自己的地址取代它。
最后一步是确定常驻部分（直到B10INIT的全部代码）的大小放在DX中，并使用INT21H的功能31H
（结束但保留常驻）退出。从B10INIT到末端的代码被下一个为执行而装入的程序所覆盖。
Al0TEST是这个常驻过程的名字，在用户按键时被启动。系统把执行传送到在中断向量表中的INT09H的地址，
它已经修改成A10TEST的地址。因为可能碰巧遇上中断（例如当用户正在执行任何一类操作时），
所以A23RESID必须保存它使用的寄存器。程序访问键盘标志，以确定是否按了Esc键（扫描码01）。
如果是，程序就使扬声器发声（扬声器的使用在第24章的“发声”一节说明）。
最后的指令包括恢复进栈的寄存器（按相反的顺序）并转移到SAVEINT9，那里有原来的INT09H的地址。
现在控制被释放，返回到中断。
61H是8255口PB口的地址,8253定时器的控制端由PB1和PB0控制,PB0控制GATE,PB1控制扬声器的输出,只有当PB0和PB1为1的时候,由8253控制的扬声器才能发声。
定时器通道3的GATE端与61H端口的bit0位相连，如果把61H端口的bit0位置为1，那么定时器通道3就会被启动，若61H的端口bit0位为0，则定时器被关闭。
扬声器控制原理
8255的地址为：60H~63H;PB端口地址为61H,控制口为63H；
8253的地址为：40H~43H;通道2地址42H，控制口地址43H。
PC的扬声器以计数器2为核心。计数器8255的CLK2的输入频率为1.193182MHz，工作于方式3，改变计数器初值可以得到不同频率的方波输出。
CODESEG SEGMENT PARA
ASSUME CS:CODESEG
ORG 100H
BEGIN:JMP B10INIT
SAVEINT9 DD ?
DURATION DW 0100H
A10TEST:PUSH AX
PUSH CX
IN AL,60H
CMP AL,01H
JNE A50EXIT
IN AL,61H
PUSH AX
OR AL,00000011B
OUT 61H,AL
MOV CX,0512H
A20:LOOP A20
OR AL,00000010B
MOV CX,0512H
A30:LOOP A30
POP AX
AND AL,11111100B
OUT 61H,AL
A50EXIT:POP CX
POP AX
JMP DWORD PTR CS:SAVEINT9
B10INIT:CLI
MOV AH,35H
MOV AL,09H
MOV WORD PTR SAVEINT9,BX
MOV WORD PTR SAVEINT9+2,ES
MOV AH,25H
MOV AL,09H
MOV DX,OFFSET A10TEST
INT 21H
MOV AH,31H
MOV DX,OFFSET B10INIT
INT 21H
STI
CODESEG ENDS
END BEGIN
测试通过的完整程序如下
CSEG SEGMENT
ASSUME CS:CSEG,DS:CSEG
OLD09H DD ?
NEW09H_BEGIN:PUSH BP
MOV BP,SP
PUSH BX
IN AL,60H
PUSH AX
PUSHF
CALL DWORD PTR CS:[0]
PUSHF
POP BX
MOV WORD PTR SS:[BP+6],BX
STI
POP AX
CMP AL,01H
JNE NEW09H_OK
PUSH AX
PUSH CX
MOV AL,0B6H
OUT 43H,AL
MOV AL,2
OUT 42H,AL
MOV AL,34H
OUT 42H,AL
IN AL,61H
MOV AH,AL
OR AL,3
OUT 61H,AL
MOV CX,9000H
LOOP $
MOV AL,AH
OUT 61H,AL
POP CX
POP AX
NEW09H_OK:
POP BX
POP BP
IRET
START:PUSH CS
POP DS
CALL CLEARBUFKB
MOV AX,3509H
INT 21H
MOV WORD PTR OLD09H,BX
MOV WORD PTR OLD09H+2,ES
MOV DX,OFFSET NEW09H_BEGIN
MOV AX,2509H
INT 21H
MOV DX,OFFSET START
ADD DX,15
MOV CL,4
SHR DX,CL
ADD DX,10H
MOV AL,0
MOV AH,31H
INT 21H
CLEARBUFKB PROC
PUSH AX
CLEARBUFKB_S:MOV AH,1
INT 16H
JZ CLEARBUFKB_OK
MOV AH,0
INT 16H
JMP CLEARBUFKB_S
CLEARBUFKB_OK:POP AX
RET
CLEARBUFKB ENDP
CSEG ENDS
END START
下一个例子将有助于对过程的清楚了解。首先，这是一个没有TSR阻止中断的常规操作的说明：
1.用户按一个键，键盘发送INT09H给BIOS。
2.BIOS使用在中断向量表中INT09H的地址确定BIOS例行程序。
3.然后把控制传送给BIOS例行程序。
4.例行程序取得字符，并且如果是标准字符，就把它传送到键盘缓冲器。
下面是常驻程序的过程：
1.用户按一个键，并且键盘发送INT09H给BIOS。
2.BIOS使用在中断向量表中INT09H的地址确定BIOS例行程序。
3.但现在的表包含的是在常驻程序中的A10TEST的地址，要把控制传送给它。
4.如果字符是Esc，则程序使扬声器发声。
5.A10TSET用转移到原先保存的INT09H地址的办法退出，在那里把控制传送给BIOS例行程序。
6.BIOS例行程序取得字符，并且如果是一个标准字符，就把它传送到键盘缓冲器。
试试用DEBUG去检验这一程序的执行结果。使用D 0:20显示中断向量表在20H（36）处的内容，
其中存放的是INT09H的中断地址。第一个字是偏移值，而第二个字是段地址，它们都是按相反字节顺序存放的。
例如，如果存放的地址是07 01 EF 05，则使用D 05EF:0107去观察所存放地址的内容。
显示应该从5051 1EB8开始，那里是在常驻程序中A10TEST的机器码的起点。
某些程序还替换了INT09H的表地址，它们不允许像这个程序那样同时使用常驻程序。
23.10要点
连接程序产生的.EXE模块由包含控制与再定位信息的标题记录和实际装入的模块组成。
在装入.COM程序时，装入程序用PSP的地址设置段寄存器，把堆栈指针设置到该段的未端，使一个零字进栈，
设置指令指针为100H（PSP的大小）。然后，控制进行到由CS:IP产生的地址，即紧跟PSP的第一个单元。
在装入.EXE程序时，装入程序把标题记录读入到存储器中，计算可执行模块的大小，
以及把模块读入到存储器中的起始段处。装入程序把每个再定位表项目的值加到起始段的值上。
它把DS和ES设置成PSP的段地址：设置SS为PSP的地址加上100H，再加上SS偏移值；
设置SP为堆栈的大小，以及设置CS为PSP的地址加上100H，再加上在标题中的CS偏移值。
装入程序用在14H处的偏移值设置IP。CS:IP对提供代码段的起始地址用于程序的执行。
PSP的字段包括在5CH处的参数区1，在6CH处的参数区2，以及在80H处的默认磁盘传送区。
在启动其他正常处理的程序之前要装入常驻程序。用INT21H的功能31H退出，
这需要在DX中的程序的大小并留出程序常驻的存储块。
23.11习题
23-1.（a）系统把程序段前缀存放在什么地方？（b）它的大小是多少？
装入程序把.COM和.EXE程序装入到程序段中，并在段的偏移值00H处建立PSP，
而且在偏移值100H处建立程序本身。
256=100H字节
23-2.在程序段前缀中这些字段的用途是什么？（a）包含CD20H的第一个字节，（b）18-2BH，
默认的文件处理表，（c）2C-2DH，程序环境的段地址，（d）80-FFH，默认的DTA。
00-01H   INT 20H指令（CD20H）便于返回系统。
18-2BH   默认文件处理表。
2C-2DH   程序环境的段地址。
80-FFH   默认DTA（磁盘传输区）的缓冲区。

PSP18-2BH：默认文件处理表。在20字节的默认文件处理表中的每个字节指向系统表（它定义有关设备或驱动器）
的一个入口。最初，表包含0101010002FF...FF，其中第一个01指的是键盘，第二个01指的是屏幕，等等：
表项目                           处理设备
01         控制台                0 键盘（标准输入）
01         控制台                1 屏幕（标准输出）
01         控制台                2 屏幕（标准错误）
00         COM1                3 辅助的（串行口）
02         LPT1                  4 标准打印机
FF         未分配                5 未分配
通常，在PSP偏移值32H处的字包含表的长度（14H或20），偏移值34H包含了段地址，以IP:CS格式表示，
其中IP是18H（在PSP中的偏移值），CS是PSP的段地址。

PSP2C-2DH：环境的段地址。为执行而装入的程序有一个相应的环境，由系统放在存储器中，
从程序段前面的小段边界开始。默认大小是160字节，最大值是32KB。
环境包含这样一些系统命令，如COMSPEC，PATH，PROMPT和SET，它们是能适用于程序的。
PSP80-FFH：默认的DTA缓冲区。装入程序用在所要求的程序名（如MASM或COPY）之后键入的完整文本
（如果有的话）来初始化这个区域。第一个字节包含在程序名键入后紧接着按的键（如果有的话）数，
跟着该数的是被键入的字符（如果有的话），而后是来自前一个操作的、留在存储器中的任何无用单元。
23-3.为执行而被装入的一个.COM程序，它的PSP从单元3AB6[0]H开始。
程序的装入程序存放在以下每个寄存器中的地址是什么？（a）CS，（b）DS，（c）ES，（d）SS。
在装入.COM程序时，装入程序用PSP的第一个字节地址设置4个段寄存器。
把堆栈指针（SP）设置到64K段的末端，偏移值为FFFEH（或如果段不够大时，则设置到存储器的末端），
把指令指针（IP）设置到100H（PSP的大小）。
CS=DS=ES=SS=3AB6[0]H
23-4.一个EXE程序的连接映像表示如下：
开始                  停止                  长度                  名字                  类别
00000H         0004FH         00050H                STACK         STACK
00050H         0007BH         0002CH               CODESEG   CODE
00080H         000ACH         0002DH               DATASEG   DATA
装入程序装入该程序，其PSP从单元2AC6[0]H开始。表现出计算结果是适当的，请确定在装入时各寄存器的内容：
（a）SS，（b）SP，（c）CS，（d）DS，（e）ES。
2AC6[0]H
+
     100H
         0H
=
2AD6
SS=2AD6
SP=50H
CS=2AD6[0]+5[0]=2ADB[0]H
DS=ES=PSP的地址=2AC6[0]H
23-5.常驻程序通常阻止键盘输入。这个被阻止的地址正好是什么？在什么地方？
BIOS INT 09键盘中断向量，中断向量表段地址0000H，偏移36
23-6.以怎样有效的两种方法去为结束一个与普通程序有别的常驻程序进行编码？
用INT21H的功能31H（保留程序）的办法使它退出，来代替正常的结束。
典型的（但不是必要的）常驻程序是由以下各部分组成：
1.重新定义中断向量表中的部分单元。
2.一个初始化过程只在第一次程序运行时执行，并实现以下操作：
用它自己的地址取代中断向量表中的地址，
确定要保留常驻的那部分程序的大小，
使用中断去通知系统结束执行当前程序，并把程序的指定部分保留在存储器中。
3.保留常驻的过程并被启动，例如作专门的键盘输入或定时器时钟那样的操作。
第七部分参考章节
第24章BIOS数据区、中断和端口
24.1引言
24.2引导过程
24.3BIOS数据区
24.4中断服务
24.5BIOS中断
24.6INT21H服务例程
24.7端口
24.8串输入/输出
24.9产生声音
24.10要点
24.11习题
目的：描述BlOS数据区，中断服务和端口操作。
24.1引言
BIOS包含输入输出例行程序的扩展集以及系统设备状态表。
操作系统和用户程序都可以请求BlOS例程与系统连接的设备进行通信。
和BIOS接口的方法是调用软件中断。这一章介绍BIOS支持的数据区、中断程序和00H到1BH的BIOS中断、DOS中断21H
以及系统端口。
24.2引导过程
在PC机上，ROM驻留在FFFF0H开始的位置。开机后，处理器进入重置状态，设置所有的存储器单元为0，
对存储器执行奇偶校验，以及设置CS为FFFF[0]H，IP为0。所以第一步要执行的指令在FFFF：0，它指向BIOS的入口。
BIOS也在40[0]：72H存储了一个值1234H来通知后继操作Ctrl+Alt+Del（重启动）不执行加电自检。
BIOS检验各个端口来识别和初始化连接的设备，包括INT11H（确定设备）和INT12H（确定存储器大小）。
然后，在常规存储器的单元0开始，BIOS建立包含有中断例程地址的中断向量表。
紧接着，BIOS确定包含系统文件的磁盘是否存在，如果有，将执行INT19H存取第一个磁盘扇区，
该扇区含有引导程序加载程序。这个程序是一个临时的操作系统，在它加载存储器之后，BIOS例程把控制传递给操作系统。
引导程序只有一个任务：把操作系统的第一部分装入内存。
24.3BIOS数据区
BIOS 在段地址40[0]H开始的低地址存储器保留了白己的256字节（100H）的数据区，该
数据区包含有按反序字节排列的数据字段，它们按照偏移地址排列。
1.串行端口数据区
00H~07H4个字，4个串行端口COM1~COM4的地址。
2.并行端口数据区
08H~0FH4个字，4个并行端口LPT1~LPT4的地址。
3.系统设备数据区
10H~11H设备状态，已安装设备的状态的原始指示。可以调用INT11H，它在AX中返回下列信息：
位设备
15，14连接的并行端口数
11~9连接的RS232串行端口数
7，6软盘设备数，位为00=1，01=2，10-3，11=4
5，4初始化显示方式，位值为00=未用，01=40×25彩色，10=80×25彩色，11=80×25黑白。
2 指示设备（鼠标），1=已安装
1 1=数字协处理器已存在
0 1=软盘驱动器已存在
4.混合数据区
12H厂商的测试标志。
5.存储器大小数据区
13H~14H系统板上的内存总数（千字节）。
15H-16H扩展内存总数（千字节）。
6.键盘数据区
17H当前SHIFT状态的第一字节：
位                  动作                  位                  动作
7                  Insert激活         3                  Alt按下
6                  CapsLock激活  2                  Ctrl按下
5                  NumLock激活  1                  左shift按下
4                  ScrollLock激活  0                 右shift按下
“激活”表示键已经按下和设置。“按下”表示在BIOS存储状态时键已被按下。
18H当前SHIFT状态的第二字节：
位                  动作                  位                  动作
7                  Insert按下         3                  hold/pause状态
6                  CapsLock按下  2                  SysReq按下
5                  NumLock按下  1                  左Alt按下
4                  ScrollLock按下  0                  左Ctrl按下
19H ASCII字符的交替键盘入口。
1AH~1BH键盘缓冲区的头指针。
1CH~1DH键盘缓冲区的尾指针。
1EH~3DH键盘缓冲区（32字节）。
7.软盘驱动器数据区
3EH磁盘搜索状态。位0对应驱动器A，1为驱动器B，2为驱动器C，3为驱动器D。
A位值为0表示下一次搜索将重新定位于柱面0，以重新校准驱动器。
3FH磁盘电机状态。若位7=1，则程序正在执行写操作。位0对应驱动器A，1为B，2为C，3为D。
40H电机超时计数，直到电机关闭
41H磁盘状态，指出上次软盘驱动器操作的错误：
00H         无错误                  09H         试图使DMA超过64K限制
01H         无效磁盘参数       0CH         未找到媒体类型
02H         未找到地址标志   10H         读时CRC出错
03H         写保护错               20H         控制器错
04H         未找到扇区         40H         搜索失败
06H         软盘改变线激活   80H         驱动器未准备好
08H         DMA过速
42H~48H软盘驱动控制器状态。
8.视频数据区
49H当前显示方式，由1位来指示：
位                  方式                  位                  方式
7                  单色                  3                  80×25彩色
6           640×200单色         2                  80×25单色
5           320×200单色         1                  40×25彩色
4           320×200彩色         0                  40×25单色
4AH~4BH屏幕上的列数。
4CH~4DH显示页缓冲区的大小。
4EH~4FH显示缓冲区的起始偏移地址，
50H~5FH8个字，8页（0-7）中的每一页的当前开始位置。
60H~61H光标开始和结束行。
62H当前显示页。
63H~64H当前显示的端口地址（单色为03B4H，彩色为03D4H）。
65H显示方式控制寄存器的当前设置。
66H当前彩色调色板。
9.系统数据区
67H~68H数据边界时间计数。
69H~6AH循环冗余校验（CRC）寄存器。
6BH最后输入值。
6CH~6FH定时器，用反序字节计时。每秒更新18.2次（约55毫秒1次）。将定时器的值除以18.2即是从午夜开始的秒数。
70H定时器溢出（若计时器超过午夜，则为1）。
71HCtrl+Break键设置位7为1，
72H~73H内存重置标志，如果内容是1234H，按下Ctrl+Alt+Del则重启。
10.硬盘数据区
74H最后一个硬盘操作的状态（详见第19章）。
75H连接的硬盘数。
11.超时数据区
78H~7BH并行端口超时（LPT1~LPT4）。
7CH-7FH串行端口超时（COM1~COM4）。
12.键盘数据区
80H~81H键盘缓冲区开始的偏移地址。
82H~83H键盘缓冲区结束的偏移地址。
13.视频数据区
84H屏幕的行数。
85H~86H字符高度，以扫描行计。
87H视频信息，按位表示：
位0=1，光标能以文本方式模拟
位3=1，视频子系统未激活
位6~5，视频存储器容量（11=256K或更多）
位7，与传递到INT10H的功能00的显示方式码的第7位相同
88H混合视频信息。
89H混合标志，按位表示：
位0=1，表示VGA是激活的
位1=1，表示允许灰度求和
位2=0，表示彩色监视器，=1表示单色监视器
位3=1，表示禁止加载默认调色板
位4和7为文本方式定义扫描行
位4         位7         模式
0         0         350行
0         1         400行
1         0         200行
14.软盘/硬盘数据区
8BH-95H控制器和错误状态。
15.键盘数据区
96H键盘方式状态和键入标志：
位                  动作                  位                  动作
7                  顺次读ID         3                  右Alt按下
6         最后的代码是ACK   2                  右Ctrl按下
5         如果读ID和KBX强制NumLock   1         最后的扫描码是E0
4         安装扩展键盘         0                  最后的扫描码是E1
97H键盘LED标志（位0=ScrollLock，位1=NumLock，位2=CapsLock）。
16.实时钟数据区
98H~A7H等待标志的状态。
17.保存指针数据区
A8H-ABH指向BIOS存储区的指针。第一个地址（偏移量：段）指向视频保存指针表。
18.混合数据区
ACH~FFH系统保留，为内部使用。
下列BIOS区域在高地址内存区：
A0000~AFFFF 视频显示图形缓冲区
B0000~B0FFF 单色视频缓冲区
B8000~B0FA0 彩色文本视频缓冲区
F0000~FFFFF ROM BIOS信息区
24.4中断服务
中断操作使一个执行程序挂起，这样系统就能采取一些特定的动作。
执行中断例程，通常返回控制给被中断的程序，使其继续执行。
BIOS处理INT00H~1FH，DOS处理INT20H~3FH。
24.4.1中断向量表
当计算机加电后，系统在常规内存000H~3FFH位置建立中断向量表。
表中提供了256（100H）种中断，每种中断与相关的4字节地址以IP:CS的形式表示偏移量：段。
中断指令的操作数，如INT05H，标识了请求的类型。因为有256项，每一项长度为4字节，
所以中断向量表占据了存储器开始的1024个字节，从00H到3FFH。
表中的每个地址与一个特定中断类型的BIOS或者DOS例程相关。
因此字节0~3含有中断0的地址，4~7含有中断1的地址，以此类推。下面列出了一些中断操作：
中断操作                           中断操作
0         除数为0                  14H         串行端口中断
1         单步处理                 16H         键盘中断
2         非屏蔽中断（NMI）17H         打印机中断
3         断点地址                  19H         引导程序加载器
4         溢出                        1AH         时钟
5         打印屏幕                 1B         键盘break 控制
8         定时器间隔             1C         定时器中断控制
9         BIOS键盘中断         1D         视频表地址
0E       磁盘中断                  1E         磁盘表地址
10         视频中断               1F         ASCII字符地址
11         设备检验               21H      DOS中断
12         内存检验            33H         鼠标中断
13H      磁盘I/O
24.4.2执行中断
中断将Flags寄存器、CS和IP的内容压入堆栈。
例如，按下Ctrl+PrintScrn使BIOS调用INT05H的向量表地址，这个地址是0014H（05H×4=14H）。
操作从0014H位置开始取4个字节地址，并在IP中存放2个字节，在CS中存放2个字节。
CS:IP中的地址指向BIOS区中一个例程的开始，此例程是打印视频显示区。
中断通过IRET指令返回，从堆栈弹出IP、CS和Flags，并将控制返回给INT之后的指令。
外部和内部中断。外部中断是由处理器外部的设备引起的。能传输外部中断信号的两条线路是非屏蔽中断（NMI）线和
中断请求（INTR）线。NMI线报告内存和I/O奇偶错。即使使用CLI清零中断标志试图屏蔽外部中断，
处理器也总是响应这种中断。INTR线报告来自外部设备的请求，也就是中断05H~0FH，
对应定时器、键盘、串行端口、固定磁盘、软盘驱动器和并行端口。
内部中断是由于执行一条INT指令或发生溢出的除操作、以单步方式执行或请求外部中断（如磁盘I/O）的结果。
程序经常使用非屏蔽的内部中断来访问BIOS和DOS例程。
24.5BIOS中断
这一节包括00H到1BH的BIOS中断。其他没有包括在内的操作只能由BIOS执行。
INT00H：除数为0。由试图除零的操作调用，显示一个信息，通常将系统挂起。
INT 01H：单步。由DEBUG和其他调试器使用，可以在程序执行过程中单步调试。
INT02H：非屏蔽中断（NM1）。在硬件出现严重错误的情况下使用，如奇偶错，它总是能产生中断。
使用CLI指令（清除中断标志）不影响中断产生的条件。
INT03H：断点。用于调试器来停止程序的执行。
DEBUG中的Go和Proceed命令在程序中设定的断点处设置这一中断。
DEBUG取消单步方式，并且允许程序正常执行一直到INT03H，随后DEBUG又重置成单步方式。
INT04H：溢出。可能由运算操作引起，通常并不采取什么动作。
INT 05H：打印屏幕。打印视频显示区的内容。使用INT05H从内部激活中断，使用Ctrl+PrintScrn在外部激活中断。
操作可以被打断，并保存光标位置，没有寄存器受影响。在BIOS数据区的50：00地址包含这一操作的状态。
INT 08H：系统定时器。调整系统时间和日期（如果必要）的硬件中断。
可编程定时器芯片每54.9254毫秒产生一次中断，大约为一秒18.2次。
INT09H：键盘中断。是由按下或放开键盘上的一个键产生的，详见第10章。
INT 0BH，INT 0CH：串行设备控制。分别控制COM1和COM2端口。
INT 0DH，INT 0FH：并行设备控制。分别控制LPT2和LPT1端口。
INT 0EH：软盘控制。用信号表示磁盘的动作，如完成一个I/O操作。
INT10H：视频显示。在AH中接收一个功能号，表示屏幕方式，设置光标、滚动和显示，详见第9章中的描述。
INT11H：确定设备。确定系统中的可选择设备，将BlOS中40：10H的值返回给AX
（在启动时，系统执行此操作并且在40：10H中保存AX，详见前节“BIOS数据区”）。
INT12H：确定内存大小。在AX中返回基本内存的大小，以连续的KB统计。
INT13H：磁盘I/O。接收AH中的功能号，分别表示磁盘状态、读扇区、写扇区、检验、格式化和得到诊断，
第19章包括这些内容。
INT14H：输入/输出通信。提供I/O位数据流（即每次一位）给RS232串行端口。
DX应该包含RS232端口的代码（0~3分别对应COM1、2、3和4）。通过AH寄存器确定功能号。
功能00H：初始化通信端口。在AL中设置下列参数，按位号表示：
位/秒                  奇偶                  终止位                  字长
7~5                  4~3                  2                           1-0
100=1200         00=无                  0=1                  10=7位
101=2400         01=奇                  1=2                  11=8位
110=4800         10=无
111=9600         11=偶
下面例子中，设置COM1每秒1200位，无奇偶校验，一位终止位和数据长度8位：
MOV AH,00H   ;请求初始化端口
MOV AL,11100011B   ;参数
MOV DX,0   ;COM1串行端口
INT 14H   ;调用中断服务
操作在AX中返回通信端口状态（详见功能03H）。
功能01H：传送字符。在AL中装入要传送的字符，DX中为端口号。
返回时，操作在AH中设置端口状态（参见功能03H）。
如果操作不能传送字节，也要设置AH的第7位，这一位一般是用来报告超时错误。在使用此服务之前执行功能00H。
功能02H：接收字符。在DX中装入端口号。操作从通信线上接收一个字符送到AL。
同时在AH中设置端口状态（参见功能03），表示错误的位为7、4、3、2、1，
因此在AX中的非零值表示一个输入错误。在使用此服务前执行功能00H。
功能03H：返回通信端口状态。在DX中装入端口号。操作在AH中返回线状态（从端口03FDH），
AL中返回调制解调器状态（从端口03FEH）：
AH（线状态）                  AL（调制解调器状态）
7         超时                  7         接收线信号检测
6         传输移位寄存器空         6         环指示器
5         传输保持寄存器空         5         数据设置就绪
4         发现Break错                  4         发送清零
3         组帧错                           3         改变接收线信号检测
2         奇偶错                           2         环检测器的变化
1         过载错                           1         数据设置就绪的变化
0         数据就绪                        0         清除发送的变化
其他INT14H功能是04H（扩展初始化）和05H（扩展通信端口控制）。
因为INT14H限制在9600bps，适合于做传输数据的实验。
一个快速但更复杂的方法是通过INS和OUTS操作直接发送到端口地址，更进一步的讨论超过了本书的范围。
INT15H：系统服务。这个精心设计的操作在AH中提供了相当多的功能，包括：
21H         加电自检         88H         确定扩展内存大小
43H         读系统状态         89H         处理器转换为保护模式
84H         操纵杆支持         C2H         鼠标接口
INT16H：键盘中断。在AH中接收基本键盘输入的功能号，参见第10章。
INT 17H：打印机输出。通过BIOS提供一些打印功能，参见第20章中所讨论的。
INT18H:ROM 基本入口。如果系统没有包含系统引导程序的磁盘，启动时调用 BIOS。
INT 19H：引导程序加载器。如果一个装有操作系统程序的磁盘（包括软盘）设备是可用的，
则将磁道0，扇区1读入内存中引导程序的单元7C00H，并将控制传递到这一单元。
这一操作可以当作软件中断使用，它不清除屏幕，也不初始化ROMBIOS中的数据。
INT1AH：读取和设置时间。根据AH中的功能码读或者设置日时钟：
00H=读系统定时器时钟。在CX中返回计数的高位部分，在DX中返回低位部分。
如果自从上一次读取已经超过了24个小时，操作在AL中设置一个非零值。
01H=设置系统定时器时钟。在CX中装入计数的高位部分，DX中装入低位部分。
02H~07H。这些功能为实时钟服务处理时间和日期。
要确定一个程序执行了多长时间，可以先设置时钟为零，然后在程序结束时读取时间。
INT IBH：键盘Break控制。当按下Ctrl+Break时，使ROMBIOS传递控制到它的中断地址，这里要设置一个标志。
24.6INT21H服务例程
下面是与本书有关的DOSINT21H服务例程，所需的功能码在AH中。
01H：键盘输入有回显（见第10章）。
02H：显示字符（见第8章）。
03H：通信输入。从串行端口读一个字符到AL，更多的是使用一个基本服务例程 BIOS INT14H。
04H：通信输出。DL包含要传送的字符，更多使用的是BIOS INT14H。
05H：打印机输出。打印单个字符：
MOV AH,05H   ;请求打印
MOV DL,char   ;单个字符
INT 21H
06H：直接键盘输入和显示输出。
这是一个很奇特的操作，它可以传送任何字符或者控制码。
有两个版本，一个是有关键盘输入的，一个是有关屏幕输出的。
对于输入，在DL中装入0FFH。如果在键盘缓冲区里没有字符，操作设置ZF，并且不等待输入。
如果缓冲区里有字符，操作将字符装入AL，并清零ZF。此操作不在屏幕回显字符，
也不检查Ctrl+Break和Ctrl+Printscrn.。AL中的非0值表示是一个标准的ASCIl字符，如字母或数字。
AL为0说明用户按下了一个扩展功能键，如Home、F1或PageUp。
为了得到AL中的描码，要立即重复调用INT21H操作。对于屏幕输出，在DL中装入ASCII字符（不是0FFH）。
07H：直接键盘输入，不回显（见第11章）。
08H：键盘输入，不回显（见第10章）。
09H：显示字符串（见第8章）。
0AH：有缓冲的键盘输入（见第10章）。
0BH：检验键盘状态（见第10章）。
0CH：清除键盘缓冲区并调用输入功能（见第10章）。
0DH：重置磁盘驱动器（见第18章）。
0EH：选择默认磁盘驱动器（见第18章）。
19H：确定默认磁盘驱动器（见第18章）。
1AH：设置磁盘传输区（DTA）（见第18章）。
1FH：得到默认驱动器参数块（见第18章）。
25H：设置中断向量。当用户按下Crl+Break 或者Ctrl+C时，正常的过程是终止程序并返同操作系统。
可以让程序提供自己的例程来处理这一情况，下面的例子使用功能25H来设置它自己的Ctrl+Break处理程序
C10BREAK在中断向量表中的地址(INT23H），这个例程可以采取任何必要的动作。
MOV AH,25H
MOV AL,23H
LEA DX,C10BREAK
INT 21H
...
C10BREAK:
...
;Ctrl+Break处理程序
...
IRET
29H：解析文件名（见第18章）。
2AH：获取系统日期。返回下列二进制值：AL=星期（星期日=0）；CX=年（1980-2099）：
DH=月（01~12）：DL=日（01～31）。
2BH：设置系统日期。加载下列二进制值：CX=年（1980-2099）；DH=月（01～12）；
DL=日（01~31）。返回时，AL指示有效操作（00H）或无效操作（FFH）。
2CH：获取系统时间。返回下列二进制值：CH=小时，24小时的形式（00-23，午夜为00）；
CL=分（00-59）；DH=秒（00~59）；DL=百分之秒（00~99）。
2DH：设置系统时间。加载下列二进制值：CH=小时，24小时的形式（00～23，午夜为00）；
CL=分（00-59）；DH=秒（00~59）；DL=百分之一秒（00~99）。
返回时，AL指示有效操作（00H）或无效操作（FFH）。
2EH：设置/重置磁盘验证（见第18章）。
2FH：获取当前磁盘传输区的地址（DTA）（见第18章）。
31H：终止但保持驻留（见第23章）。
32H：获取磁盘参数块（DPB）（见第18章）。
3300H：获得Ctrl+C状态。如果Ctrl+C标志为关闭（0），导致系统只在处理字符I/O功能01H~0CH时检验Ctrl+C。
如果标志为开启（1），系统在处理其他功能时检验Ctrl+C。
为了得到状态，在AL中设置子功能00H。在DL中的返回值为00H=不能检验，01H=能检验。
3301H：设置Ctrl+C状态。如果Ctrl+C标志为关闭（0），导致系统只在处理字符I/O功能01H~0CH时检查Ctrl+C。
如果标志为开启（1），系统在处理其他功能时检验Ctrl+C。
为了设置状态，在AL中设置子功能01H，在DL中装入状态为00H=设置检验关闭，01H=设置检验开启。
3305H：获得启动驱动器。在DL中返回用来加载系统文件的驱动器号（1=A，等等）。
3306H：获取DOS信息。返回如下值：
BL=主版本号，如版本n.11中的n。
BH=次级版本号，如版本n.11的BH（11）。
DL=位2~0为修订号。
DH=DOS版本标志（指示系统是否在常规存储器，高地址存储器区或ROM中运行）。
尽管命令SETVER可以设置版本号，但功能3306H传送的是真实的版本号。
35H：获取中断向量表的地址（见第23章）。
36H：获取空闲磁盘空间（见第18章）。
38H：获取/设置相关国家的信息。支持关于各个国家的信息的功能，如国家货币的符号和版式，
千位和小数位的分隔符，日期和时间分隔符。
在DX装入操作码：FFFFH为设置系统一直使用的国家码，直到进一步的说明，或者装入其他当前使用的国家代码。
39H：创建子目录（MKDIR）（见第18章）。
3AH：删除子目录（RMDR）（见第18章）。
3BH：改变当前目录（CHDIR）（见第18章）。
3CH：创建文件（见第17章）。
3DH：打开文件（见第17章）。
3EH：关闭文件（见第17章）。
3FH：读文件/设备（见第17章）。
40H：使用文件代号写文件/设备（见第8、17和20章。）
41H：从目录中删除文件（见第18章）。
42H：移动文件指针（见第17章）。
43H：检查/改变文件属性（见第18章）。
44H：设备的I/O控制。支持检查设备和读写数据的扩展子功能集（见第23章）。
45H：复制文件代号（见第18章）。
46H：强制复制文件代号（见第18章）。
47H：获取当前目录（见第18章）。
48H：分配内存块（见第23章）。
49H：自由分配内存块（见第23章）。
4AH：设置分配的内存块大小（见第23章）。
4BH：加载/执行一个程序（见第23章）。
4CH：终止程序。程序执行结束的标准操作（见第4章）。
4DH：取子程序回送值（见第23章）。
4EH：寻找到第一个匹配的目录入口项（见第18章）。
4FH：寻找到下一个匹配的目录入口项（见第18章）。
50H：设置程序段前缀地址（PSP）。在BX中加载当前程序PSP地址的偏移量，没有返回值。
51H：获得程序段前缀地址（PSP）。返问当前程序PSP地址的偏移量（见第23章）。
54H：获得检验状态（见第18章）。
56H：重命名文件（见第18章）。
57H：获取/设置文件日期和时间（见第18章）。
5800H：获得内存分配策略（见第24章）。
5801H：设置内存分配策略（见第24章）。
5802H：取得上部存储器连接（见第23章）。
5803H：设置上部存储器连接（见第23章）。
59H：获取扩展错误码（见第18章）。
5AH：创建临时文件（见第18章）。
5BH：创建新文件（见第18章）。
5DH：设置扩展错误。在DX中加载错误信息表的偏移地址。
紧接着执行功能59H（获得扩展错误码）重新得到表地址（见第23章）。
62H：获得PSP地址。（和功能51H相同的操作。）
65H：获得扩展国家信息。支持一系列关于各个国家信息的子功能。
67H：设置最大文件代号计数（见第23章）。
68H：提交文件（见第18章）。
6CH：扩展打开文件。和功能3CH（创建文件），3DH（打开文件）和5BH（创建不重名文件）一起使用（见第18章）。
24.7端口
端口是连接处理器和外部世界的设备。通过端口，处理器可以从输入设备接收信号，也可以输出信号到输出设备。
端口是根据其地址来识别的，端口地址的范围为0H~3FFH，共有1024个端口。
要注意的是，这些地址不是传统的存储器地址。
下面列出了一些主要的端口地址：
020H-021H可编程中断控制器端口。对外部中断做出响应，如键盘、磁盘驱动器和系统时钟等外部设备。
来自这些设备的请求中断处理器的当前工作并要求它按请求动作。这些端口是：
20H8259端口地址，当操作发送20H到端口时，它发出中断结束（EOI）信号。
21H8259中断屏蔽寄存器，表明中断允许（0）或者中断禁止（1）。各位和IRQ表示的设备相同：
IRQ 0   系统定时器         IRQ   4   串行端口（COM1）
      1   键盘                              5   并行端口（LPT2）
      2   二级I/O通道                  6   软盘控制器
      3   串行端口（COM2）      7   并行端口（LPT1）
40H-42H8253可编程时间间隔定时器端口。包含3个端口，其处理功能如下：
40H 通道0计数寄存器，每秒中断系统18.2次（每55毫秒计数1次，计算值为0-65535）并更新系统时钟。
41H 通道1，中断直接存储器访问（DMA）控制器以刷新内存（RAM芯片保留数据只有几毫秒）。
42H 通道2，控制与端口61H相连的扬声器。
060H 键盘。处理键盘扫描码。
061H 8255接口通道的端口，下列位为0值时有如下处理功能：
位0   8253时间间隔定时器（端口42H）时钟无效
位1   扬声器无效
位4   RAM奇偶错有效
位6   键盘声音关闭
位7   键盘有效
200H~20FH游戏控制器
278H~27FH并行打印机端口（LPT3）
2F8H-2FFH串行端口（COM2）
378H~37FH并行打印机端口（LPT2）
3B0H～3BBH单色显示端口
3BCH~3BFH并行打印机端口（LPT1）
3C0H~3CFHVGA端口
3DAH-3DFH VGA彩色CRT状态寄存器（只读）
3F0H~3F7H磁盘控制器
3F8H~3FFH串行端口（COM1）
尽管标准输入输出操作使用INT操作，但访问端口21H、40~42H、60H、61H和201H时，避开BIOS是安全的。
例如，引导ROMBIOS程序时，扫描系统的串行和并行端口地址。如果找到端口地址，
BIOS将串行端口地址放在从内存单元40：00H开始的数据区，并行端口的地址放在从单元40：08H开始的数据区。
每个区有4个字入口项。BIOS系统表有2个串行端口和2个并行端口，如下所示：
40：00 F803 COM1
40：02 F802 COM2
40：04 0000 未用
40：06 0000 未用
40：08 7803 LPT1
40：0A 7802 LPT2
40：0C 0000 未用
40：0E 0000 未用
例如，使用BIOS INT17H打印一个字符，在DX中插入打印机端口号：
MOV AH,00H   ;请求打印
MOV AL,char   ;打印的字符
MOV DX,0   ;打印机端口0=LPT1
INT 17H   ;调用中断服务
一些程序只允许使用LPT1打印，如果系统装有LPT1和LPT2两个打印端口，
通过下面的程序可以交换（反转触发）它们在BIOS表中的地址。
BIOSDATA定义BIOS数据区，PARLPORT定义第一个4字大小的端口地址。
BIOSDATA SEGMENT AT 40H
ORG 08H
PARLPORT DW 4 DUP (?)
BIOSDATA ENDS
...
ASSUME DS:BIOSDATA
MOV AX,BIOSDATA
MOV DS,AX
MOV AX,PARLPORT[0]
MOV BX,PARLPORT[2]
MOV PARLPORT[0],BX
MOV PARLPORT[2],AX
...
24.7.1IN和OUT指令
IN和OUT指令可以在端口级直接处理/O。IN从一个输入端口传递数据给AL（字节）或AX（字），
而OUT将AL（字节）或AX（字）中的数据传递到一个输出端口。格式如下：
[label:] IN AL/AX，端口
[label:] OUT 端口,AL/AX
可以静态或动态地指定端口地址。
静态。直接使用0~255的一个操作数：
输入IN AL,port#   ;从端口输入一个字节
输出OUT port#,AX   ;输出一个字到端口
动态。间接使用DX中0-65535的内容，可以使用这个方法通过DX加1连续地处理端口地址。使用端口60H的例子如下：
MOV DX,60H   ;端口60H（键盘）
IN AL,DX   ;从端口得到字符
24.7.2随机数发生器
下面的程序段可以利用8253时间间隔定时器产生随机数：
MOV AX,0
OUT 43H,AL
IN AL,40H
IN AL,40H
现在随机数应当在AL中。
8254是8253的更新产品，主要功能基本一样，只是8254芯片加了回读命令。
8254芯片的IO端口地址范围是0x40~0x43。其中0x40~0x42分别对应计数器通道0~2，0x43对应控制字寄存器写端口。
通过向8253写入一个控制字和一个初始计数值，我们就可以对想要使用的一个计数器进行编程。
控制字的内容会指定正在编程的计数器通道，当控制字写完后，就可以向某个通道写入初始计数值。
初始计数值必须根据控制字中设定的格式写入（二进制或BCD码格式）。
7         6         5         4               3         2         1         0
00 计数器0  00 计数器锁存命令  000 方式0              0 二进制
01 计数器1  01 只读写低字节      001 方式1              1 十进制
10 计数器2  10 只读写高字节      x10 方式2
11 非法        11 先读写低字节     x11  方式3
                         后读写高字节     100  方式4
                                                   101 方式5
61H是8255口PB口的地址,8253定时器的控制端由PB1和PB0控制,PB0控制GATE,PB1控制扬声器的输出,只有当PB0和PB1为1的时候,由8253控制的扬声器才能发声。
定时器通道3的GATE端与61H端口的bit0位相连，如果把61H端口的bit0位置为1，那么定时器通道3就会被启动，若61H的端口bit0位为0，则定时器被关闭。
扬声器控制原理
8255的地址为：60H~63H;PB端口地址为61H,控制口为63H；
8253的地址为：40H~43H;通道2地址42H，控制口地址43H。
PC的扬声器以计数器2为核心。计数器8255的CLK2的输入频率为1.193182MHz，工作于方式3，改变计数器初值可以得到不同频率的方波输出。
24.8串输入/输出
INSn和OUTSn串指令也可以传输数据，它们的工作很像第11章介绍的串指令：
INSn指令。INSn指令的操作如下：
指令示例
INS（80286+）INS ES:destination,DX
INSB（80286+）REP INSB
INSW（80286+）REP INSW
INSD（80386+）REP INSD
接收的数据（或目的文件）是通过ES:DI寻址的“串”，DX中包含输入端口的地址。通
常使用INSn要带REP前缀，CX包含要接收的项（字节、字或双字）数。
如果方向标志（DF）为0，DI根据每个接收到的项的大小增量，如果DF为1，DI减量。
下例说明INSn操作：
MOV CX,no_bytes   ;字节数
LEA DI,destination   ;目的串（ES:DI）
MOV DX,port-no   ;从端口
REP INSB   ;接收字节
OUTSn指令.OUTSn指令的操作如下：
指令示例
OUTS（80286+）OUTS DX,DS:source
OUTSB（80286+）REP OUTSB
OUTSW（80286+）REP OUTSW
OUTSD（80386+）REP OUTSD
发送的数据（或源）是通过DS:SI寻址的串，DX中包含输出端口的地址。通常使用带有REP前缀的OUTSn指令，
CX中含有要发送的项（字节、字或双字）数。
如果方向标志（DF）为0，Sl根据每个接收到的项的大小增量，如果DF为1，SI减量。
下例说明OUTSn操作：
MOV CX,no_bytes   ;字节数
LEA SI,source   ;源串（DS:SI）
MOV DX,port-no   ;从端口
REP OUTSB   ;发送字节
24.9产生声音
PC机通过内置的永久磁铁扬声器产生声音，扬声器和端口42H、43H和61H连接。扬声器发声的操作步骤如下：
1.得到端口61H的状态，并保存。
2.为了打开扬声器，发送在位0和1中的位串11到端口61H。端口激活Intel 8255可编程外围接口（PPI）芯片。
3.为了关闭扬声器，发送在位0和1中的位串00到端口61H。
图24-1中的部分程序按照升序产生一系列音符。DURATION提供了每个音符的长度，TONE确定了频率。
程序开始访问端口61H，并保存操作传送的值。时间间隔定时器产生时钟“嘀答”，每秒18.2次“嘀答”，
每次“嘀答”中断程序的执行，并引起振动发声。
TONE中的内容决定了声音的频率，高值导致低频率，低值导致高频率。程序发出每一个音符后，
通过右移一位（相当于除2）来增加TONE的频率。因为在此例中降低TONE将减少发音的长度，
程序同时左移一位（相当于乘2）来增加DURATION。
当TONE降低为零时，程序结束。DURATION和TONE中的初始值没有技术上的含义。
可以实验使用其他的值，并执行没有CLI指令的程序。
可以使用任何逻辑的变化来演奏一串音符序列，其目的可能是为了引起用户的注意。
.DATA
DURATION DW 10000
TONE DW 512H
.CODE
IN AL,61H
PUSH AX
A20:MOV DX,DURATION
A30:OR AL,00000011B
OUT 61H,AL
MOV CX,TONE
A40:LOOP A40
OR AL,00000010B
OUT 61H,AL
MOV CX,TONE
A50:LOOP A50
DEC DX
JNZ A30
SHL WORD PTR DURATION,1
SHR TONE,1
JNZ A20
POP AX
AND AL,11111100B
OUT 61H,AL
...
测试通过的完整程序如下
.MODEL SMALL
.STACK 64
.DATA
DURATION DW 0F000H
TONE DW 7000H
FLAGB DB 00H
.CODE
MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
IN AL,61H
MOV FLAGB,AL
MOV DI,WORD PTR DURATION
MOV SI,WORD PTR TONE
A20:MOV CX,SI
MOV AL,0B6H
OUT 43H,AL
MOV AL,CL
OUT 42H,AL
MOV AL,CH
OUT 42H,AL
MOV AL,FLAGB
OR AL,3
OUT 61H,AL
push dx
MOV DX,DI
call delay
pop dx
MOV AL,FLAGB
AND AL,11111100B
OUT 61H,AL
push dx
MOV DX,3000H
call delay
pop dx
MOV AH,10H
INT 16H
SHR SI,1
CMP SI,0F00H
JAE A20
MOV AL,FLAGB
OUT 61H,AL
MOV AX,4C00H
INT 21H
MAIN ENDP
DELAY PROC
push ax
push dx
mov ax,0
delay_s:sub ax,1
sbb dx,0
cmp ax,0
jne delay_s
cmp dx,0
jne delay_s
pop dx
pop ax
ret
DELAY ENDP
END MAIN
24.10要点
ROM驻留在FFFF0H开始的位置。接通电源使处理器进入重置状态，设置所有存储器单元为0，对存储器进行奇偶校验，
设置CS寄存器为FFFF[0]H和IP为0。因此要执行的第一条指令在FFFF：0，即FFFF0H，它指向BIOS的入口。
引导时，BIOS检查各个端口以识别和初始化所连接的设备。然后BIOS从存储器位置0开始建立中断向量表，
它包含产生中断的地址。BIOS执行的两个操作是确定设备和存储器的大小。
BIOS访问包含引导程序加载器的第一个磁盘扇区。
BIOS在段地址40[0]H开始的低地址存储器中保留自己的数据区。
有关的数据区包括串行端口、并行端口、系统设备、键盘、磁盘驱动器、视频控制器、硬盘和实时钟。
中断指令如INT21H，它的操作数表明请求的类型。对256种可能类型的每一种，
系统都在地址0000H~3FFH的中断向量表中保留一个4字节地址。
BIOS中断类型的范围从00H到1FH，包括打印屏幕、定时器、视频控制、软盘控制、视频显示、确定设备和内存大小、
磁盘I/O、键盘输入、通信、打印机输出和引导程序加载器。
DOS INT 21H处理的操作如键盘输入、显示输出、打印机输出、重置磁盘、打开/关闭文件、删除文件、读写记录、
终止但保持驻留、创建子目录和终止程序。
通过端口，处理器从输入设备接收信号或发送信号到输出设备。端口通过它们的地址来识别，
端口地址在00H~3FFH范围内，共有1024个端口。
PC机通过内置永久磁铁扬声器产生声音，扬声器和端口42H、43H和61H相连。
24.11习题
24-1.区别内部中断和外部中断。
外部中断是由发生在CPU外部的某个事件引起的中断。外部中断以完全随机的方式中断现行程序。
外部中断包括键盘和硬盘等外设的中断，由电源掉电、存储器出错或者总线奇偶校验错等紧急故障产生的中断。
内部中断是由发生在CPU内部的某个事件引起的中断。内部中断是CPU在执行某些指令时产生，不是完全随机产生。
内部中断不需要外部硬件的支持，不受中断允许标志IF的控制。
内部中断包括中断指令INT引起的中断，CPU遇到特殊情况引起的中断，用于程序调试的中断。
24-2.区别NMI连线和INTR连线。
可屏蔽中断请求是键盘和硬盘等外设的中断请求，由INTR中断请求线传给CPU。
如果中断允许标志IF为0，则CPU不响应由INTR传入的中断请求。
如果中断允许标志IF为1，则CPU响应由INTR传入的中断请求。
不可屏蔽中断请求是由电源掉电、存储器出错或者总线奇偶校验错等紧急故障产生的中断请求，由NMI中断请求线传给CPU。
不论中断允许标志IF的值是多少，CPU总会响应。
不可屏蔽中断的中断类型号规定为2，CPU在响应不可屏蔽中断请求时，总是转入由2号中断向量所指定的中断处理程序。
24-3.（a）指向BIOS入口的存储器地址是什么？（b）启动时，系统如何定向到这一地址？
开机后，处理器进入重置状态，设置所有的存储器单元为0，对存储器执行奇偶校验，以及设置CS为FFFF[0]H，IP为0。
所以第一步要执行的指令在FFFF：0，它指向BIOS的入口。
24-4.引导时，BlOS执行INT11H、12H和19H操作。解释每个中断的用途。
BIOS检验各个端口来识别和初始化连接的设备，包括INT11H（确定设备）和INT12H（确定存储器大小）。
然后，在常规存储器的单元0开始，BIOS建立包含有中断例程地址的中断向量表。
紧接着，BIOS确定包含系统文件的磁盘是否存在，如果有，将执行INT19H存取第一个磁盘扇区，
该扇区含有引导程序加载程序。在它加载存储器之后，BIOS例程把控制传递给操作系统。
引导程序只有一个任务：把操作系统的第一部分装入内存。
24-5.BIOS数据区的开始位置在哪里？
BIOS 在段地址40[0]H开始的低地址存储器保留了白己的256字节（100H）的数据区
24-6.下列二进制值记录在BIOS数据区。对每・项，确定是什么字段，并解释为1的位的意义。
（a）10-11H：0100 0100 01 10 0111（b）17H：11101010
（c）18H：00000001（d）96H：00011010
10H~11H设备状态，已安装设备的状态的原始指示。
位设备
15，14连接的并行端口数
11~9连接的RS232串行端口数
7，6软盘设备数，位为00=1，01=2，10-3，11=4
5，4初始化显示方式，位值为00=未用，01=40×25彩色，10=80×25彩色，11=80×25黑白。
2 指示设备（鼠标），1=已安装
1 1=数字协处理器已存在
0 1=软盘驱动器已存在
存储器大小数据区
键盘数据区
17H当前SHIFT状态的第一字节：
位                  动作                  位                  动作
7                  Insert激活         3                  Alt按下
6                  CapsLock激活  2                  Ctrl按下
5                  NumLock激活  1                  左shift按下
4                  ScrollLock激活  0                 右shift按下
“激活”表示键已经按下和设置。“按下”表示在BIOS存储状态时键已被按下。
18H当前SHIFT状态的第二字节：
位                  动作                  位                  动作
7                  Insert按下         3                  hold/pause状态
6                  CapsLock按下  2                  SysReq按下
5                  NumLock按下  1                  左Alt按下
4                  ScrollLock按下  0                  左Ctrl按下
96H键盘方式状态和键入标志：
位                  动作                  位                  动作
7                  顺次读ID         3                  右Alt按下
6         最后的代码是ACK   2                  右Ctrl按下
5         如果读ID和KBX强制NumLock   1         最后的扫描码是E0
4         安装扩展键盘         0                  最后的扫描码是E1
24-7.下列十六进制值记录在BIOS数据区。确定每-项是什么字段，并解释这些值的意义。
（a）00-03H:F8 03 F8 02（b）08-0BH：78 03 00 00
（c）13-14H：80 02（d）15-16H：00 10
（e）4AH-4BH：50 00（f）60-61H：0E 0D
（g）84H：18
串行端口数据区
00H~07H4个字，4个串行端口COM1~COM4的地址。
并行端口数据区
08H~0FH4个字，4个并行端口LPT1~LPT4的地址。
13H~14H系统板上的内存总数（千字节）。
15H-16H扩展内存总数（千字节）。
4AH~4BH屏幕上的列数。
60H~61H光标开始和结束行。
84H屏幕的行数。
24-8.识别下列BIOSINT操作：（a）单步模式，（b）通信I/O，（c）获得设备状态，（d）打印屏幕，（e）磁盘I/O，（f）键盘输入，（g）键盘，
（h）视频显示，（i）打印机输出，（j）读取和设置时间。
INT 01H：单步。由DEBUG和其他调试器使用，可以在程序执行过程中单步调试。
INT03H：断点。用于调试器来停止程序的执行。
INT 05H：打印屏幕。打印视频显示区的内容。
INT09H：键盘中断。是由按下或放开键盘上的一个键产生的。
INT 0BH，INT 0CH：串行设备控制。分别控制COM1和COM2端口。
INT 0DH，INT 0FH：并行设备控制。分别控制LPT2和LPT1端口。
INT10H：视频显示。在AH中接收一个功能号，表示屏幕方式，设置光标、滚动和显示，详见第9章中的描述。
INT11H：确定设备。确定系统中的可选择设备。
INT12H：确定内存大小。
INT13H：磁盘I/O。
INT14H：通信I/O。
INT16H：键盘输入。
INT 17H：打印机输出。
IINT1AH：读取和设置时间。
24-9.确定下列INT21H服务的功能：（a）终止但保持驻留，（b）获得中断向量表地址，
（c）创建子目录，（d）获得空闲磁盘空间，（e）获得PSP地址，，（f）创建新文件，（g）获得系统时间，（h）重命名文件。
25H：设置中断向量。
2CH：获取系统时间。
2DH：设置系统时间。
31H：终止但保持驻留。
35H：获取中断向量表的地址。
36H：获取空闲磁盘空间。
39H：创建子目录。
3AH：删除子目录。
3CH：创建文件。
3DH：打开文件。
3EH：关闭文件。
3FH：读文件/设备。
40H：写文件/设备
41H：从目录中删除文件。
42H：移动文件指针。
50H：设置程序段前缀地址（PSP）。
51H：获得程序段前缀地址（PSP）。
56H：重命名文件。
62H：获得PSP地址。
24-10.识别下列NT21H的功能：（a）05H，（b）09H，（c）0DH，（d）19H，（e）2BH，（f）31H，
（g）36H，（h）3AH，（i）42H。
01H：键盘输入有回显。
02H：显示字符。
03H：通信输入。
04H：通信输出。
05H：打印机输出。
06H：直接键盘输入和显示输出。
07H：直接键盘输入，不回显。
08H：键盘输入，不回显。
09H：显示字符串。
0AH：有缓冲的键盘输入。
0BH：检验键盘状态。
0CH：清除键盘缓冲区并调用输入功能。
0DH：重置磁盘驱动器。
0EH：选择默认磁盘驱动器。
19H：确定默认磁盘驱动器。
1AH：设置磁盘传输区（DTA）。
1FH：得到默认驱动器参数块。
25H：设置中断向量。
29H：解析文件名（见第18章）。
2AH：获取系统日期。
2BH：设置系统日期。
2CH：获取系统时间。
2DH：设置系统时间。
2EH：设置/重置磁盘验证。
2FH：获取当前磁盘传输区的地址（DTA）。
31H：终止但保持驻留。
32H：获取磁盘参数块（DPB）。
3300H：获得Ctrl+C状态。
3301H：设置Ctrl+C状态。
3305H：获得启动驱动器。
3306H：获取DOS信息。
35H：获取中断向量表的地址。
36H：获取空闲磁盘空间。
38H：获取/设置相关国家的信息。
39H：创建子目录。
3AH：删除子目录。
3BH：改变当前目录。
3CH：创建文件。
3DH：打开文件。
3EH：关闭文件。
3FH：读文件/设备。
40H：使用文件代号写文件/设备
41H：从目录中删除文件。
42H：移动文件指针。
43H：检查/改变文件属性。
44H：设备的I/O控制。
45H：复制文件代号。
46H：强制复制文件代号。
47H：获取当前目录。
48H：分配内存块。
49H：自由分配内存块。
4AH：设置分配的内存块大小。
4BH：加载/执行一个程序。
4CH：终止程序。程序执行结束的标准操作。
4DH：取子程序回送值。
4EH：寻找到第一个匹配的目录入口项。
4FH：寻找到下一个匹配的目录入口项。
50H：设置程序段前缀地址（PSP）。
51H：获得程序段前缀地址（PSP）。
54H：获得检验状态。
56H：重命名文件。
57H：获取/设置文件日期和时间。
5800H：获得内存分配策略。
5801H：设置内存分配策略。
5802H：取得上部存储器连接。
5803H：设置上部存储器连接。
59H：获取扩展错误码。
5AH：创建临时文件。
5BH：创建新文件。
5DH：设置扩展错误。
62H：获得PSP地址。
65H：获得扩展国家信息。
67H：设置最大文件代号计数。
68H：提交文件。
6CH：扩展打开文件。
24-11.参考24.7节中交换LPT1和LPT2地址的程序并修改指令，交换COM1和COM2的地址。
BIOSDATA SEGMENT AT 40H
COMPORT DW 4 DUP (?)
BIOSDATA ENDS
...
ASSUME DS:BIOSDATA
MOV AX,BIOSDATA
MOV DS,AX
MOV AX,COMPORT[0]
MOV BX,COMPORT[2]
MOV COMPORT[0],BX
MOV COMPORT[2],AX
...
24-12.针对下列要求修改图24-1程序：产生频率下降的音符；初始化TONE=01和DURATION 为一个大值。
在每次循环中，增加TONE的值，减少DURATION的值，当DURATION等于0时结束程序。
可以参照如下程序
.MODEL SMALL
.STACK 64
.DATA
DURATION DW 0F000H
TONE DW 7000H
FLAGB DB 00H
.CODE
MAIN PROC FAR
MOV AX,@data
MOV DS,AX
MOV ES,AX
IN AL,61H
MOV FLAGB,AL
MOV DI,WORD PTR DURATION
MOV SI,WORD PTR TONE
A20:MOV CX,SI
MOV AL,0B6H
OUT 43H,AL
MOV AL,CL
OUT 42H,AL
MOV AL,CH
OUT 42H,AL
MOV AL,FLAGB
OR AL,3
OUT 61H,AL
push dx
MOV DX,DI
call delay
pop dx
MOV AL,FLAGB
AND AL,11111100B
OUT 61H,AL
push dx
MOV DX,3000H
call delay
pop dx
MOV AH,10H
INT 16H
SHR SI,1
CMP SI,0F00H
JAE A20
MOV AL,FLAGB
OUT 61H,AL
MOV AX,4C00H
INT 21H
MAIN ENDP
DELAY PROC
push ax
push dx
mov ax,0
delay_s:sub ax,1
sbb dx,0
cmp ax,0
jne delay_s
cmp dx,0
jne delay_s
pop dx
pop ax
ret
DELAY ENDP
END MAIN
第25章操作符与伪操作
25.1引言
25.2类型区分符
25.3操作符
25.4伪操作
目的：提供汇编语言操作符与伪操作的详细说明
25.1引言
各种各样的汇编语言特性最初会让人感到有点不知所措。
但是，一旦对前些章所描述的比较简单而通用的特性越来越熟悉，你会发现在这一章里说明的各种类型的区分符、操作符和伪操作更加容易理解和引用。
汇编语言手册还包括了其他一些专门的特性。
注意，标准的Turbo汇编程序――TASM可以在MASM方式下运行，即它接受标准MASM的规范；也可以在理想方式下运行，
此时，在许多情况下，它使用的术语与规则会有所不同，并且有可能无法识别MASM的规范。
25.2类型区分符
类型区分符可以指示数据变量的大小或指令标号的相对距离。
标明数据变量大小的区分符是BYTE，WORD，DWORD，FWORD，QWORD，以及TBYTE。
标明指令标号距离的区分符是NEAR，FAR，以及PROC。
近地址仅是简单的偏移地址，用于当前段之内；远地址是由段：偏移地址组成的，可以访问另一段中的数据。
PTR与THIS操作符以及COM、EXTRN、LABEL和PROC伪操作使用类型区分符。
25.3操作符
操作符为在汇编期间修改与分析操作数提供了方便。操作符分为以下各种类型：
计算操作符：算术运算，变址，逻辑，移位，以及结构字段名。
宏操作符：在第21章里所涉及的各种类型。
记录操作符：MASK和WIDTH，在本章后面的RECORD伪操作部分会涉及到它们。
关系操作符：EQ，GE，GT，LE，LT，以及NE。
段操作符：OFFSET，SEG，以及段跨越。
类型（或属性）操作符：HIGH，HIGHWORD，LENGTH，LOW，LOWWORD，PTR，SHORT，SIZE，THIS，
以及TYPE。
由于有关这些类型方面的知识并不是必需的，所以本章只是按操作符字母顺序简单地加以介绍。
（1）算术运算操作符。
该操作符包括常见的一些算术符号和在汇编期间实现的算术运算。
尽管使用这些操作符的优点是每次修改程序和重新汇编时，汇编程序会自动地重新计算这些算术操作符的值，
但在大多数情况下，可以自己完成这些计算。
下面是这些操作符的表，同时还提供了使用它们的例子以及得到的结果：
符号类型                  例                  结果
+加法                  FLDA+25         把25加到FLDA的地址上
+正                  +FLDA                把FLDA作为正数处理
-减法                  FLDB-FLDA       计算2个偏移地址间的差
-负                  -FLDA                  FLDA的符号变反
*乘法                  值*3值               乘以3
/除法                  值/3                  值除以3
MOD 余数         值1 MOD 值2      值1/值2得到的余数
除加法（+）和减法（-）外，所有操作符必须是整数常数。以下相关的例子说明整数表达式：
value=12*4   ;48
value=value/6   ;48/6=8
value=-value-3；（-8）-（3）=-11
算术操作符常用于相等伪操作，在“伪操作”一节会涉及到它。
（2）HIGH与HIGHWORD操作符。
HIGH操作符回送表达式的高位（最左边）字节，而HIGHWORD（MASM6.0以后）则回送表达式的高位字
（也可参见LOW操作符）。举例如下：
EQUVAL EQU 1234H
MOV CL,HLGH EQUVAL   ;把12H装入CL
（3）变址操作符。对于存储器间接寻址，操作数访问基址或变址寄存器、常数、偏移变量以及变量。
变址操作符使用方括号，相当于加（+）符号的作用。变址的典型用法是访问表中的数据项。
可以用以下操作访问变址存储器：
把在方括号中的立即数或名字，编码成为[常数]。例如，把PART_TBL的第5项装入CL（注意，PART_TBL[0]是第1项）：
PART_TBL DB 25 DUP (?)   ;定义表格
MOV CL,PART_TBL[4]   ;取得第5项
把基址寄存器BX作为[BX]和段寄存器DS联合在一起，把基址寄存器BP作为[BP]和段寄存器SS联合在起。
例如，使用BX（作为DS:BX）中的偏移地址，把所访问的项传送到DX：
MOV DX,[BX]   ;基址寄存器DS:BX
把变址寄存器DI作为[DI]并把变址寄存器SI作为[SI]，将它们和DS段寄存器联合在起。
例如，使用SI（作为DS：SI）中的偏移地址，把所访问的项传送到AX：
MOV AX.[SI]   ;变址寄存器DS:SI
组合变址寄存器。例如，把AX的内容传送到由DS的地址、BX的偏移地址、SI的偏移地址和常数4相加所确定的地址中：
MOV [BX+SI+4],AX   ;基址+变址+常数
上面例子中的第一个操作数也可以写成[BX+SI]+4。可以按任何次序组合这些操作数，
但不能组合2个基址寄存器[BX+BP]或2个变址寄存器[DI+SI]。
变址寄存器必须在方括号内，这使得汇编程序知道按变址操作符处理它。
（4）LENGTH操作符。
LENGTH操作符回送由DUP操作符定义的项目数，如下面的MOV指令所示：
PART_TBL DW 10 DUP (?)
MOV DX,LENGTH PART_TBL   ;把长度10回送到DX
如果所访问的操作数不包含DUP项目，那么该操作符回送值01（对其可用性的限制）
（也可参见SIZE和TYPE操作符）。
（5）逻辑操作符。逻辑操作符处理表达式中的位：
操作符                           用法                           效果
AND         expression1 AND expressio2         各位相与
OR         expression1 OR expression2            各位相或
XOR         expression1 XOR expression2        各位异或
NOT         NOT expression1                           各位求反
下而是2个例子：
MOV CL,00111100B AND 01010101B   ;CL=00010100B
MOV DL,NOT 01010101B   ;DL=10101010B
（6）LOW/LOWWORD操作符。
LOW操作符回送表达式的低位（最右边）字节，而LOWWORD（MASM6.0以后）回送表达式的低位字
（也可参见HIGH操作符）。下面是一个例子：
EQU_VAL EQU 1234H
MOV CL,LOW EQU_VAL   ;把34H装入CL
（7）OFFSET操作符。
OFFSET操作符回送变量或标号的偏移地址。该操作符编码为OFFSET variable/label。
下面的MOV回送PART_TBL的偏移地址：
MOV DX,OFFSET PART_TBL
注意，指令LEA DX,PATR_TBL回送同样的值但不需要OFFSET。
（8）MASK操作符。见下一节“伪操作”中的“RECORD伪操作”。
（9）PTR操作符。
PTR操作符可以用在数据变量和指令标号中。它使用类型区分符BYTE、WORD、FWORD、DWORD、QWORD和
TBYTE指定具有二义性的操作数大小，或指定变量所定义类型（DB、DW、DF、DD、DQ或DT）之外的大小。
还使用类型区分符NEAR、FAR和PROC指明标号距离。
该操作符编码为type PTR expression，其中type是个新属性，如BYTE，而 expression则是变量或常数。
下面是PTR操作符的例子：
BYTEA DB 22H
DB 35H
WORDA DW 2672H   ;数据按72 26H存放
ADD BL,BYTE PTR WORDA+1   ;加第二个字节（26H）
MOV BYTE PTR WORDA,05H   ;把05传送给第一个字节
MOV AX,WORD PTR BYTEA   ;把2个字节（22 35）传送到AX 3522H
CALL FAR PTR [BX]   ;调用远过程
与PTR实现同样功能的是LABEL伪操作，稍后再加以讨论。
（10）SEG操作符。
SEG操作符返回指定的变量或标号所在段的段地址。把分别汇编的段组合起来的程序很可能会使用这个操作符。
该操作符编码为SEG variable/label。
以下各不相关的MOV语句回送引用的名字所在段的段地址：
MOV AX,SEG WORDA   ;取数据段地址
MOV AX,SEG A10BEGIN   ;取代码段地址
（11）段跨越操作符。
该操作符编码为冒号形式（：），它计算相对于一个特殊段的标号或变量的地址。
该操作符编码为segment:expression。段可以是段寄存器，段，或组名中的任何一个。
表达式可以是常数、表达式或SEG表达式。
以下这些例子跨越默认的DS段寄存器：
MOV BH,ES:10H   ;从ES+10H处取数
MOV CX,SS:[BX]   ;从SS+BX中的偏移值处取数
段跨越操作符适用于只有一个操作数的情况。
（12）SHL与SHR操作符。操作符SHL和SHR在汇编期间使表达式移位。
该操作符编码成expression SHL/SHR count。在下面的例子中，SHR操作符将位常数向右移3位：
MOV BL,01011101B SHR 3   ;装入00001011B
表达式很有可能引用符号名而不是常数值。
（13）SHORT操作符。SHORT操作符的用途是修改JMP在-128~+127字节目的地范围内的NEAR属性，
编码为JMP SHORT 1abel。汇编程序把机器码操作数从两个字节减少为一个字节。
这一特性对于向前转移的近跳转是有用的，因为不然的话，汇编程序最初不知道跳转地址的距离，
可能会为近跳转采用2个字节。
（14）SIZE操作符。SIZB操作符回送LENGTH与TYPE的乘积，并且仅当所引用的变量包含DUP项时才是有用的。
该操作符编码为SIZE variable。相关例子见“TYPE操作符”。
（15）THIS操作符。THIS操作符建立一个具有段与偏移值的操作数，该操作数的段和偏移值等于当前单元计数器的
相应值。该操作符编码成：THIS type，type（类型）对于变量可以是BYTE、WORD、DWORD、FWORD、
QWORD或TBYTE，对于标号可以是NEAR、FAR或PROC。
THIS 典型地可以和EQU或相等（=）伪操作一起使用。以下例子定义PART_REC：
PART_REC EQJ THIS BYTE效果和使用LABEL伪操作是一样的，如PART_REC LABEL BYTE
（16）TYPE操作符。TYPE操作符根据所引用变量的定义回送字节数。
但是，该操作对于串变量总是回送1，对于常数则回送0。该操作符的编码为TYPE variable/label。
定义                  数字变量的字节数
DB/BYTE                  1
DW/WORD               2
DD/DWORD            4
DF/FWORD            6
DQ/QWORD           8
DT/TBYTE               10
STRUC/STRUCT      由结构定义的字节数
NEAR label            FFFFH
FAR label               FFFEH
以下例子说明TYPE，LENGTH和SIZE操作符：
BYTEA DB ?   ;定义1个学节
PART_TBL DW 10 DUP (?)   ;定义10个字
MOV AX,TYPE BYTEA   ;AX=0001H
MOV AX,TYPE PART_TBL   ;AX=0002H
MOV CX,LENGTH PART_TBL   ;CX=000AH（10）
MOV DX,SIZE PART_TBL   ;DX=0014H（20）
因为PART_TBL定义为DW，TYPE回送0002H，LENGTH在DUP项的基础上回送000AH（10），
而SIZE回送类型乘以长度，即14H（20）。
（17）WIDTH操作符。见下一节的“RECORD伪操作”。
25.4伪操作
本节讨论大多数汇编程序伪操作，第4章详细介绍了定义数据DB，DW，等等）的伪操作，
第21章介绍了宏指令的伪操作，这里不再重复。伪操作分为以下各种类型：
代码标号：ALIGN，EVEN，LABEL，以及PROC。
条件汇编：IF，ELSE及其他，第21章已讨论过。
条件出错：.ERR，.ERR1及其他。
数据分配：ALIGN，EQU，EVEN，LABEL，以及ORG（DB，DW，DD，DF，DQ，以及DT在第4章已经介绍）。
列表控制：.CREF，.LIST，PAGE，SUBTTL，TITLE，.XCREF，以及.XLIST，本章将会说明它们。
（.LALL，.LFCOND，.SALL，.SFCOND，.TFCOND，以及.XALL在第21章讨论过。）
宏：ENDM，EXITM，LOCAL，MACRO，以及PURGE，在第21章介绍过。
杂类：COMMENT，INCLUDE，INCLUDELIB，NAME，&OUT，以及.RADIX。
・处理器：.8086，.286，.286P，.386，.386P，等等。
重复块：IRP，IRPC，以及REPT，在第21章讨论过。
作用域：COMM，EXTRN，以及PUBLIC。
段：.ALPHA，ASSUNE，.DOSSEG，END，ENDS，GROUP，SEGMENT，以及.SEQ。
简化段：.CODE，.CONST，.DATA，.DATA?，.EXIT，.FARDATA，.FARDATA?，.MODEL，以及.STACK。
结构/记录：ENDS，RECORD，STRUCT，TYPEDEF，UNION。
以下各节按字母顺序介绍这些伪操作。
（1）ALIGN（对准）伪操作。
ALIGN伪操作使汇编程序把下一个数据项或指令按照给定值对准在一个地址上。
对准可以为处理器访问字和双字提供方便。它的格式是ALIGN number，其中number必须是2的幂，
比如2，4，8或16。
在下面的例子中，单元计数器在0005处，ALIGN 4语句使得汇编程序将单元计数器前进到下一个能被4整除的地址：
0005 ALIGN 4
0008 DBWORD DD 0   ;对准在双字边界上
如果单元计数器已经在所要求的地址处，那么它就不动了。
汇编程序对于数据把未用的字节用零填充而对于指令则用NOP填充。
注意，ALIGN 2和EVEN效果是一样的。
（2）.ALPHA伪操作。
该伪操作位于程序的起点或其附近，它通知汇编程序为了和早期汇编程序版本兼容，需要按字母顺序排列段。
也可以在汇编程序命令行中使用/A选项。
（3）ASSUME伪操作。
ASSUME通知汇编程序把段名与CS、DS、ES和SS段寄存器联系起来。它的格式是
ASSUME segment-reg:segment-name，[...]
有效的segment-reg项是CS，DS，ES，SS，FS，以及GS。有效的segment-name项是段寄存器的段名，
NOTHING，GROUP，以及SEG表达式。一个ASSUME语句可以按任何次序给多达4个段寄存器赋值。
简化段伪操作自动生成ASSUME。
在下面的ASSUME语句中，CODESEG、DATASEG和STACK是程序用于定义段的名字：
ASSUME CS:CODESEG,DS:DATASEG,SS:STACK,ES:DATASEG
省略段的引用和编写代码NOTHING是一样的。关键字NOTHING的使用还可以取消以前的任何ASSUME所指定的
段寄存器如ASSUME ES:NOTHING。既没有对ES赋值又没有使用NOTHING取消它，
那么对于引用数据段中的一个项，指令操作数可以使用段跨越操作符（：）引用ES，
其中必须包含能正常执行的有效段地址：
MOV AX,ES:[BX]   ;使用变址地址
MOV AX,ES:WORDA   ;传送WORDA的内容
（4）.CODE伪操作。这个简化段伪操作定义代码段。
它的格式是.CODE [name]，其中name是个可选项。所有可执行代码必须存放在这个段内。
对于Tiny，Small，以及Compact存储模型，默认的段名是_TEXT。
Medium，和Large存储模型允许多个代码段，可以根据 name操作数来区分它们（参见.MODEL伪操作）。
5）COMM伪操作。把变量定义成COMM（公共）使它既有PUBLIC又有EXTRN属性。
用这种方法，不必把变量在一个模块中定义成PUBLIC，并且又在另一模块中定义成EXTRN。
COMM伪操作的格式是
COMM [NEAR/FAR] label:size[:count]
COMM是在数据段内编码的。
NEAR或FAR属性可以被编码或默认为其中的一个，这取决于存储模型。
label是变量的名字。注意，该变量不能有初始值。
size 可以是BYTE、WORD、DWORD、QWORD和TBYTE中的任何一种区分符，或是一个指定字节数的整数。
count指明变量的元素数，默认值是1。
以下例子定义带COMM属性的项：
COMM NEAR COM_FLD1:WORD   ;带COMM属性的字
COMM FAR COM_FDL2:BYTE:25   ;带COMM属性的25个字节
（6）COMMENT伪操作。这个伪操作可以用于多行的注释。其格式为
COMMENT delimiter [comments]
[comments]
delimiter [comments]
定界符（delimiter）是第一个非空白字符，比如%或+，跟在COMMENT后面。
注释结束于第二个定界符出现的行上。这一例子使用“+”作为定界符：
CONMENT + This routine scans 
Keybord input for
+ invalid characters
（7）.CONST伪操作。这个简化段伪操作定义一个带'const'类别的数据（或常数数据）段（参见.MODEL伪操作）。
（8）.CREF伪操作。这个伪操作（默认的）通知汇编程序产生交叉引用表。
可以使用后面的.XCREF伪操作禁止该表。
（9）.DATA和.DATA?伪操作。这些简化段伪操作定义数据段。.DATA定义一个初始化的近数据段；.DATA?
则定义一个未初始化的近数据段，通常在和高级语言连接时会使用它。
对于一个独立的汇编程序，也可以在DATA段内定义未初始化的近数据（参见，.FARDATA和.MODEL伪操作）。
（10）DOSSEG/.DOSSEG伪操作。有许多方法控制汇编程序排列各段的序列。
可以在程序的起点编写.SEQ或.ALPHA伪操作，或者在汇编命令行上输入/S或/A选项。
DOSSEG（MSAM6.0以后是.DOSSEG）伪操作通知汇编程序忽略所有其他请求，
而去接受DOS段序列一基本上是代码、数据和堆栈。
在程序的起点或附近编写这个伪操作，主要是便于对独立的程序使用CODEVIEW 调试程序。
（11）END伪操作。END伪操作放在源程序的末尾，它的格式是END[start-address]。
选项start-address指明代码段开始执行的地址（通常是第一条指令）。
系统装入程序使用这地址初始化CS寄存器。如果程序只由一个模块组成，那就定义一个起始地址；
如果是由许多模块组成的，那么也只有一个模块（通常是第一个）有起始地址。
（12）ENDP伪操作。ENDP伪操作指明由PROC定义的过程的结束。
它的格式是procedure-name ENDP，其中procedure-name（过程名）与所定义的过程中的过程名是相同的。
（13）ENDS伪操作。这个伪操作指明段（由SEGMENT定义的）的结束或是一个结构（由STRUC或STRUCT定义的）
的结束。它的格式是：segment-name ENDS，其中segment-name与所定义的段或结构中的名字是相同的。
（14）相等伪操作。相等伪操作的两种类型是等号和EQU。它们都只在汇编期间进行处理而不进行任何存储。
它们的用途举例来说是提供数字常数的名字和所定义项的别名。该伪操作应当在被引用前在程序中加以定义。
等号伪操作的格式是name=expression，其中expression（表达式）是任意的整数值或数字表达式。
该伪操作可以对一个项任意次赋值。以下是2个例子：
例1：ROW=12
COL=16
MOV BX,ROW+COL
例2：SCREEN_LOCS=25*0
MOV CX,SCREEN_LOCS
EQU伪操作用于再定义数据名或具有其他数据名的变量，变量，或立即值。汇编程序用操作数来替代每次出现的名字。
EQU伪操作在程序中对一个项只能赋值一次。数字与串数据格式的区别是：
数字相等：name EQU expression
串相等：name EQU <string>
使用带数字数据EQU的例子是：
COUNTER DW 0
SUM EQU COUNTER   ;COUINTER的另一个名字
TEN EQU 10   ;数字值
...
INC WORD PTR SUM   ;COUNTER增量
ADD WORD PTR SUM,TEN   ;COUNTER加10
使用带串数据EQU的例子是：
PROD_MSG EQU <'Enter product number:'>
BY_PTR EQU <BYTE PTR>
MFSSGE DB PROD_MSG   ;用串替代
MOV SAVE,BY_PTR [BX]   ;用串替代
尖括号（<>）使之更容易指明串操作数。
（15）.ERR伪操作。下面这些条件出错伪操作有助于在汇编期间对错误的检测
伪操作                           强制出错
.ERR1                  在汇编的第1遍扫视期间
.ERR2                  在汇编的第2遍扫视期间
.ERRE                  按真（0）表达式
.ERRNE               按假（非0）表达式
.ERRDEF                  按定义的符号
.ERRNDEF               按未定义的符号
.ERRB                        按空白串
.ERRNB                     按非空白串
.ERRIDN[I]                  按相同的串
.ERRDIF[I]                  按不同的串
自MASM6.0以后，已经不必关注汇编的第1遍扫视（.ERR1）和第2遍扫视（.ERR2）了。
可以使用前面的宏与条件汇编语句中的伪操作。在下面的条件汇编语句中，
如果条件不为真，则汇编程序将显示信息：
IF condition
...
ELSE
.ERR
%OUT [message]
ENDIF
（16）EVEN伪操作。EVEN通知汇编程序如果必要的话使其单元计数器向前进，以便下一个定义的数据项或指令
可以对准偶数存储边界。这一特性便于处理器一次存取16位或32位（ALIGN 2产生与EVEN同样的效果）。
下列例了中，BYTE_LOCN是偶数边界0016上的1字节字段，现在单元计数器是0017。
EVEN使汇编程序让单元计数器前进一个字节到0018，在那里，下一个数据项WORD_LOCN被定义：
0016 BYTE_LOCN DB ?
0017 EVEN   ;单元计数器向前进
0018 WORD_LOCN DW ?
（17）.EXIT伪操作。在代码段中，可以使用.EXIT伪操作产生程序结束代码。
它的格式是：.EXIT [return-value]，其中return-value（回送值）为0指没有问题，而1的回送值指结束处理的错误。
所产生的代码是：
MOV AH,4CH
MOV AL,return-value   ;如果回送值被编码则产生
INT 21H
（18）EXTRN/EXTERN伪操作。
EXTRN（或MASM6.0以后的EXTERN）伪操作通知汇编程序和连接程序有关当前汇编所引用的数据变量和标号，
它们是在另一个模块（与当前模块连接的）中定义的。伪操作的格式是EXTRN name:type[,...]，
其中name是在另一个汇编模块中定义的项并在那里被声明为PUBLIC的。type可以是下列的任何一种：
数据项：ABS（常数），BYTE，WORD，DWORD，FWORD，QWORD，TBYTE。
在产生项的段中编写EXTRN代码。
距离：NEAR或FAR。在产生项的段中编写NEAR代码，可以在任何地方编写FAR代码。
在下面的例子中，调用程序把CON_VALUE定义为PUBLIC和DW，被调用的子程序把CON_VALUE
（在另一个段中）标识为EXTRN和FAR。
调用程序：
DSEG1 SEGMENT
PUBLIC CON_VALUE
...
CON_VALUE DW ?
...
DSEG1 ENDS
被调用的子程序：
EXTRN CON_VALUE:FAR
DSEG2 SEGMENT
...
MOV AX,WORD PTR CON_VALUE
...
DSEC2 ENDS
参见第22章有关EXTRN的例子。
（19）.FARDATA和.FARDATA?伪操作。这些简化段伪操作定义数据段。
.FARDATA定义一个已经初始化的远数据段，而.FARDATA?则定义一个未初始化的远数据段。对于一个独立汇编的
程序，也可以在.FARDATA段中定义未初始化的远数据（参见.DATA与.MODEL伪操作）。
（20）GROUP伪操作。程序可以包含几个同样类型的段（代码，数据或堆栈）。
GROUP伪操作的用途是把同一类型的段集合在一个名字下，使它们常驻在一个段内，通常是在数据段内。格式是
name GROUP seg-name [,seg-name]，…
下面的GROUP把DATASEG1和DATASEG2组合在同一个汇编模块中：
GROUPX GROUP DATASEG1,DATASEG2
DATASEG1 SEGMENT PARA 'Data'
ASSUME DS:GROUPX
...
DATASEG1 ENDS
...
DATASEG2 SEGMENT PARA 'Data'
ASSUME DS:GROUPX
...
DATASEG2 ENDS
使用GROUP的作用类似于给段以相同的名字和PUBLIC属性。
（21）INCLUDE伪操作。如果有不同程序都能使用的一段汇编代码或宏指令，可以把它们存放在单独的磁盘文件中，
以便提供给任何程序使用。考虑把ASCII码转换成二进制的例行程序，将其存放在名为CONVERT.LIB的文件中。
为访问该文件，插入INCLUDE语句，如：
INCLUDE path:CONVERT.LIB
为把此语句插入源程序中，通常要写明ASCII转换例行程序的位置。汇编程序定位到磁盘上的这个文件
并把这些语句包含在程序里（如果汇编程序没有找到该文件，会发出出错信息）。
对于每个所包含的行，编程序要在.LST文件的第30列处打印一个C（取决于版本），而源代码是从第33列开始的。
第21章给出了INCLUDE的例了并说明了如何只针对编第1遍扫视使用该伪操作。
（22）LABEL伪操作。LABEL伪操作允许程序再定义指令标号或数据变量的属性。
它的格式是name LABEL type-specifier。对于标号，LABEL允许把可执行代码再定义为NEAR，FAR或PROC，
比如进入过程的第二个入口点。对于变量，类型区分符（type-specifier）BYTE，WORD，DWORD，FWORD，
QWORD或TBYTE，或者结构名，可以分别用来再定义数据项和结构名。
例如，LABEL允许程序把一个字段定义成既是DB又是DW。而汇编程序不会使单元计数器前进。
以下例子说明BYTE和WORD类型，假定是从单元010H开始的。
010   BYTE1 LABEL BYTE   ;把第一个字节定义为BYTE1，
010   WORD1 DW 2532H   ;最先两个字节为WORD1，
012   WORD2 LABEL WORD   ;第三与第四个字节为WORD2，
012   BYTE2 DB 25H   ;第三个字节为BYTE2，
013             DB 32H   ;第四个字节
...
MOV AL,BYTE1   ;传送第一个字节
MOV BX,WORD2   ;传送第三与第四个字节
第一条MOV指令只传送WORD1的第一个字节。第二条MOV指令传送从BYTE2开始的2个字节。
PTR操作符实现类似的功能。
（23）.LIST伪操作。.LIST伪操作（默认）使汇编程序列出源程序。可以有不需要列出来的代码块，
因为它是和其他程序共用的。在这种情况下，可以使用.XIST（或 .NOLIST）伪操作中止列表，然后使用.LIST恢复列表。
这些伪操作都不需要操作数。
（24）.MODEL伪操作。这个简化段伪操作产生默认段以及所要求的ASSUME与GROUP语句。
它的格式是：.MODEL memory-model，其中memory-mode（存储模型）如下所示：
Tiny（微）。代码与数据在一个段内用于.COM程序。
Small（小型）。代码在一个段内（<=64K），数据在一个段内（<=64K）。
Medium（中型）。任意个代码段，数据在一个段内（<=64K）。
Compact（紧凑型）。代码在一个段内（<=64K），任意个数据段。
Large（大型）。代码与数据均为任意个段，无>64K数组。
Huge（巨型）。代码与数据均为任意个段，数组可>64K。
Flat（平面型）。不分段，运行在保护模式下，用32位地址。
（25）.NOLIST伪操作。（参见.XLIST伪操作。）
（26）ORG伪操作。考虑一个有以下定义的数据段：
偏移值         名字         操作         操作数         单元计数器
00         WORD1         DW         2542H         02
02         BYTE1            DB          36H            03
03         WORD2         DW         212EH         05
05         BYTE2            DD         00000705H         09
最初，汇编程序的单元计数器被设置为00。由于WORD1是2个字节，单元计数器为定位下一个项要增加到02。
由于BYTE1是一个字节，单元计数器增加到03，以此类推。
可以使用ORG伪操作修改单元计数器的内容并相应地定位下一个定义的项。它的格式是ORG expression，
其中expression必须为2字节的绝对数而不能是符号名。
假设以下数据项是在上面定义的BYTE2后被立即定义的：
偏移值         名字         操作         操作数         单元计数器
                                 ORG         0
00         BYTE3         DB         ?                           01
01         WORD3         DW         ?                  03
03         BYTE4         DB         ?                           04
                                 ORG         $+5
第一个ORG把单元计数器复位为00。跟着的变量BYTE3、WORD3和BYTE4要把原来定义为WORD1、BYTE1和
WORD2的存储单元分别重新定义。
最后的ORG中，操作数包含一个美元符（$），它表示单元计数器的当前值。
因此，操作数$+5把单元计数器置成04+5，即09，这和BYTE2定义之后的设置一样。
对WORD2的引用是位于偏移值03处的1字的字段，而对于BYTE4的引用则是在偏移值03处的1字节的字段：
MOV AX,WORD2   ;一个字
MOV AL,BYTE4   ;一个字节
当使用ORG再定义存储单元时，要保证单元计数器复位成正确的值，同时应把所有再定义的存储单元都考虑在内。
再定义的变量不应当包含被定义的常数――这些常数会覆盖原来的常数。ORG不能出现在STRUC定义内。
（27）%OUT/ECHO伪操作。这个操作告诉汇编程序向标准输出设备（通常是屏幕）发出一条信息（message）
（MASM6.0以后，名为ECHO）。该伪操作的格式是%OUT/ECHO message。“.ERR伪操作”一节给出了例子。
（28）PAGE伪操作。PAGE伪操作在源程序的起点指定汇编程序列在一页中的最大行数和一行中的最大字符数。
它的格式是PAGE [ [length]，width]。例如，PAGE 60,132设置每页60行和每行132个字符。
每页的行数可以在10到255行范围内，而每行的字符数可在60到132个范围内。
省略PAGE语句汇编程序默认为PAGE 50，80。为了强制一页在指定行上退出来（比如在一个段的末尾），
编写不带操作数的PAGE。
（29）PROC伪操作。过程是由PROC伪操作开始而由ENDP结束的代码块。
虽然从技术上说，可以直接进入或者使用JMP指令进入一个过程，
但通常的做法是使用CALL进入并用RETN或RETF退出。CALL的操作数可以是NEAR或FAR类型的区分符。
与调用过程在同一段的过程是NEAR过程，它是用偏移值访问的，格式是procedure-name PROC [NEAR]。
省略操作数默认为NEAR。如果被调用的过程在调用段的外部，那么它必须表示成PUBLIC，
而且应当使用CALL进入它。
对于.EXE程序，作为执行入口点的主PROC必须是FAR。
（30）处理器伪操作。这些伪操作定义汇编程序要识别的处理器。处理器伪操作可以放在程序的开始，
或放在你希望处理器特性被允许或被禁止的地方。默认模式是8086。
.286，.386，.486，以及.586允许所有低于被命名处理器的指令系统有效（例如，.386允许.286和.8086。）。
.286P，386P，486P.以及.586P允许刚才提到的所有指令系统以及处理器特权指令。
（31）PUBLIC伪操作。PUBLIC伪操作通知汇编程序与连接程序：在汇编中它所标识的符号是被与当前模块连接的
另一模块所引用的。格式是PUBLIC symbol[，…]，其中symbol（符号）可以是标号，数（在2字节的范围内）或
变量。参见“EXTRN伪操作”一节和第22章的例子。
（32）RECORD伪操作。RECORD伪操作允许定义位模式，比如颜色模式和一位或多位开关指示器。它的格式是
record-name RECORD field-name:width[=exp][,...]
record-name（记录名）和field-name（字段名）可以是任何唯一的有效标识符。
跟在每个字段名后的是冒号（：）和宽度（width）（它指定位数）。宽度项的范围是1到32位。
长度达到8变成8位，9到16变成16位，而17到32则变成32位，如有必要，还要有内容的右对准。
下面的例子使用RECORD伪操作定义BIT_REC：
BIT_REC RECORD BITS1:3,BITS2:7,BITS3:6
BITS1定义BITREC的前面3位，BITS2定义接下去的7位，BITS3定义最后6位。总数是16位，或一个字。
可以把记录中的值初始化如下：
BIT_REC2 RECORD BITS1:3=101B,BITS2:7=0110110B,BTTS3:6=011010B
注意，RECORD定义不进行任何存储。因此，在数据段中，跟着RECORD定义，
必须编写另一个语句为记录分配存储器。定义唯一有效的名字，记录名，以及对尖括号（小于和大于符号）
组成的操作数：
DEF_BITS BIT_REC <>
在数据段中对DEF_BITS的分配产生目标码AD9AH（按9A AD存放）。该尖括号还可以包含再定义BIT_REC的项。
图25-1的部分程序把BIT_REC定义为RECORD，但记录字段没有初始值。
在这种情况下，数据段中的分配语句就像尖括号内所示的那样去初始化每个字段。
记录专用的操作符是WIDTH，shift count，以及MASK。
使用这些操作符允许修改RECORD定义而不必修改引用它的指令。
①WIDTH操作符。WIDTH操作符回送宽度，该宽度是RECORD或RECORD字段的位数。
例如，图25-1中，跟在标号A20后面的是2个WIDTH的例子。第一个MOV回送整个记录BIT_REC的宽度（16位）；
第二个MOV回送记录字段BITS2的宽度（7位）。在两种情况下，汇编程序都为宽度产生了立即操作数。
②Shift count（移位计数）。直接引用RECORD字段，比如MOV CL,BITSB是不能引用BITSB内容的。
替代的办法是：汇编程序产生一个包含移位计数的立即操作数分隔该字段。
该立即数表示必须把BITSB移位到右对准的位数。图25-1中，跟在A30后面的3个例子分别回送BITSA、BITSB和BITSC
的移位计数值。
③MASK操作符。MASK（屏蔽）操作符回送屏蔽，含有1的位表示指定字段，实际上它定义了该字段占有的位的位置。
例如，BIT_REC中所定义的每个字段的屏蔽是：
BITSA 111 0000000000000    E000
BITSB 000 1111111000000    1FC0
BITSC 000 0000000 111111   003F
图25-1中，跟在A40后面的3条指令回送BITSA、BITSB和BITSC的屏蔽值。
跟在A50和A60后面的指令分别把BISTB和BISTA与BIT_REC分隔开来。
A50把该记录取到AX中并使用BITSB的屏蔽与之相与：
记录：                       101 0110110 011010
AND BITSB的MASK：000 1111111 000000
结果：000 0110110 000000
结果是除了BITSB那些位外，清除所有位。接下来的2条指令使AX移6位，这样BITSB
被右对准为：000000 000 0110110（0036H）
跟在A60后面的例子把记录取到AX中，由于BITSA是最边的字段，例行程序只是使用移位因子右移13位：
0000000000000101（0005H）
.DATA
BIT_REC RECORD BITSA:3,BITSB:7,BITSC:6
DEF_BITS BIT_REC <101B,0110110B,011010B>
...
.CODE
...
A20:MOV BH,WIDTH BIT_REC
MOV AL,WIDTH BITSB
A30:MOV CL,BITSA
MOV CL,BITSB
MOV CL,BITSC
A40:MOV AX,MASK BITSA
MOV BX,MASK BITSB
MOV CX,MASK BITSC
A50:MOV AX,DEF_BITS
AND AX,MASK BITSB
MOV CL,BITSB
SHR AX,CL
A60:MOV AX,DEF_BITS
MOV CL,BITSA
SHR AX,CL
...
（33）SEGMENT伪操作。汇编模块由一个或多个段、段的一部分或几个段的相同部分组成。段的格式是
segment-name SEGMENT [align] [combine] ['class']
...
segment-name ENDS
align，combine和class操作数是可选的。
Align（对准）。这一操作数指明段的起始边界：
BYTE下一个地址
WORD下一个偶地址（可被2整除的）
DWORD下一个双字地址（可被4整除的）
PARA下一个小段（可被16或10H整除的）
PAGE下一个页地址（可被256或100H整除的）
PARA通常用于所有类型的段。BYTE和WORD可以用于与其他段组合的段，通常是数据段。
Combine（组合）。组合操作数NONE，PUBLIC，STACK，以及COMMON 指定连接程序处理段的方法：
NONE（默认的）：该段在逻辑上是与其他段分隔开的，然而它可以物理上与其他段相邻。该段假定有自己的基地址。
PUBLIC:LINK 把同名和同类别的PUBLIC段相互邻接地装入。对于所有这样的PUBLIC段假定只有一个基地址。
STACK:LINK对STACK的处理和PUBLIC一样。在被连接的.EXE程序中，至少必须定义一个堆栈。
如果有一个以上的堆栈，则SP和第一个堆栈相关联。
COMMON：如果COMMON段具有相同的名字和类别，那么连接程序给它们同样的基地址。
在执行期间，第二个段覆盖到第一个段上。即使最大的段被覆盖，它还是决定了公用区的长度。
AT小段地址：小段必须预先定义。该项便于在存储器的固定区域内的固定偏移地址处定义标号和变量，
比如在存储器低端的中断表或40[0]H处的BIOS数据区。例如，定义视频显示区的单元为：
VIDEO_RAM SEGMENT AT 0B800H
汇编程序建立一个虚段，它实际上提供了存储单元的映像。
Class（类别）。这一项目帮助连接程序把不同名的段联系起来，识别段，以及控制它们的次序。
类别可以包含任何单引号中的有效名字。连接程序使用此名字把有相同名字和类别的段联系在一起。
典型的例子是'Data'和'Code'。如果定义一个类别'Code'，那么连接程序希望那个段里包含指令码。
另外，CODEVIEW调试程序希望类别'Code'作为代码段。
连接程序把下面2个具有同名（CSEG）和同类别（'Code'）的段组合在一起成为在同一段寄存器中的物理段：
module1
CSEG SEGMENT PARA PUBLIC 'Code'
ASSUME CS:CSEG
...
CSEG ENDS
...
module2
CSEG SEGMENT PARA PUBLIC 'Code'
ASSUME CS:CSEG
...
CSEG ENDS
为了控制一个程序内段的排列次序，了解连接程序如何处理这一过程是有用的。
段名的原始次序提供了基本的序列，借助于PUBLIC属性和类别名可以不考虑这个序列。
下面的例子说明了连接前的2个目标模块（2个模块都包含名为DATASEG1的段，
这两个段具有PUBLIC属性和相同的类别名）：
module1 STACK SEGMENT PARA STACK
module1 DATASEG1 SEGMENT PARA PUBLIC 'Data'
module1 DATASEG2 SEGMENT PARA
module1 CODESEG SEGMENT PARA 'Code'
module2 DATASEG1 SEGMENT PARA PUBLIC 'Data'
module2 DATASEG2 SEGMENT PARA
modu1e2 CODESEG SEGMENT PARA 'Code'
在.OBJ模块被连接以后，.EXE模块看来就像这样：
module1 CODESEG SEGMENT PARA 'Code'
module2 CODESEG SEGMRNT PARA 'Code'
modules 1+2 DATASEG1 SEGMENT PARA PUBLIC 'Data'
module1 DATASEG2 SEGMENT PARA
module2 DATASEG2 SEGMENT PARA
module1 STACK SEGMENT PARA STACK
可以嵌套段，一个被嵌套的段完全包含在另一个段之内。下面的例子中，DATASEG2是完全包含在DAIASEG1中的：
DATASEG1 SEGMENT
...   ;DATASEG1开始
DATASEG2 SEGMENT
...   ;DATASEG2区
DATASEG2 ENDS
...   ;DATASEG1再继续
DATASEG1 ENDS
.ALPHA，.SEQ，以及DOSSEG伪操作和汇编程序选项/A与/S也可以控制段的次序
（把各段组合成组，见GROUP伪操作）。
（34）.SEQ伪操作。这一伪操作（默认的）放在程序起点上或附近，它告诉汇编程序保留段的原始序列。
也可以使用汇编程序命令行选项/A（参见.ALPHA和DOSSEG伪操作）。
（35）.STACK伪操作。这个简化段伪操作定义堆栈。它的格式是.STACK [size]，其中默认的堆栈大小是1024个字节，
它是可以自行定义的（参见.MODEL伪操作）。
（36）.STRATUP伪操作。可以在代码段的起点使用这个伪操作初始化DS、SS和SP。
参见.EXIT伪操作。
（37）STRUC/STRUCT伪操作。STRUC伪操作（MASM6.0以后是STURCT）便于定义结构内的相关字段。
它的格式是
structure-name STRUC/STRUCT
[所定义的字段]
structure-name ENDS
一个结构用它的名字和伪操作STRUC开始，并且用它的名字和伪操作ENDS结束。
汇编程序识别从该结构起点开始（一个接一个地）所定义的字段。有效的项目是DB，DW，DD，DQ，以及DT，
它们是用可选的字段名定义的。
在图25-2的部分程序中，STRUC定义一个名为PARAMLIST的参数表，它是用于使用INT21H的功能0AH去通过
键盘输入一个名字。注意，像RECORD伪操作一样，STRUC实际上不进行任何存储操作。
为了给结构分配存储区，分配语句是必需的，使得结构在程序中是可寻址的：
PARAMS PARAMLIST <>
这个例子中的尖括号是空的，但是可以利用它们去再定义（或废弃）在结构内的数据。
指令可以用结构名直接引用该结构。为了引用在结构中的字段，指令必须根据所用的结构分配名
（在例子中是PARAMS），接着用一个点把它与字段名连接起来形成一个整体。例如，
MOV AL,PARAMS.ACTLEN。
还可以使用分配语句（在图25-2中的PARAMS）去重定义在结构内的字段内容。
.DATA
PARAMLIST STRUC
MAXLEN DB 25
ACTLEN DB ?
NAMEIN DB 25 DUP (20H)
PARAMLIST ENDS
PARAMS PARAMLIST <>
PROMPT DB 'What is the part no.?'
...
.CODE
MOV AH,40H
MOV BX,0001H
MOV CX,21
LEA DX,PROMPT
INT 21H
MOV AH,0AH
LEA DX,PARAMS
INT 21H
MOV AL,PARAMS.ACTLEN
...
（38）SUBTTL/SUBTITLE伪操作。SUBTTL伪操作（MASM6.0以后是SUBTITLE）
把最多达60个字符的子标题打印在汇编源列表每页的行3上。可以任意次地编写这一伪操作。
它的格式是SUBTTL/SUBTITLE text。
（39）TEXTEQU伪操作。这一伪操作（由MASM6.0引入的）的格式是TEXTEOU [text-item]。
操作数text-item（文本项）可以是用字母表示的串，%开头的常数，或宏功能回送的串。
（40）TITLE伪操作。TITLE伪操作把最多达60个字符的标题打印在源列表每页的行2上。
只能按照格式TITLE text在起点上编写TITLE一次。
（41）.XCREF/.NOCREF 伪操作。.XCREF伪操作（MASM6.0以后是.NOCREF）
通知汇编程序压缩交叉引用表。它的格式是.XCREF[name[，name]…]。省略操作数使表中的所有项目都被压缩。
也可以只压缩交叉引用的特殊项目。下面是，.XCREF和.CREF的例子：
.XCREF   ;压缩所有交叉引用
.CREF   ;恢复所有交叉引用
.XCREF FIELDA,FIELDB   ;压缩两项交叉引用
（42）.XLIST/.NOLIST 伪操作。可以使用.XLIST伪操作（MASM 6.0以后是.NOLIST）
在源程序的任何地方中止对被汇编程序的列表。典型的位置是与其他程序公用的那些语句所在地，
以及不需要其他列表的地方。.LIST伪操作（默认的）恢复列表。使用这些伪操作不带操作数。
第26章PC指令系统
26.1引言
26.2寄存器表示法
26.3寻址方式字节
26.4指令系统
目的：解释机器码，介绍PC指令系统
26.1引言
这一章解释机器码并提供一个带有用途说明的符号指令列表。
许多指令都有它特定的用途，以至于1字节机器语言指令代码已经足够用了。下面是一些例子：
机器码                  符号指令                  注释
40                  INC AX                    AX加1
50                  PUSHAX                  AX进栈
C3                  RET（short）         从过程短返问
CB                  RET（far）             从过程远返回
FD                  STD                        设置方向标志
这些指令都无法直接访问存储器。指定一个立即操作数，两个寄存器，或访问存储器的指令要复杂一些，
并且要求2个或更多的机器码字节。
机器码对于指明特定寄存器有专门的规定，并对用寻址方式字节访问存储器有另外的规定。
26.2寄存器表示法
访问寄存器的指令可以有指定寄存器的3位并可以有指明宽度是字节（0）还是字（1）的w位。
而且，只有某些指令可以访问段寄存器。图26-1说明寄存器的表示法。
例如，当w位为0时，位值000指的是AL；而w位为1时，则指的是AX。
这里是具有1字节立即操作数的MOV指令的符号与机器码：
MOV AH,0                   10110 100 00000000
                                           w reg=AH
在这种情况下，机器码的第一个字节指明一个字节的宽度（w=0），并指的是AH（100）。
下面是包含一个字立即操作数的MOV指令，以及它所产生的机器码：
MOV AX,0                  10111 000 00000000 00000000
                                         w reg=AX
机器码的第一个字节指明一个字的宽度（w=1），并指的是AX（000）。
位                  w=0                  w=1
000                  AL                  AX/EAX
001                  CL                  CX/ECX
010                  DL                  DX/EDX
011                  BL                  BX/EBX
100                  AH                  SP
101                  CH                  BP
110                  DH                  SI
111                  BH                  DI

位
000         ES
001         CS
010         SS
011         DS
100         FS
101         GS
图26-1寄存器表示法
对于其他指令，w和reg可能占有不同位置。机器码的第一个字节指明流向（左/右）的d位。
机器码练习。试使用调试程序进行以下有关机器码的练习（对于DEBUG，使用命令A 100）、
按这样的次序输入MOV reg,0 指令：AL，CL，DL，BL，AH，CH，DH，BH，AX，CX，DX，BX，SP，BP，
SI，以及DI。注意机器码是如何从B0到BF增量的。
26.3寻址方式字节
当寻址方式字节存在时，会占有机器码的第二个字节，并由以下3个元素组成：
mod   2位，表示方式，其中值00、01和10指的是存储单元，而11指的是寄存器。
reg   3位，引用寄存器。
r/m   3位，引用寄存器或存储器，其中r指的是寄存器，而m指明存储器地址。
在以下把AX加到BX的例子中：
ADD BX,AX 00000011 11 011 000
                             dw mod reg r/m
d=1的意思是mod（11）和reg（011）描述第一个操作数，而r/m（000）描述第二个操作数。
由于w=1，所以宽度是一个字。因此，该指令是把AX（000）加到BX（011）中。
目标码的第二个字节说明了大多数存储器寻址方式。可以使用DEBUG检验该例子：键入机器码为E 100 03 D8
并用U 100 101来反汇编它。
Mod位。2个mod位区分是寄存器寻址还是存储器寻址。下面说明它们的用途：
00   r/m位给出严格的寻址选项；无偏移字节（除r/m=110之外）。
01   r/m位给出严格的寻址选项；一个偏移字节。
10   r/m位给出严格的寻址选项；两个偏移字节。
11   r/m指定寄存器。w位（在操作码字节中）决定访问的是8位、16位或32位的寄存器。
Reg位。3个reg位与w位相结合来确定实际宽度。
R/M位。3个r/m（寄存器/存储器）位与mod位相结合来确定寻址方式，如图26-2所示：
r/m         mod=00         mod=01 或10         mod=11         mod=11
                                                                  w=0                  w=1
000         BX+SI         DS:[BX+SI+disp]         AL                  AX
001         BX+DI        DS:[BX+DI+disp]         CL                  CX
010         BP+SI         SS:[BP+SI+disp]          DL                  DX
011         BP+DI        SS:[BP+DI+disp]         BL                   BX
100         SI               DS:[SI+disp]               AH                  SP
101         DI               DS:[DI+disp]              CH                  BP
110         Direct         DS:[disp]                    DH                  SI
111         BX             DS:[BX+disp]               BH                  DI
图26-2 r/m位
26.3.1两字节指令
以下两字节指令把BX加到AX上：
ADD AX,BX         0000 0011 11 000 011
                                      dw mod reg r/m
d=1         reg加上w描述第一个操作数（AX），而mod加上r/m再加上w描述第二个操作数（BX）。
w=1         宽度是一个字。
mod=11   第二个操作数是寄存器。
reg=000   第一个操作数是AX。
r/m=011   第二个操作数是BX。
下一个例子是AL乘以BL：
MUL BL 111101 10 11 100 011
                           w mod reg r/m
宽度（w=0）是一个字节，mod（11）引用寄存器，寄存器（r/m=011）是BL。
Reg=100在这里没有意义。如果乘数是一个字节（如在本例中），那么处埋器认为被乘数在AL中；
如果乘数是一个字，则认为被乘数在AX中；如果乘数是双字，则认为被乘数在EAX中。
26.3.2三字节指令
以下MOV产生三字节的机器码：
MOV mem-word,AX 1010 0011 mmmmmmmm mmmmmmmm
                                            dw
来自累加器（AX或AL）的传送仅仅需要知道操作是字节还是字。在这个例子中，w=1的意恩是字，
所以采用16位AX（第二个操作数中如编码为AL，则将使w位成为零）。
字节2和字节3包含对于存储单元的偏移值。使用累加器会比其他寄存器产生较短的指令长度和较快的执行速度。
26.3.3四字节指令
以下四字节指令是AL乘以一个存储单元：
MUL mem-byte 1111 0110 00 100 110 mmmmmmmm mmmmmmmm
                                       w mod reg r/m
对于这条指令，虽然reg是100，但还是假定被乘数是AL（一个字节，因为w=0）。
Mod=00指明是存储器访问，而r/m=110的意思是直接引用存储器，2个后继的字节提供对于存储单元的偏移值。
下面的例子说明LEA指令，它指定・个字地址：
LEA DX,memory 1000 1101 00 010 110 mmmmmmmm mmmmmmmm
                                         mod reg r/m
reg=010指明DX；mod=00和r/m=110指明直接引用存储器地址；后面2个字节提供对于这一单元的偏移值。
26.4指令系统
这一节涉及按字母顺序排列的指令系统。为了方便起见，一些密切相关的指令（如条件转移）是组合在一起的。
80286和后继的处理器支持的许多特殊指令没有在这里介绍，它们是：
ARPL，BOUND，CLTS，LAR，LGDT，LIDT，LLDT，LMSW，LSL，LTR，SGDT，SIDT，SLDT，SMSW，STR，
VERR，以及VERW。80486及其后继型号特有的指令：BSWAP，INVD，WBINVD，以及INVLPG也没有包括在内。
对双字寄存器或存储单元的引用包含在80386或后继的处理器中。
除前面讨论的方式字节和宽度位外，以下缩写词是有关系的：
addr   存储单元的地址。
addr-high   地址的最右边字节。
addr-low   地址的最左边字节。
data   立即操作数（如w=0，是8位；如w=1，是16位）。
data-high   立即操作数的最右边字节。
data-low   立即操作数的最左边字节。
disp   位移量（偏移值）。
reg   引用的寄存器。
标志的缩写词如下：AF=辅助，CF=进位，DF=方向，IF=中断，OF=溢出，PF=奇偶，SF=符号，TF=陷阱，以及
ZF=零。
26.4.1AAA：加法后的ASCII调整
校正2个ASCII字节在AL中的和（ADD之后的）。如果AL最右边4位的值大于9，或者如果AF被置成1，
则AAA将AH加1，AL加6，并使AF与CF置1。否则，清除AF与CF。
AAA总是清除AL最左边的4位。
标志：影响AF和CF（OF，PF，SF和ZF未定义）。
源码：AAA（无操作数）。目标码：00110111
26.4.2AAD：除法前的ASCII调整
在除法之前，调整在AX中的非压缩BCD值（被除数）。AAD将AH乘以10，把乘积加到AL上并清除AH。
在AX中结果的二进制值，现在等效于原来的非压缩BCD值，并为二进制除法操作准备就绪。
标志：影响PF，SF，以及ZF（AF，CF和OF未定义）。
源码：AAD（无操作数）目标码：1101 0101 0000 1010
26.4.3AAM：乘法后的ASCII调整
调整由2个非压缩BCD数字相乘所产生的AL中的乘积。AAM将AL除以10，并把商放在AH，把余数放在AL中。
标志：影响PF，SF和ZF（AF，CF和OF未定义）。
源码：AAM（无操作数）目标码：1101 0100 0000 1010
26.4.4AAS：减法后的ASCII调整
调整在AL中的2个ASCII字节差（SUB之后）。如果最右边4位的值大于9，或者进位标志是1，则AAS从AL中减6，
从AH中减1，并使AF和CF置1。否则，清除AF和CF。
AAS总是清除AL的最左边4位。
标志：影响AF和CF（OF，PF，SF和ZF未定义）。
源码：AAS（无操作数）目标码：0011 1111
26.4.5ADC：带进位加法
常用于二进制多字加法，把溢出的1的位带到算术运算的下一级。ADC把进位标志的内容（0/1）加到操作数1，
然后就像ADD一样，把操作数2加到操作数1上（参见SBB）。
标志：影响AF，CF，OF，PF，SF和ZF。
源码：ADC register/memory，register/memory/immediate
目标码：3种格式：
reg/mem 与reg：0001 00 dw mod reg r/m
immed（立即数）到accumulator（累加器）：0000 010w data
immed到reg/mem：1000 00 sw mod 010 r/m data
26.4.6ADD：二进制数加法
把来自存储器、寄存器或立即数的二进制值加到寄存器，或者把寄存器或立即数的值加到存储器。
值可以是字节，字或双字。
标志：影响AF，CF，OF，PF，SF和ZF。
源码：ADD register/memory，register/memory/immediate
目标码：3种格式：
reg/mem与reg：0000 00 dw mod reg r/m
immed到accumulator：0000 010 w data
immed到reg/mem：1000 00 sw mod 000 r/m data
26.4.7AND：逻辑与
完成2个操作数按位逻辑与操作。2个操作数必须同时是字节，字或双字，AND要求位与位的匹配。
对于每一对相匹配的位都是1时，在第一个操作数中的1的位被置成1，否则该位被清除。
（参见OR，XOR，以及TEST。）
标志：影响CF（0），OF（0），PF，SF和ZF（AF未定义）。
源码：AND register/memory，register/memory/immediate
目标码；3种格式：
reg/mem与reg：0010 00 dw mod reg r/m
immed 到accumulator：0010 010 w data
immed到reg/mem：1000 00 sw mod 100 r/m data
26.4.8BSF/BSR：位正向扫描/位反向扫描（80386+）为了第一个是1的位，
对操作数2的位串（16或32位）进行扫描。
BSF是从右向左扫描，而BSR则是从左向右扫描。如果找到了是1的位，则操作把它的位置（相对于右边的位0）
回送到操作数1的寄存器中，并把零标志置0；否则，该位被置1。
标志：影响ZF。
源码：BSF/BSR register，register/memory
目标码：BSF：0000 1111 1011 1100 mod reg r/m
             BSR：0000 1111 1011 1101 mod reg r/m
26.4.9BT/BTC/BTR/BTS：位测试（80386+）
把指定的位复制到进位标志。操作数1包含被测试的位串，操作数2包含指明该位位置的值。
BT简单地把该位复制到CF。其他指令也复制该位，同时还会影响操作数1中对应的位：
BTC用将操作数1中该位的值变反的方法对位求反；BTR用把该位清零的办法进行复位；BTS把该位置成1。引用是对16或32位值进行的。
标志：影响CF。
源码：BT/BTC/BTR/BTS register/memory，register/immediate
目标码：2种格式：
immed对reg：0000 1111 1011 1010 mod *** r/m
reg/mem对reg：0000 1111 10 *** 010 mod reg r/m
***的意思是100=BT，111=BTC，110=BTR，101=BTS）
26.4.10CALL：调用一个过程
调用一个近的或远的过程。如果被调用的过程是NEAR，汇编程序产生一个近CALL；
如果被调用过程是FAR，则产生一个远CALL。近CALL使IP进栈（下一条指令的偏移值），然后把目的偏移值装入IP。
远CALL使CS进栈并把目的段地址装入CS，然后使IP进栈并把目的偏移值装入IP。
在返回时，后继的RETN或RETF则用来把这些步骤反过来进行。
标志：不受影响。
源码：CALL rigister/memory/procedure-name
目标码：4种格式：
段内直接：1110 1000 disp-low disp-high
段内间接：1111 1111 mod 010 r/m
段间间接：1111 1111 mod 011 r/m
段间直接：1001 1010 offset-low offset-high seg-low seg-high
26.4.11CBW：字节转换为字
用把AL的符号（位7）复制到AH所有位的方法，把1字节带符号值扩展为带符号的字。
（还可见于MOVSX）
标志：不受影响。
源码：CBW（无操作数）目标码：1001 1000
26.4.12CDQ：双字转换为四字（80386+）
用把EAX的符号（位31）复制到整个EDX的方法，把32位带符号值扩展为64位带符号的值。
标志：不受影响。
源码：CDQ（无操作数）目标码：1001 1001
26.4.13CLC：清除进位标志
清除CF，例如，可连ADC不加1（参见STC）。
标志：CF（置0）。
源码：CLC（无操作数）目标码：1111 1000
26.4.14CLD：清除方向标志清除DF，使得如MOVS那样的串操作从左到右进行处理（参见STD）。
标志：DF（置0）
源码：CLD（无操作数）目标码：1111 1100
26.4.15CLI：清除中断标志
清除IF，禁止可屏蔽的外部中断（参见STI）。
标志：IF（置0）。
源码：CLI（无操作数）目标码：1111 1010
26.4.16CMC：进位标志变反
CF位的值变反：0变成1，1变成0。
标志：CF（反向）。
源码：CMC（无操作数）目标码：1111 0101
26.4.17CMP：比较
比较2个数据字段的二进制内容。CMP从操作数1中减去操作数2，并设置/清除标志，但不存结果。
而2个操作数都是字节、字或双字。CMP可以进行寄存器、存储器或立即数与寄存器的比较，
或者进行寄存器或立即数与存储器的比较（CMP做数值比较，串比较见CMPS）。结果如下：
                           CF         SF         ZF
操作数1<操作数2  1           1         0
操作数1=操作数2  0           0         1
操作数1>操作数2  0           0         0
标志：影响AF，CF，OF，PF，SF和ZF。
源码：CMP register/memory，register/memory/immediate
目标码：3种格式：
reg/mem与reg：0011 10dw mod reg r/m
immed 对accumulator：0011 110 w data
immed 对reg/mem：1000 00 sw mod 111 r/m data
26.4.18CMPS/CMPSB/CMPSW/CMPSD：串比较
对存储器中任意长度的串进行比较。REPn前缀通常和CX中的最大值一起放在这些指令的前面。
CMPSB比较字节，CMPSW比较字，而CMPSD（80386+）则是比较双字。
DS:SI寻址操作数1，ES:DI寻操作数2。如果方向标志是0，则比较操作从左到右进行并且SI与Dl加1（对于字节），
加2（对于字），以及加4（对于双字）；如果DF是1，则比较从右到左进行并使SI与DI减量。
REPn对于每次重复都使CX减1。REPNE第一次发现匹配时，结束操作：REPE第一次发现不匹配时，结束操作；
或者当CX减到0时，二者均结束操作。在结束时，DI与SI前进了一步，超过了产生结束的字节。
最后的比较要设置/清除标志。
标志：影响AF，CF，OF，PF，SF和ZF。
源码：[REPnn]CMPSB/CMPSW/CMPSD（无操作数）
目标码：1010 011w
26.4.19CMPXCHG：比较并交换（80486+）
比较累加器（AL，AX或EAX）和操作数1。如果相等，则CMPXCHG把操作数2复制到操作数1，并使零标志置1；
如果不相等，则CMPXCHG把操作数1复制到累加器2并清除ZF。操作数1和操作数2被编码，
而累加器的第3个元素则不编码。
标志：影响AF，CF，OF，PF，SF和ZF。
源码：CMPXCHG register/memory，register
目标码：Hex 0F B0/r或0F B1/r
26.4.20CMPXCHG8B：比较并交换（Pentium+）
比较64位的EDX:EAX和操作数。如果相等，CMPXCHG8B把EDX:EAX装入到操作数中，并使零标志置1；
如果不相等，则把操作数装入到EDX:EAX，并清除ZF。
标志：影响ZF。
源码：CMPXCHG8B register/memory（一个操作数，64位）。
目标码：Hex 0F C7
26.4.21CWD：字转换为双字
用把AX的符号（位15）复制到整个DX的方法，把一个字的带符号值扩展为在DX:AX中的带符号双字，
通常用来产生一个32位的被除数（参见CBW和MOVSX）。
标志：不受影响。
源码：CWD（无操作数）目标码：10011001
26.4.22CWDE：字转换为扩展的双字（80386+）
用复制AX的符号（位15）的方法，把一个字的带符号值扩展为EAX中的双字，典型地用来产生一个32位的被除数
（参见CWD和MOVSX）。
标志：不受影响。
源码：CWDE（无操作数）目标码：10011000
26.4.23DAA：加法后的十进制调整
在ADD或ADC把2个压缩的BCD项相加之后，校正在AL中的结果。
如果最右边4位的值大于9，或辅助标点（AF）是1，则DAA使AL加6并使AF置1。
如果在AL中的值大于99H，或如果进位标志（CF）是1，则DAA把60H加到AL中并使CF置1。
否则，清除AF与CF。现在，AL包含一个正确的2个数位的压缩十进制结果（参见DAS）。
标志：影响AF，CF，PF，SF和ZF（OF未定义）。
源码：DAA（无操作数）目标码：00100111
26.4.24DAS：减法后的十进制调整
在SUB或SBB把2个压缩的BCD项相减之后，校正在AL中的结果。
如果最右边4位的值大于9，或辅助标志（AF）是1，则DAS使AL减去6，并使AF置1。
如果AL中的值大于99H或进位标志（CF）是1，则DAS从AL中减去60H，并使进位标志置1。
否则，清除AF和CF。现在AL包含一个正确的2个数位的压缩十进制值（参见DAA）。
标志：影响AF，CF，PF，SF和ZF（OF未定义）。
源码：DAS（无操作数）
目标码：00101111
26.4.25DEC：减1
从寄存器或存储器的一个字节、字或双字中减1，并把该值看成是一个无符号整数（参见INC）。
标志：影响AF，OF，PF，SF和ZF。
源码：DEC register/memory
目标码：2种格式：
register：0100 1 reg
reg/memory：1111111 w mod 001 r/m
26.4.26DIV：无符号数除法
在操作数1中的无符号被除数除以无符号除数。DIV把最左边的1位看作是数据位，没有负的符号。
除以零会引起除以零中断（参见IDIV）。以下是按被除数大小而确定的除法操作；
大小         被除数                  除数                  商         余数         举例
            （操作数1）         （操作数2）
16位         AX         8位寄存器/存储器         AL            AH         DIV BH
32位         DX:AX   16位寄存器/存储器         AX          DX         DIV CX
64位         EDX:EAX  32位寄存器/存储器      EAX         EDX       DIV ECX
标志：影响AF，CF，OF，PF，SF和ZF（全部未定义）。
源码：DIV register/memory
目标码：1111 011w mod 110 r/m
26.4.27 ENTER：建立堆栈帧（80286+）
建立堆栈帧，用于被调用的过程接收传送的参数。操作数1给出以字节为单位的堆栈帧大小，
操作数2指明嵌套层（对于BASIC，C，以及FORTRAN编译程序而言，嵌套层为0）。
该操作使BP进栈，把SP传送到BP，并且从SP中减去帧大小。（见作为互补指令的LEAVE）。
标志：不受影响。
源码：ENTER size,nesting-level
目标码：11001000 data1 data2
26.4.28HLT：进入暂停状态
在等待硬件中断时，使处理器进入暂停状态。当一个中断发生时，处理器使CS与IP进栈并执行中断例行程序。
在返回时，IRET指令使堆栈中的内容出栈，并且恢复处理紧跟在原来的HLT之后的指令
（首先必须用STI操作使IF置1，以便允许硬件中断）。
标志：不受影响。
源码：HLT（无操作数）目标码：11110100
26.4.29IDIV：带符号（整数）除法
带符号的被除数除以带符号的除数。IDIV把最左边的位看作是符号（0=正，1=负）。除以零会引起除以零中断
（见CBW和MOVSX扩展带符号被除数的长度，还可参见DlV）。下面是按照被除数大小而确定的除法操作：
大小                  被除数                  除数                  商                  余数                  举例
                  （操作数1）         （操作数2）
16位                  AX                  8位寄存器/存储器   AL                  AH                  IDIV BH
32位               DX:AX               16位寄存器/存储器  AX                 DX                  IDIV CX
64位             EDX:EAX             32位寄存器/存储器  EAX               EDX                 IDIV ECX
标志：影响AF，CF，OF，PF，SF和ZF。
源码：IDIV register/memory
目标码：1111011 w mod 111 r/m
26.4.30IMUL：带符号（整数）乘法
带符号的被乘数乘以带符号的乘数。该操作把最左边的位看作符号（0=正，1=负）。IMUL支持4种格式：
1.该操作假定被乘数在AL、AX或EAX中，并且根据乘数的大小来确定其大小（参见MUL）。
下面是按大小而定的该操作：
大小                  被乘数                  乘数                  乘积                  举例
8位                  AL                  8位寄存器/存储器      AX                  IMUL BL
16位               AX                  16位寄存器/存储器   DX:AX               IMUL mem-word
32位               EAX                 32位寄存器/存储器   EDX:EAX           IMUL ECX
其他3种格式引用任何16或32位的通用寄存器，数据项长度必须相同。
2.操作数1（寄存器）包含被乘数，而且所求出的乘积也存放在那里；操作数2是个立即值。如：
IMUL CX,32
IMUL EBX,50
3.操作数1（寄存器）存放求得的乘积；操作数2（寄存器或存储单元）包含被乘数；操作数3是个立即值。如：
IMUL CX,DX,25
IMUL EBX,mem-dblword,100
4.操作数1（寄存器）包含被乘数，并且存放求得的乘积；操作数2（寄存器或存储单元）包含乘数。例如：
IMUL DX,mem-word 
IMUL EBX,EDX
标志：影响CF和OF（AF，PF，SF和ZF未定义）。
源码：4种格式
①IMUL register/memory（所有处理器）
②lMUL register，immediate（80286+）
③IMUL register，register，immediate（80286+）
④IMULregister，register/memory（80386+）
目标码：1111 011w mod 101 r/m（第一种格式）
26.4.31IN：输入字节或字
从输入端口传送一个字节到AL，传送一个字到AX，或传送一个双字到EAX。
端口被编码为固定的数值操作数（如IN AX，port）或编码为DX中的变量（如IN AX，DX）。
如果端口号大于256，则使用DX（参见INS和OUT）。
标志：不受影响。
源码：IN AL/AX，端口号/DX
目标码：2种格式：
变量端口：1110 110w
固定端口：1110 010w port
26.4.32 INC：加1
在寄存器或存储器中的一个字节、一个字或一个双字加1，并把该值看成是无符号整数，
例如编码为INC ECX（参见DEC）。
标志：影响AF，OF，PF，SF和ZF（不影响CF）。
源码：INC register/memory
目标码：2种格式：
register：0100 0reg
reg/memory：1111111 w mod 000 r/m
26.4.33 INS/INSB/INSW/INSD：输人串（80286+）
从端口接收一个串（目的），其目的是用ES:DI寻址，DX包含端口号。INSn通常是和REP前缀，
以及包含被接收项目（如字节、字或双字）数的CX一起使用的。
根据DF（0/1），该操作按项的大小使DI增量或减量（参见IN和OUTS）。
标志：不受影响。
源码：[REP] INSB/INSW/INSD（无操作数）
目标码：0110 110w
26.434INT：中断
进行中断处理和传送控制给中断向量表中256个地址之一。
INT执行以下操作：（1）标志进栈，并复位中断标志与陷阱标志；
（2）CS进栈，并把中断地址的高位字存放在CS中；
（3）IP进栈，并用中断地址的低位字填充IP。
对于80386+来说，INT对于16位段将16位的IP进栈，而对于32位段则使32位IP进栈。
IRET用于从中断例行程序返回。
标志：清除IF与TF。
源码：INT编号
目标码：1100 110v type（如v=0，则type是3）
26.4.35INTO：溢出中断
如果发生溢出（OF被置1），则产生一个中断（通常是无害的），并且执行INT 04H。
该中断地址是在中断向量表的10H单元（参见INT）。
标志：影响IF与TF。
源码：INTO（无操作数）
目标码：1100 1110
26.4.36 IRET/IRETD：中断返回
提供从中断例行程序的远返回。IRET实现以下过程：（1）在栈顶的字出栈进入lP中，sp加2，栈顶又出栈进入CS中；
（2）SP加2，栈顶再出栈进入标志寄存器。这过程把中断原先采取的步骤恢复原状，并实现返回。
对于80386+，使用IRETD（双字）使32位的IP出栈（参见RET）。
标志：影响所有标志。
源码：IRET（无操作数）
目标码：1100 1111
26.4.37Jcondition：条件转移
这节总结了测试各种标志状态的条件转移指令。
如果测试结果是真，该操作把操作数偏移值加到IP并传送控制到CS:IP地址；
如果不是真，则按顺序地继续处理下一条指令。对
于8086~80286，转移必须是短的（-128到127个字节）；
对于80386+，汇编程序假定为近转移（-32768到32767个字节），但可以使用SHORT操作符强制成短转移。
该操作测试标志，但不改变它们。源码是Jcondition label。
所有目标码的格式都是dist nnnn disp，其中disp位对于短转移是0111，对于近转移是1000。
在第一张表中，指令典型地用在比较操作之后，这是操作数1对操作数2的比较：
源码                  目标码                  检查的标志                  用于比较之后
JA                  dist 0111                  CF=0，ZF=0                无符号数据，高于
JAE                dist 0011                  CF=0或ZF=1                无符号数据，高于/等于
JB                  dist 0010                  CF=1，ZF=0                无符号数据，低于
JBE                dist 0110                  CF=1或ZF=1                无符号数据，低于/等于
JE                  dist 0100                  ZF=1                           带符号/无符号数据，等于
JG                 dist 1111                  SF=OF，ZF=0              带符号数据，大于
JGE               dist 1101                  SF=OF或ZF=1               带符号数据，大于/等于
JL                  dist 1100                  SF不等于OF，ZF=0       带符号数据，小于
JLE                dist 1110                  SF不等于OF或ZF=1       带符号数据，小于/等于
JNA               dist 0110                  CF=1或ZF=1                无符号数据，不高于
JNAE             dist 0010                  CF=1，ZF=0                无符号数据，不高/等于
JNB               dist 0011                  CF=0或ZF=1                无符号数据，不低于
JNBE             dist 0111                  CF=0，ZF=0                无符号数据，不低于/等于
JNE               dist 0101                  ZF=0                           带符号/无符号数据，不相等
JNG              dist 1110                  SF不等于OF或ZF=1       带符号数据，不大于
JNGE            dist 1100                  SF不等于OF，ZF=0       带符号数据，不大于/等丁
JNL              dist 1101                  SF=OF或ZF=1               带符号数据，不小于
JNLE            dist 1111                  SF=OF，ZF=0               带符号数据，不小/等于
在第二张表中，指令通常用在算术运算或其他操作之后，操作根据结果清除或设置各个位。
源码                  目标码                  检查的标志                  用于测试
JC                  dist 0010                  CF=1                           如果CF为1
JNC               dist 0011                  CF=0                           如果CF为0
JNO               dist 0001                  OF=0                           如果OF为0
JNP               dist 1011                  PF=0                           如果没有（奇）奇偶性：在低8位中1的个数为奇数时设置
JNS               dist 1001                  SF=0                           如果符号是正的
JNZ               dist 0101                  ZF=0                           如果带符号/无符号数据不是零
JO                 dist 0000                  OF=1                           如果OF为1
JP                 dist 1010                   PF=1                           如果偶奇偶性：在低8位中1的个数为偶数时设置
JPE               dist 1010                   PF=1                           同JP
JPO              dist 1011                   PF=0                           同JNP
JS                 dist 1000                   SF=1                           如果符号是负的
JZ                 dist 0100                   ZF=1                           如果带符号/无符号数据是零
26.4.38JCXZ/JECXZ：若CX/ECX为零则转移
如果CX或ECX为零，则转移到指定的地址。该操作在循环的起点可能是有用的，不过要受短转移的限制。
标志：不受影响。
源码：JCXZ/JECXZ label
目标码：1110 0011 disp
26.4.39JMP：无条件转移
在任意条件下，转移到指定地址。JMP的地址可能是短的（-128到+127个字节），
近的（+32K或-32K之内，默认的），或远的（转到另一个代码段）。短或近JMP用目的偏移地址取代IP。
远转移（如JMP FAR PTR label）用新的段地址取代CS：IP。
标志：不受影响。
源码：JMP register/memory
目标码：5种格式：
段内短直接：1110 1011 disp
段内直接：   1110 1001 disp-low disp-high
段内间接：：1111 1111 mod 100 r/m
段间间接：   1111 1111 mod 101 r/m
段间直接：   1110 1010 offset-low offset-high seg-low seg-high
26.4.40LAHF：标志装人AH
把标志寄存器的低8位装入AH（参见SAHF）。
标志：不受影响。
源码：LAHF（无操作数）目标码：1001 1111
26.4.41LDS/LES/LFS/LGS/LSS：装人段寄存器
操作数1引用任何一个通用、变址或指针寄存器。操作数2引用包含偏移：段地址的存储器中的2个字。
该操作把段地址装入段寄存器中并把偏移值装入操作数1的寄存器中。所用的例子如LDS DI,SEG_ADDRESS，
标志：不受影响。
源码：LDS/LES/LFS/LGS/LSS register，memory
目标码：LDS：1100 0101 mod reg r/m
             LES： 1100 0100 mod reg r/m
             LFS： 0000 1111 1011 0100 mod reg r/m（80386+）
             LGS：0000 1111 1011 0101 mod reg r/m（80386+）
              LSS：0000 1111 1011 0110 mod reg r/m（80586+）
26.4.42LEA：装人有效地址
把近（偏移）地址装入寄存器。
标志：不受影响。
源码：LEA register，memory
目标码：1000 1101
26.4.43LEAVE：终止堆栈帧（80286+）
终止由ENTER操作建立的过程的堆栈帧、LEAVE的动作和ENTER是相反的（传送BP到SP并使BP出栈）。
标志：不受影响。
源码：LEAVE（无操作数）目标码：1100 1001
26.4.44LES/LFS/LGS：装入附加段寄存器（见LDS）
26.4.45LOCK：封锁总线
防止数值协处理器与处理器同时改变数据项。LOCK是个1字节的前缀，可直接写在任何指令的前面。
该操作给协处理器发送一个信号，禁止协处理器使用数据，直到下一条指令完成时为止。
标志：不受影响。源码：LOCK指令
目标码：1111 0000
26.4.46LODS/LODSB/LODSW/LODSD：装人字节串、字串或双字串
把一个值从存储器装入到累加寄存器。虽然LODS是个串操作，但它并不要求REP前缀。
DS:SI寻址一个字节（如果是LODSB），寻址一个字（如果是LODSW），或寻址一个双字（如果是LODSD，
80386+）并分别从存储器装入到AL、AX或EAX中。如果方向标志是0，则SI加1（如果是字节）、加2（如果是字）或
加4（如果是双字）；否则，使SI减1、2或4。
标志：不受影响。
源码：LODS mem或LODS segreg:mem
LODSB/LODSW/LODSD（无操作数）目标码：1010 110w
26.4.47 LOOP/LOOPW/LOOPD：循环直到完成
控制指定次数的例行程序的执行。在开始循环之前CX应当包含计数值。LOOP指令出现在循环的末端并使CX减1。
如果CX是非零，则LOOP传送控制给它的操作数地址（短转移），该地址指向循环的起点（把偏移值加到IP中），
否则，LOOP直达下一条指令。
LOOP在16位方式下使用CX，在32位方式下使用ECX。LOOPW使用CX，而LOOPD（80386+）则使用ECX。
标志：不受影响。
源码：LOOPnn label
目标码：1110 0010 disp
26.4.48LOOPE/L0OPZ/LOOPEW/LOOPZW/LOOPED/LOOPZD：相等/为零时循环
控制例行程序的重复执行。LOOPE与LOOPZ是和LOOP类似的，只有当CX是非零以及零标志是1
（零条件是由另一条指令设置）时，传送控制给操作数地址（短转移）外，否则，该操作直达下一条指令
（参见LOOPNE/LOOPNZ）。
LOOPE和LOOPZ在16位方式下使用CX，在32位方式下使用ECX。LOOPEW和LOOPZW使用于CX，
而LOOPED和LOOPZD（80386+）使用ECX。
标志：不受影响。
源码：LOOPnn label
目标码：1110 0001 disp
26.4.49LOOPNE/LOOPNZ/LOOPNEW/LOOPNZW：不相等/不为零时循环
控制例行程序的重复执行。LOOPNE与LOOPNZ是和LOOP类似的，除了当CX是非零和零标志是0
（非零条件由另一条指令设置）时传送控制给操作数地址（短转移）外，该操作直达下一条指令
（参见LOOPE/LOOPZ）。
LOOPNE和LOOPNZ在16位方式下使用CX，在32位方式下使用ECX。LOOPNEW和LOOPNZW使用CX，
而LOOPNED和LOOPNZD（80386+）使用ECX。
标志：不受影响。
源码：LOOPNnn label
目标码：1110 0000 disp
26.4.50LSS：装入堆栈段寄存器（见LDS）
26.4.51MOV：传送数据
在2个寄存器或寄存器与存储器之间传送数据，并可传送立即数据到寄存器或存储器。
所引的数据定义被传送的字节数（1，2或4），操作数大小必须一致。
MOV不能在2个存储单元之间进行传送（使用MOVS），也不能把立即数据传送到段寄存器或
从段寄存器到段寄存器进行传送（参见MOVSX/MOVZX）。
标志：不受影响。
源码：MOV register/memory，register/memory/immediate
目标码：7种格式：
reg/mem到/从reg：1000 10dw mod reg r/m
immed 到reg/mem：1100 011w mod reg r/m data
immed到register：    1011 w reg data
mem到accumulator：1010 000w addr-low addr-high
accumulator到mem：1010 001w addr-low addr-high
reg/mem 到seg reg:  1000 1110 mod0sg r/m（sg-seg reg）
segreg到reg/mem：  1000 1100 mod0sg r/m（sg-seg reg）
26.4.52 MOVS/MOVSB/MOVSW/MOVSD：传送串
在存储单元之间传送数据。通常和REP前缀与CX中的长度一起使用，MOVSB传送字节，MOVSW传送字，
而MOVSD（80386+）传送双字。操作数1按ES:DI寻址，而操作数2按DS:SI寻址。
如果方向标志是0，则该操作从左到右传送数据到操作数1的目的中，同时DI和SI加1、2或4。
如果DF是1，则该操作从右到左传送数据，并使DI与SI减量。
对于每次重复，REP都使CX减1。当CX被减成0时，该操作结束。
在结束时，DI和SI前进了一步超过了所传送的最后一个字节。
标志：不受影响。
源码：[REP]MOVSB/MOVSW/MOVSD（无操作数）
目标码：1010 010w
26.4.53MOVSX/MOVZX：带符号扩展或带零扩展的传送（80386+）
把8位或16位源操作数复制到较大的16位或32位目的操作数。MOVSX把符号位填充到最左边的各个位，
而MOVZX则填充零。
标志：不受影响。
源码：MOVSX/MOVZX register/memory，register/memory/immediate
目标码：MOVSX：0000 1111 1011 111w mod reg r/m
             MOVZX：0000 1111 1011 011w mod reg r/m
26.4.54MUL：无符号数乘法
无符号的被乘数与无符号的乘数相乘。MUL把最左边的1的位看作是数据位，不是负的符号。
该操作假定被乘数是在AL、AX或EAX中，并根据乘数的大小决定其大小（参见IMUL）。
下面是取决于乘数大小的乘法操作：
大小                  被乘数                  乘数                  乘积                  举例
8位                  AL                  8位寄存器，存储器    AX                  MUL BL
16位                AX                 16位寄存器，存储器   DX:AX            MUIL mem-word
32位               EAX                32位寄有器，存储器   EDX:EAX         MUL ECX
标志：影响CF和OF（AF，PF，SP和ZF未定义）。
源码：MUL register/memory
目标码：1111 011w mod 100 r/m
26.4.55 NEG：求补
将二进制值从正到负反向或从负到正反向。NEG提供指定操作数的二进制补码，采用从零中减操作数再加1的方法。
操作数可以是在寄存器或存储器中的字节、字或双字（参见NOT）。
标志：影响AF，CF，OF，PF，SF和ZF。
源码：NEG register/memory
目标码：1111 011w mod 011 r/m
26.4.56NOP：空操作
用于删除或插入机器码，或为了定时目的的延迟执行。NOP简单地用执行XCHG AX，AX的办法实现一次空操作。
标志：不受影响。
源码：NOP（无操作数）目标码：1001 0000
26.4.57 NOT：逻辑非
把0的位变成1，并把1的位变成0。操作数是在寄存器或存储器中的字节、字或双字（参见NEG）。
标志：不受影响。
源码：NOT register/memory
目标码：1111 011w mod 010 r/m
26.4.58 OR：逻辑或
按2个操作数的位执行逻辑或操作。2个操作数都是字节、字或双字，其中位对位的相匹配。
对于每个相匹配的位对，如果二者中任何一个为1或二者都为1，则在第一个操作数中的该位被置1；
否则，该位不变（参见AND和XOR）。
标志：影响CF（0），OF（0），PF，SF和ZF（AF未定义）。
源码：OR register/memory，register/memory/immediate
目标码：3种格式：
reg/mem与register：0000 10dw mod reg r/m
immed 到accumulator：0000 110w data
immed到reg/mem：1000 00sw mod 001 r/m data
26.4.59OUT：输出字节或字
从AL传送字节、从AX传送字或从EAX传送双字到输出端口。
该端口是个固定的数值操作数或是在DX中的变量。如果端口号大于256，则使用DX（参见IN和OUTS）。
标志：不受影响。
源码：固定端口：OUT port#,AX
          变量端口：OUT DX,AX
目标码：固定端口：1110 011w port
             变量端口：1110 111w
26.4.60OUTS/OUTSB/OUTSW/OUTSD：输出串（80286+）
把串（源）发送到端口。源是按DS:SI寻址的，DX包含端口号。OUTSn通常是和REP前缀及包含被发送项
（如字节、字或双字）数的CX一起使用的。根据方向标志（0/1），
该操作按项的大小使SI增量/减量（参见IN和OUTS）。
标志：不受影响。
源码：[REP]OUTSB/OUTSW/OUTSD（无操作数）
目标码：0110 111w
26.4.61POP：字或双字出栈
把以前进栈的字或双字出栈到指定的目的地―存储单元，通用寄存器或段寄存器。
SP指向在栈顶的当前字，POP把它传送到指定目的地，并使SP加2。
32位操作数表示双字值，并把ESP加4（参见PUSH）。
标志：不受影响。
源码：POP register/memory
目标码：3种格式：
register：01011 reg
segment reg：000 sg 111（sg意思是segment reg）
reg/memory：1000 1111 mod 000 r/m
26.4.62POPA/POPAD：所有通用寄存器出栈
POPA（80286+）使栈顶的8个字出栈到DI，SI，BP，SP，BX，DX，CX和AX（按次序）。
POPAD（80386+）使栈顶的8个双字出栈到EDI，ESI，EBP，ESP，EBX，EDX，ECX和EAX。
SP的值被丢弃而不是被装入。通常，PUSHA/PUSHAD以前已使寄存器进栈。
标志：不受影响。
源码：POPA/POPAD（无操作数）目标码：0110 0001
26.4.63POPF/POPFD：标志出栈
POPF使栈顶的字出栈到16位的标志寄存器中，并使SP加2。
POPFD（80386+）使栈顶的双字出栈到32位的标志寄存器中，并使SP加4。
通常PUSHF已经使标志进栈了
标志：影响所有标志。
源码：POPF/POPFD（无操作数）目标码：1001 1101
26.4.64PUSH：进栈
为后面的使用而使字或双字进栈。SP指向栈顶的当前（双）字。PUSH使SP减2，或使ESP减4，
并从指定操作数传送一个（双）字到新的栈顶。源可以是通用寄存器，段寄存器或存储器（参见POP和PUSHF）。
标志：不受影响。
源码：PUSH register/memory
PUSH immediate（80286+）
目标码：3种格式：
register：0101 0reg
segment reg：000 sg 110（sg意思是segment reg）
reg/memory：11111111 mod 110 r/m
26.4.65PUSHA/PUSHAD：所有通用寄存器进栈
PUSHA（80286+）使AX，CX，DX，BX，SP，BP，SI和DI按次序进栈，并使SP减16。
PUSHAD（80386+）使EAX，ECX，EDX，EBX，ESP，EBP，ESI和EDI进栈，并使SP减32。
通常，POPA/POPAD在后面使寄存器出栈。
标志：不受影响。
源码：PUSHA/PUSHAD（无操作数）
目标码：0110 0000
26.4.66PUSHF/PUSHFD：标志进栈
为后续使用而使标志寄存器的内容进栈。PUSHF使SP减2。PUSHFD（80386+）使32位标志寄存器进栈，
并使SP减4（参见POPF和PUSH）。
标志：不受影响。
源码：PUSHF/PUSHFD（无操作数）
目标码：1001 1100
26.4.67RCL/RCR：经过进位循环左移/经过进位循环右移
循环的位经过进位标志。该操作把在寄存器或存储器中的字节、字或双字循环左移或循环右移各个位。
指定移位次数的操作数可以是立即数或是对CL的引用。在8088/86中，常数只可能是1，较大的循环次数必须在CL中。
在后继的处理器中，该常数可以达到31。对RCL，最左边的位进入进位标志，并且CF位进入目的的位0，
所有其他位循环左移。对于RCR，位0进入进位标志，并且CF位进入目的的最左边的位，所有其他位循环右移
（参见ROL和ROR）。
标志：影响CF和OF。
源码：RCL/RCR register/memory，CL/immediate
目标码：RCL：1101 00cw mod 010 r/m（如果c=0，移位次数是1；
            RCR：1101 00cw mod 011 r/m    如果c=1，移位次数在CL中。）
26.4.68REP：重复串
把串操作重复指定次数。REP是一个可选的重复前缀，可以放在串指令MOVS、STOS、INS和OUTS的前面。
在执行以前，把一个计数值装入CX。对于串指令的每次执行，REP使CX减1并重复该操作，直到CX为0为止，
在那一点上，继续执行下一条指令（参见REPE/REPZ/REPNE/REPNZ）。
标志：见相关的串指令。
源码：REP串指令
目标码：1111 0010
26.4.69 REPE/REPZ/REPNE/REPNZ：有条件地重复串
把串操作重复指定次数或直到条件被满足为止。REPE、REPZ、REPNE和REPNZ是可选的重复前缀，
可以放在串指令SCAS和CMPS之前，这些串指令改变零标志。在执行以前，用一个计数值装入CX中。
对于REPE/REPZ（当相等/为零时重复），该操作当ZF是1（相等/为零的条件）且CX不是零时重复。
对于REPNE/REPNZ（当不相等/不为零时重复），该操作是当ZF是0（不相等/不为零的条件）且CX不是零时重复。
当条件为真时，该操作使CX减1并执行串指令。
标志：见相关的串指令。
源码：REPE/REPZ/REPNE/REPNZ串指令
目标码：REPNE/REPNZ：1111 0010
             REPE/REPZ：1111 0011
26.4.70RET/RETN/RETF：从过程返回
从以前用近CALL或远CALL进入的过程返回。汇编程序假定：如果RET是在标记为NEAR的过程之内，则为近RET；
如果是在标记为FAR的过程之内的，则为远RET。对于近返回，RET 把栈顶的字传送到IP并使SP加2。
对于远返回，RET把栈顶的字传送到IP和CS并使SP加4。常数操作数（编码为RET 4的立即值）被加到SP上。
很明确，RETN和RETF是用于编写近返回或远返回的。
标志：不受影响。
源码：RET/RETN/RETF [立即数]
目标码：4种格式：
段内：1100 0011
带立即数段内：1100 0010 data-low data-high
段间：：1100 1011
带立即数段间：1100 1010 data-low data-high
26.4.71ROL/ROR：循环左移或循环右移
在寄存器或存储器中的字节、字或双字（80386+）循环左移或循环右移每个位。指定移位次数的操作数可以是
立即数或是对CL的引用。在8088/86中，该常数只能是1；较大的循环次数必须在CL中。
在后继的处理器中，常数可以达到31。对于ROL，最左边的位进入目的的位0，所有其他位循环左移。
对于ROR，位0进入目的的最左边的位，所有其他位循环右移（参见RCL和RCR）。循环的位也进入进位标志。
标志：影响CF和OF。
源码：ROL/ROR register/memory，CL/immediate
目标码：ROL：1101 00cw mod 000 r/m（如果c=0，计数值=1；
            ROR： 1101 00cw mod 001 r/m   如果c=1，计数值在CL中。）
26.4.72SAHF:AH的内容存人标志
AH的8位存入标志寄存器的低阶位（参见LAHF）。
标志：影响AF，CF，PF，SF和ZF。
源码：SAHF（无操作数）目标码：1001 1110
26.4.73SAL/SAR：代数左移/代数右移
在寄存器或存储器中的字节、字或双字左移或右移各位。指定移位次数的操作数可以是立即常数或是对CL的引用。
在8088/86中，该常数只能是1，较大的移位次数必须在CL中。
在后继的处理器中，该常数可达31。
SAL左移指定数量的位，并用0填充右边的空位。SAL的动作恰好和SHL一样。
SAR是算术移位，需要考虑被引用字段的符号。SAR向右移指定数量的位并用符号位（0或1）填充到左边。
所有移出的位都丢失了。
标志：影响CF，OF，PF，SF和ZF（AF未定义）。
源码：SAL/SAR register/memory，CL/immediate
目标码：SAL：1101 00cw mod 100 r/m（如果c=0，计数值是1；
            SAR：1101 00cw mod 111 r/m    如果c=1，计数值在CL中。）
26.4.74SBB：带借位减法
常用于二进制多字减法，把溢出的1的位带到算术运算的下一级。
SBB首先从操作数1中减去CF的内容（0/1），然后就像SUB一样，从操作数1中减去操作数2（参见ADC）。
标志：影响AF，CF，OF，PF，SF和ZF。
源码：SBB register/memory，register/memory/immediate
目标码：3种格式：
reg/mem 与reg：0001 10dw mod reg r/m
immed 从accumulator：0001 110w data
immed 从reg/mem：1000 00sw mod 011 r/m data
26.4.75 SCAS/SCASB/SCASW/SCASD：扫描串
用于为指定的值扫描存储器中的串。对于SCASB，把该值装入AL；对于SCASW，把该值装入AX；
对于SCASD（80386+），把该值装入EAX。ES:DI对引用被扫描的在存储器中的串。
该操作通常是和REPE/REPNE前缀连同在CX中的计数值一起使用，使用REPE是去找第一个不匹配的，
而使用REPNE则是去找第一个匹配的。如果方向标志是0，则该操作是从左到右扫描存储器，并使DI增量。
如果DF=1，则该操作是从右到左扫描存储器，并使DI减量。REPn对于每次操作都使CX减1。
该操作在相等（REPNE）或不相等（REPE）条件下或者当CX减到0时结束。
最后的比较要清除或设置标志。如果指定的条件没有找到，REP使CX减到0；否则，DI和SI包含下项的地址。
标志：影响AF，CF，OF，PF，SF和ZF。
源码：[REPnn] SCASB/SCASW/SCASD（无操作数）
目标码：1010 111w
26.4.76SETnn：有条件地设置字节（80386+）
根据条件设置指定的字节。这是个由30条指令组成的组，包括 SET（N）E，SET（N）L，SET（N）C以及SET（N）S。
这组指令恰好相当于条件转移（Jnn）的组。如果测试的条件为真，则该操作把字节操作数设置为1，否则设置为0。
例如：
CMP AX,BX   ;比较AX和BX的内容
SETE CL   ;如果相等，则设置CL为1，否则为0
标志：不受影响。
源码：SETnn register/memory
目标码：0000 1111 1001 cond mod 000 r/m
（cond按照所测试的条件而改变）
26.4.77SHL/SHR：逻辑左移/逻辑右移
左移或右移寄存器或存储器中的字节、字或双字中的各位。指定移位次数的操作数可以是立即数或是对CL的引用。
在8088/86中，该常数只能是1，较大的移位次数必须在CL中。在后继的处理器中，该常数可达31。
SHL和SHR是把符号位看作数据位的逻辑移位。
SHL向左移指定数量的位，并把0填入布边腾空的位置。SHL的动作和SAL一样。
SHR向右移指定数量的位并用0填充到左边。被移出的所有位都被丢弃了。
标志：影响CF，OF，PF，SF和ZF（AF未定义）。
源码：SHL/SHR register/memory，CL/immediate
目标码：SHL：1101 00cw mod 100 r/m（如果c=0，计数值=1；
            SHR：1101 00cw mod 101 r/m    如果c=1，计数值在CL中）
26.4.78 SHLD/SHRD：双精度移位（80386+）
把多个位移入操作数中。该指令要求3个操作数。操作数1是包含被移位值的16或32位寄存器或存储单元。
操作数2是包含要被移入操作数1的各个位的寄存器（和操作数1一样大小）。操作数3是包含移位值的CL或立即常数。
标志：影响CF，OF，PF，SF和ZF（AF未定义）。
源码：SHLD/SHRD register/memory，register，CL/immediate
目标码：0000 1111 1010 0100 mod reg r/m
26.4.79STC：设置进位标志
设置CF为1（见清除CF的CLC）。
标志：设置CF。
源码：STC（无操作数）目标码：1111 1001
26.4.80STD：设置方向标志
设置DF为1，使串操作如MOVS从右到左进行处理（见清除DF的CLD）。
标志：设置DF。
源码：STD（无操作数）目标码：1111 1101
26.4.81STI：设置中断标志
设置IF为1，在下一条指令执行之后，可屏蔽外部中断（见清除IF的CLl）。
标志：设置IF。
源码：STI（无操作数）目标码：1111 1011
26.4.82 STOS/STOSB/STOSW/STOSD：存人串
把累加器的内容存入存储器。当和REP前缀连同CX中的计数值一起使用时，该操作按指定次数复制串值，
适用于像清除一个存储区域那样的操作。STOSB把值装入AL，STOSW把值装入Ax，而STOSD（80386+）
把值装入EAX。ES:DI引用一个存储单元，该值就被存放在那里。如果方向标志是0，则该操作从左到右存入存储器，
并使DI增量。如果DF是1，则该操作从右到左存入存储器，并使Dl减量，REP对于每次重复都使CX减1，
而当CX变成0时，操作结束。
标志：不受影响。
源码：[REP]STOSB/STOSW/STOSD（无操作数）目标码：1010 101w
26.4.83SUB：二进制值减法
从寄存器减去在寄存器、存储器或立即数中的二进制值，或者从存储器中减去在寄存器中的值或立即数。
值可以是字节、字或双字（参见SBB）。
标志：影响AF，CF，OF，PF，SF和ZF。
源码：SUB register/memory，register/memory/immediate
目标码：3种格式：
reg/mem与register：0010 10dw mod reg r/m
immed 从accumulator：0010 110w data
immed 从reg/mem：1000 00sw mod 101 r/m data
26.4.84TEST：测试位
对于一个特定的位配置，用AND逻辑去测试一个字段，但不改变目的操作数。
2个操作数都是在寄存器或存储器中的字节、字或双字，第二个操作数可以是立即数。
如果任何一对相匹配的位是1，则该操作清除ZF，否则将ZF置1。执行完之后，可以使用Jnn指令去测试标志。
标志：清除CF和OF标志，并影响PF，SF和ZF。（AF未定义）。
源码：TEST register/memory，register/memory/immediate
目标码：3种格式：
reg/mem与register：1000 010w mod reg r/m
immed 到accumulator：1010 100w data
immed到reg/mem：1111 011w mod 000 r/m data
26.4.85WAIT：置处理器于等待状态
允许处理器保持在等待状态直到发生一个外部中断为止，目的是为了和协处理器同步。
处理器等待直到协处理器完成执行，并在TEST引线接收到信号时立即恢复处理。
标志：不受影响。
源码：WAIT（无操作数）目标码：1001 1011
26.4.86XADD：交换并相加（80486+）
把源操作数和目的操作数相加，和存入目的，并把原先的目的的值传送到源。
标志：影响AF，CF，OF，PF，SF和ZF。
源码：XADD register/memory，register
目标码：0000 1111 1100 000b mod reg r/m
26.4.87XCHG：交换
在2个寄存器之间交换数据（如XCHG AH,BL）或在寄存器与存储器之间交换数据（如XCHG CX,word）。
标志：不受影响。
源码：XCHG register/memory，register/memory
目标码：2种格式：
reg与accumulator：1001 0reg
reg/mem与reg：1000 011w mod reg r/m
26.4.88XLAT/XLATB：换码
把字节转换成不同格式，比如加密的数据。把转换表的地址装入BX或对EBX（对于32位大小），
然后把被转换的值装入AL。该操作把AL的值作为偏移值进入表中，从表中选择字节，
并存入AL（XLATB是XLAT的同义词）。
标志：不受影响。
源码：XLAT/XLATB [AL]（AL操作数是可选的）
目标码：1101 0111
26.4.89XOR：异或
实现2个操作数的按位逻辑异或。2个操作数都是字节、字或双字，在其中XOR按位对位相匹配。
对于每对相匹配的位，如果2个位都相同，则第一个操作数中的对应位被清除为0；
如果相匹配的位是不同的，则在第一个操作数中的对应位被置1（参见AND和OR）。
标志：影响CF（0），OF（0），PF，SF和ZF（AF未定义）。
源码：XOR register/memory，register/memory/immediate
目标码：3种格式：
reg/mem与reg：0011 00dw mod reg r/m
immed 到reg/mem：1000 000w mod 110 r/m data
immed到accumulator：0011 010w data
附录A 十六进制数与十进制数之间的转换
这一附录给出十六进制与十进制格式的数之间进行转换所需要的步骤。
第一节说明如何把十六进制的A7B8转换成十进制的42936，
第二节说明如何把42936反过来转换成十六进制的A7B8。
A.1十六进制数转换成十进制数
为了把十六进制数转换成十进制数，从最左边的十六进制数位升始，每个十六进制数字连续地乘以16，并累加其结果。
因为乘法是十进制的，所以要把十六进制数字A到F转换为十进制的10到15。把A7B8H转换为十进制格式的步骤是：
A=10 *16=160+7=167*16=2672+11=2683*16=42928+8=42936
也可以使用转换表。对于A7B8H，把最右边的数位（8）看作是位置1，左边的下一个数位（B）看作是位置2，
再下一个数位7看作是位置3，最片边的数位（A）看作是位置4。查阅表A-1并设置每个十六进制数字的值：
对于在位置1的数字8，列1=8
对于在位置2的数字B，列2=176
对于在位置3的数字7，列3=1792
对于在位置4的数字A，列4=40960
十进制值42936=8+176+1792+40960=184+42752=42936
A.2十进制数转换成十六进制数
为了把十进制数42936转换成十六进制数，首先将42936除以16，余数成为最右边的十六进制数位8。
接着，新的商2683除以16，余数是11即B，成为左边的下一个十六进制数位。
用这种方法继续从每一步除法的余数中求出十六进制数，直到商是0为止。这些步骤是如下进行的：
42936/16=2683   8
2683/16=167   11
167/16=10   7
10/16=0   10
也可以使用表A-1进行十进制到十六进制的转换。对于十进制数42936，定位在表中的数，
该数是等于或下一个比它小的数。注意等效的十六进制值和它在表中的位置。
从42936中减去该十六进制数位的十进制值，并且定位在表中的差值。该过程如下进行：
42936-40960=1976   A000
1976-1792=184         0700
184-176=8                00B0
                                 0008
                                 A7B8
附录B ASCII字符码
术语ASCII代表“American Standard Code for Information Interchange”（美国信息交换标准码）。
表B-1列出了完整的256个ASCII字符码（00H到FFH），以及对应的十六进制表示。
字符码的种类是：
00-1F有关屏幕、打印机和数据传送的控制码，它们是用来产生动作的。
20-7F有关数字、字母和标点符号的字符码（20H是标准的空格或空白）。
80-FF扩展的ASCII码，外来字符，希腊字母和数学符号，以及画框图用的图形符号。
下面是控制码00H到1FH及其说明：
十六进制         字符         十六进制         字符         十六进制         字符
00                  空                  01         标题开始         02         正文开始
03                 正文结束         04         传输结束         05         询问
06                 确认                07         响铃               08         退格
09                水平制表          0A         换行               0B         垂直制表
0C                换页                0D         回车               0E         移出
0F                移入                10         数据行换码      11         设备控制1
12                设备控制2        13         设备控制3       14         设备控制4
15                不确认             16         同步空闲         17         信息块传输结束
18                取消                19         媒介结束         1A         置换
1B                换码                1C         文件分隔符     1D         组分隔符
1E                记录分隔符       1F         单元分隔符

附录C DEBUG程序
DOS DEBUG程序对于编写很小的程序，调试汇编程序以及检查文件或存储器的内容是有用的。
你可以在DOS下面名为\DOS的目录中，或在Windows95/98下面通过开始菜单选择MS-DOS提示符，
找到DEBUG.EXE。为了打印显示的副本，简便的方法是在窗口中运行DEBUG。使用鼠标指定一个区域，
将其复制到剪贴板，接着就可以把它粘贴到记事本或字处理程序中。
为了开始该程序，键入DEBUG并按回车键，DEBUG会从磁盘装入到存储器中。
当DEBUG的提示符短划（-）出现在屏幕上时，DEBUG已准备好接受命令（那是一个短划，尽管它和光标很相像）。
可以键入一条或两条命令启动DEBUG：
1.为建立文件或检查存储器，键入不带文件说明的DEBUG；
2.为了修改或调试程序（.COM或.EXE）或者修改文件，键入带文件说明的DEBUG，比如DEBUG n:PROGC.COM。
装入程序把DEBUG装入到存储器中，并且DEBUG显示一个短划（-）作为提示符。
用256个字节（100H）的程序段前缀（PSP）地址初始化CS，DS，ES，以及SS寄存器，
同时工作区从PSP+100H处开始。下面是DEBUG如何从左到右显示标志寄存器的：
                  溢出         方向         中断         符号         零         辅助进位         奇偶         进位
为1             OV         DN            EI            NG          ZR         AC                  PE            CY
为0             NV         UP            DI            PL            NZ        NA                 PO            NC
可以根据段：偏移值（如DS：120）引用存储器地址，或者只根据偏移值（如120）引用。
也可以直接引用存储器地址，如40：17，其中40[0]H是段地址，而17H是偏移值。
注意，.EXE程序的数据段是从DS：0开始的，而.COM程序则是从DS：100开始的。
DEBUG假定所有输入的数都是十六进制的，所以不用键入后面的H。
F1和F3键是以如下方式工作的：F1每次按键重复前一个命令，而F3键却重复前面的全部命令。
另外，DEBUG不区分大、小写字母。
以下是按字母顺序对每个DEBUG命令的说明。
A（汇编）。把汇编源语句转换成机器码。这个操作对于编写和测试小的汇编程序，以及检查小的代码段特别有用。
代码的默认起始地址是CS：0100H。A命令的格式是A [address]，其中address默认为100H。
DEBUG支持以下特性：
DB和DW可以用于定义程序需要引用的数据项。
操作数在方括号内，比如[12]，它指定存储器偏移值。
PTR操作符可以用于指定字节或字，如INC BYTE PTR [12]。
寄存器-间接操作数的所有形式都是适用的，比如[BP+DI]和25[BX]。
下面的例子建立一个包含5个语句的汇编程序。键入指令，DEBUG产生代码段（这里表示为xxxx:）和从0100H开始的
偏移值
A（或A 100）<Enter>
xxxx：0100 MOV CX,[10D] <Enter>   ;取10D处的内容
xxxx：0104 ADD CX,1A <Enter>   ;加立即值
xxxx：0107 MOV [10D],CX <Enter>   ;把CX存入10D中
xxxx：010B JMP 100 <Enter>   ;转移返回到起点
xxxx：010D DW 2500 <Enter>   ;定义常数
<Enter>   ;命令结束
根据PSP的大小，DEBUG把IP设置为100H，这样语句就从100H开始。最后的<Enter>（回车键）（在一行中是2个）
通知DEBUG结束该程序。现在可以使用U（反汇编）命令检查机器码并使用T（跟踪）命令跟踪程序的执行。
改变上述的任一条指令或数据项，所提供的新长度和老长度是一样的。例如，把在104H的ADD改变为SUB，键入
A 104 <Enter>
xxxx：104 SUB CX,1A <Enter> <Enter>
重新执行该科序时，IP仍然增量。使用寄存器（R）命令把它复位成100H。使用Q退出。
C（比较）。比较存储器的2个区的内容，默认寄存器是DS。可以编写带有长度或范围的命令：
1.C start-from-addr length start-to-addr。下面的例子把从DS：050开始的20H字节与从DS：200开始的字节
进行比较：C 050 L20 200   ;使用长度20H的比较
2.C start-from-addr end-from-addr start-to-addr。这一例子是把从DS：050开始到DS：70的字节与从DS：200
开始的字节进行比较：
C 050 070 200   ;使用范围的比较
该操作显示不相等字节的地址和内容、
D（显示或转储）。以十六进制和ASCII形式显示部分存储器的内容，默认的寄存器是DS。
可以编写带有长度或范围的命令：
1.D [start-address [length]]。指定带有可选长度的起始地址，省略长度时的默认值为80H（128字节）。
下面是一些例子：
D 200   ;显示从DS：200H处开始的80H个字节
D   ;显示从上一次显示结束处开始的80H个字节
D CS:150   ;显示从CS:150H开始的80H个字节
D DS:20 L5   ;显示从DS:20H开始的5个字节
2.D[start-addr end-addr]。如下所示：
D 300 32C   ;显示从300H到32CH的字节
E（写入）。允许键入数据或机器指令，默认寄存器是DS，格式是E address[list]。
该操作有2个选项：
1.用列表（list）中的字节替换字节，如下所示：
E 105 13 3A 21   ;输入从DS：105H开始的3个字节
E CS:211 21 2A   ;输入从CS：211H开始的2个字节
E 110 'anything'   ;输入从DS:110H开始的字符串
字符串要使用单引号或双引号。
2.允许顺序地编辑字节；键入想要显示的地址（address）：
E 120   ;显示DS:120H的内容
该操作等待从键盘的输入。从DS：120H开始键入一个或多个十六进制值的字节，用空格隔开。
F（填充）。用列表中的值填充某个范围内的存储单元，默认寄存器是DS。可以编写带长度或范围的命令：
1.F start-addr length 'data'。下面是一个例子：
F 210 L19 'Help!'   ;使用19H（25）个字节的长度
2.F start-addr end-addr 'data'。下面是一个例子：
F 210 229 'Help!'   ;使用范围，210H到229H
2个例子都用包含'Help!'的字节填充从DS：210H开始的存储器单元。
G（运行）。执行正在调试的机器语言程序一直到达指定断点。要保证检查所列出的机器码是有效的IP地址，
因为无效的地址可能导致无法预料的后果。另外，只能在你自己的程序中设置断点，
不能在DOS或BIOS的程序模块中设置。该操作通过INT操作执行并暂停，如有必要，还要等待键盘输入。
默认的寄存器是CS，格式是：
G [start-address] break-address [break-acddress...]
项目=start-address是可选的。其他项目允许多达10个断点的地址。命令G 11A通知DEBUG从IP的当前单元开始执行
所有指令，直到单元11A为止。
H（十六进制）。显示2个十六进制值的和与差，编码为H value value。最大长度是4个十六进制数位。
例如，命令H 14F 22显示结果171（和）与12D（差）。
I（输入）。输入并显示来自端口的一个字节，编码为I port-address。
L（装入）。把一个文件或磁盘扇区装入存储器。文件可以是被“命名”的，以便DEBUG用下面的两种方法之识别它：
DEBUG要求带文件说明执行，或者在DEBUG内执行N（命名）命令。L命令有2种格式：
1.装入一个命名的文件：L [address]。使用地址参数使L从指定单元开始进行装入。省略地址，会使L从CS：100处
进行装入。要想装入没有命名的文件，应当首先给它命名（参见N命令）：
N filespec   ;命名文件
L   ;在CS:100处装入该文件
为了重新装入该文件，只需发出不带地址的L命令，DEBUG重新装入文件并相应地初始化寄存器。
2.装入来自磁盘扇区的数据：L [address [drive start number]]。
Address为装入数据提供起始的存储单元（默认值是CS：100）。
Drive 指明磁盘驱动器，其中0=A，1=B，等等。
Start指定要装入的第一个扇区的十六进制编号（相对数，其中柱面0、磁道0、扇区1，是相对扇区0而言的）。
Number给出进行装入的顺序扇区的十六进制数。
下面的例子是把驱动器0（A）的从扇区20H开始的15个扇区装入到以CS：100为起点的存储区：
L 100 0 20 15
L操作把装入的字节数回送到BX:CX。对于.EXE文件，DEBUG忽略地址参数（如果有的话）
而使用.EXE标题中的装入地址。它还会去掉标题，为了保存标题，要在执行DEBUG前，
用不同的扩展名重新命名该文件。
M（传送）。传送（或复制）存储单元的内容，默认的寄存器是DS。可以编写带长度或范围的命令：
1.M start-addr length end-addr。一个例子：
M DS:50 L100 DS:400   ;使用传送的长度
2.M start-from-addr end-from-addr start-to-addr。一个例子：
M DS:50 150 DS:400   ;使用传送的范围
2个例了都把从DS：050H开始到150H的字节复制到从DS：400H开始的地址。
N（命名）。命名从磁盘上读出或向磁盘写入的程序或文件。命令编码为N filespec，比如N path:SAM.COM
该操作把名字存入PSP中的CS：80处。CS：80处的第一个字节标明长度（0AH），接着是空格和文件说明。
然后可以使用L（装入）或W（写）读或写该文件。
O（输出）。发送字节到某个端口，编码为O port-address byte。
P（继续进行）。执行CALL，LOOP，INT或重复串指令（REP）直到下一条指令。它的格式是：P [=address][value]，
其中=address是可选的起始地址，value是可选的继续进行下去的指令数。省略=address默认为当前的CS:IP值。
例如，跟踪执行的是INT 10H操作，那么只要键入P就可以从头到尾地执行整个操作。参见G和T。
Q（退出）。退出DEBUG。该操作不保存文件，为了保存文件，可使用W
R（的存器）。显示寄存器的内容和下一条指令。它的格式是R[register-ame]。以下例子说明这命令的用法：
R 显示所有寄存器
R DX显示DX，DEBUG提供如下选项：
（1）按回车键，保持DX不变；
（2）键入1到4个十六进制数位改变DX的内容。
R IP显示IP。键入另一个值改变IP的内容。
R F显示标志的当前设置，每个标志表示为2个字母代码。见本附录中有关标志名的说明。
S（查找）。为列表中的字符查找存储器。如果字符被找到，该操作返回它们的地址，否则，不响应。
默认的寄存器是DS。可以编写带长度或范围的命令：
1.S start-addr length 'data'。下面的例子是在开始于DS：300，长度为2000H字节的范围内查找“VIRUS”：
S 300 L2000 "VIRUS"
2.S start-from-addr end-from-addr 'data'。下面的例子是从CS：100到CS：400的范围内查找内容为51H的字节：
S CS:100 400 51
T（跟踪）。以单步方式执行程序。注意，通常应当使用P执行整个INT指令。默认的寄存器是CS:IP，
格式是T [=address][value]。可选的项目=address通知DEBUG从哪里开始跟踪，而可选的value则给出跟踪的指令数。
省略这两个操作数，DEBUG执行下一条指令并显示寄存器。2个例子：
T   ;执行下一条指令
T 10   ;执行下面10H（16）条指令
T命令试图执行所有指令，无效的指令会导致处理器死锁，需要重新引导才行。
U（反汇编）。将机器指令进行反汇编，即把机器指令转换为符号码。默认的寄存器是CS:IP，它的格式是
U [start-addr] 或 U [start-addr end-addr]
所指定的区城应当包含有效的机器码，该操作显示的是符号指令。3个例子：
U 100   ;反汇编开始于CS：100的32个字节
U   ;反汇编上一个U以后的32个字节（如果有的话）
U 100 140   ;反汇编从100H到140H的内容
DEBUG不能正确地转换某些条件转移和专门用于80286及其后继处理器的指令，尽管它能正确地执行
（DEBUG将它们表示为DB语句）。
W（写）。从DEBUG写入文件。如果文件还没有被装入，那么它应当首先被命名（参见N）。
默认的寄存器是CS，它的格式是
W [address [drive start-sector number-of-sectors]]
只能写入带.COM扩展名的程序文件，因为W不支持.EXE格式（为了修改.EXE程序，可以临时改变扩展名）。
可以使用DEBUG，在两种情况下，向磁盘上写入程序：
1.从磁盘上检索一个已存的程序，修改然后保存它，需要遵循以下这些步骤：
使用机器语言程序的名字将其装入存储器：DEBUG n:filename.ext。
使用D命令观察该程序并使用E命令进行修改。
使用W命令写入修改过的程序。
2.使用DEBUG建立一个非常小的机器语言程序，若想保存它，需要遵循以下这些步骤：
使用A（汇编）和E命令键入源程序。
输入N filename.COM为程序命名，该程序的扩展名必须是.COM。
由于需要知道程序实际在哪里结束，所以要以字节计的程序的大小插入BX:CX对。
考虑这一程序的例子是：
xxxx：0100 MOV CL,42
xxxx：0102 MOV DL,2A
xxxx：0104 ADD CL,DL
xxxx：0106 JMP 100
虽然键入符号码，但DEBUG还要产生机器码，这就是要进行保存的。因为最后一条指令JMP是两个字节，
所以该程序大小是从100H到107H，即8。
首先使用R BX显示BX（大小的高阶部分），并输入0清除它。
接着使用R CX显示CX。DEBUG用CX nnmn回应（它可能包含任何值），这时应该用程序大小8来替代它。
键入W<Enter>，在磁盘上写入修改过的程序。
DEBUG显示信息“Writing 8 bytes”（“写8个字节”）。如果这个数字是零，可能在输入程序长度时有失误，
要再试一次。要特别注意程序的大小，该值是十六进制的，并且最后一条指令的长度可能会超过一个字节。

附录D 保留字
汇编程序认定某些具有特定意义的字，只有在规定条件下，才可以使用。汇编程序保留的字可以划分为4种类型：
（1）寄存器名，如AX和AH。
（2）符号指令，如ADD和MOV。
（3）伪操作（给汇编程序的命令），如PROC和END。
（4）操作符，如DUP和SEG。
如果用下面的保留字定义数据项，会使汇编程序混淆或造成汇编错误。个别的汇编程序版本除这里所列出的之外，
还可能有其他保留字。
寄存器名
AH，AL，AX，BH，BL，BP，BX，CH，CL，CS，CX，DH，Dl，DL，DS，DX，EAX，EBP，EBX，ECX，
EDI，EDX，EIP，ES，ESI，FS，GS，IP，SI，SP，SS。
符号指令
AAA，AAD，AAM，AAS，ADC，ADD，AND，ARPL，BOUND，BSF，BSR，BTn，CALL，CBW，CDQ，CLC，
CLD，CLI，CLTS，CMC，CMP，CMPSn，CMPXCHG，CMPXCHG8B，CWDn，DAA，DAS，DEC，DIV，
ENTER，ESC，HLT，IDIV，IMUL，IN，INC，INSn，INT，INTO，IRET，JA，JAE，JB，JBE，JCXZ，JE，JECXZ，
JG，JGE，JL，JLE，JMP，JNA，JNAE，JNB，JNBE，JNE，JNG，JNGE，JNL，JNLE，JNO，JNP，JNS，JNZ，
JO，JP，JPE，JPO，JS，JZ，LAHF，LAR，LDS，LEA，LEAVE，LES，LFS，LGDT，LGS，LIDT，LLDT，LMSW，
LOCK，LODSn，LOOP，LOOPE，LOOPNEn，LOOPNZn，LOOPZ，LSL，LSS，LTR，MOV，MOVSn，
MOVSX，MOVZX，MUL，NEG，NOP，NOT，OR，OUTn，POP，POPA，POPAD，POPF，POPFD，PUSH，
PUSHAD，PUSHF，PUSHFD，RCL，RCR，REN，REP，REPE，REPNE，REPNZ，REPZ，RET，RETF，ROL，
ROR，SAHF，SAL，SAR，SBB，SCASn，SETnn，SGDT，SHL，SHLD，SHR，SHRD，SIDT，SLDT，SMSW，
STC，STD，STI，STOSn，STR，SUB，TEST，VERR，VERRW，WAIT，XADD，XCHG，XLAT，XOR。
伪操作
ALIGN，.ALPHA，ASSUME，BYTE，.CODE，COMM，COMMENT，.CONST，.CREF，
.DATA，.DATA？，DB，DD，DF，DOSSEG，DQ，DT，DW，DWORD，ELSE，END，ENDIF，ENDM，ENDP，
ENDS，EQU，.ERRnn，EVEN，EXITM，EXTRN，EXTERN，.FARDATA，.FARDATA？，FWORD，GROUP，
IF，IF1，IF2，IFB，IFDEF，IFDIF，IFE，IFIDN，IFNB，IFNDEF，INCLUDE，INCLUDELIB，IRP，IRPC，LABEL，
.LALL，，.LFCOND，.LIST，LOCAL，MACRO，.MODEL，NAME，ORG，&OUT，PAGE，PROC，PUBLIC，
PURGE，QWORD，.RADIX，RECORD，REPT，.SALL，SEGMENT，.SEQ，.SFCOND，.STACK，STRUC，
SUBTTL，.TFCOND，TTTLE，TBYTE，UNION，WORD，.XALL，.XCREF，.XLIST。
操作符
AND，BYTE，COMMENT，CON，DUP，EQ，FAR，GE，GT，HIGH，LE，LENGTH，LINE，LOW，LT，MASK，
MOD，NE，NEAR，NOT，NOTHING，OFFSET，OR，PTR，SEG，SHL，SHORT，SHR，SIZE，STACK，THIS，
TYPE，WHILE，WIDTH，WORD，XOR。

附录E 汇编与连接程序
本附录涉及汇编，连接，产生交叉引用文件，以及把.EXE程序转换为.COM格式的一些规则。
把源程序转换为可执行文件的步骤是：
1.汇编源程序。这一步建立目标（.OBJ）文件，可选的列表（.LST）文件，以及可选的用作交叉引用的文件。
2.连接目标文件。这一步建立可执行（.EXE）文件，可选的映像（.MAP）文件，以及可选的库（LIB）文件
（连接可以把一个以上的目标文件组合成可执行文件）。
3.可以有选择地把.EXE文件转换成.COM文件。
不同的汇编程序版本对这些步骤的处理是不一样的，并且提供了很多的选项序列，这里所涉及的只是一部分。
本附录包括Microsoft MASM6.1，MASM5.1，以及Borland Turbo TASM的版本。
用在本附录中的路径对于程序以及文件来说意思是文件和目录，可以把它替换为适当的值，比如C:或C:\子目录。
E.1 MICROSOFT MASM6.1
Microsoft MASM6.1汇编程序使用ML命令，但为了和较早的版本兼容也接受MASM命令。
ML命令允许把任意多的程序汇编和连接成为一个可执行模块。用于汇编与连接的ML命令的格式是
ML [options] filename.ASM [[options]filename.ASM]...[/LlNK options]
命令行的选项（options）是大小写敏感的，由斜杠（/）字符开始。包括以下这些：
/AT 指明程序使用Tiny存储模型，该命令把程序转换成.COM格式。
/c 只汇编，不连接。
/Fl 产生列表（.LST）文件。
/Fm 产生连接映像（.MAP）文件。
/Fr 产生.SBR（交叉引用）文件。
/Sn 禁止符号表的列表。
/Zd 包含调试信息的行号。
/Zi 包含符号的调试信息（对于Code View）
两个例子：
ML /Sn /Fr program23.asm（汇编并连接）
ML /AT /Zd program34.asm（汇编，连接，产生.COM文件）
一个有用的命令是ML /?，它显示完整的命令行语法和选项。
也可以使用MASM命令行，它起的作用和MASM5.1一样（见下一节MASM5.1）。
.COM程序。如果源程序使用Tiny有储模型，则ML命令产生.COM程序。如果程序使用常规段，则ML产生.EXE文件，
这时必须使用EXE2BIN把它转换成.COM格式（见下节MASM5.1）。
连接。可以只汇编而不连接（使用/c选项），汇编并连接（默认的），在命令行中指定LINK，或者单独地运行LINK
程序。LINK的格式是
LINK [options] object-file(s),[exefile],[mapfile],[libraries]
为了显示全部连接选项，可以键入LINK /?。
交叉引用文件。使用ML命令中的/Fr选项产生.SBR文件，使用CREF程序把它转换成特有的、已排序的.CRF文件：
CREF xreffile.SBR,reffile.REF
E.2 MICROSOFT MASM 5.1
这一版本要求采用分别的步骤对程序进行汇编，连接，以及转换成.COM格式。该汇编程序命令行的格式是
MASW [options] source-file [,object-file][,list-file][,xref-file]
Options 以后说明。
Source-file 指明源程序。汇编程序缺省的扩展名为.ASM，所以不需要输入它。可以键入路径，如C:\子目录\文件名。
Object-file用来产生.OBJ文件。
List-file用来产生包含源码与目标码的.LST文件。
Xref-file 用于产生.CRF交叉引用文件，该文件包含作为交叉引用列表的符号。
每个文件可以有它自己的路径与文件名，文件名可以和源相同或不同。下面例子清楚说明了所有文件：
MASM prog-name，prog-name，prog-name，prog-name
下面的简化命令允许默认目标文件和交叉引用文件，二者都具有相同的名字，但是没有列表文件：
MASM filename, , , 。MASM包括以下一些选项（oplions）：
/C 在.LST文件中建立交叉引用表。
/L 建立标准的列表（.LST）文件。该命令行还为这一选项提供路径。
/N 在.LST文件中禁止符号表的产生。
/Z 出错时在屏幕上显示源行。
/ZD 为Coed View在目标文件中包含行号信息。
/ZI 为Coed View在目标文件中包含行号和符号的信息。
以下例子需要两个选项：MASML /L /Z 文件名。为了简要地说明所有选项，不带文件名或其他选项键入MASM /H（帮助）。
交叉引用文件。.CRF文件用于产生程序的标号，符号和变量的列表。使用CREF把.CRF文件转换成排序的交叉引用
（.REF）文件：
CREF xreffile,reffile
xreffile指明由汇编程序所产生的交叉引用文件。该程序缺省了扩展名，所以不需要输入它。可以指定路径。
reffile用于产生.REF文件。路径与文件名可以和源的路径与文件名一样或不同。
下面的例子编写一个在驱动器C上的名为ASMPROG.REF的交叉引用文件：
CREF C:\ASMPROG,C:\。
连接。连接MASM5.1程序的命令行是
LINK objfile,exefile[,mapfile][,libraryfile]
Objfile指明由汇编程序所产生的目标文件。连接程序缺省扩展名为.OBJ，所以不需要再输入它。
路径与文件名可以和源中的路径与文件名一样或不同。
Exefile 用于产生.EXE文件。路径与文件名可以和源中的路径与文件名一样或不同。
Mapfile 用于产生.MAP文件，该文件指明每一个段的相对位置与大小以及连接程序所发现的任何错误。
输入CON（对于控制台）通知连接程序在屏幕上显示映像，以便可以立即观察错误。
Librayfile 用于库选项。
如果目标文件和源文件具有相同的名字，那就不需要重复它，对驱动器号或路径的引用足以指明文件存储的要求。
下面的例子连接目标文件A05ASM1.OBJ。连接程序在驱动器n：上写.EXE文件，显示映像（CON），并且忽略库选项：
LINK n:A05ASM1,n:,CON。
假如源程序是按.COM要求写的，则连接程序显示信息“Warning:No Stack Segment”（“警告：没有堆栈段”）。
为了把一个以上的目标文件连接成可执行模块，把它们像这样组合在一行里：LINK PROCA + PROGB + PROCC。
如果打算Code View，需要使用汇编程序的/ZI命令行选项。为了连接，使用/CO选项作为LINK /CO 文件名。
把MASM5.1的目标文件转换为.COM程序。EXE2BIN程序把由MASM产生的.EXE模块转换成.COM模块，
源程序必须是按.COM的要求编码的。键入以下命令：
EXE2BIN filename，filename.COM
第一个操作数总是引用.EXE文件，所以不用编写.EXE扩展名。第二个操作数可以是任何带.COM扩展名的有效文件名。
如果遗漏了.COM扩展名，EXE2BIN便假定是.BIN，为了执行该程序，其后必须改名为.COM。
E.3 BORLAND TURBO 汇编程序（TASM）
Turbo汇编程序可以在一个命令行里汇编多个文件，每个文件都有自己的选项。也可以使用通配符（*和？）。
为了汇编在当前目录中的所有源程序，键入TASM *；为了汇编所有名为PROG1.ASM，PROG2.ASM等等源程序，
键入TASM PROG?。可以键入文件名组，每组用一个加号（+）分隔。
下面的命令汇编带/L选项的PROG1和PROG2以及带Z选项的PROG3：
TASM /L PROG1 PROG2 + /Z PROG3
L选项使TASM产生列表（.LST）文件，而Z使之显示出错的源程序行。键入不带命令行的TCREF时，
显示命令的通用格式和它的选项说明。标准方式还有许多附加的特性。Borland提供了另外两个汇编程序版本：
TASMX和TASM32，它们用于保护方式。
交叉引用文件。.XRF文件是用于产生程序标号，符号，以及变量的交叉引用列表的。
使用TCREF把列表转换成排序的交叉引用文件：
TCREF xreffile，reffile
有关TCREF命令的规则类似于MASM5.1CREF的那些规则。下面的例子是在驱动器C上写入一个名为ASMPROG.REF的
交叉引用文件：TCREF C:\ASMPROG,C:\。
连接。连接TASM程序的命令行是
TLINK objfile，exefile[,mapfile][,libraryfile]
TLINK命令的规则和MASM5.1LINK的那些规则类似。
把Turbo目标文件转换成.COM程序。TLINK允许把目标程序直接转换成.COM格式，但源程序必须是按.COM的要求
编码的。使用T选项：
TLINK /T objfile,comfile,CON
调试选项。如果要使用TurboDebugger，可以使用汇编程序的/ZI命令行选项。对于连接，使用/V选项，如
TLINK /V filename。
E.4汇编程序表
在汇编程序.LST列表后面的是段与组表以及符号表。
段与组表（Segments and Groups Table）。这个表有下面的一些标题：
Name Length Align Combine Class
name列按字母顺序列出所有段和组的名字。
length列给出每个段的十六进制的大小。
align列给出对准的类型，比如BYTE，WORD或PARA。
combine列列出所定义的组合类型，比如堆栈是STACK，没有编写类型时是NONE，
外部定义是PUBLIC，AT类型是十六进制地址。
class列列出段的类别名，与在SEGMENT语句中所编写的相同。
符号表（Symbol Table）。符号表有下面的一些标题：
Name Type Value Attribute
name列按字母顺序列出所有已定义项的名字，
type列给出类型，如下所示：
L NEAR或L FAR：近的或远的标号
N PROC或F PROC：近的或远的过程
BYTE，WORD，DWORD，FWORD，QWORD，TBYTE：数据项
ALIAS：符号的别名（或绰号）
NUMBER：绝对标号
OPCODE：指令操作数
TEXT：文本
value列给出名字、标号及过程距离段起点的十六进制偏移值。
attribute列列出符号的属性，包括它所在的段和长度。
MASM6.1还列出了过程，参数，以及局部表，这些表标明了它们的名字与属性。

附录F 键盘扫描码和ASCII码
在下面的列表中，键被分成几类。对每一类都列出了普通键（不与其他键组合）的格式以及与Shift、Ctrl和Alt键组合
的格式。在每一列开头的“Normal，”“Shift，”“Ctrl，”和“Alt”下面，有两个16进制的字节，
其值与键盘操作将它们发送给AH和AL寄存器的值相同。例如：按下字符“a”时，BIOS会将扫描码1EH发送到AH中，
并且将ASCII字符61H发送到AL中。当按下shift键输入大写字母“A”时，键盘分别传送1EH和41H。
扫描码为85H及其以上值的键对应扩展键盘。

字母         NORMAL         SHIFT         CTRL         ALT
a和A         1E 61               IE 41         1E 01         1E 00
b和B         30 62               30 42        30 02         30 00
c和C         2E 63               2E 43        2E 03          2E 00
d和D         20 64              20 44        20 04          20 00
e和E         12 65               12 45       12 05           12 00
f和F          21 66               21 46       21 06           21 00
g和G        22 67               22 47       22 07           22 00
h和H        23 68               23 48       23 08           23 00
i和I           17 69               17 49       17 09           17 00
j和J           24 6A              24 4A      24 0A           24 00
k和K         25 6B               25 4B      25 0B           25 00
l和L           26 6C              26 4C      26 0C           26 00
m和M       32 6D              32 4D     32 0D           32 00
n和N        31 6E               31 4E      31 0E            31 00
o和O        18 6F               18 4F      18 0F            18 00
p和P         19 70               19 50      19 10           19 00
q和Q         10 71              10 51       10 11           10 00
r和R          13 72               13 52       13 12          13 00
s和S          1F 73               1F 53       1F 13           1F 00
t和T          14 74                14 54      14 14           14 00
u和U         16 75               16 55       16 15           16 00
V和V          2F 76               2F 56       2F 16           2F 00
w和W        11 77               11 57       11 17           11 00
x和X          2D 78               2D 58      2D 18           2D 00
y和Y          15 79               15 59       15 19            15 00
z和Z          2C 7A               2C 5A      2C 1A           2C 00
Spacebar  39 20                39 20       39 20           39 20
F1             3B 00               54 00        5E 00            68 00
F2             3C 00               55 00        5F 00            69 00
F3             3D 00               56 00        60 00            6A 00
F4             3E 00                57 00        61 00            6B 00
F5             3F 00                58 00        62 00            6C 00
F6             40 00                59 00        63 00            6D 00
F7             41 00                5A 00        64 00            6E 00
F8             42 00                5B 00        65 00            6F 00
F9             43 00                5C 00        66 00            70 00
F10           44 00                5D 00        67 00            71 00
F11           85 00                87 00        89 00             8B 00
F12           86 00                88 00        8A 00            8C 00
Ins and 0  52 00                52 30        92 00
End and 1 4F 00                4F 31        75 00             00 01
下箭头 and 2 50 00           50 32        91 00              00 02
PgDn and 3 51 00             51 33        76 00             00 03
左箭头 and 4 4B 00           4B 34        73 00              00 04
5（键区）  4C 00               4C 35       8F 00               00 05
右箭头 and 6 4D 00           4D 36       74 00               00 06
Home and 7 47 00            47 37        77 00              00 07
上箭头 and 8 48 00            48 38       8D 00              00 08
PgUp and 9  49 00            49 39       84  00              00 09
+(灰键)         4E 00            4E 2B       90 00                4E 00
-(灰键)          4A 00            4A 2D      8E 00                4A 00
Del and .      53 00             53 2E       93 00
*(灰键)          37 2A            37 2A       96 00                37 00
`和~             29 60             29 7E                                 29 00
1和!              02 31             02 21                                78 00
2和@            03 32             03 40      03 00                 79 00
3和#             04 33              04 23                               7A 00
4和$             05 34              05 24                               7B 00
5和%            06 35              06 25                               7C 00
6和^             07 36              07 5E      07 1E                7D 00
7和&            08 37               08 26                              7E  00
8和*              09 38              09 2A                              7F  00
9和(              0A 39              0A 38                              80  00
0和)              0B 30              0B 29                               81  00
-和_              0C 2D             0C 5F      0C 1F                82  00
=和+            0D 3D            0D 2B                               83  00
Esc               01 1B              01 1B      01 1B                01 00
Backspace   0E 08              0E 08       0E 7F                0E  00
Tab             0F 09              0F 00       94 00                A5  00
Enter          1C 0D              1C 0D      1C 0A               1C  00
[和{             1A 5B              1A 7B       1A 1B               1A  00
]和}             1B 5D              1B 7D       1B  1D              1B  00
;和:              27 3B               27 3A                                27 00
'和"             28  27              28  22                                28  00
\和|             2B  5C              2B  7C      2B 1C                2B  00
,和<            33  2C              33  3C                                33  00
.和>            34  2E               34  3E                                34  00
/和?            35  2F                35  3F                               35  00
斜线(/)        E0  2F                E0  2F      95 00                A4  00
Del             53  E0                53  E0      93 E0                A3  00
下箭头        50  E0                50  E0      91 E0                A0  00
End             4F E0                4F  E0      75 E0                 9F  00
Enter          E0 0D                E0  0D     E0  0A                A6  00
Home         47 E0                47  E0      77  E0                97  00
Ins              52 E0                 52 E0      92  E0                A2  00
左箭头        4B E0                 4B E0      73  E0                9B  00
PageDown 51 E0                51 E0       76  E0                A1  00
PageUp      49 E0                49 E0       84  E0                99  00
右箭头         4D E0               4D E0      74  E0                9D  00
上箭头         48 E0                48 E0      8D  E0                98  00
尽管BIOS不会将其送入键盘缓冲区，以下的控制键也有定义好的扫描码：
CapsLock         3A
Shift（右）       36
NumLock         45
Alt                    38
ScrollLock         46
Ctrl                   1D
Shift（左）       2A
PrtScreen         37
